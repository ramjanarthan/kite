
    # Print test summary
    _ = calculate_and_print_report(wav_filenames, ground_truths, predictions, losses, args.csv)

    if args.dump:
        with open(args.dump + '.txt', 'w') as ftxt, open(args.dump + '.out', 'w') as fout:
            for wav, txt, out in zip(wavlist, ground_truths, predictions):
                ftxt.write('%s %s\n' % (wav, txt))
                fout.write('%s %s\n' % (wav, out))
            print('Reference texts dumped to %s.txt' % args.dump)
            print('Transcription   dumped to %s.out' % args.dump)

def parse_args():
    parser = argparse.ArgumentParser(description='Computing TFLite accuracy')
    parser.add_argument('--model', required=True,
                        help='Path to the model (protocol buffer binary file)')
    parser.add_argument('--scorer', required=True,
                        help='Path to the external scorer file')
    parser.add_argument('--csv', required=True,
                        help='Path to the CSV source file')
    parser.add_argument('--proc', required=False, default=cpu_count(), type=int,
                        help='Number of processes to spawn, defaulting to number of CPUs')
    parser.add_argument('--dump', required=False,
                        help='Path to dump the results as text file, with one line for each wav: "wav transcription".')
    args, unknown = parser.parse_known_args()
    # Reconstruct argv for absl.flags
    sys.argv = [sys.argv[0]] + unknown
    return args

if __name__ == '__main__':
    create_flags()
    absl.app.run(partial(main, parse_args()))
# -*- coding: utf-8 -*-
#
# DeepSpeech documentation build configuration file, created by
# sphinx-quickstart on Thu Feb  2 21:20:39 2017.
#
# This file is execfile()d with the current directory set to its
# containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#

# pylint: skip-file

import os
import sys

sys.path.insert(0, os.path.abspath('../'))

autodoc_mock_imports = ['deepspeech']

# This is in fact only relevant on ReadTheDocs, but we want to run the same way
# on our CI as in RTD to avoid regressions on RTD that we would not catch on CI
import subprocess
parent = subprocess.check_output("cd ../ && pwd", shell=True).decode().strip()
os.environ["PATH"] = os.path.join(parent, 'node_modules', '.bin') + ':' + os.environ["PATH"]
subprocess.check_call('cd ../ && npm install typedoc@0.17.4 typescript@3.8.3 @types/node@13.9.x', shell=True)
subprocess.check_call('env', shell=True)
subprocess.check_call('which typedoc', shell=True)
subprocess.check_call('cd ../ && doxygen doc/doxygen-c.conf', shell=True)
subprocess.check_call('cd ../ && doxygen doc/doxygen-java.conf', shell=True)
subprocess.check_call('cd ../ && doxygen doc/doxygen-dotnet.conf', shell=True)

# -- General configuration ------------------------------------------------

import semver

# -- Project information -----------------------------------------------------

project = u'Mozilla DeepSpeech'
copyright = '2016-2020 Mozilla Corporation, 2020 DeepSpeech authors'
author = 'DeepSpeech authors'

with open('../VERSION', 'r') as ver:
    v = ver.read().strip()
vv = semver.parse(v)

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
# The short X.Y version
version = '{}.{}'.format(vv['major'], vv['minor'])
# The full version, including alpha/beta/rc tags
release = v

# If your documentation needs a minimal Sphinx version, state it here.
#
# needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be
# extensions coming with Sphinx (named 'sphinx.ext.*') or your custom
