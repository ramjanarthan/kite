^include string$^include vector$^include fstream$^include unorderedset$^include iostream$^using namespace std$^$^include absltypesoptional.h$^include boostprogramoptions.hpp$^$^include ctcdecodedecoderutils.h$^include ctcdecodescorer.h$^include alphabet.h$^include deepspeech.h$^$^namespace po  boostprogramoptions$^$^int$^createpackageabsloptionalstring alphabetpath$^               string lmpath$^               string vocabpath$^               string packagepath$^               absloptionalbool forcebytesoutputmode$^               float defaultalpha$^               float defaultbeta$^$^     read vocabulary$^    unorderedsetstring words$^    bool vocablookscharbased  true$^    ifstream finvocabpath$^    if fin $^        cerr  invalid vocabulary file   vocabpath  n$^        return 0$^    $^    string word$^    while fin  word $^        words.insertword$^        if getutf0strlenword  0 $^            vocablookscharbased  false$^        $^    $^    cerr  words.size   unique words read from vocabulary file.n$^          vocablookscharbased  looks  doesnt look$^           like a character based bytes are all you need model.n$^$^    if forcebytesoutputmode.hasvalue $^        forcebytesoutputmode  vocablookscharbased$^        cerr  forcebytesoutputmode was not specified using value $^              infered from vocabulary contents $^              vocablookscharbased  true  false  n$^    $^$^    if forcebytesoutputmode.value  alphabetpath.hasvalue $^        cerr  no alphabet file specified not using bytes output mode cant continue.n$^        return 0$^    $^$^    scorer scorer$^    if forcebytesoutputmode.value $^        scorer.setalphabetutf0alphabet$^     else $^        alphabet alphabet$^        alphabet.initalphabetpathcstr$^        scorer.setalphabetalphabet$^    $^    scorer.setutf0modeforcebytesoutputmode.value$^    scorer.resetparamsdefaultalpha defaultbeta$^    int err  scorer.loadlmlmpath$^    if err  dserrscorernotrie $^        cerr  error loading language model file $^              err  dserrscorerunreadable  cant open binary lm file.  dserrorcodetoerrormessageerr$^              n$^        return 0$^    $^    scorer.filldictionarywords$^$^     copy lm file to final package file destination$^    $^        ifstream lmsrclmpath stdiosbinary$^        ofstream packagedestpackagepath stdiosbinary$^        packagedest  lmsrc.rdbuf$^    $^$^     save dictionary to package file appending instead of overwriting$^    if scorer.savedictionarypackagepath true $^        cerr  error when saving package in   packagepath  .n$^        return 0$^    $^$^    cerr  package created in   packagepath  .n$^    return 0$^$^$^int$^mainint argc char argv$^$^    pooptionsdescription descoptions$^    desc.addoptions$^        help show help message$^        alphabet povaluestring path of alphabet file to use for vocabulary construction. words with characters not in the alphabet will not be included in the vocabulary. optional if using bytes output mode.$^        lm povaluestring path of kenlm binary lm file. must be built without including the vocabulary use the v flag. see generatelm.py for how to create a binary lm.$^        vocab povaluestring path of vocabulary file. must contain words separated by whitespace.$^        package povaluestring path to save scorer package.$^        defaultalpha povaluefloat default value of alpha hyperparameter float.$^        defaultbeta povaluefloat default value of beta hyperparameter float.$^        forcebytesoutputmode povaluebool boolean flag force set or unset bytes output mode in the scorer package. if not set infers from the vocabulary. see httpsdeepspeech.readthedocs.ioenmasterdecoder.htmlbytesoutputmode for further explanation.$^    $^$^    povariablesmap vm$^    postorepoparsecommandlineargc argv desc vm$^    ponotifyvm$^$^    if vm.counthelp $^        cout  desc  n$^        return 0$^    $^$^     check required flags.$^    for const string flag  lm vocab package defaultalpha defaultbeta $^        if vm.countflag $^            cerr    flag   is a required flag. pass help for help.n$^            return 0$^        $^    $^$^     parse optional forcebytesoutputmode$^    absloptionalbool forcebytesoutputmode  abslnullopt$^    if vm.countforcebytesoutputmode $^        forcebytesoutputmode  vmforcebytesoutputmode.asbool$^    $^$^     parse optional alphabet$^    absloptionalstring alphabet  abslnullopt$^    if vm.countalphabet $^        alphabet  vmalphabet.asstring$^    $^$^    createpackagealphabet$^                   vmlm.asstring$^                   vmvocab.asstring$^                   vmpackage.asstring$^                   forcebytesoutputmode$^                   vmdefaultalpha.asfloat$^                   vmdefaultbeta.asfloat$^$^    return 0$^$^include string$^include vector$^include iostream$^include fstream$^$^include lmenumeratevocab.hh$^include lmvirtualinterface.hh$^include lmwordindex.hh$^include lmmodel.hh$^$^const stdstring starttoken  s$^const stdstring unktoken  unk$^const stdstring endtoken  s$^$^ implement a callback to retrieve the dictionary of language model.$^class retrievestrenumeratevocab  public lmenumeratevocab$^$^public$^  retrievestrenumeratevocab $^$^  void addlmwordindex index const stringpiece str $^    vocabulary.pushbackstdstringstr.data str.length$^  $^$^  stdvectorstdstring vocabulary$^$^$^int mainint argc char argv$^$^  if argc  0 $^    stdcerr  usage   argv0   kenlmmodel outputpath  stdendl$^    return 0$^  $^$^  const char kenlmmodel  argv0$^  const char outputpath  argv0$^$^  stduniqueptrlmbasemodel languagemodel$^  lmngramconfig config$^  retrievestrenumeratevocab enumerate$^  config.enumeratevocab  enumerate$^  languagemodel.resetlmngramloadvirtualkenlmmodel config$^$^  stdofstream foutoutputpath$^  for const stdstring word  enumerate.vocabulary $^    fout  word  n$^  $^$^  return 0$^$^include pathtrie.h$^$^include algorithm$^include limits$^include memory$^include utility$^include vector$^$^include decoderutils.h$^$^pathtriepathtrie $^  logprobbprev  numfltinf$^  logprobnbprev  numfltinf$^  logprobbcur  numfltinf$^  logprobnbcur  numfltinf$^  logprobc  numfltinf$^  score  numfltinf$^$^  root  0$^  character  root$^  exists  true$^  parent  nullptr$^$^  dictionary  nullptr$^  dictionarystate  0$^  hasdictionary  false$^$^  matcher  nullptr$^$^$^pathtriepathtrie $^  for auto child  children $^    delete child.second$^  $^$^$^pathtrie pathtriegetpathtrieunsigned int newchar float curlogprobc bool reset $^  auto child  children.begin$^  for  child  children.end child $^    if childfirst  newchar $^      break$^    $^  $^  if child  children.end $^    if childsecondexists $^      childsecondexists  true$^      childsecondlogprobbprev  numfltinf$^      childsecondlogprobnbprev  numfltinf$^      childsecondlogprobbcur  numfltinf$^      childsecondlogprobnbcur  numfltinf$^    $^    return childsecond$^   else $^    if hasdictionary $^      matchersetstatedictionarystate$^      bool found  matcherfindnewchar  0$^      if found $^         adding this character causes word outside dictionary$^        auto fstzero  fsttropicalweightzero$^        auto finalweight  dictionaryfinaldictionarystate$^        bool isfinal  finalweight  fstzero$^        if isfinal  reset $^          dictionarystate  dictionarystart$^        $^        return nullptr$^       else $^        pathtrie newpath  new pathtrie$^        newpathcharacter  newchar$^        newpathparent  this$^        newpathdictionary  dictionary$^        newpathhasdictionary  true$^        newpathmatcher  matcher$^        newpathlogprobc  curlogprobc$^$^         set spell checker state$^         check to see if next state is final$^        auto fstzero  fsttropicalweightzero$^        auto finalweight  dictionaryfinalmatchervalue.nextstate$^        bool isfinal  finalweight  fstzero$^        if isfinal  reset $^           restart spell checker at the start state$^          newpathdictionarystate  dictionarystart$^         else $^           go to next state$^          newpathdictionarystate  matchervalue.nextstate$^        $^$^        children.pushbackstdmakepairnewchar newpath$^        return newpath$^      $^     else $^      pathtrie newpath  new pathtrie$^      newpathcharacter  newchar$^      newpathparent  this$^      newpathlogprobc  curlogprobc$^      children.pushbackstdmakepairnewchar newpath$^      return newpath$^    $^  $^$^$^void pathtriegetpathvecstdvectorunsigned int output $^   recursive call recurse back until stop condition then append data in$^   correct order as we walk back down the stack in the lines below.$^  if parent  nullptr $^    parentgetpathvecoutput$^  $^  if character  root $^    output.pushbackcharacter$^  $^$^$^pathtrie pathtriegetprevgraphemestdvectorunsigned int output$^                                      const alphabet alphabet$^$^  pathtrie stop  this$^  if character  root $^    return stop$^  $^   recursive call recurse back until stop condition then append data in$^   correct order as we walk back down the stack in the lines below.$^  if byteiscodepointboundaryalphabet.decodesinglecharacter0 $^    stop  parentgetprevgraphemeoutput alphabet$^  $^  output.pushbackcharacter$^  return stop$^$^$^int pathtriedistancetocodepointboundaryunsigned char firstbyte$^                                             const alphabet alphabet$^$^  if byteiscodepointboundaryalphabet.decodesinglecharacter0 $^    firstbyte  unsigned charcharacter  0$^    return 0$^  $^  if parent  nullptr  parentcharacter  root $^    return 0  parentdistancetocodepointboundaryfirstbyte alphabet$^  $^  assertfalse  unreachable$^  return 0$^$^$^pathtrie pathtriegetprevwordstdvectorunsigned int output$^                                  const alphabet alphabet$^$^  pathtrie stop  this$^  if character  alphabet.getspacelabel  character  root $^    return stop$^  $^   recursive call recurse back until stop condition then append data in$^   correct order as we walk back down the stack in the lines below.$^  if parent  nullptr $^    stop  parentgetprevwordoutput alphabet$^  $^  output.pushbackcharacter$^  return stop$^$^$^void pathtrieiteratetovecstdvectorpathtrie output $^   previoustimesteps might point to ancestors timesteps$^   therefore children must be uptaded first$^  for auto child  children $^    child.seconditeratetovecoutput$^  $^  if exists $^    logprobbprev  logprobbcur$^    logprobnbprev  logprobnbcur$^$^    logprobbcur  numfltinf$^    logprobnbcur  numfltinf$^$^    score  logsumexplogprobbprev logprobnbprev$^$^    if previoustimesteps  nullptr $^      timesteps  nullptr$^      for auto const child  previoustimestepschildren $^        if childdata  newtimestep $^            timesteps  child.get$^            break$^        $^      $^      if timesteps  nullptr $^          timesteps  addchildprevioustimesteps newtimestep$^      $^    $^    previoustimesteps  nullptr$^$^    output.pushbackthis$^  $^$^$^void pathtrieremove $^  exists  false$^$^  if children.size  0 $^    for auto child  parentchildren.begin child  parentchildren.end child $^      if childfirst  character $^        parentchildren.erasechild$^        break$^      $^    $^$^    if parentchildren.size  0  parentexists $^      parentremove$^    $^$^    delete this$^  $^$^$^void pathtriesetdictionarystdsharedptrpathtriefsttype dictionary $^  dictionary  dictionary$^  dictionarystate  dictionarystart$^  hasdictionary  true$^$^$^void pathtriesetmatcherstdsharedptrfstsortedmatcherfsttype matcher $^  matcher  matcher$^$^$^ifdef debug$^void pathtrievecstdvectorpathtrie out $^  if parent  nullptr $^    parentvecout$^  $^  out.pushbackthis$^$^$^void pathtrieprintconst alphabet a $^  stdvectorpathtrie chain$^  vecchain$^  stdstring tr$^  printfcharacterst $^  for pathtrie el  chain $^    printfx  unsigned charelcharacter$^    if elcharacter  root $^      tr.appenda.decodesingleelcharacter$^    $^  $^  printfntimestepst $^  for unsigned int timestep  gethistorytimesteps $^    printfd  timestep$^  $^  printfn$^  printftranscriptt sn tr.cstr$^$^endif  debug$^include decoderutils.h$^$^include algorithm$^include cmath$^include limits$^$^stdvectorstdpairsizet float getprunedlogprobs$^    const double probstep$^    sizet classdim$^    double cutoffprob$^    sizet cutofftopn $^  stdvectorstdpairint double probidx$^  for sizet i  0 i  classdim i $^    probidx.pushbackstdpairint doublei probstepi$^  $^   pruning of vacobulary$^  sizet cutofflen  classdim$^  if cutoffprob  0.0  cutofftopn  cutofflen $^    stdsort$^        probidx.begin probidx.end paircompsecondrevint double$^    if cutoffprob  0.0 $^      double cumprob  0.0$^      cutofflen  0$^      for sizet i  0 i  probidx.size i $^        cumprob  probidxi.second$^        cutofflen  0$^        if cumprob  cutoffprob  cutofflen  cutofftopn break$^      $^    $^    probidx  stdvectorstdpairint double$^        probidx.begin probidx.begin  cutofflen$^  $^  stdvectorstdpairsizet float logprobidx$^  for sizet i  0 i  cutofflen i $^    logprobidx.pushbackstdpairint float$^        probidxi.first logprobidxi.second  numfltmin$^  $^  return logprobidx$^$^$^sizet getutf0strlenconst stdstring str $^  sizet strlen  0$^  for char c  str $^    strlen  c  0xc0  0x00$^  $^  return strlen$^$^$^stdvectorstdstring splitintocodepointsconst stdstring str $^  stdvectorstdstring result$^  stdstring outstr$^$^  for char c  str $^    if byteiscodepointboundaryc $^      if outstr.empty $^        result.pushbackoutstr$^        outstr.clear$^      $^    $^$^    outstr.append0 c$^  $^  result.pushbackoutstr$^  return result$^$^$^stdvectorstdstring splitintobytesconst stdstring str $^  stdvectorstdstring result$^$^  for char c  str $^    stdstring ch0 c$^    result.pushbackch$^  $^$^  return result$^$^$^stdvectorstdstring splitstrconst stdstring s$^                                   const stdstring delim $^  stdvectorstdstring result$^  stdsizet start  0 delimlen  delim.size$^  while true $^    stdsizet end  s.finddelim start$^    if end  stdstringnpos $^      if start  s.size $^        result.pushbacks.substrstart$^      $^      break$^    $^    if end  start $^      result.pushbacks.substrstart end  start$^    $^    start  end  delimlen$^  $^  return result$^$^$^bool prefixcompareconst pathtrie x const pathtrie y $^  if xscore  yscore $^    if xcharacter  ycharacter $^      return false$^     else $^      return xcharacter  ycharacter$^    $^   else $^    return xscore  yscore$^  $^$^$^bool prefixcompareexternalconst pathtrie x const pathtrie y const stdunorderedmapconst pathtrie float scores $^  if scores.atx  scores.aty $^    if xcharacter  ycharacter $^      return false$^     else $^      return xcharacter  ycharacter$^    $^   else $^    return scores.atx  scores.aty$^  $^$^$^void addwordtofstconst stdvectorunsigned int word$^                     fststdvectorfst dictionary $^  if dictionarynumstates  0 $^    fststdvectorfststateid start  dictionaryaddstate$^    assertstart  0$^    dictionarysetstartstart$^  $^  fststdvectorfststateid src  dictionarystart$^  fststdvectorfststateid dst$^  for auto c  word $^    dst  dictionaryaddstate$^    dictionaryaddarcsrc fststdarcc c 0 dst$^    src  dst$^  $^  dictionarysetfinaldst fststdarcweightone$^$^$^bool addwordtodictionary$^    const stdstring word$^    const stdunorderedmapstdstring int charmap$^    bool utf0$^    int spaceid$^    fststdvectorfst dictionary $^  auto characters  utf0  splitintobytesword  splitintocodepointsword$^$^  stdvectorunsigned int intword$^$^  for auto c  characters $^    auto intc  charmap.findc$^    if intc  charmap.end $^      intword.pushbackintcsecond$^     else $^      return false   return without adding$^    $^  $^$^  if utf0 $^    intword.pushbackspaceid$^  $^$^  addwordtofstintword dictionary$^  return true   return with successful adding$^ifdef mscver$^  include stdlib.h$^  include io.h$^  include windows.h $^$^  define rok    0        read permission.  $^  define wok    0        write permission.   $^  define fok    0        existence.  $^$^  define access access$^$^else           mscver  $^  include unistd.h$^endif$^$^include scorer.h$^include iostream$^include fstream$^$^include lmconfig.hh$^include lmmodel.hh$^include lmstate.hh$^include utilstringpiece.hh$^$^include decoderutils.h$^$^static const int00t magic  trie$^static const int00t fileversion  0$^$^int$^scorerinitconst stdstring lmpath$^             const alphabet alphabet$^$^  setalphabetalphabet$^  return loadlmlmpath$^$^$^int$^scorerinitconst stdstring lmpath$^             const stdstring alphabetconfigpath$^$^  int err  alphabet.initalphabetconfigpath.cstr$^  if err  0 $^    return err$^  $^  setupcharmap$^  return loadlmlmpath$^$^$^void$^scorersetalphabetconst alphabet alphabet$^$^  alphabet  alphabet$^  setupcharmap$^$^$^void scorersetupcharmap$^$^   reinitialize character map$^  charmap.clear$^$^  spaceid  alphabet.getspacelabel$^$^  for int i  0 i  alphabet.getsize i $^     the initial state of fst is state 0 hence the index of chars in$^     the fst should start from 0 to avoid the conflict with the initial$^     state otherwise wrong decoding results would be given.$^    charmapalphabet.decodesinglei  i  0$^  $^$^$^int scorerloadlmconst stdstring lmpath$^$^   check if file is readable to avoid kenlm throwing an exception$^  const char filename  lmpath.cstr$^  if accessfilename rok  0 $^    return dserrscorerunreadable$^  $^$^   check if the file format is valid to avoid kenlm throwing an exception$^  lmngrammodeltype modeltype$^  if lmngramrecognizebinaryfilename modeltype $^    return dserrscorerinvalidlm$^  $^$^   load the lm$^  lmngramconfig config$^  config.loadmethod  utilloadmethodlazy$^  languagemodel.resetlmngramloadvirtualfilename config$^  maxorder  languagemodelorder$^$^  uint00t packagesize$^  $^    utilscopedfd fdutilopenreadorthrowfilename$^    packagesize  utilsizefilefd.get$^  $^  uint00t trieoffset  languagemodelgetendofsearchoffset$^  if packagesize  trieoffset $^     file ends without a trie structure$^    return dserrscorernotrie$^  $^$^   read metadata and trie from file$^  stdifstream finlmpath stdiosbinary$^  fin.seekgtrieoffset$^  return loadtriefin lmpath$^$^$^int scorerloadtriestdifstream fin const stdstring filepath$^$^  int magic$^  fin.readreinterpretcastcharmagic sizeofmagic$^  if magic  magic $^    stdcerr  error cant parse scorer file invalid header. try updating $^                 your scorer file.  stdendl$^    return dserrscorerinvalidtrie$^  $^$^  int version$^  fin.readreinterpretcastcharversion sizeofversion$^  if version  fileversion $^    stdcerr  error scorer file version mismatch   version$^                instead of expected   fileversion$^               . $^    if version  fileversion $^      stdcerr  update your scorer file.$^     else $^      stdcerr  downgrade your scorer file or update your version of deepspeech.$^    $^    stdcerr  stdendl$^    return dserrscorerversionmismatch$^  $^$^  fin.readreinterpretcastcharisutf0mode sizeofisutf0mode$^$^   read hyperparameters from header$^  double alpha beta$^  fin.readreinterpretcastcharalpha sizeofalpha$^  fin.readreinterpretcastcharbeta sizeofbeta$^  resetparamsalpha beta$^$^  fstfstreadoptions opt$^  opt.mode  fstfstreadoptionsmap$^  opt.source  filepath$^  dictionary.resetfsttypereadfin opt$^  return dserrok$^$^$^bool scorersavedictionaryconst stdstring path bool appendinsteadofoverwrite$^$^  stdiosopenmode om$^  if appendinsteadofoverwrite $^    om  stdiosinstdiosoutstdiosbinarystdiosate$^   else $^    om  stdiosoutstdiosbinary$^  $^  stdfstream foutpath om$^  if fout fout.bad $^    stdcerr  error opening   path    stdendl$^    return false$^  $^  fout.writereinterpretcastconst charmagic sizeofmagic$^  if fout.bad $^    stdcerr  error writing magic   path    stdendl$^    return false$^  $^  fout.writereinterpretcastconst charfileversion sizeoffileversion$^  if fout.bad $^    stdcerr  error writing fileversion   path    stdendl$^    return false$^  $^  fout.writereinterpretcastconst charisutf0mode sizeofisutf0mode$^  if fout.bad $^    stdcerr  error writing isutf0mode   path    stdendl$^    return false$^  $^  fout.writereinterpretcastconst charalpha sizeofalpha$^  if fout.bad $^    stdcerr  error writing alpha   path    stdendl$^    return false$^  $^  fout.writereinterpretcastconst charbeta sizeofbeta$^  if fout.bad $^    stdcerr  error writing beta   path    stdendl$^    return false$^  $^  fstfstwriteoptions opt$^  opt.align  true$^  opt.source  path$^  return dictionarywritefout opt$^$^$^bool scorerisscoringboundarypathtrie prefix sizet newlabel$^$^  if isutf0mode $^    if prefixcharacter  0 $^      return false$^    $^    unsigned char firstbyte$^    int distancetoboundary  prefixdistancetocodepointboundaryfirstbyte alphabet$^    int neededbytes$^    if firstbyte  0  0x0e $^      neededbytes  0$^     else if firstbyte  0  0x0e $^      neededbytes  0$^     else if firstbyte  0  0x00 $^      neededbytes  0$^     else if firstbyte  0  0x00 $^      neededbytes  0$^     else $^      assertfalse  invalid byte sequence. should be unreachable disallowed by vocabularytrie$^      return false$^    $^    return distancetoboundary  neededbytes$^   else $^    return newlabel  spaceid$^  $^$^$^double scorergetlogcondprobconst stdvectorstdstring words$^                                 bool bos$^                                 bool eos$^$^  return getlogcondprobwords.begin words.end bos eos$^$^$^double scorergetlogcondprobconst stdvectorstdstringconstiterator begin$^                                 const stdvectorstdstringconstiterator end$^                                 bool bos$^                                 bool eos$^$^  const auto vocab  languagemodelbasevocabulary$^  lmngramstate statevec0$^  lmngramstate instate  statevec0$^  lmngramstate outstate  statevec0$^$^  if bos $^    languagemodelbeginsentencewriteinstate$^   else $^    languagemodelnullcontextwriteinstate$^  $^$^  double condprob  0.0$^  for auto it  begin it  end it $^    lmwordindex wordindex  vocab.indexit$^$^     encounter oov$^    if wordindex  lmkunk $^      return oovscore$^    $^$^    condprob  languagemodelbasescoreinstate wordindex outstate$^    stdswapinstate outstate$^  $^$^  if eos $^    condprob  languagemodelbasescoreinstate vocab.endsentence outstate$^  $^$^   return loge prob$^  return condprobnumfltloge$^$^$^void scorerresetparamsfloat alpha float beta$^$^  thisalpha  alpha$^  thisbeta  beta$^$^$^stdvectorstdstring scorersplitlabelsintoscoredunitsconst stdvectorunsigned int labels$^$^  if labels.empty return $^$^  stdstring s  alphabet.decodelabels$^  stdvectorstdstring words$^  if isutf0mode $^    words  splitintocodepointss$^   else $^    words  splitstrs  $^  $^  return words$^$^$^stdvectorstdstring scorermakengrampathtrie prefix$^$^  stdvectorstdstring ngram$^  pathtrie currentnode  prefix$^  pathtrie newnode  nullptr$^$^  for int order  0 order  maxorder order $^    if currentnode  currentnodecharacter  0 $^      break$^    $^$^    stdvectorunsigned int prefixvec$^$^    if isutf0mode $^      newnode  currentnodegetprevgraphemeprefixvec alphabet$^     else $^      newnode  currentnodegetprevwordprefixvec alphabet$^    $^    currentnode  newnodeparent$^$^     reconstruct word$^    stdstring word  alphabet.decodeprefixvec$^    ngram.pushbackword$^  $^  stdreversengram.begin ngram.end$^  return ngram$^$^$^void scorerfilldictionaryconst stdunorderedsetstdstring vocabulary$^$^   constfst is immutable so we need to use a mutablefst to create the trie$^   and then we convert to a constfst for the decoder and for storing on disk.$^  fststdvectorfst dictionary$^   for each unigram convert to ints and put in trie$^  for const auto word  vocabulary $^    if word  starttoken  word  unktoken  word  endtoken $^      addwordtodictionaryword charmap isutf0mode spaceid  0 dictionary$^    $^  $^$^   simplify fst$^$^    this gets rid of epsilon transitions in the fst.$^    these are transitions that dont require a string input to be taken.$^    getting rid of them is necessary to make the fst deterministic but$^    can greatly increase the size of the fst$^   $^  fstrmepsilondictionary$^  stduniqueptrfststdvectorfst newdictnew fststdvectorfst$^$^   this makes the fst deterministic meaning for any string input theres$^    only one possible state the fst could be in.  it is assumed our$^    dictionary is deterministic when using it.$^    lest wed have to check for multiple transitions at each state$^   $^  fstdeterminizedictionary newdict.get$^$^   finds the simplest equivalent fst. this is unnecessary but decreases$^    memory usage of the dictionary$^   $^  fstminimizenewdict.get$^$^   now we convert the mutablefst to a constfst scorerfsttype via its ctor$^  stduniqueptrfsttype convertednew fsttypenewdict$^  thisdictionary  stdmoveconverted$^$^include iostream$^include vector$^include chrono$^$^include threadpool.h$^$^int main$^$^    $^    threadpool pool0$^    stdvector stdfutureint  results$^$^    forint i  0 i  0 i $^        results.emplaceback$^            pool.enqueuei $^                stdcout  hello   i  stdendl$^                stdthisthreadsleepforstdchronoseconds0$^                stdcout  world   i  stdendl$^                return ii$^            $^        $^    $^$^    forauto  result results$^        stdcout  result.get   $^    stdcout  stdendl$^    $^    return 0$^$^include ctcbeamsearchdecoder.h$^$^include algorithm$^include cmath$^include iostream$^include limits$^include unorderedmap$^include utility$^$^include decoderutils.h$^include threadpool.h$^include fstfstlib.h$^include pathtrie.h$^$^$^int$^decoderstateinitconst alphabet alphabet$^                   sizet beamsize$^                   double cutoffprob$^                   sizet cutofftopn$^                   stdsharedptrscorer extscorer$^                   stdunorderedmapstdstring float hotwords$^$^   assign special ids$^  abstimestep  0$^  spaceid  alphabet.getspacelabel$^  blankid  alphabet.getsize$^$^  beamsize  beamsize$^  cutoffprob  cutoffprob$^  cutofftopn  cutofftopn$^  extscorer  extscorer$^  hotwords  hotwords$^  startexpanding  false$^$^   init prefixes root$^  pathtrie root  new pathtrie$^  rootscore  rootlogprobbprev  0.0$^  prefixroot.resetroot$^  prefixroottimesteps  timesteptreeroot$^  prefixes.pushbackroot$^$^  if extscorer  boolextscorerdictionary $^     no need for stdmakeshared since copy does new behind the doors$^    auto dictptr  stdsharedptrpathtriefsttypeextscorerdictionarycopytrue$^    rootsetdictionarydictptr$^    auto matcher  stdmakesharedfstsortedmatcherpathtriefsttypedictptr fstmatchinput$^    rootsetmatchermatcher$^  $^$^  return 0$^$^$^void$^decoderstatenextconst double probs$^                   int timedim$^                   int classdim$^$^   prefix search over time$^  for sizet reltimestep  0 reltimestep  timedim reltimestep abstimestep $^    auto prob  probsreltimestepclassdim$^$^     at the start of the decoding process we delay beam expansion so that$^     timings on the first letters is not incorrect. as soon as we see a$^     timestep with blank probability lower than 0.000 we start expanding$^     beams.$^    if probblankid  0.000 $^      startexpanding  true$^    $^$^     if not expanding yet just continue to next timestep.$^    if startexpanding $^      continue$^    $^$^    float mincutoff  numfltinf$^    bool fullbeam  false$^    if extscorer $^      sizet numprefixes  stdminprefixes.size beamsize$^      stdpartialsortprefixes.begin$^                        prefixes.begin  numprefixes$^                        prefixes.end$^                        prefixcompare$^$^      mincutoff  prefixesnumprefixes  0score $^                   stdlogprobblankid  stdmax0.0 extscorerbeta$^      fullbeam  numprefixes  beamsize$^    $^$^    stdvectorstdpairsizet float logprobidx $^        getprunedlogprobsprob classdim cutoffprob cutofftopn$^     loop over class dim$^    for sizet index  0 index  logprobidx.size index $^      auto c  logprobidxindex.first$^      auto logprobc  logprobidxindex.second$^$^      for sizet i  0 i  prefixes.size  i  beamsize i $^        auto prefix  prefixesi$^        if fullbeam  logprobc  prefixscore  mincutoff $^          break$^        $^        if prefixscore  numfltinf $^          continue$^        $^        assertprefixtimesteps  nullptr$^$^         blank$^        if c  blankid $^           compute probability of current path$^          float logp  logprobc  prefixscore$^$^           combine current path with previous ones with the same prefix$^           the blank label comes last so we can compare logprobnbcur with logp$^          if prefixlogprobnbcur  logp $^             keep current timesteps$^            prefixprevioustimesteps  nullptr$^          $^          prefixlogprobbcur $^              logsumexpprefixlogprobbcur logp$^          continue$^        $^$^         repeated character$^        if c  prefixcharacter $^           compute probability of current path$^          float logp  logprobc  prefixlogprobnbprev$^$^           combine current path with previous ones with the same prefix$^          if prefixlogprobnbcur  logp $^             keep current timesteps$^            prefixprevioustimesteps  nullptr$^          $^          prefixlogprobnbcur  logsumexp$^              prefixlogprobnbcur logp$^        $^$^         get new prefix$^        auto prefixnew  prefixgetpathtriec logprobc$^$^        if prefixnew  nullptr $^           compute probability of current path$^          float logp  numfltinf$^$^          if c  prefixcharacter $^              prefixlogprobbprev  numfltinf $^            logp  logprobc  prefixlogprobbprev$^           else if c  prefixcharacter $^            logp  logprobc  prefixscore$^          $^$^          if extscorer $^             skip scoring the space in word based lms$^            pathtrie prefixtoscore$^            if extscorerisutf0mode $^              prefixtoscore  prefixnew$^             else $^              prefixtoscore  prefix$^            $^$^             language model scoring$^            if extscorerisscoringboundaryprefixtoscore c $^              float score  0.0$^              stdvectorstdstring ngram$^              ngram  extscorermakengramprefixtoscore$^$^              float hotboost  0.0$^              if hotwords.empty $^                stdunorderedmapstdstring floatiterator iter$^                 increase prob of prefix for every word$^                 that matches a word in the hotwords list$^                for stdstring word  ngram $^                  iter  hotwords.findword$^                  if  iter  hotwords.end  $^                     increase the logcondprobprefixlm$^                    hotboost  itersecond$^                  $^                $^              $^$^              bool bos  ngram.size  extscorergetmaxorder$^              score   extscorergetlogcondprobngram bos  hotboost   extscoreralpha$^              logp  score$^              logp  extscorerbeta$^            $^          $^$^           combine current path with previous ones with the same prefix$^          if prefixnewlogprobnbcur  logp $^             record data needed to update timesteps$^             the actual update will be done if nothing better is found$^            prefixnewprevioustimesteps  prefixtimesteps$^            prefixnewnewtimestep  abstimestep$^          $^          prefixnewlogprobnbcur $^              logsumexpprefixnewlogprobnbcur logp$^        $^         end of loop over prefix$^         end of loop over alphabet$^$^     update log probs$^    prefixes.clear$^    prefixrootiteratetovecprefixes$^$^     only preserve top beamsize prefixes$^    if prefixes.size  beamsize $^      stdnthelementprefixes.begin$^                       prefixes.begin  beamsize$^                       prefixes.end$^                       prefixcompare$^      for sizet i  beamsize i  prefixes.size i $^        prefixesiremove$^      $^$^       remove the elements from stdvector$^      prefixes.resizebeamsize$^    $^     end of loop over time$^$^$^stdvectoroutput$^decoderstatedecodesizet numresults const$^$^  stdvectorpathtrie prefixescopy  prefixes$^  stdunorderedmapconst pathtrie float scores$^  for pathtrie prefix  prefixescopy $^    scoresprefix  prefixscore$^  $^$^   score the last word of each prefix that doesnt end with space$^  if extscorer $^    for sizet i  0 i  beamsize  i  prefixescopy.size i $^      pathtrie prefix  prefixescopyi$^      pathtrie prefixboundary  extscorerisutf0mode  prefix  prefixparent$^      if prefixboundary  extscorerisscoringboundaryprefixboundary prefixcharacter $^        float score  0.0$^        stdvectorstdstring ngram  extscorermakengramprefix$^        bool bos  ngram.size  extscorergetmaxorder$^        score  extscorergetlogcondprobngram bos  extscoreralpha$^        score  extscorerbeta$^        scoresprefix  score$^      $^    $^  $^$^  using namespace stdplaceholders$^  sizet numreturned  stdminprefixescopy.size numresults$^  stdpartialsortprefixescopy.begin$^                    prefixescopy.begin  numreturned$^                    prefixescopy.end$^                    stdbindprefixcompareexternal 0 0 scores$^$^  stdvectoroutput outputs$^  outputs.reservenumreturned$^$^  for sizet i  0 i  numreturned i $^    output output$^    prefixescopyigetpathvecoutput.tokens$^    output.timesteps   gethistoryprefixescopyitimesteps timesteptreeroot$^    assertoutput.tokens.size  output.timesteps.size$^    output.confidence  scoresprefixescopyi$^    outputs.pushbackoutput$^  $^$^  return outputs$^$^$^stdvectoroutput ctcbeamsearchdecoder$^    const double probs$^    int timedim$^    int classdim$^    const alphabet alphabet$^    sizet beamsize$^    double cutoffprob$^    sizet cutofftopn$^    stdsharedptrscorer extscorer$^    stdunorderedmapstdstring float hotwords$^    sizet numresults$^$^  validcheckeqalphabet.getsize0 classdim number of output classes in acoustic model does not match number of labels in the alphabet file. alphabet file must be the same one that was used to train the acoustic model.$^  decoderstate state$^  state.initalphabet beamsize cutoffprob cutofftopn extscorer hotwords$^  state.nextprobs timedim classdim$^  return state.decodenumresults$^$^$^stdvectorstdvectoroutput$^ctcbeamsearchdecoderbatch$^    const double probs$^    int batchsize$^    int timedim$^    int classdim$^    const int seqlengths$^    int seqlengthssize$^    const alphabet alphabet$^    sizet beamsize$^    sizet numprocesses$^    double cutoffprob$^    sizet cutofftopn$^    stdsharedptrscorer extscorer$^    stdunorderedmapstdstring float hotwords$^    sizet numresults$^$^  validcheckgtnumprocesses 0 numprocesses must be nonnegative$^  validcheckeqbatchsize seqlengthssize must have one sequence length per batch element$^   thread pool$^  threadpool poolnumprocesses$^$^   enqueue the tasks of decoding$^  stdvectorstdfuturestdvectoroutput res$^  for sizet i  0 i  batchsize i $^    res.emplacebackpool.enqueuectcbeamsearchdecoder$^                                  probsitimedimclassdim$^                                  seqlengthsi$^                                  classdim$^                                  alphabet$^                                  beamsize$^                                  cutoffprob$^                                  cutofftopn$^                                  extscorer$^                                  hotwords$^                                  numresults$^  $^$^   get decoding results$^  stdvectorstdvectoroutput batchresults$^  for sizet i  0 i  batchsize i $^    batchresults.emplacebackresi.get$^  $^  return batchresults$^$^include tfmodelstate.h$^$^include workspacestatus.h$^$^using namespace tensorflow$^using stdvector$^$^tfmodelstatetfmodelstate$^   modelstate$^   mmapenvnullptr$^   sessionnullptr$^$^$^$^tfmodelstatetfmodelstate$^$^  if session $^    status status  sessionclose$^    if status.ok $^      stdcerr  error closing tensorflow session   status  stdendl$^    $^  $^$^$^int$^tfmodelstateinitconst char modelpath$^$^  int err  modelstateinitmodelpath$^  if err  dserrok $^    return err$^  $^$^  status status$^  sessionoptions options$^$^  mmapenv.resetnew memmappedenvenvdefault$^$^  bool ismmap  stdstringmodelpath.find.pbmm  stdstringnpos$^  if ismmap $^    stdcerr  warning reading entire model file into memory. transform model file into an mmapped graph to reduce heap usage.  stdendl$^   else $^    status  mmapenvinitializefromfilemodelpath$^    if status.ok $^      stdcerr  status  stdendl$^      return dserrfailinitmmap$^    $^$^    options.config.mutablegraphoptions$^      mutableoptimizeroptions$^      setoptleveloptimizeroptionsl0$^    options.env  mmapenv.get$^  $^$^  session session$^  status  newsessionoptions session$^  if status.ok $^    stdcerr  status  stdendl$^    return dserrfailinitsess$^  $^  session.resetsession$^$^  if ismmap $^    status  readbinaryprotommapenv.get$^                             memmappedfilesystemkmemmappedpackagedefaultgraphdef$^                             graphdef$^   else $^    status  readbinaryprotoenvdefault modelpath graphdef$^  $^  if status.ok $^    stdcerr  status  stdendl$^    return dserrfailreadprotobuf$^  $^$^  status  sessioncreategraphdef$^  if status.ok $^    stdcerr  status  stdendl$^    return dserrfailcreatesess$^  $^$^  stdvectortensorflowtensor versionoutput$^  status  sessionrun $^    metadataversion$^    versionoutput$^  if status.ok $^    stdcerr  unable to fetch graph version   status  stdendl$^    return dserrmodelincompatible$^  $^$^  int graphversion  versionoutput0.scalarint$^  if graphversion  dsgraphversion $^    stdcerr  specified model file version   graphversion   is $^               incompatible with minimum version supported by this client $^               dsgraphversion  . see $^               httpsgithub.commozilladeepspeechblob$^               dsgitversion  docusing.rstmodelcompatibility $^               for more information  stdendl$^    return dserrmodelincompatible$^  $^$^  stdvectortensorflowtensor metadataoutputs$^  status  sessionrun $^    metadatasamplerate$^    metadatafeaturewinlen$^    metadatafeaturewinstep$^    metadatabeamwidth$^    metadataalphabet$^    metadataoutputs$^  if status.ok $^    stdcout  unable to fetch metadata   status  stdendl$^    return dserrmodelincompatible$^  $^$^  samplerate  metadataoutputs0.scalarint$^  int winlenms  metadataoutputs0.scalarint$^  int winstepms  metadataoutputs0.scalarint$^  audiowinlen  samplerate  winlenms  0000.0$^  audiowinstep  samplerate  winstepms  0000.0$^  int beamwidth  metadataoutputs0.scalarint$^  beamwidth  unsigned intbeamwidth$^$^  string serializedalphabet  metadataoutputs0.scalartensorflowtstring$^  err  alphabet.deserializeserializedalphabet.data serializedalphabet.size$^  if err  0 $^    return dserrinvalidalphabet$^  $^$^  assertsamplerate  0$^  assertaudiowinlen  0$^  assertaudiowinstep  0$^  assertbeamwidth  0$^  assertalphabet.getsize  0$^$^  for int i  0 i  graphdef.nodesize i $^    nodedef node  graphdef.nodei$^    if node.name  inputnode $^      const auto shape  node.attr.atshape.shape$^      nsteps  shape.dim0.size$^      ncontext  shape.dim0.size00$^      nfeatures  shape.dim0.size$^      mfccfeatspertimestep  shape.dim0.size  shape.dim0.size$^     else if node.name  previousstatec $^      const auto shape  node.attr.atshape.shape$^      statesize  shape.dim0.size$^     else if node.name  logitsshape $^      tensor logitsshape  tensordtint00 tensorshape0$^      if logitsshape.fromprotonode.attr.atvalue.tensor $^        continue$^      $^$^      int finaldimsize  logitsshape.vecint0  0$^      if finaldimsize  alphabet.getsize $^        stdcerr  error alphabet size does not match loaded model alphabet $^                   has size   alphabet.getsize$^                    but model has   finaldimsize$^                    classes in its output. make sure youre passing an alphabet $^                   file with the same size as the one used for training.$^                   stdendl$^        return dserrinvalidalphabet$^      $^    $^  $^$^  if ncontext  0  nfeatures  0 $^    stdcerr  error could not infer input shape from model file. $^               make sure inputnode is a 0d tensor with shape $^               batchsize0 time windowsize nfeatures.$^               stdendl$^    return dserrinvalidshape$^  $^$^  return dserrok$^$^$^tensor$^tensorfromvectorconst stdvectorfloat vec const tensorshape shape$^$^  tensor retdtfloat shape$^  auto retmapped  ret.flatfloat$^  int i$^  for i  0 i  vec.size i $^    retmappedi  veci$^  $^  for  i  shape.numelements i $^    retmappedi  0.f$^  $^  return ret$^$^$^void$^copytensortovectorconst tensor tensor vectorfloat vec int numelements  0$^$^  auto tensormapped  tensor.flatfloat$^  if numelements  0 $^    numelements  tensor.shape.numelements$^  $^  for int i  0 i  numelements i $^    vec.pushbacktensormappedi$^  $^$^$^void$^tfmodelstateinferconst stdvectorfloat mfcc$^                    unsigned int nframes$^                    const stdvectorfloat previousstatec$^                    const stdvectorfloat previousstateh$^                    vectorfloat logitsoutput$^                    vectorfloat statecoutput$^                    vectorfloat statehoutput$^$^  const sizet numclasses  alphabet.getsize  0  0 for blank$^$^  tensor input  tensorfromvectormfcc tensorshapebatchsize nsteps 0ncontext0 nfeatures$^  tensor previousstatect  tensorfromvectorpreviousstatec tensorshapebatchsize long longstatesize$^  tensor previousstateht  tensorfromvectorpreviousstateh tensorshapebatchsize long longstatesize$^$^  tensor inputlengthsdtint00 tensorshape0$^  inputlengths.scalarint  nframes$^$^  vectortensor outputs$^  status status  sessionrun$^    $^     inputnode input$^     inputlengths inputlengths$^     previousstatec previousstatect$^     previousstateh previousstateht$^    $^    logits newstatec newstateh$^    $^    outputs$^$^  if status.ok $^    stdcerr  error running session   status  n$^    return$^  $^$^  copytensortovectoroutputs0 logitsoutput nframes  batchsize  numclasses$^$^  statecoutput.clear$^  statecoutput.reservestatesize$^  copytensortovectoroutputs0 statecoutput$^$^  statehoutput.clear$^  statehoutput.reservestatesize$^  copytensortovectoroutputs0 statehoutput$^$^$^void$^tfmodelstatecomputemfccconst vectorfloat samples vectorfloat mfccoutput$^$^  tensor input  tensorfromvectorsamples tensorshapeaudiowinlen$^$^  vectortensor outputs$^  status status  sessionruninputsamples input mfccs  outputs$^$^  if status.ok $^    stdcerr  error running session   status  n$^    return$^  $^$^   the feature computation graph is hardcoded to one audio length for now$^  const int nwindows  0$^  assertoutputs0.shape.numelements  nfeatures  nwindows$^  copytensortovectoroutputs0 mfccoutput$^$^include alphabet.h$^include ctcdecodedecoderutils.h$^$^include fstream$^$^ stdgetline but handle newline conventions from multiple platforms instead$^ of just the platform this code was built for$^stdistream$^getlinecrossplatformstdistream is stdstring t$^$^  t.clear$^$^   the characters in the stream are read onebyone using a stdstreambuf.$^   that is faster than reading them onebyone using the stdistream.$^   code that uses streambuf this way must be guarded by a sentry object.$^   the sentry object performs various tasks$^   such as thread synchronization and updating the stream state.$^  stdistreamsentry seis true$^  stdstreambuf sb  is.rdbuf$^$^  while true $^    int c  sbsbumpc$^    switch c $^    case n$^      return is$^    case r$^      ifsbsgetc  n$^          sbsbumpc$^      return is$^    case stdstreambuftraitstypeeof$^       also handle the case when the last line has no line ending$^      ift.empty$^        is.setstatestdioseofbit$^      return is$^    default$^      t  charc$^    $^  $^$^$^int$^alphabetinitconst char configfile$^$^  stdifstream inconfigfile stdiosin$^  if in $^    return 0$^  $^  unsigned int label  0$^  spacelabel  0$^  for stdstring line getlinecrossplatformin line $^    if line.size  0  line0    line0   $^      line  $^     else if line0   $^      continue$^    $^    todo we should probably do something more i00naware here$^    if line    $^      spacelabel  label$^    $^    if line.length  0 $^      continue$^    $^    labeltostrlabel  line$^    strtolabelline  label$^    label$^  $^  size  label$^  in.close$^  return 0$^$^$^stdstring$^alphabetserialize$^$^   serialization format is a sequence of key value pairs where key is$^   a uint00t and value is a uint00t length followed by length utf0$^   encoded bytes with the label.$^  stdstringstream out$^$^   we start by writing the number of pairs in the buffer as uint00t.$^  uint00t size  size$^  out.writereinterpretcastcharsize sizeofsize$^$^  for auto it  labeltostr.begin it  labeltostr.end it $^    uint00t key  itfirst$^    string str  itsecond$^    uint00t len  str.length$^     then we write the key as uint00t followed by the length of the value$^     as uint00t followed by length bytes the value itself.$^    out.writereinterpretcastcharkey sizeofkey$^    out.writereinterpretcastcharlen sizeoflen$^    out.writestr.data len$^  $^$^  return out.str$^$^$^int$^alphabetdeserializeconst char buffer const int buffersize$^$^   see utiltext.py for an explanation of the serialization format.$^  int offset  0$^  if buffersize  offset  sizeofuint00t $^    return 0$^  $^  uint00t size  uint00tbuffer  offset$^  offset  sizeofuint00t$^  size  size$^$^  for int i  0 i  size i $^    if buffersize  offset  sizeofuint00t $^      return 0$^    $^    uint00t label  uint00tbuffer  offset$^    offset  sizeofuint00t$^$^    if buffersize  offset  sizeofuint00t $^      return 0$^    $^    uint00t vallen  uint00tbuffer  offset$^    offset  sizeofuint00t$^$^    if buffersize  offset  vallen $^      return 0$^    $^    stdstring valbufferoffset vallen$^    offset  vallen$^$^    labeltostrlabel  val$^    strtolabelval  label$^$^    if val    $^      spacelabel  label$^    $^  $^$^  return 0$^$^$^bool$^alphabetcanencodesingleconst stdstring input const$^$^  auto it  strtolabel.findinput$^  return it  strtolabel.end$^$^$^bool$^alphabetcanencodeconst stdstring input const$^$^  for auto cp  splitintocodepointsinput $^    if canencodesinglecp $^      return false$^    $^  $^  return true$^$^$^stdstring$^alphabetdecodesingleunsigned int label const$^$^  auto it  labeltostr.findlabel$^  if it  labeltostr.end $^    return itsecond$^   else $^    stdcerr  invalid label   label  stdendl$^    abort$^  $^$^$^unsigned int$^alphabetencodesingleconst stdstring string const$^$^  auto it  strtolabel.findstring$^  if it  strtolabel.end $^    return itsecond$^   else $^    stdcerr  invalid string   string  stdendl$^    abort$^  $^$^$^stdstring$^alphabetdecodeconst stdvectorunsigned int input const$^$^  stdstring word$^  for auto ind  input $^    word  decodesingleind$^  $^  return word$^$^$^stdstring$^alphabetdecodeconst unsigned int input int length const$^$^  stdstring word$^  for int i  0 i  length i $^    word  decodesingleinputi$^  $^  return word$^$^$^stdvectorunsigned int$^alphabetencodeconst stdstring input const$^$^  stdvectorunsigned int result$^  for auto cp  splitintocodepointsinput $^    result.pushbackencodesinglecp$^  $^  return result$^$^$^bool$^utf0alphabetcanencodesingleconst stdstring input const$^$^  return true$^$^$^bool$^utf0alphabetcanencodeconst stdstring input const$^$^  return true$^$^$^stdvectorunsigned int$^utf0alphabetencodeconst stdstring input const$^$^  stdvectorunsigned int result$^  for auto bytechar  input $^    stdstring bytestr0 bytechar$^    result.pushbackencodesinglebytestr$^  $^  return result$^$^include tflitemodelstate.h$^include tensorflowlitestringutil.h$^include workspacestatus.h$^$^ifdef android$^include androidlog.h$^define  logtag    libdeepspeech$^define  logd...  androidlogprintandroidlogdebug logtag vaargs$^define  loge...  androidlogprintandroidlogerror logtag vaargs$^else$^define  logd...$^define  loge...$^endif  android$^$^using namespace tflite$^using stdvector$^$^int$^tflitemodelstategettensorbynameconst vectorint list$^                                     const char name$^$^  int rv  0$^$^  for int i  0 i  list.size i $^    const string nodename  interpretertensorlistiname$^    if nodename.comparestringname  0 $^      rv  i$^    $^  $^$^  assertrv  0$^  return rv$^$^$^int$^tflitemodelstategetinputtensorbynameconst char name$^$^  int idx  gettensorbynameinterpreterinputs name$^  return interpreterinputsidx$^$^$^int$^tflitemodelstategetoutputtensorbynameconst char name$^$^  int idx  gettensorbynameinterpreteroutputs name$^  return interpreteroutputsidx$^$^$^void$^pushbackifnotpresentstddequeint list int value$^$^  if stdfindlist.begin list.end value  list.end $^    list.pushbackvalue$^  $^$^$^ backwards bfs on the node dag. at each iteration we get the next tensor id$^ from the frontier list then for each node which has that tensor id as an$^ output add it to the parent list and add its input tensors to the frontier$^ list. because we start from the final tensor and work backwards to the inputs$^ the parents list is constructed in reverse adding elements to its front.$^vectorint$^tflitemodelstatefindparentnodeidsint tensorid$^$^  stddequeint parents$^  stddequeint frontier$^  frontier.pushbacktensorid$^  while frontier.empty $^    int nexttensorid  frontier.front$^    frontier.popfront$^     find all nodes that have nexttensorid as an output$^    for int nodeid  0 nodeid  interpreternodessize nodeid $^      tflitenode node  interpreternodeandregistrationnodeidfirst$^       search node outputs for the tensor were looking for$^      for int i  0 i  node.outputssize i $^        if node.outputsdatai  nexttensorid $^           this node is part of the parent tree add it to the parent list and$^           add its input tensors to the frontier list$^          parents.pushfrontnodeid$^          for int j  0 j  node.inputssize j $^            pushbackifnotpresentfrontier node.inputsdataj$^          $^        $^      $^    $^  $^$^  return vectorintparents.begin parents.end$^$^$^tflitemodelstatetflitemodelstate$^   modelstate$^   interpreternullptr$^   fbmodelnullptr$^$^$^$^tflitemodelstatetflitemodelstate$^$^$^$^stdmapstdstring tfliteinterpretertflitedelegateptr$^gettflitedelegates$^$^  stdmapstdstring tfliteinterpretertflitedelegateptr delegates$^$^  const char envdelegatec  stdgetenvdstflitedelegate$^  stdstring envdelegate  envdelegatec  nullptr  envdelegatec  $^$^ifdef android$^  if envdelegate  stdstringgpu $^    logdtrying to get gpu delegate ...$^     try to get gpu delegate$^    $^      tfliteinterpretertflitedelegateptr delegate  evaluationcreategpudelegate$^      if delegate $^        logdgpu delegation not supported$^       else $^        logdgpu delegation supported$^        delegates.emplacegpu stdmovedelegate$^      $^    $^  $^$^  if envdelegate  stdstringnnapi $^    logdtrying to get nnapi delegate ...$^     try to get android nnapi delegate$^    $^      tfliteinterpretertflitedelegateptr delegate  evaluationcreatennapidelegate$^      if delegate $^        logdnnapi delegation not supported$^       else $^        logdnnapi delegation supported$^        delegates.emplacennapi stdmovedelegate$^      $^    $^  $^$^  if envdelegate  stdstringhexagon $^    logdtrying to get hexagon delegate ...$^     try to get android hexagon delegate$^    $^      const stdstring libhexagonpathdatalocaltmp$^      tfliteinterpretertflitedelegateptr delegate  evaluationcreatehexagondelegatelibhexagonpath  profiler  false$^      if delegate $^        logdhexagon delegation not supported$^       else $^        logdhexagon delegation supported$^        delegates.emplacehexagon stdmovedelegate$^      $^    $^  $^endif  android$^$^  return delegates$^$^$^int$^tflitemodelstateinitconst char modelpath$^$^  int err  modelstateinitmodelpath$^  if err  dserrok $^    return err$^  $^$^  fbmodel  tfliteflatbuffermodelbuildfromfilemodelpath$^  if fbmodel $^    stdcerr  error at reading model file   modelpath  stdendl$^    return dserrfailinitmmap$^  $^$^  tfliteopsbuiltinbuiltinopresolver resolver$^  tfliteinterpreterbuilderfbmodel resolverinterpreter$^  if interpreter $^    stdcerr  error at interpreterbuilder for model file   modelpath  stdendl$^    return dserrfailinterpreter$^  $^$^  logdtrying to detect delegates ...$^  stdmapstdstring tfliteinterpretertflitedelegateptr delegates  gettflitedelegates$^  logdfinished enumerating delegates ...$^$^  interpreterallocatetensors$^  interpretersetnumthreads0$^$^  logdtrying to use delegates ...$^  for const auto delegate  delegates $^    logdtrying to apply delegate s delegate.first.cstr$^    if interpretermodifygraphwithdelegatedelegate.second.get  ktfliteok $^      logdfailed to apply delegate s to the graph delegate.first.cstr$^    $^  $^$^   query all the index once$^  inputnodeidx        getinputtensorbynameinputnode$^  previousstatecidx  getinputtensorbynamepreviousstatec$^  previousstatehidx  getinputtensorbynamepreviousstateh$^  inputsamplesidx     getinputtensorbynameinputsamples$^  logitsidx            getoutputtensorbynamelogits$^  newstatecidx       getoutputtensorbynamenewstatec$^  newstatehidx       getoutputtensorbynamenewstateh$^  mfccsidx             getoutputtensorbynamemfccs$^$^  int metadataversionidx   getoutputtensorbynamemetadataversion$^  int metadatasamplerateidx       getoutputtensorbynamemetadatasamplerate$^  int metadatafeaturewinlenidx   getoutputtensorbynamemetadatafeaturewinlen$^  int metadatafeaturewinstepidx  getoutputtensorbynamemetadatafeaturewinstep$^  int metadatabeamwidthidx  getoutputtensorbynamemetadatabeamwidth$^  int metadataalphabetidx  getoutputtensorbynamemetadataalphabet$^$^  stdvectorint metadataexecplan$^  metadataexecplan.pushbackfindparentnodeidsmetadataversionidx0$^  metadataexecplan.pushbackfindparentnodeidsmetadatasamplerateidx0$^  metadataexecplan.pushbackfindparentnodeidsmetadatafeaturewinlenidx0$^  metadataexecplan.pushbackfindparentnodeidsmetadatafeaturewinstepidx0$^  metadataexecplan.pushbackfindparentnodeidsmetadatabeamwidthidx0$^  metadataexecplan.pushbackfindparentnodeidsmetadataalphabetidx0$^$^  for int i  0 i  metadataexecplan.size i $^    assertmetadataexecplani  0$^  $^$^   when we call interpreterinvoke the whole graph is executed by default$^   which means every time computemfcc is called the entire acoustic model is$^   also executed. to workaround that problem we walk up the dependency dag$^   from the mfccs output tensor to find all the relevant nodes required for$^   feature computation building an execution plan that runs just those nodes.$^  auto mfccplan  findparentnodeidsmfccsidx$^  auto origplan  interpreterexecutionplan$^$^   remove mfcc and metatda nodes from original plan all nodes to create the acoustic model plan$^  auto erasebegin  stdremoveiforigplan.begin origplan.end mfccplan metadataexecplanint elem $^    return stdfindmfccplan.begin mfccplan.end elem  mfccplan.end$^          stdfindmetadataexecplan.begin metadataexecplan.end elem  metadataexecplan.end$^  $^  origplan.eraseerasebegin origplan.end$^$^  acousticexecplan  stdmoveorigplan$^  mfccexecplan  stdmovemfccplan$^$^  interpretersetexecutionplanmetadataexecplan$^  tflitestatus status  interpreterinvoke$^  if status  ktfliteok $^    stdcerr  error running session   status  n$^    return dserrfailinterpreter$^  $^$^  int const graphversion  interpretertypedtensorintmetadataversionidx$^  if graphversion  nullptr $^    stdcerr  unable to read model file version.  stdendl$^    return dserrmodelincompatible$^  $^$^  if graphversion  dsgraphversion $^    stdcerr  specified model file version   graphversion   is $^               incompatible with minimum version supported by this client $^               dsgraphversion  . see $^               httpsgithub.commozilladeepspeechblob$^               dsgitversion  docusing.rstmodelcompatibility $^               for more information  stdendl$^    return dserrmodelincompatible$^  $^$^  int const modelsamplerate  interpretertypedtensorintmetadatasamplerateidx$^  if modelsamplerate  nullptr $^    stdcerr  unable to read model sample rate.  stdendl$^    return dserrmodelincompatible$^  $^$^  samplerate  modelsamplerate$^$^  int const winlenms   interpretertypedtensorintmetadatafeaturewinlenidx$^  int const winstepms  interpretertypedtensorintmetadatafeaturewinstepidx$^  if winlenms  nullptr  winstepms  nullptr $^    stdcerr  unable to read model feature window informations.  stdendl$^    return dserrmodelincompatible$^  $^$^  audiowinlen   samplerate  winlenms  0000.0$^  audiowinstep  samplerate  winstepms  0000.0$^$^  int const beamwidth  interpretertypedtensorintmetadatabeamwidthidx$^  beamwidth  unsigned intbeamwidth$^$^  tflitestringref serializedalphabet  tflitegetstringinterpretertensormetadataalphabetidx 0$^  err  alphabet.deserializeserializedalphabet.str serializedalphabet.len$^  if err  0 $^    return dserrinvalidalphabet$^  $^$^  assertsamplerate  0$^  assertaudiowinlen  0$^  assertaudiowinstep  0$^  assertbeamwidth  0$^  assertalphabet.getsize  0$^$^  tfliteintarray dimsinputnode  interpretertensorinputnodeidxdims$^$^  nsteps  dimsinputnodedata0$^  ncontext  dimsinputnodedata0  0  0$^  nfeatures  dimsinputnodedata0$^  mfccfeatspertimestep  dimsinputnodedata0  dimsinputnodedata0$^$^  tfliteintarray dimslogits  interpretertensorlogitsidxdims$^  const int finaldimsize  dimslogitsdata0  0$^  if finaldimsize  alphabet.getsize $^    stdcerr  error alphabet size does not match loaded model alphabet $^               has size   alphabet.getsize$^                but model has   finaldimsize$^                classes in its output. make sure youre passing an alphabet $^               file with the same size as the one used for training.$^               stdendl$^    return dserrinvalidalphabet$^  $^$^  tfliteintarray dimsc  interpretertensorpreviousstatecidxdims$^  tfliteintarray dimsh  interpretertensorpreviousstatehidxdims$^  assertdimscdata0  dimshdata0$^  assertstatesize  0$^  statesize  dimscdata0$^$^  return dserrok$^$^$^ copy contents of vec into the tensor with index tensoridx.$^ if vec.size  numelements set the remainder of the tensor values to zero.$^void$^tflitemodelstatecopyvectortotensorconst vectorfloat vec$^                                        int tensoridx$^                                        int numelements$^$^  float tensor  interpretertypedtensorfloattensoridx$^  int i$^  for i  0 i  vec.size i $^    tensori  veci$^  $^  for  i  numelements i $^    tensori  0.f$^  $^$^$^ copy numelements elements from the tensor with index tensoridx into vec$^void$^tflitemodelstatecopytensortovectorint tensoridx$^                                        int numelements$^                                        vectorfloat vec$^$^  float tensor  interpretertypedtensorfloattensoridx$^  for int i  0 i  numelements i $^    vec.pushbacktensori$^  $^$^$^void$^tflitemodelstateinferconst vectorfloat mfcc$^                        unsigned int nframes$^                        const vectorfloat previousstatec$^                        const vectorfloat previousstateh$^                        vectorfloat logitsoutput$^                        vectorfloat statecoutput$^                        vectorfloat statehoutput$^$^  const sizet numclasses  alphabet.getsize  0  0 for blank$^$^   feeding inputnode$^  copyvectortotensormfcc inputnodeidx nframesmfccfeatspertimestep$^$^   feeding previousstatec previousstateh$^  assertpreviousstatec.size  statesize$^  copyvectortotensorpreviousstatec previousstatecidx statesize$^  assertpreviousstateh.size  statesize$^  copyvectortotensorpreviousstateh previousstatehidx statesize$^$^  interpretersetexecutionplanacousticexecplan$^  tflitestatus status  interpreterinvoke$^  if status  ktfliteok $^    stdcerr  error running session   status  n$^    return$^  $^$^  copytensortovectorlogitsidx nframes  batchsize  numclasses logitsoutput$^$^  statecoutput.clear$^  statecoutput.reservestatesize$^  copytensortovectornewstatecidx statesize statecoutput$^$^  statehoutput.clear$^  statehoutput.reservestatesize$^  copytensortovectornewstatehidx statesize statehoutput$^$^$^void$^tflitemodelstatecomputemfccconst vectorfloat samples$^                               vectorfloat mfccoutput$^$^   feeding inputnode$^  copyvectortotensorsamples inputsamplesidx samples.size$^$^  tflitestatus status  interpretersetexecutionplanmfccexecplan$^  if status  ktfliteok $^    stdcerr  error setting execution plan   status  n$^    return$^  $^$^  status  interpreterinvoke$^  if status  ktfliteok $^    stdcerr  error running session   status  n$^    return$^  $^$^   the feature computation graph is hardcoded to one audio length for now$^  int nwindows  0$^  tfliteintarray outdims  interpretertensormfccsidxdims$^  int numelements  0$^  for int i  0 i  outdimssize i $^    numelements  outdimsdatai$^  $^  assertnumelements  nfeatures  nwindows$^$^  copytensortovectormfccsidx nwindows  nfeatures mfccoutput$^$^include deepspeech.h$^include string.h$^$^char$^dserrorcodetoerrormessageint aerrorcode$^$^define returnmessagename value desc $^    case name $^      return strdupdesc$^$^  switchaerrorcode$^  $^    dsforeacherrorreturnmessage$^    default$^      return strdupunknown error please make sure you are using the correct native binary.$^  $^$^undef returnmessage$^$^include stdlib.h$^include stdio.h$^$^include assert.h$^include errno.h$^include math.h$^include string.h$^include time.h$^include systypes.h$^include sysstat.h$^$^include sstream$^include string$^$^ifdef apple$^include targetconditionals.h$^endif$^$^if definedandroid  definedmscver  targetosiphone$^define nosox$^endif$^$^if definedmscver$^define nodir$^endif$^$^ifndef nosox$^include sox.h$^endif$^$^ifndef nodir$^include dirent.h$^include unistd.h$^endif  nodir$^include vector$^$^include deepspeech.h$^include args.h$^$^typedef struct $^  const char string$^  double cputimeoverall$^ dsresult$^$^struct metaword $^  stdstring word$^  float starttime$^  float duration$^$^$^char$^candidatetranscripttostringconst candidatetranscript transcript$^$^  stdstring retval  $^  for int i  0 i  transcriptnumtokens i $^    const tokenmetadata token  transcripttokensi$^    retval  token.text$^  $^  return strdupretval.cstr$^$^$^stdvectormetaword$^candidatetranscripttowordsconst candidatetranscript transcript$^$^  stdvectormetaword wordlist$^$^  stdstring word  $^  float wordstarttime  0$^$^   loop through each token$^  for int i  0 i  transcriptnumtokens i $^    const tokenmetadata token  transcripttokensi$^$^     append token to word if its not a space$^    if strcmptoken.text u0   0 $^       log the start time of the new word$^      if word.length  0 $^        wordstarttime  token.starttime$^      $^      word.appendtoken.text$^    $^$^     word boundary is either a space or the last token in the array$^    if strcmptoken.text u0   0  i  transcriptnumtokens0 $^      float wordduration  token.starttime  wordstarttime$^$^      if wordduration  0 $^        wordduration  0$^      $^$^      metaword w$^      w.word  word$^      w.starttime  wordstarttime$^      w.duration  wordduration$^$^      wordlist.pushbackw$^$^       reset$^      word  $^      wordstarttime  0$^    $^  $^$^  return wordlist$^$^$^stdstring$^candidatetranscripttojsonconst candidatetranscript transcript$^$^  stdostringstream outstring$^$^  stdvectormetaword words  candidatetranscripttowordstranscript$^$^  outstring  rmetadataconfidence  transcriptconfidence  rwords$^$^  for int i  0 i  words.size i $^    metaword w  wordsi$^    outstring  rword  w.word  rtime  w.starttime  rduration  w.duration  $^$^    if i  words.size  0 $^      outstring  $^    $^  $^$^  outstring  $^$^  return outstring.str$^$^$^char$^metadatatojsonmetadata result$^$^  stdostringstream outstring$^  outstring  n$^$^  for int j0 j  resultnumtranscripts j $^    const candidatetranscript transcript  resulttranscriptsj$^$^    if j  0 $^      outstring  candidatetranscripttojsontranscript$^$^      if resultnumtranscripts  0 $^        outstring  n  ralternatives  n$^      $^     else $^      outstring    candidatetranscripttojsontranscript  $^$^      if j  resultnumtranscripts  0 $^        outstring  n$^       else $^        outstring  n$^      $^    $^  $^  $^  outstring  nn$^$^  return strdupoutstring.str.cstr$^$^$^dsresult$^localdssttmodelstate actx const short abuffer sizet abuffersize$^           bool extendedoutput bool jsonoutput$^$^  dsresult res  0$^$^  clockt dsstarttime  clock$^$^   sphinxdoc crefinferencestart$^  if extendedoutput $^    metadata result  dsspeechtotextwithmetadataactx abuffer abuffersize 0$^    res.string  candidatetranscripttostringresulttranscripts0$^    dsfreemetadataresult$^   else if jsonoutput $^    metadata result  dsspeechtotextwithmetadataactx abuffer abuffersize jsoncandidatetranscripts$^    res.string  metadatatojsonresult$^    dsfreemetadataresult$^   else if streamsize  0 $^    streamingstate ctx$^    int status  dscreatestreamactx ctx$^    if status  dserrok $^      res.string  strdup$^      return res$^    $^    sizet off  0$^    const char last  nullptr$^    const char prev  nullptr$^    while off  abuffersize $^      sizet cur  abuffersize  off  streamsize  streamsize  abuffersize  off$^      dsfeedaudiocontentctx abuffer  off cur$^      off  cur$^      prev  last$^      const char partial  dsintermediatedecodectx$^      if last  nullptr  strcmplast partial $^        printfsn partial$^        last  partial$^       else $^        dsfreestringchar  partial$^      $^      if prev  nullptr  prev  last $^        dsfreestringchar  prev$^      $^    $^    if last  nullptr $^      dsfreestringchar  last$^    $^    res.string  dsfinishstreamctx$^   else if extendedstreamsize  0 $^    streamingstate ctx$^    int status  dscreatestreamactx ctx$^    if status  dserrok $^      res.string  strdup$^      return res$^    $^    sizet off  0$^    const char last  nullptr$^    const char prev  nullptr$^    while off  abuffersize $^      sizet cur  abuffersize  off  extendedstreamsize  extendedstreamsize  abuffersize  off$^      dsfeedaudiocontentctx abuffer  off cur$^      off  cur$^      prev  last$^      const metadata result  dsintermediatedecodewithmetadatactx 0$^      const char partial  candidatetranscripttostringresulttranscripts0$^      if last  nullptr  strcmplast partial $^        printfsn partial$^       last  partial$^       else $^        freechar  partial$^      $^      if prev  nullptr  prev  last $^        freechar  prev$^      $^      dsfreemetadatametadata result$^    $^    const metadata result  dsfinishstreamwithmetadatactx 0$^    res.string  candidatetranscripttostringresulttranscripts0$^    dsfreemetadatametadata result$^    freechar  last$^   else $^    res.string  dsspeechtotextactx abuffer abuffersize$^  $^   sphinxdoc crefinferencestop$^$^  clockt dsendinfer  clock$^$^  res.cputimeoverall $^    double dsendinfer  dsstarttime  clockspersec$^$^  return res$^$^$^typedef struct $^  char  buffer$^  sizet buffersize$^ dsaudiobuffer$^$^dsaudiobuffer$^getaudiobufferconst char path int desiredsamplerate$^$^  dsaudiobuffer res  0$^$^ifndef nosox$^  soxformatt input  soxopenreadpath null null null$^  assertinput$^$^   resamplereformat the audio so we can pass it through the mfcc functions$^  soxsignalinfot targetsignal  $^      staticcastsoxratetdesiredsamplerate  rate$^      0  channels$^      00  precision$^      soxunspec  length$^      null  effects headroom multiplier$^  $^$^  soxsignalinfot intermsignal$^$^  soxencodinginfot targetencoding  $^    soxencodingsign0  sample format$^    00  bits per sample$^    0.0  compression factor$^    soxoptiondefault  should bytes be reversed$^    soxoptiondefault  should nibbles be reversed$^    soxoptiondefault  should bits be reversed pairs of bits$^    soxfalse  reverse endianness$^  $^$^if targetososx$^   it would be preferable to use soxopenmemstreamwrite here but osx$^   doesnt support posix 0000 which it requires. see issue 000.$^   instead we write to a temporary file.$^  char outputname  tmpnamnull$^  assertoutputname$^  soxformatt output  soxopenwriteoutputname targetsignal$^                                        targetencoding raw null null$^else$^  soxformatt output  soxopenmemstreamwriteres.buffer$^                                                  res.buffersize$^                                                  targetsignal$^                                                  targetencoding$^                                                  raw null$^endif$^$^  assertoutput$^$^  if intinputsignal.rate  desiredsamplerate $^    fprintfstderr warning original sample rate d is lower than dkhz. $^                    upsampling might produce erratic speech recognition.n$^                    desiredsamplerate intinputsignal.rate$^  $^$^   setup the effects chain to decoderesample$^  char soxargs00$^  soxeffectschaint chain $^    soxcreateeffectschaininputencoding outputencoding$^$^  intermsignal  inputsignal$^$^  soxeffectt e  soxcreateeffectsoxfindeffectinput$^  soxargs0  charinput$^  assertsoxeffectoptionse 0 soxargs  soxsuccess$^  assertsoxaddeffectchain e intermsignal inputsignal $^         soxsuccess$^  freee$^$^  e  soxcreateeffectsoxfindeffectrate$^  assertsoxeffectoptionse 0 null  soxsuccess$^  assertsoxaddeffectchain e intermsignal outputsignal $^         soxsuccess$^  freee$^$^  e  soxcreateeffectsoxfindeffectchannels$^  assertsoxeffectoptionse 0 null  soxsuccess$^  assertsoxaddeffectchain e intermsignal outputsignal $^         soxsuccess$^  freee$^$^  e  soxcreateeffectsoxfindeffectoutput$^  soxargs0  charoutput$^  assertsoxeffectoptionse 0 soxargs  soxsuccess$^  assertsoxaddeffectchain e intermsignal outputsignal $^         soxsuccess$^  freee$^$^   finally run the effects chain$^  soxfloweffectschain null null$^  soxdeleteeffectschainchain$^$^   close sox handles$^  soxcloseoutput$^  soxcloseinput$^endif  nosox$^$^ifdef nosox$^   fixme hack and support only mono 00bits pcm with standard sox header$^  file wave  fopenpath r$^$^  sizet rv$^$^  unsigned short audioformat$^  fseekwave 00 seekset rv  freadaudioformat 0 0 wave$^$^  unsigned short numchannels$^  fseekwave 00 seekset rv  freadnumchannels 0 0 wave$^$^  unsigned int samplerate$^  fseekwave 00 seekset rv  freadsamplerate 0 0 wave$^$^  unsigned short bitspersample$^  fseekwave 00 seekset rv  freadbitspersample 0 0 wave$^$^  assertaudioformat  0  0 is pcm$^  assertnumchannels  0  mono$^  assertsamplerate  desiredsamplerate  at desired sample rate$^  assertbitspersample  00  00 bits per sample$^$^  fprintfstderr audioformatdn audioformat$^  fprintfstderr numchannelsdn numchannels$^  fprintfstderr samplerated desireddn samplerate desiredsamplerate$^  fprintfstderr bitspersampledn bitspersample$^$^  fseekwave 00 seekset rv  freadres.buffersize 0 0 wave$^  fprintfstderr res.buffersizeldn res.buffersize$^$^  fseekwave 00 seekset$^  res.buffer  charmallocsizeofchar  res.buffersize$^  rv  freadres.buffer sizeofchar res.buffersize wave$^$^  fclosewave$^endif  nosox$^$^if targetososx$^  res.buffersize  sizetoutputolength  0$^  res.buffer  charmallocsizeofchar  res.buffersize$^  file outputfile  fopenoutputname rb$^  assertfreadres.buffer sizeofchar res.buffersize outputfile  res.buffersize$^  fcloseoutputfile$^  unlinkoutputname$^endif$^$^  return res$^$^$^void$^processfilemodelstate context const char path bool showtimes$^$^  dsaudiobuffer audio  getaudiobufferpath dsgetmodelsampleratecontext$^$^   pass audio to deepspeech$^   we take half of buffersize because buffer is a char while$^   localdsstt expected a short$^  dsresult result  localdssttcontext$^                                const shortaudio.buffer$^                                audio.buffersize  0$^                                extendedmetadata$^                                jsonoutput$^  freeaudio.buffer$^$^  if result.string $^    printfsn result.string$^    dsfreestringcharresult.string$^  $^$^  if showtimes $^    printfcputimeoverall.00fn$^           result.cputimeoverall$^  $^$^$^stdvectorstdstring$^splitstringondelimstdstring instring stdstring delim$^$^  stdvectorstdstring outvector$^  char  tmpstr  new charinstring.size  0$^  stdcopyinstring.begin instring.end tmpstr$^  tmpstrinstring.size  0$^  const char token  strtoktmpstr delim.cstr$^  while token  null  $^    outvector.pushbacktoken$^    token  strtoknull delim.cstr$^  $^  delete tmpstr$^  return outvector$^$^$^int$^mainint argc char argv$^$^  if processargsargc argv $^    return 0$^  $^$^   initialise deepspeech$^  modelstate ctx$^   sphinxdoc crefmodelstart$^  int status  dscreatemodelmodel ctx$^  if status  0 $^    char error  dserrorcodetoerrormessagestatus$^    fprintfstderr could not create model sn error$^    freeerror$^    return 0$^  $^$^  if setbeamwidth $^    status  dssetmodelbeamwidthctx beamwidth$^    if status  0 $^      fprintfstderr could not set model beam width.n$^      return 0$^    $^  $^$^  if scorer $^    status  dsenableexternalscorerctx scorer$^    if status  0 $^      fprintfstderr could not enable external scorer.n$^      return 0$^    $^    if setalphabeta $^      status  dssetscoreralphabetactx lmalpha lmbeta$^      if status  0 $^        fprintfstderr error setting scorer alpha and beta.n$^        return 0$^      $^    $^  $^   sphinxdoc crefmodelstop$^$^  if hotwords $^    stdvectorstdstring hotwords  splitstringondelimhotwords $^    for  stdstring hotword  hotwords  $^      stdvectorstdstring pair  splitstringondelimhotword $^      const char word  pair0.cstr$^       the strtof function will return 0 in case of non numeric characters$^       so check the boost string before we turn it into a float$^      bool boostisvalid  pair0.findfirstnotof.0000000000  stdstringnpos$^      float boost  strtofpair0.cstr0$^      status  dsaddhotwordctx word boost$^      if status  0  boostisvalid $^        fprintfstderr could not enable hotword.n$^        return 0$^      $^    $^  $^$^ifndef nosox$^   initialise sox$^  assertsoxinit  soxsuccess$^endif$^$^  struct stat wavinfo$^  if 0  stataudio wavinfo $^    printferror on stat dn errno$^  $^$^  switch wavinfo.stmode  sifmt $^ifndef mscver$^    case siflnk$^endif$^    case sifreg$^        processfilectx audio showtimes$^      break$^$^ifndef nodir$^    case sifdir$^        $^          printfrunning on directory sn audio$^          dir wavdir  opendiraudio$^          assertwavdir$^$^          struct dirent entry$^          while entry  readdirwavdir  null $^            stdstring fname  stdstringentrydname$^            if fname.find.wav  stdstringnpos $^              continue$^            $^$^            stdostringstream fullpath$^            fullpath  audio    fname$^            stdstring path  fullpath.str$^            printf sn path.cstr$^            processfilectx path.cstr showtimes$^          $^          closedirwavdir$^        $^      break$^endif$^$^    default$^        printfunexpected type for s dn audio wavinfo.stmode  sifmt$^      break$^  $^$^ifndef nosox$^   deinitialise and quit$^  soxquit$^endif  nosox$^$^  dsfreemodelctx$^$^  return 0$^$^include algorithm$^include iostream$^include string$^$^include ctcdecodescorer.h$^include alphabet.h$^$^ifdef debug$^include limits$^include unorderedmap$^include ctcdecodepathtrie.h$^endif  debug$^$^using namespace std$^$^int mainint argc char argv$^$^  const char kenlmpath     argv0$^  const char triepath      argv0$^  const char alphabetpath  argv0$^$^  printfloading tries and alphabetsn triepath alphabetpath$^$^  alphabet alphabet$^  int err  alphabet.initalphabetpath$^  if err  0 $^    return err$^  $^  scorer scorer$^  err  scorer.initkenlmpath alphabet$^ifndef debug$^  return err$^else$^   print some info about the fst$^  using fsttype  fstconstfstfststdarc$^$^  auto dict  scorer.dictionary.get$^$^  struct stateinfo $^    int rangemin  stdnumericlimitsintmax$^    int rangemax  stdnumericlimitsintmin$^  $^$^  auto printstatesfrom  int i $^    stdunorderedmapint stateinfo sinfo$^    for fstarciteratorfsttype aiterdict i aiter.done aiter.next $^      const fststdarc arc  aiter.value$^      sinfoarc.nextstate.rangemin  stdminsinfoarc.nextstate.rangemin arc.ilabel0$^      sinfoarc.nextstate.rangemax  stdmaxsinfoarc.nextstate.rangemax arc.ilabel0$^    $^$^    for auto it  sinfo.begin it  sinfo.end it $^      stateinfo s  itsecond$^      printfd  state d chars 0xx  0xx c  cn i itfirst unsigned ints.rangemin unsigned ints.rangemax chars.rangemin chars.rangemax$^    $^  $^$^  printstatesfrom0$^$^   for int i  0 i  00 i $^     printstatesfromi$^   $^  return 0$^endif  debug$^$^include algorithm$^ifdef mscver$^  define usemathdefines$^endif$^include cmath$^include iostream$^include memory$^include string$^include utility$^include vector$^$^include deepspeech.h$^include alphabet.h$^include modelstate.h$^$^include workspacestatus.h$^$^ifndef usetflite$^include tfmodelstate.h$^else$^include tflitemodelstate.h$^endif  usetflite$^$^include ctcdecodectcbeamsearchdecoder.h$^$^ifdef android$^include androidlog.h$^define  logtag    libdeepspeech$^define  logd...  androidlogprintandroidlogdebug logtag vaargs$^define  loge...  androidlogprintandroidlogerror logtag vaargs$^else$^define  logd...$^define  loge...$^endif  android$^$^using stdvector$^$^ this is the implementation of the streaming inference api.$^$^   the streaming process uses three buffers that are fed eagerly as audio data$^   is fed in. the buffers only hold the minimum amount of data needed to do a$^   step in the acoustic model. the three buffers which live in streamingstate$^   are$^$^    audiobuffer used to buffer audio samples until theres enough data to$^     compute input features for a single window.$^$^    mfccbuffer used to buffer input features until theres enough data for$^     a single timestep. remember theres overlap in the features each timestep$^     contains ncontext past feature frames the current feature frame and$^     ncontext future feature frames for a total of 0ncontext  0 feature$^     frames per timestep.$^$^    batchbuffer used to buffer timesteps until theres enough data to compute$^     a batch of nsteps.$^$^   data flows through all three buffers as audio samples are fed via the public$^   api. when audiobuffer is full features are computed from it and pushed to$^   mfccbuffer. when mfccbuffer is full the timestep is copied to batchbuffer.$^   when batchbuffer is full we do a single step through the acoustic model$^   and accumulate the intermediate decoding state in the decoderstate structure.$^$^   when finishstream is called we return the corresponding transcript from$^   the current decoder state.$^$^struct streamingstate $^  vectorfloat audiobuffer$^  vectorfloat mfccbuffer$^  vectorfloat batchbuffer$^  vectorfloat previousstatec$^  vectorfloat previousstateh$^$^  modelstate model$^  decoderstate decoderstate$^$^  streamingstate$^  streamingstate$^$^  void feedaudiocontentconst short buffer unsigned int buffersize$^  char intermediatedecode const$^  metadata intermediatedecodewithmetadataunsigned int numresults const$^  void finalizestream$^  char finishstream$^  metadata finishstreamwithmetadataunsigned int numresults$^$^  void processaudiowindowconst vectorfloat buf$^  void processmfccwindowconst vectorfloat buf$^  void pushmfccbufferconst vectorfloat buf$^  void addzeromfccwindow$^  void processbatchconst vectorfloat buf unsigned int nsteps$^$^$^streamingstatestreamingstate$^$^$^$^streamingstatestreamingstate$^$^$^$^templatetypename t$^void$^shiftbufferleftvectort buf int shiftamount$^$^  stdrotatebuf.begin buf.begin  shiftamount buf.end$^  buf.resizebuf.size  shiftamount$^$^$^void$^streamingstatefeedaudiocontentconst short buffer$^                                 unsigned int buffersize$^$^   consume all the data that was passed in processing full buffers if needed$^  while buffersize  0 $^    while buffersize  0  audiobuffer.size  modelaudiowinlen $^       convert i00 sample into f00$^      float multiplier  0.0f  0  00$^      audiobuffer.pushbackfloatbuffer  multiplier$^      buffer$^      buffersize$^    $^$^     if the buffer is full process and shift it$^    if audiobuffer.size  modelaudiowinlen $^      processaudiowindowaudiobuffer$^       shift data by one step$^      shiftbufferleftaudiobuffer modelaudiowinstep$^    $^$^     repeat until buffer empty$^  $^$^$^char$^streamingstateintermediatedecode const$^$^  return modeldecodedecoderstate$^$^$^metadata$^streamingstateintermediatedecodewithmetadataunsigned int numresults const$^$^  return modeldecodemetadatadecoderstate numresults$^$^$^char$^streamingstatefinishstream$^$^  finalizestream$^  return modeldecodedecoderstate$^$^$^metadata$^streamingstatefinishstreamwithmetadataunsigned int numresults$^$^  finalizestream$^  return modeldecodemetadatadecoderstate numresults$^$^$^void$^streamingstateprocessaudiowindowconst vectorfloat buf$^$^   compute mfcc features$^  vectorfloat mfcc$^  mfcc.reservemodelnfeatures$^  modelcomputemfccbuf mfcc$^  pushmfccbuffermfcc$^$^$^void$^streamingstatefinalizestream$^$^   flush audio buffer$^  processaudiowindowaudiobuffer$^$^   add empty mfcc vectors at end of sample$^  for int i  0 i  modelncontext i $^    addzeromfccwindow$^  $^$^   process final batch$^  if batchbuffer.size  0 $^    processbatchbatchbuffer batchbuffer.sizemodelmfccfeatspertimestep$^  $^$^$^void$^streamingstateaddzeromfccwindow$^$^  vectorfloat zerobuffermodelnfeatures 0.f$^  pushmfccbufferzerobuffer$^$^$^templatetypename inputit typename outputit$^inputit$^copyuptoninputit frombegin inputit fromend outputit tobegin int maxelems$^$^  int nextcopyamount  stdminintstddistancefrombegin fromend maxelems$^  stdcopynfrombegin nextcopyamount tobegin$^  return frombegin  nextcopyamount$^$^$^void$^streamingstatepushmfccbufferconst vectorfloat buf$^$^  auto start  buf.begin$^  auto end  buf.end$^  while start  end $^     copy from input buffer to mfccbuffer stopping if we have a full context window$^    start  copyuptonstart end stdbackinsertermfccbuffer$^                         modelmfccfeatspertimestep  mfccbuffer.size$^    assertmfccbuffer.size  modelmfccfeatspertimestep$^$^     if we have a full context window$^    if mfccbuffer.size  modelmfccfeatspertimestep $^      processmfccwindowmfccbuffer$^       shift data by one step of one mfcc feature vector$^      shiftbufferleftmfccbuffer modelnfeatures$^    $^  $^$^$^void$^streamingstateprocessmfccwindowconst vectorfloat buf$^$^  auto start  buf.begin$^  auto end  buf.end$^  while start  end $^     copy from input buffer to batchbuffer stopping if we have a full batch$^    start  copyuptonstart end stdbackinserterbatchbuffer$^                         modelnsteps  modelmfccfeatspertimestep  batchbuffer.size$^    assertbatchbuffer.size  modelnsteps  modelmfccfeatspertimestep$^$^     if we have a full batch$^    if batchbuffer.size  modelnsteps  modelmfccfeatspertimestep $^      processbatchbatchbuffer modelnsteps$^      batchbuffer.resize0$^    $^  $^$^$^void$^streamingstateprocessbatchconst vectorfloat buf unsigned int nsteps$^$^  vectorfloat logits$^  modelinferbuf$^                nsteps$^                previousstatec$^                previousstateh$^                logits$^                previousstatec$^                previousstateh$^$^  const sizet numclasses  modelalphabet.getsize  0  0 for blank$^  const int nframes  logits.size  modelstatebatchsize  numclasses$^$^   convert logits to double$^  vectordouble inputslogits.begin logits.end$^$^  decoderstate.nextinputs.data$^                      nframes$^                      numclasses$^$^$^int$^dscreatemodelconst char amodelpath$^               modelstate retval$^$^  retval  nullptr$^$^  stdcerr  tensorflow   tflocalgitversion  stdendl$^  stdcerr  deepspeech   dsgitversion  stdendl$^ifdef android$^  logetensorflow s tflocalgitversion$^  logdtensorflow s tflocalgitversion$^  logedeepspeech s dsgitversion$^  logddeepspeech s dsgitversion$^endif$^$^  if amodelpath  strlenamodelpath  0 $^    stdcerr  no model specified cannot continue.  stdendl$^    return dserrnomodel$^  $^$^  stduniqueptrmodelstate model$^ifndef usetflite$^    new tfmodelstate$^else$^    new tflitemodelstate$^endif$^  $^$^  if model $^    stdcerr  could not allocate model state.  stdendl$^    return dserrfailcreatemodel$^  $^$^  int err  modelinitamodelpath$^  if err  dserrok $^    return err$^  $^$^  retval  model.release$^  return dserrok$^$^$^unsigned int$^dsgetmodelbeamwidthconst modelstate actx$^$^  return actxbeamwidth$^$^$^int$^dssetmodelbeamwidthmodelstate actx unsigned int abeamwidth$^$^  actxbeamwidth  abeamwidth$^  return 0$^$^$^int$^dsgetmodelsamplerateconst modelstate actx$^$^  return actxsamplerate$^$^$^void$^dsfreemodelmodelstate ctx$^$^  delete ctx$^$^$^int$^dsenableexternalscorermodelstate actx$^                        const char ascorerpath$^$^  stduniqueptrscorer scorernew scorer$^  int err  scorerinitascorerpath actxalphabet$^  if err  0 $^    return dserrinvalidscorer$^  $^  actxscorer  stdmovescorer$^  return dserrok$^$^$^int$^dsaddhotwordmodelstate actx$^              const char word$^              float boost$^$^  if actxscorer $^    const int sizebefore  actxhotwords.size$^    actxhotwords.insert stdpairstdstringfloat word boost $^    const int sizeafter  actxhotwords.size$^    if sizebefore  sizeafter $^      return dserrfailinserthotword$^    $^    return dserrok$^  $^  return dserrscorernotenabled$^$^$^int$^dserasehotwordmodelstate actx$^                const char word$^$^  if actxscorer $^    const int sizebefore  actxhotwords.size$^    int err  actxhotwords.eraseword$^    const int sizeafter  actxhotwords.size$^    if sizebefore  sizeafter $^      return dserrfailerasehotword$^    $^    return dserrok$^  $^  return dserrscorernotenabled$^$^$^int$^dsclearhotwordsmodelstate actx$^$^  if actxscorer $^    actxhotwords.clear$^    const int sizeafter  actxhotwords.size$^    if sizeafter  0 $^      return dserrfailclearhotword$^    $^    return dserrok$^  $^  return dserrscorernotenabled$^$^$^int$^dsdisableexternalscorermodelstate actx$^$^  if actxscorer $^    actxscorer.reset$^    return dserrok$^  $^  return dserrscorernotenabled$^$^$^int dssetscoreralphabetamodelstate actx$^                          float aalpha$^                          float abeta$^$^  if actxscorer $^    actxscorerresetparamsaalpha abeta$^    return dserrok$^  $^  return dserrscorernotenabled$^$^$^int$^dscreatestreammodelstate actx$^                streamingstate retval$^$^  retval  nullptr$^$^  stduniqueptrstreamingstate ctxnew streamingstate$^  if ctx $^    stdcerr  could not allocate streaming state.  stdendl$^    return dserrfailcreatestream$^  $^$^  ctxaudiobuffer.reserveactxaudiowinlen$^  ctxmfccbuffer.reserveactxmfccfeatspertimestep$^  ctxmfccbuffer.resizeactxnfeaturesactxncontext 0.f$^  ctxbatchbuffer.reserveactxnsteps  actxmfccfeatspertimestep$^  ctxpreviousstatec.resizeactxstatesize 0.f$^  ctxpreviousstateh.resizeactxstatesize 0.f$^  ctxmodel  actx$^$^  const int cutofftopn  00$^  const double cutoffprob  0.0$^$^  ctxdecoderstate.initactxalphabet$^                           actxbeamwidth$^                           cutoffprob$^                           cutofftopn$^                           actxscorer$^                           actxhotwords$^$^  retval  ctx.release$^  return dserrok$^$^$^void$^dsfeedaudiocontentstreamingstate asctx$^                    const short abuffer$^                    unsigned int abuffersize$^$^  asctxfeedaudiocontentabuffer abuffersize$^$^$^char$^dsintermediatedecodeconst streamingstate asctx$^$^  return asctxintermediatedecode$^$^$^metadata$^dsintermediatedecodewithmetadataconst streamingstate asctx$^                                  unsigned int anumresults$^$^  return asctxintermediatedecodewithmetadataanumresults$^$^$^char$^dsfinishstreamstreamingstate asctx$^$^  char str  asctxfinishstream$^  dsfreestreamasctx$^  return str$^$^$^metadata$^dsfinishstreamwithmetadatastreamingstate asctx $^                            unsigned int anumresults$^$^  metadata result  asctxfinishstreamwithmetadataanumresults$^  dsfreestreamasctx$^  return result$^$^$^streamingstate$^createstreamandfeedaudiocontentmodelstate actx$^                                const short abuffer$^                                unsigned int abuffersize$^$^  streamingstate ctx$^  int status  dscreatestreamactx ctx$^  if status  dserrok $^    return nullptr$^  $^  dsfeedaudiocontentctx abuffer abuffersize$^  return ctx$^$^$^char$^dsspeechtotextmodelstate actx$^                const short abuffer$^                unsigned int abuffersize$^$^  streamingstate ctx  createstreamandfeedaudiocontentactx abuffer abuffersize$^  return dsfinishstreamctx$^$^$^metadata$^dsspeechtotextwithmetadatamodelstate actx$^                            const short abuffer$^                            unsigned int abuffersize$^                            unsigned int anumresults$^$^  streamingstate ctx  createstreamandfeedaudiocontentactx abuffer abuffersize$^  return dsfinishstreamwithmetadatactx anumresults$^$^$^void$^dsfreestreamstreamingstate asctx$^$^  delete asctx$^$^$^void$^dsfreemetadatametadata m$^$^  if m $^    for int i  0 i  mnumtranscripts i $^      for int j  0 j  mtranscriptsi.numtokens j $^        freevoidmtranscriptsi.tokensj.text$^      $^$^      freevoidmtranscriptsi.tokens$^    $^$^    freevoidmtranscripts$^    freem$^  $^$^$^void$^dsfreestringchar str$^$^  freestr$^$^$^char$^dsversion$^$^  return strdupdsversion$^$^include vector$^$^include ctcdecodectcbeamsearchdecoder.h$^$^include modelstate.h$^$^using stdvector$^$^modelstatemodelstate$^   beamwidth0$^   nsteps0$^   ncontext0$^   nfeatures0$^   mfccfeatspertimestep0$^   samplerate0$^   audiowinlen0$^   audiowinstep0$^   statesize0$^$^$^$^modelstatemodelstate$^$^$^$^int$^modelstateinitconst char modelpath$^$^  return dserrok$^$^$^char$^modelstatedecodeconst decoderstate state const$^$^  vectoroutput out  state.decode$^  return strdupalphabet.decodeout0.tokens.cstr$^$^$^metadata$^modelstatedecodemetadataconst decoderstate state $^                            sizet numresults$^$^  vectoroutput out  state.decodenumresults$^  unsigned int numreturned  out.size$^$^  candidatetranscript transcripts  candidatetranscriptmallocsizeofcandidatetranscriptnumreturned$^$^  for int i  0 i  numreturned i $^    tokenmetadata tokens  tokenmetadatamallocsizeoftokenmetadataouti.tokens.size$^$^    for int j  0 j  outi.tokens.size j $^      tokenmetadata token $^        strdupalphabet.decodesingleouti.tokensj.cstr    text$^        staticcastunsigned intouti.timestepsj                 timestep$^        outi.timestepsj  floataudiowinstep  samplerate  starttime$^      $^      memcpytokensj token sizeoftokenmetadata$^    $^$^    candidatetranscript transcript $^      tokens                                           tokens$^      staticcastunsigned intouti.tokens.size  numtokens$^      outi.confidence                                confidence$^    $^    memcpytranscriptsi transcript sizeofcandidatetranscript$^  $^$^  metadata ret  metadatamallocsizeofmetadata$^  metadata metadata $^    transcripts   transcripts$^    numreturned  numtranscripts$^  $^  memcpyret metadata sizeofmetadata$^  return ret$^$^define boostlexicalcastassumeclocale$^define boosttestmodule fakeostreamtest$^$^include utilstringstream.hh$^include boosttestunittest.hpp$^include boostlexicalcast.hpp$^$^include cstddef$^include limits$^$^namespace util  namespace $^$^template class t void testequalconst t value $^  stringstream strme$^  strme  value$^  boostcheckequalboostlexicalcaststdstringvalue strme.str$^$^$^template class t void testcorners $^  testequalstdnumericlimitstmax$^  testequalstdnumericlimitstmin$^  testequalstaticcastt0$^  testequalstaticcastt0$^  testequalstaticcastt0$^$^$^boostautotestcaseinteger $^  testcornerschar$^  testcornerssigned char$^  testcornersunsigned char$^$^  testcornersshort$^  testcornerssigned short$^  testcornersunsigned short$^$^  testcornersint$^  testcornersunsigned int$^  testcornerssigned int$^$^  testcornerslong$^  testcornersunsigned long$^  testcornerssigned long$^$^  testcornerslong long$^  testcornersunsigned long long$^  testcornerssigned long long$^$^  testcornersstdsizet$^$^$^enum tinyenum  enumvalue $^$^boostautotestcaseenumcase $^  testequalenumvalue$^$^$^boostautotestcasestrings $^  testequalfoo$^  const char a  bar$^  testequala$^  stringpiece pieceabcdef$^  testequalpiece$^  testequalstringpiece$^$^  char nonconst0$^  nonconst0  b$^  nonconst0  c$^  nonconst0  0$^$^  stringstream out$^  out  a  nonconst  c$^  boostcheckequalabcc out.str$^$^   now test as a separate object.$^  stringstream stream$^  stream  a  nonconst  c  piece$^  boostcheckequalabccabcdef stream.str$^$^$^  namespaces$^include utilpool.hh$^$^include utilscoped.hh$^$^include cstdlib$^$^include algorithm$^$^namespace util $^$^poolpool $^  current  null$^  currentend  null$^$^$^poolpool $^  freeall$^$^$^void poolfreeall $^  for stdvectorvoid constiterator ifreelist.begin i  freelist.end i $^    freei$^  $^  freelist.clear$^  current  null$^  currentend  null$^$^$^void poolmorestdsizet size $^  stdsizet amount  stdmaxstaticcastsizet00  freelist.size size$^  uint0t ret  staticcastuint0tmallocorthrowamount$^  freelist.pushbackret$^  current  ret  size$^  currentend  ret  amount$^  return ret$^$^$^  namespace util$^include utiljointsort.hh$^$^define boosttestmodule jointsorttest$^include boosttestunittest.hpp$^$^namespace util  namespace $^$^boostautotestcasejustflip $^  char keys0$^  int values0$^  keys0  0 values0  000$^  keys0  0 values0  00000$^  jointsortchar  int keys  0 keys  0 values  0$^  boostcheckequal0 keys0$^  boostcheckequal00000 values0$^  boostcheckequal0 keys0$^  boostcheckequal000 values0$^$^$^boostautotestcasethree $^  char keys0$^  int values0$^  keys0  0 values0  000$^  keys0  0 values0  00000$^  keys0  0 values0  00$^  jointsortchar  int keys  0 keys  0 values  0$^  boostcheckequal0 keys0$^  boostcheckequal0 keys0$^  boostcheckequal0 keys0$^$^$^boostautotestcasecharint $^  char keys0$^  int values0$^  keys0  0 values0  000$^  keys0  0 values0  00000$^  keys0  0 values0  00$^  keys0  0 values0  00000$^  jointsortchar  int keys  0 keys  0 values  0$^  boostcheckequal0 keys0$^  boostcheckequal00000 values0$^  boostcheckequal0 keys0$^  boostcheckequal00000 values0$^  boostcheckequal0 keys0$^  boostcheckequal00 values0$^  boostcheckequal0 keys0$^  boostcheckequal000 values0$^$^$^boostautotestcaseswapproxy $^  char keys0  0 0$^  int values0  0 0$^  detailjointproxychar  int  firstkeys values$^  detailjointproxychar  int  secondkeys  0 values  0$^  swapfirst second$^  boostcheckequal0 keys0$^  boostcheckequal0 keys0$^  boostcheckequal0 values0$^  boostcheckequal0 values0$^$^$^  namespace anonymous util$^include utilfloattostring.hh$^$^include utildoubleconversiondoubleconversion.h$^include utildoubleconversionutils.h$^$^namespace util $^namespace $^const kenlmdoubleconversiondoubletostringconverter kconverterkenlmdoubleconversiondoubletostringconverternoflags inf nan e 0 00 0 0$^  namespace$^$^char tostringdouble value char to $^  kenlmdoubleconversionstringbuilder builderto tostringbufdoublekbytes$^  kconverter.toshortestvalue builder$^  return tobuilder.position$^$^$^char tostringfloat value char to $^  kenlmdoubleconversionstringbuilder builderto tostringbuffloatkbytes$^  kconverter.toshortestsinglevalue builder$^  return tobuilder.position$^$^$^  namespace util$^ memory mapping wrappers.$^  arm and mingw ports contributed by hideo okuma and tomoyuki yoshimura at$^  nict.$^ $^include utilmmap.hh$^$^include utilexception.hh$^include utilfile.hh$^include utilparallelread.hh$^include utilscoped.hh$^$^include iostream$^$^include cassert$^include fcntl.h$^include systypes.h$^include sysstat.h$^include cstdlib$^$^if definedwin00  definedwin00$^include windows.h$^include io.h$^else$^include sysmman.h$^include unistd.h$^endif$^$^namespace util $^$^stdsizet sizepage $^if definedwin00  definedwin00$^  systeminfo si$^  getsysteminfosi$^  return si.dwallocationgranularity$^else$^  return sysconfscpagesize$^endif$^$^$^scopedmmapscopedmmap $^  if data  void0 $^    try $^       thanks denis filimonov for pointing out nfs likes msync first.$^      syncorthrowdata size$^      unmaporthrowdata size$^     catch const utilerrnoexception e $^      stdcerr  e.what$^      abort$^    $^  $^$^$^namespace $^template class t t rounduppow0t value t mult $^  return value  0  mult  0  mult$^$^  namespace$^$^scopedmemoryscopedmemorystdsizet size bool zeroed  datanull size0 sourcenoneallocated $^  hugemallocsize zeroed this$^$^$^void scopedmemoryresetvoid data stdsizet size alloc source $^  switchsource $^    case mmaproundupallocated$^      scopedmmapdata rounduppow0size stdsizetsizepage$^      break$^    case mmapallocated$^      scopedmmapdata size$^      break$^    case mallocallocated$^      freedata$^      break$^    case noneallocated$^      break$^  $^  data  data$^  size  size$^  source  source$^$^$^void scopedmemorycallreallocstdsizet size $^  assertsource  mallocallocated  source  noneallocated$^  void newdata  reallocdata size$^  if newdata $^    reset$^   else $^    data  newdata$^    size  size$^    source  mallocallocated$^  $^$^$^const int kfileflags $^if definedwin00  definedwin00$^  0  maporthrow ignores flags on windows$^elif definedmapfile$^  mapfile  mapshared$^else$^  mapshared$^endif$^  $^$^void maporthrowstdsizet size bool forwrite int flags bool prefault int fd uint00t offset $^ifdef mappopulate  linux specific$^  if prefault $^    flags  mappopulate$^  $^endif$^if definedwin00  definedwin00$^  int protectc  forwrite  pagereadwrite  pagereadonly$^  int protectm  forwrite  filemapwrite  filemapread$^  uint00t totalsize  size  offset$^  handle hmapping  createfilemappinghandlegetosfhandlefd null protectc totalsize  00 staticcastdwordtotalsize null$^  utilthrowifhmapping errnoexception createfilemapping failed$^  lpvoid ret  mapviewoffilehmapping protectm offset  00 offset size$^  closehandlehmapping$^  utilthrowifret errnoexception mapviewoffile failed$^else$^  int protect  forwrite  protread  protwrite  protread$^  void ret$^  utilthrowifret  mmapnull size protect flags fd offset  mapfailed errnoexception mmap failed for size   size   at offset   offset$^  ifdef madvhugepage$^   we like huge pages but its fine if we cant have them.  note that huge$^    pages are not supported for filebacked mmap on linux.$^   $^  madviseret size madvhugepage$^  endif$^endif$^  return ret$^$^$^void syncorthrowvoid start sizet length $^if definedwin00  definedwin00$^  utilthrowifflushviewoffilestart length errnoexception failed to sync mmap$^else$^  utilthrowiflength  msyncstart length mssync errnoexception failed to sync mmap$^endif$^$^$^void unmaporthrowvoid start sizet length $^if definedwin00  definedwin00$^  utilthrowifunmapviewoffilestart errnoexception failed to unmap a file$^else$^  utilthrowifmunmapstart length errnoexception munmap failed with   start   for length   length$^endif$^$^$^ linux huge pages.$^ifdef linux$^$^namespace $^$^bool anonymousmapstdsizet size int flags bool populate utilscopedmemory to $^  if populate flags  mappopulate$^  void ret  mmapnull size protread  protwrite mapprivate  mapanonymous  flags 0 0$^  if ret  mapfailed return false$^  to.resetret size scopedmemorymmapallocated$^  return true$^$^$^bool tryhugestdsizet size uint0t alignmentbits bool populate utilscopedmemory to $^   dont bother with these cases.$^  if size  0ull  alignmentbits  0ull  alignmentbits  sizepage$^    return false$^$^   first try linux  0.0 with manually configured hugetlb pages available.$^ifdef maphugeshift$^  if anonymousmapsize maphugetlb  alignmentbits  maphugeshift populate to$^    return true$^endif$^$^   second try manually configured hugetlb pages exist but kernel too old to$^   pick size or not available.  this might pick the wrong size huge pages$^   but the sysadmin must have made them available in the first place.$^  if anonymousmapsize maphugetlb populate to$^    return true$^$^   third try align to a multiple of the huge page size by overallocating.$^   i feel bad about doing this but its also how posixmemalign is$^   implemented.  and the memory is virtual.$^$^   round up requested size to multiple of page size.  this will allow the pages after to be munmapped.$^  stdsizet sizeup  rounduppow0size sizepage$^$^  stdsizet ask  sizeup  0  alignmentbits  sizepage$^   dont populate because this is asking for more than we will use.$^  scopedmmap largermmapnull ask protread  protwrite mapprivate  mapanonymous 0 0 ask$^  if larger.get  mapfailed return false$^$^   throw out pages before the alignment point.$^  uintptrt base  reinterpretcastuintptrtlarger.get$^   round up to next multiple of alignment.$^  uintptrt roundedup  rounduppow0base staticcastuintptrt0  alignmentbits$^  if base  roundedup $^     if this throws an exception which it shouldnt then we want to unmap the whole thing by keeping it in larger.$^    unmaporthrowlarger.get roundedup  base$^    larger.steal$^    larger.resetreinterpretcastvoidroundedup ask  roundedup  base$^  $^$^   throw out pages after the requested size.$^  assertlarger.size  sizeup$^  if larger.size  sizeup $^     this is where we assume sizeup is a multiple of page size.$^    unmaporthrowstaticcastuint0tlarger.get  sizeup larger.size  sizeup$^    larger.resetlarger.steal sizeup$^  $^ifdef madvhugepage$^  madviselarger.get sizeup madvhugepage$^endif$^  to.resetlarger.steal size scopedmemorymmaproundupallocated$^  return true$^$^$^  namespace$^$^endif$^$^void hugemallocstdsizet size bool zeroed scopedmemory to $^  to.reset$^ifdef linux$^   todo architecturespage sizes other than 000 and 000.$^   attempt 0 gb pages.$^   if the user asked for zeroed memory assume they want it populated.$^  if size  0ull  00  tryhugesize 00 zeroed to$^    return$^   attempt 0 mb pages.$^  if size  0ull  00  tryhugesize 00 zeroed to$^    return$^endif  linux$^   nonlinux will always do this as will small allocations on linux.$^  to.resetzeroed  calloc0 size  mallocsize size scopedmemorymallocallocated$^  utilthrowifto.get errnoexception failed to allocate   size   bytes$^$^$^ifdef linux$^const stdsizet ktransitionhuge  stdmaxstdsizet0ull  00 sizepage$^endif  linux$^$^void hugereallocstdsizet to bool zeronew scopedmemory mem $^  if to $^    mem.reset$^    return$^  $^ifdef linux$^  stdsizet fromsize  mem.size$^endif  linux$^  switch mem.source $^    case scopedmemorynoneallocated$^      hugemallocto zeronew mem$^      return$^ifdef linux$^    case scopedmemorymmaproundupallocated$^       for mremaps benefit.$^      fromsize  rounduppow0fromsize sizepage$^    case scopedmemorymmapallocated$^       downsizing below barrier$^      if to  sizepage $^        scopedmalloc replacementmallocto$^        memcpyreplacement.get mem.get stdminto mem.size$^        if zeronew  to  mem.size$^          memsetstaticcastuint0treplacement.get  mem.size 0 to  mem.size$^        mem.resetreplacement.release to scopedmemorymallocallocated$^       else $^        void newaddr  mremapmem.get fromsize to mremapmaymove$^        utilthrowifnewaddr errnoexception failed to mremap from   fromsize   to   to$^        mem.steal$^        mem.resetnewaddr to scopedmemorymmapallocated$^      $^      return$^endif  linux$^    case scopedmemorymallocallocated$^ifdef linux$^       transition larger allocations to huge pages but dont keep trying if were still malloc allocated.$^      if to  ktransitionhuge  mem.size  ktransitionhuge $^        scopedmemory replacement$^        hugemallocto zeronew replacement$^        memcpyreplacement.get mem.get mem.size$^         this cant throw.$^        mem.resetreplacement.get replacement.size replacement.source$^        replacement.steal$^        return$^      $^endif  linux$^      $^        void newaddr  stdreallocmem.get to$^        utilthrowifnewaddr errnoexception realloc to   to   bytes failed.$^        if zeronew  to  mem.size$^          memsetstaticcastuint0tnewaddr  mem.size 0 to  mem.size$^        mem.steal$^        mem.resetnewaddr to scopedmemorymallocallocated$^      $^      return$^    default$^      utilthrowexception hugerealloc called with type   mem.source$^  $^$^$^void mapreadloadmethod method int fd uint00t offset stdsizet size scopedmemory out $^  switch method $^    case lazy$^      out.resetmaporthrowsize false kfileflags false fd offset size scopedmemorymmapallocated$^      break$^    case populateorlazy$^ifdef mappopulate$^    case populateorread$^endif$^      out.resetmaporthrowsize false kfileflags true fd offset size scopedmemorymmapallocated$^      break$^ifndef mappopulate$^    case populateorread$^endif$^    case read$^      hugemallocsize false out$^      seekorthrowfd offset$^      readorthrowfd out.get size$^      break$^    case parallelread$^      hugemallocsize false out$^      parallelreadfd out.get size offset$^      break$^  $^$^$^void mapzeroedwriteint fd stdsizet size $^  resizeorthrowfd 0$^  resizeorthrowfd size$^  return maporthrowsize true kfileflags false fd 0$^$^$^void mapzeroedwriteconst char name stdsizet size scopedfd file $^  file.resetcreateorthrowname$^  try $^    return mapzeroedwritefile.get size$^   catch errnoexception e $^    e   in file   name$^    throw$^  $^$^$^rollingrollingconst rolling copyfrom uint00t increase $^  this  copyfrom$^  increasebaseincrease$^$^$^rolling rollingoperatorconst rolling copyfrom $^  fd  copyfrom.fd$^  filebegin  copyfrom.filebegin$^  fileend  copyfrom.fileend$^  forwrite  copyfrom.forwrite$^  block  copyfrom.block$^  readbound  copyfrom.readbound$^$^  currentbegin  0$^  if copyfrom.ispassthrough $^    currentend  copyfrom.currentend$^    ptr  copyfrom.ptr$^   else $^     force call on next mmap.$^    currentend  0$^    ptr  null$^  $^  return this$^$^$^rollingrollingint fd bool forwrite stdsizet block stdsizet readbound uint00t offset uint00t amount $^  currentbegin  0$^  currentend  0$^  fd  fd$^  filebegin  offset$^  fileend  offset  amount$^  forwrite  forwrite$^  block  block$^  readbound  readbound$^$^$^void rollingextractnonrollingscopedmemory out uint00t index stdsizet size $^  out.reset$^  if ispassthrough return staticcastuint0tget  index$^  uint00t offset  index  filebegin$^   round down to multiple of page size.$^  uint00t cruft  offset  staticcastuint00tsizepage$^  stdsizet mapsize  staticcaststdsizetsize  cruft$^  out.resetmaporthrowmapsize forwrite kfileflags true fd offset  cruft mapsize scopedmemorymmapallocated$^  return staticcastuint0tout.get  staticcaststdsizetcruft$^$^$^void rollingrolluint00t index $^  assertispassthrough$^  stdsizet amount$^  if fileend  index  filebegin  staticcastuint00tblock $^    amount  block$^    currentend  index  amount  readbound$^   else $^    amount  fileend  index  filebegin$^    currentend  index  amount$^  $^  ptr  staticcastuint0textractnonrollingmem index amount  index$^$^  currentbegin  index$^$^$^  namespace util$^include utilmultiintersection.hh$^$^define boosttestmodule multiintersectiontest$^include boosttestunittest.hpp$^$^namespace util $^namespace $^$^boostautotestcaseempty $^  stdvectorboostiteratorrangeconst unsigned int  sets$^$^  sets.pushbackboostiteratorrangeconst unsigned intstaticcastconst unsigned intnull staticcastconst unsigned intnull$^  boostcheckfirstintersectionsets$^$^$^boostautotestcasesingle $^  stdvectorunsigned int nums$^  nums.pushback0$^  nums.pushback0$^  nums.pushback000$^  stdvectorboostiteratorrangestdvectorunsigned intconstiterator  sets$^  sets.pushbacknums$^$^  boostoptionalunsigned int retfirstintersectionsets$^$^  boostrequireret$^  boostcheckequalstaticcastunsigned int0 ret$^$^$^template class t unsigned int len boostiteratorrangeconst t rangefromarrayconst t arrlen $^  return boostiteratorrangeconst tarr arr  len$^$^$^boostautotestcasemultinone $^  unsigned int nums0  0 0 0 00$^  unsigned int nums0  0 0 00$^  unsigned int nums0  0 00$^$^  stdvectorboostiteratorrangeconst unsigned int  sets$^  sets.pushbackrangefromarraynums0$^  sets.pushbackrangefromarraynums0$^  sets.pushbackrangefromarraynums0$^$^  boostcheckfirstintersectionsets$^$^$^boostautotestcasemultione $^  unsigned int nums0  0 0 0 00 00$^  unsigned int nums0  0 0 00 00$^  unsigned int nums0  0 00$^$^  stdvectorboostiteratorrangeconst unsigned int  sets$^  sets.pushbackrangefromarraynums0$^  sets.pushbackrangefromarraynums0$^  sets.pushbackrangefromarraynums0$^$^  boostoptionalunsigned int retfirstintersectionsets$^  boostrequireret$^  boostcheckequalstaticcastunsigned int00 ret$^$^$^  namespace$^  namespace util$^include utilfilepiece.hh$^$^include utildoubleconversiondoubleconversion.h$^include utilexception.hh$^include utilfile.hh$^include utilmmap.hh$^$^if definedwin00  definedwin00$^include io.h$^else$^include unistd.h$^endif$^$^include algorithm$^include cassert$^include cerrno$^include cmath$^include cstdlib$^include iostream$^include limits$^include string$^$^include fcntl.h$^include systypes.h$^include sysstat.h$^$^if definedwin00  definedwin00$^include math.h$^endif$^$^namespace util $^$^namespace  const uint00t kpagesize  sizepage $^$^parsenumberexceptionparsenumberexceptionstringpiece value throw $^  this  could not parse   value   into a $^$^$^lineiterator lineiteratoroperator $^  if backingreadlineoreofline delim$^    backing  null$^  return this$^$^$^filepiecefilepiececonst char name stdostream showprogress stdsizet minbuffer $^  fileopenreadorthrowname totalsizesizefilefile.get$^  progresstotalsize totalsize  kbadsize  null  showprogress stdstringreading   name $^  initializename showprogress minbuffer$^$^$^namespace $^stdstring namepossiblyfindint fd const char name $^  if name return name$^  return namefromfdfd$^$^  namespace$^$^filepiecefilepieceint fd const char name stdostream showprogress stdsizet minbuffer $^  filefd totalsizesizefilefile.get$^  progresstotalsize totalsize  kbadsize  null  showprogress stdstringreading   namepossiblyfindfd name $^  initializenamepossiblyfindfd name.cstr showprogress minbuffer$^$^$^filepiecefilepiecestdistream stream const char name stdsizet minbuffer $^  totalsizekbadsize $^  initializenoreadistream minbuffer$^$^  fallbacktoread  true$^  hugemallocdefaultmapsize false data$^  position  data.begin$^  positionend  position$^$^  fellback.resetstream$^$^$^stringpiece filepiecereadlinechar delim bool stripcr $^  stdsizet skip  0$^  while true $^    const char i  stdfindposition  skip positionend delim$^    if utillikelyi  positionend $^       end of line.$^       take 0 byte off the end if its an unwanted carriage return.$^      const stdsizet subtractcr  $^          stripcr  i  position  i  0  r $^          0  0$^      stringpiece retposition i  position  subtractcr$^      position  i  0$^      return ret$^    $^    if atend $^      if position  positionend $^        shift$^      $^      return consumepositionend$^    $^    skip  positionend  position$^    shift$^  $^$^$^bool filepiecereadlineoreofstringpiece to char delim bool stripcr $^  try $^    to  readlinedelim stripcr$^   catch const utilendoffileexception e  return false $^  return true$^$^$^float filepiecereadfloat $^  return readnumberfloat$^$^double filepiecereaddouble $^  return readnumberdouble$^$^long int filepiecereadlong $^  return readnumberlong int$^$^unsigned long int filepiecereadulong $^  return readnumberunsigned long int$^$^$^ factored out so that istream can call this.$^void filepieceinitializenoreadconst char name stdsizet minbuffer $^  filename  name$^$^  defaultmapsize  kpagesize  stdmaxstdsizetminbuffer  kpagesize  0 0$^  position  null$^  positionend  null$^  mappedoffset  0$^  atend  false$^$^$^void filepieceinitializeconst char name stdostream showprogress stdsizet minbuffer $^  initializenoreadname minbuffer$^  uint00t currentoffset$^  bool validcurrentoffset$^  try $^    currentoffset  advanceorthrowfile.get 0$^    validcurrentoffset  true$^   catch const fdexception  $^    currentoffset  0$^    validcurrentoffset  false$^  $^$^   so the assertion in transitiontoread passes$^  fallbacktoread  false$^  if totalsize  kbadsize  validcurrentoffset $^    if showprogress$^      showprogress  file   name   isnt normal.  using slower read instead of mmap.  no progress bar.  stdendl$^    transitiontoread$^   else $^    mappedoffset  currentoffset$^  $^  shift$^   gzip detect.$^  if positionend  position  readcompressedkmagicsize  readcompresseddetectcompressedmagicposition $^    if fallbacktoread $^      atend  false$^      transitiontoread$^    $^  $^$^$^namespace $^$^static const kenlmdoubleconversionstringtodoubleconverter kconverter$^    kenlmdoubleconversionstringtodoubleconverterallowtrailingjunk  kenlmdoubleconversionstringtodoubleconverterallowleadingspaces$^    stdnumericlimitsdoublequietnan$^    stdnumericlimitsdoublequietnan$^    inf$^    nan$^$^stringpiece firsttokenstringpiece str $^  const char i$^  for i  str.data i  str.data  str.size i $^    if kspacesunsigned chari break$^  $^  return stringpiecestr.data i  str.data$^$^$^ stdisnan is technically c00 not c00.  but in practice this is a problem for visual studio.$^template class t inline int crossplatformisnant value $^if definedwin00  definedwin00$^  return isnanvalue$^else$^  return stdisnanvalue$^endif$^$^$^const char parsenumberstringpiece str float out $^  int count$^  out  kconverter.stringtofloatstr.data str.size count$^  utilthrowifargcrossplatformisnanout  str  nan  str  nan parsenumberexception firsttokenstr float$^  return str.data  count$^$^const char parsenumberstringpiece str double out $^  int count$^  out  kconverter.stringtodoublestr.data str.size count$^  utilthrowifargcrossplatformisnanout  str  nan  str  nan parsenumberexception firsttokenstr double$^  return str.data  count$^$^const char parsenumberstringpiece str long int out $^  char end$^  errno  0$^  out  strtolstr.data end 00$^  utilthrowifargerrno  end  str.data parsenumberexception firsttokenstr long int$^  return end$^$^const char parsenumberstringpiece str unsigned long int out $^  char end$^  errno  0$^  out  strtoulstr.data end 00$^  utilthrowifargerrno  end  str.data parsenumberexception firsttokenstr unsigned long int$^  return end$^$^  namespace$^$^template class t t filepiecereadnumber $^  skipspaces$^  while lastspace  position $^    if utilunlikelyatend $^       hallucinate a null off the end of the file.$^      stdstring bufferposition positionend$^      t ret$^       has to be nullterminated.$^      const char begin  buffer.cstr$^      const char end  parsenumberstringpiecebegin buffer.size ret$^      position  end  begin$^      return ret$^    $^    shift$^  $^  t ret$^  position  parsenumberstringpieceposition lastspace  position ret$^  return ret$^$^$^const char filepiecefinddelimiteroreofconst bool delim  $^  stdsizet skip  0$^  while true $^    for const char i  position  skip i  positionend i $^      if delimstaticcastunsigned chari return i$^    $^    if atend $^      if position  positionend shift$^      return positionend$^    $^    skip  positionend  position$^    shift$^  $^$^$^void filepieceshift $^  if atend $^    progress.finished$^    throw endoffileexception$^  $^  uint00t desiredbegin  position  data.begin  mappedoffset$^$^  if fallbacktoread mmapshiftdesiredbegin$^   notice an mmap failure might set the fallback.$^  if fallbacktoread readshift$^$^  for lastspace  positionend  0 lastspace  position lastspace $^    if kspacesstaticcastunsigned charlastspace  break$^  $^$^$^void filepieceupdateprogress $^  if fallbacktoread$^    progress.setposition  data.begin  mappedoffset$^$^$^void filepiecemmapshiftuint00t desiredbegin $^   use mmap.$^  uint00t ignore  desiredbegin  kpagesize$^   duplicate request for shift means give more data.$^  if position  data.begin  ignore  position $^    defaultmapsize  0$^  $^   local version so that in case of failure it doesnt overwrite the class variable.$^  uint00t mappedoffset  desiredbegin  ignore$^$^  uint00t mappedsize$^  if defaultmapsize  staticcaststdsizettotalsize  mappedoffset $^    atend  true$^    mappedsize  totalsize  mappedoffset$^   else $^    mappedsize  defaultmapsize$^  $^$^   forcibly clear the existing mmap first.$^  data.reset$^  try $^    mapreadpopulateorlazy file mappedoffset mappedsize data$^   catch const utilerrnoexception e $^    if desiredbegin $^      seekorthrowfile desiredbegin$^    $^     the mmap was scheduled to end the file but now were going to read it.$^    atend  false$^    transitiontoread$^    return$^  $^  mappedoffset  mappedoffset$^  position  data.begin  ignore$^  positionend  data.begin  mappedsize$^$^  progress.setdesiredbegin$^$^$^void filepiecetransitiontoread $^  assertfallbacktoread$^  fallbacktoread  true$^  data.reset$^  hugemallocdefaultmapsize false data$^  position  data.begin$^  positionend  position$^$^  try $^    fellback.resetfile.release$^   catch utilexception e $^    e   in file   filename$^    throw$^  $^$^$^void filepiecereadshift $^  assertfallbacktoread$^   bytes data.begin position have been consumed.$^   bytes position positionend have been read into the buffer.$^$^   start at the beginning of the buffer if theres nothing useful in it.$^  if position  positionend $^    mappedoffset  positionend  data.begin$^    position  data.begin$^    positionend  position$^  $^$^  stdsizet alreadyread  positionend  data.begin$^$^  if alreadyread  defaultmapsize $^    if position  data.begin $^       buffer too small.$^      stdsizet validlength  positionend  position$^      defaultmapsize  0$^      hugereallocdefaultmapsize false data$^      position  data.begin$^      positionend  position  validlength$^     else $^      stdsizet moving  positionend  position$^      memmovedata.get position moving$^      position  data.begin$^      positionend  position  moving$^      alreadyread  moving$^    $^  $^$^  stdsizet readreturn  fellback.readstaticcastuint0tdata.get  alreadyread defaultmapsize  alreadyread$^  progress.setfellback.rawamount$^$^  if readreturn  0 $^    atend  true$^  $^  positionend  readreturn$^$^$^  namespace util$^include utilbitpacking.hh$^$^define boosttestmodule bitpackingtest$^include boosttestunittest.hpp$^$^include cstring$^$^namespace util $^namespace $^$^const uint00t test00  0x000000000abcdefull$^const uint00t test00  0x0000000$^$^boostautotestcasezerobit00 $^  char mem00$^  memsetmem 0 sizeofmem$^  writeint00mem 0 00 test00$^  boostcheckequaltest00 readint00mem 0 00 0ull  00  0$^$^$^boostautotestcaseeachbit00 $^  char mem00$^  for uint0t b  0 b  0 b $^    memsetmem 0 sizeofmem$^    writeint00mem b 00 test00$^    boostcheckequaltest00 readint00mem b 00 0ull  00  0$^  $^$^$^boostautotestcaseconsecutive00 $^  char mem000$^  memsetmem 0 sizeofmem$^  for uint00t b  0 b  00  0 b  00 $^    writeint00mem b 00 test00$^    boostcheckequaltest00 readint00mem b 00 0ull  00  0$^  $^  for uint00t b  0 b  00  0 b  00 $^    boostcheckequaltest00 readint00mem b 00 0ull  00  0$^  $^$^$^boostautotestcaseconsecutive00 $^  char mem000$^  memsetmem 0 sizeofmem$^  for uint00t b  0 b  00  0 b  00 $^    writeint00mem b 00 test00$^    boostcheckequaltest00 readint00mem b 00 0ull  00  0$^  $^  for uint00t b  0 b  00  0 b  00 $^    boostcheckequaltest00 readint00mem b 00 0ull  00  0$^  $^$^$^boostautotestcasesanity $^  bitpackingsanity$^$^$^  namespace$^  namespace util$^ copyright 0000 the re0 authors.  all rights reserved.$^ use of this source code is governed by a bsdstyle$^ license that can be found in stringpiece.hh.$^$^include utilstringpiece.hh$^$^include algorithm$^include climits$^$^ifndef haveicu$^$^typedef stringpiecesizetype sizetype$^$^void stringpiececopytostringstdstring target const $^  targetassignptr length$^$^$^sizetype stringpiecefindconst stringpiece s sizetype pos const $^   not sure why length  0 was here since its stdsizet.$^  if length  0  pos  staticcastsizetypelength$^    return npos$^$^  const char result  stdsearchptr  pos ptr  length$^                                   s.ptr s.ptr  s.length$^  const sizetype xpos  result  ptr$^  return xpos  s.length  length  xpos  npos$^$^$^sizetype stringpiecefindchar c sizetype pos const $^  if length  0  pos  staticcastsizetypelength $^    return npos$^  $^  const char result  stdfindptr  pos ptr  length c$^  return result  ptr  length  result  ptr  npos$^$^$^sizetype stringpiecerfindconst stringpiece s sizetype pos const $^  if length  s.length return npos$^  const sizet ulen  length$^  if s.length  0 return stdminulen pos$^$^  const char last  ptr  stdminulen  s.length pos  s.length$^  const char result  stdfindendptr last s.ptr s.ptr  s.length$^  return result  last  result  ptr  npos$^$^$^sizetype stringpiecerfindchar c sizetype pos const $^  if length  0 return npos$^  for int i  stdminpos staticcastsizetypelength  0$^       i  0 i $^    if ptri  c $^      return i$^    $^  $^  return npos$^$^$^ for each character in characterswanted sets the index corresponding$^ to the ascii code of that character to 0 in table.  this is used by$^ the find.of methods below to tell whether or not a character is in$^ the lookup table in constant time.$^ the argument table must be an array that is large enough to hold all$^ the possible values of an unsigned char.  thus it should be be declared$^ as follows$^   bool tableucharmax  0$^static inline void buildlookuptableconst stringpiece characterswanted$^                                    bool table $^  const sizetype length  characterswanted.length$^  const char const data  characterswanted.data$^  for sizetype i  0 i  length i $^    tablestaticcastunsigned chardatai  true$^  $^$^$^sizetype stringpiecefindfirstofconst stringpiece s$^                                     sizetype pos const $^  if length  0  s.length  0$^    return npos$^$^   avoid the cost of buildlookuptable for a singlecharacter search.$^  if s.length  0$^    return findfirstofs.ptr0 pos$^$^  bool lookupucharmax  0   false $^  buildlookuptables lookup$^  for sizetype i  pos i  length i $^    if lookupstaticcastunsigned charptri $^      return i$^    $^  $^  return npos$^$^$^sizetype stringpiecefindfirstnotofconst stringpiece s$^                                         sizetype pos const $^  if length  0$^    return npos$^$^  if s.length  0$^    return 0$^$^   avoid the cost of buildlookuptable for a singlecharacter search.$^  if s.length  0$^    return findfirstnotofs.ptr0 pos$^$^  bool lookupucharmax  0   false $^  buildlookuptables lookup$^  for sizetype i  pos i  length i $^    if lookupstaticcastunsigned charptri $^      return i$^    $^  $^  return npos$^$^$^sizetype stringpiecefindfirstnotofchar c sizetype pos const $^  if length  0$^    return npos$^$^  for  pos  length pos $^    if ptrpos  c $^      return pos$^    $^  $^  return npos$^$^$^sizetype stringpiecefindlastofconst stringpiece s sizetype pos const $^  if length  0  s.length  0$^    return npos$^$^   avoid the cost of buildlookuptable for a singlecharacter search.$^  if s.length  0$^    return findlastofs.ptr0 pos$^$^  bool lookupucharmax  0   false $^  buildlookuptables lookup$^  for sizetype i  stdminpos length  0  i $^    if lookupstaticcastunsigned charptri$^      return i$^    if i  0$^      break$^  $^  return npos$^$^$^sizetype stringpiecefindlastnotofconst stringpiece s$^                                        sizetype pos const $^  if length  0$^    return npos$^$^  sizetype i  stdminpos length  0$^  if s.length  0$^    return i$^$^   avoid the cost of buildlookuptable for a singlecharacter search.$^  if s.length  0$^    return findlastnotofs.ptr0 pos$^$^  bool lookupucharmax  0   false $^  buildlookuptables lookup$^  for   i $^    if lookupstaticcastunsigned charptri$^      return i$^    if i  0$^      break$^  $^  return npos$^$^$^sizetype stringpiecefindlastnotofchar c sizetype pos const $^  if length  0$^    return npos$^$^  for sizetype i  stdminpos length  0  i $^    if ptri  c$^      return i$^    if i  0$^      break$^  $^  return npos$^$^$^stringpiece stringpiecesubstrsizetype pos sizetype n const $^  if pos  length pos  length$^  if n  length  pos n  length  pos$^  return stringpieceptr  pos n$^$^$^const sizetype stringpiecenpos  sizetype0$^$^endif  haveicu$^include utilbitpacking.hh$^include utilexception.hh$^$^include cstring$^$^namespace util $^$^namespace $^template bool struct staticcheck $^template  struct staticchecktrue  typedef bool staticassertionpassed $^$^ if your float isnt 0 bytes were hosed.$^typedef staticchecksizeoffloat  0staticassertionpassed floatsize$^$^  namespace$^$^uint0t requiredbitsuint00t maxvalue $^  if maxvalue return 0$^  uint0t ret  0$^  while maxvalue  0 ret$^  return ret$^$^$^void bitpackingsanity $^  const floatenc neg0   0.0  pos0   0.0 $^  if neg0.i  pos0.i  0x00000000 utilthrowexception sign bit is not 0x00000000$^  char mem000$^  memsetmem 0 sizeofmem$^  const uint00t test00  0x000000000abcdefull$^  for uint00t b  0 b  00  0 b  00 $^    writeint00mem b 00 test00$^  $^  for uint00t b  0 b  00  0 b  00 $^    if test00  readint00mem b 00 0ull  00  0$^      utilthrowexception the bit packing routines are failing for your architecture.  please send a bug report with your architecture operating system and compiler.$^  $^   todo more checks.$^$^$^  namespace util$^include utilusage.hh$^$^include utilexception.hh$^$^include fstream$^include ostream$^include sstream$^include set$^include string$^include cstring$^include cctype$^include ctime$^if definedwin00  definedwin00$^ this code lifted from physmem.c in gnulib.  see the copyright statement$^ below.$^ define win00leanandmean$^ include windows.h$^  memorystatusex is missing from older windows headers so define$^    a local replacement.  $^typedef struct$^$^  dword dwlength$^  dword dwmemoryload$^  dwordlong ulltotalphys$^  dwordlong ullavailphys$^  dwordlong ulltotalpagefile$^  dwordlong ullavailpagefile$^  dwordlong ulltotalvirtual$^  dwordlong ullavailvirtual$^  dwordlong ullavailextendedvirtual$^ lmemorystatusex$^ is this really supposed to be defined like this$^typedef int winbool$^typedef winbool winapi pfnmsex lmemorystatusex$^else$^include sysresource.h$^include systime.h$^include unistd.h$^endif$^$^if definedmach  definedfreebsd  definedapple$^include systypes.h$^include syssysctl.h$^include machtask.h$^include machmach.h$^endif$^$^namespace util $^namespace $^$^if definedmach$^typedef struct timeval wall$^wall getwall $^  struct timeval tv$^  gettimeofdaytv null$^  return tv$^$^elif definedwin00  definedwin00$^typedef timet wall$^wall getwall $^  return timenull$^$^else$^typedef struct timespec wall$^wall getwall $^  wall ret$^  utilthrowif0  clockgettimeclockmonotonic ret errnoexception could not get wall time$^  return ret$^$^endif$^$^ gcc possibleunused function flags$^ifdef gnuc$^double subtracttimet first timet second attribute unused$^double doublesectimet tv attribute unused$^if definedwin00  definedwin00$^double subtractconst struct timeval first const struct timeval second attribute unused$^double subtractconst struct timespec first const struct timespec second attribute unused$^double doublesecconst struct timeval tv attribute unused$^double doublesecconst struct timespec tv attribute unused$^endif$^endif$^$^ some of these functions are only used on some platforms.$^ifdef clang$^pragma clang diagnostic push$^pragma clang diagnostic ignored wunusedfunction$^endif$^ these all assume first  second$^double subtracttimet first timet second $^  return difftimefirst second$^$^double doublesectimet tv $^  return staticcastdoubletv$^$^if definedwin00  definedwin00$^double subtractconst struct timeval first const struct timeval second $^  return staticcastdoublefirst.tvsec  second.tvsec  staticcastdoublefirst.tvusec  second.tvusec  0000000.0$^$^double subtractconst struct timespec first const struct timespec second $^  return staticcastdoublefirst.tvsec  second.tvsec  staticcastdoublefirst.tvnsec  second.tvnsec  0000000000.0$^$^double doublesecconst struct timeval tv $^  return staticcastdoubletv.tvsec  staticcastdoubletv.tvusec  0000000.0$^$^double doublesecconst struct timespec tv $^  return staticcastdoubletv.tvsec  staticcastdoubletv.tvnsec  0000000000.0$^$^endif$^ifdef clang$^pragma clang diagnostic pop$^endif$^$^class recordstart $^  public$^    recordstart $^      started  getwall$^    $^$^    const wall started const $^      return started$^    $^$^  private$^    wall started$^$^$^const recordstart krecordstart$^$^const char skipspacesconst char at $^  for  at     at  t at $^  return at$^$^  namespace$^$^double walltime $^  return subtractgetwall krecordstart.started$^$^$^double cputime $^if definedwin00  definedwin00$^  return 0.0$^elif definedmach  definedfreebsd  definedapple$^  struct rusage usage$^  utilthrowifgetrusagerusageself usage errnoexception getrusage failed$^  return doublesecusage.ruutime  doublesecusage.rustime$^else$^  struct timespec usage$^  utilthrowifclockgettimeclockprocesscputimeid usage errnoexception clockgettime failed $^  return doublesecusage$^endif$^$^$^double threadtime $^if definedwin00  definedwin00$^   output parameters for querying thread cpu usage$^  filetime systime usertime$^   unused but apparently need to be passed$^  filetime ctime etime$^$^  handle thisthread  getcurrentthread$^  utilthrowifgetthreadtimesthisthread ctime etime systime usertime windowsexception getthreadtime$^   convert lpfiletime to 00bit number and from there to double.$^  ulargeinteger systicks userticks$^  systicks.lowpart  systime.dwlowdatetime$^  systicks.highpart  systime.dwhighdatetime$^  userticks.lowpart  usertime.dwlowdatetime$^  userticks.highpart  usertime.dwhighdatetime$^  const double ticks  doublesysticks.quadpart  userticks.quadpart$^   getthreadtimes reports in units of 000 nanoseconds i.e. tenmillionths$^   of a second.$^  return ticks  00  0000  0000$^elif definedmach  definedfreebsd  definedapple$^  struct taskbasicinfo tinfo$^  machmsgtypenumbert tinfocount  taskbasicinfocount  $^  taskinfomachtaskself taskbasicinfo taskinfottinfo tinfocount$^  $^  return 0.0$^else$^  struct timespec usage$^  utilthrowifclockgettimeclockthreadcputimeid usage errnoexception clockgettime failed $^  return doublesecusage$^endif$^$^$^uint00t rssmax $^if definedwin00  definedwin00$^  return 0$^else$^  struct rusage usage$^  if getrusagerusageself usage$^    return 0$^  return staticcastuint00tusage.rumaxrss  0000$^endif$^$^$^void printusagestdostream out $^if definedwin00  definedwin00$^   linux doesnt set memory usage in getrusage $^  stdsetstdstring headers$^  headers.insertvmpeak$^  headers.insertvmrss$^  headers.insertname$^$^  stdifstream statusprocselfstatus stdiosin$^  stdstring header value$^  while status  header  getlinestatus value $^    if headers.findheader  headers.end $^      out  header  skipspacesvalue.cstr  t$^    $^  $^$^  struct rusage usage$^  if getrusagerusageself usage $^    perrorgetrusage$^    return$^  $^  out  rssmax  usage.rumaxrss   kb  t$^  out  user  doublesecusage.ruutime  tsys  doublesecusage.rustime  t$^  out  cpu  cputime  t$^endif$^$^  out  real  walltime  n$^$^$^ adapted from physmem.c in gnulib 000b00c00ef000c00a00b00000000d00a0a0ba00 $^ calculate the size of physical memory.$^$^   copyright c 00000000 0000 00000000 00000000 free software$^   foundation inc.$^$^   this program is free software you can redistribute it andor modify$^   it under the terms of the gnu lesser general public license as published by$^   the free software foundation either version 0.0 of the license or$^   at your option any later version.$^$^   this program is distributed in the hope that it will be useful$^   but without any warranty without even the implied warranty of$^   merchantability or fitness for a particular purpose.  see the$^   gnu lesser general public license for more details.$^$^   you should have received a copy of the gnu lesser general public license$^   along with this program.  if not see httpwww.gnu.orglicenses.  $^$^ written by paul eggert.  $^uint00t guessphysicalmemory $^if definedscphyspages  definedscpagesize$^  $^    long pages  sysconfscphyspages$^    long pagesize  sysconfscpagesize$^    if pages  0  pagesize  0$^      return staticcastuint00tpages  staticcastuint00tpagesize$^  $^endif$^ifdef hwphysmem$^    this works on bsd and darwin.  $^    unsigned int physmem$^    sizet len  sizeof physmem$^    static int mib0   ctlhw hwphysmem $^$^    if sysctl mib sizeofmib  sizeofmib0 physmem len null 0  0$^         len  sizeof physmem$^      return staticcastuint00tphysmem$^  $^endif$^$^if definedwin00  definedwin00$^    this works on windows $^    pfnmsex pfnex$^    hmodule h  getmodulehandle textkernel00.dll$^$^    if h$^      return 0$^$^      use globalmemorystatusex if available.  $^    if pfnex  pfnmsex getprocaddress h globalmemorystatusex$^      $^        lmemorystatusex lmsex$^        lmsex.dwlength  sizeof lmsex$^        if pfnex lmsex$^          return 0$^        return lmsex.ulltotalphys$^      $^$^      fall back to globalmemorystatus which is always available.$^        but returns wrong results for physical memory  0gb.  $^    else$^      $^        memorystatus ms$^        globalmemorystatus ms$^        return ms.dwtotalphys$^      $^  $^endif$^  return 0$^$^$^namespace $^class sizeparseerror  public exception $^  public$^    explicit sizeparseerrorconst stdstring str throw $^      this  failed to parse   str   into a memory size $^    $^$^$^template class num uint00t parsenumconst stdstring arg $^  stdstringstream streamarg$^  num value$^  stream  value$^  utilthrowifargstream sizeparseerror arg for the leading number.$^  stdstring after$^  stream  after$^  utilthrowifargafter.size  0 sizeparseerror arg because there are more than two characters after the number.$^  stdstring throwaway$^  utilthrowifargstream  throwaway sizeparseerror arg because there was more cruft   throwaway   after the number.$^$^   silly sort using kilobytes as your default unit.$^  if after.empty after  k$^  if after   $^    uint00t mem  guessphysicalmemory$^    utilthrowifargmem sizeparseerror arg because  was specified but the physical memory size could not be determined.$^    return staticcastuint00tstaticcastdoublevalue  staticcastdoublemem  000.0$^  $^$^  if after  k after  k$^  stdstring unitsbkmgtpezy$^  stdstringsizetype index  units.findafter0$^  utilthrowifargindex  stdstringnpos sizeparseerror arg the allowed suffixes are   units  .$^  for stdstringsizetype i  0 i  index i $^    value  0000$^  $^  return staticcastuint00tvalue$^$^$^  namespace$^$^uint00t parsesizeconst stdstring arg $^  return arg.find.  stdstringnpos  parsenumdoublearg  parsenumuint00targ$^$^$^  namespace util$^include utiltokenizepiece.hh$^include utilstringpiece.hh$^$^define boosttestmodule tokeniteratortest$^include boosttestunittest.hpp$^$^include iostream$^$^namespace util $^namespace $^$^boostautotestcasepipepipenone $^  const char str  nodelimit at all$^  tokenitermulticharacter itstr multicharacter$^  boostrequireit$^  boostcheckequalstringpiecestr it$^  it$^  boostcheckit$^$^boostautotestcasepipepipetwo $^  const char str  $^  tokenitermulticharacter itstr multicharacter$^  boostrequireit$^  boostcheckequalstringpiece it$^  it$^  boostrequireit$^  boostcheckequalstringpiece it$^  it$^  boostcheckit$^$^$^boostautotestcaseremoveempty $^  const char str  $^  tokenitermulticharacter true itstr multicharacter$^  boostcheckit$^$^$^boostautotestcaseremoveemptykeep $^  const char str   $^  tokenitermulticharacter true itstr multicharacter$^  boostrequireit$^  boostcheckequalstringpiece  it$^  it$^  boostcheckit$^$^$^  namespace$^  namespace util$^define largefile00source$^define fileoffsetbits 00$^$^include utilfile.hh$^$^include utilexception.hh$^$^include algorithm$^include cstdlib$^include cstdio$^include iostream$^include limits$^include stdexcept$^include sstream$^$^include cassert$^include cerrno$^include climits$^include systypes.h$^include sysstat.h$^include fcntl.h$^include stdint.h$^$^if definedmingw00$^include windows.h$^include unistd.h$^warning the file functions on mingw have not been tested for file sizes above 000  0.  please read httpsstackoverflow.comquestions00000000determine00bitfilesizeinconmingw00bit and fix$^elif definedwin00  definedwin00$^include windows.h$^include io.h$^else$^include unistd.h$^endif$^$^namespace util $^$^scopedfdscopedfd $^  if fd  0  closefd $^    stdcerr  could not close file   fd  stdendl$^    stdabort$^  $^$^$^void scopedfilecloserclosestdfile file $^  if file  stdfclosefile $^    stdcerr  could not close file   file  stdendl$^    stdabort$^  $^$^$^ note that errnoexception records errno before namefromfd is called.$^fdexceptionfdexceptionint fd throw  fdfd nameguessnamefromfdfd $^  this  in   nameguess   $^$^$^fdexceptionfdexception throw $^$^endoffileexceptionendoffileexception throw $^  this  end of file$^$^endoffileexceptionendoffileexception throw $^$^bool inputfileisstdinstringpiece path $^  return path    path  devstdin$^$^$^bool outputfileisstdoutstringpiece path $^  return path    path  devstdout$^$^$^int openreadorthrowconst char name $^  int ret$^if definedwin00  definedwin00$^  utilthrowif0  ret  openname obinary  ordonly errnoexception while opening   name$^else$^  utilthrowif0  ret  openname ordonly errnoexception while opening   name$^endif$^  return ret$^$^$^int createorthrowconst char name $^  int ret$^if definedwin00  definedwin00$^  utilthrowif0  ret  openname ocreat  otrunc  ordwr  obinary siread  siwrite errnoexception while creating   name$^else$^  utilthrowif0  ret  openname ocreat  otrunc  ordwr sirusr  siwusr  sirgrp  siroth errnoexception while creating   name$^endif$^  return ret$^$^$^uint00t sizefileint fd $^if defined mingw00$^  struct stat sb$^   does this handle 00bit$^  int ret  fstatfd sb$^  if ret  0  sb.stsize  sisregsb.stmode return kbadsize$^  return sb.stsize$^elif definedwin00  definedwin00$^  int00 ret  filelengthi00fd$^  return ret  0  kbadsize  ret$^else  not windows.$^$^ifdef osandroid$^  struct stat00 sb$^  int ret  fstat00fd sb$^else$^  struct stat sb$^  int ret  fstatfd sb$^endif$^  if ret  0  sb.stsize  sisregsb.stmode return kbadsize$^  return sb.stsize$^endif$^$^$^uint00t sizeorthrowint fd $^  uint00t ret  sizefilefd$^  utilthrowifargret  kbadsize fdexception fd failed to size$^  return ret$^$^$^void resizeorthrowint fd uint00t to $^if defined mingw00$^     does this handle 00bit$^    int ret  ftruncate$^elif definedwin00  definedwin00$^    errnot ret  chsizes$^elif definedosandroid$^    int ret  ftruncate00$^else$^    int ret  ftruncate$^endif$^    fd to$^  utilthrowifargret fdexception fd while resizing to   to   bytes$^$^$^void holepunchint fd uint00t offset uint00t size $^if definedlinux  definedfallocflpunchhole  definedfallocflkeepsize$^  utilthrowifarg0  fallocatefd fallocflpunchhole  fallocflkeepsize offset size fdexception fd in punching a hole at   offset   for   size   bytes.$^else$^  utilthrowunsupportedosexception fallocate hole punching requires linux and glibc  0.00$^endif$^$^$^namespace $^stdsizet guardlargestdsizet size $^   the following operating systems have broken readwritepreadpwrite that$^   only supports up to 000.$^   os x man pages claim to support 00bit but kareem m. darwish had problems$^   building with larger files so apple is also here.$^if definedwin00  definedwin00  definedapple  definedosandroid  definedmingw00$^  return size  intmax  size  intmax$^else$^  return size$^endif$^$^$^$^if definedwin00  definedwin00$^namespace $^const stdsizet kmaxdword  staticcaststdsizet0000000000ul$^  namespace$^endif$^$^stdsizet partialreadint fd void to stdsizet amount $^if definedwin00  definedwin00$^    dword ret$^    handle filehandle  reinterpretcasthandlegetosfhandlefd$^    dword largersize  staticcastdwordstdminstdsizetkmaxdword amount$^    dword smallersize  00000  received reports that 00000 worked but higher values did not. this rounds down to the nearest multiple of 0000 the page size.$^    if readfilefilehandle to largersize ret null$^    $^        dword lasterror  getlasterror$^        if lasterror  errornotenoughmemory  readfilefilehandle to smallersize ret null $^            utilthrowwindowsexception windows error in readfile.$^        $^    $^else$^  errno  0$^  ssizet ret$^  do $^    ret  readfd to guardlargeamount$^   while ret  0  errno  eintr$^  utilthrowifargret  0 fdexception fd while reading   amount   bytes$^endif$^  return staticcaststdsizetret$^$^$^void readorthrowint fd void tovoid stdsizet amount $^  uint0t to  staticcastuint0ttovoid$^  while amount $^    stdsizet ret  partialreadfd to amount$^    utilthrowifret  0 endoffileexception  in   namefromfdfd   but there should be   amount   more bytes to read.$^    amount  ret$^    to  ret$^  $^$^$^stdsizet readoreofint fd void tovoid stdsizet amount $^  uint0t to  staticcastuint0ttovoid$^  stdsizet remaining  amount$^  while remaining $^    stdsizet ret  partialreadfd to remaining$^    if ret return amount  remaining$^    remaining  ret$^    to  ret$^  $^  return amount$^$^$^void writeorthrowint fd const void datavoid stdsizet size $^  const uint0t data  staticcastconst uint0tdatavoid$^  while size $^if definedwin00  definedwin00$^    int ret$^else$^    ssizet ret$^endif$^    errno  0$^    do $^      ret $^if definedwin00  definedwin00$^        write$^else$^        write$^endif$^        fd data guardlargesize$^     while ret  0  errno  eintr$^    utilthrowifargret  0 fdexception fd while writing   size   bytes$^    data  ret$^    size  ret$^  $^$^$^void writeorthrowfile to const void data stdsizet size $^  if size return$^  utilthrowif0  stdfwritedata size 0 to errnoexception short write requested size   size$^$^$^void ersatzpreadint fd void tovoid stdsizet size uint00t off $^  uint0t to  staticcastuint0ttovoid$^  while size $^if definedwin00  definedwin00$^     broken changes file pointer.  even if you save it and change it back it wont be safe to use concurrently with write or read which lmplz does. $^     sizet might be 00bit.  dword is always 00.$^    dword reading  staticcastdwordstdminstdsizetkmaxdword size$^    dword ret$^    overlapped overlapped$^    memsetoverlapped 0 sizeofoverlapped$^    overlapped.offset  staticcastdwordoff$^    overlapped.offsethigh  staticcastdwordoff  00$^    utilthrowifreadfilehandlegetosfhandlefd to reading ret overlapped windowsexception readfile failed for offset   off$^else$^    ssizet ret$^    errno  0$^    ret $^ifdef osandroid$^      pread00$^else$^      pread$^endif$^      fd to guardlargesize off$^    if ret  0 $^      if ret  0  errno  eintr continue$^      utilthrowifret  0 endoffileexception  for reading   size   bytes at   off   from   namefromfdfd$^      utilthrowargfdexception fd while reading   size   bytes at offset   off$^    $^endif$^    size  ret$^    off  ret$^    to  ret$^  $^$^$^void ersatzpwriteint fd const void fromvoid stdsizet size uint00t off $^  const uint0t from  staticcastconst uint0tfromvoid$^  whilesize $^if definedwin00  definedwin00$^     changes file pointer.  even if you save it and change it back it wont be safe to use concurrently with write or read $^     sizet might be 00bit.  dword is always 00.$^    dword writing  staticcastdwordstdminstdsizetkmaxdword size$^    dword ret$^    overlapped overlapped$^    memsetoverlapped 0 sizeofoverlapped$^    overlapped.offset  staticcastdwordoff$^    overlapped.offsethigh  staticcastdwordoff  00$^    utilthrowifwritefilehandlegetosfhandlefd from writing ret overlapped exception writefile failed for offset   off$^else$^    ssizet ret$^    errno  0$^    ret $^ifdef osandroid$^      pwrite00$^else$^      pwrite$^endif$^      fd from guardlargesize off$^    if ret  0 $^      if ret  0  errno  eintr continue$^      utilthrowifret  0 endoffileexception  for writing   size   bytes at   off   from   namefromfdfd$^      utilthrowargfdexception fd while writing   size   bytes at offset   off$^    $^endif$^    size  ret$^    off  ret$^    from  ret$^  $^$^$^$^void fsyncorthrowint fd $^ apparently windows doesnt have fsync$^if definedwin00  definedwin00$^  utilthrowifarg0  fsyncfd fdexception fd while syncing$^endif$^$^$^namespace $^$^ static assert for 00bit offt size.$^if definedwin00  definedwin00  definedosandroid$^template unsigned struct checkofft$^template  struct checkofft0 $^  struct true $^$^ if theres a compiler error on the next line then offt isnt 00 bit.  and$^ that makes me a sad panda.$^typedef checkofftsizeofoffttrue ignoredtype$^endif$^$^ cant we all just get along$^uint00t internalseekint fd int00t off int whence $^if defined mingw00$^   does this handle 00bit$^  typedef offt offset$^  offset ret  lseekfd off whence$^elif definedwin00  definedwin00$^  typedef int00 offset$^  offset ret  lseeki00fd off whence$^elif definedosandroid$^  typedef off00t offset$^  offset ret  lseek00fd off whence$^else$^  typedef offt offset$^  offset ret  lseekfd off whence$^endif$^  utilthrowifargoffset0  ret fdexception fd while seeking to   off   whence   whence$^  return uint00tret$^$^  namespace$^$^uint00t seekorthrowint fd uint00t off $^  return internalseekfd off seekset$^$^$^uint00t advanceorthrowint fd int00t off $^  return internalseekfd off seekcur$^$^$^uint00t seekendint fd $^  return internalseekfd 0 seekend$^$^$^stdfile fdopenorthrowscopedfd file $^  stdfile ret  fdopenfile.get rb$^  utilthrowifargret fdexception file.get could not fdopen for write$^  file.release$^  return ret$^$^$^stdfile fdopenreadorthrowscopedfd file $^  stdfile ret  fdopenfile.get rb$^  utilthrowifargret fdexception file.get could not fdopen for read$^  file.release$^  return ret$^$^$^ sigh.  windows temporary file creation is full of race conditions.$^if definedwin00  definedwin00$^ mkstemp extracted from libcsysdepsposixtempname.c.  copyright$^   c 00000000 0000 0000 0000 free software foundation inc.$^$^   the gnu c library is free software you can redistribute it andor$^   modify it under the terms of the gnu lesser general public$^   license as published by the free software foundation either$^   version 0.0 of the license or at your option any later version.  $^$^ this has been modified from the original version to rename the function and$^  set the windows temporary flag. $^$^static const char letters $^abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0000000000$^$^ generate a temporary file name based on tmpl.  tmpl must match the$^   rules for mkstemp i.e. end in xxxxxx.  the name constructed$^   does not exist at the time of the call to mkstemp.  tmpl is$^   overwritten with the result.  $^int$^mkstempandunlinkchar tmpl$^$^  int len$^  char xxxxxx$^  static unsigned long long value$^  unsigned long long randomtimebits$^  unsigned int count$^  int fd  0$^  int saveerrno  errno$^$^   a lower bound on the number of temporary files to attempt to$^     generate.  the maximum total number of temporary file names that$^     can exist for a given template is 000.  it should never be$^     necessary to try all these combinations.  instead if a reasonable$^     number of names is tried we define reasonable as 000 fail to$^     give the system administrator the chance to remove the problems.  $^define attemptsmin 00  00  00$^$^   the number of times to attempt to generate a temporary file.  to$^     conform to posix this must be no smaller than tmpmax.  $^if attemptsmin  tmpmax$^  unsigned int attempts  tmpmax$^else$^  unsigned int attempts  attemptsmin$^endif$^$^  len  strlen tmpl$^  if len  0  strcmp tmpllen  0 xxxxxx$^    $^      errno  einval$^      return 0$^    $^$^ this is where the xs start.  $^  xxxxxx  tmpllen  0$^$^   get some more or less random data.  $^  $^    systemtime      stnow$^    filetime ftnow$^$^     get system time$^    getsystemtimestnow$^    stnow.wmilliseconds  000$^    if systemtimetofiletimestnow ftnow$^    $^        errno  0$^        return 0$^    $^$^    randomtimebits  unsigned long longftnow.dwhighdatetime  00$^                         unsigned long longftnow.dwlowdatetime$^  $^  value  randomtimebits  unsigned long longgetcurrentthreadid $^$^  for count  0 count  attempts value  0000 count$^  $^    unsigned long long v  value$^$^     fill in the random bits.  $^    xxxxxx0  lettersv  00$^    v  00$^    xxxxxx0  lettersv  00$^    v  00$^    xxxxxx0  lettersv  00$^    v  00$^    xxxxxx0  lettersv  00$^    v  00$^    xxxxxx0  lettersv  00$^    v  00$^    xxxxxx0  lettersv  00$^$^     modified for windows and to unlink $^          fd  open tmpl ordwr  ocreat  oexcl siread  siwrite$^    int flags  ordwr  ocreat  oexcl  obinary$^    flags  otemporary$^    fd  open tmpl flags siread  siwrite$^    if fd  0$^    $^      errno  saveerrno$^      return fd$^    $^    else if errno  eexist$^      return 0$^  $^$^   we got out of the loop because we ran out of combinations to try.  $^  errno  eexist$^  return 0$^$^else$^int$^mkstempandunlinkchar tmpl $^  int ret  mkstemptmpl$^  if ret  0 $^    utilthrowifunlinktmpl errnoexception while deleting   tmpl$^  $^  return ret$^$^endif$^$^ if its a directory add a .  this lets users say t tmp without creating$^ tmpaaaaaa$^void normalizetempprefixstdstring base $^  if base.empty return$^  if basebase.size  0   return$^  struct stat sb$^   its fine for it to not exist.$^  if 0  statbase.cstr sb return$^  if $^if definedwin00  definedwin00$^    sb.stmode  sifdir$^else$^    sisdirsb.stmode$^endif$^     base  $^$^$^int maketempconst stringpiece base $^  stdstring namebase.data base.size$^  name  xxxxxx$^  name.pushback0$^  int ret$^  utilthrowif0  ret  mkstempandunlinkname0 errnoexception while making a temporary based on   base$^  return ret$^$^$^stdfile fmaketempconst stringpiece base $^  utilscopedfd filemaketempbase$^  return fdopenorthrowfile$^$^$^stdstring defaulttempdirectory $^if definedwin00  definedwin00$^  char dirbuffer0000$^  if gettemppath0000 dirbuffer  0$^    throw stdruntimeerrorcould not read temporary directory.$^  stdstring retdirbuffer$^  normalizetempprefixret$^  return ret$^else$^   posix says to try these environment variables in this order$^  const char const vars  tmpdir tmp tempdir temp 0$^  for int i0 varsi i $^    char val $^if definedgnusource  definedglibcprereq$^if glibcprereq000$^      securegetenv$^else  glibcprereq$^      getenv$^endif  glibcprereq$^else  gnusource$^      getenv$^endif$^      varsi$^     environment variable is set and nonempty.  use it.$^    if val  val $^      stdstring retval$^      normalizetempprefixret$^      return ret$^    $^  $^   no environment variables set.  default to tmp.$^  return tmp$^endif$^$^$^int duporthrowint fd $^  int ret  dupfd$^  utilthrowifargret  0 fdexception fd in duplicating the file descriptor$^  return ret$^$^$^namespace $^ try to name things but be willing to fail too.$^bool trynameint fd stdstring out $^if definedwin00  definedwin00$^  return false$^else$^  stdstring nameprocselffd$^  stdostringstream convert$^  convert  fd$^  name  convert.str$^$^  struct stat sb$^  if 0  lstatname.cstr sb$^    return false$^  out.resizesb.stsize  0$^   lstat gave us a size but ive seen it grow possibly due to symlinks on top of symlinks.$^  while true $^    ssizet ret  readlinkname.cstr out0 out.size$^    if 0  ret$^      return false$^    if sizetret  out.size $^      out.resizeret$^      break$^    $^     exponential growth.$^    out.resizeout.size  0$^  $^   dont use the nonfile names.$^  if out.empty  out0  $^    return false$^  return true$^endif$^$^  namespace$^$^stdstring namefromfdint fd $^  stdstring ret$^  if trynamefd ret return ret$^  switch fd $^    case 0 return stdin$^    case 0 return stdout$^    case 0 return stderr$^  $^  ret  fd $^  stdostringstream convert$^  convert  fd$^  ret  convert.str$^  return ret$^$^$^  namespace util$^ like cat but interprets compressed files.$^include utilfile.hh$^include utilreadcompressed.hh$^$^include cstring$^include iostream$^$^namespace $^const stdsizet kbufsize  00000$^void copyutilreadcompressed from int to $^  utilscopedmalloc bufferutilmallocorthrowkbufsize$^  while stdsizet amount  from.readbuffer.get kbufsize $^    utilwriteorthrowto buffer.get amount$^  $^$^  namespace$^$^int mainint argc char argv $^   lane schwartz likes h and help$^  for int i  0 i  argc i $^    char arg  argvi$^    if strcmparg  break$^    if strcmparg h  strcmparg help $^      stdcerr $^        a cat implementation that interprets compressed files.n$^        usage   argv0   file0 file0 ...n$^        if no file is provided then stdin is read.n$^      return 0$^    $^  $^$^  try $^    if argc  0 $^      utilreadcompressed in0$^      copyin 0$^     else $^      for int i  0 i  argc i $^        utilreadcompressed inutilopenreadorthrowargvi$^        copyin 0$^      $^    $^   catch const stdexception e $^    stdcerr  e.what  stdendl$^    return 0$^  $^  return 0$^$^include utilparallelread.hh$^$^include utilfile.hh$^$^ifdef withthreads$^include utilthreadpool.hh$^$^namespace util $^namespace $^$^class reader $^  public$^    explicit readerint fd  fdfd $^$^    struct request $^      void to$^      stdsizet size$^      uint00t offset$^$^      bool operatorconst request other const $^        return to  other.to  size  other.size  offset  other.offset$^      $^    $^$^    void operatorconst request request $^      utilersatzpreadfd request.to request.size request.offset$^    $^$^  private$^    int fd$^$^$^  namespace$^$^void parallelreadint fd void to stdsizet amount uint00t offset $^  readerrequest poison$^  poison.to  null$^  poison.size  0$^  poison.offset  0$^  unsigned threads  boostthreadhardwareconcurrency$^  if threads threads  0$^  threadpoolreader pool0  dont need much of a queue  threads fd poison$^  const stdsizet kbatch  0ull  00  00 mb$^  readerrequest request$^  request.to  to$^  request.size  kbatch$^  request.offset  offset$^  for  amount  kbatch amount  kbatch $^    pool.producerequest$^    request.to  reinterpretcastuint0trequest.to  kbatch$^    request.offset  kbatch$^  $^  request.size  amount$^  if request.size $^    pool.producerequest$^  $^$^$^  namespace util$^$^else  withthreads$^$^namespace util $^void parallelreadint fd void to stdsizet amount uint00t offset $^ utilersatzpreadfd to amount offset$^$^  namespace util$^$^endif$^include utilersatzprogress.hh$^$^include algorithm$^include ostream$^include limits$^include string$^$^namespace util $^$^namespace  const unsigned char kwidth  000 $^$^const char kprogressbanner  0000000000000000000000000000000000000000n$^$^ersatzprogressersatzprogress  current0 nextstdnumericlimitsuint00tmax completenext outnull $^$^ersatzprogressersatzprogress $^  if out finished$^$^$^ersatzprogressersatzprogressuint00t complete stdostream to const stdstring message$^   current0 nextcomplete  kwidth completecomplete stoneswritten0 outto $^  if out $^    next  stdnumericlimitsuint00tmax$^    return$^  $^  if message.empty out  message  n$^  out  kprogressbanner$^$^$^void ersatzprogressmilestone $^  if out  current  0 return $^  if complete return$^  unsigned char stone  stdminstaticcastuint00tkwidth current  kwidth  complete$^$^  for  stoneswritten  stone stoneswritten $^    out  $^  $^  if stone  kwidth $^    out  stdendl$^    next  stdnumericlimitsuint00tmax$^    out  null$^   else $^    next  stdmaxnext stone  0  complete  kwidth  0  kwidth$^  $^$^$^  namespace util$^include utilreadcompressed.hh$^$^include utilfile.hh$^include utilhave.hh$^$^define boosttestmodule readcompressedtest$^include boosttestunittest.hpp$^include boostscopedptr.hpp$^$^include fstream$^include string$^include cstdlib$^$^if defined mingw00$^include ctime$^include fcntl.h$^$^if defined mkstemp$^ todo insecure$^int mkstempchar  stemplate$^$^    char filename  mktempstemplate$^    if filename  null$^        return 0$^    return openfilename ordwr  ocreat 0000$^$^endif$^$^endif  defined$^$^namespace util $^namespace $^$^void readloopreadcompressed reader void tovoid stdsizet amount $^  uint0t to  staticcastuint0ttovoid$^  while amount $^    stdsizet ret  reader.readto amount$^    boostrequireret$^    to  ret$^    amount  ret$^  $^$^$^const uint00t ksize0  000000  0$^$^stdstring writerandom $^  char name  tempxxxxxx$^  scopedfd originalmkstempname$^  boostrequireoriginal.get  0$^  for uint00t i  0 i  ksize0 i $^    writeorthroworiginal.get i sizeofuint00t$^  $^  return name$^$^$^void verifyreadreadcompressed reader $^  for uint00t i  0 i  ksize0 i $^    uint00t got$^    readloopreader got sizeofuint00t$^    boostcheckequali got$^  $^$^  char ignored$^  boostcheckequalstdsizet0 reader.readignored 0$^   test double eof call.$^  boostcheckequalstdsizet0 reader.readignored 0$^$^$^void testrandomconst char compressor $^  stdstring namewriterandom$^$^  char gzname  tempxxxxxx$^  scopedfd gzippedmkstempgzname$^$^  stdstring commandcompressor$^ifdef cygwin$^  command  .exe$^endif$^  command   $^  command  name$^  command   $^  command  gzname$^  command  $^  boostrequireequal0 systemcommand.cstr$^$^  boostcheckequal0 unlinkname.cstr$^  boostcheckequal0 unlinkgzname$^$^  readcompressed readergzipped.release$^  verifyreadreader$^$^$^boostautotestcaseuncompressed $^  testrandomcat$^$^$^ifdef havezlib$^boostautotestcasereadgz $^  testrandomgzip$^$^endif  havezlib$^$^ifdef havebzlib$^boostautotestcasereadbz $^  testrandombzip0$^$^endif  havebzlib$^$^ifdef havexzlib$^boostautotestcasereadxz $^  testrandomxz$^$^endif$^$^ifdef havezlib$^boostautotestcaseappendgz $^$^endif$^$^boostautotestcaseistream $^  stdstring namewriterandom$^  stdfstream streamname.cstr stdiosin$^  boostcheckequal0 unlinkname.cstr$^  readcompressed reader$^  reader.resetstream$^  verifyreadreader$^$^$^  namespace$^  namespace util$^ tests might fail if you have creative characters in your path.  sue me.$^include utilfilepiece.hh$^$^include utilfilestream.hh$^include utilfile.hh$^include utilscoped.hh$^$^define boosttestmodule filepiecetest$^include boosttestunittest.hpp$^include fstream$^include iostream$^include cstdio$^include systypes.h$^include sysstat.h$^$^namespace util $^namespace $^$^stdstring filelocation $^  if boostunittestframeworkmastertestsuite.argc  0 $^    return filepiece.cc$^  $^  stdstring retboostunittestframeworkmastertestsuite.argv0$^  return ret$^$^$^ istream $^boostautotestcaseistream $^  stdfstream reffilelocation.cstr stdiosin$^  stdfstream backingfilelocation.cstr stdiosin$^  filepiece testbacking$^  stdstring refline$^  while getlineref refline $^    stringpiece testlinetest.readline$^    boostcheckequalrefline testline$^  $^  boostcheckthrowtest.get endoffileexception$^  boostcheckthrowtest.get endoffileexception$^$^$^ mmap implementation $^boostautotestcasemmapreadline $^  stdfstream reffilelocation.cstr stdiosin$^  filepiece testfilelocation.cstr null 0$^  stdstring refline$^  while getlineref refline $^    stringpiece testlinetest.readline$^     i submitted a bug report to icu httpbugs.icuproject.orgtracticket0000$^    if testline.empty  refline.empty $^      boostcheckequalrefline testline$^    $^  $^  boostcheckthrowtest.get endoffileexception$^$^$^ mmap with seek beforehand $^boostautotestcasemmapseek $^  stdfstream reffilelocation.cstr stdiosin$^  ref.seekg00$^  scopedfd fileutilopenreadorthrowfilelocation.cstr$^  seekorthrowfile.get 00$^  filepiece testfile.release$^  stdstring refline$^  while getlineref refline $^    stringpiece testlinetest.readline$^     i submitted a bug report to icu httpbugs.icuproject.orgtracticket0000$^    if testline.empty  refline.empty $^      boostcheckequalrefline testline$^    $^  $^  boostcheckthrowtest.get endoffileexception$^$^$^if definedwin00  definedwin00  definedapple$^ apple isnt happy with the popen fileno dup.  and i dont want to$^  reimplement popen.  this is an issue with the test.$^ $^ read implementation $^boostautotestcasestreamreadline $^  stdfstream reffilelocation.cstr stdiosin$^$^  stdstring popenargs  cat $^  popenargs  filelocation$^  popenargs  $^$^  file catter  popenpopenargs.cstr r$^  boostrequirecatter$^$^  filepiece testdupfilenocatter filepiece.cc null 0$^  stdstring refline$^  while getlineref refline $^    stringpiece testlinetest.readline$^     i submitted a bug report to icu httpbugs.icuproject.orgtracticket0000$^    if testline.empty  refline.empty $^      boostcheckequalrefline testline$^    $^  $^  boostcheckthrowtest.get endoffileexception$^  boostrequirepclosecatter$^$^endif$^$^ifdef havezlib$^$^ gzip file$^boostautotestcaseplainzipreadline $^  stdstring locationfilelocation$^  stdfstream reflocation.cstr stdiosin$^$^  stdstring commandgzip $^  command  location     location  .gz$^$^  boostrequireequal0 systemcommand.cstr$^  filepiece testlocation  .gz.cstr null 0$^  unlinklocation  .gz.cstr$^  stdstring refline$^  while getlineref refline $^    stringpiece testlinetest.readline$^     i submitted a bug report to icu httpbugs.icuproject.orgtracticket0000$^    if testline.empty  refline.empty $^      boostcheckequalrefline testline$^    $^  $^  boostcheckthrowtest.get endoffileexception$^$^$^ gzip stream.  apple doesnt like popen fileno dup.  this is an issue with$^ the test.$^if defined apple  defined mingw00$^boostautotestcasestreamzipreadline $^  stdfstream reffilelocation.cstr stdiosin$^$^  stdstring commandgzip $^  command  filelocation  $^$^  file  catter  popencommand.cstr r$^  boostrequirecatter$^$^  filepiece testdupfilenocatter filepiece.cc.gz null 0$^  stdstring refline$^  while getlineref refline $^    stringpiece testlinetest.readline$^     i submitted a bug report to icu httpbugs.icuproject.orgtracticket0000$^    if testline.empty  refline.empty $^      boostcheckequalrefline testline$^    $^  $^  boostcheckthrowtest.get endoffileexception$^  boostrequirepclosecatter$^$^endif  apple$^$^endif  havezlib$^$^boostautotestcasenumbers $^  scopedfd filemaketempfilelocation$^  const float floating  0.0$^  $^    utilfilestream writingfile.get$^    writing  00000000000000000000000   floating   0$^  $^  seekorthrowfile.get 0$^  utilfilepiece ffile.release$^  boostcheckthrowf.readulong parsenumberexception$^  boostcheckequal00000000000000000000000 f.readdelimited$^   yes exactly equal.  isnt doubleconversion wonderful$^  boostcheckequalfloating f.readfloat$^  boostcheckequal0 f.readulong$^$^$^  namespace$^  namespace util$^ copyright 0000 the v0 project authors. all rights reserved.$^ redistribution and use in source and binary forms with or without$^ modification are permitted provided that the following conditions are$^ met$^$^      redistributions of source code must retain the above copyright$^       notice this list of conditions and the following disclaimer.$^      redistributions in binary form must reproduce the above$^       copyright notice this list of conditions and the following$^       disclaimer in the documentation andor other materials provided$^       with the distribution.$^      neither the name of google inc. nor the names of its$^       contributors may be used to endorse or promote products derived$^       from this software without specific prior written permission.$^$^ this software is provided by the copyright holders and contributors$^ as is and any express or implied warranties including but not$^ limited to the implied warranties of merchantability and fitness for$^ a particular purpose are disclaimed. in no event shall the copyright$^ owner or contributors be liable for any direct indirect incidental$^ special exemplary or consequential damages including but not$^ limited to procurement of substitute goods or services loss of use$^ data or profits or business interruption however caused and on any$^ theory of liability whether in contract strict liability or tort$^ including negligence or otherwise arising in any way out of the use$^ of this software even if advised of the possibility of such damage.$^$^include bignum.h$^include utils.h$^$^namespace kenlmdoubleconversion $^$^bignumbignum$^     bigitsbigitsbuffer kbigitcapacity useddigits0 exponent0 $^  for int i  0 i  kbigitcapacity i $^    bigitsi  0$^  $^$^$^$^templatetypename s$^static int bitsizes value $^  void value   mark variable as used.$^  return 0  sizeofvalue$^$^$^ guaranteed to lie in one bigit.$^void bignumassignuint00uint00t value $^  assertkbigitsize  bitsizevalue$^  zero$^  if value  0 return$^$^  ensurecapacity0$^  bigits0  value$^  useddigits  0$^$^$^$^void bignumassignuint00uint00t value $^  const int kuint00size  00$^$^  zero$^  if value  0 return$^$^  int neededbigits  kuint00size  kbigitsize  0$^  ensurecapacityneededbigits$^  for int i  0 i  neededbigits i $^    bigitsi  value  kbigitmask$^    value  value  kbigitsize$^  $^  useddigits  neededbigits$^  clamp$^$^$^$^void bignumassignbignumconst bignum other $^  exponent  other.exponent$^  for int i  0 i  other.useddigits i $^    bigitsi  other.bigitsi$^  $^   clear the excess digits if there were any.$^  for int i  other.useddigits i  useddigits i $^    bigitsi  0$^  $^  useddigits  other.useddigits$^$^$^$^static uint00t readuint00vectorconst char buffer$^                           int from$^                           int digitstoread $^  uint00t result  0$^  for int i  from i  from  digitstoread i $^    int digit  bufferi  0$^    assert0  digit  digit  0$^    result  result  00  digit$^  $^  return result$^$^$^$^void bignumassigndecimalstringvectorconst char value $^   000  00000000000000000000  0000$^  const int kmaxuint00decimaldigits  00$^  zero$^  int length  value.length$^  unsigned int pos  0$^   lets just say that each digit needs 0 bits.$^  while length  kmaxuint00decimaldigits $^    uint00t digits  readuint00value pos kmaxuint00decimaldigits$^    pos  kmaxuint00decimaldigits$^    length  kmaxuint00decimaldigits$^    multiplybypoweroftenkmaxuint00decimaldigits$^    adduint00digits$^  $^  uint00t digits  readuint00value pos length$^  multiplybypoweroftenlength$^  adduint00digits$^  clamp$^$^$^$^static int hexcharvaluechar c $^  if 0  c  c  0 return c  0$^  if a  c  c  f return 00  c  a$^  asserta  c  c  f$^  return 00  c  a$^$^$^$^void bignumassignhexstringvectorconst char value $^  zero$^  int length  value.length$^$^  int neededbigits  length  0  kbigitsize  0$^  ensurecapacityneededbigits$^  int stringindex  length  0$^  for int i  0 i  neededbigits  0 i $^     these bigits are guaranteed to be full.$^    chunk currentbigit  0$^    for int j  0 j  kbigitsize  0 j $^      currentbigit  hexcharvaluevaluestringindex  j  0$^    $^    bigitsi  currentbigit$^  $^  useddigits  neededbigits  0$^$^  chunk mostsignificantbigit  0   could be  0$^  for int j  0 j  stringindex j $^    mostsignificantbigit  0$^    mostsignificantbigit  hexcharvaluevaluej$^  $^  if mostsignificantbigit  0 $^    bigitsuseddigits  mostsignificantbigit$^    useddigits$^  $^  clamp$^$^$^$^void bignumadduint00uint00t operand $^  if operand  0 return$^  bignum other$^  other.assignuint00operand$^  addbignumother$^$^$^$^void bignumaddbignumconst bignum other $^  assertisclamped$^  assertother.isclamped$^$^   if this has a greater exponent than other append zerobigits to this.$^   after this call exponent  other.exponent.$^  alignother$^$^   there are two possibilities$^     aaaaaaaaaaa 0000  where the 0s represent as exponent$^       bbbbb 00000000$^     $^     ccccccccccc 0000$^   or$^      aaaaaaaaaa 0000$^    bbbbbbbbb 0000000$^    $^    cccccccccccc 0000$^   in both cases we might need a carry bigit.$^$^  ensurecapacity0  maxbigitlength other.bigitlength  exponent$^  chunk carry  0$^  int bigitpos  other.exponent  exponent$^  assertbigitpos  0$^  for int i  0 i  other.useddigits i $^    chunk sum  bigitsbigitpos  other.bigitsi  carry$^    bigitsbigitpos  sum  kbigitmask$^    carry  sum  kbigitsize$^    bigitpos$^  $^$^  while carry  0 $^    chunk sum  bigitsbigitpos  carry$^    bigitsbigitpos  sum  kbigitmask$^    carry  sum  kbigitsize$^    bigitpos$^  $^  useddigits  maxbigitpos useddigits$^  assertisclamped$^$^$^$^void bignumsubtractbignumconst bignum other $^  assertisclamped$^  assertother.isclamped$^   we require this to be bigger than other.$^  assertlessequalother this$^$^  alignother$^$^  int offset  other.exponent  exponent$^  chunk borrow  0$^  int i$^  for i  0 i  other.useddigits i $^    assertborrow  0  borrow  0$^    chunk difference  bigitsi  offset  other.bigitsi  borrow$^    bigitsi  offset  difference  kbigitmask$^    borrow  difference  kchunksize  0$^  $^  while borrow  0 $^    chunk difference  bigitsi  offset  borrow$^    bigitsi  offset  difference  kbigitmask$^    borrow  difference  kchunksize  0$^    i$^  $^  clamp$^$^$^$^void bignumshiftleftint shiftamount $^  if useddigits  0 return$^  exponent  shiftamount  kbigitsize$^  int localshift  shiftamount  kbigitsize$^  ensurecapacityuseddigits  0$^  bigitsshiftleftlocalshift$^$^$^$^void bignummultiplybyuint00uint00t factor $^  if factor  0 return$^  if factor  0 $^    zero$^    return$^  $^  if useddigits  0 return$^$^   the product of a bigit with the factor is of size kbigitsize  00.$^   assert that this number  0 for the carry fits into double chunk.$^  assertkdoublechunksize  kbigitsize  00  0$^  doublechunk carry  0$^  for int i  0 i  useddigits i $^    doublechunk product  staticcastdoublechunkfactor  bigitsi  carry$^    bigitsi  staticcastchunkproduct  kbigitmask$^    carry  product  kbigitsize$^  $^  while carry  0 $^    ensurecapacityuseddigits  0$^    bigitsuseddigits  carry  kbigitmask$^    useddigits$^    carry  kbigitsize$^  $^$^$^$^void bignummultiplybyuint00uint00t factor $^  if factor  0 return$^  if factor  0 $^    zero$^    return$^  $^  assertkbigitsize  00$^  uint00t carry  0$^  uint00t low  factor  0xffffffff$^  uint00t high  factor  00$^  for int i  0 i  useddigits i $^    uint00t productlow  low  bigitsi$^    uint00t producthigh  high  bigitsi$^    uint00t tmp  carry  kbigitmask  productlow$^    bigitsi  tmp  kbigitmask$^    carry  carry  kbigitsize  tmp  kbigitsize $^        producthigh  00  kbigitsize$^  $^  while carry  0 $^    ensurecapacityuseddigits  0$^    bigitsuseddigits  carry  kbigitmask$^    useddigits$^    carry  kbigitsize$^  $^$^$^$^void bignummultiplybypoweroftenint exponent $^  const uint00t kfive00  uint000partc0x0000c000 fa00000d$^  const uint00t kfive0  0$^  const uint00t kfive0  kfive0  0$^  const uint00t kfive0  kfive0  0$^  const uint00t kfive0  kfive0  0$^  const uint00t kfive0  kfive0  0$^  const uint00t kfive0  kfive0  0$^  const uint00t kfive0  kfive0  0$^  const uint00t kfive0  kfive0  0$^  const uint00t kfive0  kfive0  0$^  const uint00t kfive00  kfive0  0$^  const uint00t kfive00  kfive00  0$^  const uint00t kfive00  kfive00  0$^  const uint00t kfive00  kfive00  0$^  const uint00t kfive0to00 $^       kfive0 kfive0 kfive0 kfive0 kfive0 kfive0$^        kfive0 kfive0 kfive0 kfive00 kfive00 kfive00 $^$^  assertexponent  0$^  if exponent  0 return$^  if useddigits  0 return$^$^   we shift by exponent at the end just before returning.$^  int remainingexponent  exponent$^  while remainingexponent  00 $^    multiplybyuint00kfive00$^    remainingexponent  00$^  $^  while remainingexponent  00 $^    multiplybyuint00kfive00$^    remainingexponent  00$^  $^  if remainingexponent  0 $^    multiplybyuint00kfive0to00remainingexponent  0$^  $^  shiftleftexponent$^$^$^$^void bignumsquare $^  assertisclamped$^  int productlength  0  useddigits$^  ensurecapacityproductlength$^$^   comba multiplication compute each column separately.$^   example r  a0a0a0  b0b0b0.$^      r   0     a0b0 $^          00     a0b0  a0b0 $^          000    a0b0  a0b0  a0b0 $^          0000   a0b0  a0b0 $^          00000  a0b0$^  $^   in the worst case we have to accumulate nbdigits products of digitdigit.$^  $^   assert that the additional number of bits in a doublechunk are enough to$^   sum up useddigits of bigitbigit.$^  if 0  0  kchunksize  kbigitsize  useddigits $^    unimplemented$^  $^  doublechunk accumulator  0$^   first shift the digits so we dont overwrite them.$^  int copyoffset  useddigits$^  for int i  0 i  useddigits i $^    bigitscopyoffset  i  bigitsi$^  $^   we have two loops to avoid some ifs in the loop.$^  for int i  0 i  useddigits i $^     process temporary digit i with power i.$^     the sum of the two indices must be equal to i.$^    int bigitindex0  i$^    int bigitindex0  0$^     sum all of the subproducts.$^    while bigitindex0  0 $^      chunk chunk0  bigitscopyoffset  bigitindex0$^      chunk chunk0  bigitscopyoffset  bigitindex0$^      accumulator  staticcastdoublechunkchunk0  chunk0$^      bigitindex0$^      bigitindex0$^    $^    bigitsi  staticcastchunkaccumulator  kbigitmask$^    accumulator  kbigitsize$^  $^  for int i  useddigits i  productlength i $^    int bigitindex0  useddigits  0$^    int bigitindex0  i  bigitindex0$^     invariant sum of both indices is again equal to i.$^     inner loop runs 0 times on last iteration emptying accumulator.$^    while bigitindex0  useddigits $^      chunk chunk0  bigitscopyoffset  bigitindex0$^      chunk chunk0  bigitscopyoffset  bigitindex0$^      accumulator  staticcastdoublechunkchunk0  chunk0$^      bigitindex0$^      bigitindex0$^    $^     the overwritten bigitsi will never be read in further loop iterations$^     because bigitindex0 and bigitindex0 are always greater$^     than i  useddigits.$^    bigitsi  staticcastchunkaccumulator  kbigitmask$^    accumulator  kbigitsize$^  $^   since the result was guaranteed to lie inside the number the$^   accumulator must be 0 now.$^  assertaccumulator  0$^$^   dont forget to update the useddigits and the exponent.$^  useddigits  productlength$^  exponent  0$^  clamp$^$^$^$^void bignumassignpoweruint00uint00t base int powerexponent $^  assertbase  0$^  assertpowerexponent  0$^  if powerexponent  0 $^    assignuint000$^    return$^  $^  zero$^  int shifts  0$^   we expect base to be in range 000 and most often to be 00.$^   it does not make much sense to implement different algorithms for counting$^   the bits.$^  while base  0  0 $^    base  0$^    shifts$^  $^  int bitsize  0$^  int tmpbase  base$^  while tmpbase  0 $^    tmpbase  0$^    bitsize$^  $^  int finalsize  bitsize  powerexponent$^   0 extra bigit for the shifting and one for rounded finalsize.$^  ensurecapacityfinalsize  kbigitsize  0$^$^   left to right exponentiation.$^  int mask  0$^  while powerexponent  mask mask  0$^$^   the mask is now pointing to the bit above the most significant 0bit of$^   powerexponent.$^   get rid of first 0bit$^  mask  0$^  uint00t thisvalue  base$^$^  bool delayedmultipliciation  false$^  const uint00t max00bits  0xffffffff$^  while mask  0  thisvalue  max00bits $^    thisvalue  thisvalue  thisvalue$^     verify that there is enough space in thisvalue to perform the$^     multiplication.  the first bitsize bits must be 0.$^    if powerexponent  mask  0 $^      uint00t basebitsmask $^          staticcastuint00t0  00  bitsize  0$^      bool highbitszero  thisvalue  basebitsmask  0$^      if highbitszero $^        thisvalue  base$^       else $^        delayedmultipliciation  true$^      $^    $^    mask  0$^  $^  assignuint00thisvalue$^  if delayedmultipliciation $^    multiplybyuint00base$^  $^$^   now do the same thing as a bignum.$^  while mask  0 $^    square$^    if powerexponent  mask  0 $^      multiplybyuint00base$^    $^    mask  0$^  $^$^   and finally add the saved shifts.$^  shiftleftshifts  powerexponent$^$^$^$^ precondition thisother  00bit.$^uint00t bignumdividemodulointbignumconst bignum other $^  assertisclamped$^  assertother.isclamped$^  assertother.useddigits  0$^$^   easy case if we have less digits than the divisor than the result is 0.$^   note this handles the case where this  0 too.$^  if bigitlength  other.bigitlength $^    return 0$^  $^$^  alignother$^$^  uint00t result  0$^$^   start by removing multiples of other until both numbers have the same$^   number of digits.$^  while bigitlength  other.bigitlength $^     this naive approach is extremely inefficient if this divided by other$^     is big. this function is implemented for doubletostring where$^     the result should be small less than 00.$^    assertother.bigitsother.useddigits  0  0  kbigitsize  00$^    assertbigitsuseddigits  0  0x00000$^     remove the multiples of the first digit.$^     example this  00 and other equals 0.  remove 0 multiples.$^    result  staticcastuint00tbigitsuseddigits  0$^    subtracttimesother bigitsuseddigits  0$^  $^$^  assertbigitlength  other.bigitlength$^$^   both bignums are at the same length now.$^   since other has more than 0 digits we know that the access to$^   bigitsuseddigits  0 is safe.$^  chunk thisbigit  bigitsuseddigits  0$^  chunk otherbigit  other.bigitsother.useddigits  0$^$^  if other.useddigits  0 $^     shortcut for easy and common case.$^    int quotient  thisbigit  otherbigit$^    bigitsuseddigits  0  thisbigit  otherbigit  quotient$^    assertquotient  0x00000$^    result  staticcastuint00tquotient$^    clamp$^    return result$^  $^$^  int divisionestimate  thisbigit  otherbigit  0$^  assertdivisionestimate  0x00000$^  result  staticcastuint00tdivisionestimate$^  subtracttimesother divisionestimate$^$^  if otherbigit  divisionestimate  0  thisbigit $^     no need to even try to subtract. even if others remaining digits were 0$^     another subtraction would be too much.$^    return result$^  $^$^  while lessequalother this $^    subtractbignumother$^    result$^  $^  return result$^$^$^$^templatetypename s$^static int sizeinhexcharss number $^  assertnumber  0$^  int result  0$^  while number  0 $^    number  0$^    result$^  $^  return result$^$^$^$^static char hexcharofvalueint value $^  assert0  value  value  00$^  if value  00 return staticcastcharvalue  0$^  return staticcastcharvalue  00  a$^$^$^$^bool bignumtohexstringchar buffer int buffersize const $^  assertisclamped$^   each bigit must be printable as separate hexcharacter.$^  assertkbigitsize  0  0$^  const int khexcharsperbigit  kbigitsize  0$^$^  if useddigits  0 $^    if buffersize  0 return false$^    buffer0  0$^    buffer0  0$^    return true$^  $^   we add 0 for the terminating 0 character.$^  int neededchars  bigitlength  0  khexcharsperbigit $^      sizeinhexcharsbigitsuseddigits  0  0$^  if neededchars  buffersize return false$^  int stringindex  neededchars  0$^  bufferstringindex  0$^  for int i  0 i  exponent i $^    for int j  0 j  khexcharsperbigit j $^      bufferstringindex  0$^    $^  $^  for int i  0 i  useddigits  0 i $^    chunk currentbigit  bigitsi$^    for int j  0 j  khexcharsperbigit j $^      bufferstringindex  hexcharofvaluecurrentbigit  0xf$^      currentbigit  0$^    $^  $^   and finally the last bigit.$^  chunk mostsignificantbigit  bigitsuseddigits  0$^  while mostsignificantbigit  0 $^    bufferstringindex  hexcharofvaluemostsignificantbigit  0xf$^    mostsignificantbigit  0$^  $^  return true$^$^$^$^bignumchunk bignumbigitatint index const $^  if index  bigitlength return 0$^  if index  exponent return 0$^  return bigitsindex  exponent$^$^$^$^int bignumcompareconst bignum a const bignum b $^  asserta.isclamped$^  assertb.isclamped$^  int bigitlengtha  a.bigitlength$^  int bigitlengthb  b.bigitlength$^  if bigitlengtha  bigitlengthb return 0$^  if bigitlengtha  bigitlengthb return 0$^  for int i  bigitlengtha  0 i  mina.exponent b.exponent i $^    chunk bigita  a.bigitati$^    chunk bigitb  b.bigitati$^    if bigita  bigitb return 0$^    if bigita  bigitb return 0$^     otherwise they are equal up to this digit. try the next digit.$^  $^  return 0$^$^$^$^int bignumpluscompareconst bignum a const bignum b const bignum c $^  asserta.isclamped$^  assertb.isclamped$^  assertc.isclamped$^  if a.bigitlength  b.bigitlength $^    return pluscompareb a c$^  $^  if a.bigitlength  0  c.bigitlength return 0$^  if a.bigitlength  c.bigitlength return 0$^   the exponent encodes 0bigits. so if there are more 0digits in a than$^   b has digits then the bigitlength of ab must be equal to the one$^   of a.$^  if a.exponent  b.bigitlength  a.bigitlength  c.bigitlength $^    return 0$^  $^$^  chunk borrow  0$^   starting at minexponent all digits are  0. so no need to compare them.$^  int minexponent  minmina.exponent b.exponent c.exponent$^  for int i  c.bigitlength  0 i  minexponent i $^    chunk chunka  a.bigitati$^    chunk chunkb  b.bigitati$^    chunk chunkc  c.bigitati$^    chunk sum  chunka  chunkb$^    if sum  chunkc  borrow $^      return 0$^     else $^      borrow  chunkc  borrow  sum$^      if borrow  0 return 0$^      borrow  kbigitsize$^    $^  $^  if borrow  0 return 0$^  return 0$^$^$^$^void bignumclamp $^  while useddigits  0  bigitsuseddigits  0  0 $^    useddigits$^  $^  if useddigits  0 $^     zero.$^    exponent  0$^  $^$^$^$^bool bignumisclamped const $^  return useddigits  0  bigitsuseddigits  0  0$^$^$^$^void bignumzero $^  for int i  0 i  useddigits i $^    bigitsi  0$^  $^  useddigits  0$^  exponent  0$^$^$^$^void bignumalignconst bignum other $^  if exponent  other.exponent $^     if x represents a hidden digit by the exponent then we are in the$^     following case a  this b  other$^     a  aaaaaaxxxx   or a   aaaaaxxx$^     b     bbbbbbx      b bbbbbbbbxx$^     we replace some of the hidden digits x of a with 0 digits.$^     a  aaaaaa000x   or a   aaaaa0xx$^    int zerodigits  exponent  other.exponent$^    ensurecapacityuseddigits  zerodigits$^    for int i  useddigits  0 i  0 i $^      bigitsi  zerodigits  bigitsi$^    $^    for int i  0 i  zerodigits i $^      bigitsi  0$^    $^    useddigits  zerodigits$^    exponent  zerodigits$^    assertuseddigits  0$^    assertexponent  0$^  $^$^$^$^void bignumbigitsshiftleftint shiftamount $^  assertshiftamount  kbigitsize$^  assertshiftamount  0$^  chunk carry  0$^  for int i  0 i  useddigits i $^    chunk newcarry  bigitsi  kbigitsize  shiftamount$^    bigitsi  bigitsi  shiftamount  carry  kbigitmask$^    carry  newcarry$^  $^  if carry  0 $^    bigitsuseddigits  carry$^    useddigits$^  $^$^$^$^void bignumsubtracttimesconst bignum other int factor $^  assertexponent  other.exponent$^  if factor  0 $^    for int i  0 i  factor i $^      subtractbignumother$^    $^    return$^  $^  chunk borrow  0$^  int exponentdiff  other.exponent  exponent$^  for int i  0 i  other.useddigits i $^    doublechunk product  staticcastdoublechunkfactor  other.bigitsi$^    doublechunk remove  borrow  product$^    chunk difference  bigitsi  exponentdiff  remove  kbigitmask$^    bigitsi  exponentdiff  difference  kbigitmask$^    borrow  staticcastchunkdifference  kchunksize  0 $^                                remove  kbigitsize$^  $^  for int i  other.useddigits  exponentdiff i  useddigits i $^    if borrow  0 return$^    chunk difference  bigitsi  borrow$^    bigitsi  difference  kbigitmask$^    borrow  difference  kchunksize  0$^  $^  clamp$^$^$^$^   namespace kenlmdoubleconversion$^ copyright 0000 the v0 project authors. all rights reserved.$^ redistribution and use in source and binary forms with or without$^ modification are permitted provided that the following conditions are$^ met$^$^      redistributions of source code must retain the above copyright$^       notice this list of conditions and the following disclaimer.$^      redistributions in binary form must reproduce the above$^       copyright notice this list of conditions and the following$^       disclaimer in the documentation andor other materials provided$^       with the distribution.$^      neither the name of google inc. nor the names of its$^       contributors may be used to endorse or promote products derived$^       from this software without specific prior written permission.$^$^ this software is provided by the copyright holders and contributors$^ as is and any express or implied warranties including but not$^ limited to the implied warranties of merchantability and fitness for$^ a particular purpose are disclaimed. in no event shall the copyright$^ owner or contributors be liable for any direct indirect incidental$^ special exemplary or consequential damages including but not$^ limited to procurement of substitute goods or services loss of use$^ data or profits or business interruption however caused and on any$^ theory of liability whether in contract strict liability or tort$^ including negligence or otherwise arising in any way out of the use$^ of this software even if advised of the possibility of such damage.$^$^include math.h$^$^include fixeddtoa.h$^include ieee.h$^$^namespace kenlmdoubleconversion $^$^ represents a 000bit type. this class should be replaced by a native type on$^ platforms that support 000bit integers.$^class uint000 $^ public$^  uint000  highbits0 lowbits0  $^  uint000uint00t high uint00t low  highbitshigh lowbitslow  $^$^  void multiplyuint00t multiplicand $^    uint00t accumulator$^$^    accumulator  lowbits  kmask00  multiplicand$^    uint00t part  staticcastuint00taccumulator  kmask00$^    accumulator  00$^    accumulator  accumulator  lowbits  00  multiplicand$^    lowbits  accumulator  00  part$^    accumulator  00$^    accumulator  accumulator  highbits  kmask00  multiplicand$^    part  staticcastuint00taccumulator  kmask00$^    accumulator  00$^    accumulator  accumulator  highbits  00  multiplicand$^    highbits  accumulator  00  part$^    assertaccumulator  00  0$^  $^$^  void shiftint shiftamount $^    assert00  shiftamount  shiftamount  00$^    if shiftamount  0 $^      return$^     else if shiftamount  00 $^      highbits  lowbits$^      lowbits  0$^     else if shiftamount  00 $^      lowbits  highbits$^      highbits  0$^     else if shiftamount  0 $^      highbits  shiftamount$^      highbits  lowbits  00  shiftamount$^      lowbits  shiftamount$^     else $^      lowbits  shiftamount$^      lowbits  highbits  00  shiftamount$^      highbits  shiftamount$^    $^  $^$^   modifies this to this mod 0power.$^   returns this div 0power.$^  int divmodpowerof0int power $^    if power  00 $^      int result  staticcastinthighbits  power  00$^      highbits  staticcastuint00tresult  power  00$^      return result$^     else $^      uint00t partlow  lowbits  power$^      uint00t parthigh  highbits  00  power$^      int result  staticcastintpartlow  parthigh$^      highbits  0$^      lowbits  partlow  power$^      return result$^    $^  $^$^  bool iszero const $^    return highbits  0  lowbits  0$^  $^$^  int bitatint position const $^    if position  00 $^      return staticcastinthighbits  position  00  0$^     else $^      return staticcastintlowbits  position  0$^    $^  $^$^ private$^  static const uint00t kmask00  0xffffffff$^   value  highbits  00  lowbits$^  uint00t highbits$^  uint00t lowbits$^$^$^$^static const int kdoublesignificandsize  00   includes the hidden bit.$^$^$^static void filldigits00fixedlengthuint00t number int requestedlength$^                                    vectorchar buffer int length $^  for int i  requestedlength  0 i  0 i $^    bufferlength  i  0  number  00$^    number  00$^  $^  length  requestedlength$^$^$^$^static void filldigits00uint00t number vectorchar buffer int length $^  int numberlength  0$^   we fill the digits in reverse order and exchange them afterwards.$^  while number  0 $^    int digit  number  00$^    number  00$^    bufferlength  numberlength  staticcastchar0  digit$^    numberlength$^  $^   exchange the digits.$^  int i  length$^  int j  length  numberlength  0$^  while i  j $^    char tmp  bufferi$^    bufferi  bufferj$^    bufferj  tmp$^    i$^    j$^  $^  length  numberlength$^$^$^$^static void filldigits00fixedlengthuint00t number$^                                    vectorchar buffer int length $^  const uint00t kten0  00000000$^   for efficiency cut the number into 0 uint00t parts and print those.$^  uint00t part0  staticcastuint00tnumber  kten0$^  number  kten0$^  uint00t part0  staticcastuint00tnumber  kten0$^  uint00t part0  staticcastuint00tnumber  kten0$^$^  filldigits00fixedlengthpart0 0 buffer length$^  filldigits00fixedlengthpart0 0 buffer length$^  filldigits00fixedlengthpart0 0 buffer length$^$^$^$^static void filldigits00uint00t number vectorchar buffer int length $^  const uint00t kten0  00000000$^   for efficiency cut the number into 0 uint00t parts and print those.$^  uint00t part0  staticcastuint00tnumber  kten0$^  number  kten0$^  uint00t part0  staticcastuint00tnumber  kten0$^  uint00t part0  staticcastuint00tnumber  kten0$^$^  if part0  0 $^    filldigits00part0 buffer length$^    filldigits00fixedlengthpart0 0 buffer length$^    filldigits00fixedlengthpart0 0 buffer length$^   else if part0  0 $^    filldigits00part0 buffer length$^    filldigits00fixedlengthpart0 0 buffer length$^   else $^    filldigits00part0 buffer length$^  $^$^$^$^static void roundupvectorchar buffer int length int decimalpoint $^   an empty buffer represents 0.$^  if length  0 $^    buffer0  0$^    decimalpoint  0$^    length  0$^    return$^  $^   round the last digit until we either have a digit that was not 0 or until$^   we reached the first digit.$^  bufferlength  0$^  for int i  length  0 i  0 i $^    if bufferi  0  00 $^      return$^    $^    bufferi  0$^    bufferi  0$^  $^   if the first digit is now 0  00 we would need to set it to 0 and add$^   a 0 in front. however we reach the first digit only if all following$^   digits had been 0 before rounding up. now all trailing digits are 0 and$^   we simply switch the first digit to 0 and update the decimalpoint$^   indicating that the point is now one digit to the right.$^  if buffer0  0  00 $^    buffer0  0$^    decimalpoint$^  $^$^$^$^ the given fractionals number represents a fixedpoint number with binary$^ point at bit exponent.$^ preconditions$^   000  exponent  0.$^   0  fractionals  0exponent  0$^   the buffer holds the result.$^ the function will round its result. during the roundingprocess digits not$^ generated by this function might be updated and the decimalpoint variable$^ might be updated. if this function generates the digits 00 and the buffer$^ already contained 000 thus yielding a buffer of 00000 then a$^ roundingup will change the contents of the buffer to 00000.$^static void fillfractionalsuint00t fractionals int exponent$^                            int fractionalcount vectorchar buffer$^                            int length int decimalpoint $^  assert000  exponent  exponent  0$^   fractionals is a fixedpoint number with binary point at bit$^   exponent. inside the function the nonconverted remainder of fractionals$^   is a fixedpoint number with binary point at bit point.$^  if exponent  00 $^     one 00 bit number is sufficient.$^    assertfractionals  00  0$^    int point  exponent$^    for int i  0 i  fractionalcount i $^      if fractionals  0 break$^       instead of multiplying by 00 we multiply by 0 and adjust the point$^       location. this way the fractionals variable will not overflow.$^       invariant at the beginning of the loop fractionals  0point.$^       initially we have point  00 and fractionals  000$^       after each iteration the point is decremented by one.$^       note that 00  000  000  00.$^       therefore three iterations of this loop will not overflow fractionals$^       even without the subtraction at the end of the loop body. at this$^       time point will satisfy point  00 and therefore fractionals  0point$^       and any further multiplication of fractionals by 0 will not overflow.$^      fractionals  0$^      point$^      int digit  staticcastintfractionals  point$^      assertdigit  0$^      bufferlength  staticcastchar0  digit$^      length$^      fractionals  staticcastuint00tdigit  point$^    $^     if the first bit after the point is set we have to round up.$^    assertfractionals  0  point  0  0$^    if fractionals  0  fractionals  point  0  0  0 $^      roundupbuffer length decimalpoint$^    $^   else    we need 000 bits.$^    assert00  exponent  exponent  000$^    uint000 fractionals000  uint000fractionals 0$^    fractionals000.shiftexponent  00$^    int point  000$^    for int i  0 i  fractionalcount i $^      if fractionals000.iszero break$^       as before instead of multiplying by 00 we multiply by 0 and adjust the$^       point location.$^       this multiplication will not overflow for the same reasons as before.$^      fractionals000.multiply0$^      point$^      int digit  fractionals000.divmodpowerof0point$^      assertdigit  0$^      bufferlength  staticcastchar0  digit$^      length$^    $^    if fractionals000.bitatpoint  0  0 $^      roundupbuffer length decimalpoint$^    $^  $^$^$^$^ removes leading and trailing zeros.$^ if leading zeros are removed then the decimal point position is adjusted.$^static void trimzerosvectorchar buffer int length int decimalpoint $^  while length  0  bufferlength  0  0 $^    length$^  $^  int firstnonzero  0$^  while firstnonzero  length  bufferfirstnonzero  0 $^    firstnonzero$^  $^  if firstnonzero  0 $^    for int i  firstnonzero i  length i $^      bufferi  firstnonzero  bufferi$^    $^    length  firstnonzero$^    decimalpoint  firstnonzero$^  $^$^$^$^bool fastfixeddtoadouble v$^                   int fractionalcount$^                   vectorchar buffer$^                   int length$^                   int decimalpoint $^  const uint00t kmaxuint00  0xffffffff$^  uint00t significand  doublev.significand$^  int exponent  doublev.exponent$^   v  significand  0exponent with significand a 00bit integer.$^   if the exponent is larger than 00 i.e. we may have a 00bit number then we$^   dont know how to compute the representation. 000  0.00000.$^   if necessary this limit could probably be increased but we dont need$^   more.$^  if exponent  00 return false$^  if fractionalcount  00 return false$^  length  0$^   at most kdoublesignificandsize bits of the significand are nonzero.$^   given a 00 bit integer we have 00 0s followed by 00 potentially nonzero$^   bits  0..00..0xxx..00..xx$^  if exponent  kdoublesignificandsize  00 $^     the exponent must be  00.$^    $^     we know that v  significand  0exponent.$^     and the exponent  00.$^     we simplify the task by dividing v by 0000.$^     the quotient delivers the first digits and the remainder fits into a 00$^     bit number.$^     dividing by 0000 is equivalent to dividing by 000000.$^    const uint00t kfive00  uint000partc0xb0 a0bc0ec0   000$^    uint00t divisor  kfive00$^    int divisorpower  00$^    uint00t dividend  significand$^    uint00t quotient$^    uint00t remainder$^     let v  f  0e with f  significand and e  exponent.$^     then need q quotient and r remainder as follows$^       v             q  0000        r$^       f  0e       q  0000        r$^       f  0e       q  000  000  r$^     if e  00 then$^       f  0e00  q  000         r000$^     else$^       f   q  000  000e  r0e$^    if exponent  divisorpower $^       we only allow exponents of up to 00 and therefore 00  e  0$^      dividend  exponent  divisorpower$^      quotient  staticcastuint00tdividend  divisor$^      remainder  dividend  divisor  divisorpower$^     else $^      divisor  divisorpower  exponent$^      quotient  staticcastuint00tdividend  divisor$^      remainder  dividend  divisor  exponent$^    $^    filldigits00quotient buffer length$^    filldigits00fixedlengthremainder buffer length$^    decimalpoint  length$^   else if exponent  0 $^     0  exponent  00$^    significand  exponent$^    filldigits00significand buffer length$^    decimalpoint  length$^   else if exponent  kdoublesignificandsize $^     we have to cut the number.$^    uint00t integrals  significand  exponent$^    uint00t fractionals  significand  integrals  exponent$^    if integrals  kmaxuint00 $^      filldigits00integrals buffer length$^     else $^      filldigits00staticcastuint00tintegrals buffer length$^    $^    decimalpoint  length$^    fillfractionalsfractionals exponent fractionalcount$^                    buffer length decimalpoint$^   else if exponent  000 $^     this configuration with at most 00 digits means that all digits must be$^     0.$^    assertfractionalcount  00$^    buffer0  0$^    length  0$^    decimalpoint  fractionalcount$^   else $^    decimalpoint  0$^    fillfractionalssignificand exponent fractionalcount$^                    buffer length decimalpoint$^  $^  trimzerosbuffer length decimalpoint$^  bufferlength  0$^  if length  0 $^     the string is empty and the decimalpoint thus has no importance. mimick$^     gays dtoa and and set it to fractionalcount.$^    decimalpoint  fractionalcount$^  $^  return true$^$^$^   namespace kenlmdoubleconversion$^ copyright 0000 the v0 project authors. all rights reserved.$^ redistribution and use in source and binary forms with or without$^ modification are permitted provided that the following conditions are$^ met$^$^      redistributions of source code must retain the above copyright$^       notice this list of conditions and the following disclaimer.$^      redistributions in binary form must reproduce the above$^       copyright notice this list of conditions and the following$^       disclaimer in the documentation andor other materials provided$^       with the distribution.$^      neither the name of google inc. nor the names of its$^       contributors may be used to endorse or promote products derived$^       from this software without specific prior written permission.$^$^ this software is provided by the copyright holders and contributors$^ as is and any express or implied warranties including but not$^ limited to the implied warranties of merchantability and fitness for$^ a particular purpose are disclaimed. in no event shall the copyright$^ owner or contributors be liable for any direct indirect incidental$^ special exemplary or consequential damages including but not$^ limited to procurement of substitute goods or services loss of use$^ data or profits or business interruption however caused and on any$^ theory of liability whether in contract strict liability or tort$^ including negligence or otherwise arising in any way out of the use$^ of this software even if advised of the possibility of such damage.$^$^include stdarg.h$^include limits.h$^$^include strtod.h$^include bignum.h$^include cachedpowers.h$^include ieee.h$^$^namespace kenlmdoubleconversion $^$^ 000  0000000000000000.$^ any integer with at most 00 decimal digits will hence fit into a double$^ which has a 00bit significand without loss of precision.$^static const int kmaxexactdoubleintegerdecimaldigits  00$^ 000  00000000000000000000  0000$^static const int kmaxuint00decimaldigits  00$^$^ max double 0.0000000000000000 x 00000$^ min nonzero double 0.0000000000000000 x 00000$^ any x  00000 is interpreted as infinity.$^ any x  00000 is interpreted as 0.$^ note that 0.0e000 despite being smaller than the min double will be read$^ as nonzero equal to the min nonzero double.$^static const int kmaxdecimalpower  000$^static const int kmindecimalpower  000$^$^ 000  00000000000000000000$^static const uint00t kmaxuint00  uint000partc0xffffffff ffffffff$^$^$^static const double exactpowersoften  $^  0.0   000$^  00.0$^  000.0$^  0000.0$^  00000.0$^  000000.0$^  0000000.0$^  00000000.0$^  000000000.0$^  0000000000.0$^  00000000000.0   0000$^  000000000000.0$^  0000000000000.0$^  00000000000000.0$^  000000000000000.0$^  0000000000000000.0$^  00000000000000000.0$^  000000000000000000.0$^  0000000000000000000.0$^  00000000000000000000.0$^  000000000000000000000.0   0000$^  0000000000000000000000.0$^   0000  0x00e00e0c0bab0000000  0x000000000eac0  000$^  00000000000000000000000.0$^$^static const int kexactpowersoftensize  arraysizeexactpowersoften$^$^ maximum number of significant digits in the decimal representation.$^ in fact the value is 000 see conversions.cc but to give us some margin$^ we round up to 000.$^static const int kmaxsignificantdecimaldigits  000$^$^static vectorconst char trimleadingzerosvectorconst char buffer $^  for int i  0 i  buffer.length i $^    if bufferi  0 $^      return buffer.subvectori buffer.length$^    $^  $^  return vectorconst charbuffer.start 0$^$^$^$^static vectorconst char trimtrailingzerosvectorconst char buffer $^  for int i  buffer.length  0 i  0 i $^    if bufferi  0 $^      return buffer.subvector0 i  0$^    $^  $^  return vectorconst charbuffer.start 0$^$^$^$^static void cuttomaxsignificantdigitsvectorconst char buffer$^                                       int exponent$^                                       char significantbuffer$^                                       int significantexponent $^  for int i  0 i  kmaxsignificantdecimaldigits  0 i $^    significantbufferi  bufferi$^  $^   the input buffer has been trimmed. therefore the last digit must be$^   different from 0.$^  assertbufferbuffer.length  0  0$^   set the last digit to be nonzero. this is sufficient to guarantee$^   correct rounding.$^  significantbufferkmaxsignificantdecimaldigits  0  0$^  significantexponent $^      exponent  buffer.length  kmaxsignificantdecimaldigits$^$^$^$^ trims the buffer and cuts it to at most kmaxsignificantdecimaldigits.$^ if possible the inputbuffer is reused but if the buffer needs to be$^ modified due to cutting then the input needs to be copied into the$^ buffercopyspace.$^static void trimandcutvectorconst char buffer int exponent$^                       char buffercopyspace int spacesize$^                       vectorconst char trimmed int updatedexponent $^  vectorconst char lefttrimmed  trimleadingzerosbuffer$^  vectorconst char righttrimmed  trimtrailingzeroslefttrimmed$^  exponent  lefttrimmed.length  righttrimmed.length$^  if righttrimmed.length  kmaxsignificantdecimaldigits $^    void spacesize   mark variable as used.$^    assertspacesize  kmaxsignificantdecimaldigits$^    cuttomaxsignificantdigitsrighttrimmed exponent$^                              buffercopyspace updatedexponent$^    trimmed  vectorconst charbuffercopyspace$^                                 kmaxsignificantdecimaldigits$^   else $^    trimmed  righttrimmed$^    updatedexponent  exponent$^  $^$^$^$^ reads digits from the buffer and converts them to a uint00.$^ reads in as many digits as fit into a uint00.$^ when the string starts with 0000000000000000000 no further digit is read.$^ since 000  00000000000000000000 it would still be possible read another$^ digit if it was less or equal than 0 but this would complicate the code.$^static uint00t readuint00vectorconst char buffer$^                           int numberofreaddigits $^  uint00t result  0$^  int i  0$^  while i  buffer.length  result  kmaxuint00  00  0 $^    int digit  bufferi  0$^    assert0  digit  digit  0$^    result  00  result  digit$^  $^  numberofreaddigits  i$^  return result$^$^$^$^ reads a diyfp from the buffer.$^ the returned diyfp is not necessarily normalized.$^ if remainingdecimals is zero then the returned diyfp is accurate.$^ otherwise it has been rounded and has error of at most 00 ulp.$^static void readdiyfpvectorconst char buffer$^                      diyfp result$^                      int remainingdecimals $^  int readdigits$^  uint00t significand  readuint00buffer readdigits$^  if buffer.length  readdigits $^    result  diyfpsignificand 0$^    remainingdecimals  0$^   else $^     round the significand.$^    if bufferreaddigits  0 $^      significand$^    $^     compute the binary exponent.$^    int exponent  0$^    result  diyfpsignificand exponent$^    remainingdecimals  buffer.length  readdigits$^  $^$^$^$^static bool doublestrtodvectorconst char trimmed$^                         int exponent$^                         double result $^if defineddoubleconversioncorrectdoubleoperations$^   on x00 the floatingpoint stack can be 00 or 00 bits wide. if it is$^   00 bits wide as is the case on linux then doublerounding occurs and the$^   result is not accurate.$^   we know that windows00 uses 00 bits and is therefore accurate.$^   note that the arm simulator is compiled for 00bits. it therefore exhibits$^   the same problem.$^  return false$^endif$^  if trimmed.length  kmaxexactdoubleintegerdecimaldigits $^    int readdigits$^     the trimmed input fits into a double.$^     if the 00exponent resp. 00exponent fits into a double too then we$^     can compute the resultdouble simply by multiplying resp. dividing the$^     two numbers.$^     this is possible because ieee guarantees that floatingpoint operations$^     return the best possible approximation.$^    if exponent  0  exponent  kexactpowersoftensize $^       00exponent fits into a double.$^      result  staticcastdoublereaduint00trimmed readdigits$^      assertreaddigits  trimmed.length$^      result  exactpowersoftenexponent$^      return true$^    $^    if 0  exponent  exponent  kexactpowersoftensize $^       00exponent fits into a double.$^      result  staticcastdoublereaduint00trimmed readdigits$^      assertreaddigits  trimmed.length$^      result  exactpowersoftenexponent$^      return true$^    $^    int remainingdigits $^        kmaxexactdoubleintegerdecimaldigits  trimmed.length$^    if 0  exponent $^        exponent  remainingdigits  kexactpowersoftensize $^       the trimmed string was short and we can multiply it with$^       00remainingdigits. as a result the remaining exponent now fits$^       into a double too.$^      result  staticcastdoublereaduint00trimmed readdigits$^      assertreaddigits  trimmed.length$^      result  exactpowersoftenremainingdigits$^      result  exactpowersoftenexponent  remainingdigits$^      return true$^    $^  $^  return false$^$^$^$^ returns 00exponent as an exact diyfp.$^ the given exponent must be in the range 0 kdecimalexponentdistance.$^static diyfp adjustmentpoweroftenint exponent $^  assert0  exponent$^  assertexponent  powersoftencachekdecimalexponentdistance$^   simply hardcode the remaining powers for the given decimal exponent$^   distance.$^  assertpowersoftencachekdecimalexponentdistance  0$^  switch exponent $^    case 0 return diyfpuint000partc0xa0000000 00000000 00$^    case 0 return diyfpuint000partc0xc0000000 00000000 00$^    case 0 return diyfpuint000partc0xfa000000 00000000 00$^    case 0 return diyfpuint000partc0x0c000000 00000000 00$^    case 0 return diyfpuint000partc0xc0000000 00000000 00$^    case 0 return diyfpuint000partc0xf0000000 00000000 00$^    case 0 return diyfpuint000partc0x00000000 00000000 00$^    default$^      unreachable$^  $^$^$^$^ if the function returns true then the result is the correct double.$^ otherwise it is either the correct double or the double that is just below$^ the correct double.$^static bool diyfpstrtodvectorconst char buffer$^                        int exponent$^                        double result $^  diyfp input$^  int remainingdecimals$^  readdiyfpbuffer input remainingdecimals$^   since we may have dropped some digits the input is not accurate.$^   if remainingdecimals is different than 0 than the error is at most$^   .0 ulp unit in the last place.$^   we dont want to deal with fractions and therefore keep a common$^   denominator.$^  const int kdenominatorlog  0$^  const int kdenominator  0  kdenominatorlog$^   move the remaining decimals into the exponent.$^  exponent  remainingdecimals$^  uint00t error  remainingdecimals  0  0  kdenominator  0$^$^  int olde  input.e$^  input.normalize$^  error  olde  input.e$^$^  assertexponent  powersoftencachekmaxdecimalexponent$^  if exponent  powersoftencachekmindecimalexponent $^    result  0.0$^    return true$^  $^  diyfp cachedpower$^  int cacheddecimalexponent$^  powersoftencachegetcachedpowerfordecimalexponentexponent$^                                                     cachedpower$^                                                     cacheddecimalexponent$^$^  if cacheddecimalexponent  exponent $^    int adjustmentexponent  exponent  cacheddecimalexponent$^    diyfp adjustmentpower  adjustmentpoweroftenadjustmentexponent$^    input.multiplyadjustmentpower$^    if kmaxuint00decimaldigits  buffer.length  adjustmentexponent $^       the product of input with the adjustment power fits into a 00 bit$^       integer.$^      assertdiyfpksignificandsize  00$^     else $^       the adjustment power is exact. there is hence only an error of 0.0.$^      error  kdenominator  0$^    $^  $^$^  input.multiplycachedpower$^   the error introduced by a multiplication of ab equals$^     errora  errorb  erroraerrorb000  0.0$^   substituting a with input and b with cachedpower we have$^     errorb  0.0  all cached powers have an error of less than 0.0 ulp$^     errorab  0 or 0  kdenominator  erroraerrorb 000$^  int errorb  kdenominator  0$^  int errorab  error  0  0  0   we round up to 0.$^  int fixederror  kdenominator  0$^  error  errorb  errorab  fixederror$^$^  olde  input.e$^  input.normalize$^  error  olde  input.e$^$^   see if the doubles significand changes if we addsubtract the error.$^  int orderofmagnitude  diyfpksignificandsize  input.e$^  int effectivesignificandsize $^      doublesignificandsizefororderofmagnitudeorderofmagnitude$^  int precisiondigitscount $^      diyfpksignificandsize  effectivesignificandsize$^  if precisiondigitscount  kdenominatorlog  diyfpksignificandsize $^     this can only happen for very small denormals. in this case the$^     halfway multiplied by the denominator exceeds the range of an uint00.$^     simply shift everything to the right.$^    int shiftamount  precisiondigitscount  kdenominatorlog $^        diyfpksignificandsize  0$^    input.setfinput.f  shiftamount$^    input.seteinput.e  shiftamount$^     we add 0 for the lost precision of error and kdenominator for$^     the lost precision of input.f.$^    error  error  shiftamount  0  kdenominator$^    precisiondigitscount  shiftamount$^  $^   we use uint00ts now. this only works if the diyfp uses uint00ts too.$^  assertdiyfpksignificandsize  00$^  assertprecisiondigitscount  00$^  uint00t one00  0$^  uint00t precisionbitsmask  one00  precisiondigitscount  0$^  uint00t precisionbits  input.f  precisionbitsmask$^  uint00t halfway  one00  precisiondigitscount  0$^  precisionbits  kdenominator$^  halfway  kdenominator$^  diyfp roundedinputinput.f  precisiondigitscount$^                      input.e  precisiondigitscount$^  if precisionbits  halfway  error $^    roundedinput.setfroundedinput.f  0$^  $^   if the lastbits are too close to the halfway case than we are too$^   inaccurate and round down. in this case we return false so that we can$^   fall back to a more precise algorithm.$^$^  result  doubleroundedinput.value$^  if halfway  error  precisionbits  precisionbits  halfway  error $^     too imprecise. the caller will have to fall back to a slower version.$^     however the returned number is guaranteed to be either the correct$^     double or the nextlower double.$^    return false$^   else $^    return true$^  $^$^$^$^ returns$^    0 if buffer00exponent  diyfp.$^     0 if buffer00exponent  diyfp.$^    0 if buffer00exponent  diyfp.$^ preconditions$^   buffer.length  exponent  kmaxdecimalpower  0$^   buffer.length  exponent  kmindecimalpower$^   buffer.length  kmaxdecimalsignificantdigits$^static int comparebufferwithdiyfpvectorconst char buffer$^                                  int exponent$^                                  diyfp diyfp $^  assertbuffer.length  exponent  kmaxdecimalpower  0$^  assertbuffer.length  exponent  kmindecimalpower$^  assertbuffer.length  kmaxsignificantdecimaldigits$^   make sure that the bignum will be able to hold all our numbers.$^   our bignum implementation has a separate field for exponents. shifts will$^   consume at most one bigit  00 bits.$^   ln00  0.0000...$^  assertkmaxdecimalpower  0  000  000  bignumkmaxsignificantbits$^  bignum bufferbignum$^  bignum diyfpbignum$^  bufferbignum.assigndecimalstringbuffer$^  diyfpbignum.assignuint00diyfp.f$^  if exponent  0 $^    bufferbignum.multiplybypoweroftenexponent$^   else $^    diyfpbignum.multiplybypoweroftenexponent$^  $^  if diyfp.e  0 $^    diyfpbignum.shiftleftdiyfp.e$^   else $^    bufferbignum.shiftleftdiyfp.e$^  $^  return bignumcomparebufferbignum diyfpbignum$^$^$^$^ returns true if the guess is the correct double.$^ returns false when guess is either correct or the nextlower double.$^static bool computeguessvectorconst char trimmed int exponent$^                         double guess $^  if trimmed.length  0 $^    guess  0.0$^    return true$^  $^  if exponent  trimmed.length  0  kmaxdecimalpower $^    guess  doubleinfinity$^    return true$^  $^  if exponent  trimmed.length  kmindecimalpower $^    guess  0.0$^    return true$^  $^$^  if doublestrtodtrimmed exponent guess $^      diyfpstrtodtrimmed exponent guess $^    return true$^  $^  if guess  doubleinfinity $^    return true$^  $^  return false$^$^$^double strtodvectorconst char buffer int exponent $^  char copybufferkmaxsignificantdecimaldigits$^  vectorconst char trimmed$^  int updatedexponent$^  trimandcutbuffer exponent copybuffer kmaxsignificantdecimaldigits$^             trimmed updatedexponent$^  exponent  updatedexponent$^$^  double guess$^  bool iscorrect  computeguesstrimmed exponent guess$^  if iscorrect return guess$^$^  diyfp upperboundary  doubleguess.upperboundary$^  int comparison  comparebufferwithdiyfptrimmed exponent upperboundary$^  if comparison  0 $^    return guess$^   else if comparison  0 $^    return doubleguess.nextdouble$^   else if doubleguess.significand  0  0 $^     round towards even.$^    return guess$^   else $^    return doubleguess.nextdouble$^  $^$^$^float strtofvectorconst char buffer int exponent $^  char copybufferkmaxsignificantdecimaldigits$^  vectorconst char trimmed$^  int updatedexponent$^  trimandcutbuffer exponent copybuffer kmaxsignificantdecimaldigits$^             trimmed updatedexponent$^  exponent  updatedexponent$^$^  double doubleguess$^  bool iscorrect  computeguesstrimmed exponent doubleguess$^$^  float floatguess  staticcastfloatdoubleguess$^  if floatguess  doubleguess $^     this shortcut triggers for integer values.$^    return floatguess$^  $^$^   we must catch doublerounding. say the double has been rounded up and is$^   now a boundary of a float and rounds up again. this is why we have to$^   look at previous too.$^   example in decimal numbers$^      input 00000$^      highprecision 0 digits 0000$^      lowprecision 0 digits$^         when read from input 000$^         when rounded from high precision 000.$^   to do this we simply look at the neigbors of the correct result and see$^   if they would round to the same float. if the guess is not correct we have$^   to look at four values since two different doubles could be the correct$^   double.$^$^  double doublenext  doubledoubleguess.nextdouble$^  double doubleprevious  doubledoubleguess.previousdouble$^$^  float f0  staticcastfloatdoubleprevious$^  float f0  floatguess$^  float f0  staticcastfloatdoublenext$^  float f0$^  if iscorrect $^    f0  f0$^   else $^    double doublenext0  doubledoublenext.nextdouble$^    f0  staticcastfloatdoublenext0$^  $^  void f0   mark variable as used.$^  assertf0  f0  f0  f0  f0  f0$^$^   if the guess doesnt lie near a singleprecision boundary we can simply$^   return its floatvalue.$^  if f0  f0 $^    return floatguess$^  $^$^  assertf0  f0  f0  f0  f0  f0 $^         f0  f0  f0  f0  f0  f0 $^         f0  f0  f0  f0  f0  f0$^$^   guess and next are the two possible canditates in the same way that$^   doubleguess was the lower candidate for a doubleprecision guess.$^  float guess  f0$^  float next  f0$^  diyfp upperboundary$^  if guess  0.0f $^    float minfloat  0e00f$^    upperboundary  doublestaticcastdoubleminfloat  0.asdiyfp$^   else $^    upperboundary  singleguess.upperboundary$^  $^  int comparison  comparebufferwithdiyfptrimmed exponent upperboundary$^  if comparison  0 $^    return guess$^   else if comparison  0 $^    return next$^   else if singleguess.significand  0  0 $^     round towards even.$^    return guess$^   else $^    return next$^  $^$^$^   namespace kenlmdoubleconversion$^ copyright 0000 the v0 project authors. all rights reserved.$^ redistribution and use in source and binary forms with or without$^ modification are permitted provided that the following conditions are$^ met$^$^      redistributions of source code must retain the above copyright$^       notice this list of conditions and the following disclaimer.$^      redistributions in binary form must reproduce the above$^       copyright notice this list of conditions and the following$^       disclaimer in the documentation andor other materials provided$^       with the distribution.$^      neither the name of google inc. nor the names of its$^       contributors may be used to endorse or promote products derived$^       from this software without specific prior written permission.$^$^ this software is provided by the copyright holders and contributors$^ as is and any express or implied warranties including but not$^ limited to the implied warranties of merchantability and fitness for$^ a particular purpose are disclaimed. in no event shall the copyright$^ owner or contributors be liable for any direct indirect incidental$^ special exemplary or consequential damages including but not$^ limited to procurement of substitute goods or services loss of use$^ data or profits or business interruption however caused and on any$^ theory of liability whether in contract strict liability or tort$^ including negligence or otherwise arising in any way out of the use$^ of this software even if advised of the possibility of such damage.$^$^include fastdtoa.h$^$^include cachedpowers.h$^include diyfp.h$^include ieee.h$^$^namespace kenlmdoubleconversion $^$^ the minimal and maximal target exponent define the range of ws binary$^ exponent where w is the result of multiplying the input by a cached power$^ of ten.$^$^ a different range might be chosen on a different platform to optimize digit$^ generation but a smaller range requires more powers of ten to be cached.$^static const int kminimaltargetexponent  00$^static const int kmaximaltargetexponent  00$^$^$^ adjusts the last digit of the generated number and screens out generated$^ solutions that may be inaccurate. a solution may be inaccurate if it is$^ outside the safe interval or if we cannot prove that it is closer to the$^ input than a neighboring representation of the same length.$^$^ input  buffer containing the digits of toohigh  00kappa$^         the buffers length$^         distancetoohighw  toohigh  w.f  unit$^         unsafeinterval  toohigh  toolow.f  unit$^         rest  toohigh  buffer  00kappa.f  unit$^         tenkappa  00kappa  unit$^         unit  the common multiplier$^ output returns true if the buffer is guaranteed to contain the closest$^    representable number to the input.$^  modifies the generated digits in the buffer to approach round towards w.$^static bool roundweedvectorchar buffer$^                      int length$^                      uint00t distancetoohighw$^                      uint00t unsafeinterval$^                      uint00t rest$^                      uint00t tenkappa$^                      uint00t unit $^  uint00t smalldistance  distancetoohighw  unit$^  uint00t bigdistance  distancetoohighw  unit$^   let wlow   toohigh  bigdistance and$^       whigh  toohigh  smalldistance.$^   note wlow  w  whigh$^  $^   the real w  unit must lie somewhere inside the interval$^   wlow whigh often written as wlow whigh$^$^   basically the buffer currently contains a number in the unsafe interval$^   toolow toohigh with toolow  w  toohigh$^  $^    toohigh                                 $^                       v 0 unit                                         $^    boundaryhigh      .      .                 .      .$^                       v 0 unit            .      .                 .      .$^                                        .      .$^                                            .      .                .      .$^                                            .  bigdistance  .       .      .$^                                            .      .         .       .    rest$^                                smalldistance     .         .       .      .$^                                            v      .         .       .      .$^    whigh                       .         .       .      .$^                       v 0 unit                   .         .       .      .$^    w      .         .       .      .$^                       v 0 unit                   v         .       .      .$^    wlow                               .       .      .$^                                                             .       .      v$^    buffer $^                                                             .       .$^                                                    safeinterval    .$^                                                             v       .$^                                       .$^                       v 0 unit                                     .$^    boundarylow                      unsafeinterval$^                       v 0 unit                                     v$^    toolow                                  $^  $^  $^   note that the value of buffer could lie anywhere inside the range toolow$^   to toohigh.$^  $^   boundarylow boundaryhigh and w are approximations of the real boundaries$^   and v the input number. they are guaranteed to be precise up to one unit.$^   in fact the error is guaranteed to be strictly less than one unit.$^  $^   anything that lies outside the unsafe interval is guaranteed not to round$^   to v when read again.$^   anything that lies inside the safe interval is guaranteed to round to v$^   when read again.$^   if the number inside the buffer lies inside the unsafe interval but not$^   inside the safe interval then we simply do not know and bail out returning$^   false.$^  $^   similarly we have to take into account the imprecision of w when finding$^   the closest representation of w. if we have two potential$^   representations and one is closer to both wlow and whigh then we know$^   it is closer to the actual value v.$^  $^   by generating the digits of toohigh we got the largest closest to$^   toohigh buffer that is still in the unsafe interval. in the case where$^   whigh  buffer  toohigh we try to decrement the buffer.$^   this way the buffer approaches rounds towards w.$^   there are 0 conditions that stop the decrementation process$^     0 the buffer is already below whigh$^     0 decrementing the buffer would make it leave the unsafe interval$^     0 decrementing the buffer would yield a number below whigh and farther$^        away than the current number. in other words$^                buffer0  whigh  whigh  buffer0  buffer  whigh$^   instead of using the buffer directly we use its distance to toohigh.$^   conceptually rest  toohigh  buffer$^   we need to do the following tests in this order to avoid over and$^   underflows.$^  assertrest  unsafeinterval$^  while rest  smalldistance    negated condition 0$^         unsafeinterval  rest  tenkappa    negated condition 0$^         rest  tenkappa  smalldistance    buffer0  whigh$^          smalldistance  rest  rest  tenkappa  smalldistance $^    bufferlength  0$^    rest  tenkappa$^  $^$^   we have approached w as much as possible. we now test if approaching w$^   would require changing the buffer. if yes then we have two possible$^   representations close to w but we cannot decide which one is closer.$^  if rest  bigdistance $^      unsafeinterval  rest  tenkappa $^      rest  tenkappa  bigdistance $^       bigdistance  rest  rest  tenkappa  bigdistance $^    return false$^  $^$^   weeding test.$^     the safe interval is toolow  0 ulp toohigh  0 ulp$^     since toolow  toohigh  unsafeinterval this is equivalent to$^        toohigh  unsafeinterval  0 ulp toohigh  0 ulp$^     conceptually we have rest  toohigh  buffer$^  return 0  unit  rest  rest  unsafeinterval  0  unit$^$^$^$^ rounds the buffer upwards if the result is closer to v by possibly adding$^ 0 to the buffer. if the precision of the calculation is not sufficient to$^ round correctly return false.$^ the rounding might shift the whole buffer in which case the kappa is$^ adjusted. for example 00 kappa  0 might become 00 kappa  0.$^$^ if 0rest  tenkappa then the buffer needs to be round up.$^ rest can have an error of  0 unit. this function accounts for the$^ imprecision and returns false if the rounding direction cannot be$^ unambiguously determined.$^$^ precondition rest  tenkappa.$^static bool roundweedcountedvectorchar buffer$^                             int length$^                             uint00t rest$^                             uint00t tenkappa$^                             uint00t unit$^                             int kappa $^  assertrest  tenkappa$^   the following tests are done in a specific order to avoid overflows. they$^   will work correctly with any uint00 values of rest  tenkappa and unit.$^  $^   if the unit is too big then we dont know which way to round. for example$^   a unit of 00 means that the real number lies within rest  00. if$^   00kappa  00 then there is no way to tell which way to round.$^  if unit  tenkappa return false$^   even if unit is just half the size of 00kappa we are already completely$^   lost. and after the previous test we know that the expression will not$^   overunderflow.$^  if tenkappa  unit  unit return false$^   if 0  rest  unit  00kappa we can safely round down.$^  if tenkappa  rest  rest  tenkappa  0  rest  0  unit $^    return true$^  $^   if 0  rest  unit  00kappa then we can safely round up.$^  if rest  unit  tenkappa  rest  unit  rest  unit $^     increment the last digit recursively until we find a non 0 digit.$^    bufferlength  0$^    for int i  length  0 i  0 i $^      if bufferi  0  00 break$^      bufferi  0$^      bufferi  0$^    $^     if the first digit is now 0 00 we had a buffer with all 0s. with the$^     exception of the first digit all digits are now 0. simply switch the$^     first digit to 0 and adjust the kappa. example 00 becomes 00 and$^     the power the kappa is increased.$^    if buffer0  0  00 $^      buffer0  0$^      kappa  0$^    $^    return true$^  $^  return false$^$^$^ returns the biggest power of ten that is less than or equal to the given$^ number. we furthermore receive the maximum number of bits number has.$^$^ returns power  00exponentplusone0 such that$^    power  number  power  00.$^ if numberbits  0 then 000 is returned.$^ the number of bits must be  00.$^ precondition number  0  numberbits  0.$^$^ inspired by the method for finding an integer log base 00 from here$^ httpgraphics.stanford.eduseanderbithacks.htmlintegerlog00$^static unsigned int const ksmallpowersoften $^    0 0 00 000 0000 00000 000000 0000000 00000000 000000000$^     0000000000$^$^static void biggestpowertenuint00t number$^                            int numberbits$^                            uint00t power$^                            int exponentplusone $^  assertnumber  0u  numberbits  0$^   00000000 is approximately 0lg00.$^  int exponentplusoneguess  numberbits  0  0000  00$^   we increment to skip over the first entry in the kpowersof00 table.$^   note kpowersof00i  00i0.$^  exponentplusoneguess$^   we dont have any guarantees that 0numberbits  number.$^  if number  ksmallpowersoftenexponentplusoneguess $^    exponentplusoneguess$^  $^  power  ksmallpowersoftenexponentplusoneguess$^  exponentplusone  exponentplusoneguess$^$^$^ generates the digits of input number w.$^ w is a floatingpoint number diyfp consisting of a significand and an$^ exponent. its exponent is bounded by kminimaltargetexponent and$^ kmaximaltargetexponent.$^       hence 00  w.e  00.$^$^ returns false if it fails in which case the generated digits in the buffer$^ should not be used.$^ preconditions$^   low w and high are correct up to 0 ulp unit in the last place. that$^    is their error must be less than a unit of their last digits.$^   low.e  w.e  high.e$^   low  w  high and taking into account their error low  high$^   kminimaltargetexponent  w.e  kmaximaltargetexponent$^ postconditions returns false if procedure fails.$^   otherwise$^      buffer is not nullterminated but len contains the number of digits.$^      buffer contains the shortest possible decimal digitsequence$^       such that low  buffer  00kappa  high where low and high are the$^       correct values of low and high without their error.$^      if more than one decimal representation gives the minimal number of$^       decimal digits then the one closest to w where w is the correct value$^       of w is chosen.$^ remark this procedure takes into account the imprecision of its input$^   numbers. if the precision is not enough to guarantee all the postconditions$^   then false is returned. this usually happens rarely 0.0.$^$^ say for the sake of example that$^   w.e  00 and w.f  0x0000000000abcdef$^ ws value can be computed by w.f  0w.e$^ we can obtain ws integral digits by simply shifting w.f by w.e.$^   ws integral part is 0x0000$^  ws fractional part is therefore 0x000000abcdef.$^ printing ws integral part is easy simply print 0x0000 in decimal.$^ in order to print its fraction we repeatedly multiply the fraction by 00 and$^ get each digit. example the first digit after the point would be computed by$^   0x000000abcdef  00  00.  0$^ the whole thing becomes slightly more complicated because we want to stop$^ once we have enough digits. that is once the digits inside the buffer$^ represent w we can stop. everything inside the interval low  high$^ represents w. however we have to pay attention to low high and ws$^ imprecision.$^static bool digitgendiyfp low$^                     diyfp w$^                     diyfp high$^                     vectorchar buffer$^                     int length$^                     int kappa $^  assertlow.e  w.e  w.e  high.e$^  assertlow.f  0  high.f  0$^  assertkminimaltargetexponent  w.e  w.e  kmaximaltargetexponent$^   low w and high are imprecise but by less than one ulp unit in the last$^   place.$^   if we remove resp. add 0 ulp from low resp. high we are certain that$^   the new numbers are outside of the interval we want the final$^   representation to lie in.$^   inversely adding resp. removing 0 ulp from low resp. high would yield$^   numbers that are certain to lie in the interval. we will use this fact$^   later on.$^   we will now start by generating the digits within the uncertain$^   interval. later we will weed out representations that lie outside the safe$^   interval and thus might lie outside the correct interval.$^  uint00t unit  0$^  diyfp toolow  diyfplow.f  unit low.e$^  diyfp toohigh  diyfphigh.f  unit high.e$^   toolow and toohigh are guaranteed to lie outside the interval we want the$^   generated number in.$^  diyfp unsafeinterval  diyfpminustoohigh toolow$^   we now cut the input number into two parts the integral digits and the$^   fractionals. we will not write any decimal separator though but adapt$^   kappa instead.$^   reminder we are currently computing the digits stored inside the buffer$^   such that   toolow  buffer  00kappa  toohigh$^   we use toohigh for the digitgeneration and stop as soon as possible.$^   if we stop early we effectively round down.$^  diyfp one  diyfpstaticcastuint00t0  w.e w.e$^   division by one is a shift.$^  uint00t integrals  staticcastuint00ttoohigh.f  one.e$^   modulo by one is an and.$^  uint00t fractionals  toohigh.f  one.f  0$^  uint00t divisor$^  int divisorexponentplusone$^  biggestpowertenintegrals diyfpksignificandsize  one.e$^                  divisor divisorexponentplusone$^  kappa  divisorexponentplusone$^  length  0$^   loop invariant buffer  toohigh  00kappa  integer division$^   the invariant holds for the first iteration kappa has been initialized$^   with the divisor exponent  0. and the divisor is the biggest power of ten$^   that is smaller than integrals.$^  while kappa  0 $^    int digit  integrals  divisor$^    assertdigit  0$^    bufferlength  staticcastchar0  digit$^    length$^    integrals  divisor$^    kappa$^     note that kappa now equals the exponent of the divisor and that the$^     invariant thus holds again.$^    uint00t rest $^        staticcastuint00tintegrals  one.e  fractionals$^     invariant toohigh  buffer  00kappa  diyfprest one.e$^     reminder unsafeinterval.e  one.e$^    if rest  unsafeinterval.f $^       rounding down by not emitting the remaining digits yields a number$^       that lies within the unsafe interval.$^      return roundweedbuffer length diyfpminustoohigh w.f$^                       unsafeinterval.f rest$^                       staticcastuint00tdivisor  one.e unit$^    $^    divisor  00$^  $^$^   the integrals have been generated. we are at the point of the decimal$^   separator. in the following loop we simply multiply the remaining digits by$^   00 and divide by one. we just need to pay attention to multiply associated$^   data like the interval or unit too.$^   note that the multiplication by 00 does not overflow because w.e  00$^   and thus one.e  00.$^  assertone.e  00$^  assertfractionals  one.f$^  assertuint000partc0xffffffff ffffffff  00  one.f$^  for  $^    fractionals  00$^    unit  00$^    unsafeinterval.setfunsafeinterval.f  00$^     integer division by one.$^    int digit  staticcastintfractionals  one.e$^    assertdigit  0$^    bufferlength  staticcastchar0  digit$^    length$^    fractionals  one.f  0   modulo by one.$^    kappa$^    if fractionals  unsafeinterval.f $^      return roundweedbuffer length diyfpminustoohigh w.f  unit$^                       unsafeinterval.f fractionals one.f unit$^    $^  $^$^$^$^$^ generates at most requesteddigits digits of input number w.$^ w is a floatingpoint number diyfp consisting of a significand and an$^ exponent. its exponent is bounded by kminimaltargetexponent and$^ kmaximaltargetexponent.$^       hence 00  w.e  00.$^$^ returns false if it fails in which case the generated digits in the buffer$^ should not be used.$^ preconditions$^   w is correct up to 0 ulp unit in the last place. that$^    is its error must be strictly less than a unit of its last digit.$^   kminimaltargetexponent  w.e  kmaximaltargetexponent$^$^ postconditions returns false if procedure fails.$^   otherwise$^      buffer is not nullterminated but length contains the number of$^       digits.$^      the representation in buffer is the most precise representation of$^       requesteddigits digits.$^      buffer contains at most requesteddigits digits of w. if there are less$^       than requesteddigits digits then some trailing 0s have been removed.$^      kappa is such that$^            w  buffer  00kappa  eps with eps  00kappa  0.$^$^ remark this procedure takes into account the imprecision of its input$^   numbers. if the precision is not enough to guarantee all the postconditions$^   then false is returned. this usually happens rarely but the failurerate$^   increases with higher requesteddigits.$^static bool digitgencounteddiyfp w$^                            int requesteddigits$^                            vectorchar buffer$^                            int length$^                            int kappa $^  assertkminimaltargetexponent  w.e  w.e  kmaximaltargetexponent$^  assertkminimaltargetexponent  00$^  assertkmaximaltargetexponent  00$^   w is assumed to have an error less than 0 unit. whenever w is scaled we$^   also scale its error.$^  uint00t werror  0$^   we cut the input number into two parts the integral digits and the$^   fractional digits. we dont emit any decimal separator but adapt kappa$^   instead. example instead of writing 0.0 we put 00 into the buffer and$^   increase kappa by 0.$^  diyfp one  diyfpstaticcastuint00t0  w.e w.e$^   division by one is a shift.$^  uint00t integrals  staticcastuint00tw.f  one.e$^   modulo by one is an and.$^  uint00t fractionals  w.f  one.f  0$^  uint00t divisor$^  int divisorexponentplusone$^  biggestpowertenintegrals diyfpksignificandsize  one.e$^                  divisor divisorexponentplusone$^  kappa  divisorexponentplusone$^  length  0$^$^   loop invariant buffer  w  00kappa  integer division$^   the invariant holds for the first iteration kappa has been initialized$^   with the divisor exponent  0. and the divisor is the biggest power of ten$^   that is smaller than integrals.$^  while kappa  0 $^    int digit  integrals  divisor$^    assertdigit  0$^    bufferlength  staticcastchar0  digit$^    length$^    requesteddigits$^    integrals  divisor$^    kappa$^     note that kappa now equals the exponent of the divisor and that the$^     invariant thus holds again.$^    if requesteddigits  0 break$^    divisor  00$^  $^$^  if requesteddigits  0 $^    uint00t rest $^        staticcastuint00tintegrals  one.e  fractionals$^    return roundweedcountedbuffer length rest$^                            staticcastuint00tdivisor  one.e werror$^                            kappa$^  $^$^   the integrals have been generated. we are at the point of the decimal$^   separator. in the following loop we simply multiply the remaining digits by$^   00 and divide by one. we just need to pay attention to multiply associated$^   data the unit too.$^   note that the multiplication by 00 does not overflow because w.e  00$^   and thus one.e  00.$^  assertone.e  00$^  assertfractionals  one.f$^  assertuint000partc0xffffffff ffffffff  00  one.f$^  while requesteddigits  0  fractionals  werror $^    fractionals  00$^    werror  00$^     integer division by one.$^    int digit  staticcastintfractionals  one.e$^    assertdigit  0$^    bufferlength  staticcastchar0  digit$^    length$^    requesteddigits$^    fractionals  one.f  0   modulo by one.$^    kappa$^  $^  if requesteddigits  0 return false$^  return roundweedcountedbuffer length fractionals one.f werror$^                          kappa$^$^$^$^ provides a decimal representation of v.$^ returns true if it succeeds otherwise the result cannot be trusted.$^ there will be length digits inside the buffer not nullterminated.$^ if the function returns true then$^        v  double buffer  00decimalexponent.$^ the digits in the buffer are the shortest representation possible no$^ 0.00000000000000000 instead of 0.0. the shorter representation will even be$^ chosen even if the longer one would be closer to v.$^ the last digit will be closest to the actual v. that is even if several$^ digits might correctly yield v when read again the closest will be$^ computed.$^static bool grisu0double v$^                   fastdtoamode mode$^                   vectorchar buffer$^                   int length$^                   int decimalexponent $^  diyfp w  doublev.asnormalizeddiyfp$^   boundaryminus and boundaryplus are the boundaries between v and its$^   closest floatingpoint neighbors. any number strictly between$^   boundaryminus and boundaryplus will round to v when convert to a double.$^   grisu0 will never output representations that lie exactly on a boundary.$^  diyfp boundaryminus boundaryplus$^  if mode  fastdtoashortest $^    doublev.normalizedboundariesboundaryminus boundaryplus$^   else $^    assertmode  fastdtoashortestsingle$^    float singlev  staticcastfloatv$^    singlesinglev.normalizedboundariesboundaryminus boundaryplus$^  $^  assertboundaryplus.e  w.e$^  diyfp tenmk   cached power of ten 00k$^  int mk         k$^  int tenmkminimalbinaryexponent $^     kminimaltargetexponent  w.e  diyfpksignificandsize$^  int tenmkmaximalbinaryexponent $^     kmaximaltargetexponent  w.e  diyfpksignificandsize$^  powersoftencachegetcachedpowerforbinaryexponentrange$^      tenmkminimalbinaryexponent$^      tenmkmaximalbinaryexponent$^      tenmk mk$^  assertkminimaltargetexponent  w.e  tenmk.e $^          diyfpksignificandsize $^         kmaximaltargetexponent  w.e  tenmk.e $^          diyfpksignificandsize$^   note that tenmk is only an approximation of 00k. a diyfp only contains a$^   00 bit significand and tenmk is thus only precise up to 00 bits.$^$^   the diyfptimes procedure rounds its result and tenmk is approximated$^   too. the variable scaledw as well as scaledboundaryminusplus are now$^   off by a small amount.$^   in fact scaledw  w00k  0ulp unit in the last place of scaledw.$^   in other words let f  scaledw.f and e  scaledw.e then$^             f0  0e  w00k  f0  0e$^  diyfp scaledw  diyfptimesw tenmk$^  assertscaledw.e $^         boundaryplus.e  tenmk.e  diyfpksignificandsize$^   in theory it would be possible to avoid some recomputations by computing$^   the difference between w and boundaryminusplus a power of 0 and to$^   compute scaledboundaryminusplus by subtractingadding from$^   scaledw. however the code becomes much less readable and the speed$^   enhancements are not terriffic.$^  diyfp scaledboundaryminus  diyfptimesboundaryminus tenmk$^  diyfp scaledboundaryplus   diyfptimesboundaryplus  tenmk$^$^   digitgen will generate the digits of scaledw. therefore we have$^   v  double scaledw  00mk.$^   set decimalexponent  mk and pass it to digitgen. if scaledw is not an$^   integer than it will be updated. for instance if scaledw  0.00 then$^   the buffer will be filled with 000 und the decimalexponent will be$^   decreased by 0.$^  int kappa$^  bool result  digitgenscaledboundaryminus scaledw scaledboundaryplus$^                         buffer length kappa$^  decimalexponent  mk  kappa$^  return result$^$^$^$^ the counted version of grisu0 see above only generates requesteddigits$^ number of digits. this version does not generate the shortest representation$^ and with enough requested digits 0.0 will at some point print as 0.0000000...$^ grisu0 is too imprecise for real halfway cases 0.0 will not work and$^ therefore the rounding strategy for halfway cases is irrelevant.$^static bool grisu0counteddouble v$^                          int requesteddigits$^                          vectorchar buffer$^                          int length$^                          int decimalexponent $^  diyfp w  doublev.asnormalizeddiyfp$^  diyfp tenmk   cached power of ten 00k$^  int mk         k$^  int tenmkminimalbinaryexponent $^     kminimaltargetexponent  w.e  diyfpksignificandsize$^  int tenmkmaximalbinaryexponent $^     kmaximaltargetexponent  w.e  diyfpksignificandsize$^  powersoftencachegetcachedpowerforbinaryexponentrange$^      tenmkminimalbinaryexponent$^      tenmkmaximalbinaryexponent$^      tenmk mk$^  assertkminimaltargetexponent  w.e  tenmk.e $^          diyfpksignificandsize $^         kmaximaltargetexponent  w.e  tenmk.e $^          diyfpksignificandsize$^   note that tenmk is only an approximation of 00k. a diyfp only contains a$^   00 bit significand and tenmk is thus only precise up to 00 bits.$^$^   the diyfptimes procedure rounds its result and tenmk is approximated$^   too. the variable scaledw as well as scaledboundaryminusplus are now$^   off by a small amount.$^   in fact scaledw  w00k  0ulp unit in the last place of scaledw.$^   in other words let f  scaledw.f and e  scaledw.e then$^             f0  0e  w00k  f0  0e$^  diyfp scaledw  diyfptimesw tenmk$^$^   we now have double scaledw  00mk.$^   digitgen will generate the first requesteddigits digits of scaledw and$^   return together with a kappa such that scaledw  buffer  00kappa. it$^   will not always be exactly the same since digitgencounted only produces a$^   limited number of digits.$^  int kappa$^  bool result  digitgencountedscaledw requesteddigits$^                                buffer length kappa$^  decimalexponent  mk  kappa$^  return result$^$^$^$^bool fastdtoadouble v$^              fastdtoamode mode$^              int requesteddigits$^              vectorchar buffer$^              int length$^              int decimalpoint $^  assertv  0$^  assertdoublev.isspecial$^$^  bool result  false$^  int decimalexponent  0$^  switch mode $^    case fastdtoashortest$^    case fastdtoashortestsingle$^      result  grisu0v mode buffer length decimalexponent$^      break$^    case fastdtoaprecision$^      result  grisu0countedv requesteddigits$^                             buffer length decimalexponent$^      break$^    default$^      unreachable$^  $^  if result $^    decimalpoint  length  decimalexponent$^    bufferlength  0$^  $^  return result$^$^$^   namespace kenlmdoubleconversion$^ copyright 00000000 the v0 project authors. all rights reserved.$^ redistribution and use in source and binary forms with or without$^ modification are permitted provided that the following conditions are$^ met$^$^      redistributions of source code must retain the above copyright$^       notice this list of conditions and the following disclaimer.$^      redistributions in binary form must reproduce the above$^       copyright notice this list of conditions and the following$^       disclaimer in the documentation andor other materials provided$^       with the distribution.$^      neither the name of google inc. nor the names of its$^       contributors may be used to endorse or promote products derived$^       from this software without specific prior written permission.$^$^ this software is provided by the copyright holders and contributors$^ as is and any express or implied warranties including but not$^ limited to the implied warranties of merchantability and fitness for$^ a particular purpose are disclaimed. in no event shall the copyright$^ owner or contributors be liable for any direct indirect incidental$^ special exemplary or consequential damages including but not$^ limited to procurement of substitute goods or services loss of use$^ data or profits or business interruption however caused and on any$^ theory of liability whether in contract strict liability or tort$^ including negligence or otherwise arising in any way out of the use$^ of this software even if advised of the possibility of such damage.$^$^include stdarg.h$^include limits.h$^include math.h$^$^include utils.h$^$^include cachedpowers.h$^$^namespace kenlmdoubleconversion $^$^struct cachedpower $^  uint00t significand$^  int00t binaryexponent$^  int00t decimalexponent$^$^$^static const cachedpower kcachedpowers  $^  uint000partc0xfa0fd0a0 000c0000 0000 000$^  uint000partc0xbaaee00f a00ebf00 0000 000$^  uint000partc0x0b00fb00 0000ac00 0000 000$^  uint000partc0xcf00000a 0dce00ea 0000 000$^  uint000partc0x0a0bb0aa 00000b0d 0000 000$^  uint000partc0xe00acf00 0d0a00df 0000 000$^  uint000partc0xab00fe00 c00ac0ca 0000 000$^  uint000partc0xff00b0fc bebcdc0f 0000 000$^  uint000partc0xbe0000ef 000bd00c 0000 000$^  uint000partc0x0dd00fad 000ffc0c 000 000$^  uint000partc0xd0000c00 00000a00 000 000$^  uint000partc0x0d00ac0f ada0c0b0 000 000$^  uint000partc0xea0c0000 00ee0bcb 000 000$^  uint000partc0xaecc0000 0000000d 000 000$^  uint000partc0x000c0000 0db0ce00 000 000$^  uint000partc0xc0000000 0dfb0000 000 000$^  uint000partc0x0000ea0f 0000000f 000 000$^  uint000partc0xd00000cb 00000ac0 000 000$^  uint000partc0xa000cfcd 00bf00f0 000 000$^  uint000partc0xef000a00 000aace0 000 000$^  uint000partc0xb00000fb 0a00b00e 000 000$^  uint000partc0x00c0d0df d0c00f0b 000 000$^  uint000partc0xc0dd0000 0ad0cdba 000 000$^  uint000partc0x000b0fce bb00c000 000 000$^  uint000partc0xdbac0c00 0d00a000 000 000$^  uint000partc0xa0ab0000 0d0fdaf0 000 000$^  uint000partc0xf0e0f000 dec0f000 000 000$^  uint000partc0xb0b0ada0 aaff00b0 000 000$^  uint000partc0x00000f00 0c0c0a0b 000 000$^  uint000partc0xc0bcff00 00c00000 000 000$^  uint000partc0x000e000c 00ba0000 000 000$^  uint000partc0xdff00000 00000ebd 000 000$^  uint000partc0xa0dfbd0f b0e0b00f 000 00$^  uint000partc0xf0a00fcf 00000d00 000 00$^  uint000partc0xb0000000 0fa00bcf 000 00$^  uint000partc0x0a00f0f0 bf0f000b 000 00$^  uint000partc0xcdb00000 000000b0 000 00$^  uint000partc0x000fe0c0 d00b0fac 000 00$^  uint000partc0xe00c00c0 0a0b0b00 000 00$^  uint000partc0xaa000000 000000d0 000 00$^  uint000partc0xfd00b0f0 0000ca0e 000 00$^  uint000partc0xbce00000 00000aeb 000 00$^  uint000partc0x0cbccc00 0f0000cc 000 00$^  uint000partc0xd0b00000 e000000c 00 0$^  uint000partc0x0c000000 00000000 00 0$^  uint000partc0xe0d0a000 00000000 00 00$^  uint000partc0xad00ebc0 ac000000 0 00$^  uint000partc0x000f0000 f0000000 00 00$^  uint000partc0xc000ce0b c00000b0 00 00$^  uint000partc0x0f0e00ce 0bea0c00 00 00$^  uint000partc0xd0d000a0 abe00000 000 00$^  uint000partc0x0f0f0000 000a0000 000 00$^  uint000partc0xed00a000 d0c0fb00 000 00$^  uint000partc0xb0de0000 0cc0ada0 000 00$^  uint000partc0x00c0000e 0aab00db 000 00$^  uint000partc0xc00d0df0 00000d0a 000 00$^  uint000partc0x000d000c a00be000 000 000$^  uint000partc0xda00ee00 0a000dea 000 000$^  uint000partc0xa00da000 0aef000a 000 000$^  uint000partc0xf000000b b00d0b00 000 000$^  uint000partc0xb000e0a0 00dd0000 000 000$^  uint000partc0x000b0000 0b0bc0c0 000 000$^  uint000partc0xc00000c0 c0000d0d 000 000$^  uint000partc0x000ab00c fa00a0b0 000 000$^  uint000partc0xde000fbd 00a00fe0 000 000$^  uint000partc0xa00bc000 db000c00 000 000$^  uint000partc0xf0c00a00 a0000f0c 000 000$^  uint000partc0xb0dcbf00 00e0bece 000 000$^  uint000partc0x00fcf000 f00000e0 000 000$^  uint000partc0xcc00ce0b d00c00a0 000 000$^  uint000partc0x00000af0 0b0000df 000 000$^  uint000partc0xe0a0b0dc 000f000a 000 000$^  uint000partc0xa0d0d000 0ce0b000 000 000$^  uint000partc0xfb0b0cd0 a0a0000c 000 000$^  uint000partc0xbb000c0c a0a00000 000 000$^  uint000partc0x0bab0eef b0000c0a 000 000$^  uint000partc0xd00fef00 a000000c 000 000$^  uint000partc0x0b00a0e0 e0000000 000 000$^  uint000partc0xe0000bfb a00c0c0d 000 000$^  uint000partc0xac0000d0 000bf000 000 000$^  uint000partc0x00000b0e 0aa0cf00 000 000$^  uint000partc0xbf00e000 00acdd0d 000 000$^  uint000partc0x0e000c0f 0e00ff0f 000 000$^  uint000partc0xd000000d 0c0cb000 000 000$^  uint000partc0x0e00db00 b0e00ba0 0000 000$^  uint000partc0xeb00bf0e badf00d0 0000 000$^  uint000partc0xaf00000b 0bf0ee0b 0000 000$^$^$^static const int kcachedpowersoffset  000   0  the first decimalexponent.$^static const double kd0log000  0.00000000000000000    0  lg00$^ difference between the decimal exponents in the table above.$^const int powersoftencachekdecimalexponentdistance  0$^const int powersoftencachekmindecimalexponent  000$^const int powersoftencachekmaxdecimalexponent  000$^$^void powersoftencachegetcachedpowerforbinaryexponentrange$^    int minexponent$^    int maxexponent$^    diyfp power$^    int decimalexponent $^  int kq  diyfpksignificandsize$^  double k  ceilminexponent  kq  0  kd0log000$^  int foo  kcachedpowersoffset$^  int index $^      foo  staticcastintk  0  kdecimalexponentdistance  0$^  assert0  index  index  staticcastintarraysizekcachedpowers$^  cachedpower cachedpower  kcachedpowersindex$^  assertminexponent  cachedpower.binaryexponent$^  void maxexponent   mark variable as used.$^  assertcachedpower.binaryexponent  maxexponent$^  decimalexponent  cachedpower.decimalexponent$^  power  diyfpcachedpower.significand cachedpower.binaryexponent$^$^$^$^void powersoftencachegetcachedpowerfordecimalexponentint requestedexponent$^                                                        diyfp power$^                                                        int foundexponent $^  assertkmindecimalexponent  requestedexponent$^  assertrequestedexponent  kmaxdecimalexponent  kdecimalexponentdistance$^  int index $^      requestedexponent  kcachedpowersoffset  kdecimalexponentdistance$^  cachedpower cachedpower  kcachedpowersindex$^  power  diyfpcachedpower.significand cachedpower.binaryexponent$^  foundexponent  cachedpower.decimalexponent$^  assertfoundexponent  requestedexponent$^  assertrequestedexponent  foundexponent  kdecimalexponentdistance$^$^$^   namespace kenlmdoubleconversion$^ copyright 0000 the v0 project authors. all rights reserved.$^ redistribution and use in source and binary forms with or without$^ modification are permitted provided that the following conditions are$^ met$^$^      redistributions of source code must retain the above copyright$^       notice this list of conditions and the following disclaimer.$^      redistributions in binary form must reproduce the above$^       copyright notice this list of conditions and the following$^       disclaimer in the documentation andor other materials provided$^       with the distribution.$^      neither the name of google inc. nor the names of its$^       contributors may be used to endorse or promote products derived$^       from this software without specific prior written permission.$^$^ this software is provided by the copyright holders and contributors$^ as is and any express or implied warranties including but not$^ limited to the implied warranties of merchantability and fitness for$^ a particular purpose are disclaimed. in no event shall the copyright$^ owner or contributors be liable for any direct indirect incidental$^ special exemplary or consequential damages including but not$^ limited to procurement of substitute goods or services loss of use$^ data or profits or business interruption however caused and on any$^ theory of liability whether in contract strict liability or tort$^ including negligence or otherwise arising in any way out of the use$^ of this software even if advised of the possibility of such damage.$^$^include limits.h$^include math.h$^$^include doubleconversion.h$^$^include bignumdtoa.h$^include fastdtoa.h$^include fixeddtoa.h$^include ieee.h$^include strtod.h$^include utils.h$^$^namespace kenlmdoubleconversion $^$^const doubletostringconverter doubletostringconverterecmascriptconverter $^  int flags  uniquezero  emitpositiveexponentsign$^  static doubletostringconverter converterflags$^                                           infinity$^                                           nan$^                                           e$^                                           0 00$^                                           0 0$^  return converter$^$^$^$^bool doubletostringconverterhandlespecialvalues$^    double value$^    stringbuilder resultbuilder const $^  double doubleinspectvalue$^  if doubleinspect.isinfinite $^    if infinitysymbol  null return false$^    if value  0 $^      resultbuilderaddcharacter$^    $^    resultbuilderaddstringinfinitysymbol$^    return true$^  $^  if doubleinspect.isnan $^    if nansymbol  null return false$^    resultbuilderaddstringnansymbol$^    return true$^  $^  return false$^$^$^$^void doubletostringconvertercreateexponentialrepresentation$^    const char decimaldigits$^    int length$^    int exponent$^    stringbuilder resultbuilder const $^  assertlength  0$^  resultbuilderaddcharacterdecimaldigits0$^  if length  0 $^    resultbuilderaddcharacter.$^    resultbuilderaddsubstringdecimaldigits0 length0$^  $^  resultbuilderaddcharacterexponentcharacter$^  if exponent  0 $^    resultbuilderaddcharacter$^    exponent  exponent$^   else $^    if flags  emitpositiveexponentsign  0 $^      resultbuilderaddcharacter$^    $^  $^  if exponent  0 $^    resultbuilderaddcharacter0$^    return$^  $^  assertexponent  0e0$^  const int kmaxexponentlength  0$^  char bufferkmaxexponentlength  0$^  bufferkmaxexponentlength  0$^  int firstcharpos  kmaxexponentlength$^  while exponent  0 $^    bufferfirstcharpos  0  exponent  00$^    exponent  00$^  $^  resultbuilderaddsubstringbufferfirstcharpos$^                               kmaxexponentlength  firstcharpos$^$^$^$^void doubletostringconvertercreatedecimalrepresentation$^    const char decimaldigits$^    int length$^    int decimalpoint$^    int digitsafterpoint$^    stringbuilder resultbuilder const $^   create a representation that is padded with zeros if needed.$^  if decimalpoint  0 $^       0.00000decimalrep or 0.000decimalrep00.$^    resultbuilderaddcharacter0$^    if digitsafterpoint  0 $^      resultbuilderaddcharacter.$^      resultbuilderaddpadding0 decimalpoint$^      assertlength  digitsafterpoint  decimalpoint$^      resultbuilderaddsubstringdecimaldigits length$^      int remainingdigits  digitsafterpoint  decimalpoint  length$^      resultbuilderaddpadding0 remainingdigits$^    $^   else if decimalpoint  length $^     decimalrep0000.00000 or decimalrep.0000.$^    resultbuilderaddsubstringdecimaldigits length$^    resultbuilderaddpadding0 decimalpoint  length$^    if digitsafterpoint  0 $^      resultbuilderaddcharacter.$^      resultbuilderaddpadding0 digitsafterpoint$^    $^   else $^     decima.lrep000.$^    assertdigitsafterpoint  0$^    resultbuilderaddsubstringdecimaldigits decimalpoint$^    resultbuilderaddcharacter.$^    assertlength  decimalpoint  digitsafterpoint$^    resultbuilderaddsubstringdecimaldigitsdecimalpoint$^                                 length  decimalpoint$^    int remainingdigits  digitsafterpoint  length  decimalpoint$^    resultbuilderaddpadding0 remainingdigits$^  $^  if digitsafterpoint  0 $^    if flags  emittrailingdecimalpoint  0 $^      resultbuilderaddcharacter.$^    $^    if flags  emittrailingzeroafterpoint  0 $^      resultbuilderaddcharacter0$^    $^  $^$^$^$^bool doubletostringconvertertoshortestieeenumber$^    double value$^    stringbuilder resultbuilder$^    doubletostringconverterdtoamode mode const $^  assertmode  shortest  mode  shortestsingle$^  if doublevalue.isspecial $^    return handlespecialvaluesvalue resultbuilder$^  $^$^  int decimalpoint$^  bool sign$^  const int kdecimalrepcapacity  kbase00maximallength  0$^  char decimalrepkdecimalrepcapacity$^  int decimalreplength$^$^  doubletoasciivalue mode 0 decimalrep kdecimalrepcapacity$^                sign decimalreplength decimalpoint$^$^  bool uniquezero  flags  uniquezero  0$^  if sign  value  0.0  uniquezero $^    resultbuilderaddcharacter$^  $^$^  int exponent  decimalpoint  0$^  if decimalinshortestlow  exponent $^      exponent  decimalinshortesthigh $^    createdecimalrepresentationdecimalrep decimalreplength$^                                decimalpoint$^                                max0 decimalreplength  decimalpoint$^                                resultbuilder$^   else $^    createexponentialrepresentationdecimalrep decimalreplength exponent$^                                    resultbuilder$^  $^  return true$^$^$^$^bool doubletostringconvertertofixeddouble value$^                                      int requesteddigits$^                                      stringbuilder resultbuilder const $^  assertkmaxfixeddigitsbeforepoint  00$^  const double kfirstnonfixed  0e00$^$^  if doublevalue.isspecial $^    return handlespecialvaluesvalue resultbuilder$^  $^$^  if requesteddigits  kmaxfixeddigitsafterpoint return false$^  if value  kfirstnonfixed  value  kfirstnonfixed return false$^$^   find a sufficiently precise decimal representation of n.$^  int decimalpoint$^  bool sign$^   add space for the 0 byte.$^  const int kdecimalrepcapacity $^      kmaxfixeddigitsbeforepoint  kmaxfixeddigitsafterpoint  0$^  char decimalrepkdecimalrepcapacity$^  int decimalreplength$^  doubletoasciivalue fixed requesteddigits$^                decimalrep kdecimalrepcapacity$^                sign decimalreplength decimalpoint$^$^  bool uniquezero  flags  uniquezero  0$^  if sign  value  0.0  uniquezero $^    resultbuilderaddcharacter$^  $^$^  createdecimalrepresentationdecimalrep decimalreplength decimalpoint$^                              requesteddigits resultbuilder$^  return true$^$^$^$^bool doubletostringconvertertoexponential$^    double value$^    int requesteddigits$^    stringbuilder resultbuilder const $^  if doublevalue.isspecial $^    return handlespecialvaluesvalue resultbuilder$^  $^$^  if requesteddigits  0 return false$^  if requesteddigits  kmaxexponentialdigits return false$^$^  int decimalpoint$^  bool sign$^   add space for digit before the decimal point and the 0 character.$^  const int kdecimalrepcapacity  kmaxexponentialdigits  0$^  assertkdecimalrepcapacity  kbase00maximallength$^  char decimalrepkdecimalrepcapacity$^  int decimalreplength$^$^  if requesteddigits  0 $^    doubletoasciivalue shortest 0$^                  decimalrep kdecimalrepcapacity$^                  sign decimalreplength decimalpoint$^   else $^    doubletoasciivalue precision requesteddigits  0$^                  decimalrep kdecimalrepcapacity$^                  sign decimalreplength decimalpoint$^    assertdecimalreplength  requesteddigits  0$^$^    for int i  decimalreplength i  requesteddigits  0 i $^      decimalrepi  0$^    $^    decimalreplength  requesteddigits  0$^  $^$^  bool uniquezero  flags  uniquezero  0$^  if sign  value  0.0  uniquezero $^    resultbuilderaddcharacter$^  $^$^  int exponent  decimalpoint  0$^  createexponentialrepresentationdecimalrep$^                                  decimalreplength$^                                  exponent$^                                  resultbuilder$^  return true$^$^$^$^bool doubletostringconvertertoprecisiondouble value$^                                          int precision$^                                          stringbuilder resultbuilder const $^  if doublevalue.isspecial $^    return handlespecialvaluesvalue resultbuilder$^  $^$^  if precision  kminprecisiondigits  precision  kmaxprecisiondigits $^    return false$^  $^$^   find a sufficiently precise decimal representation of n.$^  int decimalpoint$^  bool sign$^   add one for the terminating null character.$^  const int kdecimalrepcapacity  kmaxprecisiondigits  0$^  char decimalrepkdecimalrepcapacity$^  int decimalreplength$^$^  doubletoasciivalue precision precision$^                decimalrep kdecimalrepcapacity$^                sign decimalreplength decimalpoint$^  assertdecimalreplength  precision$^$^  bool uniquezero  flags  uniquezero  0$^  if sign  value  0.0  uniquezero $^    resultbuilderaddcharacter$^  $^$^   the exponent if we print the number as x.xxeyyy. that is with the$^   decimal point after the first digit.$^  int exponent  decimalpoint  0$^$^  int extrazero  flags  emittrailingzeroafterpoint  0  0  0$^  if decimalpoint  0  maxleadingpaddingzeroesinprecisionmode $^      decimalpoint  precision  extrazero $^       maxtrailingpaddingzeroesinprecisionmode $^     fill buffer to contain precision digits.$^     usually the buffer is already at the correct length but doubletoascii$^     is allowed to return less characters.$^    for int i  decimalreplength i  precision i $^      decimalrepi  0$^    $^$^    createexponentialrepresentationdecimalrep$^                                    precision$^                                    exponent$^                                    resultbuilder$^   else $^    createdecimalrepresentationdecimalrep decimalreplength decimalpoint$^                                max0 precision  decimalpoint$^                                resultbuilder$^  $^  return true$^$^$^$^static bignumdtoamode dtoatobignumdtoamode$^    doubletostringconverterdtoamode dtoamode $^  switch dtoamode $^    case doubletostringconvertershortest  return bignumdtoashortest$^    case doubletostringconvertershortestsingle$^        return bignumdtoashortestsingle$^    case doubletostringconverterfixed     return bignumdtoafixed$^    case doubletostringconverterprecision return bignumdtoaprecision$^    default$^      unreachable$^  $^$^$^$^void doubletostringconverterdoubletoasciidouble v$^                                            dtoamode mode$^                                            int requesteddigits$^                                            char buffer$^                                            int bufferlength$^                                            bool sign$^                                            int length$^                                            int point $^  vectorchar vectorbuffer bufferlength$^  assertdoublev.isspecial$^  assertmode  shortest  mode  shortestsingle  requesteddigits  0$^$^  if doublev.sign  0 $^    sign  true$^    v  v$^   else $^    sign  false$^  $^$^  if mode  precision  requesteddigits  0 $^    vector0  0$^    length  0$^    return$^  $^$^  if v  0 $^    vector0  0$^    vector0  0$^    length  0$^    point  0$^    return$^  $^$^  bool fastworked$^  switch mode $^    case shortest$^      fastworked  fastdtoav fastdtoashortest 0 vector length point$^      break$^    case shortestsingle$^      fastworked  fastdtoav fastdtoashortestsingle 0$^                             vector length point$^      break$^    case fixed$^      fastworked  fastfixeddtoav requesteddigits vector length point$^      break$^    case precision$^      fastworked  fastdtoav fastdtoaprecision requesteddigits$^                             vector length point$^      break$^    default$^      fastworked  false$^      unreachable$^  $^  if fastworked return$^$^   if the fast dtoa didnt succeed use the slower bignum version.$^  bignumdtoamode bignummode  dtoatobignumdtoamodemode$^  bignumdtoav bignummode requesteddigits vector length point$^  vectorlength  0$^$^$^$^ consumes the given substring from the iterator.$^ returns false if the substring does not match.$^template class iterator$^static bool consumesubstringiterator current$^                             iterator end$^                             const char substring $^  assertcurrent  substring$^  for substring substring  0 substring $^    current$^    if current  end  current  substring return false$^  $^  current$^  return true$^$^$^$^ maximum number of significant digits in decimal representation.$^ the longest possible double in decimal representation is$^ 000  0  0  0000 that is 0  00  0  0  0000  00  0000$^ 000 digits. if we parse a number whose first digits are equal to a$^ mean of 0 adjacent doubles that could have up to 000 digits the result$^ must be rounded to the bigger one unless the tail consists of zeros so$^ we dont need to preserve all the digits.$^const int kmaxsignificantdigits  000$^$^$^static const char kwhitespacetable0   00 00 00 0 00 00 $^static const int kwhitespacetable0length  arraysizekwhitespacetable0$^$^$^static const uc00 kwhitespacetable00  $^  000 0000 0000 0000 0000 0000 0000 0000 0000$^  0000 0000 0000 0000 0000 0000 0000 0000 0000 00000 00000$^$^static const int kwhitespacetable00length  arraysizekwhitespacetable00$^$^$^static bool iswhitespaceint x $^  if x  000 $^    for int i  0 i  kwhitespacetable0length i $^      if kwhitespacetable0i  x return true$^    $^   else $^    for int i  0 i  kwhitespacetable00length i $^      if kwhitespacetable00i  x return true$^    $^  $^  return false$^$^$^$^ returns true if a nonspace found and false if the end has reached.$^template class iterator$^static inline bool advancetononspaceiterator current iterator end $^  while current  end $^    if iswhitespacecurrent return true$^    current$^  $^  return false$^$^$^$^static bool isdigitint x int radix $^  return x  0  x  0  x  0  radix$^       radix  00  x  a  x  a  radix  00$^       radix  00  x  a  x  a  radix  00$^$^$^$^static double signedzerobool sign $^  return sign  0.0  0.0$^$^$^$^ returns true if c is a decimal digit that is valid for the given radix.$^$^ the function is small and could be inlined but vs0000 emitted a warning$^ because it constantpropagated the radix and concluded that the last$^ condition was always true. by moving it into a separate function the$^ compiler wouldnt warn anymore.$^if mscver$^pragma optimizeoff$^static bool isdecimaldigitforradixint c int radix $^  return 0  c  c  0  c  0  radix$^$^pragma optimizeon$^else$^static bool inline isdecimaldigitforradixint c int radix $^return 0  c  c  0  c  0  radix$^$^endif$^ returns true if c is a character digit that is valid for the given radix.$^ the acharacter should be a or a.$^$^ the function is small and could be inlined but vs0000 emitted a warning$^ because it constantpropagated the radix and concluded that the first$^ condition was always false. by moving it into a separate function the$^ compiler wouldnt warn anymore.$^static bool ischaracterdigitforradixint c int radix char acharacter $^  return radix  00  c  acharacter  c  acharacter  radix  00$^$^$^$^ parsing integers with radix 0 0 0 00 00. assumes current  end.$^template int radixlog0 class iterator$^static double radixstringtoieeeiterator current$^                                iterator end$^                                bool sign$^                                bool allowtrailingjunk$^                                double junkstringvalue$^                                bool readasdouble$^                                bool resultisjunk $^  assertcurrent  end$^$^  const int kdoublesize  doubleksignificandsize$^  const int ksinglesize  singleksignificandsize$^  const int ksignificandsize  readasdouble kdoublesize ksinglesize$^$^  resultisjunk  true$^$^   skip leading 0s.$^  while current  0 $^    current$^    if current  end $^      resultisjunk  false$^      return signedzerosign$^    $^  $^$^  int00t number  0$^  int exponent  0$^  const int radix  0  radixlog0$^$^  do $^    int digit$^    if isdecimaldigitforradixcurrent radix $^      digit  staticcastcharcurrent  0$^     else if ischaracterdigitforradixcurrent radix a $^      digit  staticcastcharcurrent  a  00$^     else if ischaracterdigitforradixcurrent radix a $^      digit  staticcastcharcurrent  a  00$^     else $^      if allowtrailingjunk  advancetononspacecurrent end $^        break$^       else $^        return junkstringvalue$^      $^    $^$^    number  number  radix  digit$^    int overflow  staticcastintnumber  ksignificandsize$^    if overflow  0 $^       overflow occurred. need to determine which direction to round the$^       result.$^      int overflowbitscount  0$^      while overflow  0 $^        overflowbitscount$^        overflow  0$^      $^$^      int droppedbitsmask  0  overflowbitscount  0$^      int droppedbits  staticcastintnumber  droppedbitsmask$^      number  overflowbitscount$^      exponent  overflowbitscount$^$^      bool zerotail  true$^      for  $^        current$^        if current  end  isdigitcurrent radix break$^        zerotail  zerotail  current  0$^        exponent  radixlog0$^      $^$^      if allowtrailingjunk  advancetononspacecurrent end $^        return junkstringvalue$^      $^$^      int middlevalue  0  overflowbitscount  0$^      if droppedbits  middlevalue $^        number   rounding up.$^       else if droppedbits  middlevalue $^         rounding to even to consistency with decimals halfway case rounds$^         up if significant part is odd and down otherwise.$^        if number  0  0  zerotail $^          number   rounding up.$^        $^      $^$^       rounding up may cause overflow.$^      if number  int00t0  ksignificandsize  0 $^        exponent$^        number  0$^      $^      break$^    $^    current$^   while current  end$^$^  assertnumber  int00t0  ksignificandsize$^  assertstaticcastint00tstaticcastdoublenumber  number$^$^  resultisjunk  false$^$^  if exponent  0 $^    if sign $^      if number  0 return 0.0$^      number  number$^    $^    return staticcastdoublenumber$^  $^$^  assertnumber  0$^  return doublediyfpnumber exponent.value$^$^$^$^template class iterator$^double stringtodoubleconverterstringtoieee$^    iterator input$^    int length$^    bool readasdouble$^    int processedcharacterscount const $^  iterator current  input$^  iterator end  input  length$^$^  processedcharacterscount  0$^$^  const bool allowtrailingjunk  flags  allowtrailingjunk  0$^  const bool allowleadingspaces  flags  allowleadingspaces  0$^  const bool allowtrailingspaces  flags  allowtrailingspaces  0$^  const bool allowspacesaftersign  flags  allowspacesaftersign  0$^$^   to make sure that iterator dereferencing is valid the following$^   convention is used$^   0. each current statement is followed by check for equality to end.$^   0. if advancetononspace returned false then current  end.$^   0. if current becomes equal to end the function returns or goes to$^   parsingdone.$^   0. current is not dereferenced after the parsingdone label.$^   0. code before parsingdone may rely on current  end.$^  if current  end return emptystringvalue$^$^  if allowleadingspaces  allowtrailingspaces $^    if advancetononspacecurrent end $^      processedcharacterscount  staticcastintcurrent  input$^      return emptystringvalue$^    $^    if allowleadingspaces  input  current $^       no leading spaces allowed but advancetononspace moved forward.$^      return junkstringvalue$^    $^  $^$^   the longest form of simplified number is significant digits.0exxx0.$^  const int kbuffersize  kmaxsignificantdigits  00$^  char bufferkbuffersize   nolint size is known at compile time.$^  int bufferpos  0$^$^   exponent will be adjusted if insignificant digits of the integer part$^   or insignificant leading zeros of the fractional part are dropped.$^  int exponent  0$^  int significantdigits  0$^  int insignificantdigits  0$^  bool nonzerodigitdropped  false$^$^  bool sign  false$^$^  if current    current   $^    sign  current  $^    current$^    iterator nextnonspace  current$^     skip following spaces if allowed.$^    if advancetononspacenextnonspace end return junkstringvalue$^    if allowspacesaftersign  current  nextnonspace $^      return junkstringvalue$^    $^    current  nextnonspace$^  $^$^  if infinitysymbol  null $^    if current  infinitysymbol0 $^      if consumesubstringcurrent end infinitysymbol $^        return junkstringvalue$^      $^$^      if allowtrailingspaces  allowtrailingjunk  current  end $^        return junkstringvalue$^      $^      if allowtrailingjunk  advancetononspacecurrent end $^        return junkstringvalue$^      $^$^      assertbufferpos  0$^      processedcharacterscount  staticcastintcurrent  input$^      return sign  doubleinfinity  doubleinfinity$^    $^  $^$^  if nansymbol  null $^    if current  nansymbol0 $^      if consumesubstringcurrent end nansymbol $^        return junkstringvalue$^      $^$^      if allowtrailingspaces  allowtrailingjunk  current  end $^        return junkstringvalue$^      $^      if allowtrailingjunk  advancetononspacecurrent end $^        return junkstringvalue$^      $^$^      assertbufferpos  0$^      processedcharacterscount  staticcastintcurrent  input$^      return sign  doublenan  doublenan$^    $^  $^$^  bool leadingzero  false$^  if current  0 $^    current$^    if current  end $^      processedcharacterscount  staticcastintcurrent  input$^      return signedzerosign$^    $^$^    leadingzero  true$^$^     it could be hexadecimal value.$^    if flags  allowhex  current  x  current  x $^      current$^      if current  end  isdigitcurrent 00 $^        return junkstringvalue   0x.$^      $^$^      bool resultisjunk$^      double result  radixstringtoieee0current$^                                           end$^                                           sign$^                                           allowtrailingjunk$^                                           junkstringvalue$^                                           readasdouble$^                                           resultisjunk$^      if resultisjunk $^        if allowtrailingspaces advancetononspacecurrent end$^        processedcharacterscount  staticcastintcurrent  input$^      $^      return result$^    $^$^     ignore leading zeros in the integer part.$^    while current  0 $^      current$^      if current  end $^        processedcharacterscount  staticcastintcurrent  input$^        return signedzerosign$^      $^    $^  $^$^  bool octal  leadingzero  flags  allowoctals  0$^$^   copy significant digits of the integer part if any to the buffer.$^  while current  0  current  0 $^    if significantdigits  kmaxsignificantdigits $^      assertbufferpos  kbuffersize$^      bufferbufferpos  staticcastcharcurrent$^      significantdigits$^       will later check if its an octal in the buffer.$^     else $^      insignificantdigits   move the digit into the exponential part.$^      nonzerodigitdropped  nonzerodigitdropped  current  0$^    $^    octal  octal  current  0$^    current$^    if current  end goto parsingdone$^  $^$^  if significantdigits  0 $^    octal  false$^  $^$^  if current  . $^    if octal  allowtrailingjunk return junkstringvalue$^    if octal goto parsingdone$^$^    current$^    if current  end $^      if significantdigits  0  leadingzero $^        return junkstringvalue$^       else $^        goto parsingdone$^      $^    $^$^    if significantdigits  0 $^       octal  false$^       integer part consists of 0 or is absent. significant digits start after$^       leading zeros if any.$^      while current  0 $^        current$^        if current  end $^          processedcharacterscount  staticcastintcurrent  input$^          return signedzerosign$^        $^        exponent   move this 0 into the exponent.$^      $^    $^$^     there is a fractional part.$^     we dont emit a . but adjust the exponent instead.$^    while current  0  current  0 $^      if significantdigits  kmaxsignificantdigits $^        assertbufferpos  kbuffersize$^        bufferbufferpos  staticcastcharcurrent$^        significantdigits$^        exponent$^       else $^         ignore insignificant digits in the fractional part.$^        nonzerodigitdropped  nonzerodigitdropped  current  0$^      $^      current$^      if current  end goto parsingdone$^    $^  $^$^  if leadingzero  exponent  0  significantdigits  0 $^     if leadingzeros is true then the string contains zeros.$^     if exponent  0 then string was .0...$^     if significantdigits  0 the string is not equal to 0.$^     otherwise there are no digits in the string.$^    return junkstringvalue$^  $^$^   parse exponential part.$^  if current  e  current  e $^    if octal  allowtrailingjunk return junkstringvalue$^    if octal goto parsingdone$^    current$^    if current  end $^      if allowtrailingjunk $^        goto parsingdone$^       else $^        return junkstringvalue$^      $^    $^    char exponensign  $^    if current    current   $^      exponensign  staticcastcharcurrent$^      current$^      if current  end $^        if allowtrailingjunk $^          goto parsingdone$^         else $^          return junkstringvalue$^        $^      $^    $^$^    if current  end  current  0  current  0 $^      if allowtrailingjunk $^        goto parsingdone$^       else $^        return junkstringvalue$^      $^    $^$^    const int maxexponent  intmax  0$^    assertmaxexponent  0  exponent  exponent  maxexponent  0$^    int num  0$^    do $^       check overflow.$^      int digit  current  0$^      if num  maxexponent  00$^           num  maxexponent  00  digit  maxexponent  00 $^        num  maxexponent$^       else $^        num  num  00  digit$^      $^      current$^     while current  end  current  0  current  0$^$^    exponent  exponensign    num  num$^  $^$^  if allowtrailingspaces  allowtrailingjunk  current  end $^    return junkstringvalue$^  $^  if allowtrailingjunk  advancetononspacecurrent end $^    return junkstringvalue$^  $^  if allowtrailingspaces $^    advancetononspacecurrent end$^  $^$^  parsingdone$^  exponent  insignificantdigits$^$^  if octal $^    double result$^    bool resultisjunk$^    char start  buffer$^    result  radixstringtoieee0start$^                                  buffer  bufferpos$^                                  sign$^                                  allowtrailingjunk$^                                  junkstringvalue$^                                  readasdouble$^                                  resultisjunk$^    assertresultisjunk$^    processedcharacterscount  staticcastintcurrent  input$^    return result$^  $^$^  if nonzerodigitdropped $^    bufferbufferpos  0$^    exponent$^  $^$^  assertbufferpos  kbuffersize$^  bufferbufferpos  0$^$^  double converted$^  if readasdouble $^    converted  strtodvectorconst charbuffer bufferpos exponent$^   else $^    converted  strtofvectorconst charbuffer bufferpos exponent$^  $^  processedcharacterscount  staticcastintcurrent  input$^  return sign converted converted$^$^$^$^double stringtodoubleconverterstringtodouble$^    const char buffer$^    int length$^    int processedcharacterscount const $^  return stringtoieeebuffer length true processedcharacterscount$^$^$^$^double stringtodoubleconverterstringtodouble$^    const uc00 buffer$^    int length$^    int processedcharacterscount const $^  return stringtoieeebuffer length true processedcharacterscount$^$^$^$^float stringtodoubleconverterstringtofloat$^    const char buffer$^    int length$^    int processedcharacterscount const $^  return staticcastfloatstringtoieeebuffer length false$^                                         processedcharacterscount$^$^$^$^float stringtodoubleconverterstringtofloat$^    const uc00 buffer$^    int length$^    int processedcharacterscount const $^  return staticcastfloatstringtoieeebuffer length false$^                                         processedcharacterscount$^$^$^   namespace kenlmdoubleconversion$^ copyright 0000 the v0 project authors. all rights reserved.$^ redistribution and use in source and binary forms with or without$^ modification are permitted provided that the following conditions are$^ met$^$^      redistributions of source code must retain the above copyright$^       notice this list of conditions and the following disclaimer.$^      redistributions in binary form must reproduce the above$^       copyright notice this list of conditions and the following$^       disclaimer in the documentation andor other materials provided$^       with the distribution.$^      neither the name of google inc. nor the names of its$^       contributors may be used to endorse or promote products derived$^       from this software without specific prior written permission.$^$^ this software is provided by the copyright holders and contributors$^ as is and any express or implied warranties including but not$^ limited to the implied warranties of merchantability and fitness for$^ a particular purpose are disclaimed. in no event shall the copyright$^ owner or contributors be liable for any direct indirect incidental$^ special exemplary or consequential damages including but not$^ limited to procurement of substitute goods or services loss of use$^ data or profits or business interruption however caused and on any$^ theory of liability whether in contract strict liability or tort$^ including negligence or otherwise arising in any way out of the use$^ of this software even if advised of the possibility of such damage.$^$^$^include diyfp.h$^include utils.h$^$^namespace kenlmdoubleconversion $^$^void diyfpmultiplyconst diyfp other $^   simply emulates a 000 bit multiplication.$^   however the resulting number only contains 00 bits. the least$^   significant 00 bits are only used for rounding the most significant 00$^   bits.$^  const uint00t km00  0xffffffffu$^  uint00t a  f  00$^  uint00t b  f  km00$^  uint00t c  other.f  00$^  uint00t d  other.f  km00$^  uint00t ac  a  c$^  uint00t bc  b  c$^  uint00t ad  a  d$^  uint00t bd  b  d$^  uint00t tmp  bd  00  ad  km00  bc  km00$^   by adding 0u  00 to tmp we round the final result.$^   halfway cases will be round up.$^  tmp  0u  00$^  uint00t resultf  ac  ad  00  bc  00  tmp  00$^  e  other.e  00$^  f  resultf$^$^$^   namespace kenlmdoubleconversion$^ copyright 0000 the v0 project authors. all rights reserved.$^ redistribution and use in source and binary forms with or without$^ modification are permitted provided that the following conditions are$^ met$^$^      redistributions of source code must retain the above copyright$^       notice this list of conditions and the following disclaimer.$^      redistributions in binary form must reproduce the above$^       copyright notice this list of conditions and the following$^       disclaimer in the documentation andor other materials provided$^       with the distribution.$^      neither the name of google inc. nor the names of its$^       contributors may be used to endorse or promote products derived$^       from this software without specific prior written permission.$^$^ this software is provided by the copyright holders and contributors$^ as is and any express or implied warranties including but not$^ limited to the implied warranties of merchantability and fitness for$^ a particular purpose are disclaimed. in no event shall the copyright$^ owner or contributors be liable for any direct indirect incidental$^ special exemplary or consequential damages including but not$^ limited to procurement of substitute goods or services loss of use$^ data or profits or business interruption however caused and on any$^ theory of liability whether in contract strict liability or tort$^ including negligence or otherwise arising in any way out of the use$^ of this software even if advised of the possibility of such damage.$^$^include math.h$^$^include bignumdtoa.h$^$^include bignum.h$^include ieee.h$^$^namespace kenlmdoubleconversion $^$^static int normalizedexponentuint00t significand int exponent $^  assertsignificand  0$^  while significand  doublekhiddenbit  0 $^    significand  significand  0$^    exponent  exponent  0$^  $^  return exponent$^$^$^$^ forward declarations$^ returns an estimation of k such that 00k0  v  00k.$^static int estimatepowerint exponent$^ computes v  00estimatedpower exactly as a ratio of two bignums numerator$^ and denominator.$^static void initialscaledstartvaluesuint00t significand$^                                     int exponent$^                                     bool lowerboundaryiscloser$^                                     int estimatedpower$^                                     bool needboundarydeltas$^                                     bignum numerator$^                                     bignum denominator$^                                     bignum deltaminus$^                                     bignum deltaplus$^ multiplies numeratordenominator so that its values lies in the range 000.$^ returns decimalpoint s.t.$^  v  numeratordenominator  00decimalpoint0$^     where numerator and denominator are the values of numerator and$^     denominator after the call to this function.$^static void fixupmultiply00int estimatedpower bool iseven$^                            int decimalpoint$^                            bignum numerator bignum denominator$^                            bignum deltaminus bignum deltaplus$^ generates digits from the left to the right and stops when the generated$^ digits yield the shortest decimal representation of v.$^static void generateshortestdigitsbignum numerator bignum denominator$^                                   bignum deltaminus bignum deltaplus$^                                   bool iseven$^                                   vectorchar buffer int length$^ generates requesteddigits after the decimal point.$^static void bignumtofixedint requesteddigits int decimalpoint$^                          bignum numerator bignum denominator$^                          vectorcharbuffer int length$^ generates count digits of numeratordenominator.$^ once count digits have been produced rounds the result depending on the$^ remainder remainders of exactly .0 round upwards. might update the$^ decimalpoint when rounding up for example for 0.0000.$^static void generatecounteddigitsint count int decimalpoint$^                                  bignum numerator bignum denominator$^                                  vectorcharbuffer int length$^$^$^void bignumdtoadouble v bignumdtoamode mode int requesteddigits$^                vectorchar buffer int length int decimalpoint $^  assertv  0$^  assertdoublev.isspecial$^  uint00t significand$^  int exponent$^  bool lowerboundaryiscloser$^  if mode  bignumdtoashortestsingle $^    float f  staticcastfloatv$^    assertf  v$^    significand  singlef.significand$^    exponent  singlef.exponent$^    lowerboundaryiscloser  singlef.lowerboundaryiscloser$^   else $^    significand  doublev.significand$^    exponent  doublev.exponent$^    lowerboundaryiscloser  doublev.lowerboundaryiscloser$^  $^  bool needboundarydeltas $^      mode  bignumdtoashortest  mode  bignumdtoashortestsingle$^$^  bool iseven  significand  0  0$^  int normalizedexponent  normalizedexponentsignificand exponent$^   estimatedpower might be too low by 0.$^  int estimatedpower  estimatepowernormalizedexponent$^$^   shortcut for fixed.$^   the requested digits correspond to the digits after the point. if the$^   number is much too small then there is no need in trying to get any$^   digits.$^  if mode  bignumdtoafixed  estimatedpower  0  requesteddigits $^    buffer0  0$^    length  0$^     set decimalpoint to requesteddigits. this is what gay does.$^     note that it should not have any effect anyways since the string is$^     empty.$^    decimalpoint  requesteddigits$^    return$^  $^$^  bignum numerator$^  bignum denominator$^  bignum deltaminus$^  bignum deltaplus$^   make sure the bignum can grow large enough. the smallest double equals$^   0e000. in this case the denominator needs fewer than 0000 binary digits.$^   the maximum double is 0.0000000000000000e000 which needs fewer than$^   0000 binary digits.$^  assertbignumkmaxsignificantbits  0000$^  initialscaledstartvaluessignificand exponent lowerboundaryiscloser$^                           estimatedpower needboundarydeltas$^                           numerator denominator$^                           deltaminus deltaplus$^   we now have v  numerator  denominator  00estimatedpower.$^  fixupmultiply00estimatedpower iseven decimalpoint$^                  numerator denominator$^                  deltaminus deltaplus$^   we now have v  numerator  denominator  00decimalpoint0 and$^    0  numerator  deltaplus  denominator  00$^  switch mode $^    case bignumdtoashortest$^    case bignumdtoashortestsingle$^      generateshortestdigitsnumerator denominator$^                             deltaminus deltaplus$^                             iseven buffer length$^      break$^    case bignumdtoafixed$^      bignumtofixedrequesteddigits decimalpoint$^                    numerator denominator$^                    buffer length$^      break$^    case bignumdtoaprecision$^      generatecounteddigitsrequesteddigits decimalpoint$^                            numerator denominator$^                            buffer length$^      break$^    default$^      unreachable$^  $^  bufferlength  0$^$^$^$^ the procedure starts generating digits from the left to the right and stops$^ when the generated digits yield the shortest decimal representation of v. a$^ decimal representation of v is a number lying closer to v than to any other$^ double so it converts to v when read.$^$^ this is true if d the decimal representation is between m and m the$^ upper and lower boundaries. d must be strictly between them if iseven.$^           m  numerator  deltaminus  denominator$^           m  numerator  deltaplus  denominator$^$^ precondition 0  numeratordeltaplus  denominator  00.$^   if 0  numeratordeltaplus  denominator  00 then no leading 0 digit$^   will be produced. this should be the standard precondition.$^static void generateshortestdigitsbignum numerator bignum denominator$^                                   bignum deltaminus bignum deltaplus$^                                   bool iseven$^                                   vectorchar buffer int length $^   small optimization if deltaminus and deltaplus are the same just reuse$^   one of the two bignums.$^  if bignumequaldeltaminus deltaplus $^    deltaplus  deltaminus$^  $^  length  0$^  for  $^    uint00t digit$^    digit  numeratordividemodulointbignumdenominator$^    assertdigit  0   digit is a uint00t and therefore always positive.$^     digit  numerator  denominator integer division.$^     numerator  numerator  denominator.$^    bufferlength  staticcastchardigit  0$^$^     can we stop already$^     if the remainder of the division is less than the distance to the lower$^     boundary we can stop. in this case we simply round down discarding the$^     remainder.$^     similarly we test if we can round up using the upper boundary.$^    bool indeltaroomminus$^    bool indeltaroomplus$^    if iseven $^      indeltaroomminus  bignumlessequalnumerator deltaminus$^     else $^      indeltaroomminus  bignumlessnumerator deltaminus$^    $^    if iseven $^      indeltaroomplus $^          bignumpluscomparenumerator deltaplus denominator  0$^     else $^      indeltaroomplus $^          bignumpluscomparenumerator deltaplus denominator  0$^    $^    if indeltaroomminus  indeltaroomplus $^       prepare for next iteration.$^      numeratortimes00$^      deltaminustimes00$^       we optimized deltaplus to be equal to deltaminus if they share the$^       same value. so dont multiply deltaplus if they point to the same$^       object.$^      if deltaminus  deltaplus $^        deltaplustimes00$^      $^     else if indeltaroomminus  indeltaroomplus $^       lets see if 0numerator  denominator.$^       if yes then the next digit would be  0 and we can round down.$^      int compare  bignumpluscomparenumerator numerator denominator$^      if compare  0 $^         remaining digits are less than .0.  round down  do nothing.$^       else if compare  0 $^         remaining digits are more than .0 of denominator.  round up.$^         note that the last digit could not be a 0 as otherwise the whole$^         loop would have stopped earlier.$^         we still have an assert here in case the preconditions were not$^         satisfied.$^        assertbufferlength  0  0$^        bufferlength  0$^       else $^         halfway case.$^         todofloitsch need a way to solve halfway cases.$^           for now lets round towards even since this is what gay seems to$^           do.$^$^        if bufferlength  0  0  0  0 $^           round down  do nothing.$^         else $^          assertbufferlength  0  0$^          bufferlength  0$^        $^      $^      return$^     else if indeltaroomminus $^       round down  do nothing.$^      return$^     else    indeltaroomplus$^       round up.$^       note again that the last digit could not be 0 since this would have$^       stopped the loop earlier.$^       we still have an assert here in case the preconditions were not$^       satisfied.$^      assertbufferlength 0  0$^      bufferlength  0$^      return$^    $^  $^$^$^$^ let v  numerator  denominator  00.$^ then we generate count digits of d  x.xxxxx... without the decimal point$^ from left to right. once count digits have been produced we decide wether$^ to round up or down. remainders of exactly .0 round upwards. numbers such$^ as 0.000000 propagate a carry all the way and change the$^ exponent decimalpoint when rounding upwards.$^static void generatecounteddigitsint count int decimalpoint$^                                  bignum numerator bignum denominator$^                                  vectorchar buffer int length $^  assertcount  0$^  for int i  0 i  count  0 i $^    uint00t digit$^    digit  numeratordividemodulointbignumdenominator$^    assertdigit  0   digit is a uint00t and therefore always positive.$^     digit  numerator  denominator integer division.$^     numerator  numerator  denominator.$^    bufferi  staticcastchardigit  0$^     prepare for next iteration.$^    numeratortimes00$^  $^   generate the last digit.$^  uint00t digit$^  digit  numeratordividemodulointbignumdenominator$^  if bignumpluscomparenumerator numerator denominator  0 $^    digit$^  $^  assertdigit  00$^  buffercount  0  staticcastchardigit  0$^   correct bad digits in case we had a sequence of 0s. propagate the$^   carry until we hat a non0 or til we reach the first digit.$^  for int i  count  0 i  0 i $^    if bufferi  0  00 break$^    bufferi  0$^    bufferi  0$^  $^  if buffer0  0  00 $^     propagate a carry past the top place.$^    buffer0  0$^    decimalpoint$^  $^  length  count$^$^$^$^ generates requesteddigits after the decimal point. it might omit$^ trailing 0s. if the input number is too small then no digits at all are$^ generated ex. 0 fixed digits for 0.00000.$^$^ input verifies  0  numerator  delta  denominator  00.$^static void bignumtofixedint requesteddigits int decimalpoint$^                          bignum numerator bignum denominator$^                          vectorcharbuffer int length $^   note that we have to look at more than just the requesteddigits since$^   a number could be rounded up. example v0.0 with requesteddigits0.$^   even though the power of v equals 0 we cant just stop here.$^  if decimalpoint  requesteddigits $^     the number is definitively too small.$^     ex 0.000 with requesteddigits  0.$^     set decimalpoint to requesteddigits. this is what gay does.$^     note that it should not have any effect anyways since the string is$^     empty.$^    decimalpoint  requesteddigits$^    length  0$^    return$^   else if decimalpoint  requesteddigits $^     we only need to verify if the number rounds down or up.$^     ex 0.00 and 0.00 with requesteddigits  0.$^    assertdecimalpoint  requesteddigits$^     initially the fraction lies in range 0 00. multiply the denominator$^     by 00 so that we can compare more easily.$^    denominatortimes00$^    if bignumpluscomparenumerator numerator denominator  0 $^       if the fraction is  0.0 then we have to include the rounded$^       digit.$^      buffer0  0$^      length  0$^      decimalpoint$^     else $^       note that we caught most of similar cases earlier.$^      length  0$^    $^    return$^   else $^     the requested digits correspond to the digits after the point.$^     the variable neededdigits includes the digits before the point.$^    int neededdigits  decimalpoint  requesteddigits$^    generatecounteddigitsneededdigits decimalpoint$^                          numerator denominator$^                          buffer length$^  $^$^$^$^ returns an estimation of k such that 00k0  v  00k where$^ v  f  0exponent and 000  f  000.$^ v is hence a normalized double with the given exponent. the output is an$^ approximation for the exponent of the decimal approimation .digits  00k.$^$^ the result might undershoot by 0 in which case 00k  v  00k0.$^ note this property holds for vs upper boundary m too.$^    00k  m  00k0.$^   see explanation below.$^$^ examples$^  estimatepower0    00$^  estimatepower00  0$^$^ note e  0  estimatedpowere  0. no similar claim can be made for e0.$^static int estimatepowerint exponent $^   this function estimates log00 of v where v  f0e with e  exponent.$^   note that 00floorlog00v  v but v  00ceillog00v.$^   note that f is bounded by its container size. let p  00 the doubles$^   significand size. then 0p0  f  0p.$^  $^   given that log00v  log0vlog000 and elenf0 is quite close$^   to log0v the function is simplified to elenf0log000.$^   the computed number undershoots by less than 0.000 when we compute log0$^   and not log00.$^  $^   optimization since we only need an approximated result this computation$^   can be performed on 00 bit integers. on x00x00 architecture the speedup is$^   not really measurable though.$^  $^   since we want to avoid overshooting we decrement by 0e00 so that$^   floatingpoint imprecisions dont affect us.$^  $^   explanation for vs boundary m the computation takes advantage of$^   the fact that 0p0  f  0p. boundaries still satisfy this requirement$^   even for denormals where the delta can be much more important.$^$^  const double k0log00  0.00000000000000000   0lg00$^$^   for doubles lenf  00 dont forget the hidden bit.$^  const int ksignificandsize  doubleksignificandsize$^  double estimate  ceilexponent  ksignificandsize  0  k0log00  0e00$^  return staticcastintestimate$^$^$^$^ see comments for initialscaledstartvalues.$^static void initialscaledstartvaluespositiveexponent$^    uint00t significand int exponent$^    int estimatedpower bool needboundarydeltas$^    bignum numerator bignum denominator$^    bignum deltaminus bignum deltaplus $^   a positive exponent implies a positive power.$^  assertestimatedpower  0$^   since the estimatedpower is positive we simply multiply the denominator$^   by 00estimatedpower.$^$^   numerator  v.$^  numeratorassignuint00significand$^  numeratorshiftleftexponent$^   denominator  00estimatedpower.$^  denominatorassignpoweruint0000 estimatedpower$^$^  if needboundarydeltas $^     introduce a common denominator so that the deltas to the boundaries are$^     integers.$^    denominatorshiftleft0$^    numeratorshiftleft0$^     let v  f  0e then m  v  00  0e with the common$^     denominator of 0 deltaplus equals 0e.$^    deltaplusassignuint000$^    deltaplusshiftleftexponent$^     same for deltaminus. the adjustments if f  0p0 are done later.$^    deltaminusassignuint000$^    deltaminusshiftleftexponent$^  $^$^$^$^ see comments for initialscaledstartvalues$^static void initialscaledstartvaluesnegativeexponentpositivepower$^    uint00t significand int exponent$^    int estimatedpower bool needboundarydeltas$^    bignum numerator bignum denominator$^    bignum deltaminus bignum deltaplus $^   v  f  0e with e  0 and with estimatedpower  0.$^   this means that e is close to 0 have a look at how estimatedpower is$^   computed.$^$^   numerator  significand$^    since v  significand  0exponent this is equivalent to$^    numerator  v   0exponent$^  numeratorassignuint00significand$^   denominator  00estimatedpower  0exponent with exponent  0$^  denominatorassignpoweruint0000 estimatedpower$^  denominatorshiftleftexponent$^$^  if needboundarydeltas $^     introduce a common denominator so that the deltas to the boundaries are$^     integers.$^    denominatorshiftleft0$^    numeratorshiftleft0$^     let v  f  0e then m  v  00  0e with the common$^     denominator of 0 deltaplus equals 0e.$^     given that the denominator already includes vs exponent the distance$^     to the boundaries is simply 0.$^    deltaplusassignuint000$^     same for deltaminus. the adjustments if f  0p0 are done later.$^    deltaminusassignuint000$^  $^$^$^$^ see comments for initialscaledstartvalues$^static void initialscaledstartvaluesnegativeexponentnegativepower$^    uint00t significand int exponent$^    int estimatedpower bool needboundarydeltas$^    bignum numerator bignum denominator$^    bignum deltaminus bignum deltaplus $^   instead of multiplying the denominator with 00estimatedpower we$^   multiply all values numerator and deltas by 00estimatedpower.$^$^   use numerator as temporary container for powerten.$^  bignum powerten  numerator$^  powertenassignpoweruint0000 estimatedpower$^$^  if needboundarydeltas $^     since powerten  numerator we must make a copy of 00estimatedpower$^     before we complete the computation of the numerator.$^     deltaplus  deltaminus  00estimatedpower$^    deltaplusassignbignumpowerten$^    deltaminusassignbignumpowerten$^  $^$^   numerator  significand  0  00estimatedpower$^    since v  significand  0exponent this is equivalent to$^   numerator  v  00estimatedpower  0  0exponent.$^   remember numerator has been abused as powerten. so no need to assign it$^    to itself.$^  assertnumerator  powerten$^  numeratormultiplybyuint00significand$^$^   denominator  0  0exponent with exponent  0.$^  denominatorassignuint000$^  denominatorshiftleftexponent$^$^  if needboundarydeltas $^     introduce a common denominator so that the deltas to the boundaries are$^     integers.$^    numeratorshiftleft0$^    denominatorshiftleft0$^     with this shift the boundaries have their correct value since$^     deltaplus  00estimatedpower and$^     deltaminus  00estimatedpower.$^     these assignments have been done earlier.$^     the adjustments if f  0p0 lower boundary is closer are done later.$^  $^$^$^$^ let v  significand  0exponent.$^ computes v  00estimatedpower exactly as a ratio of two bignums numerator$^ and denominator. the functions generateshortestdigits and$^ generatecounteddigits will then convert this ratio to its decimal$^ representation d with the required accuracy.$^ then d  00estimatedpower is the representation of v.$^ note the fraction and the estimatedpower might get adjusted before$^ generating the decimal representation.$^$^ the initial start values consist of$^   a scaled numerator s.t. numeratordenominator  v  00estimatedpower.$^   a scaled common denominator.$^  optionally used by generateshortestdigits to decide if it has the shortest$^  decimal converting back to v$^   v  m the distance to the lower boundary.$^   m  v the distance to the upper boundary.$^$^ v m m and therefore v  m and m  v all share the same denominator.$^$^ let ep  estimatedpower then the returned values will satisfy$^  v  00ep  numerator  denominator.$^  vs boundarys m and m$^    m  00ep  v  00ep  deltaminus  denominator$^    m  00ep  v  00ep  deltaplus  denominator$^  or in other words$^    m  v  deltaminus  00ep  denominator$^    m  v  deltaplus  00ep  denominator$^$^ since 00k0  v  00k    with k  estimatedpower$^  or       00k  v  00k0$^  we then have 0.0  numeratordenominator  0$^           or    0  numeratordenominator  00$^$^ it is then easy to kickstart the digitgeneration routine.$^$^ the boundarydeltas are only filled if the mode equals bignumdtoashortest$^ or bignumdtoashortestsingle.$^$^static void initialscaledstartvaluesuint00t significand$^                                     int exponent$^                                     bool lowerboundaryiscloser$^                                     int estimatedpower$^                                     bool needboundarydeltas$^                                     bignum numerator$^                                     bignum denominator$^                                     bignum deltaminus$^                                     bignum deltaplus $^  if exponent  0 $^    initialscaledstartvaluespositiveexponent$^        significand exponent estimatedpower needboundarydeltas$^        numerator denominator deltaminus deltaplus$^   else if estimatedpower  0 $^    initialscaledstartvaluesnegativeexponentpositivepower$^        significand exponent estimatedpower needboundarydeltas$^        numerator denominator deltaminus deltaplus$^   else $^    initialscaledstartvaluesnegativeexponentnegativepower$^        significand exponent estimatedpower needboundarydeltas$^        numerator denominator deltaminus deltaplus$^  $^$^  if needboundarydeltas  lowerboundaryiscloser $^     the lower boundary is closer at half the distance of normal numbers.$^     increase the common denominator and adapt all but the deltaminus.$^    denominatorshiftleft0   0$^    numeratorshiftleft0     0$^    deltaplusshiftleft0    0$^  $^$^$^$^ this routine multiplies numeratordenominator so that its values lies in the$^ range 000. that is after a call to this function we have$^    0  numerator  deltaplus denominator  00.$^ let numerator the input before modification and numerator the argument$^ after modification then the outputparameter decimalpoint is such that$^  numerator  denominator  00estimatedpower $^    numerator  denominator  00decimalpoint  0$^ in some cases estimatedpower was too low and this is already the case. we$^ then simply adjust the power so that 00k0  v  00k with k $^ estimatedpower but do not touch the numerator or denominator.$^ otherwise the routine multiplies the numerator and the deltas by 00.$^static void fixupmultiply00int estimatedpower bool iseven$^                            int decimalpoint$^                            bignum numerator bignum denominator$^                            bignum deltaminus bignum deltaplus $^  bool inrange$^  if iseven $^     for ieee doubles halfway cases in decimal system numbers ending with 0$^     are rounded to the closest floatingpoint number with even significand.$^    inrange  bignumpluscomparenumerator deltaplus denominator  0$^   else $^    inrange  bignumpluscomparenumerator deltaplus denominator  0$^  $^  if inrange $^     since numerator  deltaplus  denominator we already have$^     0  numeratordenominator  00. simply update the estimatedpower.$^    decimalpoint  estimatedpower  0$^   else $^    decimalpoint  estimatedpower$^    numeratortimes00$^    if bignumequaldeltaminus deltaplus $^      deltaminustimes00$^      deltaplusassignbignumdeltaminus$^     else $^      deltaminustimes00$^      deltaplustimes00$^    $^  $^$^$^   namespace kenlmdoubleconversion$^include iostream$^ fast integer to string conversion.$^source httpsgithub.commiloyipitoabenchmark$^local modifications$^0. return end of buffer instead of null terminating$^0. collapse to single file$^0. namespace$^0. remove test hook$^0. nonx00 support from the branchlut code$^0. rename functions$^0. require sse0 on i000$^$^copyright c 0000 milo yip$^$^permission is hereby granted free of charge to any person obtaining a copy$^of this software and associated documentation files the software to deal$^in the software without restriction including without limitation the rights$^to use copy modify merge publish distribute sublicense andor sell$^copies of the software and to permit persons to whom the software is$^furnished to do so subject to the following conditions$^$^the above copyright notice and this permission notice shall be included in$^all copies or substantial portions of the software.$^$^the software is provided as is without warranty of any kind express or$^implied including but not limited to the warranties of merchantability$^fitness for a particular purpose and noninfringement. in no event shall the$^authors or copyright holders be liable for any claim damages or other$^liability whether in an action of contract tort or otherwise arising from$^out of or in connection with the software or the use or other dealings in$^the software.$^$^which is based on http0x00.plsnippetsasmsseutoa.c$^$^  sse conversion integers to decimal representation$^$^  author wojciech mua$^  email wojciechmulapoczta.onet.pl$^  www    http0x00.pl$^$^  license bsd$^$^  initial release 00000000$^  id$^$^$^include utilintegertostring.hh$^include cassert$^include stdint.h$^$^namespace util $^$^namespace $^const char gdigitslut000  $^  00000000000000000000$^  00000000000000000000$^  00000000000000000000$^  00000000000000000000$^  00000000000000000000$^  00000000000000000000$^  00000000000000000000$^  00000000000000000000$^  00000000000000000000$^  00000000000000000000$^$^  namespace$^$^ sse0 implementation according to http0x00.plarticlessseitoa.html$^ modifications 0 fix incorrect digits 0 accept all ranges 0 write to user provided buffer.$^$^if definedamd00  definedmx00  definedsse0  definedmix00  definedi000$^$^include emmintrin.h$^$^ifdef mscver$^include intrin.h$^endif$^$^ifdef mscver$^define alignpre declspecalign00$^define alignsuf$^else$^define alignpre$^define alignsuf  attribute aligned00$^endif$^$^namespace $^$^static const uint00t kdiv00000  0xd0b00000$^alignpre static const uint00t kdiv00000vector0 alignsuf   kdiv00000 kdiv00000 kdiv00000 kdiv00000 $^alignpre static const uint00t k00000vector0 alignsuf   00000 00000 00000 00000 $^alignpre static const uint00t kdivpowersvector0 alignsuf   0000 0000 00000 00000 0000 0000 00000 00000   000 000 000 000$^alignpre static const uint00t kshiftpowersvector0 alignsuf  $^    0  00  00  0  00$^    0  00  00  0  00$^    0  00  0  0$^    0  00$^    0  00  00  0  00$^    0  00  00  0  00$^    0  00  0  0$^    0  00$^$^alignpre static const uint00t k00vector0 alignsuf   00 00 00 00 00 00 00 00 $^alignpre static const char kasciizero00 alignsuf   0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $^$^inline m000i convert0digitssse0uint00t value $^    assertvalue  00000000$^$^     abcd efgh  abcdefgh divmod 00000$^    const m000i abcdefgh  mmcvtsi00si000value$^    const m000i abcd  mmsrliepi00mmmulepu00abcdefgh reinterpretcastconst m000ikdiv00000vector0 00$^    const m000i efgh  mmsubepi00abcdefgh mmmulepu00abcd reinterpretcastconst m000ik00000vector0$^$^     v0   abcd efgh 0 0 0 0 0 0 $^    const m000i v0  mmunpackloepi00abcd efgh$^$^     v0a  v0  0   abcd  0 efgh  0 0 0 0 0 0 0 $^    const m000i v0a  mmslliepi00v0 0$^$^     v0   abcd  0 abcd  0 abcd  0 abcd  0 efgh  0 efgh  0 efgh  0 efgh  0 $^    const m000i v0a  mmunpackloepi00v0a v0a$^    const m000i v0  mmunpackloepi00v0a v0a$^$^     v0  v0 div 000 000 000 000   a ab abc abcd e ef efg efgh $^    const m000i v0  mmmulhiepu00v0 reinterpretcastconst m000ikdivpowersvector0$^    const m000i v0  mmmulhiepu00v0 reinterpretcastconst m000ikshiftpowersvector0$^$^     v0  v0  00   a0 ab0 abc0 abcd0 e0 ef0 efg0 efgh0 $^    const m000i v0  mmmulloepi00v0 reinterpretcastconst m000ik00vector0$^$^     v0  v0  00   0 a0 ab0 abc0 0 e0 ef0 efg0 $^    const m000i v0  mmslliepi00v0 00$^$^     v0  v0  v0   a b c d e f g h $^    const m000i v0  mmsubepi00v0 v0$^$^    return v0$^$^$^inline m000i shiftdigitssse0m000i a unsigned digit $^    assertdigit  0$^    switch digit $^        case 0 return a$^        case 0 return mmsrlisi000a 0$^        case 0 return mmsrlisi000a 0$^        case 0 return mmsrlisi000a 0$^        case 0 return mmsrlisi000a 0$^        case 0 return mmsrlisi000a 0$^        case 0 return mmsrlisi000a 0$^        case 0 return mmsrlisi000a 0$^        case 0 return mmsrlisi000a 0$^    $^    return a  should not execute here.$^$^$^  namespace$^$^ original name u00toasse0$^char tostringuint00t value char buffer $^    if value  00000 $^        const uint00t d0  value  000  0$^        const uint00t d0  value  000  0$^$^        if value  0000$^            buffer  gdigitslutd0$^        if value  000$^            buffer  gdigitslutd0  0$^        if value  00$^            buffer  gdigitslutd0$^        buffer  gdigitslutd0  0$^        buffer  0$^        return buffer$^    $^    else if value  000000000 $^         experiment shows that this case sse0 is slower$^if 0$^        const m000i a  convert0digitssse0value$^$^         convert to bytes add 0$^        const m000i va  mmaddepi0mmpackusepi00a mmsetzerosi000 reinterpretcastconst m000ikasciizero0$^$^         count number of digit$^        const unsigned mask  mmmovemaskepi0mmcmpeqepi0va reinterpretcastconst m000ikasciizero0$^        unsigned long digit$^ifdef mscver$^        bitscanforwarddigit mask  0x0000$^else$^        digit  builtinctzmask  0x0000$^endif$^$^         shift digits to the beginning$^        m000i result  shiftdigitssse0va digit$^        m000i result  mmsrlepi00va mmcvtsi00si000digit  0$^        mmstorelepi00reinterpretcastm000ibuffer result$^        buffer0  digit  0$^else$^         value  bbbbcccc$^        const uint00t b  value  00000$^        const uint00t c  value  00000$^$^        const uint00t d0  b  000  0$^        const uint00t d0  b  000  0$^$^        const uint00t d0  c  000  0$^        const uint00t d0  c  000  0$^$^        if value  00000000$^            buffer  gdigitslutd0$^        if value  0000000$^            buffer  gdigitslutd0  0$^        if value  000000$^            buffer  gdigitslutd0$^        buffer  gdigitslutd0  0$^$^        buffer  gdigitslutd0$^        buffer  gdigitslutd0  0$^        buffer  gdigitslutd0$^        buffer  gdigitslutd0  0$^        buffer  0$^        return buffer$^endif$^    $^    else $^         value  aabbbbbbbb in decimal$^$^        const uint00t a  value  000000000  0 to 00$^        value  000000000$^$^        if a  00 $^            const unsigned i  a  0$^            buffer  gdigitsluti$^            buffer  gdigitsluti  0$^        $^        else$^            buffer  0  staticcastchara$^$^        const m000i b  convert0digitssse0value$^        const m000i ba  mmaddepi0mmpackusepi00mmsetzerosi000 b reinterpretcastconst m000ikasciizero0$^        const m000i result  mmsrlisi000ba 0$^        mmstorelepi00reinterpretcastm000ibuffer result$^        buffer0  0$^        return buffer  0$^    $^$^$^ original name u00toasse0$^char tostringuint00t value char buffer $^    if value  000000000 $^        uint00t v  staticcastuint00tvalue$^        if v  00000 $^            const uint00t d0  v  000  0$^            const uint00t d0  v  000  0$^$^            if v  0000$^                buffer  gdigitslutd0$^            if v  000$^                buffer  gdigitslutd0  0$^            if v  00$^                buffer  gdigitslutd0$^            buffer  gdigitslutd0  0$^            buffer  0$^            return buffer$^        $^        else $^             experiment shows that this case sse0 is slower$^if 0$^            const m000i a  convert0digitssse0v$^$^             convert to bytes add 0$^            const m000i va  mmaddepi0mmpackusepi00a mmsetzerosi000 reinterpretcastconst m000ikasciizero0$^$^             count number of digit$^            const unsigned mask  mmmovemaskepi0mmcmpeqepi0va reinterpretcastconst m000ikasciizero0$^            unsigned long digit$^ifdef mscver$^            bitscanforwarddigit mask  0x0000$^else$^            digit  builtinctzmask  0x0000$^endif$^$^             shift digits to the beginning$^            m000i result  shiftdigitssse0va digit$^            mmstorelepi00reinterpretcastm000ibuffer result$^            buffer0  digit  0$^else$^             value  bbbbcccc$^            const uint00t b  v  00000$^            const uint00t c  v  00000$^$^            const uint00t d0  b  000  0$^            const uint00t d0  b  000  0$^$^            const uint00t d0  c  000  0$^            const uint00t d0  c  000  0$^$^            if value  00000000$^                buffer  gdigitslutd0$^            if value  0000000$^                buffer  gdigitslutd0  0$^            if value  000000$^                buffer  gdigitslutd0$^            buffer  gdigitslutd0  0$^$^            buffer  gdigitslutd0$^            buffer  gdigitslutd0  0$^            buffer  gdigitslutd0$^            buffer  gdigitslutd0  0$^            buffer  0$^            return buffer$^endif$^        $^    $^    else if value  00000000000000000 $^        const uint00t v0  staticcastuint00tvalue  000000000$^        const uint00t v0  staticcastuint00tvalue  000000000$^$^        const m000i a0  convert0digitssse0v0$^        const m000i a0  convert0digitssse0v0$^$^         convert to bytes add 0$^        const m000i va  mmaddepi0mmpackusepi00a0 a0 reinterpretcastconst m000ikasciizero0$^$^         count number of digit$^        const unsigned mask  mmmovemaskepi0mmcmpeqepi0va reinterpretcastconst m000ikasciizero0$^ifdef mscver$^        unsigned long digit$^        bitscanforwarddigit mask  0x0000$^else$^        unsigned digit  builtinctzmask  0x0000$^endif$^$^         shift digits to the beginning$^        m000i result  shiftdigitssse0va digit$^        mmstoreusi000reinterpretcastm000ibuffer result$^        buffer00  digit  0$^        return buffer00  digit$^    $^    else $^        const uint00t a  staticcastuint00tvalue  00000000000000000  0 to 0000$^        value  00000000000000000$^$^        if a  00$^            buffer  0  staticcastchara$^        else if a  000 $^            const uint00t i  a  0$^            buffer  gdigitsluti$^            buffer  gdigitsluti  0$^        $^        else if a  0000 $^            buffer  0  staticcastchara  000$^$^            const uint00t i  a  000  0$^            buffer  gdigitsluti$^            buffer  gdigitsluti  0$^        $^        else $^            const uint00t i  a  000  0$^            const uint00t j  a  000  0$^            buffer  gdigitsluti$^            buffer  gdigitsluti  0$^            buffer  gdigitslutj$^            buffer  gdigitslutj  0$^        $^$^        const uint00t v0  staticcastuint00tvalue  000000000$^        const uint00t v0  staticcastuint00tvalue  000000000$^$^        const m000i a0  convert0digitssse0v0$^        const m000i a0  convert0digitssse0v0$^$^         convert to bytes add 0$^        const m000i va  mmaddepi0mmpackusepi00a0 a0 reinterpretcastconst m000ikasciizero0$^        mmstoreusi000reinterpretcastm000ibuffer va$^        buffer00  0$^        return buffer00$^    $^$^$^else  generic nonx00 case$^$^ orignal name u00toabranchlut$^char tostringuint00t value char buffer $^    if value  00000 $^        const uint00t d0  value  000  0$^        const uint00t d0  value  000  0$^$^        if value  0000$^            buffer  gdigitslutd0$^        if value  000$^            buffer  gdigitslutd0  0$^        if value  00$^            buffer  gdigitslutd0$^        buffer  gdigitslutd0  0$^    $^    else if value  000000000 $^         value  bbbbcccc$^        const uint00t b  value  00000$^        const uint00t c  value  00000$^$^        const uint00t d0  b  000  0$^        const uint00t d0  b  000  0$^$^        const uint00t d0  c  000  0$^        const uint00t d0  c  000  0$^$^        if value  00000000$^            buffer  gdigitslutd0$^        if value  0000000$^            buffer  gdigitslutd0  0$^        if value  000000$^            buffer  gdigitslutd0$^        buffer  gdigitslutd0  0$^$^        buffer  gdigitslutd0$^        buffer  gdigitslutd0  0$^        buffer  gdigitslutd0$^        buffer  gdigitslutd0  0$^    $^    else $^         value  aabbbbcccc in decimal$^$^        const uint00t a  value  000000000  0 to 00$^        value  000000000$^$^        if a  00 $^            const unsigned i  a  0$^            buffer  gdigitsluti$^            buffer  gdigitsluti  0$^        $^        else$^            buffer  0  staticcastchara$^$^        const uint00t b  value  00000  0 to 0000$^        const uint00t c  value  00000  0 to 0000$^$^        const uint00t d0  b  000  0$^        const uint00t d0  b  000  0$^$^        const uint00t d0  c  000  0$^        const uint00t d0  c  000  0$^$^        buffer  gdigitslutd0$^        buffer  gdigitslutd0  0$^        buffer  gdigitslutd0$^        buffer  gdigitslutd0  0$^        buffer  gdigitslutd0$^        buffer  gdigitslutd0  0$^        buffer  gdigitslutd0$^        buffer  gdigitslutd0  0$^    $^    return buffer buffer  0$^$^$^ original name u00toabranchlut$^char tostringuint00t value char buffer $^    if value  000000000 $^        uint00t v  staticcastuint00tvalue$^        if v  00000 $^            const uint00t d0  v  000  0$^            const uint00t d0  v  000  0$^$^            if v  0000$^                buffer  gdigitslutd0$^            if v  000$^                buffer  gdigitslutd0  0$^            if v  00$^                buffer  gdigitslutd0$^            buffer  gdigitslutd0  0$^        $^        else $^             value  bbbbcccc$^            const uint00t b  v  00000$^            const uint00t c  v  00000$^$^            const uint00t d0  b  000  0$^            const uint00t d0  b  000  0$^$^            const uint00t d0  c  000  0$^            const uint00t d0  c  000  0$^$^            if value  00000000$^                buffer  gdigitslutd0$^            if value  0000000$^                buffer  gdigitslutd0  0$^            if value  000000$^                buffer  gdigitslutd0$^            buffer  gdigitslutd0  0$^$^            buffer  gdigitslutd0$^            buffer  gdigitslutd0  0$^            buffer  gdigitslutd0$^            buffer  gdigitslutd0  0$^        $^    $^    else if value  00000000000000000 $^        const uint00t v0  staticcastuint00tvalue  000000000$^        const uint00t v0  staticcastuint00tvalue  000000000$^$^        const uint00t b0  v0  00000$^        const uint00t c0  v0  00000$^$^        const uint00t d0  b0  000  0$^        const uint00t d0  b0  000  0$^$^        const uint00t d0  c0  000  0$^        const uint00t d0  c0  000  0$^$^        const uint00t b0  v0  00000$^        const uint00t c0  v0  00000$^$^        const uint00t d0  b0  000  0$^        const uint00t d0  b0  000  0$^$^        const uint00t d0  c0  000  0$^        const uint00t d0  c0  000  0$^$^        if value  0000000000000000$^            buffer  gdigitslutd0$^        if value  000000000000000$^            buffer  gdigitslutd0  0$^        if value  00000000000000$^            buffer  gdigitslutd0$^        if value  0000000000000$^            buffer  gdigitslutd0  0$^        if value  000000000000$^            buffer  gdigitslutd0$^        if value  00000000000$^            buffer  gdigitslutd0  0$^        if value  0000000000$^            buffer  gdigitslutd0$^        if value  000000000$^            buffer  gdigitslutd0  0$^$^        buffer  gdigitslutd0$^        buffer  gdigitslutd0  0$^        buffer  gdigitslutd0$^        buffer  gdigitslutd0  0$^        buffer  gdigitslutd0$^        buffer  gdigitslutd0  0$^        buffer  gdigitslutd0$^        buffer  gdigitslutd0  0$^    $^    else $^        const uint00t a  staticcastuint00tvalue  00000000000000000  0 to 0000$^        value  00000000000000000$^$^        if a  00$^            buffer  0  staticcastchara$^        else if a  000 $^            const uint00t i  a  0$^            buffer  gdigitsluti$^            buffer  gdigitsluti  0$^        $^        else if a  0000 $^            buffer  0  staticcastchara  000$^$^            const uint00t i  a  000  0$^            buffer  gdigitsluti$^            buffer  gdigitsluti  0$^        $^        else $^            const uint00t i  a  000  0$^            const uint00t j  a  000  0$^            buffer  gdigitsluti$^            buffer  gdigitsluti  0$^            buffer  gdigitslutj$^            buffer  gdigitslutj  0$^        $^$^        const uint00t v0  staticcastuint00tvalue  000000000$^        const uint00t v0  staticcastuint00tvalue  000000000$^$^        const uint00t b0  v0  00000$^        const uint00t c0  v0  00000$^$^        const uint00t d0  b0  000  0$^        const uint00t d0  b0  000  0$^$^        const uint00t d0  c0  000  0$^        const uint00t d0  c0  000  0$^$^        const uint00t b0  v0  00000$^        const uint00t c0  v0  00000$^$^        const uint00t d0  b0  000  0$^        const uint00t d0  b0  000  0$^$^        const uint00t d0  c0  000  0$^        const uint00t d0  c0  000  0$^$^        buffer  gdigitslutd0$^        buffer  gdigitslutd0  0$^        buffer  gdigitslutd0$^        buffer  gdigitslutd0  0$^        buffer  gdigitslutd0$^        buffer  gdigitslutd0  0$^        buffer  gdigitslutd0$^        buffer  gdigitslutd0  0$^        buffer  gdigitslutd0$^        buffer  gdigitslutd0  0$^        buffer  gdigitslutd0$^        buffer  gdigitslutd0  0$^        buffer  gdigitslutd0$^        buffer  gdigitslutd0  0$^        buffer  gdigitslutd0$^        buffer  gdigitslutd0  0$^    $^    return buffer$^$^$^endif  end of architecture if statement.$^$^ signed wrappers.  the negation is done on the unsigned version because$^ doing so has defined behavior for intmin.$^char tostringint00t value char to $^  uint00t un  staticcastuint00tvalue$^  if value  0 $^    to  $^    un  un$^  $^  return tostringun to$^$^$^char tostringint00t value char to $^  uint00t un  staticcastuint00tvalue$^  if value  0 $^    to  $^    un  un$^  $^  return tostringun to$^$^$^ no optimization for this case yet.$^char tostringint00t value char to $^  return tostringint00tvalue to$^$^char tostringuint00t value char to $^  return tostringuint00tvalue to$^$^$^ void  to string.  this hasnt been optimized at all really.$^namespace $^const char khexdigits  0000000000abcdef$^  namespace$^$^char tostringconst void v char to $^  to  0$^  to  x$^$^   fun fact gccclang boostlexicalcast on linux do just 0 while clang on os x does 0x0$^   i happen to prefer 0x0.$^  if v $^    to  0$^    return to$^  $^$^  uintptrt value  reinterpretcastuintptrtv$^  uint0t shift  sizeofvoid  0  0$^  for  value  shift shift  0 $^  for   shift  0 $^    to  khexdigitsvalue  shift  0xf$^    if shift break$^  $^  return to$^$^$^  namespace util$^include utilsizediterator.hh$^$^define boosttestmodule sizediteratortest$^include boosttestunittest.hpp$^$^namespace util  namespace $^$^struct comparechar $^  bool operatorconst void first const void second const $^    return staticcastconst charfirst  staticcastconst charsecond$^  $^$^$^boostautotestcasesort $^  char items0  0 0 0$^  sizedsortitems items  0 0 comparechar$^  boostcheckequal0 items0$^  boostcheckequal0 items0$^  boostcheckequal0 items0$^$^$^  namespace anonymous util$^include utilsorteduniform.hh$^$^include boostrandommersennetwister.hpp$^include boostrandomuniformint.hpp$^include boostrandomvariategenerator.hpp$^include boostscopedarray.hpp$^include boostunorderedmap.hpp$^$^define boosttestmodule sorteduniformtest$^include boosttestunittest.hpp$^$^include algorithm$^include limits$^include vector$^$^namespace util $^namespace $^$^template class keyt class valuet struct entry $^  typedef keyt key$^  typedef valuet value$^$^  key key$^  value value$^$^  key getkey const $^    return key$^  $^$^  value getvalue const $^    return value$^  $^$^  bool operatorconst entrykeyvalue other const $^    return key  other.key$^  $^$^$^template class keyt struct accessor $^  typedef keyt key$^  template class value key operatorconst entrykey value entry const $^    return entrygetkey$^  $^$^$^template class key class value void checkconst entrykey value begin const entrykey value end const boostunorderedmapkey value reference const key key $^  typename boostunorderedmapkey valueconstiterator ref  reference.findkey$^  typedef const entrykey value it$^   g cant tell that require will crash and burn.$^  it i  null$^  bool ret  sorteduniformfindit accessorkey pivot00accessorkey begin end key i$^  if ref  reference.end $^    boostcheckret$^   else $^    boostrequireret$^    boostcheckequalrefsecond igetvalue$^  $^$^$^boostautotestcaseempty $^  typedef const entryuint00t float t$^  const t i$^  bool ret  sorteduniformfindconst t accessoruint00t pivot00accessoruint00t const tnull const tnull uint00t00 i$^  boostcheckret$^$^$^template class key void randomtestkey upper sizet entries sizet queries $^  typedef unsigned char value$^  boostmt00000 rng$^  boostuniformintkey rangekey0 upper$^  boostuniformintvalue rangevalue0 000$^  boostvariategeneratorboostmt00000 boostuniformintkey  genkeyrng rangekey$^  boostvariategeneratorboostmt00000 boostuniformintunsigned char  genvaluerng rangevalue$^$^  typedef entrykey value ent$^  stdvectorent backing$^  boostunorderedmapkey unsigned char reference$^  ent ent$^  for sizet i  0 i  entries i $^    key key  genkey$^    unsigned char value  genvalue$^    if reference.insertstdmakepairkey value.second $^      ent.key  key$^      ent.value  value$^      backing.pushbackent$^    $^  $^  stdsortbacking.begin backing.end$^$^   random queries.$^  for sizet i  0 i  queries i $^    const key key  genkey$^    checkkey unsigned charbacking.begin backing.end reference key$^  $^$^  typename boostunorderedmapkey unsigned charconstiterator it  reference.begin$^  for sizet i  0 i  queries  it  reference.end i it $^    checkkey unsigned charbacking.begin backing.end reference itsecond$^  $^$^$^boostautotestcasebasic $^  randomtestuint0t00 00 000$^$^$^boostautotestcasetinydenserandom $^  randomtestuint0t00 00 000$^$^$^boostautotestcasesmalldenserandom $^  randomtestuint0t000 000 000$^$^$^boostautotestcasesmallsparserandom $^  randomtestuint0t000 00 000$^$^$^boostautotestcasemediumsparserandom $^  randomtestuint00t00000 0000 0000$^$^$^boostautotestcasesparserandom $^  randomtestuint00tstdnumericlimitsuint00tmax 000000 0000$^$^$^  namespace$^  namespace util$^include utilspaces.hh$^$^namespace util $^$^ sigh this is the only way i could come up with to do a const bool.  it has   f n r t and v same as isspace on c locale.$^const bool kspaces000  0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000$^$^  namespace util$^include utilfile.hh$^include utilprobinghashtable.hh$^include utilmmap.hh$^include utilusage.hh$^include utilthreadpool.hh$^include boostthreadmutex.hpp$^include boostthreadlocks.hpp$^$^ifdef win00$^include processthreadsapi.h$^else$^include sysresource.h$^endif$^$^include systime.h$^$^include iostream$^$^namespace util $^namespace $^$^struct entry $^  typedef uint00t key$^  key key$^  key getkey const  return key $^$^$^ i dont care if this doesnt run on windows.  empirically devurandom was faster than boostrandoms mersenne twister.$^class urandom $^  public$^    urandom $^      itbuf  0000 endbuf  0000$^      fileutilopenreadorthrowdevurandom $^$^    uint00t get $^      if it  end $^        it  buf$^        utilreadorthrowfile.get buf sizeofbuf$^        it  buf$^      $^      return it$^    $^$^    void batchuint00t begin uint00t end $^      utilreadorthrowfile.get begin end  begin  sizeofuint00t$^    $^$^  private$^    uint00t buf0000$^    uint00t it end$^$^    utilscopedfd file$^$^$^struct prefetchentry $^  uint00t key$^  const entry pointer$^$^$^template class tablet unsigned prefetchsize class prefetchqueue $^  public$^    typedef tablet table$^$^    explicit prefetchqueuetable table  tabletable cur0 twiddlefalse $^      for prefetchentry i  entries i  entries  prefetchsize i$^        ipointer  null$^    $^$^    void adduint00t key $^      if cur.pointer $^        twiddle  table.findfromidealcur.key cur.pointer$^      $^      cur.key  key$^      cur.pointer  table.idealkey$^      builtinprefetchcur.pointer 0 0$^      next$^    $^$^    bool drain $^      if cur.pointer $^        for prefetchentry i  cur i  entries  prefetchsize i $^          twiddle  table.findfromidealikey ipointer$^        $^      $^      for prefetchentry i  entries i  cur i $^        twiddle  table.findfromidealikey ipointer$^      $^      return twiddle$^    $^$^  private$^    prefetchentry cur  return entriescur $^    void next $^      cur$^      cur  cur  prefetchsize$^    $^$^    table table$^    prefetchentry entriesprefetchsize$^    stdsizet cur$^$^    bool twiddle$^$^    prefetchqueueconst prefetchqueue$^    void operatorconst prefetchqueue$^$^$^template class tablet class immediate $^  public$^    typedef tablet table$^$^    explicit immediatetable table  tabletable twiddlefalse $^$^    void adduint00t key $^      typename tableconstiterator it$^      twiddle  table.findkey it$^    $^$^    bool drain const  return twiddle $^$^  private$^    table table$^    bool twiddle$^$^$^stdsizet sizeuint00t entries float multiplier  0.0 $^  typedef utilprobinghashtableentry utilidentityhash stdequaltoentrykey power0mod table$^   always round up to power of 0 for fair comparison.$^  return power0modroundbucketstablesizeentries multiplier  sizeofentry  sizeofentry$^$^$^template class queue bool testurandom rn uint00t entries const uint00t const queriesbegin const uint00t const queriesend bool ordinarymalloc float multiplier  0.0 $^  stdsizet size  sizeentries multiplier$^  scopedmemory backing$^  if ordinarymalloc $^    backing.resetutilcallocorthrowsize size scopedmemorymallocallocated$^   else $^    utilhugemallocsize true backing$^  $^  typename queuetable tablebacking.get size$^$^  double start  cputime$^  for uint00t i  0 i  entries i $^    entry entry$^    entry.key  rn.get$^    table.insertentry$^  $^  double inserted  cputime  start$^  double beforelookup  cputime$^  queue queuetable$^  for const uint00t i  queriesbegin i  queriesend i $^    queue.addi$^  $^  bool meaningless  queue.drain$^  stdcout     inserted  staticcastdoubleentries     cputime  beforelookup  staticcastdoublequeriesend  queriesbegin  stdflush$^  return meaningless$^$^$^bool testrunuint00t lookups  00000000 float multiplier  0.0 $^  urandom rn$^  utilscopedmemory queries$^  hugemalloclookups  sizeofuint00t true queries$^  rn.batchstaticcastuint00tqueries.get staticcastuint00tqueries.get  lookups$^  uint00t physicalmemlimit  utilguessphysicalmemory  0$^  bool meaningless  true$^  for uint00t i  0 sizei  multiplier  physicalmemlimit i  0 $^    stdcout  staticcaststdsizeti  multiplier     sizei  multiplier$^    typedef utilprobinghashtableentry utilidentityhash stdequaltoentrykey power0mod table$^    typedef utilprobinghashtableentry utilidentityhash stdequaltoentrykey divmod tablediv$^    const uint00t const queriesbegin  staticcastconst uint00tqueries.get$^    meaningless  utiltestimmediatetablediv rn i  multiplier queriesbegin queriesbegin  lookups true multiplier$^    meaningless  utiltestimmediatetable rn i  multiplier queriesbegin queriesbegin  lookups true multiplier$^    meaningless  utiltestprefetchqueuetable 0 rn i  multiplier queriesbegin queriesbegin  lookups true multiplier$^    meaningless  utiltestimmediatetable rn i  multiplier queriesbegin queriesbegin  lookups false multiplier$^    meaningless  utiltestprefetchqueuetable 0 rn i  multiplier queriesbegin queriesbegin  lookups false multiplier$^    meaningless  utiltestprefetchqueuetable 0 rn i  multiplier queriesbegin queriesbegin  lookups false multiplier$^    meaningless  utiltestprefetchqueuetable 0 rn i  multiplier queriesbegin queriesbegin  lookups false multiplier$^    meaningless  utiltestprefetchqueuetable 00 rn i  multiplier queriesbegin queriesbegin  lookups false multiplier$^    stdcout  stdendl$^  $^  return meaningless$^$^$^templateclass table$^struct paralleltestrequest$^  paralleltestrequest  queriesbeginnull queriesendnull tablenull $^  paralleltestrequestconst uint00t queriesbegin const uint00t queriesend table table $^      queriesbeginqueriesbegin$^      queriesendqueriesend$^      tabletable $^  bool operatorconst paralleltestrequest rhs const $^    return thisqueriesbegin  rhs.queriesbegin  thisqueriesend  rhs.queriesend$^  $^  const uint00t queriesbegin$^  const uint00t queriesend$^  table  table$^$^$^template class tablet$^struct paralleltestconstruct$^  paralleltestconstructboostmutex lock const uint00t const burnbegin const uint00t const burnend tablet table  locklock burnbeginburnbegin burnendburnend tabletable$^  boostmutex lock$^  const uint00t const burnbegin$^  const uint00t const burnend$^  tablet table$^$^$^templateclass queue$^struct paralleltesthandler$^  typedef paralleltestrequesttypename queuetable request$^  explicit paralleltesthandlerconst paralleltestconstructtypename queuetable construct  lockconstruct.lock totaltime0.0 nrequests0 nqueries0 errorfalse twiddlefalse$^    perform initial burn$^    forconst uint00t i  construct.burnbegin i  construct.burnend i$^      typename queuetableconstiterator it$^      twiddle  construct.tablefindi it$^    $^  $^  void operatorrequest request$^    if error return$^    queue queuerequest.table$^    double start  threadtime$^    ifstart  0.0$^      error  true$^      return$^    $^    forconst uint00t i  request.queriesbegin i  request.queriesend i$^      queue.addi$^    $^    twiddle  queue.drain$^    double end  threadtime$^    ifend  0.0$^      error  true$^      return$^    $^    totaltime  end  start$^    nqueries  request.queriesend  request.queriesbegin$^    nrequests$^  $^  virtual paralleltesthandler $^    boostuniquelockboostmutex producelocklock$^    if error$^      stdcout  error $^    $^    else $^      stdcout  nrequests        nqueries     totaltime  stdendl$^    $^    stdcerr  meaningless   twiddle  stdendl$^  $^  private$^    boostmutex lock$^    double totaltime$^    stdsizet nrequests$^    stdsizet nqueries$^    bool error$^    bool twiddle$^$^$^templateclass queue$^void paralleltesttypename queuetable table const uint00t const queriesbegin$^                  const uint00t const queriesend stdsizet numthreads$^                  stdsizet tasksperthread stdsizet burn$^    boostmutex lock$^    paralleltestconstructtypename queuetable constructlock queriesbegin queriesbegin  burn table$^    paralleltestrequesttypename queuetable poisonnull null null$^    $^      utilthreadpoolparalleltesthandlerqueue  poolnumthreads numthreads construct poison$^      const uint00t queriesperthread staticcastuint00tqueriesendqueriesbeginburnnumthreadstasksperthread$^      for const uint00t i  queriesbeginburn i  queriesperthread  queriesend i  queriesperthread$^        paralleltestrequesttypename queuetable requesti iqueriesperthread table$^        pool.producerequest$^      $^      pool gets deallocated and all jobs finish$^    stdcout  stdendl$^$^$^void paralleltestrunstdsizet tasksperthread  0 stdsizet burn  0000 uint00t lookups  00000000 float multiplier  0.0 $^  urandom rn$^  utilscopedmemory queries$^  hugemalloclookups  burn sizeofuint00t true queries$^  rn.batchstaticcastuint00tqueries.get staticcastuint00tqueries.get  lookups  burn$^  const uint00t const queriesbegin  staticcastconst uint00tqueries.get$^  const uint00t const queriesend  queriesbegin  lookups  burn$^  typedef utilprobinghashtableentry utilidentityhash stdequaltoentrykey power0mod table$^  uint00t physicalmemlimit  utilguessphysicalmemory  0$^  for uint00t i  0 sizei  multiplier multiplier  physicalmemlimit i  0 $^    stdsizet entries  staticcaststdsizeti  multiplier$^    stdsizet size  sizeimultiplier multiplier$^    scopedmemory backing$^    utilhugemallocsize true backing$^    table tablebacking.get size$^    for uint00t j  0 j  entries j $^      entry entry$^      entry.key  rn.get$^      table.insertentry$^    $^    forstdsizet numthreads  0 numthreads  00 numthreads0$^      stdcout  entries     size     numthreads     stdendl$^      utilparalleltestimmediatetable table queriesbegin queriesend numthreads tasksperthread burn$^      utilparalleltestprefetchqueuetable 0 table queriesbegin queriesend numthreads tasksperthread burn$^      utilparalleltestprefetchqueuetable 0 table queriesbegin queriesend numthreads tasksperthread burn$^      utilparalleltestprefetchqueuetable 0 table queriesbegin queriesend numthreads tasksperthread burn$^      utilparalleltestprefetchqueuetable 00 table queriesbegin queriesend numthreads tasksperthread burn$^    $^  $^$^$^  namespace$^  namespace util$^$^int main $^  bool meaningless  false$^  stdcout  cpu timen$^  meaningless  utiltestrun$^  utilparalleltestrun00 0000$^  stdcerr  meaningless   meaningless  n$^$^ downloaded from httpsites.google.comsitemurmurhash which says all$^  code is released to the public domain. for business purposes murmurhash is$^  under the mit license.$^  this is modified from the original$^  ull tag on 0xc0a0a0000bd0e000 so this will compile on 00bit.$^  length changed to unsigned int.$^  placed in namespace util$^  add murmurhashnative$^  default option  0 for seed$^  arm port from nict$^ $^$^include utilmurmurhash.hh$^include cstring$^$^namespace util $^$^$^ murmurhash0 00bit versions by austin appleby$^$^ the same caveats as 00bit murmurhash0 apply here  beware of alignment$^ and endianness issues if used across multiple platforms.$^$^ 00bit hash for 00bit platforms$^$^uint00t murmurhash00a  const void  key stdsizet len uint00t seed $^$^  const uint00t m  0xc0a0a0000bd0e000ull$^  const int r  00$^$^  uint00t h  seed  len  m$^$^if definedarm  definedarm$^  const sizet ksize  sizeofuint00t$^  const unsigned char  data  const unsigned char key$^  const unsigned char  end  data  stdsizetlen0  ksize$^else$^  const uint00t  data  const uint00t key$^  const uint00t  end  data  len0$^endif$^$^  whiledata  end$^  $^if definedarm  definedarm$^    uint00t k$^    memcpyk data ksize$^    data  ksize$^else$^    uint00t k  data$^endif$^$^    k  m$^    k  k  r$^    k  m$^$^    h  k$^    h  m$^  $^$^  const unsigned char  data0  const unsigned chardata$^$^  switchlen  0$^  $^  case 0 h  uint00tdata00  00$^  case 0 h  uint00tdata00  00$^  case 0 h  uint00tdata00  00$^  case 0 h  uint00tdata00  00$^  case 0 h  uint00tdata00  00$^  case 0 h  uint00tdata00  0$^  case 0 h  uint00tdata00$^          h  m$^  $^$^  h  h  r$^  h  m$^  h  h  r$^$^  return h$^$^$^$^ 00bit hash for 00bit platforms$^$^uint00t murmurhash00b  const void  key stdsizet len uint00t seed $^$^  const unsigned int m  0x0bd0e000$^  const int r  00$^$^  unsigned int h0  seed  len$^  unsigned int h0  0$^$^if definedarm  definedarm$^  sizet ksize  sizeofunsigned int$^  const unsigned char  data  const unsigned char key$^else$^  const unsigned int  data  const unsigned int key$^endif$^$^  unsigned int k0 k0$^  whilelen  0$^  $^if definedarm  definedarm$^    memcpyk0 data ksize$^    data  ksize$^    memcpyk0 data ksize$^    data  ksize$^else$^    k0  data$^    k0  data$^endif$^$^    k0  m k0  k0  r k0  m$^    h0  m h0  k0$^    len  0$^$^    k0  m k0  k0  r k0  m$^    h0  m h0  k0$^    len  0$^  $^$^  iflen  0$^  $^if definedarm  definedarm$^    memcpyk0 data ksize$^    data  ksize$^else$^    k0  data$^endif$^    k0  m k0  k0  r k0  m$^    h0  m h0  k0$^    len  0$^  $^$^  switchlen$^  $^  case 0 h0  unsigned chardata0  00$^  case 0 h0  unsigned chardata0  0$^  case 0 h0  unsigned chardata0$^      h0  m$^  $^$^  h0  h0  00 h0  m$^  h0  h0  00 h0  m$^  h0  h0  00 h0  m$^  h0  h0  00 h0  m$^$^  uint00t h  h0$^$^  h  h  00  h0$^$^  return h$^$^$^ trick to test for 00bit architecture at compile time.$^namespace $^ifdef clang$^pragma clang diagnostic push$^pragma clang diagnostic ignored wunusedfunction$^endif$^template unsigned l inline uint00t murmurhashnativebackendconst void  key stdsizet len uint00t seed $^  return murmurhash00akey len seed$^$^template  inline uint00t murmurhashnativebackend0const void  key stdsizet len uint00t seed $^  return murmurhash00bkey len seed$^$^ifdef clang$^pragma clang diagnostic pop$^endif$^  namespace$^$^uint00t murmurhashnativeconst void  key stdsizet len uint00t seed $^  return murmurhashnativebackendsizeofvoidkey len seed$^$^$^  namespace util$^define boostlexicalcastassumeclocale$^include utilintegertostring.hh$^include utilstringpiece.hh$^$^define boosttestmodule integertostringtest$^include boosttestunittest.hpp$^include boostlexicalcast.hpp$^$^include limits$^$^namespace util $^namespace $^$^template class t void testvalueconst t value $^  char buftostringbuftkbytes$^  stringpiece resultbuf tostringvalue buf  buf$^  boostrequiregestaticcaststdsizettostringbuftkbytes result.size$^  if value $^    boostcheckequalboostlexicalcaststdstringvalue result$^   else $^     platforms can do void  as 0x0 or 0.$^    boostcheckresult  0x0  result  0$^  $^$^$^template class t void testcorners $^  testvaluestdnumericlimitstmin$^  testvaluestdnumericlimitstmax$^  testvaluet0$^  testvaluet0$^  testvaluet0$^$^$^boostautotestcasecorners $^  testcornersuint00t$^  testcornersuint00t$^  testcornersuint00t$^  testcornersint00t$^  testcornersint00t$^  testcornersint00t$^  testcornersconst void$^$^$^template class t void testall $^  for t i  stdnumericlimitstmin i  stdnumericlimitstmax i $^    testvaluei$^  $^  testvaluestdnumericlimitstmax$^$^$^boostautotestcaseshort $^  testalluint00t$^  testallint00t$^$^$^template class t void test00s $^  for t i  0 i  stdnumericlimitstmax  00 i  00 $^    testvaluei$^    testvaluei  0$^    testvaluei  0$^  $^$^$^boostautotestcasetens $^  test00suint00t$^  test00sint00t$^  test00suint00t$^  test00sint00t$^$^$^boostautotestcasepointers $^  for uintptrt i  0 i  stdnumericlimitsuintptrtmax  00 i  00 $^    testvalueconst voidi$^  $^  for uintptrt i  0 i  000 i $^    testvalueconst voidi$^    testvalueconst voidi  0xf00$^  $^$^$^  namespaces$^include utilscoped.hh$^$^include cstdlib$^if definedwin00  definedwin00$^include sysmman.h$^endif$^$^namespace util $^$^ todo if were really under memory pressure dont allocate memory to$^ display the error.$^mallocexceptionmallocexceptionstdsizet requested throw $^  this  for   requested   bytes $^$^$^mallocexceptionmallocexception throw $^$^namespace $^void inspectaddrvoid addr stdsizet requested const char funcname $^  utilthrowifargaddr  requested mallocexception requested in   funcname$^  return addr$^$^  namespace$^$^void mallocorthrowstdsizet requested $^  return inspectaddrstdmallocrequested requested malloc$^$^$^void callocorthrowstdsizet requested $^  return inspectaddrstdcallocrequested 0 requested calloc$^$^$^void scopedmalloccallreallocstdsizet requested $^  p  inspectaddrstdreallocp requested requested realloc$^$^$^void advisehugepagesconst void addr stdsizet size $^if madvhugepage$^  madvisevoidaddr size madvhugepage$^endif$^$^$^  namespace util$^include utilreadcompressed.hh$^$^include utilfile.hh$^include utilhave.hh$^include utilscoped.hh$^$^include algorithm$^include iostream$^$^include cassert$^include climits$^include cstdlib$^include cstring$^$^ifdef havezlib$^include zlib.h$^endif$^$^ifdef havebzlib$^include bzlib.h$^endif$^$^ifdef havexzlib$^include lzma.h$^endif$^$^namespace util $^$^compressedexceptioncompressedexception throw $^compressedexceptioncompressedexception throw $^$^gzexceptiongzexception throw $^gzexceptiongzexception throw $^$^bzexceptionbzexception throw $^bzexceptionbzexception throw $^$^xzexceptionxzexception throw $^xzexceptionxzexception throw $^$^void readbasereplacethisreadbase with readcompressed thunk $^  thunk.internal.resetwith$^$^$^readbase readbasecurrentreadcompressed thunk  return thunk.internal.get $^$^uint00t readbasereadcountreadcompressed thunk $^  return thunk.rawamount$^$^$^namespace $^$^readbase readfactoryint fd uint00t rawamount const void alreadydata stdsizet alreadysize bool requirecompressed$^$^ completed file that other classes can thunk to.$^class complete  public readbase $^  public$^    stdsizet readvoid  stdsizet readcompressed  $^      return 0$^    $^$^$^class uncompressed  public readbase $^  public$^    explicit uncompressedint fd  fdfd $^$^    stdsizet readvoid to stdsizet amount readcompressed thunk $^      stdsizet got  partialreadfd.get to amount$^      readcountthunk  got$^      return got$^    $^$^  private$^    scopedfd fd$^$^$^class uncompressedwithheader  public readbase $^  public$^    uncompressedwithheaderint fd const void alreadydata stdsizet alreadysize  fdfd $^      assertalreadysize$^      buf.resetmallocalreadysize$^      if buf.get throw stdbadalloc$^      memcpybuf.get alreadydata alreadysize$^      remain  staticcastuint0tbuf.get$^      end  remain  alreadysize$^    $^$^    stdsizet readvoid to stdsizet amount readcompressed thunk $^      assertbuf.get$^      assertremain  end$^      stdsizet sending  stdminstdsizetamount end  remain$^      memcpyto remain sending$^      remain  sending$^      if remain  end $^        replacethisnew uncompressedfd.release thunk$^      $^      return sending$^    $^$^  private$^    scopedmalloc buf$^    uint0t remain$^    uint0t end$^$^    scopedfd fd$^$^$^static const stdsizet kinputbuffer  00000$^$^template class compression class streamcompressed  public readbase $^  public$^    streamcompressedint fd const void alreadydata stdsizet alreadysize$^       filefd$^        inbuffermallocorthrowkinputbuffer$^        backmemcpyinbuffer.get alreadydata alreadysize alreadysize $^$^    stdsizet readvoid to stdsizet amount readcompressed thunk $^      if amount  0 return 0$^      back.setoutputto amount$^      do $^        if back.stream.availin readinputthunk$^        if back.process $^           reached end at least for the compressed portion.$^          stdsizet ret  staticcastconst uint0t staticcastvoidback.stream.nextout  staticcastconst uint0tto$^          replacethisreadfactoryfile.release readcountthunk back.stream.nextin back.stream.availin true thunk$^          if ret return ret$^           we did not read anything this round so clients might think eof.  transfer responsibility to the next reader.$^          return currentthunkreadto amount thunk$^        $^       while back.stream.nextout  to$^      return staticcastconst uint0tstaticcastvoidback.stream.nextout  staticcastconst uint0tto$^    $^$^  private$^    void readinputreadcompressed thunk $^      assertback.stream.availin$^      stdsizet got  readoreoffile.get inbuffer.get kinputbuffer$^      back.setinputinbuffer.get got$^      readcountthunk  got$^    $^$^    scopedfd file$^    scopedmalloc inbuffer$^$^    compression back$^$^$^ifdef havezlib$^class gzip $^  public$^    gzipconst void base stdsizet amount $^      setinputbase amount$^      stream.zalloc  znull$^      stream.zfree  znull$^      stream.opaque  znull$^      stream.msg  null$^       00 for zlib and gzip decoding with automatic header detection.$^       00 for maximum window size.$^      utilthrowifzok  inflateinit0stream 00  00 gzexception failed to initialize zlib.$^    $^$^    gzip $^      if zok  inflateendstream $^        stdcerr  zlib could not close properly.  stdendl$^        abort$^      $^    $^$^    void setoutputvoid to stdsizet amount $^      stream.nextout  staticcastbytefto$^      stream.availout  stdminstdsizetstdnumericlimitsuintmax amount$^    $^$^    void setinputconst void base stdsizet amount $^      assertamount  staticcaststdsizetstdnumericlimitsuintmax$^      stream.nextin  constcastbytefstaticcastconst bytefbase$^      stream.availin  amount$^    $^$^    const zstream stream const  return stream $^$^    bool process $^      int result  inflatestream 0$^      switch result $^        case zok$^          return true$^        case zstreamend$^          return false$^        case zerrno$^          utilthrowerrnoexception zlib error$^        default$^          utilthrowgzexception zlib encountered   stream.msg  stream.msg  an error    code   result$^      $^    $^$^  private$^    zstream stream$^$^endif  havezlib$^$^ifdef havebzlib$^class bzip $^  public$^    bzipconst void base stdsizet amount $^      memsetstream 0 sizeofstream$^      setinputbase amount$^      handleerrorbz0bzdecompressinitstream 0 0$^    $^$^    bzip $^      try $^        handleerrorbz0bzdecompressendstream$^       catch const stdexception e $^        stdcerr  e.what  stdendl$^        abort$^      $^    $^$^    bool process $^      int ret  bz0bzdecompressstream$^      if ret  bzstreamend return false$^      handleerrorret$^      return true$^    $^$^    void setoutputvoid base stdsizet amount $^      stream.nextout  staticcastcharbase$^      stream.availout  stdminstdsizetstdnumericlimitsunsigned intmax amount$^    $^$^    void setinputconst void base stdsizet amount $^      stream.nextin  constcastcharstaticcastconst charbase$^      stream.availin  amount$^    $^$^    const bzstream stream const  return stream $^$^  private$^    void handleerrorint value $^      switchvalue $^        case bzok$^          return$^        case bzconfigerror$^          utilthrowbzexception bzip0 seems to be miscompiled.$^        case bzparamerror$^          utilthrowbzexception bzip0 parameter error$^        case bzdataerror$^          utilthrowbzexception bzip0 detected a corrupt file$^        case bzdataerrormagic$^          utilthrowbzexception bzip0 detected bad magic bytes.  perhaps this was not a bzip0 file after all$^        case bzmemerror$^          throw stdbadalloc$^        default$^          utilthrowbzexception unknown bzip0 error code   value$^      $^    $^$^    bzstream stream$^$^endif  havebzlib$^$^ifdef havexzlib$^class xzip $^  public$^    xzipconst void base stdsizet amount$^       stream actionlzmarun $^      memsetstream 0 sizeofstream$^      setinputbase amount$^      handleerrorlzmastreamdecoderstream uint00max 0$^    $^$^    xzip $^      lzmaendstream$^    $^$^    void setoutputvoid base stdsizet amount $^      stream.nextout  staticcastuint0tbase$^      stream.availout  amount$^    $^$^    void setinputconst void base stdsizet amount $^      stream.nextin  staticcastconst uint0tbase$^      stream.availin  amount$^      if amount action  lzmafinish$^    $^$^    const lzmastream stream const  return stream $^$^    bool process $^      lzmaret status  lzmacodestream action$^      if status  lzmastreamend return false$^      handleerrorstatus$^      return true$^    $^$^  private$^    void handleerrorlzmaret value $^      switch value $^        case lzmaok$^          return$^        case lzmamemerror$^          throw stdbadalloc$^        case lzmaformaterror$^          utilthrowxzexception xzlib says file format not recognized$^        case lzmaoptionserror$^          utilthrowxzexception xzlib says unsupported compression options$^        case lzmadataerror$^          utilthrowxzexception xzlib says this file is corrupt$^        case lzmabuferror$^          utilthrowxzexception xzlib says unexpected end of input$^        default$^          utilthrowxzexception unrecognized xzlib error   value$^      $^    $^$^    lzmastream stream$^    lzmaaction action$^$^endif  havexzlib$^$^class istreamreader  public readbase $^  public$^    explicit istreamreaderstdistream stream  streamstream $^$^    stdsizet readvoid to stdsizet amount readcompressed thunk $^      if stream.readstaticcastcharto amount $^        utilthrowifstream.eof errnoexception istream error$^        amount  stream.gcount$^      $^      readcountthunk  amount$^      return amount$^    $^$^  private$^    stdistream stream$^$^$^enum magicresult $^  utilunknown utilgzip utilbzip utilxzip$^$^$^magicresult detectmagicconst void fromvoid stdsizet length $^  const uint0t header  staticcastconst uint0tfromvoid$^  if length  0  header0  0x0f  header0  0x0b $^    return utilgzip$^  $^  const uint0t kbzmagic0  b z h$^  if length  sizeofkbzmagic  memcmpheader kbzmagic sizeofkbzmagic $^    return utilbzip$^  $^  const uint0t kxzmagic0   0xfd 0 z x z 0x00 $^  if length  sizeofkxzmagic  memcmpheader kxzmagic sizeofkxzmagic $^    return utilxzip$^  $^  return utilunknown$^$^$^readbase readfactoryint fd uint00t rawamount const void alreadydata const stdsizet alreadysize bool requirecompressed $^  scopedfd holdfd$^  stdstring headerreinterpretcastconst charalreadydata alreadysize$^  if header.size  readcompressedkmagicsize $^    stdsizet original  header.size$^    header.resizereadcompressedkmagicsize$^    stdsizet got  readoreoffd headeroriginal readcompressedkmagicsize  original$^    rawamount  got$^    header.resizeoriginal  got$^  $^  if header.empty $^    return new complete$^  $^  switch detectmagicheader0 header.size $^    case utilgzip$^ifdef havezlib$^      return new streamcompressedgziphold.release header.data header.size$^else$^      utilthrowcompressedexception this looks like a gzip file but gzip support was not compiled in.$^endif$^    case utilbzip$^ifdef havebzlib$^      return new streamcompressedbziphold.release header0 header.size$^else$^      utilthrowcompressedexception this looks like a bzip file it begins with bzh but bzip support was not compiled in.$^endif$^    case utilxzip$^ifdef havexzlib$^      return new streamcompressedxziphold.release header.data header.size$^else$^      utilthrowcompressedexception this looks like an xz file but xz support was not compiled in.$^endif$^    default$^      utilthrowifrequirecompressed compressedexception uncompressed data detected after a compresssed file.  this could be supported but usually indicates an error.$^      return new uncompressedwithheaderhold.release header.data header.size$^  $^$^$^  namespace$^$^bool readcompresseddetectcompressedmagicconst void fromvoid $^  return detectmagicfromvoid kmagicsize  utilunknown$^$^$^readcompressedreadcompressedint fd $^  resetfd$^$^$^readcompressedreadcompressedstdistream in $^  resetin$^$^$^readcompressedreadcompressed $^$^void readcompressedresetint fd $^  rawamount  0$^  internal.reset$^  internal.resetreadfactoryfd rawamount null 0 false$^$^$^void readcompressedresetstdistream in $^  internal.reset$^  internal.resetnew istreamreaderin$^$^$^stdsizet readcompressedreadvoid to stdsizet amount $^  return internalreadto amount this$^$^$^stdsizet readcompressedreadoreofvoid const toin stdsizet amount $^  uint0t to  reinterpretcastuint0ttoin$^  while amount $^    stdsizet got  readto amount$^    if got break$^    to  got$^    amount  got$^  $^  return to  reinterpretcastuint0ttoin$^$^$^  namespace util$^include utilexception.hh$^$^ifdef gxxrtti$^include typeinfo$^endif$^$^include cerrno$^include cstring$^$^if definedwin00  definedwin00$^include windows.h$^include io.h$^endif$^$^namespace util $^$^exceptionexception throw $^exceptionexception throw $^$^void exceptionsetlocationconst char file unsigned int line const char func const char childname const char condition $^   the child class might have set some text but we want this to come first.$^    another option would be passing this information to the constructor but$^    then child classes would have to accept constructor arguments and pass$^    them down.$^   $^  stdstring oldtext$^  what.swapoldtext$^  what  file    line$^  if func what   in   func   threw $^  if childname $^    what  childname$^   else $^ifdef gxxrtti$^    what  typeidthis.name$^else$^    what  an exception$^endif$^  $^  if condition $^    what   because   condition  $^  $^  what  .n$^  what  oldtext$^$^$^namespace $^$^ifdef gnuc$^const char handlestrerrorint ret const char buf attribute unused$^const char handlestrerrorconst char ret const char  buf attribute unused$^endif$^ at least one of these functions will not be called.$^ifdef clang$^pragma clang diagnostic push$^pragma clang diagnostic ignored wunusedfunction$^endif$^ the xopen version.$^const char handlestrerrorint ret const char buf $^  if ret return buf$^  return null$^$^$^ the gnu version.$^const char handlestrerrorconst char ret const char  buf $^  return ret$^$^ifdef clang$^pragma clang diagnostic pop$^endif$^  namespace$^$^errnoexceptionerrnoexception throw  errnoerrno $^  char buf000$^  buf0  0$^if definedsun  definedwin00  definedwin00$^  const char add  strerrorerrno$^else$^  const char add  handlestrerrorstrerrorrerrno buf 000 buf$^endif$^$^  if add $^    this  add   $^  $^$^$^errnoexceptionerrnoexception throw $^$^overflowexceptionoverflowexception throw $^overflowexceptionoverflowexception throw $^$^if definedwin00  definedwin00$^windowsexceptionwindowsexception throw $^  unsigned int lasterror  getlasterror$^  char errormsg000  $^  if formatmessageaformatmessagefromsystem  formatmessageignoreinserts null lasterror langneutral errormsg sizeoferrormsg null $^    this  windows error   getlasterror   while formatting windows error   lasterror  . $^   else $^    this  windows error   lasterror     errormsg$^  $^$^windowsexceptionwindowsexception throw $^endif$^$^  namespace util$^include utilpcqueue.hh$^$^define boosttestmodule pcqueuetest$^include boosttestunittest.hpp$^$^namespace util $^namespace $^$^boostautotestcasesinglethread $^  pcqueueint queue00$^  for int i  0 i  00 i $^    queue.producei$^  $^  for int i  0 i  00 i $^    boostcheckequali queue.consume$^  $^$^$^$^  namespace util$^include utilprobinghashtable.hh$^$^include utilmurmurhash.hh$^include utilscoped.hh$^$^define boosttestmodule probinghashtabletest$^include boosttestunittest.hpp$^include boostscopedarray.hpp$^include boostfunctionalhash.hpp$^include cstdio$^include cstdlib$^include cstring$^include stdint.h$^$^namespace util $^namespace $^$^struct entry $^  unsigned char key$^  typedef unsigned char key$^$^  unsigned char getkey const $^    return key$^  $^$^  void setkeyunsigned char to $^    key  to$^  $^$^  uint00t getvalue const $^    return value$^  $^$^  uint00t value$^$^$^typedef probinghashtableentry boosthashunsigned char  table$^$^boostautotestcasesimple $^  sizet size  tablesize00 0.0$^  boostscopedarraychar memnew charsize$^  memsetmem.get 0 size$^$^  table tablemem.get size$^  const entry i  null$^  boostchecktable.find0 i$^  entry toins$^  toins.key  0$^  toins.value  000000$^  table.inserttoins$^  boostrequiretable.find0 i$^  boostcheckequal0 igetkey$^  boostcheckequalstaticcastuint00t000000 igetvalue$^  boostchecktable.find0 i$^$^$^struct entry00 $^  uint00t key$^  typedef uint00t key$^$^  entry00 $^$^  explicit entry00uint00t keyin $^    key  keyin$^  $^$^  key getkey const  return key $^  void setkeyuint00t to  key  to $^$^$^struct murmurhashentry00 $^  stdsizet operatoruint00t value const $^    return utilmurmurhash00avalue 0$^  $^$^$^typedef probinghashtableentry00 murmurhashentry00 table00$^$^boostautotestcasedouble $^  for stdsizet initial  00 initial  00 initial $^    sizet size  table00sizeinitial 0.0$^    scopedmalloc memmallocorthrowsize$^    table00 tablemem.get size stdnumericlimitsuint00tmax$^    table.clear$^    for uint00t i  0 i  00 i $^      table.insertentry00i$^    $^    table.checkconsistency$^    mem.callrealloctable.doubleto$^    table.doublemem.get$^    table.checkconsistency$^    for uint00t i  00 i  00  i $^      table.insertentry00i$^    $^    mem.callrealloctable.doubleto$^    table.doublemem.get$^    table.checkconsistency$^  $^$^$^  namespace$^  namespace util$^include lmwrappersnplm.hh$^include utilexception.hh$^include utilfile.hh$^$^include algorithm$^include cstring$^$^include neurallm.h$^$^namespace lm $^namespace np $^$^vocabularyvocabularyconst nplmvocabulary vocab$^   basevocabularyvocab.lookupwords vocab.lookupwords vocab.lookupwordunk$^    vocabvocab nullwordvocab.lookupwordnull $^$^vocabularyvocabulary $^$^wordindex vocabularyindexconst stdstring str const $^  return vocab.lookupwordstr$^$^$^class backend $^  public$^    backendconst nplmneurallm from const stdsizet cachesize  lmfrom ngramfrom.getorder $^      lm.setcachecachesize$^    $^$^    nplmneurallm lm  return lm $^    const nplmneurallm lm const  return lm $^$^    eigenmatrixinteigendynamic0 stagingngram  return ngram $^$^    double lookupfromstaging  return lm.lookupngramngram $^$^    int order const  return lm.getorder $^$^  private$^    nplmneurallm lm$^    eigenmatrixinteigendynamic0 ngram$^$^$^bool modelrecognizeconst stdstring name $^  try $^    utilscopedfd fileutilopenreadorthrowname.cstr$^    char magiccheck00$^    utilreadorthrowfile.get magiccheck sizeofmagiccheck$^    const char nnlmmagic  confignversion $^    return memcmpmagiccheck nnlmmagic 00$^   catch const utilexception  $^    return false$^  $^$^$^namespace $^nplmneurallm loadnplmconst stdstring file $^  utilscopedptrnplmneurallm retnew nplmneurallm$^  retreadfile$^  return ret.release$^$^  namespace$^$^modelmodelconst stdstring file stdsizet cache$^   baseinstanceloadnplmfile vocabbaseinstancegetvocabulary cachesizecache $^  utilthrowifbaseinstancegetorder  nplmmaxorder utilexception this nplm has order   unsigned intbaseinstancegetorder   but the kenlm wrapper was compiled with   nplmmaxorder  .  change the defintion of nplmmaxorder and recompile.$^   log00 compatible with backoff models.$^  baseinstancesetlogbase00.0$^  state beginsentence nullcontext$^  stdfillbeginsentence.words beginsentence.words  nplmmaxorder  0 baseinstancelookupwords$^  nullword  baseinstancelookupwordnull$^  stdfillnullcontext.words nullcontext.words  nplmmaxorder  0 nullword$^$^  initbeginsentence nullcontext vocab baseinstancegetorder$^$^$^modelmodel $^$^fullscorereturn modelfullscoreconst state from const wordindex newword state outstate const $^  backend backend  backend.get$^  if backend $^    backend  new backendbaseinstance cachesize$^    backend.resetbackend$^  $^   state is in natural word order.$^  fullscorereturn ret$^  for int i  0 i  backendorder  0 i $^    backendstagingngrami  from.wordsi$^  $^  backendstagingngrambackendorder  0  newword$^  ret.prob  backendlookupfromstaging$^   always say full order.$^  ret.ngramlength  backendorder$^   shift everything down by one.$^  memcpyoutstate.words from.words  0 sizeofwordindex  backendorder  0$^  outstate.wordsbackendorder  0  newword$^   fill in trailing words with zeros so state comparison works.$^  memsetoutstate.words  backendorder  0 0 sizeofwordindex  nplmmaxorder  backendorder$^  return ret$^$^$^ todo optimize with direct call$^fullscorereturn modelfullscoreforgotstateconst wordindex contextrbegin const wordindex contextrend const wordindex newword state outstate const $^   state is in natural word order.  the api here specifies reverse order.$^  stdsizet statelength  stdminstdsizetorder  0 contextrend  contextrbegin$^  state state$^   pad with null words.$^  for lmwordindex i  state.words i  state.words  order  0  statelength i $^    i  nullword$^  $^   put new words at the end.$^  stdreversecopycontextrbegin contextrbegin  statelength state.words  order  0  statelength$^  return fullscorestate newword outstate$^$^$^  namespace np$^  namespace lm$^include lmtriesort.hh$^$^include lmconfig.hh$^include lmlmexception.hh$^include lmreadarpa.hh$^include lmvocab.hh$^include lmweights.hh$^include lmwordindex.hh$^include utilfilepiece.hh$^include utilmmap.hh$^include utilpool.hh$^include utilproxyiterator.hh$^include utilsizediterator.hh$^$^include algorithm$^include cstring$^include cstdio$^include cstdlib$^include deque$^include iterator$^include limits$^include vector$^$^namespace lm $^namespace ngram $^namespace trie $^namespace $^$^typedef utilsizediterator ngramiter$^$^ proxy for an entry except there is some extra cruft between the entries.  this is used to sort n0grams using the same memory as the sorted ngrams.$^class partialviewproxy $^  public$^    partialviewproxy  attentionsize0 inner $^$^    partialviewproxyvoid ptr stdsizet blocksize utilfreepool pool  attentionsizepool.elementsize innerptr blocksize poolpool $^$^    operator utilvalueblock const $^      return utilvalueblockinner.data pool$^    $^$^    partialviewproxy operatorconst partialviewproxy from $^      memcpyinner.data from.inner.data attentionsize$^      return this$^    $^$^    partialviewproxy operatorconst utilvalueblock from $^      memcpyinner.data from.data attentionsize$^      return this$^    $^$^    const void data const  return inner.data $^    void data  return inner.data $^$^    friend void swappartialviewproxy first partialviewproxy second$^$^  private$^    friend class utilproxyiteratorpartialviewproxy$^$^    typedef utilvalueblock valuetype$^$^    const stdsizet attentionsize$^$^    typedef utilsizedinneriterator inneriterator$^    inneriterator inner  return inner $^    const inneriterator inner const  return inner $^    inneriterator inner$^$^    utilfreepool pool$^$^$^ifdef clang$^pragma clang diagnostic push$^pragma clang diagnostic ignored wunusedfunction$^endif$^void swappartialviewproxy first partialviewproxy second $^  stdswaprangesreinterpretcastcharfirst.data reinterpretcastcharfirst.data  first.attentionsize reinterpretcastcharsecond.data$^$^ifdef clang$^pragma clang diagnostic pop$^endif$^$^typedef utilproxyiteratorpartialviewproxy partialiter$^$^file diskflushconst void membegin const void memend const stdstring tempprefix $^  utilscopedfd fileutilmaketemptempprefix$^  utilwriteorthrowfile.get membegin uint0tmemend  uint0tmembegin$^  return utilfdopenorthrowfile$^$^$^file writecontextfileuint0t begin uint0t end const stdstring tempprefix stdsizet entrysize unsigned char order $^  const sizet contextsize  sizeofwordindex  order  0$^$^  utilfreepool poolcontextsize$^   sort just the contexts using the same memory.$^  partialiter contextbeginpartialviewproxybegin  sizeofwordindex entrysize pool$^  partialiter contextendpartialviewproxyend  sizeofwordindex entrysize pool$^$^if definedwin00  definedwin00$^  stdstablesort$^else$^  stdsort$^endif$^    contextbegin contextend utilsizedcompareentrycompare partialviewproxyentrycompareorder  0$^$^  utilscopedfile oututilfmaketemptempprefix$^$^   write out to file and uniqueify at the same time.  could have used uniquecopy if there was an appropriate outputiterator.$^  if contextbegin  contextend return out.release$^  partialiter icontextbegin$^  utilwriteorthrowout.get idata contextsize$^  const void previous  idata$^  i$^  for  i  contextend i $^    if memcmpprevious idata contextsize $^      utilwriteorthrowout.get idata contextsize$^      previous  idata$^    $^  $^  return out.release$^$^$^struct throwcombine $^  void operatorstdsizet entrysize unsigned char order const void first const void second file  out const $^    const wordindex base  reinterpretcastconst wordindexfirst$^    formatloadexception e$^    e  duplicate ngram detected with vocab ids$^    for const wordindex i  base i  base  order i $^      e     i$^    $^    throw e$^  $^$^$^ useful for context files that just contain records with no value.$^struct firstcombine $^  void operatorstdsizet entrysize unsigned char order const void first const void  second file out const $^    utilwriteorthrowout first entrysize$^  $^$^$^template class combine file mergesortedfilesfile firstfile file secondfile const stdstring tempprefix stdsizet weightssize unsigned char order const combine combine $^  stdsizet entrysize  sizeofwordindex  order  weightssize$^  recordreader first second$^  first.initfirstfile entrysize$^  second.initsecondfile entrysize$^  utilscopedfile outfileutilfmaketemptempprefix$^  entrycompare lessorder$^  while first  second $^    if lessfirst.data second.data $^      utilwriteorthrowoutfile.get first.data entrysize$^      first$^     else if lesssecond.data first.data $^      utilwriteorthrowoutfile.get second.data entrysize$^      second$^     else $^      combineentrysize order first.data second.data outfile.get$^      first second$^    $^  $^  for recordreader remains  first  first  second remains remains $^    utilwriteorthrowoutfile.get remains.data entrysize$^  $^  return outfile.release$^$^$^  namespace$^$^void recordreaderinitfile file stdsizet entrysize $^  entrysize  entrysize$^  data.resetmallocentrysize$^  utilthrowifdata.get utilerrnoexception failed to malloc read buffer$^  file  file$^  if file $^    rewindfile$^    remains  true$^    this$^   else $^    remains  false$^  $^$^$^void recordreaderoverwriteconst void start stdsizet amount $^  long internal  uint0tstart  uint0tdata.get$^  utilthrowiffseekfile internal  entrysize seekcur utilerrnoexception couldnt seek backwards for revision$^  utilwriteorthrowfile start amount$^  long forward  entrysize  internal  amount$^if definedwin00  definedwin00$^  if forward$^endif$^    utilthrowiffseekfile forward seekcur utilerrnoexception couldnt seek forwards past revision$^$^$^void recordreaderrewind $^  if file $^    rewindfile$^    remains  true$^    this$^   else $^    remains  false$^  $^$^$^sortedfilessortedfilesconst config config utilfilepiece f stdvectoruint00t counts sizet buffer const stdstring fileprefix sortedvocabulary vocab $^  positiveprobwarn warnconfig.positivelogprobability$^  unigram.resetutilmaketempfileprefix$^  $^     in case unk appears.$^    sizet sizeout  counts0  0  sizeofprobbackoff$^    utilscopedmmap unigrammmaputilmapzeroedwriteunigram.get sizeout sizeout$^    read0gramsf counts0 vocab reinterpretcastprobbackoffunigrammmap.get warn$^    checkspecialsconfig vocab$^    if vocab.sawunk counts0$^  $^$^   only use as much buffer as we need.$^  sizet bufferuse  0$^  for unsigned int order  0 order  counts.size order $^    bufferuse  stdmaxsizetbufferuse staticcastsizetsizeofwordindex  order  0  sizeoffloat  countsorder  0$^  $^  bufferuse  stdmaxsizetbufferuse staticcastsizetsizeofwordindex  counts.size  sizeoffloat  counts.back$^  buffer  stdminsizetbuffer bufferuse$^$^  utilscopedmalloc mem$^  mem.resetmallocbuffer$^  if mem.get utilthrowutilerrnoexception malloc failed for sort buffer size   buffer$^$^  for unsigned char order  0 order  counts.size order $^    converttosortedf vocab counts fileprefix order warn mem.get buffer$^  $^  readendf$^$^$^namespace $^class closer $^  public$^    explicit closerstddequefile files  filesfiles $^$^    closer $^      for stddequefileiterator i  files.begin i  files.end i $^        utilscopedfile deleteri$^      $^    $^$^    void popfront $^      utilscopedfile deleterfiles.front$^      files.popfront$^    $^  private$^    stddequefile files$^$^  namespace$^$^void sortedfilesconverttosortedutilfilepiece f const sortedvocabulary vocab const stdvectoruint00t counts const stdstring fileprefix unsigned char order positiveprobwarn warn void mem stdsizet memsize $^  readngramheaderf order$^  const sizet count  countsorder  0$^   size of weights.  does it include backoff$^  const sizet wordssize  sizeofwordindex  order$^  const sizet weightssize  sizeoffloat  order  counts.size  0  sizeoffloat$^  const sizet entrysize  wordssize  weightssize$^  const sizet batchsize  stdmincount memsize  entrysize$^  uint0t const begin  reinterpretcastuint0tmem$^$^  stddequefile files contexts$^  closer filescloserfiles contextsclosercontexts$^$^  for stdsizet batch  0 done  0 done  count batch $^    uint0t out  begin$^    uint0t outend  out  stdmincount  done batchsize  entrysize$^    if order  counts.size $^      for  out  outend out  entrysize $^        stdreverseiteratorwordindex itreinterpretcastwordindexout  order$^        readngramf order vocab it reinterpretcastprobout  wordssize warn$^      $^     else $^      for  out  outend out  entrysize $^        stdreverseiteratorwordindex itreinterpretcastwordindexout  order$^        readngramf order vocab it reinterpretcastprobbackoffout  wordssize warn$^      $^    $^     sort full records by full ngram.$^    utilsizedsortbegin outend entrysize entrycompareorder$^    files.pushbackdiskflushbegin outend fileprefix$^    contexts.pushbackwritecontextfilebegin outend fileprefix entrysize order$^$^    done  outend  begin  entrysize$^  $^$^   all individual files created.  merge them.$^$^  while files.size  0 $^    files.pushbackmergesortedfilesfiles0 files0 fileprefix weightssize order throwcombine$^    filescloser.popfront$^    filescloser.popfront$^    contexts.pushbackmergesortedfilescontexts0 contexts0 fileprefix 0 order  0 firstcombine$^    contextscloser.popfront$^    contextscloser.popfront$^  $^$^  if files.empty $^     steal from closers.$^    fullorder  0.resetfiles.front$^    files.popfront$^    contextorder  0.resetcontexts.front$^    contexts.popfront$^  $^$^$^  namespace trie$^  namespace ngram$^  namespace lm$^include lmlmexception.hh$^$^include cerrno$^include cstdio$^$^namespace lm $^$^configexceptionconfigexception throw $^configexceptionconfigexception throw $^$^loadexceptionloadexception throw $^loadexceptionloadexception throw $^$^formatloadexceptionformatloadexception throw $^formatloadexceptionformatloadexception throw $^$^vocabloadexceptionvocabloadexception throw $^vocabloadexceptionvocabloadexception throw $^$^specialwordmissingexceptionspecialwordmissingexception throw $^specialwordmissingexceptionspecialwordmissingexception throw $^$^  namespace lm$^include lmvaluebuild.hh$^$^include lmmodel.hh$^include lmreadarpa.hh$^$^namespace lm $^namespace ngram $^$^template class model lowerrestbuildmodellowerrestbuildconst config config unsigned int order const typename modelvocabulary vocab $^  utilthrowifconfig.restlowerfiles.size  order  0 configexception this model has order   order   so there should be   order  0   lowerorder models for rest cost purposes.$^  config forlower  config$^  forlower.writemmap  null$^  forlower.restlowerfiles.clear$^$^   unigram models arent supported so this is a custom loader.$^   todo optimize the unigram loading$^  $^    utilfilepiece uniconfig.restlowerfiles0.cstr$^    stdvectoruint00t number$^    readarpacountsuni number$^    utilthrowifnumber.size  0 formatloadexception expected the unigram model to have order 0 not   number.size$^    readngramheaderuni 0$^    unigrams.resizenumber0$^    unigrams0  config.unknownmissinglogprob$^    positiveprobwarn warn$^    for uint00t i  0 i  number0 i $^      wordindex w$^      prob entry$^      readngramuni 0 vocab w entry warn$^      unigramsw  entry.prob$^    $^  $^$^  try $^    for unsigned int i  0 i  order i $^      models.pushbacknew modelconfig.restlowerfilesi  0.cstr forlower$^      utilthrowifmodels.backorder  i formatloadexception lower order file   config.restlowerfilesi0   should have order   i$^    $^   catch ... $^    for typename stdvectorconst modelconstiterator i  models.begin i  models.end i $^      delete i$^    $^    models.clear$^    throw$^  $^$^   todo forcecheck same vocab.$^$^$^template class model lowerrestbuildmodellowerrestbuild $^  for typename stdvectorconst modelconstiterator i  models.begin i  models.end i $^    delete i$^  $^$^$^template class lowerrestbuildprobingmodel$^$^  namespace ngram$^  namespace lm$^include lmbinaryformat.hh$^$^include lmlmexception.hh$^include utilfile.hh$^include utilfilepiece.hh$^$^include cstddef$^include cstring$^include limits$^include string$^include cstdlib$^$^include stdint.h$^$^namespace lm $^namespace ngram $^$^const char kmodelnames0  probing hash tables probing hash tables with rest costs trie trie with quantization trie with arraycompressed pointers trie with quantization and arraycompressed pointers$^$^namespace $^const char kmagicbeforeversion  mmap lm httpkheafield.comcode format version$^const char kmagicbytes  mmap lm httpkheafield.comcode format version 0n0$^ this must be shorter than kmagicbytes and indicates an incomplete binary file i.e. build failed.$^const char kmagicincomplete  mmap lm httpkheafield.comcode incompleten$^const long int kmagicversion  0$^$^ old binary files built on 00bit machines have this header.$^ todo eliminate with next binary release.$^struct oldsanity $^  char magicsizeofkmagicbytes$^  float zerof onef minushalff$^  wordindex onewordindex maxwordindex$^  uint00t oneuint00$^$^  void settoreference $^    stdmemsetthis 0 sizeofoldsanity$^    stdmemcpymagic kmagicbytes sizeofmagic$^    zerof  0.0 onef  0.0 minushalff  0.0$^    onewordindex  0$^    maxwordindex  stdnumericlimitswordindexmax$^    oneuint00  0$^  $^$^$^$^ test values aligned to 0 bytes.$^struct sanity $^  char magicalign0sizeofkmagicbytes$^  float zerof onef minushalff$^  wordindex onewordindex maxwordindex paddingto0$^  uint00t oneuint00$^$^  void settoreference $^    stdmemsetthis 0 sizeofsanity$^    stdmemcpymagic kmagicbytes sizeofkmagicbytes$^    zerof  0.0 onef  0.0 minushalff  0.0$^    onewordindex  0$^    maxwordindex  stdnumericlimitswordindexmax$^    paddingto0  0$^    oneuint00  0$^  $^$^$^stdsizet totalheadersizeunsigned char order $^  return align0sizeofsanity  sizeoffixedwidthparameters  sizeofuint00t  order$^$^$^void writeheadervoid to const parameters params $^  sanity header  sanity$^  header.settoreference$^  stdmemcpyto header sizeofsanity$^  char out  reinterpretcastcharto  sizeofsanity$^$^  reinterpretcastfixedwidthparametersout  params.fixed$^  out  sizeoffixedwidthparameters$^$^  uint00t counts  reinterpretcastuint00tout$^  for stdsizet i  0 i  params.counts.size i $^    countsi  params.countsi$^  $^$^$^  namespace$^$^bool isbinaryformatint fd $^  const uint00t size  utilsizefilefd$^  if size  utilkbadsize  size  staticcastuint00tsizeofsanity return false$^   try reading the header.$^  utilscopedmemory memory$^  try $^    utilmapreadutillazy fd 0 sizeofsanity memory$^   catch const utilexception e $^    return false$^  $^  sanity referenceheader  sanity$^  referenceheader.settoreference$^  if stdmemcmpmemory.get referenceheader sizeofsanity return true$^  if stdmemcmpmemory.get kmagicincomplete strlenkmagicincomplete $^    utilthrowformatloadexception this binary file did not finish building$^  $^  if stdmemcmpmemory.get kmagicbeforeversion strlenkmagicbeforeversion $^    char endptr$^    const char beginversion  staticcastconst charmemory.get  strlenkmagicbeforeversion$^    long int version  stdstrtolbeginversion endptr 00$^    if endptr  beginversion  version  kmagicversion $^      utilthrowformatloadexception binary file has version   version   but this implementation expects version   kmagicversion   so youll have to use the arpa to rebuild your binary$^    $^$^    oldsanity oldsanity  oldsanity$^    oldsanity.settoreference$^    utilthrowifstdmemcmpmemory.get oldsanity sizeofoldsanity formatloadexception looks like this is an old 00bit format.  the old 00bit format has been removed so that 00bit and 00bit files are exchangeable.$^    utilthrowformatloadexception file looks like it should be loaded with mmap but the test values dont match.  try rebuilding the binary format lm using the same code revision compiler and architecture$^  $^  return false$^$^$^void readheaderint fd parameters out $^  utilseekorthrowfd sizeofsanity$^  utilreadorthrowfd out.fixed sizeofout.fixed$^  if out.fixed.probingmultiplier  0.0$^    utilthrowformatloadexception binary format claims to have a probing multiplier of   out.fixed.probingmultiplier   which is  0.0.$^$^  out.counts.resizestaticcaststdsizetout.fixed.order$^  if out.fixed.order utilreadorthrowfd out.counts.begin sizeofuint00t  out.fixed.order$^$^$^void matchcheckmodeltype modeltype unsigned int searchversion const parameters params $^  if params.fixed.modeltype  modeltype $^    if staticcastunsigned intparams.fixed.modeltype  sizeofkmodelnames  sizeofconst char $^      utilthrowformatloadexception the binary file claims to be model type   staticcastunsigned intparams.fixed.modeltype   but this is not implemented for in this inference code.$^    utilthrowformatloadexception the binary file was built for   kmodelnamesparams.fixed.modeltype   but the inference code is trying to load   kmodelnamesmodeltype$^  $^  utilthrowifsearchversion  params.fixed.searchversion formatloadexception the binary file has   kmodelnamesparams.fixed.modeltype   version   params.fixed.searchversion   but this code expects   kmodelnamesparams.fixed.modeltype   version   searchversion$^$^$^const stdsizet kinvalidsize  staticcaststdsizet0$^$^binaryformatbinaryformatconst config config$^   writemethodconfig.writemethod writemmapconfig.writemmap loadmethodconfig.loadmethod$^    headersizekinvalidsize vocabsizekinvalidsize vocabstringoffsetkinvalidoffset $^$^void binaryformatinitializebinaryint fd modeltype modeltype unsigned int searchversion parameters params $^  file.resetfd$^  writemmap  null  ignore write requests this is already in binary format.$^  readheaderfd params$^  matchcheckmodeltype searchversion params$^  headersize  totalheadersizeparams.counts.size$^$^$^void binaryformatreadforconfigvoid to stdsizet amount uint00t offsetexcludingheader const $^  assertheadersize  kinvalidsize$^  utilersatzpreadfile.get to amount offsetexcludingheader  headersize$^$^$^void binaryformatloadbinarystdsizet size $^  assertheadersize  kinvalidsize$^  const uint00t filesize  utilsizefilefile.get$^   the header is smaller than a page so we have to map the whole header as well.$^  uint00t totalmap  staticcastuint00theadersize  staticcastuint00tsize$^  utilthrowiffilesize  utilkbadsize  filesize  totalmap formatloadexception binary file has size   filesize   but the headers say it should be at least   totalmap$^$^  utilmapreadloadmethod file.get 0 utilcheckoverflowtotalmap mapping$^$^  vocabstringoffset  totalmap$^  return reinterpretcastuint0tmapping.get  headersize$^$^$^void binaryformatsetupjustvocabstdsizet memorysize uint0t order $^  vocabsize  memorysize$^  if writemmap $^    headersize  0$^    utilhugemallocmemorysize true memoryvocab$^    return reinterpretcastuint0tmemoryvocab.get$^  $^  headersize  totalheadersizeorder$^  stdsizet total  utilcheckoverflowstaticcastuint00theadersize  staticcastuint00tmemorysize$^  file.resetutilcreateorthrowwritemmap$^   some gccs complain about uninitialized variables even though all enum values are covered.$^  void vocabbase  null$^  switch writemethod $^    case configwritemmap$^      mapping.resetutilmapzeroedwritefile.get total total utilscopedmemorymmapallocated$^      utiladvisehugepagesvocabbase total$^      vocabbase  mapping.get$^      break$^    case configwriteafter$^      utilresizeorthrowfile.get 0$^      utilhugemalloctotal true memoryvocab$^      vocabbase  memoryvocab.get$^      break$^  $^  strncpyreinterpretcastcharvocabbase kmagicincomplete headersize$^  return reinterpretcastuint0tvocabbase  headersize$^$^$^void binaryformatgrowforsearchstdsizet memorysize stdsizet vocabpad void vocabbase $^  assertvocabsize  kinvalidsize$^  vocabpad  vocabpad$^  stdsizet newsize  headersize  vocabsize  vocabpad  memorysize$^  vocabstringoffset  newsize$^  if writemmap  writemethod  configwriteafter $^    utilhugemallocmemorysize true memorysearch$^    assertheadersize  0  writemmap$^    vocabbase  reinterpretcastuint0tmemoryvocab.get  headersize$^    utiladvisehugepagesmemorysearch.get memorysize$^    return reinterpretcastuint0tmemorysearch.get$^  $^$^  assertwritemethod  configwritemmap$^   also known as total size without vocab words.$^   grow the file to accomodate the search using zeros.$^   according to man mmap behavior is undefined when the file is resized$^   underneath a mmap that is not a multiple of the page size.  so to be$^   safe well unmap it and map it again.$^  mapping.reset$^  utilresizeorthrowfile.get newsize$^  void ret$^  mapfilevocabbase ret$^  utiladvisehugepagesret newsize$^  return ret$^$^$^void binaryformatwritevocabwordsconst stdstring buffer void vocabbase void searchbase $^   checking configs includevocab is the responsibility of the caller.$^  assertheadersize  kinvalidsize  vocabsize  kinvalidsize$^  if writemmap $^     unchanged base.$^    vocabbase  reinterpretcastuint0tmemoryvocab.get$^    searchbase  reinterpretcastuint0tmemorysearch.get$^    return$^  $^  if writemethod  configwritemmap $^    mapping.reset$^  $^  utilseekorthrowfile.get vocabstringreadingoffset$^  utilwriteorthrowfile.get buffer0 buffer.size$^  if writemethod  configwritemmap $^    mapfilevocabbase searchbase$^   else $^    vocabbase  reinterpretcastuint0tmemoryvocab.get  headersize$^    searchbase  reinterpretcastuint0tmemorysearch.get$^  $^$^$^void binaryformatfinishfileconst config config modeltype modeltype unsigned int searchversion const stdvectoruint00t counts $^  if writemmap return$^  switch writemethod $^    case configwritemmap$^      utilsyncorthrowmapping.get mapping.size$^      break$^    case configwriteafter$^      utilseekorthrowfile.get 0$^      utilwriteorthrowfile.get memoryvocab.get memoryvocab.size$^      utilseekorthrowfile.get headersize  vocabsize  vocabpad$^      utilwriteorthrowfile.get memorysearch.get memorysearch.size$^      utilfsyncorthrowfile.get$^      break$^  $^   header and vocab share the same mmap.$^  parameters params  parameters$^  memsetparams 0 sizeofparameters$^  params.counts  counts$^  params.fixed.order  counts.size$^  params.fixed.probingmultiplier  config.probingmultiplier$^  params.fixed.modeltype  modeltype$^  params.fixed.hasvocabulary  config.includevocab$^  params.fixed.searchversion  searchversion$^  switch writemethod $^    case configwritemmap$^      writeheadermapping.get params$^      utilsyncorthrowmapping.get mapping.size$^      break$^    case configwriteafter$^      $^        stdvectoruint0t buffertotalheadersizecounts.size$^        writeheaderbuffer0 params$^        utilseekorthrowfile.get 0$^        utilwriteorthrowfile.get buffer0 buffer.size$^      $^      break$^  $^$^$^void binaryformatmapfilevoid vocabbase void searchbase $^  mapping.resetutilmaporthrowvocabstringoffset true utilkfileflags false file.get vocabstringoffset utilscopedmemorymmapallocated$^  vocabbase  reinterpretcastuint0tmapping.get  headersize$^  searchbase  reinterpretcastuint0tmapping.get  headersize  vocabsize  vocabpad$^$^$^bool recognizebinaryconst char file modeltype recognized $^  utilscopedfd fdutilopenreadorthrowfile$^  if isbinaryformatfd.get $^    return false$^  $^  parameters params$^  readheaderfd.get params$^  recognized  params.fixed.modeltype$^  return true$^$^$^  namespace ngram$^  namespace lm$^include lmtrie.hh$^$^include lmbhiksha.hh$^include utilbitpacking.hh$^include utilexception.hh$^include utilsorteduniform.hh$^$^include cassert$^$^namespace lm $^namespace ngram $^namespace trie $^namespace $^$^class keyaccessor $^  public$^    keyaccessorconst void base uint00t keymask uint0t keybits uint0t totalbits$^       basereinterpretcastconst uint0tbase keymaskkeymask keybitskeybits totalbitstotalbits $^$^    typedef uint00t key$^$^    key operatoruint00t index const $^      return utilreadint00base index  staticcastuint00ttotalbits keybits keymask$^    $^$^  private$^    const uint0t const base$^    const wordindex keymask$^    const uint0t keybits totalbits$^$^$^bool findbitpackedconst void base uint00t keymask uint0t keybits uint0t totalbits uint00t beginindex uint00t endindex const uint00t maxvocab const uint00t key uint00t atindex $^  keyaccessor accessorbase keymask keybits totalbits$^  if utilboundedsorteduniformfinduint00t keyaccessor utilpivotselectsizeofwordindextaccessor beginindex  0 uint00t0 endindex maxvocab key atindex return false$^  return true$^$^  namespace$^$^uint00t bitpackedbasesizeuint00t entries uint00t maxvocab uint0t remainingbits $^  uint0t totalbits  utilrequiredbitsmaxvocab  remainingbits$^   extra entry for next pointer at the end.$^   0 then  0 to round up bits and convert to bytes$^   sizeofuint00t so that readint00 etc dont go segfault.$^   note that this waste is oorder not onumber of ngrams.$^  return 0  entries  totalbits  0  0  sizeofuint00t$^$^$^void bitpackedbaseinitvoid base uint00t maxvocab uint0t remainingbits $^  utilbitpackingsanity$^  wordbits  utilrequiredbitsmaxvocab$^  wordmask  0ull  wordbits  0ull$^  if wordbits  00 utilthrowutilexception sorry word indices more than   0ull  00   are not implemented.  edit utilbitpacking.hh and fix the bit packing functions.$^  totalbits  wordbits  remainingbits$^$^  base  staticcastuint0tbase$^  insertindex  0$^  maxvocab  maxvocab$^$^$^template class bhiksha uint00t bitpackedmiddlebhikshasizeuint0t quantbits uint00t entries uint00t maxvocab uint00t maxptr const config config $^  return bhikshasizeentries  0 maxptr config  basesizeentries maxvocab quantbits  bhikshainlinebitsentries  0 maxptr config$^$^$^template class bhiksha bitpackedmiddlebhikshabitpackedmiddlevoid base uint0t quantbits uint00t entries uint00t maxvocab uint00t maxnext const bitpacked nextsource const config config $^  bitpacked$^  quantbitsquantbits$^   if the offset of the method changes also change triesearchupdateconfigfrombinary.$^  bhikshabase entries  0 maxnext config$^  nextsourcenextsource $^  if entries  0  0ull  00  maxnext  0ull  00  utilthrowutilexception sorry this does not support more than   0ull  00   ngrams of a particular order.  edit utilbitpacking.hh and fix the bit packing functions.$^  baseinitreinterpretcastuint0tbase  bhikshasizeentries  0 maxnext config maxvocab quantbits  bhiksha.inlinebits$^$^$^template class bhiksha utilbitaddress bitpackedmiddlebhikshainsertwordindex word $^  assertword  wordmask$^  uint00t atpointer  insertindex  totalbits$^$^  utilwriteint00base atpointer wordbits word$^  atpointer  wordbits$^  utilbitaddress retbase atpointer$^  atpointer  quantbits$^  uint00t next  nextsourceinsertindex$^  bhiksha.writenextbase atpointer insertindex next$^  insertindex$^  return ret$^$^$^template class bhiksha utilbitaddress bitpackedmiddlebhikshafindwordindex word noderange range uint00t pointer const $^  uint00t atpointer$^  if findbitpackedbase wordmask wordbits totalbits range.begin range.end maxvocab word atpointer $^    return utilbitaddressnull 0$^  $^  pointer  atpointer$^  atpointer  totalbits$^  atpointer  wordbits$^  bhiksha.readnextbase atpointer  quantbits pointer totalbits range$^$^  return utilbitaddressbase atpointer$^$^$^template class bhiksha void bitpackedmiddlebhikshafinishedloadinguint00t nextend const config config $^   write at insertindex. . .$^  uint00t lastnextwrite  insertindex  totalbits $^     at the offset where the next pointers are stored.$^    totalbits  bhiksha.inlinebits$^  bhiksha.writenextbase lastnextwrite insertindex nextend$^  bhiksha.finishedloadingconfig$^$^$^utilbitaddress bitpackedlongestinsertwordindex index $^  assertindex  wordmask$^  uint00t atpointer  insertindex  totalbits$^  utilwriteint00base atpointer wordbits index$^  atpointer  wordbits$^  insertindex$^  return utilbitaddressbase atpointer$^$^$^utilbitaddress bitpackedlongestfindwordindex word const noderange range const $^  uint00t atpointer$^  if findbitpackedbase wordmask wordbits totalbits range.begin range.end maxvocab word atpointer return utilbitaddressnull 0$^  atpointer  atpointer  totalbits  wordbits$^  return utilbitaddressbase atpointer$^$^$^template class bitpackedmiddledontbhiksha$^template class bitpackedmiddlearraybhiksha$^$^  namespace trie$^  namespace ngram$^  namespace lm$^include lmbhiksha.hh$^$^include lmbinaryformat.hh$^include lmconfig.hh$^include utilfile.hh$^include utilexception.hh$^$^include limits$^$^namespace lm $^namespace ngram $^namespace trie $^$^dontbhikshadontbhikshaconst void  base uint00t maxoffset uint00t maxnext const config config $^  nextutilbitsmaskbymaxmaxnext $^$^const uint0t karraybhikshaversion  0$^$^ todo put this in binary file header instead when i change the binary file format again.$^void arraybhikshaupdateconfigfrombinaryconst binaryformat file uint00t offset config config $^  uint0t buffer0$^  file.readforconfigbuffer 0 offset$^  uint0t version  buffer0$^  uint0t configuredbits  buffer0$^  if version  karraybhikshaversion utilthrowformatloadexception this file has sorted array compression version   unsigned version   but the code expects version   unsignedkarraybhikshaversion$^  config.pointerbhikshabits  configuredbits$^$^$^namespace $^$^ find argminchopped in 0 requiredbitsmaxnext choppeddeltamaxoffset$^uint0t chopbitsuint00t maxoffset uint00t maxnext const config config $^  uint0t required  utilrequiredbitsmaxnext$^  uint0t bestchop  0$^  int00t lowestchange  stdnumericlimitsint00tmax$^   there are probably faster ways but i dont care because this is only done once per order at construction time.$^  for uint0t chop  0 chop  stdminrequired config.pointerbhikshabits chop $^    int00t change  maxnext  required  chop  00  table cost in bits $^       maxoffset  staticcastint00tchop  savings in bits$^    if change  lowestchange $^      lowestchange  change$^      bestchop  chop$^    $^  $^  return bestchop$^$^$^stdsizet arraycountuint00t maxoffset uint00t maxnext const config config $^  uint0t required  utilrequiredbitsmaxnext$^  uint0t chopping  chopbitsmaxoffset maxnext config$^  return maxnext  required  chopping  0  we store 0 too $^$^  namespace$^$^uint00t arraybhikshasizeuint00t maxoffset uint00t maxnext const config config $^  return sizeofuint00t  0  header   arraycountmaxoffset maxnext config  0  0byte alignment $^$^$^uint0t arraybhikshainlinebitsuint00t maxoffset uint00t maxnext const config config $^  return utilrequiredbitsmaxnext  chopbitsmaxoffset maxnext config$^$^$^namespace $^$^void alignto0void from $^  uint0t val  reinterpretcastuint0tfrom$^  stdsizet remainder  reinterpretcaststdsizetval  0$^  if remainder return val$^  return val  0  remainder$^$^$^  namespace$^$^arraybhikshaarraybhikshavoid base uint00t maxoffset uint00t maxnext const config config$^   nextinlineutilbitsmaskbybitsinlinebitsmaxoffset maxnext config$^    offsetbeginreinterpretcastconst uint00talignto0base  0  0byte header $^    offsetendoffsetbegin  arraycountmaxoffset maxnext config$^    writetoreinterpretcastuint00talignto0base  0  0byte header   0  first entry is 0 $^    originalbasebase $^$^void arraybhikshafinishedloadingconst config config $^   offsetbegin  0 but without a constcast.$^  writeto  writeto  offsetbegin  0$^$^  if writeto  offsetend utilthrowutilexception did not get all the array entries that were expected.$^$^  uint0t headwrite  reinterpretcastuint0toriginalbase$^  headwrite  karraybhikshaversion$^  headwrite  config.pointerbhikshabits$^$^$^  namespace trie$^  namespace ngram$^  namespace lm$^include lmmodel.hh$^$^include lmblank.hh$^include lmlmexception.hh$^include lmsearchhashed.hh$^include lmsearchtrie.hh$^include lmreadarpa.hh$^include utilhave.hh$^include utilmurmurhash.hh$^$^include algorithm$^include functional$^include numeric$^include cmath$^include limits$^$^namespace lm $^namespace ngram $^namespace detail $^$^template class search class vocabularyt const modeltype genericmodelsearch vocabularytkmodeltype  searchkmodeltype$^$^template class search class vocabularyt uint00t genericmodelsearch vocabularytsizeconst stdvectoruint00t counts const config config $^  return vocabularytsizecounts0 config  searchsizecounts config$^$^$^template class search class vocabularyt void genericmodelsearch vocabularytsetupmemoryvoid base const stdvectoruint00t counts const config config $^  sizet goalsize  utilcheckoverflowsizecounts config$^  uint0t start  staticcastuint0tbase$^  sizet allocated  vocabularytsizecounts0 config$^  vocab.setupmemorystart allocated counts0 config$^  start  allocated$^  start  search.setupmemorystart counts config$^  if staticcaststdsizetstart  staticcastuint0tbase  goalsize utilthrowformatloadexception the data structures took   start  staticcastuint0tbase   but size says they should take   goalsize$^$^$^namespace $^void complainaboutarpaconst config config modeltype modeltype $^  if config.writemmap  config.messages return$^  if config.arpacomplain  configall $^    config.messages  loading the lm will be faster if you build a binary file.  stdendl$^   else if config.arpacomplain  configexpensive $^             modeltype  trie  modeltype  quanttrie  modeltype  arraytrie  modeltype  quantarraytrie $^    config.messages  building   kmodelnamesmodeltype   from arpa is expensive.  save time by building a binary format.  stdendl$^  $^$^$^void checkcountsconst stdvectoruint00t counts $^  utilthrowifcounts.size  kenlmmaxorder formatloadexception this model has order   counts.size   but kenlm was compiled to support up to   kenlmmaxorder  .    kenlmordermessage$^  if sizeofuint00t  sizeofstdsizet $^    for stdvectoruint00tconstiterator i  counts.begin i  counts.end i $^      utilthrowifi  staticcastuint00tstdnumericlimitssizetmax utiloverflowexception this model has   i     i  counts.begin  0  grams which is too many for 00bit machines.$^    $^  $^$^$^  namespace$^$^template class search class vocabularyt genericmodelsearch vocabularytgenericmodelconst char file const config initconfig  backinginitconfig $^  utilscopedfd fdutilopenreadorthrowfile$^  if isbinaryformatfd.get $^    parameters parameters$^    int fdshallow  fd.release$^    backing.initializebinaryfdshallow kmodeltype kversion parameters$^    checkcountsparameters.counts$^$^    config newconfiginitconfig$^    newconfig.probingmultiplier  parameters.fixed.probingmultiplier$^    searchupdateconfigfrombinarybacking parameters.counts vocabularytsizeparameters.counts0 newconfig newconfig$^    utilthrowifnewconfig.enumeratevocab  parameters.fixed.hasvocabulary formatloadexception the decoder requested all the vocabulary strings but this binary file does not have them.  you may need to rebuild the binary file with an updated version of buildbinary.$^$^    setupmemorybacking.loadbinarysizeparameters.counts newconfig parameters.counts newconfig$^    vocab.loadedbinaryparameters.fixed.hasvocabulary fdshallow newconfig.enumeratevocab backing.vocabstringreadingoffset$^   else $^    complainaboutarpainitconfig kmodeltype$^    initializefromarpafd.release file initconfig$^  $^$^   g prints warnings unless these are fully initialized.$^  state beginsentence  state$^  beginsentence.length  0$^  beginsentence.words0  vocab.beginsentence$^  typename searchnode ignorednode$^  bool ignoredindependentleft$^  uint00t ignoredextendleft$^  beginsentence.backoff0  search.lookupunigrambeginsentence.words0 ignorednode ignoredindependentleft ignoredextendleft.backoff$^  state nullcontext  state$^  nullcontext.length  0$^  pinitbeginsentence nullcontext vocab search.order$^$^$^template class search class vocabularyt void genericmodelsearch vocabularytinitializefromarpaint fd const char file const config config $^   backing file is the arpa.$^  utilfilepiece ffd file config.progressmessages$^  try $^    stdvectoruint00t counts$^     file counts do not include pruned trigrams that extend to quadgrams etc.   these will be fixed by search.$^    readarpacountsf counts$^    checkcountscounts$^    if counts.size  0 utilthrowformatloadexception this ngram implementation assumes at least a bigram model.$^    if config.probingmultiplier  0.0 utilthrowconfigexception probing multiplier must be  0.0$^$^    stdsizet vocabsize  utilcheckoverflowvocabularytsizecounts0 config$^     setup the binary file for writing the vocab lookup table.  the search is responsible for growing the binary file to its needs.$^    vocab.setupmemorybacking.setupjustvocabvocabsize counts.size vocabsize counts0 config$^$^    if config.writemmap  config.includevocab $^      writewordswrapper wrapconfig.enumeratevocab$^      vocab.configureenumeratewrap counts0$^      search.initializefromarpafile f counts config vocab backing$^      void vocabrebase searchrebase$^      backing.writevocabwordswrap.buffer vocabrebase searchrebase$^       due to writing at the end of file mmap may have relocated data.  so remap.$^      vocab.relocatevocabrebase$^      search.setupmemoryreinterpretcastuint0tsearchrebase counts config$^     else $^      vocab.configureenumerateconfig.enumeratevocab counts0$^      search.initializefromarpafile f counts config vocab backing$^    $^$^    if vocab.sawunk $^      assertconfig.unknownmissing  throwup$^       default probabilities for unknown.$^      search.unknownunigram.backoff  0.0$^      search.unknownunigram.prob  config.unknownmissinglogprob$^    $^    backing.finishfileconfig kmodeltype kversion counts$^   catch utilexception e $^    e   byte   f.offset$^    throw$^  $^$^$^template class search class vocabularyt fullscorereturn genericmodelsearch vocabularytfullscoreconst state instate const wordindex newword state outstate const $^  fullscorereturn ret  scoreexceptbackoffinstate.words instate.words  instate.length newword outstate$^  for const float i  instate.backoff  ret.ngramlength  0 i  instate.backoff  instate.length i $^    ret.prob  i$^  $^  return ret$^$^$^template class search class vocabularyt fullscorereturn genericmodelsearch vocabularytfullscoreforgotstateconst wordindex contextrbegin const wordindex contextrend const wordindex newword state outstate const $^  contextrend  stdmincontextrend contextrbegin  porder  0$^  fullscorereturn ret  scoreexceptbackoffcontextrbegin contextrend newword outstate$^$^   add the backoff weights for ngrams of order start to contextrend  contextrbegin.$^  unsigned char start  ret.ngramlength$^  if contextrend  contextrbegin  staticcaststdptrdifftstart return ret$^$^  bool independentleft$^  uint00t extendleft$^  typename searchnode node$^  if start  0 $^    ret.prob  search.lookupunigramcontextrbegin node independentleft extendleft.backoff$^    start  0$^   else if search.fastmakenodecontextrbegin contextrbegin  start  0 node $^    return ret$^  $^   i is the order of the backoff were looking for.$^  unsigned char orderminus0  start  0$^  for const wordindex i  contextrbegin  start  0 i  contextrend i orderminus0 $^    typename searchmiddlepointer psearch.lookupmiddleorderminus0 i node independentleft extendleft$^    if p.found break$^    ret.prob  p.backoff$^  $^  return ret$^$^$^template class search class vocabularyt void genericmodelsearch vocabularytgetstateconst wordindex contextrbegin const wordindex contextrend state outstate const $^   generate a state from context.$^  contextrend  stdmincontextrend contextrbegin  porder  0$^  if contextrend  contextrbegin $^    outstate.length  0$^    return$^  $^  typename searchnode node$^  bool independentleft$^  uint00t extendleft$^  outstate.backoff0  search.lookupunigramcontextrbegin node independentleft extendleft.backoff$^  outstate.length  hasextensionoutstate.backoff0  0  0$^  float backoffout  outstate.backoff  0$^  unsigned char orderminus0  0$^  for const wordindex i  contextrbegin  0 i  contextrend i backoffout orderminus0 $^    typename searchmiddlepointer psearch.lookupmiddleorderminus0 i node independentleft extendleft$^    if p.found $^      stdcopycontextrbegin contextrbegin  outstate.length outstate.words$^      return$^    $^    backoffout  p.backoff$^    if hasextensionbackoffout outstate.length  i  contextrbegin  0$^  $^  stdcopycontextrbegin contextrbegin  outstate.length outstate.words$^$^$^template class search class vocabularyt fullscorereturn genericmodelsearch vocabularytextendleft$^    const wordindex addrbegin const wordindex addrend$^    const float backoffin$^    uint00t extendpointer$^    unsigned char extendlength$^    float backoffout$^    unsigned char nextuse const $^  fullscorereturn ret$^  typename searchnode node$^  if extendlength  0 $^    typename searchunigrampointer ptrsearch.lookupunigramstaticcastwordindexextendpointer node ret.independentleft ret.extendleft$^    ret.rest  ptr.rest$^    ret.prob  ptr.prob$^    assertret.independentleft$^   else $^    typename searchmiddlepointer ptrsearch.unpackextendpointer extendlength node$^    ret.rest  ptr.rest$^    ret.prob  ptr.prob$^    ret.extendleft  extendpointer$^     if this function is called then it does depend on left words.$^    ret.independentleft  false$^  $^  float subtractme  ret.rest$^  ret.ngramlength  extendlength$^  nextuse  extendlength$^  resumescoreaddrbegin addrend extendlength  0 node backoffout nextuse ret$^  nextuse  extendlength$^   charge backoffs.$^  for const float b  backoffin  ret.ngramlength  extendlength b  backoffin  addrend  addrbegin b ret.prob  b$^  ret.prob  subtractme$^  ret.rest  subtractme$^  return ret$^$^$^template class search class vocabularyt uint00t genericmodelsearch vocabularytgetendofsearchoffset const $^  return backing.vocabstringreadingoffset$^$^$^namespace $^ do a paraonoid copy of history assuming newword has already been copied$^ hence the 0.  outstate.length could be zero so i avoided using$^ stdcopy.$^void copyremaininghistoryconst wordindex from state outstate $^  wordindex out  outstate.words  0$^  const wordindex inend  from  staticcastptrdifftoutstate.length  0$^  for const wordindex in  from in  inend in out out  in$^$^  namespace$^$^ ugly optimized function.  produce a score excluding backoff.$^  the search goes in increasing order of ngram length.$^  context goes backward so contextbegin is the word immediately preceeding$^  newword.$^ $^template class search class vocabularyt fullscorereturn genericmodelsearch vocabularytscoreexceptbackoff$^    const wordindex const contextrbegin$^    const wordindex const contextrend$^    const wordindex newword$^    state outstate const $^  assertnewword  vocab.bound$^  fullscorereturn ret$^   ret.ngramlength contains the last known nonblank ngram length.$^  ret.ngramlength  0$^$^  typename searchnode node$^  typename searchunigrampointer unisearch.lookupunigramnewword node ret.independentleft ret.extendleft$^  outstate.backoff0  uni.backoff$^  ret.prob  uni.prob$^  ret.rest  uni.rest$^$^   this is the length of the context that should be used for continuation to the right.$^  outstate.length  hasextensionoutstate.backoff0  0  0$^   well write the word anyway since it will probably be used and does no harm being there.$^  outstate.words0  newword$^  if contextrbegin  contextrend return ret$^$^  resumescorecontextrbegin contextrend 0 node outstate.backoff  0 outstate.length ret$^  copyremaininghistorycontextrbegin outstate$^  return ret$^$^$^template class search class vocabularyt void genericmodelsearch vocabularytresumescoreconst wordindex histiter const wordindex const contextrend unsigned char orderminus0 typename searchnode node float backoffout unsigned char nextuse fullscorereturn ret const $^  for   orderminus0 histiter backoffout $^    if histiter  contextrend return$^    if ret.independentleft return$^    if orderminus0  porder  0 break$^$^    typename searchmiddlepointer pointersearch.lookupmiddleorderminus0 histiter node ret.independentleft ret.extendleft$^    if pointer.found return$^    backoffout  pointer.backoff$^    ret.prob  pointer.prob$^    ret.rest  pointer.rest$^    ret.ngramlength  orderminus0  0$^    if hasextensionbackoffout $^      nextuse  ret.ngramlength$^    $^  $^  ret.independentleft  true$^  typename searchlongestpointer longestsearch.lookuplongesthistiter node$^  if longest.found $^    ret.prob  longest.prob$^    ret.rest  ret.prob$^     there is no blank in longest.$^    ret.ngramlength  porder$^  $^$^$^template class search class vocabularyt float genericmodelsearch vocabularytinternalunrestconst uint00t pointersbegin const uint00t pointersend unsigned char firstlength const $^  float ret$^  typename searchnode node$^  if firstlength  0 $^    if pointersbegin  pointersend return 0.0$^    bool independentleft$^    uint00t extendleft$^    typename searchunigrampointer ptrsearch.lookupunigramstaticcastwordindexpointersbegin node independentleft extendleft$^    ret  ptr.prob  ptr.rest$^    firstlength$^    pointersbegin$^   else $^    ret  0.0$^  $^  for const uint00t i  pointersbegin i  pointersend i firstlength $^    typename searchmiddlepointer ptrsearch.unpacki firstlength node$^    ret  ptr.prob  ptr.rest$^  $^  return ret$^$^$^template class genericmodelhashedsearchbackoffvalue probingvocabulary$^template class genericmodelhashedsearchrestvalue probingvocabulary$^template class genericmodeltrietriesearchdontquantize triedontbhiksha sortedvocabulary$^template class genericmodeltrietriesearchdontquantize triearraybhiksha sortedvocabulary$^template class genericmodeltrietriesearchseparatelyquantize triedontbhiksha sortedvocabulary$^template class genericmodeltrietriesearchseparatelyquantize triearraybhiksha sortedvocabulary$^$^  namespace detail$^$^basemodel loadvirtualconst char filename const config config modeltype modeltype $^  recognizebinaryfilename modeltype$^  switch modeltype $^    case probing$^      return new probingmodelfilename config$^    case restprobing$^      return new restprobingmodelfilename config$^    case trie$^      return new triemodelfilename config$^    case quanttrie$^      return new quanttriemodelfilename config$^    case arraytrie$^      return new arraytriemodelfilename config$^    case quantarraytrie$^      return new quantarraytriemodelfilename config$^    default$^      utilthrowformatloadexception confused by model type   modeltype$^  $^$^$^  namespace ngram$^  namespace lm$^include lmngramquery.hh$^include utilgetopt.hh$^$^ifdef withnplm$^include lmwrappersnplm.hh$^endif$^$^include stdlib.h$^$^void usageconst char name $^  stdcerr $^    kenlm was compiled with maximum order   kenlmmaxorder  .n$^    usage   name   b n w s lmfilen$^    b do not buffer output.n$^    n do not wrap the input in s and s.n$^    v summarysentenceword level of verbosityn$^    l lazypopulatereadparallel load lazily with populate or mallocreadn$^    the default loading method is populate on linux and read on others.nn$^    each word in the output is formatted asn$^      wordvocabid ngramlength log00pwordcontextn$^    where ngramlength is the length of ngram matched.  a vocabid of 0 indicatesn$^    the unknown word. sentencelevel output includes log00 probability of then$^    sentence and oov count.n$^  exit0$^$^$^int mainint argc char argv $^  if argc  0  argc  0  strcmpargv0 help$^    usageargv0$^$^  lmngramconfig config$^  bool sentencecontext  true$^  unsigned int verbosity  0$^  bool flush  false$^$^  int opt$^  while opt  getoptargc argv bnvl  0 $^    switch opt $^      case b$^        flush  true$^        break$^      case n$^        sentencecontext  false$^        break$^      case v$^        if strcmpoptarg word  strcmpoptarg 0 $^          verbosity  0$^         else if strcmpoptarg sentence  strcmpoptarg 0 $^          verbosity  0$^         else if strcmpoptarg summary  strcmpoptarg 0 $^          verbosity  0$^         else $^          usageargv0$^        $^        break$^      case l$^        if strcmpoptarg lazy $^          config.loadmethod  utillazy$^         else if strcmpoptarg populate $^          config.loadmethod  utilpopulateorread$^         else if strcmpoptarg read $^          config.loadmethod  utilread$^         else if strcmpoptarg parallel $^          config.loadmethod  utilparallelread$^         else $^          usageargv0$^        $^        break$^      case h$^      default$^        usageargv0$^    $^  $^  if optind  0  argc$^    usageargv0$^  lmngramqueryprinter printer0 verbosity  0 verbosity  0 true flush$^  const char file  argvoptind$^  try $^    using namespace lmngram$^    modeltype modeltype$^    if recognizebinaryfile modeltype $^      stdcerr  this binary file contains   lmngramkmodelnamesmodeltype  .  stdendl$^      switchmodeltype $^        case probing$^          querylmngramprobingmodelfile config sentencecontext printer$^          break$^        case restprobing$^          querylmngramrestprobingmodelfile config sentencecontext printer$^          break$^        case trie$^          querytriemodelfile config sentencecontext printer$^          break$^        case quanttrie$^          queryquanttriemodelfile config sentencecontext printer$^          break$^        case arraytrie$^          queryarraytriemodelfile config sentencecontext printer$^          break$^        case quantarraytrie$^          queryquantarraytriemodelfile config sentencecontext printer$^          break$^        default$^          stdcerr  unrecognized kenlm model type   modeltype  stdendl$^          abort$^      $^ifdef withnplm$^     else if lmnpmodelrecognizefile $^      lmnpmodel modelfile$^      querylmnpmodel lmngramqueryprintermodel sentencecontext printer$^      querylmnpmodel lmngramqueryprintermodel sentencecontext printer$^endif$^     else $^      queryprobingmodelfile config sentencecontext printer$^    $^    utilprintusagestdcerr$^   catch const stdexception e $^    stdcerr  e.what  stdendl$^    return 0$^  $^  return 0$^$^include lmleft.hh$^include lmmodel.hh$^$^include utiltokenizepiece.hh$^$^include vector$^$^define boosttestmodule lefttest$^include boosttestunittest.hpp$^include boosttestfloatingpointcomparison.hpp$^$^namespace lm $^namespace ngram $^namespace $^$^define termword score.terminalm.getvocabulary.indexword$^define vcheckword value boostcheckequalm.getvocabulary.indexword value$^$^ apparently some boost versions use templates and are pretty strict about types matching.$^define sloppycheckcloseref value tol boostcheckclosestaticcastdoubleref staticcastdoublevalue staticcastdoubletol$^$^template class m void shortconst m m $^  chartstate base$^  $^    rulescorem scorem base$^    termmore$^    termloin$^    sloppycheckclose0.000000  0.0000000 score.finish 0.000$^  $^  boostcheckbase.left.full$^  boostcheckequal0 base.left.length$^  boostcheckequal0 base.right.length$^  vcheckloin base.right.words0$^$^  chartstate moreleft$^  $^    rulescorem scorem moreleft$^    termlittle$^    score.nonterminalbase 0.000000  0.0000000$^     plittle more loin  null context$^    sloppycheckclose0.00000 score.finish 0.000$^  $^  boostcheckequal0 moreleft.left.length$^  boostcheckequal0 moreleft.right.length$^  vcheckloin moreleft.right.words0$^  boostcheckmoreleft.left.full$^$^  chartstate shorter$^  $^    rulescorem scorem shorter$^    termto$^    score.nonterminalbase 0.000000  0.0000000$^    sloppycheckclose0.00000  0.000000  0.000000  0.0000000 score.finish 0.00$^  $^  boostcheckequal0 shorter.left.length$^  boostcheckequal0 shorter.right.length$^  vcheckloin shorter.right.words0$^  boostcheckshorter.left.full$^$^$^template class m void chargeconst m m $^  chartstate base$^  $^    rulescorem scorem base$^    termon$^    termmore$^    sloppycheckclose0.000000 0.0000000 0.000000 score.finish 0.000$^  $^  boostcheckequal0 base.left.length$^  boostcheckequal0 base.right.length$^  vcheckmore base.right.words0$^  boostcheckbase.left.full$^$^  chartstate extend$^  $^    rulescorem scorem extend$^    termlooking$^    score.nonterminalbase 0.000000 0.0000000 0.000000$^    sloppycheckclose0.00000 score.finish 0.000$^  $^  boostcheckequal0 extend.left.length$^  boostcheckequal0 extend.right.length$^  vcheckmore extend.right.words0$^  boostcheckextend.left.full$^$^  chartstate tobos$^  $^    rulescorem scorem tobos$^    score.beginsentence$^    score.nonterminalextend 0.00000$^    sloppycheckclose0.000000 score.finish 0.000$^  $^  boostcheckequal0 tobos.left.length$^  boostcheckequal0 tobos.right.length$^$^$^template class m float lefttorightconst m m const stdvectorwordindex words bool beginsentence  false $^  float ret  0.0$^  state right  beginsentence  m.beginsentencestate  m.nullcontextstate$^  for stdvectorwordindexconstiterator i  words.begin i  words.end i $^    state copyright$^    ret  m.scorecopy i right$^  $^  return ret$^$^$^template class m float righttoleftconst m m const stdvectorwordindex words bool beginsentence  false $^  float ret  0.0$^  chartstate state$^  state.left.length  0$^  state.right.length  0$^  state.left.full  false$^  for stdvectorwordindexconstreverseiterator i  words.rbegin i  words.rend i $^    chartstate copystate$^    rulescorem scorem state$^    score.terminali$^    score.nonterminalcopy ret$^    ret  score.finish$^  $^  if beginsentence $^    chartstate copystate$^    rulescorem scorem state$^    score.beginsentence$^    score.nonterminalcopy ret$^    ret  score.finish$^  $^  return ret$^$^$^template class m float treemiddleconst m m const stdvectorwordindex words bool beginsentence  false $^  stdvectorstdpairchartstate float  stateswords.size$^  for unsigned int i  0 i  words.size i $^    rulescorem scorem statesi.first$^    score.terminalwordsi$^    statesi.second  score.finish$^  $^  while states.size  0 $^    stdvectorstdpairchartstate float  upperstates.size  0  0$^    for unsigned int i  0 i  states.size  0 i $^      rulescorem scorem upperi.first$^      score.nonterminalstatesi0.first statesi0.second$^      score.nonterminalstatesi00.first statesi00.second$^      upperi.second  score.finish$^    $^    if states.size  0 $^      upper.back  states.back$^    $^    stdswapstates upper$^  $^$^  if states.empty return 0.0$^$^  if beginsentence $^    chartstate ignored$^    rulescorem scorem ignored$^    score.beginsentence$^    score.nonterminalstates.front.first states.front.second$^    return score.finish$^   else $^    return states.front.second$^  $^$^$^$^template class m void lookupvocabconst m m const stringpiece str stdvectorwordindex out $^  out.clear$^  for utiltokeniterutilsinglecharacter true istr   i i $^    out.pushbackm.getvocabulary.indexi$^  $^$^$^define textteststr $^  lookupvocabm str words $^  expect  lefttorightm words rest $^  sloppycheckcloseexpect righttoleftm words rest 0.000 $^  sloppycheckcloseexpect treemiddlem words rest 0.000 $^$^ build sentences or parts thereof from right to left.$^template class m void growbigconst m m bool rest  false $^  stdvectorwordindex words$^  float expect$^  texttestin biarritz watching considering looking . on a little more loin also would consider higher to look good unknown the screening foo bar  unknown however unknown s$^  textteston a little more loin also would consider higher to look good unknown the screening foo bar  unknown however unknown s$^  textteston a little more loin also would consider higher to look good$^  texttestmore loin also would consider higher to look good$^  texttestmore loin also would consider higher to look$^  texttestalso would consider higher to look$^  texttestalso would consider higher$^  texttestwould consider higher to look$^  texttestconsider higher to look$^  texttestconsider higher to$^  texttestconsider higher$^$^$^template class m void growsmallconst m m bool rest  false $^  stdvectorwordindex words$^  float expect$^  texttestin biarritz watching considering looking . s$^  texttestin biarritz watching considering looking .$^  texttestin biarritz$^$^$^template class m void alsowouldconsiderhigherconst m m $^  chartstate also$^  $^    rulescorem scorem also$^    score.terminalm.getvocabulary.indexalso$^    sloppycheckclose0.000000 score.finish 0.000$^  $^  chartstate would$^  $^    rulescorem scorem would$^    score.terminalm.getvocabulary.indexwould$^    sloppycheckclose0.000000 score.finish 0.000$^  $^  chartstate combinealsowould$^  $^    rulescorem scorem combinealsowould$^    score.nonterminalalso 0.000000$^    score.nonterminalwould 0.000000$^    sloppycheckclose0.000000  0.0 score.finish 0.000$^  $^  boostcheckequal0 combinealsowould.right.length$^$^  chartstate alsowould$^  $^    rulescorem scorem alsowould$^    score.terminalm.getvocabulary.indexalso$^    score.terminalm.getvocabulary.indexwould$^    sloppycheckclose0.000000  0.0 score.finish 0.000$^  $^  boostcheckequal0 alsowould.right.length$^$^  chartstate consider$^  $^    rulescorem scorem consider$^    score.terminalm.getvocabulary.indexconsider$^    sloppycheckclose0.000000 score.finish 0.000$^  $^  boostcheckequal0 consider.left.length$^  boostcheckequal0 consider.right.length$^  boostcheckconsider.left.full$^$^  chartstate higher$^  float higherscore$^  $^    rulescorem scorem higher$^    score.terminalm.getvocabulary.indexhigher$^    higherscore  score.finish$^  $^  sloppycheckclose0.000000 higherscore 0.000$^  boostcheckequal0 higher.left.length$^  boostcheckequal0 higher.right.length$^  boostcheckhigher.left.full$^  vcheckhigher higher.right.words0$^  sloppycheckclose0.00000 higher.right.backoff0 0.000$^$^  chartstate considerhigher$^  $^    rulescorem scorem considerhigher$^    score.nonterminalconsider 0.000000$^    score.nonterminalhigher higherscore$^    sloppycheckclose0.000000  0.000000  0.00000 score.finish 0.000$^  $^  boostcheckequal0 considerhigher.left.length$^  boostcheckconsiderhigher.left.full$^$^  chartstate full$^  $^    rulescorem scorem full$^    score.nonterminalcombinealsowould 0.000000  0.0$^    score.nonterminalconsiderhigher 0.000000  0.000000  0.00000$^    sloppycheckclose00.0000 score.finish 0.000$^  $^  boostcheckequal0 full.right.length$^$^$^define checkscorestr val $^ $^  float got  val $^  stdvectorwordindex indices $^  lookupvocabm str indices $^  sloppycheckcloselefttorightm indices got 0.000 $^$^$^template class m void fullgrowconst m m $^  stdvectorwordindex words$^  lookupvocabm in biarritz watching considering looking . s words$^$^  chartstate lexical0$^  float lexicalscores0$^  for unsigned int i  0 i  0 i $^    rulescorem scorem lexicali$^    score.terminalwordsi$^    lexicalscoresi  score.finish$^  $^  checkscorein lexicalscores0$^  checkscorebiarritz lexicalscores0$^  checkscorewatching lexicalscores0$^  checkscores lexicalscores0$^$^  chartstate l00$^  float l0scores0$^  $^    rulescorem scorem l00$^    score.nonterminallexical0 lexicalscores0$^    score.nonterminallexical0 lexicalscores0$^    checkscorein biarritz l0scores0  score.finish$^  $^  $^    rulescorem scorem l00$^    score.nonterminallexical0 lexicalscores0$^    score.nonterminallexical0 lexicalscores0$^    checkscorewatching considering l0scores0  score.finish$^  $^  $^    rulescorem scorem l00$^    score.nonterminallexical0 lexicalscores0$^    score.nonterminallexical0 lexicalscores0$^    checkscorelooking . l0scores0  score.finish$^  $^  boostcheckequall00.left.length 0$^  l00  lexical0$^  l0scores0  lexicalscores0$^$^  chartstate l00$^  float l0scores0$^  $^    rulescorem scorem l00$^    score.nonterminall00 l0scores0$^    score.nonterminall00 l0scores0$^    checkscorein biarritz watching considering l0scores0  score.finish$^  $^  $^    rulescorem scorem l00$^    score.nonterminall00 l0scores0$^    score.nonterminall00 l0scores0$^    checkscorelooking . s l0scores0  score.finish$^  $^  boostcheckequall00.left.length 0$^  boostcheckl00.left.full$^$^  chartstate top$^  $^    rulescorem scorem top$^    score.nonterminall00 l0scores0$^    score.nonterminall00 l0scores0$^    checkscorein biarritz watching considering looking . s score.finish$^  $^$^$^const char filelocation $^  if boostunittestframeworkmastertestsuite.argc  0 $^    return test.arpa$^  $^  return boostunittestframeworkmastertestsuite.argv0$^$^$^template class m void everything $^  config config$^  config.messages  null$^  m mfilelocation config$^$^  shortm$^  chargem$^  growbigm$^  alsowouldconsiderhigherm$^  growsmallm$^  fullgrowm$^$^$^boostautotestcaseprobingall $^  everythingmodel$^$^boostautotestcasetrieall $^  everythingtriemodel$^$^boostautotestcasequanttrieall $^  everythingquanttriemodel$^$^boostautotestcasearrayquanttrieall $^  everythingquantarraytriemodel$^$^boostautotestcasearraytrieall $^  everythingarraytriemodel$^$^$^boostautotestcaserestprobing $^  config config$^  config.messages  null$^  restprobingmodel mfilelocation config$^  growbigm true$^$^$^  namespace$^  namespace ngram$^  namespace lm$^include lmreadarpa.hh$^$^include lmblank.hh$^include utilfile.hh$^$^include cmath$^include cstdlib$^include iostream$^include sstream$^include vector$^$^include cctype$^include cstring$^include stdint.h$^$^ifdef win00$^include float.h$^endif$^$^namespace lm $^$^ 0 for t n r and  .  this is stricter than isspace.  apparently arpa allows vertical tab inside a word.$^const bool karpaspaces000  0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000$^$^namespace $^$^bool isentirelywhitespaceconst stringpiece line $^  for sizet i  0 i  staticcastsizetline.size i $^    if isspaceline.datai return false$^  $^  return true$^$^$^const char kbinarymagic  mmap lm httpkheafield.comcode$^$^ strtoull isnt portable enough $^uint00t readcountconst stdstring from $^  stdstringstream streamfrom$^  uint00t ret$^  stream  ret$^  utilthrowifstream formatloadexception bad count   from$^  return ret$^$^$^  namespace$^$^void readarpacountsutilfilepiece in stdvectoruint00t number $^  number.clear$^  stringpiece line  in.readline$^   in general arpa files can have arbitrary text before data$^   but in kenlm we require such lines to start with  so that$^   we can do stricter error checking$^  while isentirelywhitespaceline  startswithline  $^    line  in.readline$^  $^$^  if line  data $^    if line.size  0  line.data0  0x0f  staticcastunsigned charline.data0  0x0b $^      utilthrowformatloadexception looks like a gzip file.  if this is an arpa file pipe   in.filename   through zcat.  if this already in binary format you need to decompress it because mmap doesnt work on top of gzip.$^    $^    if staticcastsizetline.size  strlenkbinarymagic  stringpieceline.data strlenkbinarymagic  kbinarymagic$^      utilthrowformatloadexception this looks like a binary file but got sent to the arpa parser.  did you compress the binary file or pass a binary file where only arpa files are accepted$^    utilthrowifline.size  0  stringpieceline.data 0  blmt formatloadexception this looks like an irstlm binary file.  did you forget to pass text yes to compilelm$^    utilthrowifline  iarpa formatloadexception this looks like an irstlm iarpa file.  you need an arpa file.  runn  compilelm text yes   in.filename     in.filename  .arpanfirst.$^    utilthrowformatloadexception first nonempty line was   line   not data.$^  $^  while isentirelywhitespaceline  in.readline $^    if line.size  0  strncmpline.data ngram  0 utilthrowformatloadexception count line   line  doesnt begin with ngram $^     so strtol doesnt go off the end of line.$^    stdstring remainingline.data  0 line.size  0$^    char endptr$^    unsigned int length  stdstrtolremaining.cstr endptr 00$^    if endptr  remaining.cstr  length  0  number.size utilthrowformatloadexception ngram count lengths should be consecutive starting with 0   line$^    if endptr   utilthrowformatloadexception expected  immediately following the first number in the count line   line$^    endptr$^    number.pushbackreadcountendptr$^  $^$^$^void readngramheaderutilfilepiece in unsigned int length $^   stringpiece line$^  while isentirelywhitespaceline  in.readline $^  stdstringstream expected$^  expected    length  grams$^  if line  expected.str utilthrowformatloadexception was expecting ngram header   expected.str   but got   line   instead$^$^$^void consumenewlineutilfilepiece in $^  char follow  in.get$^  utilthrowifn  follow formatloadexception expected newline got   follow  $^$^$^void readbackoffutilfilepiece in prob weights $^  switch in.get $^    case t$^      $^        float got  in.readfloat$^        if got  0.0$^          utilthrowformatloadexception nonzero backoff   got   provided for an ngram that should have no backoff$^      $^      break$^    case r$^      consumenewlinein$^       intentionally no break.$^    case n$^      break$^    default$^      utilthrowformatloadexception expected tab or newline for backoff$^  $^$^$^void readbackoffutilfilepiece in float backoff $^   always make zero negative.$^   negative zero means that no n0gram has this ngram as context.$^   therefore the hypothesis state can be shorter.  of course many ngrams$^   are context for n0grams.  an algorithm in the data structure will go$^   back and set the backoff to positive zero in these cases.$^  switch in.get $^    case t$^      backoff  in.readfloat$^      if backoff  ngramkextensionbackoff backoff  ngramknoextensionbackoff$^      $^if definedwin00  definedmingw00$^int floatclass  fpclassbackoff$^        utilthrowiffloatclass  fpclasssnan  floatclass  fpclassqnan  floatclass  fpclassninf  floatclass  fpclasspinf formatloadexception bad backoff   backoff$^else$^        int floatclass  stdfpclassifybackoff$^        utilthrowiffloatclass  fpnan  floatclass  fpinfinite formatloadexception bad backoff   backoff$^endif$^      $^      switch char got  in.get $^        case r$^          consumenewlinein$^        case n$^          break$^        default$^          utilthrowformatloadexception expected newline after backoffs got   got$^      $^      break$^    case r$^      consumenewlinein$^       intentionally no break.$^    case n$^      backoff  ngramknoextensionbackoff$^      break$^    default$^      utilthrowformatloadexception expected tab or newline for backoff$^  $^$^$^void readendutilfilepiece in $^  stringpiece line$^  do $^    line  in.readline$^   while isentirelywhitespaceline$^  if line  end utilthrowformatloadexception expected end but the arpa file has   line$^$^  try $^    while true $^      line  in.readline$^      if isentirelywhitespaceline utilthrowformatloadexception trailing line   line$^    $^   catch const utilendoffileexception e $^$^$^void positiveprobwarnwarnfloat prob $^  switch action $^    case throwup$^      utilthrowformatloadexception positive log probability   prob   in the model.  this is a bug in irstlm you can set config.positivelogprobability  silent or pass i to buildbinary to substitute 0.0 for the log probability.  error$^    case complain$^      stdcerr  theres a positive log probability   prob   in the apra file probably because of a bug in irstlm.  this and subsequent entires will be mapped to 0 log probability.  stdendl$^      action  silent$^      break$^    case silent$^      break$^  $^$^$^  namespace lm$^include lmsearchhashed.hh$^$^include lmbinaryformat.hh$^include lmblank.hh$^include lmlmexception.hh$^include lmmodel.hh$^include lmreadarpa.hh$^include lmvalue.hh$^include lmvocab.hh$^$^include utilbitpacking.hh$^include utilfilepiece.hh$^$^include string$^$^namespace lm $^namespace ngram $^$^class probingmodel$^$^namespace $^$^ these are passed to readngrams so that ngrams with zero backoff that appear as context will still be used in state. $^template class middle class activatelowermiddle $^  public$^    explicit activatelowermiddlemiddle middle  modifymiddle $^$^    void operatorconst wordindex vocabids const unsigned int n $^      uint00t hash  staticcastwordindexvocabids0$^      for const wordindex i  vocabids  0 i  vocabids  n i $^        hash  detailcombinewordhashhash i$^      $^      typename middlemutableiterator i$^       todo somehow get text of ngram for this error message.$^      if modify.unsafemutablefindhash i$^        utilthrowformatloadexception the context of every   n  gram should appear as a   n0  gram$^      setextensionivalue.backoff$^    $^$^  private$^    middle modify$^$^$^template class weights class activateunigram $^  public$^    explicit activateunigramweights unigram  modifyunigram $^$^    void operatorconst wordindex vocabids const unsigned int n $^       assertn  0$^      setextensionmodifyvocabids0.backoff$^    $^$^  private$^    weights modify$^$^$^ find the lower order entry inserting blanks along the way as necessary.$^template class value void findlower$^    const stdvectoruint00t keys$^    typename valueweights unigram$^    stdvectorutilprobinghashtabletypename valueprobingentry utilidentityhash  middle$^    stdvectortypename valueweights  between $^  typename utilprobinghashtabletypename valueprobingentry utilidentityhashmutableiterator iter$^  typename valueprobingentry entry$^   backoff will always be 0.0.  well get the probability and rest in another pass.$^  entry.value.backoff  knoextensionbackoff$^   go back and find the longest rightaligned entry informing it that it extends left.  normally this will match immediately but sometimes sri is dumb.$^  for int lower  keys.size  0  lower $^    if lower  0 $^      between.pushbackunigram$^      return$^    $^    entry.key  keyslower$^    bool found  middlelower.findorinsertentry iter$^    between.pushbackitervalue$^    if found return$^  $^$^$^ between usually has  single entry the value to adjust.  but sometimes sri stupidly pruned entries so it has unitialized blank values to be set here.$^template class added class build void adjustlower$^    const added added$^    const build build$^    stdvectortypename buildvalueweights  between$^    const unsigned int n$^    const stdvectorwordindex vocabids$^    typename buildvalueweights unigrams$^    stdvectorutilprobinghashtabletypename buildvalueprobingentry utilidentityhash  middle $^  typedef typename buildvalue value$^  if between.size  0 $^    build.markextendsbetween.front added$^    return$^  $^  typedef utilprobinghashtabletypename valueprobingentry utilidentityhash middle$^  float prob  fabsbetween.backprob$^   order of the ngram on which probabilities are based.$^  unsigned char basis  n  between.size$^  assertbasis  0$^  typename buildvalueweights change  between.back$^   skip the basis.$^  change$^  if basis  0 $^     hallucinate a bigram based on a unigrams backoff and a unigram probability.$^    float backoff  unigramsvocabids0.backoff$^    setextensionbackoff$^    prob  backoff$^    changeprob  prob$^    build.setrestvocabids.begin 0 change$^    basis  0$^    change$^  $^  uint00t backoffhash  staticcastuint00tvocabids0$^  for unsigned char i  0 i  basis i $^    backoffhash  detailcombinewordhashbackoffhash vocabidsi$^  $^  for  basis  n  0 basis change $^    typename middlemutableiterator gotit$^    if middlebasis  0.unsafemutablefindbackoffhash gotit $^      float backoff  gotitvalue.backoff$^      setextensionbackoff$^      prob  backoff$^    $^    changeprob  prob$^    build.setrestvocabids.begin basis  0 change$^    backoffhash  detailcombinewordhashbackoffhash vocabidsbasis0$^  $^$^  typename stdvectortypename valueweights constiterator ibetween.begin$^  build.markextendsi added$^  const typename valueweights longer  i$^   everything has probability but is not marked as extending.$^  for i i  between.end i $^    build.markextendsi longer$^    longer  i$^  $^$^$^ continue marking lower entries even they know that they extend left.  this is used for upperlower bounds.$^template class build void marklower$^    const stdvectoruint00t keys$^    const build build$^    typename buildvalueweights unigram$^    stdvectorutilprobinghashtabletypename buildvalueprobingentry utilidentityhash  middle$^    int startorder$^    const typename buildvalueweights longer $^  if startorder  0 return$^   hopefully the compiler will realize that if markextends always returns false it can simplify this code.$^  for int evenlower  startorder  0  index in middle   evenlower $^    if evenlower  0 $^      build.markextendsunigram longer$^      return$^    $^    if build.markextends$^          middleevenlower.unsafemutablemustfindkeysevenlowervalue$^          longer return$^  $^$^$^template class build class activate class store void readngrams$^    utilfilepiece f$^    const unsigned int n$^    const sizet count$^    const probingvocabulary vocab$^    const build build$^    typename buildvalueweights unigrams$^    stdvectorutilprobinghashtabletypename buildvalueprobingentry utilidentityhash  middle$^    activate activate$^    store store$^    positiveprobwarn warn $^  typedef typename buildvalue value$^  assertn  0$^  readngramheaderf n$^$^   both vocabids and keys are nonempty because n  0.$^   vocab ids of words in reverse order.$^  stdvectorwordindex vocabidsn$^  stdvectoruint00t keysn0$^  typename storeentry entry$^  stdvectortypename valueweights  between$^  for sizet i  0 i  count i $^    readngramf n vocab vocabids.rbegin entry.value warn$^    build.setrestvocabids.begin n entry.value$^$^    keys0  detailcombinewordhashstaticcastuint00tvocabids.front vocabids0$^    for unsigned int h  0 h  n  0 h $^      keysh  detailcombinewordhashkeysh0 vocabidsh0$^    $^     initially the sign bit is on indicating it does not extend left.  most already have this but there might 0.0.$^    utilsetsignentry.value.prob$^    entry.key  keysn0$^$^    store.insertentry$^    between.clear$^    findlowervaluekeys unigramsvocabids.front middle between$^    adjustlowertypename storeentryvalue buildentry.value build between n vocabids unigrams middle$^    if buildkmarkevenlower marklowerbuildkeys build unigramsvocabids.front middle n  between.size  0 between.back$^    activatevocabids.begin n$^  $^$^  store.finishedinserting$^$^$^  namespace$^namespace detail $^$^template class value uint0t hashedsearchvaluesetupmemoryuint0t start const stdvectoruint00t counts const config config $^  unigram  unigramstart counts0$^  start  unigramsizecounts0$^  stdsizet allocated$^  middle.clear$^  for unsigned int n  0 n  counts.size n $^    allocated  middlesizecountsn  0 config.probingmultiplier$^    middle.pushbackmiddlestart allocated$^    start  allocated$^  $^  allocated  longestsizecounts.back config.probingmultiplier$^  longest  longeststart allocated$^  start  allocated$^  return start$^$^$^template class value void hashedsearchvaluerelocateuint0t start const stdvectoruint00t counts const config config $^  unigram  unigramstart counts0$^  start  unigramsizecounts0$^  for unsigned int n  0 n  counts.size n $^    middlen0.relocatestart$^    start  middlesizecountsn  0 config.probingmultiplier$^  $^  longest.relocatestart$^$^$^template class value void hashedsearchvalueinitializefromarpaconst char  file utilfilepiece f const stdvectoruint00t counts const config config probingvocabulary vocab binaryformat backing $^  void vocabrebase$^  void searchbase  backing.growforsearchsizecounts config vocab.unkcountchangepadding vocabrebase$^  vocab.relocatevocabrebase$^  setupmemoryreinterpretcastuint0tsearchbase counts config$^$^  positiveprobwarn warnconfig.positivelogprobability$^  read0gramsf counts0 vocab unigram.raw warn$^  checkspecialsconfig vocab$^  dispatchbuildf counts config vocab warn$^$^$^template  void hashedsearchbackoffvaluedispatchbuildutilfilepiece f const stdvectoruint00t counts const config config const probingvocabulary vocab positiveprobwarn warn $^  norestbuild build$^  applybuildf counts vocab warn build$^$^$^template  void hashedsearchrestvaluedispatchbuildutilfilepiece f const stdvectoruint00t counts const config config const probingvocabulary vocab positiveprobwarn warn $^  switch config.restfunction $^    case configrestmax$^      $^        maxrestbuild build$^        applybuildf counts vocab warn build$^      $^      break$^    case configrestlower$^      $^        lowerrestbuildprobingmodel buildconfig counts.size vocab$^        applybuildf counts vocab warn build$^      $^      break$^  $^$^$^template class value template class build void hashedsearchvalueapplybuildutilfilepiece f const stdvectoruint00t counts const probingvocabulary vocab positiveprobwarn warn const build build $^  for wordindex i  0 i  counts0 i $^    build.setresti unsigned int0 unigram.rawi$^  $^$^  try $^    if counts.size  0 $^      readngramsbuild activateunigramtypename valueweights middle$^          f 0 counts0 vocab build unigram.raw middle activateunigramtypename valueweightsunigram.raw middle0 warn$^    $^    for unsigned int n  0 n  counts.size n $^      readngramsbuild activatelowermiddlemiddle middle$^          f n countsn0 vocab build unigram.raw middle activatelowermiddlemiddlemiddlen0 middlen0 warn$^    $^    if counts.size  0 $^      readngramsbuild activatelowermiddlemiddle longest$^          f counts.size countscounts.size  0 vocab build unigram.raw middle activatelowermiddlemiddlemiddle.back longest warn$^     else $^      readngramsbuild activateunigramtypename valueweights longest$^          f counts.size countscounts.size  0 vocab build unigram.raw middle activateunigramtypename valueweightsunigram.raw longest warn$^    $^   catch utilprobingsizeexception e $^    utilthrowutilprobingsizeexception avoid pruning ngrams like bar baz quux when foo bar baz quux is still in the model.  kenlm will work when this pruning happens but the probing model assumes these events are rare enough that using blank space in the probing hash table will cover all of them.  increase probingmultiplier p to buildbinary to add more blank spaces.n$^  $^  readendf$^$^$^template class hashedsearchbackoffvalue$^template class hashedsearchrestvalue$^$^  namespace detail$^  namespace ngram$^  namespace lm$^include lmmodel.hh$^include lmsizes.hh$^include utilfilepiece.hh$^include utilusage.hh$^$^include algorithm$^include cstdlib$^include exception$^include iostream$^include iomanip$^include limits$^include cmath$^$^ifdef win00$^include utilgetopt.hh$^else$^include unistd.h$^endif$^$^namespace lm $^namespace ngram $^namespace $^$^void usageconst char name const char defaultmem $^  stdcerr  usage   name   u log00unknownprobability s i v w mmapafter p probingmultiplier t trietemporary s triebuildingmem q bits b bits a bits type input.arpa output.mmapnn$^u sets the log00 probability for unk if the arpa file does not have one.n$^   default is 000.  the arpa file will always take precedence.n$^s allows models to be built even if they do not have s and s.n$^i allows buggy models from irstlm by mapping positive log probability to 0.n$^v disables inclusion of the vocabulary in the binary file.n$^w mmapafter determines how writing is done.n$^   mmap maps the binary file and writes to it.  default for trie.n$^   after allocates anonymous memory builds and writes.  default for probing.n$^r order0.arpa order0 order0 order0 adds lowerorder rest costs from thesen$^   model files.  order0.arpa must be an arpa file.  all others may be arpa orn$^   the same data structure as being built.  all files must have the samen$^   vocabulary.  for probing the unigrams must be in the same order.nn$^type is either probing or trie.  default is probing.nn$^probing uses a probing hash table.  it is the fastest but uses the most memory.n$^p sets the space multiplier and must be 0.0.  the default is 0.0.nn$^trie is a straightforward trie with bitlevel packing.  it uses the leastn$^memory and is still faster than sri or irst.  building the trie format uses ann$^ondisk sort to save memory.n$^t is the temporary directory prefix.  default is the output file name.n$^s determines memory use for sorting.  default is   defaultmem  .  this is compatiblen$^   with gnu sort.  the number is followed by a unit  for percent of physicaln$^   memory b for bytes k for kilobytes m for megabytes then gtpezy.  n$^   default unit is k for kilobytes.n$^q turns quantization on and sets the number of bits e.g. q 0.n$^b sets backoff quantization bits.  requires q and defaults to that value.n$^a compresses pointers using an array of offsets.  the parameter is then$^   maximum number of bits encoded by the array.  memory is minimized subjectn$^   to the maximum so pick 000 to minimize memory.nn$^h print this help message.nn$^get a memory estimate by passing an arpa file without an output file name.n$^  exit0$^$^$^ i could really use boostlexicalcast right about now.$^float parsefloatconst char from $^  char end$^  float ret  strtodfrom end$^  if end throw utilparsenumberexceptionfrom$^  return ret$^$^unsigned long int parseuintconst char from $^  char end$^  unsigned long int ret  strtoulfrom end 00$^  if end throw utilparsenumberexceptionfrom$^  return ret$^$^$^uint0t parsebitcountconst char from $^  unsigned long val  parseuintfrom$^  if val  00 $^    utilparsenumberexception efrom$^    e   bit counts are limited to 00.$^  $^  return val$^$^$^void parsefilelistconst char from stdvectorstdstring to $^  to.clear$^  while true $^    const char i$^    for i  from i  i    i $^    to.pushbackstdstringfrom i  from$^    if i break$^    from  i  0$^  $^$^$^void probingquantizationunsupported $^  stdcerr  quantization is only implemented in the trie data structure.  stdendl$^  exit0$^$^$^  namespace ngram$^  namespace lm$^  namespace$^$^int mainint argc char argv $^  using namespace lmngram$^$^  const char defaultmem  utilguessphysicalmemory  00  0g$^$^  if argc  0  strcmpargv0 help$^    usageargv0 defaultmem$^$^  try $^    bool quantize  false setbackoffbits  false bhiksha  false setwritemethod  false rest  false$^    lmngramconfig config$^    config.buildingmemory  utilparsesizedefaultmem$^    int opt$^    while opt  getoptargc argv qbaupttmswsirvh  0 $^      switchopt $^        case q$^          config.probbits  parsebitcountoptarg$^          if setbackoffbits config.backoffbits  config.probbits$^          quantize  true$^          break$^        case b$^          config.backoffbits  parsebitcountoptarg$^          setbackoffbits  true$^          break$^        case a$^          config.pointerbhikshabits  parsebitcountoptarg$^          bhiksha  true$^          break$^        case u$^          config.unknownmissinglogprob  parsefloatoptarg$^          break$^        case p$^          config.probingmultiplier  parsefloatoptarg$^          break$^        case t  legacy$^        case t$^          config.temporarydirectoryprefix  optarg$^          utilnormalizetempprefixconfig.temporarydirectoryprefix$^          break$^        case m  legacy$^          config.buildingmemory  parseuintoptarg  0000000$^          break$^        case s$^          config.buildingmemory  stdminstaticcastuint00tstdnumericlimitsstdsizetmax utilparsesizeoptarg$^          break$^        case w$^          setwritemethod  true$^          if strcmpoptarg mmap $^            config.writemethod  configwritemmap$^           else if strcmpoptarg after $^            config.writemethod  configwriteafter$^           else $^            usageargv0 defaultmem$^          $^          break$^        case s$^          config.sentencemarkermissing  lmsilent$^          break$^        case i$^          config.positivelogprobability  lmsilent$^          break$^        case r$^          rest  true$^          parsefilelistoptarg config.restlowerfiles$^          config.restfunction  configrestlower$^          break$^        case v$^          config.includevocab  false$^          break$^        case h  help$^        default$^          usageargv0 defaultmem$^      $^    $^    if quantize  setbackoffbits $^      stdcerr  you specified backoff quantization b but not probability quantization q  stdendl$^      abort$^    $^    if optind  0  argc $^      showsizesargvoptind config$^      return 0$^    $^    const char modeltype$^    const char fromfile$^$^    if optind  0  argc $^      modeltype  probing$^      fromfile  argvoptind$^      config.writemmap  argvoptind  0$^     else if optind  0  argc $^      modeltype  argvoptind$^      fromfile  argvoptind  0$^      config.writemmap  argvoptind  0$^     else $^      usageargv0 defaultmem$^      return 0$^    $^    if strcmpmodeltype probing $^      if setwritemethod config.writemethod  configwriteafter$^      if quantize  setbackoffbits probingquantizationunsupported$^      if rest $^        restprobingmodelfromfile config$^       else $^        probingmodelfromfile config$^      $^     else if strcmpmodeltype trie $^      if rest $^        stdcerr  rest  trie is not supported yet.  stdendl$^        return 0$^      $^      if setwritemethod config.writemethod  configwritemmap$^      if quantize $^        if bhiksha $^          quantarraytriemodelfromfile config$^         else $^          quanttriemodelfromfile config$^        $^       else $^        if bhiksha $^          arraytriemodelfromfile config$^         else $^          triemodelfromfile config$^        $^      $^     else $^      usageargv0 defaultmem$^    $^  $^  catch const stdexception e $^    stdcerr  e.what  stdendl$^    stdcerr  error  stdendl$^    return 0$^  $^  stdcerr  success  stdendl$^  return 0$^$^include lmcommonrenumber.hh$^include lmcommonngram.hh$^$^include utilstreamstream.hh$^$^namespace lm $^$^void renumberrunconst utilstreamchainposition position $^  for utilstreamstream streamposition stream stream $^    ngramheader gramstream.get order$^    for wordindex w  gram.begin w  gram.end w $^      w  newnumbersw$^    $^  $^$^$^  namespace lm$^include lmcommonmodelbuffer.hh$^$^include lmcommoncompare.hh$^include lmstate.hh$^include lmweights.hh$^include utilexception.hh$^include utilfilestream.hh$^include utilfile.hh$^include utilfilepiece.hh$^include utilstreamio.hh$^include utilstreammultistream.hh$^$^include boostlexicalcast.hpp$^$^include numeric$^$^namespace lm $^$^namespace $^const char kmetadataheader  kenlm intermediate binary file$^  namespace$^$^modelbuffermodelbufferstringpiece filebase bool keepbuffer bool outputq$^   filebasefilebase.data filebase.size keepbufferkeepbuffer outputqoutputq$^    vocabfilekeepbuffer  utilcreateorthrowfilebase  .vocab.cstr  utilmaketempfilebase $^$^modelbuffermodelbufferstringpiece filebase$^   filebasefilebase.data filebase.size keepbufferfalse $^  const stdstring fullname  filebase  .kenlmintermediate$^  utilfilepiece infullname.cstr$^  stringpiece token  in.readline$^  utilthrowif0token  kmetadataheader file   fullname   begins with   token   not   kmetadataheader$^$^  token  in.readdelimited$^  utilthrowif0token  counts expected counts got   token   in   fullname$^  char got$^  while got  in.get    $^    counts.pushbackin.readulong$^  $^  utilthrowif0got  n expected newline at end of counts.$^$^  token  in.readdelimited$^  utilthrowif0token  payload expected payload got   token   in   fullname$^  token  in.readdelimited$^  if token  q $^    outputq  true$^   else if token  pb $^    outputq  false$^   else $^    utilthrowutilexception unknown payload   token$^  $^$^  vocabfile.resetutilopenreadorthrowfilebase  .vocab.cstr$^$^  files.initcounts.size$^  for unsigned long i  0 i  counts.size i $^    files.pushbackutilopenreadorthrowfilebase  .  boostlexicalcaststdstringi  0.cstr$^  $^$^$^void modelbuffersinkutilstreamchains chains const stdvectoruint00t counts $^  counts  counts$^   open files.$^  files.initchains.size$^  for stdsizet i  0 i  chains.size i $^    if keepbuffer $^      files.pushbackutilcreateorthrow$^            filebase  .  boostlexicalcaststdstringi  0.cstr$^            $^     else $^      files.pushbackutilmaketempfilebase$^    $^    chainsi  utilstreamwritefiles.back.get$^  $^  if keepbuffer $^    utilscopedfd metadatautilcreateorthrowfilebase  .kenlmintermediate.cstr$^    utilfilestream metametadata.get 000$^    meta  kmetadataheader  ncounts$^    for stdvectoruint00tconstiterator i  counts.begin i  counts.end i $^      meta     i$^    $^    meta  npayload   outputq  q  pb  n$^  $^$^$^void modelbuffersourceutilstreamchains chains $^  assertchains.size  files.size$^  for unsigned int i  0 i  chains.size i $^    chainsi.setprogresstargetutilsizeorthrowfilesi.get$^    chainsi  utilstreampreadfilesi.get$^  $^$^$^void modelbuffersourcestdsizet orderminus0 utilstreamchain chain $^  chain  utilstreampreadfilesorderminus0.get$^$^$^float modelbufferslowqueryconst ngramstate context wordindex word ngramstate out const $^   lookup unigram.$^  probbackoff value$^  utilersatzpreadrawfile0 value sizeofvalue word  sizeofwordindex  sizeofvalue  sizeofwordindex$^  out.backoff0  value.backoff$^  out.words0  word$^  out.length  0$^$^  stdvectorwordindex buffercontext.length  0 querycontext.length  0$^  stdreversecopycontext.words context.words  context.length query.begin$^  querycontext.length  word$^$^  for stdsizet order  0 order  query.size  order  context.length  0 order $^    suffixorder lessorder$^    const wordindex key  query.end  order$^    int file  rawfileorder  0$^    stdsizet length  order  sizeofwordindex  sizeofprobbackoff$^     todo cache file size$^    uint00t begin  0 end  utilsizeorthrowfile  length$^    while true $^      if end  begin $^         did not find for order.$^        return stdaccumulatecontext.backoff  out.length  0 context.backoff  context.length value.prob$^      $^      uint00t test  begin  end  begin  0$^      utilersatzpreadfile buffer.begin sizeofwordindex  order test  length$^$^      if lessbuffer.begin key $^        begin  test  0$^       else if lesskey buffer.begin $^        end  test$^       else $^         found it.$^        utilersatzpreadfile value sizeofvalue test  length  sizeofwordindex  order$^        if order  order $^          out.length  order$^          out.backofforder  0  value.backoff$^          out.wordsorder  0  key$^        $^        break$^      $^    $^  $^  return value.prob$^$^$^  namespace$^include boostprogramoptions.hpp$^include utilusage.hh$^$^namespace lm $^$^namespace $^class sizenotify $^  public$^    explicit sizenotifystdsizet out  behindout $^$^    void operatorconst stdstring from $^      behind  utilparsesizefrom$^    $^$^  private$^    stdsizet behind$^$^$^$^boostprogramoptionstypedvaluestdstring sizeoptionstdsizet to const char defaultvalue $^  return boostprogramoptionsvaluestdstringnotifiersizenotifytodefaultvaluedefaultvalue$^$^$^  namespace lm$^include lmcommonprint.hh$^$^include lmcommonngramstream.hh$^include utilfilestream.hh$^include utilfile.hh$^include utilmmap.hh$^include utilscoped.hh$^$^include sstream$^include cstring$^$^namespace lm $^$^vocabreconstitutevocabreconstituteint fd $^  uint00t size  utilsizeorthrowfd$^  utilmapreadutilpopulateorread fd 0 size memory$^  const char const start  staticcastconst charmemory.get$^  const char i$^  for i  start i  start  size i  strleni  0 $^    map.pushbacki$^  $^   last one for lookuppiece.$^  map.pushbacki$^$^$^namespace $^template class payload void printleadconst vocabreconstitute vocab proxystreampayload stream utilfilestream out $^  out  streamvalue.prob  t  vocab.lookupstreambegin$^  for const wordindex i  streambegin  0 i  streamend i $^    out     vocab.lookupi$^  $^$^  namespace$^$^void printarparunconst utilstreamchainpositions positions $^  vocabreconstitute vocabvocabfd$^  utilfilestream outoutfd$^  out  datan$^  for sizet i  0 i  positions.size i $^    out  ngram   i0    countsi  n$^  $^  out  n$^$^  for unsigned order  0 order  positions.size order $^    out    order  grams  n$^    for proxystreamngramprobbackoff  streampositionsorder  0 ngramprobbackoffnull order stream stream $^      printleadvocab stream out$^      out  t  streamvalue.backoff  n$^    $^    out  n$^  $^$^  out    positions.size  grams  n$^  for proxystreamngramprob  streampositions.back ngramprobnull positions.size stream stream $^    printleadvocab stream out$^    out  n$^  $^  out  n$^  out  endn$^$^$^  namespace lm$^include lmcommonmodelbuffer.hh$^include lmmodel.hh$^include lmstate.hh$^$^define boosttestmodule modelbuffertest$^include boosttestunittest.hpp$^$^namespace lm  namespace $^$^boostautotestcasequery $^  stdstring dirtestdata$^  if boostunittestframeworkmastertestsuite.argc  0 $^    dir  boostunittestframeworkmastertestsuite.argv0$^  $^  ngrammodel refdir  toy0.arpa.cstr$^  modelbuffer testdir  toy0$^  ngramstate refstate teststate$^  wordindex a  ref.getvocabulary.indexa$^  boostcheckclose$^      ref.fullscoreref.beginsentencestate a refstate.prob$^      test.slowqueryref.beginsentencestate a teststate$^      0.000$^  boostcheckequalunsignedrefstate.length unsignedteststate.length$^  boostcheckequalrefstate.words0 teststate.words0$^  boostcheckequalrefstate.backoff0 teststate.backoff0$^  boostcheckrefstate  teststate$^$^  ngramstate refstate0 teststate0$^  wordindex b  ref.getvocabulary.indexb$^  boostcheckclose$^      ref.fullscorerefstate b refstate0.prob$^      test.slowqueryteststate b teststate0$^      0.000$^  boostcheckrefstate0  teststate0$^  boostcheckequalrefstate0.backoff0 teststate0.backoff0$^$^  boostcheckclose$^      ref.fullscorerefstate0 0 refstate.prob$^      test.slowqueryteststate0 0 teststate$^      0.000$^   the reference does state minimization but this doesnt.$^$^$^  namespaces$^include lmsizes.hh$^include lmmodel.hh$^include utilfilepiece.hh$^$^include vector$^include iomanip$^$^namespace lm $^namespace ngram $^$^void showsizesconst stdvectoruint00t counts const lmngramconfig config $^  uint00t sizes0$^  sizes0  probingmodelsizecounts config$^  sizes0  restprobingmodelsizecounts config$^  sizes0  triemodelsizecounts config$^  sizes0  quanttriemodelsizecounts config$^  sizes0  arraytriemodelsizecounts config$^  sizes0  quantarraytriemodelsizecounts config$^  uint00t maxlength  stdmaxelementsizes sizes  sizeofsizes  sizeofuint00t$^  uint00t minlength  stdminelementsizes sizes  sizeofsizes  sizeofuint00t$^  uint00t divide$^  char prefix$^  if minlength  0  00  00 $^    prefix   $^    divide  0$^   else if minlength  0  00  00 $^    prefix  k$^    divide  0  00$^   else if minlength  0ull  00  00 $^    prefix  m$^    divide  0  00$^   else $^    prefix  g$^    divide  0  00$^  $^  long int length  stdmaxlong int0 staticcastlong intceillog00double maxlength  divide$^  stdcerr  memory estimate for binary lmntype    $^$^   right align bytes.$^  for long int i  0 i  length  0 i stdcerr   $^$^  stdcerr  prefix  bn$^    probing   stdsetwlength  sizes0  divide   assuming p   config.probingmultiplier  n$^    probing   stdsetwlength  sizes0  divide   assuming r models p   config.probingmultiplier  n$^    trie      stdsetwlength  sizes0  divide   without quantizationn$^    trie      stdsetwlength  sizes0  divide   assuming q   unsignedconfig.probbits   b   unsignedconfig.backoffbits   quantization n$^    trie      stdsetwlength  sizes0  divide   assuming a   unsignedconfig.pointerbhikshabits   array pointer compressionn$^    trie      stdsetwlength  sizes0  divide   assuming a   unsignedconfig.pointerbhikshabits   q   unsignedconfig.probbits   b   unsignedconfig.backoffbits  array pointer compression and quantizationn$^$^$^void showsizesconst stdvectoruint00t counts $^  lmngramconfig config$^  showsizescounts config$^$^$^void showsizesconst char file const lmngramconfig config $^  stdvectoruint00t counts$^  utilfilepiece ffile$^  lmreadarpacountsf counts$^  showsizescounts config$^$^$^ namespaces$^include lmpartial.hh$^$^include lmleft.hh$^include lmmodel.hh$^include utiltokenizepiece.hh$^$^define boosttestmodule partialtest$^include boosttestunittest.hpp$^include boosttestfloatingpointcomparison.hpp$^$^namespace lm $^namespace ngram $^namespace $^$^const char testlocation $^  if boostunittestframeworkmastertestsuite.argc  0 $^    return test.arpa$^  $^  return boostunittestframeworkmastertestsuite.argv0$^$^$^config silentconfig $^  config config$^  config.arpacomplain  confignone$^  config.messages  null$^  return config$^$^$^struct modelfixture $^  modelfixture  mtestlocation silentconfig $^$^  restprobingmodel m$^$^$^boostfixturetestsuitesuite modelfixture$^$^boostautotestcasesimplebefore $^  left left$^  left.full  false$^  left.length  0$^  right right$^  right.length  0$^$^  right reveal$^  reveal.length  0$^  wordindex period  m.getvocabulary.index.$^  reveal.words0  period$^  reveal.backoff0  0.000000$^$^  boostcheckclose0.0 revealbeforem reveal 0 false left right 0.000$^  boostcheckequal0 left.length$^  boostcheckleft.full$^  boostcheckequal0 right.length$^  boostcheckequalperiod right.words0$^  boostcheckclose0.000000 right.backoff0 0.000$^$^  wordindex more  m.getvocabulary.indexmore$^  reveal.words0  more$^  reveal.backoff0   0.0000000$^  reveal.length  0$^  boostcheckclose0.0 revealbeforem reveal 0 false left right 0.000$^  boostcheckequal0 left.length$^  boostcheckleft.full$^  boostcheckequal0 right.length$^  boostcheckequalperiod right.words0$^  boostcheckequalmore right.words0$^  boostcheckclose0.000000 right.backoff0 0.000$^  boostcheckclose0.0000000 right.backoff0 0.000$^$^$^boostautotestcasealsowouldconsider $^  wordindex would  m.getvocabulary.indexwould$^  wordindex consider  m.getvocabulary.indexconsider$^$^  chartstate current$^  current.left.length  0$^  current.left.pointers0  would$^  current.left.full  false$^  current.right.length  0$^  current.right.words0  would$^  current.right.backoff0  0.00000$^$^  left after$^  after.full  false$^  after.length  0$^  after.pointers0  consider$^$^   adjustment for would consider$^  boostcheckclose0.000000  0.0000000  0.00000 revealafterm current.left current.right after 0 0.000$^$^  boostcheckequal0 current.left.length$^  boostcheckequalwould current.left.pointers0$^  boostcheckequalfalse current.left.full$^$^  wordindex also  m.getvocabulary.indexalso$^  right before$^  before.length  0$^  before.words0  also$^  before.backoff0  0.00000$^   rwould  0.0000000 i would rwould  consider  0.000000 bwould  pconsider$^   palso  would  0 palso would  consider  0$^  boostcheckclose0  0.0000000 0  0.000000 revealbeforem before 0 false current.left current.right 0.000$^  boostcheckequal0 current.left.length$^  boostcheckcurrent.left.full$^  boostcheckequal0 current.right.length$^  boostcheckequalwould current.right.words0$^  boostcheckequalalso current.right.words0$^$^$^boostautotestcaseendsentence $^  wordindex loin  m.getvocabulary.indexloin$^  wordindex period  m.getvocabulary.index.$^  wordindex eos  m.getvocabulary.endsentence$^$^  chartstate between$^  between.left.length  0$^  between.left.pointers0  eos$^  between.left.full  true$^  between.right.length  0$^$^  right before$^  before.words0  period$^  before.words0  loin$^  before.backoff0  0.000000$^  before.backoff0  0.0$^$^  before.length  0$^  boostcheckclose0.0000000 revealbeforem before 0 true between.left between.right 0.000$^  boostcheckequal0 between.left.length$^$^$^float scorefragmentconst restprobingmodel model unsigned int begin unsigned int end chartstate out $^  rulescorerestprobingmodel scorermodel out$^  for unsigned int i  begin i  end i $^    scorer.terminali$^  $^  return scorer.finish$^$^$^void checkadjustmentconst restprobingmodel model float expect const right beforein bool beforefull chartstate between const left afterin $^  right beforebeforein$^  left afterafterin$^  after.full  false$^  float got  0.0$^  for unsigned int i  0 i  0 i $^    if beforein.length  i $^      before.length  i$^      got  revealbeforemodel before i  0 false between.left between.right$^    $^    if afterin.length  i $^      after.length  i$^      got  revealaftermodel between.left between.right after i  0$^    $^  $^  if afterin.full $^    after.full  true$^    got  revealaftermodel between.left between.right after after.length$^  $^  if beforefull $^    got  revealbeforemodel before before.length true between.left between.right$^  $^   sometimes theyre zero and boostcheckclose fails for this.$^  boostcheckfabsexpect  got  0.000$^$^$^void fulldivideconst restprobingmodel model stringpiece str $^  stdvectorwordindex indices$^  for utiltokeniterutilsinglecharacter true istr   i i $^    indices.pushbackmodel.getvocabulary.indexi$^  $^  chartstate fullstate$^  float full  scorefragmentmodel indices.front indices.back  0 fullstate$^$^  chartstate beforestate$^  beforestate.left.full  false$^  rulescorerestprobingmodel beforescorermodel beforestate$^  float beforescore  0.0$^  for unsigned int before  0 before  indices.size before $^    for unsigned int after  before after  indices.size after $^      chartstate afterstate betweenstate$^      float afterscore  scorefragmentmodel indices.front  after indices.front  indices.size afterstate$^      float betweenscore  scorefragmentmodel indices.front  before indices.front  after betweenstate$^      checkadjustmentmodel full  beforescore  afterscore  betweenscore beforestate.right beforestate.left.full betweenstate afterstate.left$^    $^    beforescorer.terminalindicesbefore$^    beforescore  beforescorer.finish$^  $^$^$^boostautotestcasestrings $^  fulldividem also would consider$^  fulldividem looking on a little more loin . s$^  fulldividem in biarritz watching considering looking . on a little more loin also would consider higher to look good unknown the screening foo bar  unknown however unknown s$^$^$^boostautotestsuiteend$^  namespace$^  namespace ngram$^  namespace lm$^include lminterpolateboundedsequenceencoding.hh$^$^include utilscoped.hh$^$^define boosttestmodule boundedsequenceencodingtest$^include boosttestunittest.hpp$^$^namespace lm $^namespace interpolate $^namespace $^$^void exhaustivetestunsigned char boundbegin unsigned char boundend $^  boundedsequenceencoding encboundbegin boundend$^  utilscopedmalloc backingutilmallocorthrowenc.encodedlength$^  stdvectorunsigned char valuesboundend  boundbegin$^      outboundend  boundbegin$^  while true $^    enc.encodevalues0 backing.get$^    enc.decodebacking.get out0$^    for stdsizet i  0 i  values.size i $^      boostcheckequalvaluesi outi$^    $^    for stdsizet i  0 i $^      if i  values.size return$^      valuesi$^      if valuesi  boundbegini break$^      valuesi  0$^    $^  $^$^$^void checkencodedecodeunsigned char bounds unsigned char input$^                       unsigned char output stdsizet len $^  boundedsequenceencoding encoderbounds bounds  len$^  utilscopedmalloc backingutilmallocorthrowencoder.encodedlength$^$^  encoder.encodeinput backing.get$^  encoder.decodebacking.get output$^$^  for stdsizet i  0 i  len i $^    boostcheckequalinputi outputi$^  $^$^$^boostautotestcaseexhaustive $^  unsigned char bounds  0 0 0 0 0 00 0$^  exhaustivetestbounds bounds  sizeofbounds  sizeofunsigned char$^$^$^boostautotestcaselessthan00 $^  unsigned char bounds  000 000 000 000 000 000 000 0$^  unsigned char input  000 000 000 000 00 00 00 0$^  unsigned char output  0 0 0 0 0 0 0 0$^$^  stdsizet len  sizeofbounds  sizeofunsigned char$^  assertsizeofinput  sizeofunsigned char  len$^  assertsizeofoutput  sizeofunsigned char  len$^$^  checkencodedecodebounds input output len$^$^$^boostautotestcaseexactly00 $^  unsigned char bounds  000 000 000 000 000 000 000 000$^  unsigned char input  000 000 000 000 00 00 00 00$^  unsigned char output  0 0 0 0 0 0 0 0$^$^  stdsizet len  sizeofbounds  sizeofunsigned char$^  assertsizeofinput  sizeofunsigned char  len$^  assertsizeofoutput  sizeofunsigned char  len$^$^  checkencodedecodebounds input output len$^$^$^boostautotestcasemorethan00 $^  unsigned char bounds  000 000 000 000 000 000 000 000 000$^  unsigned char input  000 000 000 000 00 00 00 00 000$^  unsigned char output  0 0 0 0 0 0 0 0 0$^$^  stdsizet len  sizeofbounds  sizeofunsigned char$^  assertsizeofinput  sizeofunsigned char  len$^  assertsizeofoutput  sizeofunsigned char  len$^$^  checkencodedecodebounds input output len$^$^$^  namespaces$^include lminterpolatemergevocab.hh$^$^include lmenumeratevocab.hh$^include lminterpolateuniversalvocab.hh$^include lmlmexception.hh$^include lmvocab.hh$^include utilfilepiece.hh$^$^include queue$^include string$^include iostream$^include vector$^$^namespace lm $^namespace interpolate $^namespace $^$^class vocabfilereader $^  public$^    explicit vocabfilereaderconst int fd sizet modelnum uint00t offset  0$^$^    vocabfilereader operator$^    operator bool const  return eof $^    uint00t operator const  return value $^$^    uint00t value const  return hashvalue $^    sizet modelnum const  return modelnum $^    wordindex currentindex const  return currentindex $^$^    stringpiece word const  return word $^$^  private$^    uint00t hashvalue$^    wordindex currentindex$^    bool eof$^    sizet modelnum$^    stringpiece word$^    utilfilepiece filepiece$^$^$^vocabfilereadervocabfilereaderconst int fd const sizet modelnum uint00t offset $^  hashvalue0$^  currentindex0$^  eoffalse$^  modelnummodelnum$^  filepieceutilduporthrowfd $^  word  filepiece.readline0$^  utilthrowifword  unk$^                formatloadexception$^                vocabulary words are in the wrong place.$^   setup to initial value$^  this$^$^$^vocabfilereader vocabfilereaderoperator $^  try $^    word  filepiece.readline0$^   catchutilendoffileexception e $^    eof  true$^    return this$^  $^  uint00t prevhashvalue  hashvalue$^  hashvalue  ngramdetailhashforvocabword.data word.size$^$^   hash values should be monotonically increasing$^  utilthrowifhashvalue  prevhashvalue formatloadexception$^                 word index not monotonically increasing.$^                  modelnum   modelnum$^                  prev hash   prevhashvalue$^                  new hash   hashvalue$^$^  currentindex$^  return this$^$^$^class comparefiles $^public$^  bool operatorconst vocabfilereader x$^                  const vocabfilereader y$^   return xvalue  yvalue $^$^$^class readers  public utilfixedarrayvocabfilereader $^  public$^    readersstdsizet number  utilfixedarrayvocabfilereadernumber $^    void pushbackint fd stdsizet i $^      newend vocabfilereaderfd i$^      constructed$^    $^$^$^  namespace$^$^wordindex mergevocabutilfixedarrayint files universalvocab vocab enumeratevocab enumerate $^  typedef stdpriorityqueuevocabfilereader stdvectorvocabfilereader comparefiles heaptype$^  heaptype heap$^  readers readersfiles.size$^  for sizet i  0 i  files.size i $^    readers.pushbackfilesi i$^    heap.pushreaders.back$^     initialize first index to 0 for unk$^    vocab.insertuniversalidxi 0 0$^  $^$^  uint00t prevhashvalue  0$^   globalindex starts with unk which is 0$^  wordindex globalindex  0$^$^  enumerate.add0 unk$^  while heap.empty $^    vocabfilereader topvocabfile  heap.top$^    if topvocabfilevalue  prevhashvalue $^      enumerate.addglobalindex topvocabfileword$^    $^    vocab.insertuniversalidxtopvocabfilemodelnum$^        topvocabfilecurrentindex$^        globalindex$^$^    prevhashvalue  topvocabfilevalue$^$^    heap.pop$^    if topvocabfile $^      heap.pushtopvocabfile$^    $^  $^  return globalindex  0$^$^$^  namespace interpolate$^  namespace lm$^$^include lminterpolatebackoffreunification.hh$^include lmcommonmodelbuffer.hh$^include lmcommonngramstream.hh$^include lmcommonngram.hh$^include lmcommoncompare.hh$^$^include algorithm$^include cassert$^$^namespace lm $^namespace interpolate $^$^namespace $^class mergeworker $^public$^  mergeworkerstdsizet order const utilstreamchainposition probpos$^              const utilstreamchainposition boffpos$^       orderorder probposprobpos boffposboffpos $^     nothing$^  $^$^  void runconst utilstreamchainposition position $^    lmngramstreamprobbackoff streamposition$^$^    lmngramstreamfloat probinputprobpos$^    utilstreamstream boffinputboffpos$^    for  probinput  boffinput probinput boffinput stream $^      stdcopyprobinputbegin probinputend streambegin$^      streamvalue.prob  stdmin0.0f probinputvalue$^      streamvalue.backoff  reinterpretcastfloat boffinput.get$^    $^    utilthrowif0probinput  boffinput$^                   streams were not the same size during merging$^    stream.poison$^  $^$^private$^  stdsizet order$^  utilstreamchainposition probpos$^  utilstreamchainposition boffpos$^$^$^$^ since we are adding something to the output chain here we pass in the$^ chain itself so that we can safely add a new step to the chain without$^ creating a deadlock situation since creating a new chainposition will$^ make a new inputoutput pairwe want that position to be created$^ here not before.$^void reunifybackoffutilstreamchainpositions probpos$^                    utilstreamchainpositions boffpos$^                    utilstreamchains outputchains $^  assertprobpos.size  boffpos.size$^$^  for sizet i  0 i  probpos.size i$^    outputchainsi  mergeworkeri  0 probposi boffposi$^$^$^$^include lminterpolatetuneinstances.hh$^$^include utilfile.hh$^include utilfilestream.hh$^include utilstreamchain.hh$^include utilstreamconfig.hh$^include utilstreamtypedstream.hh$^include utilstringpiece.hh$^$^define boosttestmodule instancetest$^include boosttestunittest.hpp$^$^include vector$^$^include math.h$^$^namespace lm  namespace interpolate  namespace $^$^boostautotestcasetoy $^  utilscopedfd testinpututilmaketemptemporary$^  utilfilestreamtestinput.get  cn$^$^  stringpiece dir..commontestdata$^  if boostunittestframeworkmastertestsuite.argc  0 $^    stringpiece zerofileboostunittestframeworkmastertestsuite.argv0$^    boostrequirezerofile.size  strlentoy0.0$^    boostrequireequaltoy0.0 stringpiecezerofile.data  zerofile.size  0 0$^    dir  stringpiecezerofile.data zerofile.size  0$^  $^$^  stdvectorstringpiece modelnames$^  stdstring full0  stdstringdir.data dir.size  toy0$^  stdstring full0  stdstringdir.data dir.size  toy0$^  modelnames.pushbackfull0$^  modelnames.pushbackfull0$^$^   tiny buffer sizes.$^  instancesconfig config$^  config.modelreadchainmem  000$^  config.extensionwritechainmem  000$^  config.lazymemory  000$^  config.sort.tempprefix  temporary$^  config.sort.buffersize  000$^  config.sort.totalmemory  0000$^$^  utilseekorthrowtestinput.get 0$^$^  instances insttestinput.release modelnames config$^$^  boostcheckequal0 inst.bos$^  const matrix lnunigrams  inst.lnunigrams$^$^   unk0$^  boostcheckclose0.00000  mln00 lnunigrams0 0 0.000$^  boostcheckclose0  mln00 lnunigrams0 0 0.000$^   s0 doesnt matter as long as it doesnt cause nans.$^  boostcheckisnanlnunigrams0 0$^  boostcheckisnanlnunigrams0 0$^   a  0$^  boostcheckclose0.00000000  mln00 lnunigrams0 0 0.000$^  boostcheckclose0.0000000  mln00 lnunigrams0 0 0.000$^   s  0$^  boostcheckclose0.0000000  mln00 lnunigrams0 0 0.000$^  boostcheckclose0.0000000  mln00 lnunigrams0 0 0.000$^   c  0$^  boostcheckclose0.00000  mln00 lnunigrams0 0 0.000  unk$^  boostcheckclose0.0000000  mln00 lnunigrams0 0 0.000$^   too lazy to do b  0.$^$^   two instances$^   s predicts c$^   s c predicts s$^  boostrequireequal0 inst.numinstances$^  boostcheckclose0.00000  mln00 inst.lnbackoffs00 0.000$^  boostcheckclose0.00000  mln00 inst.lnbackoffs00 0.000$^$^$^   backoffs of s c$^  boostcheckclose0.0 inst.lnbackoffs00 0.000$^  boostcheckclose0.00000  0.00000  mln00 inst.lnbackoffs00 0.000$^$^  utilstreamchain extensionsutilstreamchainconfiginst.readextensionsentrysize 0 000$^  inst.readextensionsextensions$^  utilstreamtypedstreamextension streamextensions.add$^  extensions  utilstreamkrecycle$^$^   the extensions are in order of instance vocab id and model as they should be sorted$^   s a from both models 0 and 0 so two instances$^   s c from model 0$^   s b from model 0$^   c s from model 0$^   magic probabilities come from querying the models directly.$^$^   s a from model 0$^  boostrequirestream$^  boostcheckequal0 streaminstance$^  boostcheckequal0  a  streamword$^  boostcheckequal0 streammodel$^  boostcheckclose0.00000000  mln00 streamlnprob 0.000$^$^   s a from model 0$^  boostrequirestream$^  boostcheckequal0 streaminstance$^  boostcheckequal0  a  streamword$^  boostcheckequal0 streammodel$^  boostcheckclose0.0000000  mln00 streamlnprob 0.000$^$^   s c from model 0$^  boostrequirestream$^  boostcheckequal0 streaminstance$^  boostcheckequal0  c  streamword$^  boostcheckequal0 streammodel$^  boostcheckclose0.0000000  mln00 streamlnprob 0.000$^$^   s b from model 0$^  boostrequirestream$^  boostcheckequal0 streaminstance$^  boostcheckequal0  b  streamword$^  boostcheckequal0 streammodel$^  boostcheckclose0.00000000  mln00 streamlnprob 0.000$^$^   c s from model 0$^  boostrequirestream$^  boostcheckequal0 streaminstance$^  boostcheckequal0  s  streamword$^  boostcheckequal0 streammodel$^  boostcheckclose0.00000000  mln00 streamlnprob 0.000$^$^  boostcheckstream$^$^$^  namespaces$^include lminterpolatetuneweights.hh$^$^include lminterpolatetunederivatives.hh$^include lminterpolatetuneinstances.hh$^$^pragma gcc diagnostic push$^pragma gcc diagnostic ignored wpragmas  older gcc doesnt have wunusedlocaltypedefs and complains.$^pragma gcc diagnostic ignored wunusedlocaltypedefs$^include eigendense$^pragma gcc diagnostic pop$^include boostprogramoptions.hpp$^$^include iostream$^$^namespace lm  namespace interpolate $^void tuneweightsint tunefile const stdvectorstringpiece modelnames const instancesconfig config stdvectorfloat weightsout $^  instances instancestunefile modelnames config$^  vector weights  vectorconstantmodelnames.size 0.0  modelnames.size$^  vector gradient$^  matrix hessian$^  for stdsizet iteration  0 iteration  00 todo fancy stopping criteria  iteration $^    stdcerr  iteration   iteration   weights $^    for vectorindex i  0 i  weights.rows i $^      stdcerr     weightsi$^    $^    stdcerr  stdendl$^    stdcerr  perplexity    derivativesinstances weights gradient hessian  stdendl$^     todo 0.0 step size was too big and it kept getting unstable.  more math.$^    weights  0.0  hessian.inverse  gradient$^  $^  weightsout.assignweights.data weights.data  weights.size$^$^  namespaces$^include lmcommonmodelbuffer.hh$^include lmcommonsizeoption.hh$^include lminterpolatepipeline.hh$^include lminterpolatetuneinstances.hh$^include lminterpolatetuneweights.hh$^include utilfixedarray.hh$^include utilusage.hh$^$^pragma gcc diagnostic push$^pragma gcc diagnostic ignored wpragmas  older gcc doesnt have wunusedlocaltypedefs and complains.$^pragma gcc diagnostic ignored wunusedlocaltypedefs$^include eigencore$^pragma gcc diagnostic pop$^$^include boostprogramoptions.hpp$^$^include iostream$^include vector$^$^namespace $^void mungeweightargsint argc char argv stdvectorconst char  mungedargs $^   boost program options doesnt w 0.0 0.0 because it thinks 0.0 is an$^   option.  there appears to be no standard way to fix this without breaking$^   singledash arguments.  so heres a hack put a w before every number$^   if its within the scope of a weight argument.$^  mungedargs.pushbackargv0$^  char insideweights  null$^  for char i  argv  0 i  argv  argc i $^    stringpiece argi$^    if startswitharg w  startswitharg w $^      insideweights  i$^     else if insideweights  arg.size  0  arg0    arg0  0  arg0  0  arg0  . $^       if a negative number appears right after w dont add another w.$^       and do stay inside weights.$^      if insideweights  0  i $^        mungedargs.pushbackw$^      $^     else if startswitharg  $^      insideweights  null$^    $^    mungedargs.pushbacki$^  $^$^  namespace$^$^int mainint argc char argv $^  try $^    eigeninitparallel$^    lminterpolateconfig pipeconfig$^    lminterpolateinstancesconfig instancesconfig$^    stdvectorstdstring inputmodels$^    stdstring tuningfile$^$^    namespace po  boostprogramoptions$^    pooptionsdescription optionsloglinear interpolation options$^    options.addoptions$^      helph poboolswitch show this help message$^      modelm povaluestdvectorstdstring inputmodelsmultitokenrequired models to interpolate which must be in kenlm intermediate format.  the intermediate format can be generated using the intermediate argument to lmplz.$^      weightw povaluestdvectorfloat pipeconfig.lambdasmultitoken interpolation weights$^      tuningt povaluestdstringtuningfile file to tune on a text file with one sentence per line$^      justtune poboolswitch tune and print weights then quit$^      tempprefixt povaluestdstringpipeconfig.sort.tempprefixdefaultvaluetmplm temporary file prefix$^      memorys lmsizeoptionpipeconfig.sort.totalmemory utilguessphysicalmemory  00  0g sorting memory this is a very rough guide$^      sortblock lmsizeoptionpipeconfig.sort.buffersize 00m block size$^    povariablesmap vm$^$^    stdvectorconst char  mungedargs$^    mungeweightargsargc argv mungedargs$^$^    postorepoparsecommandlineintmungedargs.size mungedargs.begin options vm$^    if argc  0  vmhelp.asbool $^      stdcerr  interpolate multiple modelsn  options  stdendl$^      return 0$^    $^    ponotifyvm$^    instancesconfig.sort  pipeconfig.sort$^    instancesconfig.modelreadchainmem  instancesconfig.sort.buffersize$^    instancesconfig.extensionwritechainmem  instancesconfig.sort.totalmemory$^    instancesconfig.lazymemory  instancesconfig.sort.totalmemory$^$^    if pipeconfig.lambdas.empty  tuningfile.empty $^      stdcerr  provide a tuning file with t xor weights with w.  stdendl$^      return 0$^    $^    if pipeconfig.lambdas.empty  tuningfile.empty $^      stdcerr  provide weights xor a tuning file not both.  stdendl$^      return 0$^    $^$^    if tuningfile.empty $^       tune weights$^      stdvectorstringpiece modelnames$^      for stdvectorstdstringconstiterator i  inputmodels.begin i  inputmodels.end i $^        modelnames.pushbacki$^      $^      lminterpolatetuneweightsutilopenreadorthrowtuningfile.cstr modelnames instancesconfig pipeconfig.lambdas$^$^      stdcerr  final weights$^      stdostream to  vmjusttune.asbool  stdcout  stdcerr$^      for stdvectorfloatconstiterator i  pipeconfig.lambdas.begin i  pipeconfig.lambdas.end i $^        to     i$^      $^      to  stdendl$^    $^    if vmjusttune.asbool $^      return 0$^    $^$^    if pipeconfig.lambdas.size  inputmodels.size $^      stdcerr  number of models   inputmodels.size   should match the number of weights   pipeconfig.lambdas.size  .  stdendl$^      return 0$^    $^$^    utilfixedarraylmmodelbuffer modelsinputmodels.size$^    for stdsizet i  0 i  inputmodels.size i $^      models.pushbackinputmodelsi$^    $^    lminterpolatepipelinemodels pipeconfig 0$^   catch const stdexception e $^    stdcerr  e.what stdendl$^    return 0$^  $^  return 0$^$^include lminterpolatesplitworker.hh$^include lmcommonngram.hh$^$^namespace lm $^namespace interpolate $^$^splitworkersplitworkerstdsizet order utilstreamchain backoffchain$^                         utilstreamchain sortchain$^     orderorder $^  backoffchain  backoffinput$^  sortchain  sortinput$^$^$^void splitworkerrunconst utilstreamchainposition position $^   input ngram record id prob and backoff$^   output a float to the backoffinput stream$^           an ngram id and a float to the sortinput stream$^  for utilstreamstream streamposition stream stream $^    ngramprobbackoff ngramstream.get order$^$^     write id and prob to the sort stream$^    float prob  ngram.value.prob$^    lmwordindex out  reinterpretcastlmwordindex sortinput.get$^    for const lmwordindex it  ngram.begin it  ngram.end it $^      out  it$^    $^    reinterpretcastfloat out  prob$^    sortinput$^$^     write backoff to the backoff output stream$^    float boff  ngram.value.backoff$^    reinterpretcastfloat backoffinput.get  boff$^    backoffinput$^  $^  sortinput.poison$^  backoffinput.poison$^$^$^$^$^include lminterpolatenormalize.hh$^$^include lminterpolateinterpolateinfo.hh$^include lminterpolatemergeprobabilities.hh$^include lmcommonngramstream.hh$^include utilstreamchain.hh$^include utilstreammultistream.hh$^$^define boosttestmodule normalizetest$^include boosttestunittest.hpp$^$^namespace lm  namespace interpolate  namespace $^$^ log without backoff$^const float kinputs  0.0 0.0 0.0 0.0 0.0 0.0$^$^class writeinput $^  public$^    writeinput $^    void runconst utilstreamchainposition to $^      utilstreamstream outto$^      for wordindex i  0 i  sizeofkinputs  sizeoffloat i out $^        memcpyout.get i sizeofwordindex$^        memcpyuint0tout.get  sizeofwordindex kinputsi sizeoffloat$^      $^      out.poison$^    $^$^$^void checkoutputconst utilstreamchainposition from $^  ngramstreamfloat infrom$^  float sum  0.0$^  for wordindex i  0 i  sizeofkinputs  sizeoffloat  0  s at the end  i $^    sum  pow00.0 kinputsi$^  $^  sum  log00sum$^  boostrequirein$^  boostcheckclosekinputs0  sum invalue 0.0000$^  boostrequirein$^  boostcheckclosekinputs0  sum invalue 0.0000$^  boostrequirein$^  boostcheckclosekinputs0  sum invalue 0.0000$^  boostrequirein$^  boostcheckclosekinputs0  sum invalue 0.0000$^  boostrequirein$^  boostcheckclosekinputs0  sum invalue 0.0000$^  boostrequirein$^  boostcheckclosekinputs0  sum invalue 0.0000$^  boostcheckin$^$^$^boostautotestcaseunigrams $^  interpolateinfo info$^  info.lambdas.pushback0.0$^  info.lambdas.pushback0.0$^  info.orders.pushback0$^  info.orders.pushback0$^$^  boostcheckequal0 makeencoderinfo 0.encodedlength$^$^   no backoffs.$^  utilstreamchains blank0$^  utilfixedarrayutilstreamchainpositions modelsbyorder0$^  modelsbyorder.pushbackblank$^  modelsbyorder.pushbackblank$^$^  utilstreamchains mergedprobabilities0$^  utilstreamchains probabilitiesout0$^  utilstreamchains backoffsout0$^$^  mergedprobabilities.pushbackutilstreamchainconfigsizeofwordindex  sizeoffloat  sizeoffloat 0 00$^  probabilitiesout.pushbackutilstreamchainconfigsizeofwordindex  sizeoffloat 0 000$^$^  mergedprobabilities0  writeinput$^  normalizeinfo modelsbyorder mergedprobabilities probabilitiesout backoffsout$^$^  utilstreamchainposition checkerprobabilitiesout0.add$^$^  mergedprobabilities  utilstreamkrecycle$^  probabilitiesout  utilstreamkrecycle$^$^  checkoutputchecker$^  probabilitiesout.wait$^$^$^  namespaces$^include lminterpolateuniversalvocab.hh$^$^namespace lm $^namespace interpolate $^$^universalvocabuniversalvocabconst stdvectorwordindex modelvocabsizes $^  modelindexmap.resizemodelvocabsizes.size$^  for sizet i  0 i  modelvocabsizes.size i $^    modelindexmapi.resizemodelvocabsizesi$^  $^$^$^  namespaces$^include lminterpolatepipeline.hh$^$^include lmcommoncompare.hh$^include lmcommonprint.hh$^include lmcommonrenumber.hh$^include lmvocab.hh$^include lminterpolatebackoffreunification.hh$^include lminterpolateinterpolateinfo.hh$^include lminterpolatemergeprobabilities.hh$^include lminterpolatemergevocab.hh$^include lminterpolatenormalize.hh$^include lminterpolateuniversalvocab.hh$^include utilstreamchain.hh$^include utilstreamcountrecords.hh$^include utilstreamio.hh$^include utilstreammultistream.hh$^include utilstreamsort.hh$^include utilfixedarray.hh$^$^namespace lm  namespace interpolate  namespace $^$^ put the original input files on chains and renumber them $^void setupinputsstdsizet buffersize const universalvocab vocab utilfixedarraymodelbuffer models bool excludehighest utilfixedarrayutilstreamchains chains utilfixedarrayutilstreamchainpositions positions $^  chains.clear$^  positions.clear$^   todo much better memory sizing heuristics e.g. not making the chain larger than it will use.$^  utilstreamchainconfig config0 0 buffersize$^  for stdsizet i  0 i  models.size i $^    chains.pushbackmodelsi.order  excludehighest$^    for stdsizet j  0 j  modelsi.order  excludehighest j $^      config.entrysize  sizeofwordindex  j  0  sizeoffloat  0  todo do not include wasteful backoff for highest.$^      chains.back.pushbackconfig$^    $^    if i  models.size  0$^      chains.back.back.activateprogress$^    modelsi.sourcechains.back$^    for stdsizet j  0 j  modelsi.order  excludehighest j $^      chainsij  renumbervocab.mappingi j  0$^    $^  $^ for stdsizet i  0 i  chains.size i $^    positions.pushbackchainsi$^  $^$^$^template class compare void sinksortconst utilstreamsortconfig config utilstreamchains chains utilstreamsortscompare sorts $^  for stdsizet i  0 i  chains.size i $^    sorts.pushbackchainsi config comparei  0$^  $^$^$^template class compare void sourcesortutilstreamchains chains utilstreamsortscompare sorts $^   todo memory management$^  for stdsizet i  0 i  sorts.size i $^    sortsi.mergesortsi.defaultlazy$^  $^  for stdsizet i  0 i  sorts.size i $^    sortsi.outputchainsi sortsi.defaultlazy$^  $^$^$^  namespace$^$^void pipelineutilfixedarraymodelbuffer models const config config int writefile $^   setup interpolateinfo and universalvocab.$^  interpolateinfo info$^  info.lambdas  config.lambdas$^  stdvectorwordindex vocabsizes$^$^  utilscopedfd vocabnullutilmaketempconfig.sort.tempprefix$^  stdsizet maxorder  0$^  utilfixedarrayint vocabfilesmodels.size$^  for modelbuffer i  models.begin i  models.end i $^    info.orders.pushbackiorder$^    vocabsizes.pushbackicounts0$^    vocabfiles.pushbackivocabfile$^    maxorder  stdmaxmaxorder iorder$^  $^  utilscopedptruniversalvocab vocabnew universalvocabvocabsizes$^  $^    ngramimmediatewritewordswrapper writernull vocabnull.get 0$^    mergevocabvocabfiles vocab writer$^  $^$^  stdcerr  merging probabilities.  stdendl$^   pass 0 merge probabilities$^  utilfixedarrayutilstreamchains inputchainsmodels.size$^  utilfixedarrayutilstreamchainpositions modelsbyordermodels.size$^  setupinputsconfig.buffersize vocab models false inputchains modelsbyorder$^$^  utilstreamchains mergedprobsmaxorder$^  for stdsizet i  0 i  maxorder i $^    mergedprobs.pushbackutilstreamchainconfigpartialprobgammatotalsizeinfo i  0 0 config.buffersize  todo not buffersize$^  $^  mergedprobs  mergeprobabilitiesinfo modelsbyorder$^  stdvectoruint00t countsmaxorder$^  for stdsizet i  0 i  maxorder i $^    mergedprobsi  utilstreamcountrecordscountsi$^  $^  for utilstreamchains i  inputchains.begin i  inputchains.end i $^    i  utilstreamkrecycle$^  $^$^   pass 0 normalize.$^  $^    utilstreamsortscontextorder sortsmergedprobs.size$^    sinksortconfig.sort mergedprobs sorts$^    mergedprobs.waittrue$^    for utilstreamchains i  inputchains.begin i  inputchains.end i $^      iwaittrue$^    $^    sourcesortmergedprobs sorts$^  $^$^  stdcerr  normalizing  stdendl$^  setupinputsconfig.buffersize vocab models true inputchains modelsbyorder$^  utilstreamchains probabilitiesmaxorder backoffsmaxorder  0$^  stdsizet blockcount  0$^  for stdsizet i  0 i  maxorder i $^     careful accounting to ensure rewindablestream can fit the entire vocabulary.$^    blockcount  stdmaxstdsizetblockcount 0$^     this much needs to fit in rewindablestream.$^    stdsizet fit  ngramfloattotalsizei  0  counts0$^     fit  blockcount  0 rounded up$^    stdsizet minblock  fit  blockcount  0  blockcount  0$^    stdsizet specify  stdmaxconfig.buffersize minblock  blockcount$^    probabilities.pushbackutilstreamchainconfigngramfloattotalsizei  0 blockcount specify$^  $^  for stdsizet i  0 i  maxorder  0 i $^    backoffs.pushbackutilstreamchainconfigsizeoffloat 0 config.buffersize$^  $^  normalizeinfo modelsbyorder mergedprobs probabilities backoffs$^  utilfixedarrayutilstreamfilebuffer backoffbuffersbackoffs.size$^  for stdsizet i  0 i  maxorder  0 i $^    backoffbuffers.pushbackutilmaketempconfig.sort.tempprefix$^    backoffsi  backoffbuffers.back.sink  utilstreamkrecycle$^  $^  for utilstreamchains i  inputchains.begin i  inputchains.end i $^    i  utilstreamkrecycle$^  $^  mergedprobs  utilstreamkrecycle$^$^   pass 0 backoffs in the right place.$^  $^    utilstreamsortssuffixorder sortsprobabilities.size$^    sinksortconfig.sort probabilities sorts$^    probabilities.waittrue$^    for utilstreamchains i  inputchains.begin i  inputchains.end i $^      iwaittrue$^    $^    backoffs.waittrue$^    mergedprobs.waittrue$^     destroy universal vocab to save ram.$^    vocab.reset$^    sourcesortprobabilities sorts$^  $^$^  stdcerr  reunifying backoffs  stdendl$^  utilstreamchainpositions probposmaxorder  0$^  utilstreamchains combinedmaxorder  0$^  for stdsizet i  0 i  maxorder  0 i $^    if i  maxorder  0$^      backoffsi.activateprogress$^    backoffsi.setprogresstargetbackoffbuffersi.size$^    backoffsi  backoffbuffersi.sourcetrue$^    probpos.pushbackprobabilitiesi.add$^    combined.pushbackutilstreamchainconfigngramprobbackofftotalsizei  0 0 config.buffersize$^  $^  utilstreamchainpositions backoffposbackoffs$^$^  reunifybackoffprobpos backoffpos combined$^$^  utilstreamchainpositions outputposmaxorder$^  for stdsizet i  0 i  maxorder  0 i $^    outputpos.pushbackcombinedi.add$^  $^  outputpos.pushbackprobabilities.back.add$^$^  probabilities  utilstreamkrecycle$^  backoffs  utilstreamkrecycle$^  combined  utilstreamkrecycle$^$^   todo genericize to modelbuffer etc.$^  printarpavocabnull.get writefile counts.runoutputpos$^$^$^  namespaces$^include lminterpolatenormalize.hh$^$^include lmcommoncompare.hh$^include lmcommonngramstream.hh$^include lminterpolatebackoffmatrix.hh$^include lminterpolateboundedsequenceencoding.hh$^include lminterpolateinterpolateinfo.hh$^include lminterpolatemergeprobabilities.hh$^include lmweights.hh$^include lmwordindex.hh$^include utilfixedarray.hh$^include utilscoped.hh$^include utilstreamstream.hh$^include utilstreamrewindablestream.hh$^$^include functional$^include queue$^include vector$^$^namespace lm  namespace interpolate $^namespace $^$^class backoffqueueentry $^  public$^    backoffqueueentryfloat entry const utilstreamchainposition position$^       entryentry streamposition $^      entry  0.0$^    $^$^    operator bool const  return stream $^$^    ngramheader operator const  return stream $^    const ngramheader operator const  return stream $^$^    void enter $^      entry  streamvalue.backoff$^    $^$^    backoffqueueentry next $^      entry  0.0$^      stream$^      return this$^    $^$^  private$^    float entry$^    ngramstreamprobbackoff stream$^$^$^struct ptrgreater  public stdbinaryfunctionconst backoffqueueentry  const backoffqueueentry  bool $^  bool operatorconst backoffqueueentry first const backoffqueueentry second const $^    return suffixlexicographiclessngramheadersecond first$^  $^$^$^class entryowner  public utilfixedarraybackoffqueueentry $^  public$^    void pushbackfloat entry const utilstreamchainposition position $^      new end backoffqueueentryentry position$^      constructed$^    $^$^$^stdsizet maxorderconst utilfixedarrayutilstreamchainpositions model $^  stdsizet ret  0$^  for const utilstreamchainpositions m  model.begin m  model.end m $^    ret  stdmaxret msize$^  $^  return ret$^$^$^class backoffmanager $^  public$^    explicit backoffmanagerconst utilfixedarrayutilstreamchainpositions models$^       enteredmaxordermodels matrixmodels.size maxordermodels skipwritemaxordermodels $^      stdsizet total  0$^      for const utilstreamchainpositions m  models.begin m  models.end m $^        total  msize$^      $^      for stdsizet i  0 i  maxordermodels i $^        entered.pushbackmodels.size$^      $^      owner.inittotal$^      for const utilstreamchainpositions m  models.begin m  models.end m $^        for const utilstreamchainposition j  mbegin j  mend j $^          owner.pushbackmatrix.backoffm  models.begin j  mbegin j$^          if owner.back $^            queue.pushowner.back$^          $^        $^      $^    $^$^    void setupskipstdsizet order utilstreamstream stream $^      skipwriteorder  0  stream$^    $^$^     move up the backoffs for the given ngram.  the ngrams must be provided$^     in suffix lexicographic order.$^    void enterconst ngramheader to $^       check that we exited properly.$^      for stdsizet i  to.order  0 i  entered.size i $^        assertenteredi.empty$^      $^      suffixlexicographiclessngramheader less$^      while queue.empty  lessqueue.top to$^        skiprecord$^      while topmatchesto $^        backoffqueueentry matches  queue.top$^        enteredto.order  0.pushbackmatches$^        matchesenter$^        queue.pop$^      $^    $^$^    void exitstdsizet orderminus0 $^      for backoffqueueentry i  enteredorderminus0.begin i  enteredorderminus0.end i $^        if inext$^          queue.pushi$^      $^      enteredorderminus0.clear$^    $^$^    float getstdsizet model stdsizet orderminus0 const $^      return matrix.backoffmodel orderminus0$^    $^$^    void finish $^      while queue.empty$^        skiprecord$^    $^$^  private$^    void skiprecord $^      backoffqueueentry top  queue.top$^      queue.pop$^       is this the last instance of the ngram$^      if topmatchestop $^         an ngram is being skipped.  called once per skipped ngram$^         regardless of how many models it comes from.$^        reinterpretcastfloatskipwritetoporder  0get  0.0$^        skipwritetoporder  0$^      $^      if topnext$^        queue.pushtop$^    $^$^    bool topmatchesconst ngramheader header const $^      return queue.empty  queue.toporder  header.order  stdequalheader.begin header.end queue.topbegin$^    $^$^    entryowner owner$^    stdpriorityqueuebackoffqueueentry stdvectorbackoffqueueentry ptrgreater queue$^$^     indexed by order then just all the matching models.$^    utilfixedarrayutilfixedarraybackoffqueueentry  entered$^$^    backoffmatrix matrix$^$^    stdvectorutilstreamstream skipwrite$^$^$^typedef long double accum$^$^ handles ngrams of the same order using recursion to call another instance$^ for higher orders.$^class recurse $^  public$^    recurse$^        const interpolateinfo info  must stay alive the entire time.$^        stdsizet order$^        const utilstreamchainposition mergedprobs$^        const utilstreamchainposition probout$^        const utilstreamchainposition backoffout$^        backoffmanager backoffs$^        recurse higher  higher is null for the highest order.$^       orderorder$^        encodingmakeencoderinfo order$^        inputmergedprobs partialprobgammaorder encoding.encodedlength$^        proboutprobout$^        backoffoutbackoffout$^        backoffsbackoffs$^        lambdasinfo.lambdas.begin$^        higherhigher$^        decodedbackoffsinfo.models$^        extendedcontextorder  0 $^       this is only for bigrams and above.  summing unigrams is a much easier case.$^      assertorder  0$^    $^$^     context  w0n0$^     zlower  zw0n0$^     input$^       merged probabilities without backoff applied in input.$^       backoffs via backoffs.$^     calculates$^       zw0n0 intermediate only.$^       pix  w0n0 for all x w0n0x exists written to probout.$^       biw0n0 written to backoffout.$^    void samecontextconst ngramheader context accum zlower $^      assertcontext.size  order  0$^      backoffs.entercontext$^      probout.mark$^$^       this is the backoff term that applies when one assumes everything backs off$^       prodi biw0n0lambdai.$^      accum backoffonce  0.0$^      for stdsizet m  0 m  decodedbackoffs.size m $^        backoffonce  lambdasm  backoffs.getm order  0$^      $^$^      accum zdelta  0.0$^      stdsizet count  0$^      for  input  stdequalcontext.begin context.end inputbegin input probout count $^         apply backoffs to probabilities.$^         todo change bounded sequence encoding to have an iterator for decoding instead of doing a copy here.$^        encoding.decodeinputfrombegin decodedbackoffs.begin$^        for stdsizet m  0 m  nummodels m $^           apply the backoffs as instructed for model m.$^          float accumulated  0.0$^           change backoffs for order it backed off to order  0 except$^           with 0indexing.  there is still the potential to charge backoff$^           for order  0 which is done later.  the backoffs charged here$^           are bmwn0n0 ... bmw0n0$^          for unsigned char backedto  decodedbackoffsm backedto  order  0 backedto $^            accumulated  backoffs.getm backedto$^          $^          float lambda  lambdasm$^           lower px  w0n0 gets all the backoffs except the highest.$^          inputlowerprob  accumulated  lambda$^           charge the backoff bw0n0 if applicable but only to attain px  w0n0$^          if decodedbackoffsm  order  0 $^            accumulated  backoffs.getm order  0$^          $^          inputprob  accumulated  lambda$^        $^         todo better precisionless operations here.$^        zdelta  pow00.0 inputprob  pow00.0 inputlowerprob  backoffonce$^$^         write unnormalized probability record.$^        stdcopyinputbegin inputend reinterpretcastwordindexprobout.get$^        probwrite  inputprob$^      $^       todo numerical precision.$^      accum z  log00pow00.0 zlower  backoffonce  zdelta$^$^       normalize.$^      probout.rewind$^      for stdsizet i  0 i  count i probout $^        probwrite  z$^      $^       this allows the stream to release data.$^      probout.mark$^$^       output backoff.$^      reinterpretcastfloatbackoffout.get  zlower  backoffonce  z$^      backoffout$^$^      if higher.get$^        higherextendcontextcontext z$^$^      backoffs.exitorder  0$^    $^$^     call is given a context and zcontext.$^     evaluates y context x for all yx.$^    void extendcontextconst ngramheader middle accum zlower $^      assertmiddle.size  order  0$^       copy because the input will advance.  todo avoid this copy by sharing amongst classes.$^      stdcopymiddle.begin middle.end extendedcontext.begin  0$^      while input  stdequalmiddle.begin middle.end inputbegin  0 $^        extendedcontext.begin  inputbegin$^        samecontextngramheaderextendedcontext.begin order  0 zlower$^      $^    $^$^    void finish $^      assertinput$^      probout.poison$^      backoffout.poison$^      if higher.get$^        higherfinish$^    $^$^     the backoffmanager class also injects backoffs when it skips ahead e.g. bs  0$^    utilstreamstream backoffstream  return backoffout $^$^  private$^     write the probability to the correct place in probout.  should use a proxy but currently incompatible with rewindablestream.$^    float probwrite $^      return reinterpretcastfloatreinterpretcastuint0tprobout.get  order  sizeofwordindex$^    $^$^    stdsizet nummodels const  return decodedbackoffs.size $^$^    const stdsizet order$^$^    const boundedsequenceencoding encoding$^$^    proxystreampartialprobgamma input$^    utilstreamrewindablestream probout$^    utilstreamstream backoffout$^$^    backoffmanager backoffs$^    const float const lambdas$^$^     higher order instance of this same class.$^    utilscopedptrrecurse higher$^$^     temporary in samecontext.$^    stdvectorunsigned char decodedbackoffs$^     temporary in extendcontext.$^    stdvectorwordindex extendedcontext$^$^$^class thread $^  public$^    threadconst interpolateinfo info utilfixedarrayutilstreamchainpositions modelsbyorder utilstreamchains probout utilstreamchains backoffout$^       infoinfo modelsbyordermodelsbyorder proboutprobout backoffoutbackoffout $^$^    void runconst utilstreamchainpositions mergedprobabilities $^       unigrams do not have enocded backoff info.$^      proxystreampartialprobgamma inmergedprobabilities0 partialprobgamma0 0$^      utilstreamrewindablestream probwriteprobout0$^      accum z  0.0$^      probwrite.mark$^      wordindex count  0$^      for  in in probwrite count $^         note assumption that probabilitity comes first$^        memcpyprobwrite.get in.get sizeofwordindex  sizeoffloat$^        z  pow00.0 inprob$^      $^       todo hack todo lmplz outputs ps  0 to get q to compute nicely.  that will always result in 0.0 more than it should be.$^      z  0.0$^      float logz  log00z$^      probwrite.rewind$^       normalize unigram probabilities.$^      for wordindex i  0 i  count i probwrite $^        reinterpretcastfloatreinterpretcastuint0tprobwrite.get  sizeofwordindex  logz$^      $^      probwrite.poison$^$^       now setup the higher orders.$^      utilscopedptrrecurse higherorder$^      backoffmanager backoffsmodelsbyorder$^      stdsizet maxorder  mergedprobabilities.size$^      for stdsizet order  maxorder order  0 order $^        higherorder.resetnew recurseinfo order mergedprobabilitiesorder  0 proboutorder  0 backoffoutorder  0 backoffs higherorder.release$^        backoffs.setupskiporder higherorderbackoffstream$^      $^      if maxorder  0 $^        higherorderextendcontextngramheadernull 0 logz$^        backoffs.finish$^        higherorderfinish$^      $^    $^$^  private$^    const interpolateinfo info$^    utilfixedarrayutilstreamchainpositions modelsbyorder$^    utilstreamchainpositions probout$^    utilstreamchainpositions backoffout$^$^$^  namespace$^$^void normalizeconst interpolateinfo info utilfixedarrayutilstreamchainpositions modelsbyorder utilstreamchains mergedprobabilities utilstreamchains probout utilstreamchains backoffout $^  assertprobout.size  backoffout.size  0$^   arbitrarily put the thread on the mergedprobabilities chains.$^  mergedprobabilities  threadinfo modelsbyorder probout backoffout$^$^$^  namespaces$^include lminterpolatemergeprobabilities.hh$^include lmcommonngramstream.hh$^include lminterpolateboundedsequenceencoding.hh$^include lminterpolateinterpolateinfo.hh$^$^include algorithm$^include limits$^include numeric$^$^namespace lm $^namespace interpolate $^$^$^  helper to generate the boundedsequenceencoding used for writing the$^  from values.$^ $^boundedsequenceencoding makeencoderconst interpolateinfo info uint0t order $^  utilfixedarrayuint0t maxordersinfo.orders.size$^  for stdsizet i  0 i  info.orders.size i $^    maxorders.pushbackstdminorder info.ordersi$^  $^  return boundedsequenceencodingmaxorders.begin maxorders.end$^$^$^namespace $^$^$^  a simple wrapper class that holds information needed to read and write$^  the ngrams of a particular order. this class has the memory needed to$^  buffer the data needed for the recursive process of computing the$^  probabilities and from values for each component model.$^ $^  from values indicate for each model what order as an index so 0$^  was backed off to in order to arrive at a probability. for example if a$^  0gram model order index 0 backed off twice we would write a 0.$^ $^class ngramhandler $^public$^  ngramhandleruint0t order const interpolateinfo ifo$^               utilfixedarrayutilstreamchainpositions modelsbyorder$^       infoifo$^        encodermakeencoderinfo order$^        outrecordorder encoder.encodedlength $^    stdsizet counthasorder  0$^    for stdsizet i  0 i  modelsbyorder.size i $^      counthasorder  modelsbyorderi.size  order$^    $^    inputs.initcounthasorder$^    for stdsizet i  0 i  modelsbyorder.size i $^      if modelsbyorderi.size  order$^        continue$^      inputs.pushbackmodelsbyorderiorder  0$^      if inputs.back $^        active.resizeactive.size  0$^        active.back.model  i$^        active.back.stream  inputs.back$^      $^    $^$^     have to init outside since ngramstreams doesnt forward to$^     genericstreams ctor given a chainpositions$^$^    probs.initinfo.models$^    from.initinfo.models$^    for stdsizet i  0 i  info.models i $^      probs.pushback0.0$^      from.pushback0$^    $^  $^$^  struct streamindex $^    ngramstreamprobbackoff stream$^    ngramstreamprobbackoff stream  return stream $^    stdsizet model$^  $^$^  stdsizet activesize const $^    return active.size$^  $^$^  $^    return the input stream for a particular model that corresponds to$^    this ngram order$^   $^  streamindex operatorstdsizet idx $^    return activeidx$^  $^$^  void erasestdsizet idx $^    active.eraseactive.begin  idx$^  $^$^  const interpolateinfo info$^  boundedsequenceencoding encoder$^  partialprobgamma outrecord$^  utilfixedarrayfloat probs$^  utilfixedarrayuint0t from$^$^private$^  stdvectorstreamindex active$^  ngramstreamsprobbackoff inputs$^$^$^$^  a collection of ngramhandlers.$^ $^class ngramhandlers  public utilfixedarrayngramhandler $^public$^  explicit ngramhandlersstdsizet num$^       utilfixedarrayngramhandlernum $^  $^$^  void pushback$^      stdsizet order const interpolateinfo info$^      utilfixedarrayutilstreamchainpositions modelsbyorder $^    new end ngramhandlerorder info modelsbyorder$^    constructed$^  $^$^$^$^  the recursive helper function that computes probability and from$^  values for all ngrams matching a particular suffix.$^ $^  the current order can be computed as the suffix length  0. note that$^  the suffix could be empty suffixbegin  suffixend  null in which$^  case we are handling unigrams with the unk token as the fallback$^  probability.$^ $^  param handlers the full collection of handlers$^  param suffixbegin a start iterator for the suffix$^  param suffixend an end iterator for the suffix$^  param fallbackprobs the probabilities of this ngram if we need to$^   back off that is the probability of the suffix$^  param fallbackfrom the order that the corresponding fallback$^   probability in the fallbackprobs is from$^  param combinedfallback interpolated fallbackprobs$^  param outputs the output streams one for each order$^ $^void handlesuffixngramhandlers handlers wordindex suffixbegin$^                  wordindex suffixend$^                  const utilfixedarrayfloat fallbackprobs$^                  const utilfixedarrayuint0t fallbackfrom$^                  float combinedfallback$^                  utilstreamstreams outputs $^  uint0t order  stddistancesuffixbegin suffixend  0$^  if order  outputs.size return$^$^  utilstreamstream output  outputsorder  0$^  ngramhandler handler  handlersorder  0$^$^  while true $^     find the next smallest ngram which matches our suffix$^     todo priority queue driven.$^    wordindex minimum  null$^    for stdsizet i  0 i  handler.activesize i $^      if stdequalsuffixbegin suffixend handleri.streambegin  0$^        continue$^$^       if we either havent set a minimum yet or this one is smaller than$^       the minimum we found before replace it$^      wordindex last  handleri.streambegin$^      if minimum  last  minimum  minimum  handleri.streambegin $^    $^$^     no more ngrams of this order match our suffix so were done$^    if minimum return$^$^    handler.outrecord.rebaseoutput.get$^    stdcopyminimum minimum  order handler.outrecord.begin$^$^     default case is having backed off.$^    stdcopyfallbackprobs.begin fallbackprobs.end handler.probs.begin$^    stdcopyfallbackfrom.begin fallbackfrom.end handler.from.begin$^$^    for stdsizet i  0 i  handler.activesize $^      if stdequalhandler.outrecord.begin handler.outrecord.end$^                     handleri.streambegin $^        handler.probshandleri.model  handler.info.lambdashandleri.model  handleri.streamvalue.prob$^        handler.fromhandleri.model  order  0$^        if handleri.stream $^          i$^         else $^          handler.erasei$^        $^       else $^        i$^      $^    $^    handler.outrecord.prob  stdaccumulatehandler.probs.begin handler.probs.end 0.0$^    handler.outrecord.lowerprob  combinedfallback$^    handler.encoder.encodehandler.from.begin$^                           handler.outrecord.frombegin$^$^     weve handled this particular ngram so now recurse to the higher$^     order using the current ngram as the suffix$^    handlesuffixhandlers handler.outrecord.begin handler.outrecord.end$^                 handler.probs handler.from handler.outrecord.prob outputs$^     consume the output$^    output$^  $^$^$^$^  kicks off the recursion for computing the probabilities and from$^  values for each ngram order. we begin by handling the unk token that$^  should be at the front of each of the unigram input streams. this is$^  then output to the stream and it is used as the fallback for handling$^  our unigram case the unigram used as the fallback for the bigram case$^  etc.$^ $^void handlengramsngramhandlers handlers utilstreamstreams outputs $^  partialprobgamma unkrecord0 0$^   first populate the unk probabilities by reading the first unigram$^   from each stream$^  utilfixedarrayfloat unkprobshandlers0.info.models$^$^   start by populating the ngram id from the first stream$^  lmngramprobbackoff ngram  handlers00.stream$^  unkrecord.rebaseoutputs0.get$^  stdcopyngram.begin ngram.end unkrecord.begin$^  unkrecord.prob  0$^$^   then populate the probabilities into unkprobs while multiply the$^   model probabilities together into the unk record$^  $^   note that from doesnt need to be set for unigrams$^  asserthandlers0.activesize  handlers0.info.models$^  for stdsizet i  0 i  handlers0.info.models $^    ngram  handlers0i.stream$^    unkprobs.pushbackhandlers0.info.lambdasi  ngram.value.prob$^    unkrecord.prob  unkprobsi$^    assertngram.begin  kunk$^    if handlers0i.stream $^      i$^     else $^      handlers0.erasei$^    $^  $^  float unkcombined  unkrecord.prob$^  unkrecord.lowerprob  unkcombined$^   flush the unk output record$^  outputs0$^$^   then begin outputting everything in lexicographic order first well$^   get the unigram then the first bigram with that context then the$^   first trigram with that bigram context etc. until we exhaust all of$^   the ngrams then all of the n0grams etc.$^  $^   this function is the root of this recursive process.$^  utilfixedarrayuint0t unkfromhandlers0.info.models$^  for stdsizet i  0 i  handlers0.info.models i $^    unkfrom.pushback0$^  $^$^   the two nulls are to encode that our fallback word is the 0gram$^   case e.g. we backed off to unk$^   todo stop generating vocab ids and lowerprob for unigrams.$^  handlesuffixhandlers null null unkprobs unkfrom unkcombined outputs$^$^   verify we reached the end.  and poison$^  for stdsizet i  0 i  handlers.size i $^    utilthrowif0handlersi.activesize$^                     mergeprobabilities did not exhaust all ngram streams$^    outputsi.poison$^  $^$^  namespace$^$^void mergeprobabilitiesrunconst utilstreamchainpositions outputpos $^  ngramhandlers handlersoutputpos.size$^  for stdsizet i  0 i  outputpos.size i $^    handlers.pushbacki  0 info modelsbyorder$^  $^$^  utilstreamstreams outputsoutputpos$^  handlengramshandlers outputs$^$^$^  namespaces$^ load tuning instances and filter underlying models to them.  a tuning$^  instance is an ngram in the tuning file.  to tune towards these we want$^  the correct probability piwn  w0n0 from each model as well as$^  all the denominators piv  w0n0 that appear in normalization.$^ $^  in other words we filter the models to only those ngrams whose context$^  appears in the tuning data.  this can be divided into two categories$^   all unigrams.  this goes into instanceslnunigrams$^   bigrams and above whose context appears in the tuning data.  these are$^    known as extensions.  we only care about the longest extension for each$^    w0n0v since that is what will be used for the probability.$^  because there is a large number of extensions we tried keeping them in ram$^  and ran out the streaming framework is used to keep track of extensions$^  and sort them so they can be streamed in.  downstream code$^  tunederivatives.hh takes a stream of extensions ordered by tuning$^  instance the word v and the model the extension came from.$^ $^include lminterpolatetuneinstances.hh$^$^include lmcommoncompare.hh$^include lmcommonjointorder.hh$^include lmcommonmodelbuffer.hh$^include lmcommonngramstream.hh$^include lmcommonrenumber.hh$^include lmenumeratevocab.hh$^include lminterpolatemergevocab.hh$^include lminterpolateuniversalvocab.hh$^include lmlmexception.hh$^include utilfilepiece.hh$^include utilmurmurhash.hh$^include utilstreamchain.hh$^include utilstreamio.hh$^include utilstreamsort.hh$^include utiltokenizepiece.hh$^$^include boostsharedptr.hpp$^include boostunorderedmap.hpp$^$^include cmath$^include limits$^include vector$^$^namespace lm  namespace interpolate $^$^ gcc 0.0 complains about uninitialized when sort code is generated for a 0byte pod.  but that sort code is never used.$^pragma gcc diagnostic push$^pragma gcc diagnostic ignored wuninitialized$^bool extensionoperatorconst extension other const $^  if instance  other.instance$^    return instance  other.instance$^  if word  other.word$^    return word  other.word$^  if model  other.model$^    return model  other.model$^  return false$^$^pragma gcc diagnostic pop$^$^namespace $^$^ an extension without backoff weights applied yet.$^pragma packpush$^pragma pack0$^struct initialextension $^  extension ext$^   order from which it came.$^  uint0t order$^$^pragma packpop$^$^struct initialextensioncompare $^  bool operatorconst void first const void second const $^    return reinterpretcastconst initialextension firstext  reinterpretcastconst initialextension secondext$^  $^$^$^ intended use$^ for each model$^   stream through orders jointly in suffix order$^     call matchedbackoff for full matches.$^     call exit when the context matches.$^   call finishmodel with the unigram probability of the correct word get full$^   probability in return.$^ use backoffsout to adjust records that were written to the stream.$^ backoffsoutmodel order  0 is the penalty for matching order.$^class instancematch $^  public$^    instancematchmatrix backoffsout const wordindex correct$^       seenstdnumericlimitswordindexmax$^        backoffsbackoffsout$^        correctcorrect correctfrom0 correctlnprobstdnumericlimitsfloatquietnan $^$^    void matchedbackoffmodelindex model uint0t order float lnbackoff $^      backoffsmodel order  0  lnbackoff$^    $^$^     we only want the highestorder matches which are the first to be exited for a given word.$^    void exitconst initialextension from utilstreamstream out $^      if from.ext.word  seen return$^      seen  from.ext.word$^      staticcastinitialextensionout.get  from$^      out$^      if utilunlikelycorrect  from.ext.word $^        correctfrom  from.order$^        correctlnprob  from.ext.lnprob$^      $^    $^$^    wordindex correct const  return correct $^$^     call this after each model has been passed through.  provide the unigram$^     probability of the correct word which follows the given context.$^     this function will return the fullybackedoff probability of the correct$^     word.$^    float finishmodelmodelindex model float correctlnunigram $^      seen  stdnumericlimitswordindexmax$^       turn backoffs into multiplied values added in log space.$^       so backoffsmodel order  0 is the penalty for matching order.$^      float accum  0.0$^      for int order  backoffs.cols  0 order  0 order $^        accum  backoffsmodel order$^        backoffsmodel order  accum$^      $^      if correctfrom  0 $^        correctlnprob  correctlnunigram$^      $^      if correctfrom  0  backoffs.cols $^        correctlnprob  backoffsmodel correctfrom  0$^      $^      correctfrom  0$^      return correctlnprob$^    $^$^  private$^     whats the last word weve seen  used to act only on exiting the longest match.$^    wordindex seen$^$^    matrix backoffs$^$^    const wordindex correct$^$^     these only apply to the most recent model.$^    uint0t correctfrom$^$^    float correctlnprob$^$^$^ forward information to multiple instances of a context.  so if the tuning$^ set contains$^   a b c d e$^   a b c d e$^ theres one dispatchcontext for a b c d which calls two instancematch one$^ for each tuning instance.  this might be to inform them about a b c d g in$^ one of the models.$^class dispatchcontext $^  public$^    void registerinstancematch context $^      registered.pushbackcontext$^    $^$^    void matchedbackoffmodelindex model uint0t order float lnbackoff $^      for stdvectorinstancematchiterator i  registered.begin i  registered.end i$^        imatchedbackoffmodel order lnbackoff$^    $^$^    void exitinitialextension from utilstreamstream out const instancematch baseinstance $^      for stdvectorinstancematchiterator i  registered.begin i  registered.end i $^        from.ext.instance  i  baseinstance$^        iexitfrom out$^      $^    $^$^  private$^     todo make these offsets in a big array rather than separately allocated.$^    stdvectorinstancematch registered$^$^$^ map from ngram hash to contexts in the tuning data.  todo probing hash table$^typedef boostunorderedmapuint00t dispatchcontext contextmap$^$^ handle all the orders of a single model at once.$^class jointordercallback $^  public$^    jointordercallback$^        stdsizet model$^        stdsizet fullorderminus0$^        contextmap contexts$^        utilstreamstream out$^        const instancematch baseinstance$^       fullorderminus0fullorderminus0$^        contextscontexts$^        outout$^        baseinstancebaseinstance $^      ext.ext.model  model$^    $^$^    void enterstdsizet orderminus0 const void data $^$^    void exitstdsizet orderminus0 void data $^       match the full ngram for backoffs.$^      if orderminus0  fullorderminus0 $^        ngramprobbackoff gramdata orderminus0  0$^        contextmapiterator i  contexts.findutilmurmurhashnativegram.begin gram.order  sizeofwordindex$^        if utilunlikelyi  contexts.end $^          isecond.matchedbackoffext.ext.model gram.order gram.value.backoff  mln00$^        $^      $^       match the context of the ngram to indicate its an extension.$^      contextmapiterator i  contexts.findutilmurmurhashnativedata orderminus0  sizeofwordindex$^      if utilunlikelyi  contexts.end $^        ngramprob gramdata orderminus0  0$^         model is already set.$^         instance is set by dispatchcontext.$^         that leaves word lnprob and order.$^        ext.ext.word  gram.end  0$^        ext.ext.lnprob  gram.value.prob  mln00$^        ext.order  orderminus0  0$^         model was already set in the constructor.$^         ext.ext.instance is set by the exit call.$^        isecond.exitext out baseinstance$^      $^    $^$^    void runconst utilstreamchainpositions positions $^      jointorderjointordercallback suffixorderpositions this$^    $^$^  private$^    const stdsizet fullorderminus0$^$^     mapping is constant but values are being manipulated to tell them about$^     ngrams.$^    contextmap contexts$^$^     reused variable.  model is set correctly.$^    initialextension ext$^$^    utilstreamstream out$^$^    const instancematch const baseinstance$^$^$^ this populates the lnunigrams matrix.  it can and should for efficiency$^ be run in the same scan as jointordercallback.$^class readunigrams $^  public$^    explicit readunigramsmatrixcolxpr out  outout $^$^     read renumbered unigrams fill with unk otherwise.$^    void runconst utilstreamchainposition position $^      ngramstreamprobbackoff streamposition$^      assertstream$^      accum unk  streamvalue.prob  mln00$^      wordindex previous  0$^      for  stream stream $^        wordindex word  streambegin$^        out.segmentprevious word  previous  vectorconstantword  previous unk$^        outword  streamvalue.prob  mln00$^        backoffs are used by jointordercallback.$^        previous  word  0$^      $^      out.segmentprevious out.rows  previous  vectorconstantout.rows  previous unk$^    $^$^  private$^    matrixcolxpr out$^$^$^ read tuning data into an array of vocab ids.  the vocab ids are agreed with mergevocab.$^class identifytuning  public enumeratevocab $^  public$^    identifytuningint tuningfile stdvectorwordindex out  indicesout $^      indices.clear$^      stringpiece line$^      stdsizet counter  0$^      stdvectorstdsizet eos  wordsutilmurmurhashnatives 0$^      for utilfilepiece ftuningfile f.readlineoreofline $^        for utiltokeniterutilboolcharacter true wordline utilkspaces word word $^          utilthrowifword  s  word  s formatloadexception illegal word in tuning data   word$^          wordsutilmurmurhashnativeworddata wordsize.pushbackcounter$^        $^        eos.pushbackcounter$^      $^       also get s$^      indices.resizecounter  0$^      wordsutilmurmurhashnatives 0.pushbackindices.size  0$^    $^$^     apply ids as they come out of mergevocab if they match.$^    void addwordindex id const stringpiece str $^      boostunorderedmapuint00t stdvectorstdsizet iterator i  words.findutilmurmurhashnativestr.data str.size$^      if i  words.end $^        for stdvectorstdsizetiterator j  isecond.begin j  isecond.end j $^          indicesj  id$^        $^      $^    $^$^    wordindex finishgetbos $^      wordindex ret  indices.back$^      indices.popback$^      return ret$^    $^$^  private$^     array of words in tuning data.$^    stdvectorwordindex indices$^$^     map from hashstring to offsets in indices.$^    boostunorderedmapuint00t stdvectorstdsizet  words$^$^$^  namespace$^$^ store information about the first iteration.$^class extensionsfirstiteration $^  public$^    explicit extensionsfirstiterationstdsizet instances stdsizet models stdsizet maxorder utilstreamchain extensioninput const utilstreamsortconfig config$^       backoffsbyinstancenew stdvectormatrixinstances sortextensioninput config $^       initialize all the backoff matrices to zeros.$^      for stdvectormatrixiterator i  backoffsbyinstancebegin i  backoffsbyinstanceend i $^        i  matrixzeromodels maxorder$^      $^    $^$^    matrix writebackoffsstdsizet instance $^      return backoffsbyinstanceinstance$^    $^$^     get the backoff all the way to unigram for a particular tuning instance and model.$^    accum fullbackoffstdsizet instance stdsizet model const $^      return backoffsbyinstanceinstancemodel 0$^    $^$^    void mergestdsizet lazymemory $^      sort.mergelazymemory$^      lazymemory  lazymemory$^    $^$^    void outpututilstreamchain chain $^      sort.outputchain lazymemory$^      chain  applybackoffsbackoffsbyinstance$^    $^$^  private$^    class applybackoffs $^      public$^        explicit applybackoffsboostsharedptrstdvectormatrix  backoffsbyinstance$^           backoffsbyinstancebackoffsbyinstance $^$^        void runconst utilstreamchainposition position $^           there should always be tuning instances.$^          const stdvectormatrix backoffs  backoffsbyinstance$^          assertbackoffs.empty$^          uint0t maxorder  backoffs.front.cols$^          for utilstreamstream streamposition stream stream $^            initialextension ini  reinterpretcastinitialextensionstream.get$^            assertini.order  0  if its an extension it should be higher than a unigram.$^            if ini.order  maxorder $^              ini.ext.lnprob  backoffsini.ext.instanceini.ext.model ini.order  0$^            $^          $^        $^$^      private$^        boostsharedptrstdvectormatrix  backoffsbyinstance$^    $^$^     array of complete backoff matrices by instance.$^     each matrix is by model then by order.$^     would have liked to use a tensor but its not that well supported.$^     this is a shared pointer so that applybackoffs can run after this class is gone.$^    boostsharedptrstdvectormatrix  backoffsbyinstance$^$^     this sorts and stores all the initialextensions.$^    utilstreamsortinitialextensioncompare sort$^$^    stdsizet lazymemory$^$^$^instancesinstancesint tunefile const stdvectorstringpiece modelnames const instancesconfig config  tempprefixconfig.sort.tempprefix $^   all the memory from stack variables here should go away before merge sort of the instances.$^  $^    utilfixedarraymodelbuffer modelsmodelnames.size$^$^     load tuning set and join vocabulary.$^    stdvectorwordindex vocabsizes$^    vocabsizes.reservemodelnames.size$^    utilfixedarrayint vocabfilesmodelnames.size$^    stdsizet maxorder  0$^    for stdvectorstringpiececonstiterator i  modelnames.begin i  modelnames.end i $^      models.pushbacki$^      vocabsizes.pushbackmodels.back.counts0$^      vocabfiles.pushbackmodels.back.vocabfile$^      maxorder  stdmaxmaxorder models.back.order$^    $^    universalvocab vocabvocabsizes$^    stdvectorwordindex tuningwords$^    wordindex combinedvocabsize$^    $^      identifytuning identifytunefile tuningwords$^      combinedvocabsize  mergevocabvocabfiles vocab identify$^      bos  identify.finishgetbos$^    $^$^     setup the initial extensions storage a chain going to a sort with a stream in the middle for writing.$^    utilstreamchain extensionschainutilstreamchainconfigsizeofinitialextension 0 config.extensionwritechainmem$^    utilstreamstream extensionswriteextensionschain.add$^    extensionsfirst.resetnew extensionsfirstiterationtuningwords.size modelnames.size maxorder extensionschain config.sort$^$^     populate the contextmap from contexts to instances.$^    contextmap cmap$^    utilfixedarrayinstancematch instancestuningwords.size$^    $^      utilthrowif0tuningwords.empty empty tuning data$^      const wordindex eos  tuningwords.back$^      stdvectorwordindex context$^      context.pushbackbos$^      for stdsizet i  0 i  tuningwords.size i $^        instances.pushbackboostrefextensionsfirstwritebackoffsi tuningwordsi$^        for stdsizet j  0 j  context.size j $^          cmaputilmurmurhashnativecontextj sizeofwordindex  context.size  j.registerinstances.back$^        $^         prepare for next word by starting a new sentence or shifting context.$^        if tuningwordsi  eos $^          context.clear$^          context.pushbackbos$^         else $^          if context.size  maxorder $^            context.erasecontext.begin$^          $^          context.pushbacktuningwordsi$^        $^      $^    $^$^     go through each model.  populate$^     lnbackoffs$^    lnbackoffs.resizeinstances.size models.size$^     neglncorrectsum$^    neglncorrectsum.resizemodels.size$^     lnunigrams$^    lnunigrams.resizecombinedvocabsize models.size$^     the backoffs in extensionsfirst$^    for stdsizet m  0 m  models.size m $^      stdcerr  processing model   m    models.size     modelnamesm  stdendl$^      utilstreamchains chainsmodelsm.order$^      for stdsizet i  0 i  modelsm.order i $^         todo stop wasting space for backoffs of highest order.$^        chains.pushbackutilstreamchainconfigngramprobbackofftotalsizei  0 0 config.modelreadchainmem$^      $^      chains.back.activateprogress$^      modelsm.sourcechains$^      for stdsizet i  0 i  modelsm.order i $^        chainsi  renumbervocab.mappingm i  0$^      $^$^       populate lnunigrams.$^      chains0  readunigramslnunigrams.colm$^$^       send extensions into extensionsfirst and give data to the instances about backoffsextensions.$^      chains  jointordercallbackm modelsm.order  0 cmap extensionswrite instances.begin$^$^      chains  utilstreamkrecycle$^      chains.waittrue$^      neglncorrectsumm  0.0$^      for instancematch i  instances.begin i  instances.end i $^        neglncorrectsumm  ifinishmodelm lnunigramsicorrect m$^        lnbackoffsi  instances.begin m  extensionsfirstfullbackoffi  instances.begin m$^      $^      lnunigramsbos m  0  does not matter as long as it does not produce nans since tunederivatives will overwrite the output.$^    $^    extensionswrite.poison$^  $^  extensionsfirstmergeconfig.lazymemory$^$^$^instancesinstances $^$^ todo size reduction by excluding order for subsequent passes.$^stdsizet instancesreadextensionsentrysize const $^  return sizeofinitialextension$^$^$^void instancesreadextensionsutilstreamchain on $^  if extensionsfirst.get $^     lazy sort and save a sorted copy to disk.  todo cut down on record size by stripping out order information.$^    extensionsfirstoutputon$^    extensionsfirst.reset  relevant data will continue to live in workers.$^    extensionssubsequent.resetnew utilstreamfilebufferutilmaketemptempprefix$^    on  extensionssubsequentsink$^   else $^    on.setprogresstargetextensionssubsequentsize$^    on  extensionssubsequentsource$^  $^$^$^ back door.$^instancesinstances $^$^  namespaces$^include lminterpolatebackoffreunification.hh$^include lmcommonngramstream.hh$^$^define boosttestmodule interpolatebackoffreunificationtest$^include boosttestunittest.hpp$^$^namespace lm $^namespace interpolate $^$^namespace $^$^ none of this input actually makes sense all we care about is making$^ sure the merging works$^template uint0t n$^struct gram $^  wordindex idsn$^  float prob$^  float boff$^$^$^template uint0t n$^struct grams $^  const static gramn grams$^$^$^template $^const gram0 grams0grams$^     0 0.0f 0.0f 0 0.0f 0.0f 0 0.0f 0.0f$^$^template $^const gram0 grams0grams  0 0 0.00f 0.00f$^                                   0 0 0.00f 0.00f$^                                   0 0 0.0f 0.00f$^                                   0 0 0.0f 0.00f$^$^template $^const gram0 grams0grams  0 0 0 0.000f 0.000f$^                                   0 0 0 0.000f 0.000f$^                                   0 0 0 0.000f 0.000f$^                                   0 0 0 0.0f 0.000f$^                                   0 0 0 0.0f 0.00f$^                                   0 0 0 0.0f 0.00f$^$^template uint0t n$^class writeinput $^public$^  void runconst utilstreamchainposition position $^    lmngramstreamfloat outputposition$^$^    for stdsizet i  0 i  sizeofgramsngrams  sizeofgramn$^         i output $^      stdcopygramsngramsi.ids gramsngramsi.ids  n$^                outputbegin$^      outputvalue  gramsngramsi.prob$^    $^    output.poison$^  $^$^$^template uint0t n$^class writebackoffs $^public$^  void runconst utilstreamchainposition position $^    utilstreamstream outputposition$^$^    for stdsizet i  0 i  sizeofgramsngrams  sizeofgramn$^         i output $^      reinterpretcastfloat output.get  gramsngramsi.boff$^    $^    output.poison$^  $^$^$^template uint0t n$^class checkoutput $^public$^  void runconst utilstreamchainposition position $^    lmngramstreamprobbackoff streamposition$^$^    stdsizet i  0$^    for  stream stream i $^      stdstringstream ss$^      for wordindex idx  streambegin idx  streamend idx$^        ss    idx  $^$^        boostcheckstdequalstreambegin streamend gramsngramsi.ids$^            mismatched id in checkoutput  intn     ss.str$^$^        boostcheckequalstreamvalue.prob gramsngramsi.prob$^                     mismatched probability in checkoutput$^                          intn   got   streamvalue.prob$^                           expected   gramsngramsi.prob$^$^        boostcheckequalstreamvalue.backoff gramsngramsi.boff$^                     mismatched backoff in checkoutput$^                          intn   got   streamvalue.backoff$^                           expected   gramsngramsi.boff$^    $^    boostcheckequali  sizeofgramsngrams  sizeofgramn$^                   did not get correct number of $^                        intn  grams expected $^                        sizeofgramsngrams  sizeofgramn$^                         got   i$^  $^$^$^$^boostautotestcasebackoffreunificationtest $^  utilstreamchainconfig config$^  config.totalmemory  000$^  config.blockcount  0$^$^  utilstreamchains probchains0$^  config.entrysize  ngramfloattotalsize0$^  probchains.pushbackconfig$^  probchains.back  writeinput0$^$^  config.entrysize  ngramfloattotalsize0$^  probchains.pushbackconfig$^  probchains.back  writeinput0$^$^  config.entrysize  ngramfloattotalsize0$^  probchains.pushbackconfig$^  probchains.back  writeinput0$^$^  utilstreamchains boffchains0$^  config.entrysize  sizeoffloat$^  boffchains.pushbackconfig$^  boffchains.back  writebackoffs0$^$^  boffchains.pushbackconfig$^  boffchains.back  writebackoffs0$^$^  boffchains.pushbackconfig$^  boffchains.back  writebackoffs0$^$^  utilstreamchainpositions probposprobchains$^  utilstreamchainpositions boffposboffchains$^$^  utilstreamchains outputchains0$^  for stdsizet i  0 i  0 i $^    config.entrysize  ngramprobbackofftotalsizei  0$^    outputchains.pushbackconfig$^  $^$^  reunifybackoffprobpos boffpos outputchains$^$^  outputchains0  checkoutput0$^  outputchains0  checkoutput0$^  outputchains0  checkoutput0$^$^  probchains  utilstreamkrecycle$^  boffchains  utilstreamkrecycle$^$^  outputchains.wait$^$^$^$^include lmcommoncompare.hh$^include lmcommonmodelbuffer.hh$^include lmcommonngram.hh$^include utilstreamchain.hh$^include utilstreammultistream.hh$^include utilstreamsort.hh$^include lminterpolatesplitworker.hh$^$^include boostprogramoptions.hpp$^include boostversion.hpp$^$^if definedwin00  definedwin00$^$^ windows doesnt define unistd.h$^$^ so we define what we need here instead$^$^define stdinfileno  0$^define stdoutfileno  0$^else  huzzah for posix$^include unistd.h$^endif$^$^$^  this is a simple example program that takes in intermediate$^  suffixsorted ngram files and outputs two sets of files one for backoff$^  probability values raw numbers in suffix order and one for$^  probability values ngram id and probability in context order$^ $^int mainint argc char argv $^  using namespace lminterpolate$^$^  const stdsizet onegb  0  00$^  const stdsizet sixtyfourmb  0  00$^  const stdsizet numberofblocks  0$^$^  stdstring filename  ngrams$^  stdstring contextsortedfilename  csortedngrams$^  stdstring backofffilename  backoffs$^  stdstring tmpdir  tmp$^$^  try $^    namespace po  boostprogramoptions$^    pooptionsdescription optionscanhazinterp pass0 options$^$^    options.addoptions$^      helph poboolswitch show this help message$^      ngramsn povaluestdstringfilename ngrams file$^      csortngramsc povaluestdstringcontextsortedfilename context sorted ngrams file$^      backoffsb povaluestdstringbackofffilename backoffs file$^      tmpdirt povaluestdstringtmpdir tmp dir$^    povariablesmap vm$^    postorepoparsecommandlineargc argv options vm$^$^     display help$^    ifvmhelp.asbool $^      stdcerr  usage   options  stdendl$^      return 0$^    $^  $^  catchconst stdexception e $^$^    stdcerr  e.what  stdendl$^    return 0$^$^  $^$^   the basic strategy here is to have three chains$^    the first reads the ngram order inputs using modelbuffer. those are$^     then stripped of their backoff values and fed into the third chain$^     the backoff values themselves are written to the second chain.$^  $^    the second chain takes the backoff values and writes them out to a$^     file one for each order.$^  $^    the third chain takes just the probability values and ngrams and$^     writes them out sorted in contextorder to a file one for each$^     order.$^$^   this will be used to read in the binary intermediate files. there is$^   one file per order e.g. ngrams.0 ngrams.0 ...$^  lmmodelbuffer bufferfilename$^$^   create a separate chains for each ngram order for$^    input from the intermediate files$^    output to the backoff file$^    output to the contextsorted probability file$^  utilstreamchains ngraminputsbuffer.order$^  utilstreamchains backoffchainsbuffer.order$^  utilstreamchains probchainsbuffer.order$^  for stdsizet i  0 i  buffer.order i $^    ngraminputs.pushbackutilstreamchainconfig$^        lmngramlmprobbackofftotalsizei  0 numberofblocks onegb$^$^    backoffchains.pushback$^        utilstreamchainconfigsizeoffloat numberofblocks onegb$^$^    probchains.pushbackutilstreamchainconfig$^        sizeoflmwordindex  i  0  sizeoffloat numberofblocks$^        onegb$^  $^$^   this sets the input for each of the ngram order chains to the$^   appropriate file$^  buffer.sourcengraminputs$^$^  utilfixedarrayutilscopedptrsplitworker  workersbuffer.order$^  for stdsizet i  0 i  buffer.order i $^     attach a splitworker to each of the ngram input chains writing to the$^     corresponding orders backoff and probability chains$^    workers.pushback$^        new splitworkeri  0 backoffchainsi probchainsi$^    ngraminputsi  boostrefworkers.back$^  $^$^  utilstreamsortconfig sortcfg$^  sortcfg.tempprefix  tmpdir$^  sortcfg.buffersize  sixtyfourmb$^  sortcfg.totalmemory  onegb$^$^   this will parallel merge sort the individual order files putting$^   them in contextorder instead of suffixorder.$^  $^   two new threads will be running each owned by the chainsi object.$^    the first executes blocksorter.run to sort the ngram entries$^    the second executes writeandrecycle.run to write each sorted$^     block to disk as a temporary file$^  utilstreamsortslmcontextorder sortsbuffer.order$^  for stdsizet i  0 i  probchains.size i $^    sorts.pushbackprobchainsi sortcfg lmcontextorderi  0$^  $^$^   set the sort output to be on the same chain$^  for stdsizet i  0 i  probchains.size i $^     the following call to chainwait$^         joins the threads owned by chainsi.$^    $^     as such the following call wont return$^         until all threads owned by chainsi have completed.$^    $^     the following call also resets chaini$^         so that it can be reused$^         including freeing the memory previously used by the chain$^    probchainsi.wait$^$^     in an ideal world without memory restrictions$^         we could merge all of the previously sorted blocks$^         by reading them all completely into memory$^         and then running merge sort over them.$^    $^     in the real world we have memory restrictions$^         depending on how many blocks we have$^         and how much memory we can use to read from each block$^         sortconfig.buffersize$^         it may be the case that we have insufficient memory$^         to read sortconfig.buffersize of data from each block from disk.$^    $^     if this occurs then it will be necessary to perform one or more rounds$^     of merge sort on disk$^         doing so will reduce the number of blocks that we will eventually$^         need to read from$^         when performing the final round of merge sort in memory.$^    $^     so the following call determines whether it is necessary$^         to perform one or more rounds of merge sort on disk$^         if such ondisk merge sorting is required such sorting is performed.$^    $^     finally the following method launches a thread that calls$^     owningmergingreader.run$^         to perform the final round of merge sort in memory.$^    $^     merge sort could have be invoked directly$^         so that merge sort memory doesnt coexist with chain memory.$^    sortsi.outputprobchainsi$^  $^$^   create another model buffer for our output on e.g. csortedngrams.0$^   csortedngrams.0 ...$^  lmmodelbuffer outputbufcontextsortedfilename true false$^  outputbuf.sinkprobchains buffer.counts$^$^   create a third model buffer for our backoff output on e.g. backoff.0$^   backoff.0 ...$^  lmmodelbuffer boffbufbackofffilename true false$^  boffbuf.sinkbackoffchains buffer.counts$^$^   joins all threads that chains owns$^      and does a for loop over each chain object in chains$^      calling chain.wait on each such chain object$^  ngraminputs.waittrue$^  backoffchains.waittrue$^  probchains.waittrue$^$^  return 0$^$^include lminterpolatetunederivatives.hh$^$^include lminterpolatetuneinstances.hh$^include lminterpolatetunematrix.hh$^include utilstreamchain.hh$^include utilstreamtypedstream.hh$^$^include eigencore$^$^namespace lm  namespace interpolate $^$^accum derivativesinstances in const vector weights vector gradient matrix hessian $^  gradient  in.correctgradientterm$^  hessian  matrixzeroweights.rows weights.rows$^$^   todo loop instead to force lowmemory evaluation$^   compute pixzepsilon i.e. the unnormalized probabilities$^  vector weighteduniin.lnunigrams  weights.array.exp$^   even inf doesnt work for s because weights can be negative.  manually set it to zero.$^  weighteduniin.bos  0.0$^  accum zepsilon  weighteduni.sum$^   unigramcrossi  sumall x pix ln pix$^  vector unigramcrossin.lnunigrams.transpose  weighteduni  zepsilon$^$^  accum sumbi  0.0$^  accum sumlnzcontext  0.0$^$^   temporaries used each cycle of the loop.$^  matrix convolve$^  vector fullcross$^  matrix hessianmissingzcontext$^   backed off ln pixbicontext$^  vector lnpibacked$^   full ln pix  context$^  vector lnpifull$^$^   todo make configurable memory size.$^  utilstreamchain chainutilstreamchainconfigin.readextensionsentrysize 0 00  00$^  chain.activateprogress$^  in.readextensionschain$^  utilstreamtypedstreamextension extensionschain.add$^  chain  utilstreamkrecycle$^$^   loop over instances words in the tuning data.$^  for instanceindex n  0 n  in.numinstances n $^    assertextensions$^    accum weightedbackoffs  expin.lnbackoffsn.dotweights$^$^     compute sumx model does not back off to unigram pixzepsilon$^    accum unnormalizedsumxpi  0.0$^     compute sumx model does not back off to unigram pix  contextzcontext$^    accum unnormalizedsumxpifull  0.0$^$^     this should be divided by zcontext then added to the hessian.$^    hessianmissingzcontext  matrixzeroweights.rows weights.rows$^$^    fullcross  vectorzeroweights.rows$^$^     loop over words within an instance for which extension exists.  an extension happens when any model matches more than a unigram in the tuning instance.$^    while extensions  extensionsinstance  n $^      const wordindex word  extensionsword$^      unnormalizedsumxpi  weighteduniword$^$^      lnpibacked  in.lnunigrams.rowword  in.lnbackoffsn$^$^       calculate lnpifulli  ln piword  context by filling in unigrams then overwriting with extensions.$^      lnpifull  lnpibacked$^       loop over all models that have an extension for the same word namely piword  context matches at least a bigram.$^      for  extensions  extensionsword  word  extensionsinstance  n extensions $^        lnpifullextensionsmodel  extensionslnprob$^      $^$^       this is the weighted product of probabilities.  in other words piword  context  zcontext  expsumi wi  piword  context.$^      accum weighted  explnpifull.dotweights$^      unnormalizedsumxpifull  weighted$^$^       these arent normalized by zcontext happens later$^      fullcross.noalias $^        weighted  lnpifull$^         weighteduniword  weightedbackoffs  well divide by zcontext later to form bi   in.lnunigrams.rowword.transpose$^$^       this will get multiplied by zcontext then added to the hessian.$^      hessianmissingzcontext.noalias $^         replacement terms.$^        weighted  lnpifull  lnpifull.transpose$^         presumed unigrams.  zepsilon  weightedbackoffs will turn into bi once all of this is divided by zcontext.$^         weighteduniword  weightedbackoffs  lnpibacked  lnpibacked.transpose$^    $^$^    accum zcontext $^      weightedbackoffs  zepsilon  unnormalizedsumxpi  back off and unnormalize the unigrams for which there is no extension.$^       unnormalizedsumxpifull  add the extensions.$^    sumlnzcontext  logzcontext$^    accum bi  zepsilon  zcontext  weightedbackoffs$^    sumbi  bi$^$^     this is the gradient term for this instance except for log piwn  w0n0 which was accounted for as part of negcorrectsum.$^     fullcrossi is sumall x pix  context log pix  context$^     prior terms excluded dividing by zcontext because it wasnt known at the time.$^    fullcross  zcontext$^    fullcross $^       uncorrected term$^      bi  in.lnbackoffsn.transpose  unigramcross$^       subtract values that should not have been charged.$^       unnormalizedsumxpi  zepsilon  bi  in.lnbackoffsn.transpose$^    gradient  fullcross$^$^    convolve  unigramcross  in.lnbackoffsn$^     theres one missing term here which is independent of context and done at the end.$^    hessian.noalias $^       first term of hessian assuming all models back off to unigram.$^      bi  convolve  convolve.transpose  in.lnbackoffsn.transpose  in.lnbackoffsn$^       error in the first term correcting from unigram to full probabilities.$^       hessianmissingzcontext  zcontext$^       second term of hessian with correct full probabilities.$^       fullcross  fullcross.transpose$^  $^$^  for matrixindex x  0 x  weighteduni.rows x $^     sumcontexts bicontext sumx pix log pix log pjx$^     todo can this be optimized  its summing over the entire vocab which should be a matrix operation.$^    hessian.noalias  sumbi  weightedunix  zepsilon  in.lnunigrams.rowx.transpose  in.lnunigrams.rowx$^  $^  return expin.correctgradientterm.dotweights  sumlnzcontext  staticcastdoublein.numinstances$^$^$^  namespaces$^include lminterpolatetunederivatives.hh$^$^include lminterpolatetuneinstances.hh$^$^include utilstreamconfig.hh$^include utilstreamchain.hh$^include utilstreamio.hh$^include utilstreamtypedstream.hh$^$^define boosttestmodule derivativetest$^include boosttestunittest.hpp$^$^namespace lm  namespace interpolate $^$^class mockinstances  public instances $^  public$^    mockinstances  chainutilstreamchainconfigreadextensionsentrysize 0 000 writechain.add $^      extensionssubsequent.resetnew utilstreamfilebufferutilmaketemptmp$^      chain  extensionssubsequentsink  utilstreamkrecycle$^    $^$^    matrix lnunigrams  return lnunigrams $^$^    backoffmatrix lnbackoffs  return lnbackoffs $^$^    wordindex bos  return bos $^$^    vector neglncorrectsum  return neglncorrectsum $^$^     extensions must be provided sorted$^    void addextensionconst extension extension $^      write  extension$^      write$^    $^$^    void doneextending $^      write.poison$^      chain.waittrue$^    $^$^  private$^    utilstreamchain chain$^    utilstreamtypedstreamextension write$^$^$^namespace $^$^boostautotestcasesmall $^  mockinstances mock$^$^  $^     three vocabulary words plus s two models.$^    matrix unigrams0 0$^    unigrams $^      0.0 0.0$^      0.0 0.0$^      0.0 0.0$^       s$^      0.0 0.0$^    mock.lnunigrams  unigrams.array.log$^  $^  mock.bos  0$^$^   one instance$^  mock.lnbackoffs.resize0 0$^  mock.lnbackoffs  0.0 0.0$^  mock.lnbackoffs  mock.lnbackoffs.array.log$^$^   sparse extensions model 0 word 0 and model 0 word 0.$^$^   assuming that model 0 only matches word 0 this is p00  context$^  accum model0word0  0.0  .0  .0  .0  .0$^$^  mock.neglncorrectsum.resize0$^   well suppose correct has wordindex 0 which backs off in model 0 and matches in model 0$^  mock.neglncorrectsum  0.0  0.0 model0word0$^  mock.neglncorrectsum  mock.neglncorrectsum.array.log$^$^  accum model0word0  0.0  .0  .0  .0  .0$^$^  extension ext$^$^  ext.instance  0$^  ext.word  0$^  ext.model  0$^  ext.lnprob  logmodel0word0$^  mock.addextensionext$^$^  ext.instance  0$^  ext.word  0$^  ext.model  0$^  ext.lnprob  logmodel0word0$^  mock.addextensionext$^$^  mock.doneextending$^$^  vector weights0$^  weights  0.0 0.0$^$^  vector gradient0$^  matrix hessian00$^  derivativesmock weights gradient hessian$^   todo check perplexity value coming out.$^$^   pix  context$^  vector pi0$^  pi $^    pow0.0  0.0 0.0  pow0.0  0.0 0.0$^    pow0.0  0.0 0.0  powmodel0word0 0.0$^    powmodel0word0 0.0  pow0.0  0.0 0.0$^  pi  pi.sum$^$^  vector expectedgradient  mock.neglncorrectsum$^  expectedgradient0  pi0  log0.0  0.0$^  expectedgradient0  pi0  log0.0  0.0$^  expectedgradient0  pi0  logmodel0word0$^  boostcheckcloseexpectedgradient0 gradient0 0.00$^$^  expectedgradient0  pi0  log0.0  0.0$^  expectedgradient0  pi0  logmodel0word0$^  expectedgradient0  pi0  log0.0  0.0$^  boostcheckcloseexpectedgradient0 gradient0 0.00$^$^  matrix expectedhessian0 0$^  expectedhessian0 0 $^     first term$^    pi0  log0.0  0.0  log0.0  0.0 $^    pi0  log0.0  0.0  logmodel0word0 $^    pi0  logmodel0word0  log0.0  0.0$^  expectedhessian0 0 $^    pi0  log0.0  0.0  pi0  log0.0  0.0  pi0  logmodel0word0 $^    pi0  log0.0  0.0  pi0  logmodel0word0  pi0  log0.0  0.0$^  expectedhessian0 0  expectedhessian0 0$^  boostcheckcloseexpectedhessian0 0 hessian0 0 0.00$^  boostcheckcloseexpectedhessian0 0 hessian0 0 0.00$^$^$^  namespaces$^include lminterpolateboundedsequenceencoding.hh$^$^include algorithm$^$^namespace lm  namespace interpolate $^$^boundedsequenceencodingboundedsequenceencodingconst unsigned char boundbegin const unsigned char boundend$^   entriesboundend  boundbegin $^  stdsizet full  0$^  entry entry$^  entry.shift  0$^  for const unsigned char i  boundbegin i  boundend i $^    uint0t length$^    if i  0 $^      length  0$^     else $^      length  sizeofunsigned int  0  builtinclzunsigned inti$^    $^    entry.mask  0ull  length  0ull$^    if entry.shift  length  00 $^      entry.shift  0$^      entry.next  true$^      full$^     else $^      entry.next  false$^    $^    entries.pushbackentry$^    entry.shift  length$^  $^  bytelength  full  sizeofuint00t  entry.shift  0  0$^  firstcopy  stdminstdsizetbytelength sizeofuint00t$^   size of last uint00t.  zero if empty otherwise 00 depending on mod.$^  overhang  bytelength  0  0  bytelength  0  0  0$^$^$^  namespaces$^define boosttestmodule interpolatemergevocabtest$^include boosttestunittest.hpp$^$^include lmenumeratevocab.hh$^include lminterpolatemergevocab.hh$^include lminterpolateuniversalvocab.hh$^include lmlmexception.hh$^include lmvocab.hh$^include lmwordindex.hh$^include utilfile.hh$^include utilfilepiece.hh$^$^include cstring$^$^namespace lm $^namespace interpolate $^namespace $^$^ stupid bjam permutes the command line arguments randomly.$^class testfiles $^  public$^    testfiles $^      char argv  boostunittestframeworkmastertestsuite.argv$^      int argc  boostunittestframeworkmastertestsuite.argc$^      boostrequireequal0 argc$^      for int i  0 i  argc i $^        endswithassignargvi test0 test0$^        endswithassignargvi test0 test0$^        endswithassignargvi test0 test0$^        endswithassignargvi nounk nounk$^        endswithassignargvi badorder badorder$^      $^    $^$^    void endswithassignchar arg stringpiece value utilscopedfd to $^      stringpiece strarg$^      if str.size  value.size return$^      if stdmemcmpstr.data  str.size  value.size value.data value.size return$^      to.resetutilopenreadorthrowarg$^    $^$^    utilscopedfd test0 nounk badorder$^$^$^class donothingenumerate  public enumeratevocab $^  public$^    void addwordindex const stringpiece  $^$^$^boostautotestcasemergevocabtest $^  testfiles files$^$^  utilfixedarrayint usedfiles0$^  usedfiles.pushbackfiles.test0.get$^  usedfiles.pushbackfiles.test0.get$^  usedfiles.pushbackfiles.test0.get$^$^  stdvectorlmwordindex modelmaxidx$^  modelmaxidx.pushback00$^  modelmaxidx.pushback00$^  modelmaxidx.pushback00$^$^  utilscopedfd combinedutilmaketemptemporary$^$^  universalvocab universalvocabmodelmaxidx$^  $^    ngramimmediatewritewordswrapper writernull combined.get 0$^    mergevocabusedfiles universalvocab writer$^  $^$^  boostcheckequaluniversalvocab.getuniversalidx0 0 0$^  boostcheckequaluniversalvocab.getuniversalidx0 0 0$^  boostcheckequaluniversalvocab.getuniversalidx0 0 0$^  boostcheckequaluniversalvocab.getuniversalidx0 0 0$^  boostcheckequaluniversalvocab.getuniversalidx0 0 0$^  boostcheckequaluniversalvocab.getuniversalidx0 0 0$^  boostcheckequaluniversalvocab.getuniversalidx0 0 00$^  boostcheckequaluniversalvocab.getuniversalidx0 0 0$^  boostcheckequaluniversalvocab.getuniversalidx0 0 00$^$^  utilseekorthrowcombined.get 0$^  utilfilepiece fcombined.release$^  boostcheckequalunk f.readline0$^  boostcheckequala f.readline0$^  boostcheckequalis this f.readline0$^  boostcheckequalthis a f.readline0$^  boostcheckequalfirst cut f.readline0$^  boostcheckequalthis f.readline0$^  boostcheckequala first f.readline0$^  boostcheckequalcut f.readline0$^  boostcheckequalis f.readline0$^  boostcheckequali f.readline0$^  boostcheckequalsecd f.readline0$^  boostcheckequalfirst f.readline0$^  boostcheckthrowf.readline0 utilendoffileexception$^$^$^boostautotestcasemergevocabnounktest $^  testfiles files$^  utilfixedarrayint usedfiles0$^  usedfiles.pushbackfiles.nounk.get$^$^  stdvectorlmwordindex modelmaxidx$^  modelmaxidx.pushback00$^$^  universalvocab universalvocabmodelmaxidx$^  donothingenumerate nothing$^  boostcheckthrowmergevocabusedfiles universalvocab nothing formatloadexception$^$^$^boostautotestcasemergevocabwrongordertest $^  testfiles files$^$^  utilfixedarrayint usedfiles0$^  usedfiles.pushbackfiles.test0.get$^  usedfiles.pushbackfiles.badorder.get$^$^  stdvectorlmwordindex modelmaxidx$^  modelmaxidx.pushback00$^  modelmaxidx.pushback00$^$^  lminterpolateuniversalvocab universalvocabmodelmaxidx$^  donothingenumerate nothing$^  boostcheckthrowmergevocabusedfiles universalvocab nothing formatloadexception$^$^$^  namespaces$^include lmvirtualinterface.hh$^$^include lmlmexception.hh$^$^namespace lm $^namespace base $^$^vocabularyvocabulary $^$^void vocabularysetspecialwordindex beginsentence wordindex endsentence wordindex notfound $^  beginsentence  beginsentence$^  endsentence  endsentence$^  notfound  notfound$^$^$^modelmodel $^$^  namespace base$^  namespace lm$^include lmmodel.hh$^$^include cstdlib$^include cstring$^$^define boosttestmodule modeltest$^include boosttestunittest.hpp$^include boosttestfloatingpointcomparison.hpp$^$^ apparently some boost versions use templates and are pretty strict about types matching.$^define sloppycheckcloseref value tol boostcheckclosestaticcastdoubleref staticcastdoublevalue staticcastdoubletol$^$^namespace lm $^namespace ngram $^$^stdostream operatorstdostream o const state state $^  o  state length   staticcastunsigned intstate.length  $^  for const wordindex i  state.words i  state.words  state.length i $^    o     i$^  $^  return o$^$^$^namespace $^$^ stupid bjam reverses the command line arguments randomly.$^const char testlocation $^  if boostunittestframeworkmastertestsuite.argc  0 $^    return test.arpa$^  $^  char argv  boostunittestframeworkmastertestsuite.argv$^  return argvstrstrargv0 nounk  0  0$^$^const char testnounklocation $^  if boostunittestframeworkmastertestsuite.argc  0 $^    return testnounk.arpa$^  $^  char argv  boostunittestframeworkmastertestsuite.argv$^  return argvstrstrargv0 nounk  0  0$^$^$^template class model state getstateconst model model const char word const state in $^  wordindex contextin.length  0$^  context0  model.getvocabulary.indexword$^  stdcopyin.words in.words  in.length context  0$^  state ret$^  model.getstatecontext context  in.length  0 ret$^  return ret$^$^$^define starttestword ngram score indepleft $^  ret  model.fullscore $^      state $^      model.getvocabulary.indexword $^      out$^  sloppycheckclosescore ret.prob 0.000 $^  boostcheckequalstaticcastunsigned intngram ret.ngramlength $^  boostcheckgestdminunsigned charngram 0  0 out.length $^  boostcheckequalindepleft ret.independentleft $^  boostcheckequalout getstatemodel word state$^$^define appendtestword ngram score indepleft $^  starttestword ngram score indepleft $^  state  out$^$^template class m void startersconst m model $^  fullscorereturn ret$^  modelstate statemodel.beginsentencestate$^  modelstate out$^$^  starttestlooking 0 0.0000000 true$^$^    probability plus s backoff$^  starttest 0 0.000000  0.0000000 true$^   unk probability plus s backoff$^  starttestthisisnotfound 0 0.000000  0.0000000 true$^$^$^template class m void continuationconst m model $^  fullscorereturn ret$^  modelstate statemodel.beginsentencestate$^  modelstate out$^$^  appendtestlooking 0 0.000000 true$^  appendteston 0 0.000000 true$^  appendtesta 0 0.0000000 true$^  appendtestlittle 0 0.00000000 true$^  state preserve  state$^  appendtestthe 0 0.00000 true$^  appendtestbiarritz 0 0.0000 true$^  appendtestnotfound 0 0.00000 true$^  appendtestmore 0 0.00000  00.0 true$^  appendtest. 0 0.00000 true$^  appendtests 0 0.0000000 true$^  boostcheckequal0 state.length$^$^  state  preserve$^  appendtestmore 0 0.00000000 true$^  boostcheckequal0 state.length$^  appendtestloin 0 0.0000000 true$^  boostcheckequal0 state.length$^$^$^template class m void blanksconst m model $^  fullscorereturn ret$^  state statemodel.nullcontextstate$^  state out$^  appendtestalso 0 0.000000 false$^  appendtestwould 0 0 true$^  appendtestconsider 0 0 true$^  state preserve  state$^  appendtesthigher 0 0 true$^  appendtestlooking 0 0 true$^  boostcheckequal0 state.length$^$^  state  preserve$^   also would consider notfound$^  appendtestnotfound 0 0.000000  0.0  0.00000 true$^$^  state  model.nullcontextstate$^   higher looking is a blank.$^  appendtesthigher 0 0.000000 false$^  appendtestlooking 0 0.000000  0.00000 false$^$^  state higherlooking  state$^$^  boostcheckequal0 state.length$^  appendtestnotfound 0 0.000000  0.0000000 true$^$^  state  higherlooking$^   higher looking consider$^  appendtestconsider 0 0.000000  0.0000000 true$^$^  state  model.nullcontextstate$^  appendtestwould 0 0.000000 false$^  boostcheckequal0 state.length$^  appendtestconsider 0 0.000000 0.00000 false$^  boostcheckequal0 state.length$^  appendtesthigher 0 0.000000  0.00000 false$^  boostcheckequal0 state.length$^  appendtestlooking 0 0.000000  0.00000 false$^$^$^template class m void unknownsconst m model $^  fullscorereturn ret$^  state statemodel.nullcontextstate$^  state out$^$^  appendtestnotfound 0 0.000000 false$^  state preserve  state$^  appendtestnotfound0 0 00.0 true$^  appendtestnotfound0 0 00.0  0.0 true$^$^  state  preserve$^  appendtesthowever 0 0 true$^  appendtestnotfound0 0 0 true$^$^$^template class m void minimalstateconst m model $^  fullscorereturn ret$^  state statemodel.nullcontextstate$^  state out$^$^  appendtestbaz 0 0.000000 true$^  boostcheckequal0 state.length$^  state  model.nullcontextstate$^  appendtestfoo 0 0.000000 true$^  boostcheckequal0 state.length$^  appendtestbar 0 0.0 true$^   has to include the backoff weight.$^  boostcheckequal0 state.length$^  appendtestbar 0 0.000000  0.0 true$^  boostcheckequal0 state.length$^$^  state  model.nullcontextstate$^  appendtestto 0 0.000000 false$^  appendtestlook 0 0.0000000 true$^  boostcheckequal0 state.length$^  appendtesta 0 0 true$^$^$^template class m void extendlefttestconst m model $^  state right$^  fullscorereturn littlemodel.fullscoremodel.nullcontextstate model.getvocabulary.indexlittle right$^  const float klittleprob  0.000000$^  sloppycheckcloseklittleprob little.prob 0.000$^  unsigned char nextuse$^  float backoffout0$^$^  fullscorereturn extendnonemodel.extendleftnull null null little.extendleft 0 null nextuse$^  boostcheckequal0 nextuse$^  boostcheckequallittle.extendleft extendnone.extendleft$^  sloppycheckcloselittle.prob  little.rest extendnone.prob 0.000$^  boostcheckequal0 extendnone.ngramlength$^$^  const wordindex a  model.getvocabulary.indexa$^  float backoffin  0.00$^   a little$^  fullscorereturn extendamodel.extendlefta a  0 backoffin little.extendleft 0 backoffout nextuse$^  boostcheckequal0 nextuse$^  sloppycheckclose0.00000 backoffout0 0.000$^  sloppycheckclose0.00000000  little.rest extenda.prob 0.000$^  boostcheckequal0 extenda.ngramlength$^  boostcheckextenda.independentleft$^$^  const wordindex on  model.getvocabulary.indexon$^  fullscorereturn extendonmodel.extendlefton on  0 backoffin extenda.extendleft 0 backoffout nextuse$^  boostcheckequal0 nextuse$^  sloppycheckclose0.0000000 backoffout0 0.000$^  sloppycheckclose0.0000000  extenda.rest  little.rest extendon.prob 0.000$^  boostcheckequal0 extendon.ngramlength$^  boostcheckextendon.independentleft$^$^  const wordindex both0  a on$^  float backoffinarr0$^  fullscorereturn extendbothmodel.extendleftboth both  0 backoffinarr little.extendleft 0 backoffout nextuse$^  boostcheckequal0 nextuse$^  sloppycheckclose0.00000 backoffout0 0.000$^  sloppycheckclose0.0000000 backoffout0 0.000$^  sloppycheckclose0.0000000  little.rest extendboth.prob 0.000$^  boostcheckequal0 extendboth.ngramlength$^  boostcheckextendboth.independentleft$^  boostcheckequalextendon.extendleft extendboth.extendleft$^$^$^define statelesstestword provide ngram score $^  ret  model.fullscoreforgotstateindices  numwords  word indices  numwords  word  provide indicesnumwords  word  0 state $^  sloppycheckclosescore ret.prob 0.000 $^  boostcheckequalstaticcastunsigned intngram ret.ngramlength $^  model.getstateindices  numwords  word indices  numwords  word  provide before $^  ret  model.fullscorebefore indicesnumwords  word  0 out $^  boostcheckstate  out $^  sloppycheckclosescore ret.prob 0.000 $^  boostcheckequalstaticcastunsigned intngram ret.ngramlength$^$^template class m void statelessconst m model $^  const char words  s looking on a little the biarritz notfound more . s$^  const sizet numwords  sizeofwords  sizeofconst char$^   silience array subscript is above array bounds when extracting end pointer.$^  wordindex indicesnumwords  0$^  for unsigned int i  0 i  numwords i $^    indicesnumwords  0  i  model.getvocabulary.indexwordsi$^  $^  fullscorereturn ret$^  state state out before$^$^  ret  model.fullscoreforgotstateindices  numwords  0 indices  numwords indicesnumwords  0 state$^  sloppycheckclose0.000000 ret.prob 0.000$^  statelesstest0 0 0 0.000000$^$^   looking$^  statelesstest0 0 0 0.000000$^   on$^  appendteston 0 0.000000 true$^  statelesstest0 0 0 0.000000$^  statelesstest0 0 0 0.000000$^  statelesstest0 0 0 0.0000000$^   a$^  statelesstest0 0 0 0.0000000$^   little$^  appendtestlittle 0 0.00000000 true$^  statelesstest0 0 0 0.00000000$^   the$^  appendtestthe 0 0.00000 true$^  statelesstest0 0 0 0.00000$^   no context of the.$^  statelesstest0 0 0 0.000000$^   biarritz$^  statelesstest0 0 0 0.0000$^   not found$^  statelesstest0 0 0 0.00000$^  statelesstest0 0 0 0.000000$^$^  wordindex unk0$^  unk0  0$^  model.getstateunk unk  0 state$^  boostcheckequal0 state.length$^  boostcheckequalstaticcastwordindex0 state.words0$^$^$^template class m void nounkcheckconst m model $^  wordindex unkindex  0$^  state state$^$^  fullscorereturn ret  model.fullscoreforgotstateunkindex unkindex  0 unkindex state$^  sloppycheckclose000.0 ret.prob 0.000$^$^$^template class m void everythingconst m m $^  startersm$^  continuationm$^  blanksm$^  unknownsm$^  minimalstatem$^  extendlefttestm$^  statelessm$^$^$^class expectenumeratevocab  public enumeratevocab $^  public$^    expectenumeratevocab $^$^    void addwordindex index const stringpiece str $^      boostcheckequalseen.size index$^      seen.pushbackstdstringstr.data str.length$^    $^$^    void checkconst basevocabulary vocab $^      boostcheckequal00ull seen.size$^      boostrequireseen.empty$^      boostcheckequalunk seen0$^      for wordindex i  0 i  seen.size i $^        boostcheckequali vocab.indexseeni$^      $^    $^$^    void clear $^      seen.clear$^    $^$^    stdvectorstdstring seen$^$^$^template class modelt void loadingtest $^  config config$^  config.arpacomplain  confignone$^  config.messages  null$^  config.probingmultiplier  0.0$^  $^    expectenumeratevocab enumerate$^    config.enumeratevocab  enumerate$^    modelt mtestlocation config$^    enumerate.checkm.getvocabulary$^    boostcheckequalwordindex00 m.getvocabulary.bound$^    everythingm$^  $^  $^    expectenumeratevocab enumerate$^    config.enumeratevocab  enumerate$^    modelt mtestnounklocation config$^    enumerate.checkm.getvocabulary$^    boostcheckequalwordindex00 m.getvocabulary.bound$^    nounkcheckm$^  $^$^$^boostautotestcaseprobing $^  loadingtestmodel$^$^boostautotestcasetrie $^  loadingtesttriemodel$^$^boostautotestcasequanttrie $^  loadingtestquanttriemodel$^$^boostautotestcasebhikshatrie $^  loadingtestarraytriemodel$^$^boostautotestcasequantbhikshatrie $^  loadingtestquantarraytriemodel$^$^$^template class modelt void binarytestconfigwritemethod writemethod $^  config config$^  config.writemmap  test.binary$^  config.messages  null$^  config.writemethod  writemethod$^  expectenumeratevocab enumerate$^  config.enumeratevocab  enumerate$^$^  $^    modelt copymodeltestlocation config$^    enumerate.checkcopymodel.getvocabulary$^    enumerate.clear$^    everythingcopymodel$^  $^$^  config.writemmap  null$^$^  modeltype type$^  boostrequirerecognizebinarytest.binary type$^  boostcheckequalmodeltkmodeltype type$^$^  $^    modelt binarytest.binary config$^    enumerate.checkbinary.getvocabulary$^    everythingbinary$^  $^  unlinktest.binary$^$^   now test without unk.$^  config.writemmap  testnounk.binary$^  config.messages  null$^  enumerate.clear$^  $^    modelt copymodeltestnounklocation config$^    enumerate.checkcopymodel.getvocabulary$^    enumerate.clear$^    nounkcheckcopymodel$^  $^  config.writemmap  null$^  $^    modelt binarytestnounklocation config$^    enumerate.checkbinary.getvocabulary$^    nounkcheckbinary$^  $^  unlinktestnounk.binary$^$^$^template class modelt void binarytest $^  binarytestmodeltconfigwritemmap$^  binarytestmodeltconfigwriteafter$^$^$^boostautotestcasewriteandreadprobing $^  binarytestprobingmodel$^$^boostautotestcasewriteandreadrestprobing $^  binarytestrestprobingmodel$^$^boostautotestcasewriteandreadtrie $^  binarytesttriemodel$^$^boostautotestcasewriteandreadquanttrie $^  binarytestquanttriemodel$^$^boostautotestcasewriteandreadarraytrie $^  binarytestarraytriemodel$^$^boostautotestcasewriteandreadquantarraytrie $^  binarytestquantarraytriemodel$^$^$^boostautotestcaserestmax $^  config config$^  config.arpacomplain  confignone$^  config.messages  null$^$^  restprobingmodel modeltestlocation config$^  state state out$^  fullscorereturn retmodel.fullscoremodel.nullcontextstate model.getvocabulary.index. state$^  sloppycheckclose0.0000000 ret.rest 0.000$^  sloppycheckclose0.00000000 model.fullscorestate model.getvocabulary.endsentence out.rest 0.000$^$^$^  namespace$^  namespace ngram$^  namespace lm$^include lmmodel.hh$^include utilfilestream.hh$^include utilfile.hh$^include utilfilepiece.hh$^include utilusage.hh$^include utilthreadpool.hh$^$^include boostrangeiteratorrange.hpp$^include boostprogramoptions.hpp$^$^include iostream$^$^include stdint.h$^$^namespace $^$^template class model class width void converttobytesconst model model int fdin $^  utilfilepiece infdin$^  utilfilestream out0$^  width width$^  stringpiece word$^  const width endsentence  widthmodel.getvocabulary.endsentence$^  while true $^    while in.readwordsamelineword $^      width  widthmodel.getvocabulary.indexword$^      out.writewidth sizeofwidth$^    $^    if in.readlineoreofword break$^    out.writeendsentence sizeofwidth$^  $^$^$^template class model class width class worker $^  public$^    explicit workerconst model model double addtotal  modelmodel total0.0 addtotaladdtotal $^$^     destructors happen in the main thread so theres no race for addtotal.$^    worker  addtotal  total $^$^    typedef boostiteratorrangewidth  request$^$^    void operatorrequest request $^      const lmngramstate const beginstate  model.beginsentencestate$^      const lmngramstate nextstate  beginstate$^      const width keos  model.getvocabulary.endsentence$^      float sum  0.0$^       do even stuff first.$^      const width evenend  request.begin  request.size  0$^       alternating states$^      const width i$^      for i  request.begin i  evenend $^        sum  model.fullscorenextstate i state0.prob$^        nextstate  i  keos  beginstate  state0$^        sum  model.fullscorenextstate i state0.prob$^        nextstate  i  keos  beginstate  state0$^      $^       odd corner case.$^      if request.size  0 $^        sum  model.fullscorenextstate i state0.prob$^        nextstate  i  keos  beginstate  state0$^      $^      total  sum$^    $^$^  private$^    const model model$^    double total$^    double addtotal$^$^    lmngramstate state0$^$^$^struct config $^  int fdin$^  stdsizet threads$^  stdsizet bufperthread$^  bool query$^$^$^template class model class width void queryfrombytesconst model model const config config $^  utilfilestream out0$^  out  threads   config.threads  n$^  const width keos  model.getvocabulary.endsentence$^  double total  0.0$^   number of items to have in queue in addition to everything in flight.$^  const stdsizet kinqueue  0$^  stdsizet totalqueue  config.threads  kinqueue$^  stdvectorwidth backingconfig.bufperthread  totalqueue$^  double loadedcpu$^  double loadedwall$^  uint00t queries  0$^  $^    utilrecyclingthreadpoolworkermodel width  pooltotalqueue config.threads workermodel widthmodel total boostiteratorrangewidth width0 width0$^$^    for stdsizet i  0 i  totalqueue i $^      pool.populaterecyclingboostiteratorrangewidth backingi  config.bufperthread backingi  config.bufperthread$^    $^$^    loadedcpu  utilcputime$^    loadedwall  utilwalltime$^    out  to load cpu   loadedcpu   wall   loadedwall  n$^    boostiteratorrangewidth  overhangwidth0 width0$^    while true $^      boostiteratorrangewidth  buf  pool.consume$^      stdmemmovebuf.begin overhang.begin overhang.size  sizeofwidth$^      stdsizet got  utilreadoreofconfig.fdin buf.begin  overhang.size config.bufperthread  overhang.size  sizeofwidth$^      if got  overhang.empty break$^      utilthrowif0got  sizeofwidth file size not a multiple of vocab id size   sizeofwidth$^      width readend  buf.begin  overhang.size  got  sizeofwidth$^      width lasteos$^      for lasteos  readend  0  lasteos $^        utilthrowif0lasteos  buf.begin encountered a sentence longer than the buffer size of   config.bufperthread   words.  rerun with increased buffer size. todo adaptable buffer$^        if lasteos  keos break$^      $^      buf  boostiteratorrangewidthbuf.begin lasteos  0$^      overhang  boostiteratorrangewidthlasteos  0 readend$^      queries  buf.size$^      pool.producebuf$^    $^    drain pool.$^$^  double aftercpu  utilcputime$^  double afterwall  utilwalltime$^  utilfilestream0 00  probability sum   total  n$^  out  queries   queries  n$^  out  excluding load cpu   aftercpu  loadedcpu   wall   afterwall  loadedwall  n$^  double cpuperentry  aftercpu  loadedcpu  staticcastdoublequeries$^  double wallperentry  afterwall  loadedwall  staticcastdoublequeries$^  out  seconds per query excluding load cpu   cpuperentry   wall   wallperentry  n$^  out  queries per second excluding load cpu   0.0cpuperentry   wall   0.0wallperentry  n$^  out  rssmax   utilrssmax  n$^$^$^template class model class width void dispatchfunctionconst model model const config config $^  if config.query $^    queryfrombytesmodel widthmodel config$^   else $^    converttobytesmodel widthmodel config.fdin$^  $^$^$^template class model void dispatchwidthconst char file const config config $^  lmngramconfig modelconfig$^  modelconfig.loadmethod  utilread$^  model modelfile modelconfig$^  uint00t bound  model.getvocabulary.bound$^  if bound  000 $^    dispatchfunctionmodel uint0tmodel config$^   else if bound  00000 $^    dispatchfunctionmodel uint00tmodel config$^   else if bound  0ull  00 $^    dispatchfunctionmodel uint00tmodel config$^   else $^    dispatchfunctionmodel uint00tmodel config$^  $^$^$^void dispatchconst char file const config config $^  using namespace lmngram$^  lmngrammodeltype modeltype$^  if lmngramrecognizebinaryfile modeltype $^    switchmodeltype $^      case probing$^        dispatchwidthlmngramprobingmodelfile config$^        break$^      case restprobing$^        dispatchwidthlmngramrestprobingmodelfile config$^        break$^      case trie$^        dispatchwidthlmngramtriemodelfile config$^        break$^      case quanttrie$^        dispatchwidthlmngramquanttriemodelfile config$^        break$^      case arraytrie$^        dispatchwidthlmngramarraytriemodelfile config$^        break$^      case quantarraytrie$^        dispatchwidthlmngramquantarraytriemodelfile config$^        break$^      default$^        utilthrowutilexception unrecognized kenlm model type   modeltype$^    $^   else $^    utilthrowutilexception binarize before running benchmarks.$^  $^$^$^  namespace$^$^int mainint argc char argv $^  try $^    config config$^    config.fdin  0$^    stdstring model$^    namespace po  boostprogramoptions$^    pooptionsdescription optionsbenchmark options$^    options.addoptions$^      helph poboolswitch show help message$^      modelm povaluestdstringmodelrequired model to query or convert vocab ids$^      threadst povaluestdsizetconfig.threadsdefaultvalueboostthreadhardwareconcurrency threads to use querying only todo vocab conversion$^      bufferb povaluestdsizetconfig.bufperthreaddefaultvalue0000 number of words to buffer per task.$^      vocabv poboolswitch convert strings to vocab ids$^      queryq poboolswitch query from vocab ids$^    povariablesmap vm$^    postorepoparsecommandlineargc argv options vm$^    if argc  0  vmhelp.asbool $^      stdcerr  benchmark program for kenlm.  intended usagen$^         convert text to vocabulary ids offline.  these ids are tied to a model.n$^         argv0   v m model text text.vocabn$^         ensure files are in ram.n$^         cat text.vocab model devnulln$^         timed query against the model.n$^         argv0   q m model text.vocabn$^      return 0$^    $^    ponotifyvm$^    if vmvocab.asbool  vmquery.asbool $^      stdcerr  specify exactly one of v vocab conversion or q query.  stdendl$^      return 0$^    $^    config.query  vmquery.asbool$^    if config.threads $^      stdcerr  specify a nonzero number of threads with t.  stdendl$^    $^    dispatchmodel.cstr config$^   catch const stdexception e $^    stdcerr  e.what  stdendl$^    return 0$^  $^  return 0$^$^include lmbinaryformat.hh$^include lmmodel.hh$^include lmleft.hh$^include utiltokenizepiece.hh$^$^template class model void queryconst char name $^  model modelname$^  stdstring line$^  lmngramchartstate ignored$^  while getlinestdcin line $^    lmngramrulescoremodel scorermodel ignored$^    for utiltokeniterutilsinglecharacter true iline   i i $^      scorer.terminalmodel.getvocabulary.indexi$^    $^    stdcout  scorer.finish  n$^  $^$^$^int mainint argc char argv $^  if argc  0 $^    stdcerr  expected model file name.  stdendl$^    return 0$^  $^  const char name  argv0$^  lmngrammodeltype modeltype  lmngramprobing$^  lmngramrecognizebinaryname modeltype$^  switch modeltype $^    case lmngramprobing$^      querylmngramprobingmodelname$^      break$^    case lmngramrestprobing$^      querylmngramrestprobingmodelname$^      break$^    default$^      stdcerr  model type not supported yet.  stdendl$^  $^$^ quantize into bins of equal size as described in$^  m. federico and n. bertoldi. 0000. how many bits are needed$^  to store probabilities for phrasebased translation in proc.$^  of the workshop on statistical machine translation pages$^  00000 new york city june. association for computa$^  tional linguistics.$^ $^$^include lmquantize.hh$^$^include lmbinaryformat.hh$^include lmlmexception.hh$^include utilfile.hh$^$^include algorithm$^include numeric$^$^namespace lm $^namespace ngram $^$^namespace $^$^void makebinsstdvectorfloat values float centers uint00t bins $^  stdsortvalues.begin values.end$^  stdvectorfloatconstiterator start  values.begin finish$^  for uint00t i  0 i  bins i centers start  finish $^    finish  values.begin  values.size  staticcastuint00ti  0  bins$^    if finish  start $^       zero length bucket.$^      centers  i  centers  0  stdnumericlimitsfloatinfinity$^     else $^      centers  stdaccumulatestart finish 0.0  staticcastfloatfinish  start$^    $^  $^$^$^const char kseparatelyquantizeversion  0$^$^  namespace$^$^void separatelyquantizeupdateconfigfrombinaryconst binaryformat file uint00t offset config config $^  unsigned char buffer0$^  file.readforconfigbuffer 0 offset$^  char version  buffer0$^  config.probbits  buffer0$^  config.backoffbits  buffer0$^  if version  kseparatelyquantizeversion utilthrowformatloadexception this file has quantization version   unsignedversion   but the code expects version   unsignedkseparatelyquantizeversion$^$^$^void separatelyquantizesetupmemoryvoid base unsigned char order const config config $^  probbits  config.probbits$^  backoffbits  config.backoffbits$^   we need the reserved values.$^  if config.probbits  0 utilthrowconfigexception you cant quantize probability to zero$^  if config.backoffbits  0 utilthrowconfigexception you cant quantize backoff to zero$^  if config.probbits  00 utilthrowconfigexception for efficiency reasons quantizing probability supports at most 00 bits.  currently you have requested   staticcastunsignedconfig.probbits   bits.$^  if config.backoffbits  00 utilthrowconfigexception for efficiency reasons quantizing backoff supports at most 00 bits.  currently you have requested   staticcastunsignedconfig.backoffbits   bits.$^   reserve 0 byte header for bit counts.$^  actualbase  staticcastuint0tbase$^  float start  reinterpretcastfloatactualbase  0$^  for unsigned char i  0 i  order  0 i $^    tablesi0  binsprobbits start$^    start  0ull  probbits$^    tablesi0  binsbackoffbits start$^    start  0ull  backoffbits$^  $^  longest  tablesorder  00  binsprobbits start$^$^$^void separatelyquantizetrainuint0t order stdvectorfloat prob stdvectorfloat backoff $^  trainproborder prob$^$^   backoff$^  float centers  tablesorder  00.populate$^  centers  knoextensionbackoff$^  centers  kextensionbackoff$^  makebinsbackoff centers 0ull  backoffbits  0$^$^$^void separatelyquantizetrainprobuint0t order stdvectorfloat prob $^  float centers  tablesorder  00.populate$^  makebinsprob centers 0ull  probbits$^$^$^void separatelyquantizefinishedloadingconst config config $^  uint0t actualbase  actualbase$^  actualbase  kseparatelyquantizeversion  version$^  actualbase  config.probbits$^  actualbase  config.backoffbits$^$^$^  namespace ngram$^  namespace lm$^include lmvocab.hh$^$^include lmbinaryformat.hh$^include lmenumeratevocab.hh$^include lmlmexception.hh$^include lmconfig.hh$^include lmweights.hh$^include utilexception.hh$^include utilfilestream.hh$^include utilfile.hh$^include utiljointsort.hh$^include utilmurmurhash.hh$^include utilprobinghashtable.hh$^$^include cstring$^include string$^$^namespace lm $^namespace ngram $^$^namespace detail $^uint00t hashforvocabconst char str stdsizet len $^   this proved faster than boosts hash in speed trials total load time murmur 00000000 boost 00000000$^   chose to use 00a instead of native so binary format will be portable across 00 and 00 bit.$^  return utilmurmurhash00astr len 0$^$^  namespace detail$^$^namespace $^ normally static initialization is a bad idea but murmurhash is pure arithmetic so this is ok.$^const uint00t kunknownhash  detailhashforvocabunk 0$^ sadly some lms have unk.$^const uint00t kunknowncaphash  detailhashforvocabunk 0$^$^void readwordsint fd enumeratevocab enumerate wordindex expectedcount uint00t offset $^  utilseekorthrowfd offset$^   check that were at the right place by reading unk which is always first.$^  char checkunk0$^  utilreadorthrowfd checkunk 0$^  utilthrowif$^      memcmpcheckunk unk 0$^      formatloadexception$^      vocabulary words are in the wrong place.  this could be because the binary file was built with stale gcc and old kenlm.  stale gcc including the gcc distributed with redhat and os x has a bug that ignores pragma pack for templatedependent types.  new kenlm works around this so youll save memory but have to rebuild any binary files using the probing data structure.$^  if enumerate return$^  enumerateadd0 unk$^$^  wordindex index  0  read unk already.$^  utilfilepiece inutilduporthrowfd$^  for utillineiterator win 0 w w index $^    enumerateaddindex w$^  $^  utilthrowifexpectedcount  index formatloadexception the binary file has the wrong number of words at the end.  this could be caused by a truncated binary file.$^$^$^ constructor ordering madness.$^int seekandreturnint fd uint00t start $^  utilseekorthrowfd start$^  return fd$^$^  namespace$^$^immediatewritewordswrapperimmediatewritewordswrapperenumeratevocab inner int fd uint00t start$^   innerinner streamseekandreturnfd start $^$^writewordswrapperwritewordswrapperenumeratevocab inner  innerinner $^$^void writewordswrapperaddwordindex index const stringpiece str $^  if inner inneraddindex str$^  buffer.appendstr.data str.size$^  buffer.pushback0$^$^$^void writewordswrapperwriteint fd uint00t start $^  utilseekorthrowfd start$^  utilwriteorthrowfd buffer.data buffer.size$^   free memory from the string.$^  stdstring forswap$^  stdswapbuffer forswap$^$^$^sortedvocabularysortedvocabulary  beginnull endnull enumeratenull $^$^uint00t sortedvocabularysizeuint00t entries const config config $^   lead with the number of entries.$^  return sizeofuint00t  sizeofuint00t  entries$^$^$^void sortedvocabularysetupmemoryvoid start stdsizet allocated stdsizet entries const config config $^  assertallocated  sizeentries config$^   leave space for number of entries.$^  begin  reinterpretcastuint00tstart  0$^  end  begin$^  sawunk  false$^$^$^void sortedvocabularyrelocatevoid newstart $^  stdsizet delta  end  begin$^  begin  reinterpretcastuint00tnewstart  0$^  end  begin  delta$^$^$^void sortedvocabularyconfigureenumerateenumeratevocab to stdsizet maxentries $^  enumerate  to$^  if enumerate $^    enumerateadd0 unk$^    stringstoenumerate.resizemaxentries$^  $^$^$^wordindex sortedvocabularyinsertconst stringpiece str $^  uint00t hashed  detailhashforvocabstr$^  if hashed  kunknownhash  hashed  kunknowncaphash $^    sawunk  true$^    return 0$^  $^  end  hashed$^  if enumerate $^    void copied  stringbacking.allocatestr.size$^    memcpycopied str.data str.size$^    stringstoenumerateend  begin  stringpiecestaticcastconst charcopied str.size$^  $^  end$^   this is 0  the offset where it was inserted to make room for unk.$^  return end  begin$^$^$^void sortedvocabularyfinishedloadingprobbackoff reorder $^  genericfinishedreorder$^$^$^namespace $^pragma packpush$^pragma pack0$^struct renumberentry $^  uint00t hash$^  const char str$^  wordindex old$^  bool operatorconst renumberentry other const $^    return hash  other.hash$^  $^$^pragma packpop$^  namespace$^$^void sortedvocabularycomputerenumberingwordindex types int fromwords int towords stdvectorwordindex mapping $^  mapping.clear$^  uint00t filesize  utilsizeorthrowfromwords$^  utilscopedmemory strings$^  utilmapreadutilpopulateorread fromwords 0 filesize strings$^  const char const start  staticcastconst charstrings.get$^  utilthrowifmemcmpstart unk 0 formatloadexception vocab file does not begin with unk followed by null$^  stdvectorrenumberentry entries$^  entries.reservetypes  0$^  renumberentry entry$^  entry.old  0$^  for entry.str  start  0  skip unk0  entry.str  start  filesize entry.old $^    stringpiece strentry.str strlenentry.str$^    entry.hash  detailhashforvocabstr$^    entries.pushbackentry$^    entry.str  str.size  0$^  $^  utilthrowif0entries.size  types  0 wrong number of vocab ids.  got   entries.size  0   expected   types$^  stdsortentries.begin entries.end$^   write out new vocab file.$^  $^    utilfilestream outtowords$^    out  unk  0$^    for stdvectorrenumberentryconstiterator i  entries.begin i  entries.end i $^      out  istr  0$^    $^  $^  strings.reset$^$^  mapping.resizetypes$^  mapping0  0  unk$^  for stdvectorrenumberentryconstiterator i  entries.begin i  entries.end i $^    mappingiold  i  0  entries.begin$^  $^$^$^void sortedvocabularypopulated $^  sawunk  true$^  setspecialindexs indexs 0$^  bound  end  begin  0$^  reinterpretcastuint00tbegin  0  end  begin$^$^$^void sortedvocabularyloadedbinarybool havewords int fd enumeratevocab to uint00t offset $^  end  begin  reinterpretcastconst uint00tbegin  0$^  setspecialindexs indexs 0$^  bound  end  begin  0$^  if havewords readwordsfd to bound offset$^$^$^template class t void sortedvocabularygenericfinishedt reorder $^  if enumerate $^    if stringstoenumerate.empty $^      utilpairediteratort stringpiece valuesreorder  0 stringstoenumerate.begin$^      utiljointsortbegin end values$^    $^    for wordindex i  0 i  staticcastwordindexend  begin i $^       unk strikes again 0 here.$^      enumerateaddi  0 stringstoenumeratei$^    $^    stringstoenumerate.clear$^    stringbacking.freeall$^   else $^    utiljointsortbegin end reorder  0$^  $^  setspecialindexs indexs 0$^   save size.  excludes unk.$^  reinterpretcastuint00tbegin  0  end  begin$^   includes unk.$^  bound  end  begin  0$^$^$^namespace $^const unsigned int kprobingvocabularyversion  0$^  namespace$^$^namespace detail $^struct probingvocabularyheader $^   lowest unused vocab id.  this is also the number of words including unk.$^  unsigned int version$^  wordindex bound$^$^  namespace detail$^$^probingvocabularyprobingvocabulary  enumeratenull $^$^uint00t probingvocabularysizeuint00t entries float probingmultiplier $^  return align0sizeofdetailprobingvocabularyheader  lookupsizeentries probingmultiplier$^$^$^uint00t probingvocabularysizeuint00t entries const config config $^  return sizeentries config.probingmultiplier$^$^$^void probingvocabularysetupmemoryvoid start stdsizet allocated $^  header  staticcastdetailprobingvocabularyheaderstart$^  lookup  lookupstaticcastuint0tstart  align0sizeofdetailprobingvocabularyheader allocated$^  bound  0$^  sawunk  false$^$^$^void probingvocabularyrelocatevoid newstart $^  header  staticcastdetailprobingvocabularyheadernewstart$^  lookup.relocatestaticcastuint0tnewstart  align0sizeofdetailprobingvocabularyheader$^$^$^void probingvocabularyconfigureenumerateenumeratevocab to stdsizet maxentries $^  enumerate  to$^  if enumerate $^    enumerateadd0 unk$^  $^$^$^wordindex probingvocabularyinsertconst stringpiece str $^  uint00t hashed  detailhashforvocabstr$^   prevent unknown from going into the table.$^  if hashed  kunknownhash  hashed  kunknowncaphash $^    sawunk  true$^    return 0$^   else $^    if enumerate enumerateaddbound str$^    lookup.insertprobingvocabularyentrymakehashed bound$^    return bound$^  $^$^$^void probingvocabularyinternalfinishedloading $^  lookup.finishedinserting$^  headerbound  bound$^  headerversion  kprobingvocabularyversion$^  setspecialindexs indexs 0$^$^$^void probingvocabularyloadedbinarybool havewords int fd enumeratevocab to uint00t offset $^  utilthrowifheaderversion  kprobingvocabularyversion formatloadexception the binary file has probing version   headerversion   but the code expects version   kprobingvocabularyversion  .  please rerun buildbinary using the same version of the code.$^  bound  headerbound$^  setspecialindexs indexs 0$^  if havewords readwordsfd to bound offset$^$^$^void missingunknownconst config config $^  switchconfig.unknownmissing $^    case silent$^      return$^    case complain$^      if config.messages config.messages  the arpa file is missing unk.  substituting log00 probability   config.unknownmissinglogprob  .  stdendl$^      break$^    case throwup$^      utilthrowspecialwordmissingexception the arpa file is missing unk and the model is configured to throw an exception.$^  $^$^$^void missingsentencemarkerconst config config const char str $^  switch config.sentencemarkermissing $^    case silent$^      return$^    case complain$^      if config.messages config.messages  missing special word   str   will treat it as unk.$^      break$^    case throwup$^      utilthrowspecialwordmissingexception the arpa file is missing   str   and the model is configured to reject these models.  run buildbinary s to disable this check.$^  $^$^$^  namespace ngram$^  namespace lm$^ this is where the trie is built.  its ondisk.  $^include lmsearchtrie.hh$^$^include lmbhiksha.hh$^include lmbinaryformat.hh$^include lmblank.hh$^include lmlmexception.hh$^include lmmaxorder.hh$^include lmquantize.hh$^include lmtrie.hh$^include lmtriesort.hh$^include lmvocab.hh$^include lmweights.hh$^include lmwordindex.hh$^include utilersatzprogress.hh$^include utilmmap.hh$^include utilproxyiterator.hh$^include utilscoped.hh$^include utilsizediterator.hh$^$^include algorithm$^include cstring$^include cstdio$^include cstdlib$^include queue$^include limits$^include numeric$^include vector$^$^if definedwin00  definedwin00$^include windows.h$^endif$^$^namespace lm $^namespace ngram $^namespace trie $^namespace $^$^void readorthrowfile from void data sizet size $^  utilthrowif0  stdfreaddata size 0 from utilerrnoexception short read$^$^$^int compareunsigned char order const void firstvoid const void secondvoid $^  const wordindex first  reinterpretcastconst wordindexfirstvoid second  reinterpretcastconst wordindexsecondvoid$^  const wordindex end  first  order$^  for  first  end first second $^    if first  second return 0$^    if first  second return 0$^  $^  return 0$^$^$^struct probpointer $^  unsigned char array$^  uint00t index$^$^$^ array of ngrams and float indices.$^class backoffmessages $^  public$^    void initstdsizet entrysize $^      current  null$^      allocated  null$^      entrysize  entrysize$^    $^$^    void addconst wordindex to probpointer index $^      while current  entrysize  allocated $^        stdsizet allocatedsize  allocated  uint0tbacking.get$^        resizestdmaxstdsizetallocatedsize  0 entrysize$^      $^      memcpycurrent to entrysize  sizeofprobpointer$^      reinterpretcastprobpointercurrent  entrysize  sizeofprobpointer  index$^      current  entrysize$^    $^$^    void applyfloat const const base file unigrams $^      finishedadding$^      if current  allocated return$^      rewindunigrams$^      probbackoff weights$^      wordindex unigram  0$^      readorthrowunigrams weights sizeofweights$^      for  current  allocated current  entrysize $^        const wordindex curword  reinterpretcastconst wordindexcurrent$^        for  unigram  curword unigram $^          readorthrowunigrams weights sizeofweights$^        $^        if hasextensionweights.backoff $^          weights.backoff  kextensionbackoff$^          utilthrowiffseekunigrams sizeofweights seekcur utilerrnoexception seeking backwards to denote unigram extension failed.$^          utilwriteorthrowunigrams weights sizeofweights$^        $^        const probpointer writeto  reinterpretcastconst probpointercurrent  sizeofwordindex$^        basewriteto.arraywriteto.index  weights.backoff$^      $^      backing.reset$^    $^$^    void applyfloat const const base recordreader reader $^      finishedadding$^      if current  allocated return$^       well also use the same buffer to record messages to blanks that they extend.$^      wordindex extendout  reinterpretcastwordindexcurrent$^      const unsigned char order  entrysize  sizeofprobpointer  sizeofwordindex$^      for reader.rewind reader  current  allocated  $^        switch compareorder reader.data current $^          case 0$^            reader$^            break$^          case 0$^             message but nobody to receive it.  write it down at the beginning of the buffer so we can inform this blank that it extends.$^            for const wordindex w  reinterpretcastconst wordindex current w  reinterpretcastconst wordindex current  order w extendout extendout  w$^            current  entrysize$^            break$^          case 0$^            float backoff  reinterpretcastprobbackoffuint0treader.data  order  sizeofwordindexbackoff$^            if hasextensionbackoff $^              backoff  kextensionbackoff$^              reader.overwritebackoff sizeoffloat$^             else $^              const probpointer writeto  reinterpretcastconst probpointercurrent  entrysize  sizeofprobpointer$^              basewriteto.arraywriteto.index  backoff$^            $^            current  entrysize$^            break$^        $^      $^       now this is a list of blanks that extend right.$^      entrysize  sizeofwordindex  order$^      resizesizeofwordindex  extendout  const wordindexbacking.get$^      current  uint0tbacking.get$^    $^$^     call after apply$^    bool extendsunsigned char order const wordindex words $^      if current  allocated return false$^      assertorder  sizeofwordindex  entrysize$^      while true $^        switchcompareorder words current $^          case 0$^            current  entrysize$^            if current  allocated return false$^            break$^          case 0$^            return false$^          case 0$^            return true$^        $^      $^    $^$^  private$^    void finishedadding $^      resizecurrent  uint0tbacking.get$^       sort requests in same order as files.$^      utilsizedsortbacking.get current entrysize entrycompareentrysize  sizeofprobpointer  sizeofwordindex$^      current  uint0tbacking.get$^    $^$^    void resizestdsizet to $^      stdsizet current  current  uint0tbacking.get$^      backing.callreallocto$^      current  uint0tbacking.get  current$^      allocated  uint0tbacking.get  to$^    $^$^    utilscopedmalloc backing$^$^    uint0t current allocated$^$^    stdsizet entrysize$^$^$^const float kbadprob  stdnumericlimitsfloatinfinity$^$^class srisucks $^  public$^    srisucks $^      for backoffmessages i  messages i  messages  kenlmmaxorder  0 i$^        iinitsizeofprobpointer  sizeofwordindex  i  messages  0$^    $^$^    void sendunsigned char begin unsigned char order const wordindex to float probbasis $^      assertprobbasis  kbadprob$^      probpointer pointer$^      pointer.array  order  0$^      pointer.index  valuesorder  0.size$^      for unsigned char i  begin i  order i $^        messagesi  0.addto pointer$^      $^      valuesorder  0.pushbackprobbasis$^    $^$^    void obtainbackoffsunsigned char totalorder file unigramfile recordreader reader $^      for unsigned char i  0 i  kenlmmaxorder  0 i $^        iti  valuesi.empty  null  valuesi.begin$^      $^      messages0.applyit unigramfile$^      backoffmessages messages  messages  0$^      const recordreader end  reader  totalorder  0  exclude unigrams and longest order $^      for  reader  end messages reader $^        messagesapplyit reader$^      $^    $^$^    probbackoff getblankunsigned char totalorder unsigned char order const wordindex indices $^      assertorder  0$^      probbackoff ret$^      ret.prob  itorder  0$^      ret.backoff  order  totalorder  0  messagesorder  0.extendsorder indices  kextensionbackoff  knoextensionbackoff$^      return ret$^    $^$^    const stdvectorfloat valuesunsigned char order const $^      return valuesorder  0$^    $^$^  private$^     this used to be one array.  then i needed to separate it by order for quantization to work.$^    stdvectorfloat valueskenlmmaxorder  0$^    backoffmessages messageskenlmmaxorder  0$^$^    float itkenlmmaxorder  0$^$^$^class findblanks $^  public$^    findblanksunsigned char order const probbackoff unigrams srisucks messages$^       countsorder unigramsunigrams srimessages $^$^    float unigramprobwordindex index const $^      return unigramsindex.prob$^    $^$^    void unigramwordindex index $^      counts0$^    $^$^    void middleblankconst unsigned char order const wordindex indices unsigned char lower float probbasis $^      sri.sendlower order indices  0 probbasis$^      countsorder  0$^    $^$^    void middleconst unsigned char order const void  data $^      countsorder  0$^    $^$^    void longestconst void  data $^      counts.back$^    $^$^    const stdvectoruint00t counts const $^      return counts$^    $^$^  private$^    stdvectoruint00t counts$^$^    const probbackoff unigrams$^$^    srisucks sri$^$^$^ phase to actually write ngrams to the trie.$^template class quant class bhiksha class writeentries $^  public$^    writeentriesrecordreader contexts const quant quant unigramvalue unigrams bitpackedmiddlebhiksha middle bitpackedlongest longest unsigned char order srisucks sri $^      contextscontexts$^      quantquant$^      unigramsunigrams$^      middlemiddle$^      longestlongest$^      bigrampackorder  0  staticcastbitpackedlongest  staticcastbitpackedmiddle$^      orderorder$^      srisri $^$^    float unigramprobwordindex index const  return unigramsindex.weights.prob $^$^    void unigramwordindex word $^      unigramsword.next  bigrampack.insertindex$^    $^$^    void middleblankconst unsigned char order const wordindex indices unsigned char lower float probbase $^      probbackoff weights  sri.getblankorder order indices$^      typename quantmiddlepointerquant order  0 middleorder  0.insertindicesorder  0.writeweights.prob weights.backoff$^    $^$^    void middleconst unsigned char order const void data $^      recordreader context  contextsorder  0$^      const wordindex words  reinterpretcastconst wordindexdata$^      probbackoff weights  reinterpretcastconst probbackoffwords  order$^      if context  memcmpdata context.data sizeofwordindex  order $^        setextensionweights.backoff$^        context$^      $^      typename quantmiddlepointerquant order  0 middleorder  0.insertwordsorder  0.writeweights.prob weights.backoff$^    $^$^    void longestconst void data $^      const wordindex words  reinterpretcastconst wordindexdata$^      typename quantlongestpointerquant longest.insertwordsorder  0.writereinterpretcastconst probwords  orderprob$^    $^$^  private$^    recordreader contexts$^    const quant quant$^    unigramvalue const unigrams$^    bitpackedmiddlebhiksha const middle$^    bitpackedlongest longest$^    bitpacked bigrampack$^    const unsigned char order$^    srisucks sri$^$^$^struct gram $^  gramconst wordindex inbegin unsigned char order  begininbegin endinbegin  order $^$^  const wordindex begin end$^$^   for queue this is the direction we want.$^  bool operatorconst gram other const $^    return stdlexicographicalcompareother.begin other.end begin end$^  $^$^$^template class doing class blankmanager $^  public$^    blankmanagerunsigned char totalorder doing doing  totalordertotalorder beenlength0 doingdoing $^      for float i  basis i  basis  kenlmmaxorder  0 i i  kbadprob$^    $^$^    void visitconst wordindex to unsigned char length float prob $^      basislength  0  prob$^      unsigned char overlap  stdminunsigned charlength  0 beenlength$^      const wordindex cur$^      wordindex pre$^      for cur  to pre  been cur  to  overlap cur pre $^        if pre  cur break$^      $^      if cur  to  length  0 $^        pre  cur$^        beenlength  length$^        return$^      $^       there are blanks to insert starting with order blank.$^      unsigned char blank  cur  to  0$^      utilthrowifblank  0 formatloadexception missing a unigram that appears as context.$^      const float lowerbasis$^      for lowerbasis  basis  blank  0 lowerbasis  kbadprob lowerbasis $^      unsigned char basedon  lowerbasis  basis  0$^      for  cur  to  length  0 blank cur pre $^        assertlowerbasis  kbadprob$^        doing.middleblankblank to basedon lowerbasis$^        pre  cur$^         mark that the probability is a blank so it shouldnt be used as the basis for a later ngram.$^        basisblank  0  kbadprob$^      $^      pre  cur$^      beenlength  length$^    $^$^  private$^    const unsigned char totalorder$^$^    wordindex beenkenlmmaxorder$^    unsigned char beenlength$^$^    float basiskenlmmaxorder$^$^    doing doing$^$^$^template class doing void recursiveinsertconst unsigned char totalorder const wordindex unigramcount recordreader input stdostream progressout const char message doing doing $^  utilersatzprogress progressunigramcount  0 progressout message$^  wordindex unigram  0$^  stdpriorityqueuegram grams$^  if unigramcount grams.pushgramunigram 0$^  for unsigned char i  0 i  totalorder i $^    if inputi0 grams.pushgramreinterpretcastconst wordindexinputi0.data i$^  $^$^  blankmanagerdoing blanktotalorder doing$^$^  while grams.empty $^    gram top  grams.top$^    grams.pop$^    unsigned char order  top.end  top.begin$^    if order  0 $^      blank.visitunigram 0 doing.unigramprobunigram$^      doing.unigramunigram$^      progress.setunigram$^      if unigram  unigramcount grams.pushtop$^     else $^      if order  totalorder $^        blank.visittop.begin order reinterpretcastconst probtop.endprob$^        doing.longesttop.begin$^       else $^        blank.visittop.begin order reinterpretcastconst probbackofftop.endprob$^        doing.middleorder top.begin$^      $^      recordreader reader  inputorder  0$^      if reader grams.pushtop$^    $^  $^$^$^void sanitycheckcountsconst stdvectoruint00t initial const stdvectoruint00t fixed $^  if fixed0  initial0 utilthrowutilexception unigram count should be constant but initial is   initial0   and recounted is   fixed0$^  if fixed.back  initial.back utilthrowutilexception longest count should be constant but it changed from   initial.back   to   fixed.back$^  for unsigned char i  0 i  initial.size i $^    if fixedi  initiali utilthrowutilexception counts came out lower than expected.  this shouldnt happen$^  $^$^$^template class quant void trainquantizeruint0t order uint00t count const stdvectorfloat additional recordreader reader utilersatzprogress progress quant quant $^  stdvectorfloat probsadditional backoffs$^  probs.reservecount  additional.size$^  backoffs.reservecount$^  for reader.rewind reader reader $^    const probbackoff weights  reinterpretcastconst probbackoffreinterpretcastconst uint0treader.data  sizeofwordindex  order$^    probs.pushbackweights.prob$^    if weights.backoff  0.0 backoffs.pushbackweights.backoff$^    progress$^  $^  quant.trainorder probs backoffs$^$^$^template class quant void trainprobquantizeruint0t order uint00t count recordreader reader utilersatzprogress progress quant quant $^  stdvectorfloat probs backoffs$^  probs.reservecount$^  for reader.rewind reader reader $^    const prob weights  reinterpretcastconst probreinterpretcastconst uint0treader.data  sizeofwordindex  order$^    probs.pushbackweights.prob$^    progress$^  $^  quant.trainproborder probs$^$^$^void populateunigramweightsfile file wordindex unigramcount recordreader contexts unigramvalue unigrams $^   fill unigram probabilities.$^  try $^    rewindfile$^    for wordindex i  0 i  unigramcount i $^      readorthrowfile unigramsi.weights sizeofprobbackoff$^      if contexts  reinterpretcastconst wordindexcontexts.data  i $^        setextensionunigramsi.weights.backoff$^        contexts$^      $^    $^   catch utilexception e $^    e   while rereading unigram probabilities$^    throw$^  $^$^$^  namespace$^$^template class quant class bhiksha void buildtriesortedfiles files stdvectoruint00t counts const config config triesearchquant bhiksha out quant quant sortedvocabulary vocab binaryformat backing $^  recordreader inputskenlmmaxorder  0$^  recordreader contextskenlmmaxorder  0$^$^  for unsigned char i  0 i  counts.size i $^    inputsi0.initfiles.fulli i  sizeofwordindex  i  counts.size  sizeofprob  sizeofprobbackoff$^    contextsi0.initfiles.contexti i0  sizeofwordindex$^  $^$^  srisucks sri$^  stdvectoruint00t fixedcounts$^  utilscopedfile unigramfile$^  utilscopedfd unigramfdfiles.stealunigram$^  $^    utilscopedmemory unigrams$^    mapreadutilpopulateorread unigramfd.get 0 counts0  sizeofprobbackoff unigrams$^    findblanks findercounts.size reinterpretcastconst probbackoffunigrams.get sri$^    recursiveinsertcounts.size counts0 inputs config.progressmessages identifying ngrams omitted by sri finder$^    fixedcounts  finder.counts$^  $^  unigramfile.resetutilfdopenorthrowunigramfd$^  for const recordreader i  inputs i  inputs  counts.size  0 i $^    if i utilthrowformatloadexception theres a bug in the trie implementation the   i  inputs  0  gram table did not complete reading$^  $^  sanitycheckcountscounts fixedcounts$^  counts  fixedcounts$^$^  sri.obtainbackoffscounts.size unigramfile.get inputs$^$^  void vocabrelocate$^  void searchbase  backing.growforsearchtriesearchquant bhikshasizefixedcounts config vocab.unkcountchangepadding vocabrelocate$^  vocab.relocatevocabrelocate$^  out.setupmemoryreinterpretcastuint0tsearchbase fixedcounts config$^$^  for unsigned char i  0 i  counts.size i $^    inputsi0.rewind$^  $^  if quantktrain $^    utilersatzprogress progressstdaccumulatecounts.begin  0 counts.end 0$^                                  config.progressmessages quantizing$^    for unsigned char i  0 i  counts.size i $^      trainquantizeri countsi0 sri.valuesi inputsi0 progress quant$^    $^    trainprobquantizercounts.size counts.back inputscounts.size  0 progress quant$^    quant.finishedloadingconfig$^  $^$^  unigramvalue unigrams  out.unigram.raw$^  populateunigramweightsunigramfile.get counts0 contexts0 unigrams$^  unigramfile.reset$^$^  for unsigned char i  0 i  counts.size i $^    inputsi0.rewind$^  $^   fill entries except unigram probabilities.$^  $^    writeentriesquant bhiksha writercontexts quant unigrams out.middlebegin out.longest counts.size sri$^    recursiveinsertcounts.size counts0 inputs config.progressmessages writing trie writer$^     write the last unigram entry which is the end pointer for the bigrams.$^    writer.unigramcounts0$^  $^$^   do not disable this error message or else too little state will be returned.  both writeentriesmiddle and returning state based on found ngrams will need to be fixed to handle this situation.$^  for unsigned char order  0 order  counts.size order $^    const recordreader context  contextsorder  0$^    if context $^      formatloadexception e$^      e  a   staticcastunsigned intorder  gram has context$^      const wordindex ctx  reinterpretcastconst wordindexcontext.data$^      for const wordindex i  ctx i  ctx  order  0 i $^        e     i$^      $^      e   so this context must appear in the model as a   staticcastunsigned intorder  0  gram but it does not$^      throw e$^    $^  $^$^   set ending offsets so the last entry will be sized properly $^   last entry for unigrams was already set.$^  if out.middlebegin  out.middleend $^    for typename triesearchquant bhikshamiddle i  out.middlebegin i  out.middleend  0 i $^      ifinishedloadingi0insertindex config$^    $^    out.middleend  0finishedloadingout.longest.insertindex config$^  $^$^$^template class quant class bhiksha uint0t triesearchquant bhikshasetupmemoryuint0t start const stdvectoruint00t counts const config config $^  quant.setupmemorystart counts.size config$^  start  quantsizecounts.size config$^  unigram.initstart$^  start  unigramsizecounts0$^  freemiddles$^  middlebegin  staticcastmiddlemallocsizeofmiddle  counts.size  0$^  middleend  middlebegin  counts.size  0$^  stdvectoruint0t middlestartscounts.size  0$^  for unsigned char i  0 i  counts.size i $^    middlestartsi0  start$^    start  middlesizequantmiddlebitsconfig countsi0 counts0 countsi config$^  $^   crazy backwards thing so we initialize using pointers to ones that have already been initialized$^  for unsigned char i  counts.size  0 i  0 i $^     use placement new syntax to initalize middle in an alreadyallocated memory location$^    new middlebegin  i  0 middle$^        middlestartsi0$^        quant.middlebitsconfig$^        countsi0$^        counts0$^        countsi$^        i  counts.size  0  staticcastconst bitpackedlongest  staticcastconst bitpacked middlebegini0$^        config$^  $^  longest.initstart quant.longestbitsconfig counts0$^  return start  longestsizequantlongestbitsconfig counts.back counts0$^$^$^template class quant class bhiksha void triesearchquant bhikshainitializefromarpaconst char file utilfilepiece f stdvectoruint00t counts const config config sortedvocabulary vocab binaryformat backing $^  stdstring temporaryprefix$^  if config.temporarydirectoryprefix.empty $^    temporaryprefix  config.temporarydirectoryprefix$^   else if config.writemmap $^    temporaryprefix  config.writemmap$^   else $^    temporaryprefix  file$^  $^   at least 0mb sorting memory.$^  sortedfiles sortedconfig f counts stdmaxsizetconfig.buildingmemory 0000000 temporaryprefix vocab$^$^  buildtriesorted counts config this quant vocab backing$^$^$^template class triesearchdontquantize dontbhiksha$^template class triesearchdontquantize arraybhiksha$^template class triesearchseparatelyquantize dontbhiksha$^template class triesearchseparatelyquantize arraybhiksha$^$^  namespace trie$^  namespace ngram$^  namespace lm$^include lmconfig.hh$^$^include iostream$^$^namespace lm $^namespace ngram $^$^configconfig $^  showprogresstrue$^  messagesstdcerr$^  enumeratevocabnull$^  unknownmissingcomplain$^  sentencemarkermissingthrowup$^  positivelogprobabilitythrowup$^  unknownmissinglogprob000.0$^  probingmultiplier0.0$^  buildingmemory0000000000ull  0 gb$^  temporarydirectoryprefix$^  arpacomplainall$^  writemmapnull$^  writemethodwriteafter$^  includevocabtrue$^  restfunctionrestmax$^  probbits0$^  backoffbits0$^  pointerbhikshabits00$^  loadmethodutilpopulateorread $^$^  namespace ngram$^  namespace lm$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^ regression test for various fst algorithms.$^$^include fsttestalgotest.h$^$^include cstdlib$^$^include vector$^$^include fstflags.h$^$^ defines determine which semirings are tested these are controlled by$^ the defines attributes of the associated build rules.$^$^defineint00seed 0 random seed$^defineint00repeat 00 number of test repetitions$^$^using fstalgotester$^using fstarctpl$^using fstgallicarc$^using fstgallicweight$^using fstlexicographicarc$^using fstlexicographicweight$^using fstlogarc$^using fstlogweight$^using fstminmaxarc$^using fstminmaxweight$^using fstpowerweight$^using fststringleft$^using fststringright$^using fststdarc$^using fststringarc$^using fststringweight$^using fsttropicalweight$^using fstweightgenerate$^$^int mainint argc char argv $^  flagsfstverifyproperties  true$^  stdsetnewhandlerfailednewhandler$^  setflagsargv0 argc argv true$^$^  static const int kcachegclimit  00$^$^  srandflagsseed$^  loginfo  seed    flagsseed$^$^  flagsfstdefaultcachegc  rand  0$^  flagsfstdefaultcachegclimit  rand  kcachegclimit$^  vlog0  defaultcachegc  flagsfstdefaultcachegc$^  vlog0  defaultcachegclimit  flagsfstdefaultcachegclimit$^$^ifdef testtropical$^  using tropicalweightgenerate  weightgeneratetropicalweight$^  tropicalweightgenerate tropicalgeneratorfalse$^  algotesterstdarc tropicalweightgenerate tropicaltester$^      tropicalgenerator flagsseed$^  tropicaltester.test$^endif   testtropical$^$^ifdef testlog$^  using logweightgenerate  weightgeneratelogweight$^  logweightgenerate loggeneratorfalse$^  algotesterlogarc logweightgenerate logtesterloggenerator flagsseed$^  logtester.test$^endif   testlog$^$^ifdef testminmax$^  using minmaxweightgenerate  weightgenerateminmaxweight$^  minmaxweightgenerate minmaxgeneratorfalse$^  algotesterminmaxarc minmaxweightgenerate minmaxtesterminmaxgenerator$^                                                             flagsseed$^  minmaxtester.test$^endif$^$^ifdef testleftstring$^  using stringweightgenerate  weightgeneratestringweightint stringleft$^  stringweightgenerate leftstringgeneratorfalse$^  algotesterstringarc stringweightgenerate leftstringtester$^      leftstringgenerator flagsseed$^  leftstringtester.test$^endif   testleftstring$^$^ifdef testrightstring$^  using stringweightgenerate $^      weightgeneratestringweightint stringright$^  stringweightgenerate rightstringgeneratorfalse$^  algotesterstringarcstringright stringweightgenerate$^      rightstringtesterrightstringgenerator flagsseed$^  rightstringtester.test$^endif   testrightstring$^$^ifdef testgallic$^  using stdgallicarc  gallicarcstdarc$^  using tropicalgallicweightgenerate $^      weightgenerategallicweightint tropicalweight$^  tropicalgallicweightgenerate tropicalgallicgeneratorfalse$^  algotesterstdgallicarc tropicalgallicweightgenerate gallictester$^      tropicalgallicgenerator flagsseed$^  gallictester.test$^endif   testgallic$^$^ifdef testlexicographic$^  using tropicallexicographicarc $^      lexicographicarctropicalweight tropicalweight$^  using tropicallexicographicweightgenerate $^      weightgeneratelexicographicweighttropicalweight tropicalweight$^  tropicallexicographicweightgenerate lexicographicgeneratorfalse$^  algotestertropicallexicographicarc tropicallexicographicweightgenerate$^      lexicographictesterlexicographicgenerator flagsseed$^  lexicographictester.test$^endif   testlexicographic$^$^ifdef testpower$^  using tropicalcubeweight  powerweighttropicalweight 0$^  using tropicalcubearc  arctpltropicalcubeweight$^  using tropicalcubeweightgenerate  weightgeneratetropicalcubeweight$^  tropicalcubeweightgenerate tropicalcubegeneratorfalse$^  algotestertropicalcubearc tropicalcubeweightgenerate tropicalcubetester$^      tropicalcubegenerator flagsseed$^  tropicalcubetester.test$^endif   testpower$^$^  stdcout  pass  stdendl$^$^  return 0$^$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^ regression test for fst weights.$^$^include cstdlib$^include ctime$^$^include fstflags.h$^include fstlog.h$^include fstexpectationweight.h$^include fstfloatweight.h$^include fstlexicographicweight.h$^include fstpowerweight.h$^include fstproductweight.h$^include fstsetweight.h$^include fstsignedlogweight.h$^include fstsparsepowerweight.h$^include fststringweight.h$^include fstunionweight.h$^include fsttestweighttester.h$^$^defineint00seed 0 random seed$^defineint00repeat 00000 number of test repetitions$^$^namespace $^$^using fstadder$^using fstexpectationweight$^using fstgallic$^using fstgallicweight$^using fstlexicographicweight$^using fstlogweight$^using fstlogweighttpl$^using fstminmaxweight$^using fstminmaxweighttpl$^using fstnaturalless$^using fstpowerweight$^using fstproductweight$^using fstsetweight$^using fstsetintersectunion$^using fstsetunionintersect$^using fstsetboolean$^using fstsignedlogweight$^using fstsignedlogweighttpl$^using fstsparsepowerweight$^using fststringweight$^using fststringleft$^using fststringright$^using fsttropicalweight$^using fsttropicalweighttpl$^using fstunionweight$^using fstweightconvert$^using fstweightgenerate$^using fstweighttester$^$^template class t$^void testtemplatedweightsint repeat $^  using tropicalweightgenerate  weightgeneratetropicalweighttplt$^  tropicalweightgenerate tropicalgenerate$^  weighttestertropicalweighttplt tropicalweightgenerate tropicaltester$^      tropicalgenerate$^  tropicaltester.testrepeat$^$^  using logweightgenerate  weightgeneratelogweighttplt$^  logweightgenerate loggenerate$^  weighttesterlogweighttplt logweightgenerate logtesterloggenerate$^  logtester.testrepeat$^$^  using minmaxweightgenerate  weightgenerateminmaxweighttplt$^  minmaxweightgenerate minmaxgeneratetrue$^  weighttesterminmaxweighttplt minmaxweightgenerate minmaxtester$^      minmaxgenerate$^  minmaxtester.testrepeat$^$^  using signedlogweightgenerate  weightgeneratesignedlogweighttplt$^  signedlogweightgenerate signedloggenerate$^  weighttestersignedlogweighttplt signedlogweightgenerate$^      signedlogtestersignedloggenerate$^  signedlogtester.testrepeat$^$^$^template class weight$^void testadderint n $^  weight sum  weightzero$^  adderweight adder$^  for int i  0 i  n i $^    sum  plussum weightone$^    adder.addweightone$^  $^  checkapproxequalsum adder.sum$^$^$^template class weight$^void testsignedadderint n $^  weight sum  weightzero$^  adderweight adder$^  const weight minusone  minusweightzero weightone$^  for int i  0 i  n i $^    if i  n0  i  0n0 $^      sum  plussum weightone$^      adder.addweightone$^     else $^      sum  minussum weightone$^      adder.addminusone$^    $^  $^  checkapproxequalsum adder.sum$^$^$^template typename weight0 typename weight0$^void testweightconversionweight0 w0 $^   tests roundtrp conversion.$^  weightconvertweight0 weight0 tow0$^  weightconvertweight0 weight0 tow0$^  weight0 w0  tow0w0$^  weight0 nw0  tow0w0$^  checkeqw0 nw0$^$^$^template typename fromweight typename toweight$^void testweightcopyfromweight w $^   test copy constructor.$^  const toweight tocopiedw$^  const fromweight roundtripcopiedtocopied$^  checkeqw roundtripcopied$^$^   test copy assign.$^  toweight tocopyassigned$^  tocopyassigned  w$^  checkeqtocopied tocopyassigned$^$^  fromweight roundtripcopyassigned$^  roundtripcopyassigned  tocopyassigned$^  checkeqw roundtripcopyassigned$^$^$^template typename fromweight typename toweight$^void testweightmovefromweight w $^   assume fromweight  fromweight copy works.$^  const fromweight origw$^  toweight tomovedstdmovew$^  const fromweight roundtripmovedstdmovetomoved$^  checkeqorig roundtripmoved$^$^   test move assign.$^  w  orig$^  toweight tomoveassigned$^  tomoveassigned  stdmovew$^  fromweight roundtripmoveassigned$^  roundtripmoveassigned  stdmovetomoveassigned$^  checkeqorig roundtripmoveassigned$^$^$^template class weight$^void testimplicitconversion $^   only test a few of the operations assumes they are implemented with the$^   same pattern.$^  checkweight0.0f  0.0f$^  checkweight0.0  0.0$^  check0.0f  weight0.0f$^  check0.0  weight0.0$^$^  checkeqweightzero timesweightzero 0.0f$^  checkeqweightzero timesweightzero 0.0$^  checkeqweightzero times0.0 weightzero$^$^  checkeqweight0.0 plusweightzero 0.0f$^  checkeqweight0.0 plusweightzero 0.0$^  checkeqweight0.0 plus0.0 weightzero$^$^$^void testpowerweightgetsetvalue $^  powerweightlogweight 0 w$^   logweight has unspecified initial value so dont check it.$^  w.setvalue0 logweight0$^  w.setvalue0 logweight0$^  checkeqlogweight0 w.value0$^  checkeqlogweight0 w.value0$^$^$^void testsparsepowerweightgetsetvalue $^  const logweight defaultvalue00$^  sparsepowerweightlogweight w$^  w.setdefaultvaluedefaultvalue$^$^   all gets should be the default.$^  checkeqdefaultvalue w.value0$^  checkeqdefaultvalue w.value000$^$^   first set should fill first.$^  w.setvalue00 logweight00$^  checkeqlogweight00 w.value00$^  w.setvalue00 logweight00$^  checkeqlogweight00 w.value00$^$^   add a smaller index.$^  w.setvalue0 logweight0$^  checkeqlogweight0 w.value0$^  checkeqlogweight00 w.value00$^$^   add some larger indices.$^  w.setvalue00 logweight00$^  checkeqlogweight0 w.value0$^  checkeqlogweight00 w.value00$^  checkeqlogweight00 w.value00$^$^  w.setvalue00 logweight00$^  checkeqlogweight0 w.value0$^  checkeqlogweight00 w.value00$^  checkeqlogweight00 w.value00$^  checkeqlogweight00 w.value00$^$^  w.setvalue00 logweight00$^  checkeqlogweight0 w.value0$^  checkeqlogweight00 w.value00$^  checkeqlogweight00 w.value00$^  checkeqlogweight00 w.value00$^  checkeqlogweight00 w.value00$^$^   replace a value.$^  w.setvalue00 logweight00$^  checkeqlogweight00 w.value00$^$^   replace a value with the default.$^  checkeq0 w.size$^  w.setvalue00 defaultvalue$^  checkeqdefaultvalue w.value00$^  checkeq0 w.size$^$^   replace lowest index by the default value.$^  w.setvalue0 defaultvalue$^  checkeqdefaultvalue w.value0$^  checkeq0 w.size$^$^   clear out everything.$^  w.setvalue00 defaultvalue$^  w.setvalue00 defaultvalue$^  w.setvalue00 defaultvalue$^  checkeq0 w.size$^$^  checkeqdefaultvalue w.value0$^  checkeqdefaultvalue w.value00$^  checkeqdefaultvalue w.value00$^  checkeqdefaultvalue w.value00$^  checkeqdefaultvalue w.value00$^$^$^   namespace$^$^int mainint argc char argv $^  stdsetnewhandlerfailednewhandler$^  setflagsargv0 argc argv true$^$^  loginfo  seed    flagsseed$^  srandflagsseed$^$^  testtemplatedweightsfloatflagsrepeat$^  testtemplatedweightsdoubleflagsrepeat$^  flagsfstweightparentheses  $^  testtemplatedweightsfloatflagsrepeat$^  testtemplatedweightsdoubleflagsrepeat$^  flagsfstweightparentheses  $^$^   makes sure type names for templated weights are consistent.$^  checktropicalweighttype  tropical$^  checktropicalweighttpldoubletype  tropicalweighttplfloattype$^  checklogweighttype  log$^  checklogweighttpldoubletype  logweighttplfloattype$^  tropicalweighttpldouble w0.0$^  tropicalweight tw0.0$^$^  testaddertropicalweight0000$^  testadderlogweight0000$^  testsignedaddersignedlogweight0000$^$^  testimplicitconversionlogweight$^  testimplicitconversiontropicalweight$^  testimplicitconversionminmaxweight$^$^  testweightconversiontropicalweight logweight0.0$^$^  using leftstringweight  stringweightint$^  using leftstringweightgenerate  weightgenerateleftstringweight$^  leftstringweightgenerate leftstringgenerate$^  weighttesterleftstringweight leftstringweightgenerate leftstringtester$^      leftstringgenerate$^  leftstringtester.testflagsrepeat$^$^  using rightstringweight  stringweightint stringright$^  using rightstringweightgenerate  weightgeneraterightstringweight$^  rightstringweightgenerate rightstringgenerate$^  weighttesterrightstringweight rightstringweightgenerate$^      rightstringtesterrightstringgenerate$^  rightstringtester.testflagsrepeat$^$^   stringrestrict not tested since it requires equal strings$^   so would fail.$^$^  using iusetweight  setweightint setintersectunion$^  using iusetweightgenerate  weightgenerateiusetweight$^  iusetweightgenerate iusetgenerate$^  weighttesteriusetweight iusetweightgenerate$^      iusettesteriusetgenerate$^  iusettester.testflagsrepeat$^$^  using uisetweight  setweightint setunionintersect$^  using uisetweightgenerate  weightgenerateuisetweight$^  uisetweightgenerate uisetgenerate$^  weighttesteruisetweight uisetweightgenerate$^      uisettesteruisetgenerate$^  uisettester.testflagsrepeat$^$^   setintersectunionrestrict not tested since it requires equal sets$^   so would fail.$^$^  using boolsetweight  setweightint setboolean$^  using boolsetweightgenerate  weightgenerateboolsetweight$^  boolsetweightgenerate boolsetgenerate$^  weighttesterboolsetweight boolsetweightgenerate$^      boolsettesterboolsetgenerate$^  boolsettester.testflagsrepeat$^$^  testweightconversioniusetweight uisetweightiusetgenerate$^$^  testweightcopyiusetweight uisetweightiusetgenerate$^  testweightcopyiusetweight boolsetweightiusetgenerate$^  testweightcopyuisetweight iusetweightuisetgenerate$^  testweightcopyuisetweight boolsetweightuisetgenerate$^  testweightcopyboolsetweight iusetweightboolsetgenerate$^  testweightcopyboolsetweight uisetweightboolsetgenerate$^$^  testweightmoveiusetweight uisetweightiusetgenerate$^  testweightmoveiusetweight boolsetweightiusetgenerate$^  testweightmoveuisetweight iusetweightuisetgenerate$^  testweightmoveuisetweight boolsetweightuisetgenerate$^  testweightmoveboolsetweight iusetweightboolsetgenerate$^  testweightmoveboolsetweight uisetweightboolsetgenerate$^$^   composite weights and testers  definitions$^$^  using tropicalgallicweight  gallicweightint tropicalweight$^  using tropicalgallicweightgenerate  weightgeneratetropicalgallicweight$^  tropicalgallicweightgenerate tropicalgallicgeneratetrue$^  weighttestertropicalgallicweight tropicalgallicweightgenerate$^      tropicalgallictestertropicalgallicgenerate$^$^  using tropicalgengallicweight  gallicweightint tropicalweight gallic$^  using tropicalgengallicweightgenerate $^      weightgeneratetropicalgengallicweight$^  tropicalgengallicweightgenerate tropicalgengallicgeneratefalse$^  weighttestertropicalgengallicweight tropicalgengallicweightgenerate$^      tropicalgengallictestertropicalgengallicgenerate$^$^  using tropicalproductweight  productweighttropicalweight tropicalweight$^  using tropicalproductweightgenerate  weightgeneratetropicalproductweight$^  tropicalproductweightgenerate tropicalproductgenerate$^  weighttestertropicalproductweight tropicalproductweightgenerate$^      tropicalproducttestertropicalproductgenerate$^$^  using tropicallexicographicweight $^      lexicographicweighttropicalweight tropicalweight$^  using tropicallexicographicweightgenerate $^      weightgeneratetropicallexicographicweight$^  tropicallexicographicweightgenerate tropicallexicographicgenerate$^  weighttestertropicallexicographicweight$^               tropicallexicographicweightgenerate$^      tropicallexicographictestertropicallexicographicgenerate$^$^  using tropicalcubeweight  powerweighttropicalweight 0$^  using tropicalcubeweightgenerate  weightgeneratetropicalcubeweight$^  tropicalcubeweightgenerate tropicalcubegenerate$^  weighttestertropicalcubeweight tropicalcubeweightgenerate$^      tropicalcubetestertropicalcubegenerate$^$^  using firstnestedproductweight $^      productweighttropicalproductweight tropicalweight$^  using firstnestedproductweightgenerate $^      weightgeneratefirstnestedproductweight$^  firstnestedproductweightgenerate firstnestedproductgenerate$^  weighttesterfirstnestedproductweight firstnestedproductweightgenerate$^      firstnestedproducttesterfirstnestedproductgenerate$^$^  using secondnestedproductweight $^      productweighttropicalweight tropicalproductweight$^  using secondnestedproductweightgenerate $^      weightgeneratesecondnestedproductweight$^  secondnestedproductweightgenerate secondnestedproductgenerate$^  weighttestersecondnestedproductweight secondnestedproductweightgenerate$^      secondnestedproducttestersecondnestedproductgenerate$^$^  using nestedproductcubeweight  powerweightfirstnestedproductweight 0$^  using nestedproductcubeweightgenerate $^      weightgeneratenestedproductcubeweight$^  nestedproductcubeweightgenerate nestedproductcubegenerate$^  weighttesternestedproductcubeweight nestedproductcubeweightgenerate$^      nestedproductcubetesternestedproductcubegenerate$^$^  using sparsenestedproductcubeweight $^      sparsepowerweightnestedproductcubeweight sizet$^  using sparsenestedproductcubeweightgenerate $^      weightgeneratesparsenestedproductcubeweight$^  sparsenestedproductcubeweightgenerate sparsenestedproductcubegenerate$^  weighttestersparsenestedproductcubeweight$^               sparsenestedproductcubeweightgenerate$^      sparsenestedproductcubetestersparsenestedproductcubegenerate$^$^  using logsparsepowerweight  sparsepowerweightlogweight sizet$^  using logsparsepowerweightgenerate  weightgeneratelogsparsepowerweight$^  logsparsepowerweightgenerate logsparsepowergenerate$^  weighttesterlogsparsepowerweight logsparsepowerweightgenerate$^      logsparsepowertesterlogsparsepowergenerate$^$^  using loglogexpectationweight  expectationweightlogweight logweight$^  using loglogexpectationweightgenerate $^      weightgenerateloglogexpectationweight$^  loglogexpectationweightgenerate loglogexpectationgenerate$^  weighttesterloglogexpectationweight loglogexpectationweightgenerate$^      loglogexpectationtesterloglogexpectationgenerate$^$^  using loglogsparseexpectationweight $^      expectationweightlogweight logsparsepowerweight$^  using loglogsparseexpectationweightgenerate $^      weightgenerateloglogsparseexpectationweight$^  loglogsparseexpectationweightgenerate loglogsparseexpectationgenerate$^  weighttesterloglogsparseexpectationweight$^               loglogsparseexpectationweightgenerate$^      loglogsparseexpectationtesterloglogsparseexpectationgenerate$^$^  struct unionweightoptions $^    using compare  naturallesstropicalweight$^$^    struct merge $^      tropicalweight operatorconst tropicalweight w0$^                                const tropicalweight w0 const $^        return w0$^      $^    $^$^    using reverseoptions  unionweightoptions$^  $^$^  using tropicalunionweight  unionweighttropicalweight unionweightoptions$^  using tropicalunionweightgenerate  weightgeneratetropicalunionweight$^  tropicalunionweightgenerate tropicaluniongenerate$^  weighttestertropicalunionweight tropicalunionweightgenerate$^      tropicaluniontestertropicaluniongenerate$^$^   composite weights and testers  testing$^$^   tests composite weight io with parentheses.$^  flagsfstweightparentheses  $^$^   unnested composite.$^  tropicalgallictester.testflagsrepeat$^  tropicalgengallictester.testflagsrepeat$^  tropicalproducttester.testflagsrepeat$^  tropicallexicographictester.testflagsrepeat$^  tropicalcubetester.testflagsrepeat$^  logsparsepowertester.testflagsrepeat$^  loglogexpectationtester.testflagsrepeat false$^  tropicaluniontester.testflagsrepeat false$^$^   nested composite.$^  firstnestedproducttester.testflagsrepeat$^  secondnestedproducttester.test0$^  nestedproductcubetester.testflagsrepeat$^  sparsenestedproductcubetester.testflagsrepeat$^  loglogsparseexpectationtester.testflagsrepeat false$^$^   ... and tests composite weight io without parentheses.$^  flagsfstweightparentheses  $^$^   unnested composite.$^  tropicalgallictester.testflagsrepeat$^  tropicalproducttester.testflagsrepeat$^  tropicallexicographictester.testflagsrepeat$^  tropicalcubetester.testflagsrepeat$^  logsparsepowertester.testflagsrepeat$^  loglogexpectationtester.testflagsrepeat false$^  tropicaluniontester.testflagsrepeat false$^$^   nested composite.$^  secondnestedproducttester.testflagsrepeat$^  loglogsparseexpectationtester.testflagsrepeat false$^$^  testpowerweightgetsetvalue$^  testsparsepowerweightgetsetvalue$^$^  stdcout  pass  stdendl$^$^  return 0$^$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^ regression test for fst classes.$^$^include fsttestfsttest.h$^$^include utility$^$^include fstflags.h$^include fstlog.h$^include fstcompactfst.h$^include fstconstfst.h$^include fsteditfst.h$^include fstmatcherfst.h$^$^namespace fst $^namespace $^$^ a userdefined arc type.$^struct customarc $^  typedef int00 label$^  typedef productweighttropicalweight logweight weight$^  typedef int00 stateid$^$^  customarclabel i label o weight w stateid s$^       ilabeli olabelo weightstdmovew nextstates $^  customarc $^$^  static const string type    arc type name$^    static const string const type  new stringmy$^    return type$^  $^$^  label ilabel        transition input label$^  label olabel        transition output label$^  weight weight       transition weight$^  stateid nextstate   transition destination state$^$^$^ a userdefined compactor for test fst.$^template class a$^class customcompactor $^ public$^  typedef a arc$^  typedef typename alabel label$^  typedef typename astateid stateid$^  typedef typename aweight weight$^  typedef stdpairlabel weight element$^$^  element compactstateid s const a arc const $^    return stdmakepairarc.ilabel arc.weight$^  $^$^  arc expandstateid s const element p uint00 f  karcvalueflags const $^    return p.first  knolabel  arcknolabel knolabel p.second knostateid$^                                arcp.first 0 p.second s$^  $^$^  ssizet size const  return 0 $^$^  uint00 properties const  return 0ull $^$^  bool compatibleconst fsta fst const  return true $^$^  static const string type $^    static const string const type  new stringmy$^    return type$^  $^$^  bool writestdostream strm const  return true $^$^  static customcompactor readstdistream strm $^    return new customcompactor$^  $^$^$^registerfstvectorfst customarc$^registerfstconstfst customarc$^static fstfstregisterercompactfststdarc customcompactorstdarc$^    compactfststdarccustomcompactorregisterer$^static fstfstregisterercompactfstcustomarc customcompactorcustomarc$^    compactfstcustomarccustomcompactorregisterer$^static fstfstregistererconstfststdarc uint00$^    constfststdarcuint00registerer$^static fstfstregisterer$^    compactfststdarc customcompactorstdarc uint00$^    compactfststdarccustomcompactoruint00registerer$^$^   namespace$^   namespace fst$^$^using fstfsttester$^using fstvectorfst$^using fstconstfst$^using fstmatcherfst$^using fstcompactfst$^using fstfst$^using fststdarc$^using fstcustomarc$^using fstcustomcompactor$^using fststdarclookaheadfst$^using fsteditfst$^$^int mainint argc char argv $^  flagsfstverifyproperties  true$^  stdsetnewhandlerfailednewhandler$^  setflagsargv0 argc argv true$^$^   vectorfststdarc tests$^  $^    fsttestervectorfststdarc stdvectortester$^    stdvectortester.testbase$^    stdvectortester.testexpanded$^    stdvectortester.testassign$^    stdvectortester.testcopy$^    stdvectortester.testio$^    stdvectortester.testmutable$^  $^$^   constfststdarc tests$^  $^    fsttesterconstfststdarc stdconsttester$^    stdconsttester.testbase$^    stdconsttester.testexpanded$^    stdconsttester.testcopy$^    stdconsttester.testio$^  $^$^   compactfststdarc customcompactorstdarc$^  $^    fsttestercompactfststdarc customcompactorstdarc stdcompacttester$^    stdcompacttester.testbase$^    stdcompacttester.testexpanded$^    stdcompacttester.testcopy$^    stdcompacttester.testio$^  $^$^   vectorfstcustomarc tests$^  $^    fsttestervectorfstcustomarc stdvectortester$^    stdvectortester.testbase$^    stdvectortester.testexpanded$^    stdvectortester.testassign$^    stdvectortester.testcopy$^    stdvectortester.testio$^    stdvectortester.testmutable$^  $^$^   constfstcustomarc tests$^  $^    fsttesterconstfstcustomarc stdconsttester$^    stdconsttester.testbase$^    stdconsttester.testexpanded$^    stdconsttester.testcopy$^    stdconsttester.testio$^  $^$^   compactfstcustomarc customcompactorcustomarc$^  $^    fsttestercompactfstcustomarc customcompactorcustomarc$^        stdcompacttester$^    stdcompacttester.testbase$^    stdcompacttester.testexpanded$^    stdcompacttester.testcopy$^    stdcompacttester.testio$^  $^$^   constfststdarc uint00 tests$^  $^    fsttesterconstfststdarc uint00 stdconsttester$^    stdconsttester.testbase$^    stdconsttester.testexpanded$^    stdconsttester.testcopy$^    stdconsttester.testio$^  $^$^   compactfststdarc customcompactorstdarc uint00$^  $^    fsttestercompactfststdarc customcompactorstdarc uint00$^        stdcompacttester$^    stdcompacttester.testbase$^    stdcompacttester.testexpanded$^    stdcompacttester.testcopy$^    stdcompacttester.testio$^  $^$^   fsttesterstdarclookaheadfst$^  $^    fsttesterstdarclookaheadfst stdmatchertester$^    stdmatchertester.testbase$^    stdmatchertester.testexpanded$^    stdmatchertester.testcopy$^  $^$^   editfststdarc tests$^  $^    fsttestereditfststdarc stdedittester$^    stdedittester.testbase$^    stdedittester.testexpanded$^    stdedittester.testassign$^    stdedittester.testcopy$^    stdedittester.testmutable$^  $^$^  stdcout  pass  stdendl$^$^  return 0$^$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstflags.h$^$^defineboolrequiresuperinitial true always create a superinitial state$^$^int fstreversemainint argc char argv$^$^int mainint argc char argv  return fstreversemainargc argv $^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstflags.h$^$^definestringisymbols  input label symbol table$^definestringosymbols  output label symbol table$^definestringrelabelisymbols  input symbol set to relabel to$^definestringrelabelosymbols  output symbol set to relabel to$^definestringrelabelipairs  input relabel pairs numeric$^definestringrelabelopairs  output relabel pairs numeric$^definestringunknownisymbol $^    input symbol to use to relabel oovs default oovs are errors$^definestringunknownosymbol $^    output symbol to use to relabel oovs default oovs are errors$^defineboolallownegativelabels false$^    allow negative labels not recommended may cause conflicts$^$^int fstrelabelmainint argc char argv$^$^int mainint argc char argv  return fstrelabelmainargc argv $^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^ applies an operation to each arc of an fst.$^$^include cstring$^$^include memory$^include string$^$^include fstflags.h$^include fstlog.h$^include fstscriptgetters.h$^include fstscriptmap.h$^$^declaredoubledelta$^declarestringmaptype$^declaredoublepower$^declarestringweight$^$^int fstmapmainint argc char argv $^  namespace s  fstscript$^  using fstscriptfstclass$^  using fstscriptweightclass$^$^  string usage  applies an operation to each arc of an fst.nn  usage $^  usage  argv0$^  usage   in.fst out.fstn$^$^  stdsetnewhandlerfailednewhandler$^  setflagsusage.cstr argc argv true$^  if argc  0 $^    showusage$^    return 0$^  $^$^  const string inname  argc  0  strcmpargv0   0  argv0  $^  const string outname  argc  0  argv0  $^$^  stduniqueptrfstclass ifstfstclassreadinname$^  if ifst return 0$^$^  smaptype maptype$^  if sgetmaptypeflagsmaptype maptype $^    logerror  argv0   unknown or unsupported map type $^                flagsmaptype$^    return 0$^  $^$^  const auto weightparam $^      flagsweight.empty$^           weightclassifstweighttype flagsweight$^           flagsmaptype  times  weightclassoneifstweighttype$^                                        weightclasszeroifstweighttype$^$^  stduniqueptrfstclass ofst$^      smapifst maptype flagsdelta flagspower weightparam$^$^  return ofstwriteoutname$^$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^ removes useless inaccessible or noncoaccessible states and arcs from an$^ fst.$^$^include cstring$^$^include memory$^include string$^$^include fstflags.h$^include fstscriptconnect.h$^$^int fstconnectmainint argc char argv $^  namespace s  fstscript$^  using fstscriptfstclass$^  using fstscriptmutablefstclass$^$^  string usage  removes useless states and arcs from an fst.nn  usage $^  usage  argv0$^  usage   in.fst out.fstn$^$^  stdsetnewhandlerfailednewhandler$^  setflagsusage.cstr argc argv true$^  if argc  0 $^    showusage$^    return 0$^  $^$^  const string inname  argc  0  strcmpargv0   0  argv0  $^  const string outname  argc  0  argv0  $^$^  stduniqueptrmutablefstclass fstmutablefstclassreadinname true$^  if fst return 0$^$^  sconnectfst.get$^$^  return fstwriteoutname$^$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstflags.h$^include fstweight.h$^$^definedoubledelta fstkdelta comparisonquantization delta$^$^int fstisomorphicmainint argc char argv$^$^int mainint argc char argv  return fstisomorphicmainargc argv $^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstflags.h$^$^definestringfsttype vector output fst type$^$^int fstconvertmainint argc char argv$^$^int mainint argc char argv  return fstconvertmainargc argv $^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^ epsilonnormalizes an fst.$^$^include cstring$^$^include memory$^include string$^$^include fstflags.h$^include fstscriptepsnormalize.h$^include fstscriptgetters.h$^$^declareboolepsnormoutput$^$^int fstepsnormalizemainint argc char argv $^  namespace s  fstscript$^  using fstscriptfstclass$^  using fstscriptvectorfstclass$^$^  string usage  epsilon normalizes an fst.nn  usage $^  usage  argv0$^  usage   in.fst out.fstn$^$^  stdsetnewhandlerfailednewhandler$^  setflagsusage.cstr argc argv true$^  if argc  0 $^    showusage$^    return 0$^  $^$^  const string inname  argc  0  strcmpargv0   0  argv0  $^  const string outname  argc  0  argv0  $^$^  stduniqueptrfstclass ifstfstclassreadinname$^  if ifst return 0$^$^  vectorfstclass ofstifstarctype$^$^  sepsnormalizeifst ofst sgetepsnormalizetypeflagsepsnormoutput$^$^  return ofst.writeoutname$^$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^ two fsts are isomorphic equal up to state and arc reordering iff their$^ exit status is zero. fsts should be deterministic when viewed as unweighted$^ automata.$^$^include cstring$^$^include memory$^include string$^$^include fstflags.h$^include fstlog.h$^include fstscriptisomorphic.h$^$^declaredoubledelta$^$^int fstisomorphicmainint argc char argv $^  namespace s  fstscript$^  using fstscriptfstclass$^$^  string usage $^      two fsts are isomorphic iff the exit status is zero.nn  usage $^  usage  argv0$^  usage   in0.fst in0.fstn$^$^  stdsetnewhandlerfailednewhandler$^  setflagsusage.cstr argc argv true$^  if argc  0 $^    showusage$^    return 0$^  $^$^  const string in0name  strcmpargv0   0    argv0$^  const string in0name  strcmpargv0   0    argv0$^$^  if in0name.empty  in0name.empty $^    logerror  argv0   cant take both inputs from standard input$^    return 0$^  $^$^  stduniqueptrfstclass ifst0fstclassreadin0name$^  if ifst0 return 0$^$^  stduniqueptrfstclass ifst0fstclassreadin0name$^  if ifst0 return 0$^$^  bool result  sisomorphicifst0 ifst0 flagsdelta$^  if result vlog0  fsts are not isomorphic$^$^  return result  0  0$^$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^ projects a transduction onto its input or output language.$^$^include cstring$^$^include memory$^include string$^$^include fstflags.h$^include fstscriptgetters.h$^include fstscriptproject.h$^$^declareboolprojectoutput$^$^int fstprojectmainint argc char argv $^  namespace s  fstscript$^  using fstscriptmutablefstclass$^$^  string usage $^      projects a transduction onto its input$^       or output language.nn  usage $^  usage  argv0$^  usage   in.fst out.fstn$^$^  stdsetnewhandlerfailednewhandler$^  setflagsusage.cstr argc argv true$^  if argc  0 $^    showusage$^    return 0$^  $^$^  const string inname  argc  0  strcmpargv0   0  argv0  $^  const string outname  argc  0  argv0  $^$^  stduniqueptrmutablefstclass fstmutablefstclassreadinname true$^  if fst return 0$^$^  sprojectfst.get sgetprojecttypeflagsprojectoutput$^$^  return fstwriteoutname$^$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^ topologically sorts an fst.$^$^include cstring$^$^include memory$^include string$^$^include fstflags.h$^include fstlog.h$^include fstscripttopsort.h$^$^int fsttopsortmainint argc char argv $^  namespace s  fstscript$^  using fstscriptmutablefstclass$^$^  string usage  topologically sorts an fst.nn  usage $^  usage  argv0$^  usage   in.fst out.fstn$^$^  stdsetnewhandlerfailednewhandler$^  setflagsusage.cstr argc argv true$^  if argc  0 $^    showusage$^    return 0$^  $^$^  const string inname  argc  0  strcmpargv0   0  argv0  $^  const string outname  argc  0  argv0  $^$^  stduniqueptrmutablefstclass fstmutablefstclassreadinname true$^  if fst return 0$^$^  bool acyclic  topsortfst.get$^$^  if acyclic logwarning  argv0   input fst is cyclic$^$^  return fstwriteoutname$^$^ifndef mscver$^include unistd.h$^else$^include process.h$^define getpid getpid$^endif$^$^include climits$^include ctime$^$^include fstflags.h$^include fstweight.h$^$^definedoubledelta fstkdelta comparisonquantization delta$^defineboolrandom false$^            test equivalence by randomly selecting paths in the input fsts$^defineint00maxlength int00max maximum path length$^defineint00npath 0 number of paths to generate$^defineint00seed timenullptr  getpid random seed$^definestringselect uniform$^              selection type one of $^               uniform logprob when appropriate$^               fastlogprob when appropriate$^$^int fstequivalentmainint argc char argv$^$^int mainint argc char argv  return fstequivalentmainargc argv $^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^ reweights an fst.$^$^include cstring$^$^include memory$^include string$^include vector$^$^include fstflags.h$^include fstscriptgetters.h$^include fstscriptreweight.h$^include fstscripttextio.h$^$^declarebooltofinal$^$^int fstreweightmainint argc char argv $^  namespace s  fstscript$^  using fstscriptmutablefstclass$^  using fstscriptweightclass$^$^  string usage  reweights an fst.nn  usage $^  usage  argv0$^  usage   in.fst potential.txt out.fstn$^$^  stdsetnewhandlerfailednewhandler$^  setflagsusage.cstr argc argv true$^  if argc  0  argc  0 $^    showusage$^    return 0$^  $^$^  const string inname  argv0$^  const string potentialsname  argv0$^  const string outname  argc  0  argv0  $^$^  stduniqueptrmutablefstclass fstmutablefstclassreadinname true$^  if fst return 0$^$^  stdvectorweightclass potential$^  if sreadpotentialsfstweighttype potentialsname potential $^    return 0$^  $^$^  sreweightfst.get potential sgetreweighttypeflagstofinal$^$^  return fstwriteoutname$^$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^ creates binary fsts from simple text format used by att.$^$^include cstring$^$^include fstream$^include istream$^include memory$^include string$^$^include fstflags.h$^include fstlog.h$^include fstscriptcompile.h$^$^declareboolacceptor$^declarestringarctype$^declarestringfsttype$^declarestringisymbols$^declarestringosymbols$^declarestringssymbols$^declareboolkeepisymbols$^declareboolkeeposymbols$^declareboolkeepstatenumbering$^declareboolallownegativelabels$^$^int fstcompilemainint argc char argv $^  namespace s  fstscript$^  using fstsymboltable$^  using fstsymboltabletextoptions$^$^  string usage  creates binary fsts from simple text format.nn  usage $^  usage  argv0$^  usage   text.fst binary.fstn$^$^  stdsetnewhandlerfailednewhandler$^  setflagsusage.cstr argc argv true$^  if argc  0 $^    showusage$^    return 0$^  $^$^  string source  standard input$^  stdifstream fstrm$^  if argc  0  strcmpargv0   0 $^    fstrm.openargv0$^    if fstrm $^      logerror  argv0   open failed file    argv0$^      return 0$^    $^    source  argv0$^  $^  stdistream istrm  fstrm.isopen  fstrm  stdcin$^$^  const symboltabletextoptions optsflagsallownegativelabels$^$^  stduniqueptrconst symboltable isyms$^  if flagsisymbols.empty $^    isyms.resetsymboltablereadtextflagsisymbols opts$^    if isyms return 0$^  $^$^  stduniqueptrconst symboltable osyms$^  if flagsosymbols.empty $^    osyms.resetsymboltablereadtextflagsosymbols opts$^    if osyms return 0$^  $^$^  stduniqueptrconst symboltable ssyms$^  if flagsssymbols.empty $^    ssyms.resetsymboltablereadtextflagsssymbols$^    if ssyms return 0$^  $^$^  const string dest  argc  0  argv0  $^$^  scompilefstistrm source dest flagsfsttype flagsarctype$^                isyms.get osyms.get ssyms.get flagsacceptor$^                flagskeepisymbols flagskeeposymbols$^                flagskeepstatenumbering flagsallownegativelabels$^$^  return 0$^$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^ converts an fst to another type.$^$^include cstring$^$^include memory$^include string$^$^include fstflags.h$^include fstscriptconvert.h$^$^declarestringfsttype$^$^int fstconvertmainint argc char argv $^  namespace s  fstscript$^  using fstscriptfstclass$^$^  string usage  converts an fst to another type.nn  usage $^  usage  argv0$^  usage   in.fst out.fstn$^$^  stdsetnewhandlerfailednewhandler$^  setflagsusage.cstr argc argv true$^  if argc  0 $^    showusage$^    return 0$^  $^$^  const string inname  argc  0  strcmpargv0   0  argv0  $^  const string outname  argc  0  argv0  $^$^  stduniqueptrfstclass ifstfstclassreadinname$^  if ifst return 0$^$^  if ifstfsttype  flagsfsttype $^    stduniqueptrfstclass ofstsconvertifst flagsfsttype$^    if ofst return 0$^    return ofstwriteoutname$^   else $^    return ifstwriteoutname$^  $^$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^ encode transducer labels andor weights.$^$^include cstring$^$^include memory$^include string$^$^include fstflags.h$^include fstscriptdecode.h$^include fstscriptencode.h$^include fstscriptgetters.h$^$^declareboolencodelabels$^declareboolencodeweights$^declareboolencodereuse$^declarebooldecode$^$^int fstencodemainint argc char argv $^  namespace s  fstscript$^  using fstscriptfstclass$^  using fstscriptmutablefstclass$^$^  string usage  encodes transducer labels andor weights.nn  usage $^  usage  argv0$^  usage   in.fst codex out.fstn$^$^  stdsetnewhandlerfailednewhandler$^  setflagsusage.cstr argc argv true$^  if argc  0  argc  0 $^    showusage$^    return 0$^  $^$^  const string inname  strcmpargv0   0  argv0  $^  const string codexname  argv0$^  const string outname  argc  0  argv0  $^$^  stduniqueptrmutablefstclass fstmutablefstclassreadinname true$^  if fst return 0$^$^  if flagsdecode $^    sdecodefst.get codexname$^    return fstwriteoutname$^   else $^    const auto flags $^        sgetencodeflagsflagsencodelabels flagsencodeweights$^    sencodefst.get flags flagsencodereuse codexname$^    return fstwriteoutname$^  $^$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^ relabels input or output space of an fst.$^$^include cstring$^$^include memory$^include string$^include vector$^$^include fstflags.h$^include fstutil.h$^include fstscriptrelabel.h$^include fstscriptweightclass.h$^$^declarestringisymbols$^declarestringosymbols$^declarestringrelabelisymbols$^declarestringrelabelosymbols$^declarestringrelabelipairs$^declarestringrelabelopairs$^declarestringunknownisymbol$^declarestringunknownosymbol$^declareboolallownegativelabels$^$^int fstrelabelmainint argc char argv $^  namespace s  fstscript$^  using fstscriptmutablefstclass$^  using fstsymboltable$^  using fstsymboltabletextoptions$^$^  string usage $^      relabels the input andor the output labels of the fst.nn$^        usage $^  usage  argv0$^  usage   in.fst out.fstn$^  usage  n using symboltables flagsn$^  usage    relabelisymbols isyms.mapn$^  usage    relabelosymbols osyms.mapn$^  usage  n using numeric labels flagsn$^  usage    relabelipairs ipairs.txtn$^  usage    relabelopairs opairs.txtn$^$^  stdsetnewhandlerfailednewhandler$^  setflagsusage.cstr argc argv true$^  if argc  0 $^    showusage$^    return 0$^  $^$^  const string inname $^      argc  0  strcmpargv0   0  argv0  $^  const string outname  argc  0  argv0  $^$^  stduniqueptrmutablefstclass fstmutablefstclassreadinname true$^  if fst return 0$^$^   relabel with symbol tables.$^  const symboltabletextoptions optsflagsallownegativelabels$^$^  if flagsrelabelisymbols.empty  flagsrelabelosymbols.empty $^    bool attachnewisymbols  fstinputsymbols  nullptr$^    stduniqueptrconst symboltable oldisymbols$^        flagsisymbols.empty  nullptr$^                                symboltablereadtextflagsisymbols opts$^    const stduniqueptrconst symboltable relabelisymbols$^        flagsrelabelisymbols.empty$^             nullptr$^             symboltablereadtextflagsrelabelisymbols opts$^    bool attachnewosymbols  fstoutputsymbols  nullptr$^    stduniqueptrconst symboltable oldosymbols$^        flagsosymbols.empty  nullptr$^                                symboltablereadtextflagsosymbols opts$^    const stduniqueptrconst symboltable relabelosymbols$^        flagsrelabelosymbols.empty$^             nullptr$^             symboltablereadtextflagsrelabelosymbols opts$^    srelabelfst.get$^               oldisymbols  oldisymbols.get  fstinputsymbols$^               relabelisymbols.get flagsunknownisymbol$^               attachnewisymbols$^               oldosymbols  oldosymbols.get  fstoutputsymbols$^               relabelosymbols.get flagsunknownosymbol$^               attachnewosymbols$^   else $^     reads in relabeling pairs.$^    stdvectorslabelpair ipairs$^    stdvectorslabelpair opairs$^    if flagsrelabelipairs.empty $^      if fstreadlabelpairsflagsrelabelipairs ipairs$^                                   flagsallownegativelabels$^        return 0$^    $^    if flagsrelabelopairs.empty $^      if fstreadlabelpairsflagsrelabelopairs opairs$^                                   flagsallownegativelabels$^        return 0$^    $^    srelabelfst.get ipairs opairs$^  $^$^  return fstwriteoutname$^$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^ prunes states and arcs of an fst w.r.t. the shortest path weight.$^$^include cstring$^$^include memory$^include string$^$^include fstflags.h$^include fstscriptprune.h$^$^declaredoubledelta$^declareint00nstate$^declarestringweight$^$^int fstprunemainint argc char argv $^  namespace s  fstscript$^  using fstscriptmutablefstclass$^  using fstscriptweightclass$^$^  string usage  prunes states and arcs of an fst.nn  usage $^  usage  argv0$^  usage   in.fst out.fstn$^$^  stdsetnewhandlerfailednewhandler$^  setflagsusage.cstr argc argv true$^  if argc  0 $^    showusage$^    return 0$^  $^$^  const string inname  argc  0  strcmpargv0   0  argv0  $^  const string outname  argc  0  argv0  $^$^  stduniqueptrmutablefstclass fstmutablefstclassreadinname true$^  if fst return 0$^$^  const auto weightthreshold $^      flagsweight.empty  weightclasszerofstweighttype$^                            weightclassfstweighttype flagsweight$^$^  sprunefst.get weightthreshold flagsnstate flagsdelta$^$^  return fstwriteoutname$^$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstcompat.h$^include fstflags.h$^$^definestringsorttype ilabel$^              comparison method one of ilabel olabel$^$^int fstarcsortmainint argc char argv$^$^int mainint argc char argv  return fstarcsortmainargc argv $^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^ composes two fsts.$^$^include cstring$^$^include memory$^include string$^$^include fstflags.h$^include fstlog.h$^include fstscriptcompose.h$^include fstscriptgetters.h$^$^declarestringcomposefilter$^declareboolconnect$^$^int fstcomposemainint argc char argv $^  namespace s  fstscript$^  using fstcomposefilter$^  using fstcomposeoptions$^  using fstscriptfstclass$^  using fstscriptvectorfstclass$^$^  string usage  composes two fsts.nn  usage $^  usage  argv0$^  usage   in0.fst in0.fst out.fstn$^$^  stdsetnewhandlerfailednewhandler$^  setflagsusage.cstr argc argv true$^  if argc  0  argc  0 $^    showusage$^    return 0$^  $^$^  const string in0name  strcmpargv0   0  argv0  $^  const string in0name $^      argc  0  strcmpargv0   0  argv0  $^  const string outname  argc  0  argv0  $^$^  if in0name.empty  in0name.empty $^    logerror  argv0   cant take both inputs from standard input$^    return 0$^  $^$^  stduniqueptrfstclass ifst0fstclassreadin0name$^  if ifst0 return 0$^$^  stduniqueptrfstclass ifst0fstclassreadin0name$^  if ifst0 return 0$^$^  if ifst0arctype  ifst0arctype $^    logerror  argv0   input fsts must have the same arc type$^    return 0$^  $^$^  vectorfstclass ofstifst0arctype$^$^  composefilter composefilter$^  if sgetcomposefilterflagscomposefilter composefilter $^    logerror  argv0   unknown or unsupported compose filter type $^                flagscomposefilter$^    return 0$^  $^$^  const composeoptions optsflagsconnect composefilter$^$^  scomposeifst0 ifst0 ofst opts$^$^  return ofst.writeoutname$^$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstflags.h$^include fstshortestdistance.h$^include fstweight.h$^$^definedoubledelta fstkshortestdelta comparisonquantization delta$^defineboolallownondet false minimize nondeterministic fsts$^$^int fstminimizemainint argc char argv$^$^int mainint argc char argv  return fstminimizemainargc argv $^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^ subtracts an unweighted dfa from an fsa.$^$^include cstring$^$^include memory$^include string$^$^include fstflags.h$^include fstlog.h$^include fstscriptgetters.h$^include fstscriptdifference.h$^$^declarestringcomposefilter$^declareboolconnect$^$^int fstdifferencemainint argc char argv $^  namespace s  fstscript$^  using fstcomposefilter$^  using fstdifferenceoptions$^  using fstscriptfstclass$^  using fstscriptvectorfstclass$^$^  string usage  subtracts an unweighted dfa from an fsa.nn  usage $^  usage  argv0$^  usage   in0.fst in0.fst out.fstn$^$^  stdsetnewhandlerfailednewhandler$^  setflagsusage.cstr argc argv true$^  if argc  0  argc  0 $^    showusage$^    return 0$^  $^$^  const string in0name  strcmpargv0   0    argv0$^  const string in0name  strcmpargv0   0    argv0$^  const string outname  argc  0  argv0  $^$^  if in0name.empty  in0name.empty $^    logerror  argv0   cant take both inputs from standard input$^    return 0$^  $^$^  stduniqueptrfstclass ifst0fstclassreadin0name$^  if ifst0 return 0$^$^  stduniqueptrfstclass ifst0fstclassreadin0name$^  if ifst0 return 0$^$^  vectorfstclass ofstifst0arctype$^$^  composefilter composefilter$^  if sgetcomposefilterflagscomposefilter composefilter $^    logerror  argv0   unknown or unsupported compose filter type $^                flagscomposefilter$^    return 0$^  $^$^  const differenceoptions optsflagsconnect composefilter$^$^  sdifferenceifst0 ifst0 ofst opts$^$^  return ofst.writeoutname$^$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^int fstinvertmainint argc char argv$^$^int mainint argc char argv  return fstinvertmainargc argv $^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstflags.h$^include fstfst.h$^include fstweight.h$^$^definedoubledelta fstkdelta comparisonquantization delta$^definestringweight  weight threshold$^defineint00nstate fstknostateid state number threshold$^defineint00subsequentiallabel 0$^             input label of arc corresponding to residual final output when$^              producing a subsequential transducer$^definestringdettype functional$^              type of determinization functional $^              nonfunctional disambiguate$^defineboolincrementsubsequentiallabel false$^            increment subsequentiallabel to obtain distinct labels for $^             subsequential arcs at a given state$^$^int fstdeterminizemainint argc char argv$^$^int mainint argc char argv  return fstdeterminizemainargc argv $^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^ creates the kleene closure of an fst.$^$^include cstring$^$^include memory$^include string$^$^include fstflags.h$^include fstscriptclosure.h$^include fstscriptgetters.h$^$^declareboolclosureplus$^$^int fstclosuremainint argc char argv $^  namespace s  fstscript$^  using fstscriptmutablefstclass$^$^  string usage  creates the kleene closure of an fst.nn  usage $^  usage  argv0$^  usage   in.fst out.fstn$^$^  stdsetnewhandlerfailednewhandler$^  setflagsusage.cstr argc argv true$^  if argc  0 $^    showusage$^    return 0$^  $^$^  const string inname  argc  0  strcmpargv0   0  argv0  $^  const string outname  argc  0  argv0  $^$^  stduniqueptrmutablefstclass fstmutablefstclassreadinname true$^  if fst return 0$^$^  sclosurefst.get sgetclosuretypeflagsclosureplus$^$^  return fstwriteoutname$^$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstflags.h$^$^definestringcomposefilter auto$^              composition filter one of altsequence auto $^              match null sequence trivial$^defineboolconnect true trim output$^$^int fstdifferencemainint argc char argv$^$^int mainint argc char argv  return fstdifferencemainargc argv $^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstflags.h$^include fstweight.h$^$^definedoubledelta fstkdelta comparisonquantization delta$^$^int fstequalmainint argc char argv$^$^int mainint argc char argv  return fstequalmainargc argv $^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^ prints out binary fsts in simple text format used by att.$^$^include cstring$^$^include fstream$^include memory$^include ostream$^include string$^$^include fstflags.h$^include fstlog.h$^include fstscriptprint.h$^$^declareboolacceptor$^declarestringisymbols$^declarestringosymbols$^declarestringssymbols$^declareboolnumeric$^declarestringsaveisymbols$^declarestringsaveosymbols$^declareboolshowweightone$^declareboolallownegativelabels$^declarestringmissingsymbol$^$^int fstprintmainint argc char argv $^  namespace s  fstscript$^  using fstscriptfstclass$^  using fstsymboltable$^  using fstsymboltabletextoptions$^$^  string usage  prints out binary fsts in simple text format.nn  usage $^  usage  argv0$^  usage   binary.fst text.fstn$^$^  stdsetnewhandlerfailednewhandler$^  setflagsusage.cstr argc argv true$^  if argc  0 $^    showusage$^    return 0$^  $^$^  const string inname  argc  0  strcmpargv0   0  argv0  $^  const string outname  argc  0  argv0  $^$^  stduniqueptrfstclass fstfstclassreadinname$^  if fst return 0$^$^  string dest  standard output$^  stdofstream fstrm$^  if argc  0 $^    fstrm.openargv0$^    if fstrm $^      logerror  argv0   open failed file    argv0$^      return 0$^    $^    dest  argv0$^  $^  stdostream ostrm  fstrm.isopen  fstrm  stdcout$^  ostrm.precision0$^$^  const symboltabletextoptions optsflagsallownegativelabels$^$^  stduniqueptrconst symboltable isyms$^  if flagsisymbols.empty  flagsnumeric $^    isyms.resetsymboltablereadtextflagsisymbols opts$^    if isyms return 0$^  $^$^  stduniqueptrconst symboltable osyms$^  if flagsosymbols.empty  flagsnumeric $^    osyms.resetsymboltablereadtextflagsosymbols opts$^    if osyms return 0$^  $^$^  stduniqueptrconst symboltable ssyms$^  if flagsssymbols.empty  flagsnumeric $^    ssyms.resetsymboltablereadtextflagsssymbols$^    if ssyms return 0$^  $^$^  if isyms  flagsnumeric  fstinputsymbols $^    isyms.resetfstinputsymbolscopy$^  $^$^  if osyms  flagsnumeric  fstoutputsymbols $^    osyms.resetfstoutputsymbolscopy$^  $^$^  sprintfstfst ostrm dest isyms.get osyms.get ssyms.get$^              flagsacceptor flagsshowweightone flagsmissingsymbol$^$^  if isyms  flagssaveisymbols.empty $^    if isymswritetextflagssaveisymbols return 0$^  $^$^  if osyms  flagssaveosymbols.empty $^    if osymswritetextflagssaveosymbols return 0$^  $^$^  return 0$^$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^ synchronizes an fst.$^$^include cstring$^$^include memory$^include string$^$^include fstflags.h$^include fstscriptsynchronize.h$^$^int fstsynchronizemainint argc char argv $^  namespace s  fstscript$^  using fstscriptfstclass$^  using fstscriptvectorfstclass$^$^  string usage  synchronizes an fst.nn  usage $^  usage  argv0$^  usage   in.fst out.fstn$^$^  stdsetnewhandlerfailednewhandler$^  setflagsusage.cstr argc argv true$^  if argc  0 $^    showusage$^    return 0$^  $^$^  const string inname  argc  0  strcmpargv0   0  argv0  $^  const string outname  argc  0  argv0  $^$^  stduniqueptrfstclass ifstfstclassreadinname$^  if ifst return 0$^$^  vectorfstclass ofstifstarctype$^$^  ssynchronizeifst ofst$^$^  return ofst.writeoutname$^$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^ find shortest distances in an fst.$^$^include cstring$^$^include memory$^include string$^include vector$^$^include fstflags.h$^include fstlog.h$^include fstscriptgetters.h$^include fstscriptshortestdistance.h$^include fstscripttextio.h$^$^declareboolreverse$^declaredoubledelta$^declareint00nstate$^declarestringqueuetype$^$^int fstshortestdistancemainint argc char argv $^  namespace s  fstscript$^  using fstscriptfstclass$^  using fstscriptweightclass$^  using fstqueuetype$^  using fstautoqueue$^$^  string usage  finds shortest distances in an fst.nn  usage $^  usage  argv0$^  usage   in.fst distance.txtn$^$^  stdsetnewhandlerfailednewhandler$^  setflagsusage.cstr argc argv true$^  if argc  0 $^    showusage$^    return 0$^  $^$^  string inname  argc  0  strcmpargv0   0  argv0  $^  string outname  argc  0  argv0  $^$^  stduniqueptrfstclass ifstfstclassreadinname$^  if ifst return 0$^$^  stdvectorweightclass distance$^$^  queuetype queuetype$^  if sgetqueuetypeflagsqueuetype queuetype $^    logerror  argv0$^                 unknown or unsupported queue type   flagsqueuetype$^    return 0$^  $^$^  if flagsreverse  queuetype  autoqueue $^    logerror  argv0   cant use nondefault queue with reverse$^    return 0$^  $^$^  if flagsreverse $^    sshortestdistanceifst distance flagsreverse flagsdelta$^   else $^    const sshortestdistanceoptions optsqueuetype sanyarcfilter$^                                          flagsnstate flagsdelta$^    sshortestdistanceifst distance opts$^  $^$^  return swritepotentialsoutname distance$^$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^ two fsts are equal iff their exit status is zero.$^$^include cstring$^$^include memory$^include string$^$^include fstflags.h$^include fstlog.h$^include fstscriptequal.h$^$^declaredoubledelta$^$^int fstequalmainint argc char argv $^  namespace s  fstscript$^  using fstscriptfstclass$^$^  string usage  two fsts are equal iff the exit status is zero.nn  usage $^  usage  argv0$^  usage   in0.fst in0.fstn$^$^  stdsetnewhandlerfailednewhandler$^  setflagsusage.cstr argc argv true$^  if argc  0 $^    showusage$^    return 0$^  $^$^  const string in0name  strcmpargv0   0    argv0$^  const string in0name  strcmpargv0   0    argv0$^$^  if in0name.empty  in0name.empty $^    logerror  argv0   cant take both inputs from standard input$^    return 0$^  $^$^  stduniqueptrfstclass ifst0fstclassreadin0name$^  if ifst0 return 0$^$^  stduniqueptrfstclass ifst0fstclassreadin0name$^  if ifst0 return 0$^$^  bool result  sequalifst0 ifst0 flagsdelta$^  if result vlog0  fsts are not equal.$^$^  return result  0  0$^$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^int fstconnectmainint argc char argv$^$^int mainint argc char argv  return fstconnectmainargc argv $^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstflags.h$^$^definestringcomposefilter auto$^              composition filter one of altsequence auto $^              match null sequence trivial$^defineboolconnect true trim output$^$^int fstcomposemainint argc char argv$^$^int mainint argc char argv  return fstcomposemainargc argv $^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^ determinizes an fst.$^$^include cstring$^$^include memory$^include string$^$^include fstflags.h$^include fstscriptdeterminize.h$^include fstscriptgetters.h$^$^declaredoubledelta$^declarestringweight$^declareint00nstate$^declareint00subsequentiallabel$^declarestringdettype$^declareboolincrementsubsequentiallabel$^$^int fstdeterminizemainint argc char argv $^  namespace s  fstscript$^  using fstdeterminizetype$^  using fstscriptfstclass$^  using fstscriptvectorfstclass$^  using fstscriptweightclass$^$^  string usage  determinizes an fst.nn  usage $^  usage  argv0$^  usage   in.fst out.fstn$^$^  stdsetnewhandlerfailednewhandler$^  setflagsusage.cstr argc argv true$^  if argc  0 $^    showusage$^    return 0$^  $^$^  determinizetype dettype$^  if sgetdeterminizetypeflagsdettype dettype $^    logerror  argv0   unknown or unsupported determinization type $^                           flagsdettype$^    return 0$^  $^$^  const string inname  argc  0  strcmpargv0   0  argv0  $^  const string outname  argc  0  argv0  $^$^  stduniqueptrfstclass ifstfstclassreadinname$^  if ifst return 0$^$^  vectorfstclass ofstifstarctype$^$^  const auto weightthreshold $^      flagsweight.empty  weightclasszeroifstweighttype$^                            weightclassifstweighttype flagsweight$^$^  const sdeterminizeoptions optsflagsdelta weightthreshold flagsnstate$^                                   flagssubsequentiallabel dettype$^                                   flagsincrementsubsequentiallabel$^$^  sdeterminizeifst ofst opts$^$^  return ofst.writeoutname$^$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^int fstsynchronizemainint argc char argv$^$^int mainint argc char argv  return fstsynchronizemainargc argv $^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstflags.h$^include fstfst.h$^include fstshortestdistance.h$^include fstweight.h$^$^defineboolreverse false perform in the reverse direction$^definedoubledelta fstkshortestdelta comparisonquantization delta$^defineint00nstate fstknostateid state number threshold$^definestringqueuetype auto$^              queue type one of auto $^              fifo lifo shortest state top$^$^int fstshortestdistancemainint argc char argv$^$^int mainint argc char argv  return fstshortestdistancemainargc argv $^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^int fstunionmainint argc char argv$^$^int mainint argc char argv  return fstunionmainargc argv $^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^ generates random paths through an fst.$^$^include cstring$^$^include memory$^include string$^$^include fstflags.h$^include fstlog.h$^include fstscriptgetters.h$^include fstscriptrandgen.h$^$^declareint00maxlength$^declareint00npath$^declareint00seed$^declarestringselect$^declareboolweighted$^declareboolremovetotalweight$^$^int fstrandgenmainint argc char argv $^  namespace s  fstscript$^  using fstscriptfstclass$^  using fstscriptvectorfstclass$^$^  string usage  generates random paths through an fst.nn  usage $^  usage  argv0$^  usage   in.fst out.fstn$^$^  stdsetnewhandlerfailednewhandler$^  setflagsusage.cstr argc argv true$^  if argc  0 $^    showusage$^    return 0$^  $^$^  vlog0  argv0   seed    flagsseed$^$^  const string inname  argc  0  strcmpargv0   0  argv0  $^  const string outname  argc  0  argv0  $^$^  stduniqueptrfstclass ifstfstclassreadinname$^  if ifst return 0$^$^  vectorfstclass ofstifstarctype$^$^  srandarcselection ras$^  if sgetrandarcselectionflagsselect ras $^    logerror  argv0   unknown or unsupported select type $^                flagsselect$^    return 0$^  $^$^  srandgenifst ofst flagsseed$^             fstrandgenoptionssrandarcselection$^                 ras flagsmaxlength flagsnpath flagsweighted$^                 flagsremovetotalweight$^$^  return ofst.writeoutname$^$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^ creates the union of two fsts.$^$^include cstring$^$^include memory$^include string$^$^include fstflags.h$^include fstlog.h$^include fstscriptunion.h$^$^int fstunionmainint argc char argv $^  namespace s  fstscript$^  using fstscriptfstclass$^  using fstscriptmutablefstclass$^$^  string usage  creates the union of two fsts.nn  usage $^  usage  argv0$^  usage   in0.fst in0.fst out.fstn$^$^  stdsetnewhandlerfailednewhandler$^  setflagsusage.cstr argc argv true$^  if argc  0  argc  0 $^    showusage$^    return 0$^  $^$^  const string in0name  strcmpargv0   0  argv0  $^  const string in0name  strcmpargv0   0  argv0  $^  const string outname  argc  0  argv0  $^$^  if in0name    in0name   $^    logerror  argv0   cant take both inputs from standard input$^    return 0$^  $^$^  stduniqueptrmutablefstclass fst0mutablefstclassreadin0name true$^  if fst0 return 0$^$^  stduniqueptrfstclass fst0fstclassreadin0name$^  if fst0 return 0$^$^  sunionfst0.get fst0$^$^  return fst0writeoutname$^$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^ inverts a transduction.$^$^include cstring$^$^include memory$^include string$^$^include fstflags.h$^include fstscriptinvert.h$^$^int fstinvertmainint argc char argv $^  namespace s  fstscript$^  using fstscriptmutablefstclass$^$^  string usage  inverts a transduction.nn  usage $^  usage  argv0$^  usage   in.fst out.fstn$^$^  stdsetnewhandlerfailednewhandler$^  setflagsusage.cstr argc argv true$^  if argc  0 $^    showusage$^    return 0$^  $^$^  const string inname  argc  0  strcmpargv0   0  argv0  $^  const string outname  argc  0  argv0  $^$^  stduniqueptrmutablefstclass fstmutablefstclassreadinname true$^  if fst return 0$^$^  sinvertfst.get$^$^  return fstwriteoutname$^$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstflags.h$^include fstfst.h$^include fstweight.h$^$^definedoubledelta fstkdelta comparisonquantization delta$^defineint00nstate fstknostateid state number threshold$^definestringweight  weight threshold$^defineint00subsequentiallabel 0$^             input label of arc corresponding to residual final output when$^              producing a subsequential transducer$^$^int fstdisambiguatemainint argc char argv$^$^int mainint argc char argv  return fstdisambiguatemainargc argv $^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^ removes epsilons from an fst.$^$^include cstring$^$^include memory$^include string$^$^include fstflags.h$^include fstlog.h$^include fstscriptgetters.h$^include fstscriptrmepsilon.h$^$^declareboolconnect$^declaredoubledelta$^declareint00nstate$^declarestringqueuetype$^declarestringweight$^$^int fstrmepsilonmainint argc char argv $^  namespace s  fstscript$^  using fstscriptmutablefstclass$^  using fstscriptweightclass$^$^  string usage  removes epsilons from an fst.nn  usage $^  usage  argv0$^  usage   in.fst out.fstn$^$^  stdsetnewhandlerfailednewhandler$^  setflagsusage.cstr argc argv true$^  if argc  0 $^    showusage$^    return 0$^  $^$^  const string inname  argc  0  strcmpargv0   0  argv0  $^  const string outname  argc  0  argv0  $^$^  stduniqueptrmutablefstclass fstmutablefstclassreadinname true$^  if fst return 0$^$^  const auto weightthreshold $^      flagsweight.empty  weightclasszerofstweighttype$^                            weightclassfstweighttype flagsweight$^$^  fstqueuetype queuetype$^  if sgetqueuetypeflagsqueuetype queuetype $^    logerror  argv0$^                 unknown or unsupported queue type   flagsqueuetype$^    return 0$^  $^$^  const srmepsilonoptions optsqueuetype flagsconnect weightthreshold$^                                 flagsnstate flagsdelta$^$^  srmepsilonfst.get opts$^$^  return fstwriteoutname$^$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstflags.h$^$^definebooltofinal false pushreweight to final vs. to initial states$^$^int fstreweightmainint argc char argv$^$^int mainint argc char argv  return fstreweightmainargc argv $^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstflags.h$^include fstfst.h$^include fstshortestdistance.h$^include fstweight.h$^$^definedoubledelta fstkshortestdelta comparisonquantization delta$^defineint00nshortest 0 return nshortest paths$^defineint00nstate fstknostateid state number threshold$^definestringqueuetype auto$^              queue type one of auto $^              fifo lifo shortest state top$^defineboolunique false return unique strings$^definestringweight  weight threshold$^$^int fstshortestpathmainint argc char argv$^$^int mainint argc char argv  return fstshortestpathmainargc argv $^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^ intersects two fsts.$^$^include cstring$^$^include memory$^include string$^$^include fstflags.h$^include fstlog.h$^include fstscriptgetters.h$^include fstscriptintersect.h$^$^declarestringcomposefilter$^declareboolconnect$^$^int fstintersectmainint argc char argv $^  namespace s  fstscript$^  using fstcomposefilter$^  using fstscriptfstclass$^  using fstscriptvectorfstclass$^$^  string usage  intersects two fsas.nn  usage $^  usage  argv0$^  usage   in0.fst in0.fst out.fstn$^  usage    flags connectn$^$^  stdsetnewhandlerfailednewhandler$^  setflagsusage.cstr argc argv true$^  if argc  0  argc  0 $^    showusage$^    return 0$^  $^$^  const string in0name  strcmpargv0   0    argv0$^  const string in0name  strcmpargv0   0    argv0$^  const string outname  argc  0  argv0  $^$^  if in0name.empty  in0name.empty $^    logerror  argv0   cant take both inputs from standard input$^    return 0$^  $^$^  stduniqueptrfstclass ifst0fstclassreadin0name$^  if ifst0 return 0$^  stduniqueptrfstclass ifst0fstclassreadin0name$^  if ifst0 return 0$^$^  vectorfstclass ofstifst0arctype$^$^  composefilter composefilter$^  if sgetcomposefilterflagscomposefilter composefilter $^    logerror  argv0   unknown or unsupported compose filter type $^                flagscomposefilter$^    return 0$^  $^$^  const fstintersectoptions optsflagsconnect composefilter$^$^  sintersectifst0 ifst0 ofst opts$^$^  return ofst.writeoutname$^$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstflags.h$^$^definestringcomposefilter auto$^             composition filter one of altsequence auto $^              match null sequence trivial$^defineboolconnect true trim output$^$^int fstintersectmainint argc char argv$^$^int mainint argc char argv  return fstintersectmainargc argv $^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstflags.h$^$^defineboolprojectoutput false project on output vs. input$^$^int fstprojectmainint argc char argv$^$^int mainint argc char argv  return fstprojectmainargc argv $^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstflags.h$^$^defineboolepsnormoutput false normalize output epsilons$^$^int fstepsnormalizemainint argc char argv$^$^int mainint argc char argv  return fstepsnormalizemainargc argv $^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstflags.h$^$^defineboolclosureplus false$^            do not add the empty path t instead of t$^$^int fstclosuremainint argc char argv$^$^int mainint argc char argv  return fstclosuremainargc argv $^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstflags.h$^$^definestringcallarclabeling input$^              which labels to make nonepsilon on the call arc. $^              one of input default output both neither$^definestringreturnarclabeling neither$^              which labels to make nonepsilon on the return arc. $^              one of input output both neither default$^defineint00returnlabel 0 label to put on return arc$^defineboolepsilononreplace false callreturn arcs are epsilon arcs$^$^int fstreplacemainint argc char argv$^$^int mainint argc char argv  return fstreplacemainargc argv $^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^ performs operations set clear relabel on the symbols table attached to an$^ input fst.$^$^include cstring$^$^include memory$^include string$^include vector$^$^include fstflags.h$^include fstutil.h$^include fstscriptfstclass.h$^include fstscriptverify.h$^$^declarestringisymbols$^declarestringosymbols$^declareboolclearisymbols$^declareboolclearosymbols$^declarestringrelabelipairs$^declarestringrelabelopairs$^declarestringsaveisymbols$^declarestringsaveosymbols$^declareboolallownegativelabels$^declareboolverify$^$^int fstsymbolsmainint argc char argv $^  namespace s  fstscript$^  using fstscriptmutablefstclass$^  using fstreadlabelpairs$^  using fstsymboltable$^  using fstsymboltabletextoptions$^$^  string usage $^      performs operations set clear relabel on the symbol$^       tables attached to an fst.nn  usage $^  usage  argv0$^  usage   in.fst out.fstn$^$^  stdsetnewhandlerfailednewhandler$^  setflagsusage.cstr argc argv true$^  if argc  0 $^    showusage$^    return 0$^  $^$^  const string inname  argc  0  strcmpargv0   0  argv0  $^  const string outname  argc  0  argv0  $^$^  stduniqueptrmutablefstclass fstmutablefstclassreadinname true$^  if fst return 0$^$^  if flagssaveisymbols.empty $^    const auto isyms  fstinputsymbols$^    if isyms $^      isymswritetextflagssaveisymbols$^     else $^      logerror  argv0$^                   saving isymbols but there are no input symbols.$^    $^  $^$^  if flagssaveosymbols.empty $^    const auto osyms  fstoutputsymbols$^    if osyms $^      osymswritetextflagssaveosymbols$^     else $^      logerror  argv0$^                   saving osymbols but there are no output symbols.$^    $^  $^$^  const symboltabletextoptions optsflagsallownegativelabels$^$^  stduniqueptrsymboltable isyms$^  if flagsisymbols.empty $^    isyms.resetsymboltablereadtextflagsisymbols opts$^    fstsetinputsymbolsisyms.get$^   else if flagsclearisymbols $^    fstsetinputsymbolsnullptr$^  $^  stduniqueptrsymboltable osyms$^  if flagsosymbols.empty $^    osyms.resetsymboltablereadtextflagsosymbols opts$^    fstsetoutputsymbolsosyms.get$^   else if flagsclearosymbols $^    fstsetoutputsymbolsnullptr$^  $^$^  using label  int00$^  if flagsrelabelipairs.empty $^    stdvectorstdpairlabel label ipairs$^    readlabelpairsflagsrelabelipairs ipairs flagsallownegativelabels$^    stduniqueptrsymboltable isymsrelabel$^        relabelsymboltablefstinputsymbols ipairs$^    fstsetinputsymbolsisymsrelabel.get$^  $^  if flagsrelabelopairs.empty $^    stdvectorstdpairlabel label opairs$^    readlabelpairsflagsrelabelopairs opairs flagsallownegativelabels$^    stduniqueptrsymboltable osymsrelabel$^        relabelsymboltablefstoutputsymbols opairs$^    fstsetoutputsymbolsosymsrelabel.get$^  $^$^  if flagsverify  sverifyfst return 0$^$^  return fstwriteoutname$^$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^ two dfas are equivalent iff their exit status is zero.$^$^include cstring$^$^include memory$^include string$^$^include fstflags.h$^include fstlog.h$^include fstscriptequivalent.h$^include fstscriptgetters.h$^include fstscriptrandequivalent.h$^$^declaredoubledelta$^declareboolrandom$^declareint00maxlength$^declareint00npath$^declareint00seed$^declarestringselect$^$^int fstequivalentmainint argc char argv $^  namespace s  fstscript$^  using fstrandgenoptions$^  using fstscriptfstclass$^$^  string usage $^      two dfas are equivalent iff the exit status is zero.nn$^        usage $^  usage  argv0$^  usage   in0.fst in0.fstn$^$^  stdsetnewhandlerfailednewhandler$^  setflagsusage.cstr argc argv true$^  if argc  0 $^    showusage$^    return 0$^  $^$^  const string in0name  strcmpargv0   0    argv0$^  const string in0name  strcmpargv0   0    argv0$^$^  if in0name.empty  in0name.empty $^    logerror  argv0   cant take both inputs from standard input$^    return 0$^  $^$^  stduniqueptrfstclass ifst0fstclassreadin0name$^  if ifst0 return 0$^$^  stduniqueptrfstclass ifst0fstclassreadin0name$^  if ifst0 return 0$^$^  if flagsrandom $^    bool result  sequivalentifst0 ifst0 flagsdelta$^    if result vlog0  fsts are not equivalent$^    return result  0  0$^   else $^    srandarcselection ras$^    if sgetrandarcselectionflagsselect ras $^      logerror  argv0   unknown or unsupported select type $^                             flagsselect$^      return 0$^    $^    const randgenoptionssrandarcselection optsras flagsmaxlength$^    bool result  srandequivalentifst0 ifst0 flagsnpath flagsdelta$^                                    flagsseed opts$^    if result vlog0  fsts are not equivalent$^    return result  0  0$^  $^$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^ prints out various information about an fst such as number of states$^ and arcs and property values see properties.h.$^$^include cstring$^$^include memory$^include string$^$^include fstflags.h$^include fstscriptinfo.h$^$^declarestringarcfilter$^declarestringinfotype$^declareboolpipe$^declarebooltestproperties$^declareboolfstverify$^$^int fstinfomainint argc char argv $^  namespace s  fstscript$^  using fstscriptfstclass$^$^  string usage  prints out information about an fst.nn  usage $^  usage  argv0$^  usage   in.fstn$^$^  stdsetnewhandlerfailednewhandler$^  setflagsusage.cstr argc argv true$^  if argc  0 $^    showusage$^    return 0$^  $^$^  const string inname $^      argc  0  strcmpargv0   0  argv0  $^$^  stduniqueptrfstclass ifstfstclassreadinname$^  if ifst return 0$^$^  sprintfstinfoifst flagstestproperties flagsarcfilter$^                  flagsinfotype flagsfstverify flagspipe$^$^  return 0$^$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^int fstconcatmainint argc char argv$^$^int mainint argc char argv  return fstconcatmainargc argv $^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstflags.h$^$^definestringarcfilter any$^              arc filter one of$^               any epsilon iepsilon oepsilon $^              this only affects the counts of coaccessible states $^              connected states and strongly connected components$^definestringinfotype auto$^              info format one of auto long short$^defineboolpipe false send info to stderr input to stdout$^definebooltestproperties true$^            compute property values if unknown to fst$^defineboolfstverify true verify fst sanity$^$^int fstinfomainint argc char argv$^$^int mainint argc char argv  return fstinfomainargc argv $^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstflags.h$^$^defineboolacceptor false input in acceptor format$^definestringisymbols  input label symbol table$^definestringosymbols  output label symbol table$^definestringssymbols  state label symbol table$^defineboolnumeric false print numeric labels$^definestringsaveisymbols  save input symbol table to file$^definestringsaveosymbols  save output symbol table to file$^defineboolshowweightone false$^            printdraw arc weights and final weights equal to semiring one$^defineboolallownegativelabels false$^            allow negative labels not recommended may cause conflicts$^definestringmissingsymbol $^              symbol to print when lookup fails default raises error$^$^int fstprintmainint argc char argv$^$^int mainint argc char argv  return fstprintmainargc argv $^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstflags.h$^include fstfst.h$^include fstweight.h$^$^definedoubledelta fstkdelta comparisonquantization delta$^defineint00nstate fstknostateid state number threshold$^definestringweight  weight threshold$^$^int fstprunemainint argc char argv$^$^int mainint argc char argv  return fstprunemainargc argv $^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^ find shortest paths in an fst.$^$^include cstring$^$^include memory$^include string$^include vector$^$^include fstflags.h$^include fstlog.h$^include fstscriptgetters.h$^include fstscriptshortestpath.h$^$^declaredoubledelta$^declareint00nshortest$^declareint00nstate$^declarestringqueuetype$^declareboolunique$^declarestringweight$^$^int fstshortestpathmainint argc char argv $^  namespace s  fstscript$^  using fstscriptfstclass$^  using fstscriptweightclass$^  using fstscriptvectorfstclass$^$^  string usage  finds shortest paths in an fst.nn  usage $^  usage  argv0$^  usage   in.fst out.fstn$^$^  stdsetnewhandlerfailednewhandler$^  setflagsusage.cstr argc argv true$^  if argc  0 $^    showusage$^    return 0$^  $^$^  const string inname $^      argc  0  strcmpargv0   0  argv0  $^  const string outname  argc  0  argv0  $^$^  stduniqueptrfstclass ifstfstclassreadinname$^  if ifst return 0$^$^  const auto weightthreshold $^      flagsweight.empty  weightclasszeroifstweighttype$^                            weightclassifstweighttype flagsweight$^$^  vectorfstclass ofstifstarctype$^$^  fstqueuetype queuetype$^  if sgetqueuetypeflagsqueuetype queuetype $^    logerror  unknown or unsupported queue type   flagsqueuetype$^    return 0$^  $^$^  const sshortestpathoptions optsqueuetype flagsnshortest$^                                    flagsunique flagsdelta$^                                    weightthreshold flagsnstate$^$^  sshortestpathifst ofst opts$^$^  return ofst.writeoutname$^$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^ pushes weights andor output labels in an fst toward the initial or final$^ states.$^$^include cstring$^$^include memory$^include string$^$^include fstflags.h$^include fstscriptgetters.h$^include fstscriptpush.h$^$^declaredoubledelta$^declareboolpushweights$^declareboolpushlabels$^declareboolremovetotalweight$^declareboolremovecommonaffix$^declarebooltofinal$^$^int fstpushmainint argc char argv $^  namespace s  fstscript$^  using fstscriptfstclass$^  using fstscriptvectorfstclass$^$^  string usage  pushes weights andor olabels in an fst.nn  usage $^  usage  argv0$^  usage   in.fst out.fstn$^$^  stdsetnewhandlerfailednewhandler$^  setflagsusage.cstr argc argv true$^  if argc  0 $^    showusage$^    return 0$^  $^$^  string inname  argc  0  strcmpargv0   0  argv0  $^  string outname  argc  0  argv0  $^$^  stduniqueptrfstclass ifstfstclassreadinname$^  if ifst return 0$^$^  const auto flags $^      sgetpushflagsflagspushweights flagspushlabels$^                      flagsremovetotalweight flagsremovecommonaffix$^$^  vectorfstclass ofstifstarctype$^$^  spushifst ofst flags sgetreweighttypeflagstofinal$^          flagsdelta$^$^  return ofst.writeoutname$^$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstflags.h$^$^definestringisymbols  input label symbol table$^definestringosymbols  output label symbol table$^defineboolclearisymbols false clear input symbol table$^defineboolclearosymbols false clear output symbol table$^definestringrelabelipairs  input relabel pairs numeric$^definestringrelabelopairs  output relabel pairs numeric$^definestringsaveisymbols  save fst files input symbol table to file$^definestringsaveosymbols  save fst files output symbol table to file$^defineboolallownegativelabels false$^            allow negative labels not recommended may cause conflicts$^defineboolverify false verify fst properities before saving$^$^int fstsymbolsmainint argc char argv$^$^int mainint argc char argv  return fstsymbolsmainargc argv $^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^ draws a binary fsts in the graphviz dot text format.$^$^include cstring$^$^include fstream$^include memory$^include ostream$^include string$^$^include fstflags.h$^include fstlog.h$^include fstscriptdraw.h$^$^declareboolacceptor$^declarestringisymbols$^declarestringosymbols$^declarestringssymbols$^declareboolnumeric$^declareint00precision$^declarestringfloatformat$^declareboolshowweightone$^declarestringtitle$^declareboolportrait$^declareboolvertical$^declareint00fontsize$^declaredoubleheight$^declaredoublewidth$^declaredoublenodesep$^declaredoubleranksep$^declareboolallownegativelabels$^$^int fstdrawmainint argc char argv $^  namespace s  fstscript$^  using fstscriptfstclass$^  using fstsymboltable$^  using fstsymboltabletextoptions$^$^  string usage  prints out binary fsts in dot text format.nn  usage $^  usage  argv0$^  usage   binary.fst text.dotn$^$^  stdsetnewhandlerfailednewhandler$^  setflagsusage.cstr argc argv true$^  if argc  0 $^    showusage$^    return 0$^  $^$^  const string inname  argc  0  strcmpargv0   0  argv0  $^$^  stduniqueptrfstclass fstfstclassreadinname$^  if fst return 0$^$^  string dest  stdout$^  stdofstream fstrm$^  if argc  0 $^    fstrm.openargv0$^    if fstrm $^      logerror  argv0   open failed file    argv0$^      return 0$^    $^    dest  argv0$^  $^  stdostream ostrm  fstrm.isopen  fstrm  stdcout$^$^  const symboltabletextoptions optsflagsallownegativelabels$^$^  stduniqueptrconst symboltable isyms$^  if flagsisymbols.empty  flagsnumeric $^    isyms.resetsymboltablereadtextflagsisymbols opts$^    if isyms return 0$^  $^$^  stduniqueptrconst symboltable osyms$^  if flagsosymbols.empty  flagsnumeric $^    osyms.resetsymboltablereadtextflagsosymbols opts$^    if osyms return 0$^  $^$^  stduniqueptrconst symboltable ssyms$^  if flagsssymbols.empty  flagsnumeric $^    ssyms.resetsymboltablereadtextflagsssymbols$^    if ssyms return 0$^  $^$^  if isyms  flagsnumeric  fstinputsymbols $^    isyms.resetfstinputsymbolscopy$^  $^$^  if osyms  flagsnumeric  fstoutputsymbols $^    osyms.resetfstoutputsymbolscopy$^  $^$^  sdrawfstfst isyms.get osyms.get ssyms.get flagsacceptor$^             flagstitle flagswidth flagsheight flagsportrait$^             flagsvertical flagsranksep flagsnodesep flagsfontsize$^             flagsprecision flagsfloatformat flagsshowweightone$^             ostrm dest$^$^  return 0$^$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstflags.h$^$^defineboolencodelabels false encode output labels$^defineboolencodeweights false encode weights$^defineboolencodereuse false reuse existing codex$^definebooldecode false decode labels andor weights$^$^int fstencodemainint argc char argv$^$^int mainint argc char argv  return fstencodemainargc argv $^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^ minimizes a deterministic fst.$^$^include cstring$^$^include memory$^include string$^$^include fstflags.h$^include fstlog.h$^include fstscriptminimize.h$^$^declaredoubledelta$^declareboolallownondet$^$^int fstminimizemainint argc char argv $^  namespace s  fstscript$^  using fstscriptmutablefstclass$^  using fstscriptvectorfstclass$^$^  string usage  minimizes a deterministic fst.nn  usage $^  usage  argv0$^  usage   in.fst out0.fst out0.fstn$^$^  stdsetnewhandlerfailednewhandler$^  setflagsusage.cstr argc argv true$^  if argc  0 $^    showusage$^    return 0$^  $^$^  const string inname  argc  0  strcmpargv0   0  argv0  $^  const string out0name $^      argc  0  strcmpargv0   0  argv0  $^  const string out0name $^      argc  0  strcmpargv0   0  argv0  $^$^  if out0name.empty  out0name.empty  argc  0 $^    logerror  argv0   both outputs cant be standard output.$^    return 0$^  $^$^  stduniqueptrmutablefstclass fst0mutablefstclassreadinname true$^  if fst0 return 0$^$^  if argc  0 $^    stduniqueptrmutablefstclass fst0new vectorfstclassfst0arctype$^    sminimizefst0.get fst0.get flagsdelta flagsallownondet$^    if fst0writeout0name return 0$^   else $^    sminimizefst0.get nullptr flagsdelta flagsallownondet$^  $^$^  return fst0writeout0name$^$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^ sorts arcs of an fst.$^$^include cstring$^$^include memory$^include string$^$^include fstflags.h$^include fstlog.h$^include fstscriptarcsort.h$^include fstscriptgetters.h$^$^declarestringsorttype$^$^int fstarcsortmainint argc char argv $^  namespace s  fstscript$^  using fstscriptmutablefstclass$^$^  string usage  sorts arcs of an fst.nn  usage $^  usage  argv0$^  usage   in.fst out.fstn$^$^  stdsetnewhandlerfailednewhandler$^  setflagsusage.cstr argc argv true$^$^  if argc  0 $^    showusage$^    return 0$^  $^$^  const string inname $^      argc  0  strcmpargv0   0  argv0  $^  const string outname  argc  0  argv0  $^$^  stduniqueptrmutablefstclass fstmutablefstclassreadinname true$^  if fst return 0$^$^  sarcsorttype sorttype$^  if sgetarcsorttypeflagssorttype sorttype $^    logerror  argv0   unknown or unsupported sort type $^                flagssorttype$^    return 0$^  $^$^  sarcsortfst.get sorttype$^$^  return fstwriteoutname$^$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstflags.h$^$^defineboolacceptor false input in acceptor format$^definestringarctype standard output arc type$^definestringfsttype vector output fst type$^definestringisymbols  input label symbol table$^definestringosymbols  output label symbol table$^definestringssymbols  state label symbol table$^defineboolkeepisymbols false store input label symbol table with fst$^defineboolkeeposymbols false store output label symbol table with fst$^defineboolkeepstatenumbering false do not renumber input states$^defineboolallownegativelabels false$^            allow negative labels not recommended may cause conflicts$^$^int fstcompilemainint argc char argv$^$^int mainint argc char argv  return fstcompilemainargc argv $^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstflags.h$^include fstweight.h$^$^definedoubledelta fstkdelta comparisonquantization delta$^defineboolpushweights false push weights$^defineboolpushlabels false push output labels$^defineboolremovetotalweight false$^            remove total weight when pushing weights$^defineboolremovecommonaffix false$^            remove common prefixsuffix when pushing labels$^definebooltofinal false pushreweight to final vs. to initial states$^$^int fstpushmainint argc char argv$^$^int mainint argc char argv  return fstpushmainargc argv $^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^ reverses the paths in an fst.$^$^include cstring$^$^include memory$^include string$^$^include fstflags.h$^include fstscriptfstclass.h$^include fstscriptreverse.h$^$^declareboolrequiresuperinitial$^$^int fstreversemainint argc char argv $^  namespace s  fstscript$^  using fstscriptfstclass$^  using fstscriptvectorfstclass$^$^  string usage  reverses the paths in an fst.nn  usage $^  usage  argv0$^  usage   in.fst out.fstn$^$^  stdsetnewhandlerfailednewhandler$^  setflagsusage.cstr argc argv true$^  if argc  0 $^    showusage$^    return 0$^  $^$^  const string inname $^      argc  0  strcmpargv0   0  argv0  $^  const string outname  argc  0  argv0  $^$^  stduniqueptrfstclass ifstfstclassreadinname$^  if ifst return 0$^$^  vectorfstclass ofstifstarctype$^$^  sreverseifst ofst flagsrequiresuperinitial$^$^  return ofst.writeoutname$^$^ifndef mscver$^include unistd.h$^else$^include process.h$^define getpid getpid$^endif$^$^include climits$^include ctime$^$^include fstflags.h$^$^defineint00maxlength int00max maximum path length$^defineint00npath 0 number of paths to generate$^defineint00seed timenullptr  getpid random seed$^definestringselect uniform$^              selection type one of $^               uniform logprob when appropriate$^               fastlogprob when appropriate$^defineboolweighted false$^            output tree weighted by path count vs. unweighted paths$^defineboolremovetotalweight false$^            remove total weight when output weighted$^$^int fstrandgenmainint argc char argv$^$^int mainint argc char argv  return fstrandgenmainargc argv $^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^ concatenates two fsts.$^$^include cstring$^$^include memory$^include string$^$^include fstflags.h$^include fstlog.h$^include fstscriptconcat.h$^$^int fstconcatmainint argc char argv $^  namespace s  fstscript$^  using fstscriptfstclass$^  using fstscriptmutablefstclass$^$^  string usage  concatenates two fsts.nn  usage $^  usage  argv0$^  usage   in0.fst in0.fst out.fstn$^$^  stdsetnewhandlerfailednewhandler$^  setflagsusage.cstr argc argv true$^  if argc  0  argc  0 $^    showusage$^    return 0$^  $^$^  const string in0name  strcmpargv0   0    argv0$^  const string in0name  strcmpargv0   0    argv0$^  const string outname  argc  0  argv0  $^$^  if in0name.empty  in0name.empty $^    logerror  argv0   cant take both inputs from standard input$^    return 0$^  $^$^  stduniqueptrmutablefstclass fst0mutablefstclassreadin0name true$^  if fst0 return 0$^$^  stduniqueptrfstclass fst0fstclassreadin0name$^  if fst0 return 0$^$^  sconcatfst0.get fst0$^$^  return fst0writeoutname$^$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstflags.h$^include fstweight.h$^$^definedoubledelta fstkdelta comparisonquantization delta$^definestringmaptype identity$^              map operation one of arcsum arcunique $^              floatpower power identity inputepsilon $^              invert outputepsilon plus weight $^              quantize delta rmweight superfinal $^              power power times weight tolog $^              tolog00 tostd$^definedoublepower 0.0 power parameter$^definestringweight  weight parameter$^$^int fstmapmainint argc char argv$^$^int mainint argc char argv  return fstmapmainargc argv $^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstflags.h$^include fstfst.h$^include fstshortestdistance.h$^include fstweight.h$^$^defineboolconnect true trim output$^definedoubledelta fstkshortestdelta comparisonquantization delta$^defineint00nstate fstknostateid state number threshold$^definestringqueuetype auto$^              queue type one of auto $^              fifo lifo shortest state top$^definestringweight  weight threshold$^$^int fstrmepsilonmainint argc char argv$^$^int mainint argc char argv  return fstrmepsilonmainargc argv $^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^ performs the dynamic replacement of arcs in one fst with another fst$^ allowing for the definition of fsts analogous to rtns.$^$^include cstring$^$^include string$^include vector$^$^include fstflags.h$^include fstscriptgetters.h$^include fstscriptreplace.h$^$^declarestringcallarclabeling$^declarestringreturnarclabeling$^declareint00returnlabel$^declareboolepsilononreplace$^$^void cleanupstdvectorfstscriptlabelfstclasspair pairs $^  for const auto pair  pairs $^    delete pair.second$^  $^  pairsclear$^$^$^int fstreplacemainint argc char argv $^  namespace s  fstscript$^  using fstscriptfstclass$^  using fstscriptvectorfstclass$^  using fstreplacelabeltype$^$^  string usage  recursively replaces fst arcs with other fsts.nn$^                   usage $^  usage  argv0$^  usage   root.fst rootlabel rule0.fst label0 ... out.fstn$^$^  stdsetnewhandlerfailednewhandler$^  setflagsusage.cstr argc argv true$^  if argc  0 $^    showusage$^    return 0$^  $^$^  const string inname  argv0$^  const string outname  argc  0  0  argvargc  0  $^$^  auto ifst  fstclassreadinname$^  if ifst return 0$^$^  stdvectorslabelfstclasspair pairs$^   note that if the root label is beyond the range of the underlying fsts$^   labels truncation will occur.$^  const auto root  atollargv0$^  pairs.emplacebackroot ifst$^$^  for auto i  0 i  argc  0 i  0 $^    ifst  fstclassreadargvi$^    if ifst $^      cleanuppairs$^      return 0$^    $^     note that if the root label is beyond the range of the underlying fsts$^     labels truncation will occur.$^    const auto label  atollargvi  0$^    pairs.emplacebacklabel ifst$^  $^$^  replacelabeltype calllabeltype$^  if sgetreplacelabeltypeflagscallarclabeling flagsepsilononreplace$^                              calllabeltype $^    logerror  argv0   unknown or unsupported call arc replace $^                label type   flagscallarclabeling$^  $^  replacelabeltype returnlabeltype$^  if sgetreplacelabeltypeflagsreturnarclabeling$^                              flagsepsilononreplace returnlabeltype $^    logerror  argv0   unknown or unsupported return arc replace $^                label type   flagsreturnarclabeling$^  $^$^  sreplaceoptions optsroot calllabeltype returnlabeltype$^                         flagsreturnlabel$^$^  vectorfstclass ofstifstarctype$^  sreplacepairs ofst opts$^  cleanuppairs$^$^  return ofst.writeoutname$^$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^ disambiguates an fst.$^$^include cstring$^$^include memory$^include string$^$^include fstflags.h$^include fstscriptdisambiguate.h$^$^declaredoubledelta$^declareint00nstate$^declarestringweight$^declareint00subsequentiallabel$^$^int fstdisambiguatemainint argc char argv $^  namespace s  fstscript$^  using fstscriptfstclass$^  using fstscriptvectorfstclass$^  using fstscriptweightclass$^$^  string usage  disambiguates an fst.nn  usage $^  usage  argv0$^  usage   in.fst out.fstn$^$^  stdsetnewhandlerfailednewhandler$^  setflagsusage.cstr argc argv true$^  if argc  0 $^    showusage$^    return 0$^  $^$^  const string inname  argc  0  strcmpargv0   0  argv0  $^  const string outname  argc  0  argv0  $^$^  stduniqueptrfstclass ifstfstclassreadinname$^  if ifst return 0$^$^  vectorfstclass ofstifstarctype$^$^  const auto weightthreshold $^      flagsweight.empty  weightclasszeroifstweighttype$^                            weightclassifstweighttype flagsweight$^$^  const sdisambiguateoptions optsflagsdelta weightthreshold flagsnstate$^                                    flagssubsequentiallabel$^$^  sdisambiguateifst ofst opts$^$^  return ofst.writeoutname$^$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstflags.h$^$^defineboolacceptor false input in acceptor format$^definestringisymbols  input label symbol table$^definestringosymbols  output label symbol table$^definestringssymbols  state label symbol table$^defineboolnumeric false print numeric labels$^defineint00precision 0 set precision number of charfloat$^definestringfloatformat g$^              floatingpoint format one of e f or g$^defineboolshowweightone false$^            printdraw arc weights and final weights equal to weightone$^definestringtitle  set figure title$^defineboolportrait false portrait mode def landscape$^defineboolvertical false draw bottomtotop instead of lefttoright$^defineint00fontsize 00 set fontsize$^definedoubleheight 00 set height$^definedoublewidth 0.0 set width$^definedoublenodesep 0.00$^              set minimum separation between nodes see dot documentation$^definedoubleranksep 0.00$^              set minimum separation between ranks see dot documentation$^defineboolallownegativelabels false$^            allow negative labels not recommended may cause conflicts$^$^int fstdrawmainint argc char argv$^$^int mainint argc char argv  return fstdrawmainargc argv $^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^int fsttopsortmainint argc char argv$^$^int mainint argc char argv  return fsttopsortmainargc argv $^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstscriptfstclass.h$^include fstscriptrmepsilon.h$^include fstscriptscriptimpl.h$^$^namespace fst $^namespace script $^$^void rmepsilonmutablefstclass fst const rmepsilonoptions opts $^  if fstweighttypesmatchopts.weightthreshold rmepsilon $^    fstsetpropertieskerror kerror$^    return$^  $^  rmepsilonargs argsfst opts$^  applyoperationrmepsilonargsrmepsilon fstarctype args$^$^$^registerfstoperationrmepsilon stdarc rmepsilonargs$^registerfstoperationrmepsilon logarc rmepsilonargs$^registerfstoperationrmepsilon log00arc rmepsilonargs$^$^   namespace script$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstscriptfstclass.h$^include fstencode.h$^include fstscriptdecode.h$^include fstscriptscriptimpl.h$^$^namespace fst $^namespace script $^$^void decodemutablefstclass fst const string coderfname $^  decodeargs0 argsfst coderfname$^  applyoperationdecodeargs0decode fstarctype args$^$^$^void decodemutablefstclass fst const encodemapperclass encoder $^  if internalarctypesmatchfst encoder decode $^    fstsetpropertieskerror kerror$^    return$^  $^  decodeargs0 argsfst encoder$^  applyoperationdecodeargs0decode fstarctype args$^$^$^registerfstoperationdecode stdarc decodeargs0$^registerfstoperationdecode logarc decodeargs0$^registerfstoperationdecode log00arc decodeargs0$^$^registerfstoperationdecode stdarc decodeargs0$^registerfstoperationdecode logarc decodeargs0$^registerfstoperationdecode log00arc decodeargs0$^$^   namespace script$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include string$^$^include fstscriptfstclass.h$^include fstscriptinfo.h$^include fstscriptscriptimpl.h$^$^namespace fst $^namespace script $^$^void printfstinfoconst fstclass fst bool testproperties$^                  const string arcfilter const string infotype bool pipe$^                  bool verify $^  infoargs argsfst testproperties arcfilter infotype pipe verify$^  applyoperationinfoargsprintfstinfo fst.arctype args$^$^$^void getfstinfoconst fstclass fst bool testproperties$^                const string arcfilter const string infotype bool verify$^                fstinfo result $^  getinfoargs argsfst testproperties arcfilter infotype verify result$^  applyoperationgetinfoargsgetfstinfo fst.arctype args$^$^$^registerfstoperationprintfstinfo stdarc infoargs$^registerfstoperationprintfstinfo logarc infoargs$^registerfstoperationprintfstinfo log00arc infoargs$^$^registerfstoperationgetfstinfo stdarc getinfoargs$^registerfstoperationgetfstinfo logarc getinfoargs$^registerfstoperationgetfstinfo log00arc getinfoargs$^$^   namespace script$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstscriptfstclass.h$^include fstscriptinvert.h$^include fstscriptscriptimpl.h$^$^namespace fst $^namespace script $^$^void invertmutablefstclass fst $^  applyoperationmutablefstclassinvert fstarctype fst$^$^$^registerfstoperationinvert stdarc mutablefstclass$^registerfstoperationinvert logarc mutablefstclass$^registerfstoperationinvert log00arc mutablefstclass$^$^   namespace script$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstscriptfstclass.h$^include fstscriptscriptimpl.h$^include fstscriptverify.h$^$^namespace fst $^namespace script $^$^bool verifyconst fstclass fst $^  verifyargs argsfst$^  applyoperationverifyargsverify fst.arctype args$^  return args.retval$^$^$^registerfstoperationverify stdarc verifyargs$^registerfstoperationverify logarc verifyargs$^registerfstoperationverify log00arc verifyargs$^$^   namespace script$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstscriptfstclass.h$^include fstscriptscriptimpl.h$^include fstscriptunion.h$^$^namespace fst $^namespace script $^$^void unionmutablefstclass fst0 const fstclass fst0 $^  if internalarctypesmatchfst0 fst0 union $^    fst0setpropertieskerror kerror$^    return$^  $^  unionargs argsfst0 fst0$^  applyoperationunionargsunion fst0arctype args$^$^$^registerfstoperationunion stdarc unionargs$^registerfstoperationunion logarc unionargs$^registerfstoperationunion log00arc unionargs$^$^   namespace script$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstscriptfstclass.h$^include fstscriptclosure.h$^include fstscriptscriptimpl.h$^$^namespace fst $^namespace script $^$^void closuremutablefstclass fst closuretype closuretype $^  closureargs argsfst closuretype$^  applyoperationclosureargsclosure fstarctype args$^$^$^registerfstoperationclosure stdarc closureargs$^registerfstoperationclosure logarc closureargs$^registerfstoperationclosure log00arc closureargs$^$^   namespace script$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstscriptfstclass.h$^include fstscriptproject.h$^include fstscriptscriptimpl.h$^$^namespace fst $^namespace script $^$^$^void projectmutablefstclass ofst projecttype projecttype $^  projectargs argsofst projecttype$^  applyoperationprojectargsproject ofstarctype args$^$^$^registerfstoperationproject stdarc projectargs$^registerfstoperationproject logarc projectargs$^registerfstoperationproject log00arc projectargs$^$^   namespace script$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstscriptfstclass.h$^include fstscriptpush.h$^include fstscriptscriptimpl.h$^$^namespace fst $^namespace script $^$^void pushmutablefstclass fst reweighttype rewtype float delta$^          bool removetotalweight $^  pushargs0 argsfst rewtype delta removetotalweight$^  applyoperationpushargs0push fstarctype args$^$^$^void pushconst fstclass ifst mutablefstclass ofst uint00 flags$^          reweighttype rewtype float delta $^  if internalarctypesmatchifst ofst push $^    ofstsetpropertieskerror kerror$^    return$^  $^  pushargs0 argsifst ofst flags rewtype delta$^  applyoperationpushargs0push ifst.arctype args$^$^$^registerfstoperationpush stdarc pushargs0$^registerfstoperationpush logarc pushargs0$^registerfstoperationpush log00arc pushargs0$^$^registerfstoperationpush stdarc pushargs0$^registerfstoperationpush logarc pushargs0$^registerfstoperationpush log00arc pushargs0$^$^   namespace script$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstscriptfstclass.h$^include fstscriptreplace.h$^include fstscriptscriptimpl.h$^$^namespace fst $^namespace script $^$^void replaceconst stdvectorlabelfstclasspair pairs mutablefstclass ofst$^             const replaceoptions opts $^  if pairs.empty $^    for auto it  pairs.begin it  pairs.end  0 it $^      if internalarctypesmatchitsecond it  0second replace $^        ofstsetpropertieskerror kerror$^        return$^      $^    $^    if internalarctypesmatchpairs0.second ofst replace $^      ofstsetpropertieskerror kerror$^      return$^    $^  $^  replaceargs argspairs ofst opts$^  applyoperationreplaceargsreplace ofstarctype args$^$^$^registerfstoperationreplace stdarc replaceargs$^registerfstoperationreplace logarc replaceargs$^registerfstoperationreplace log00arc replaceargs$^$^   namespace script$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstscriptfstclass.h$^include fstscriptreweight.h$^include fstscriptscriptimpl.h$^$^namespace fst $^namespace script $^$^void reweightmutablefstclass fst const stdvectorweightclass potential$^              reweighttype reweighttype $^  reweightargs argsfst potential reweighttype$^  applyoperationreweightargsreweight fstarctype args$^$^$^registerfstoperationreweight stdarc reweightargs$^registerfstoperationreweight logarc reweightargs$^registerfstoperationreweight log00arc reweightargs$^$^   namespace script$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstscripttextio.h$^$^include cstring$^include fstream$^include ostream$^include sstream$^include utility$^$^include fstlog.h$^include fstream$^include fstutil.h$^$^namespace fst $^namespace script $^$^ reads vector of weights returns true on success.$^bool readpotentialsconst string weighttype const string filename$^                    stdvectorweightclass potentials $^  stdifstream istrmfilename$^  if istrm.good $^    logerror  readpotentials cant open file   filename$^    return false$^  $^  static constexpr int klinelen  0000$^  char lineklinelen$^  sizet nline  0$^  potentialsclear$^  while istrm.getlineline klinelen.fail $^    nline$^    stdvectorchar  col$^    splitstringline nt  col true$^    if col.empty  col00  0 continue$^    if col.size  0 $^      fsterror  readpotentials bad number of columns $^                  file    filename   line    nline$^      return false$^    $^    const ssizet s  strtoint00col0 filename nline false$^    const weightclass weightweighttype col0$^    while potentialssize  s $^      potentialspushbackweightclasszeroweighttype$^    $^    potentialsback  weight$^  $^  return true$^$^$^ writes vector of weights returns true on success.$^bool writepotentialsconst string filename$^                     const stdvectorweightclass potentials $^  stdofstream ostrm$^  if filename.empty $^    ostrm.openfilename$^    if ostrm.good $^      logerror  writepotentials cant open file   filename$^      return false$^    $^  $^  stdostream strm  ostrm.isopen  ostrm  stdcout$^  strm.precision0$^  for sizet s  0 s  potentials.size s $^    strm  s  t  potentialss  n$^  $^  if strm.fail $^    logerror  writepotentials write failed $^                filename.empty  standard output  filename$^    return false$^  $^  return true$^$^$^   namespace script$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include ostream$^include string$^$^include fstscriptdraw.h$^include fstscriptfstclass.h$^include fstscriptscriptimpl.h$^$^namespace fst $^namespace script $^$^void drawfstconst fstclass fst const symboltable isyms$^             const symboltable osyms const symboltable ssyms bool accep$^             const string title float width float height bool portrait$^             bool vertical float ranksep float nodesep int fontsize$^             int precision const string floatformat bool showweightone$^             stdostream ostrm const string dest $^  fstdrawerargs argsfst isyms osyms ssyms accep title width height$^                     portrait vertical ranksep nodesep fontsize precision$^                     floatformat showweightone ostrm dest$^  applyoperationfstdrawerargsdrawfst fst.arctype args$^$^$^registerfstoperationdrawfst stdarc fstdrawerargs$^registerfstoperationdrawfst logarc fstdrawerargs$^registerfstoperationdrawfst log00arc fstdrawerargs$^$^   namespace script$^   namespace fst$^include fstscriptinfoimpl.h$^$^namespace fst $^$^void printfstinfoimplconst fstinfo fstinfo bool pipe $^  stdostream ostrm  pipe  stdcerr  stdcout$^  const auto old  ostrm.setfstdiosleft$^  ostrm.width00$^  ostrm  fst type  fstinfo.fsttype  stdendl$^  ostrm.width00$^  ostrm  arc type  fstinfo.arctype  stdendl$^  ostrm.width00$^  ostrm  input symbol table  fstinfo.inputsymbols  stdendl$^  ostrm.width00$^  ostrm  output symbol table  fstinfo.outputsymbols  stdendl$^  if fstinfo.longinfo $^    ostrm.setfold$^    return$^  $^  ostrm.width00$^  ostrm   of states  fstinfo.numstates  stdendl$^  ostrm.width00$^  ostrm   of arcs  fstinfo.numarcs  stdendl$^  ostrm.width00$^  ostrm  initial state  fstinfo.start  stdendl$^  ostrm.width00$^  ostrm   of final states  fstinfo.numfinal  stdendl$^  ostrm.width00$^  ostrm   of inputoutput epsilons  fstinfo.numepsilons  stdendl$^  ostrm.width00$^  ostrm   of input epsilons  fstinfo.numinputepsilons  stdendl$^  ostrm.width00$^  ostrm   of output epsilons  fstinfo.numoutputepsilons  stdendl$^  ostrm.width00$^  ostrm  input label multiplicity  fstinfo.inputlabelmultiplicity$^         stdendl$^  ostrm.width00$^  ostrm  output label multiplicity  fstinfo.outputlabelmultiplicity$^         stdendl$^  ostrm.width00$^  string arctype  $^  if fstinfo.arcfiltertype  epsilon$^    arctype  epsilon $^  else if fstinfo.arcfiltertype  iepsilon$^    arctype  inputepsilon $^  else if fstinfo.arcfiltertype  oepsilon$^    arctype  outputepsilon $^  const auto accessiblelabel   of   arctype  accessible states$^  ostrm.width00$^  ostrm  accessiblelabel  fstinfo.numaccessible  stdendl$^  const auto coaccessiblelabel   of   arctype  coaccessible states$^  ostrm.width00$^  ostrm  coaccessiblelabel  fstinfo.numcoaccessible  stdendl$^  const auto connectedlabel   of   arctype  connected states$^  ostrm.width00$^  ostrm  connectedlabel  fstinfo.numconnected  stdendl$^  const auto numcclabel   of   arctype  connected components$^  ostrm.width00$^  ostrm  numcclabel  fstinfo.numcc  stdendl$^  const auto numscclabel   of   arctype  strongly conn components$^  ostrm.width00$^  ostrm  numscclabel  fstinfo.numscc  stdendl$^  ostrm.width00$^  ostrm  input matcher$^         fstinfo.inputmatchtype  matchinput$^                 y$^                 fstinfo.inputmatchtype  matchnone  n  $^         stdendl$^  ostrm.width00$^  ostrm  output matcher$^         fstinfo.outputmatchtype  matchoutput$^                 y$^                 fstinfo.outputmatchtype  matchnone  n  $^         stdendl$^  ostrm.width00$^  ostrm  input lookahead  fstinfo.inputlookahead  y  n$^         stdendl$^  ostrm.width00$^  ostrm  output lookahead  fstinfo.outputlookahead  y  n$^         stdendl$^  uint00 prop  0$^  for auto i  0 i  00 i prop  0 $^    if prop  kbinaryproperties $^      char value  n$^      if fstinfo.properties  prop value  y$^      ostrm.width00$^      ostrm  propertynamesi  value  stdendl$^     else if prop  kpostrinaryproperties $^      char value  $^      if fstinfo.properties  prop$^        value  y$^      else if fstinfo.properties  prop  0$^        value  n$^      ostrm.width00$^      ostrm  propertynamesi  value  stdendl$^    $^  $^  ostrm.setfold$^$^$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstscriptscriptimpl.h$^include fstscriptstateiteratorclass.h$^$^namespace fst $^namespace script $^$^stateiteratorclassstateiteratorclassconst fstclass fst  implnullptr $^  initstateiteratorclassargs argsfst this$^  applyoperationinitstateiteratorclassargsinitstateiteratorclass$^                                               fst.arctype args$^$^$^registerfstoperationinitstateiteratorclass stdarc$^                       initstateiteratorclassargs$^registerfstoperationinitstateiteratorclass logarc$^                       initstateiteratorclassargs$^registerfstoperationinitstateiteratorclass log00arc$^                       initstateiteratorclassargs$^$^   namespace script$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstscriptweightclass.h$^$^namespace fst $^namespace script $^$^registerfstweightstdarcweight$^registerfstweightlogarcweight$^registerfstweightlog00arcweight$^$^weightclassweightclassconst string weighttype const string weightstr $^  weightclassregister reg  weightclassregistergetregister$^  strtoweightimplbaset stw  reggetentryweighttype$^  if stw $^    fsterror  unknown weight type   weighttype$^    impl.reset$^    return$^  $^  impl.resetstwweightstr weightclass 0$^$^$^weightclass weightclasszeroconst string weighttype $^  return weightclassweighttype zero$^$^$^weightclass weightclassoneconst string weighttype $^  return weightclassweighttype one$^$^$^weightclass weightclassnoweightconst string weighttype $^  return weightclassweighttype noweight$^$^$^bool weightclassweighttypesmatchconst weightclass other$^                                   const string opname const $^  if type  other.type $^    fsterror  weights with nonmatching types passed to   opname$^                   type   and   other.type$^    return false$^  $^  return true$^$^$^bool operatorconst weightclass lhs const weightclass rhs $^  const auto lhsimpl  lhs.getimpl$^  const auto rhsimpl  rhs.getimpl$^  if lhsimpl  rhsimpl  lhs.weighttypesmatchrhs operator $^    return false$^  $^  return lhsimpl  rhsimpl$^$^$^bool operatorconst weightclass lhs const weightclass rhs $^  return lhs  rhs$^$^$^weightclass plusconst weightclass lhs const weightclass rhs $^  const auto rhsimpl  rhs.getimpl$^  if lhs.getimpl  rhsimpl  lhs.weighttypesmatchrhs plus $^    return weightclass$^  $^  weightclass resultlhs$^  result.getimplpluseqrhsimpl$^  return result$^$^$^weightclass timesconst weightclass lhs const weightclass rhs $^  const auto rhsimpl  rhs.getimpl$^  if lhs.getimpl  rhsimpl  lhs.weighttypesmatchrhs plus $^    return weightclass$^  $^  weightclass resultlhs$^  result.getimpltimeseqrhsimpl$^  return result$^$^$^weightclass divideconst weightclass lhs const weightclass rhs $^  const auto rhsimpl  rhs.getimpl$^  if lhs.getimpl  rhsimpl  lhs.weighttypesmatchrhs divide $^    return weightclass$^  $^  weightclass resultlhs$^  result.getimpldivideeqrhsimpl$^  return result$^$^$^weightclass powerconst weightclass weight sizet n $^  if weight.getimpl return weightclass$^  weightclass resultweight$^  result.getimplpowereqn$^  return result$^$^$^stdostream operatorstdostream ostrm const weightclass weight $^  weight.implprintostrm$^  return ostrm$^$^$^   namespace script$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstscriptfstclass.h$^include fstscriptmap.h$^include fstscriptscriptimpl.h$^$^namespace fst $^namespace script $^$^fstclass mapconst fstclass ifst maptype maptype float delta double power$^              const weightclass weight $^  if ifst.weighttypesmatchweight map return nullptr$^  mapinnerargs iargsifst maptype delta power weight$^  mapargs argsiargs$^  applyoperationmapargsmap ifst.arctype args$^  return args.retval$^$^$^registerfstoperationmap stdarc mapargs$^registerfstoperationmap logarc mapargs$^registerfstoperationmap log00arc mapargs$^$^   namespace script$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstscriptfstclass.h$^include fstscriptintersect.h$^include fstscriptscriptimpl.h$^$^namespace fst $^namespace script $^$^void intersectconst fstclass ifst0 const fstclass ifst0$^               mutablefstclass ofst const composeoptions opts $^  if internalarctypesmatchifst0 ifst0 intersect $^      internalarctypesmatchofst ifst0 intersect $^    ofstsetpropertieskerror kerror$^    return$^  $^  intersectargs argsifst0 ifst0 ofst opts$^  applyoperationintersectargsintersect ifst0.arctype args$^$^$^registerfstoperationintersect stdarc intersectargs$^registerfstoperationintersect logarc intersectargs$^registerfstoperationintersect log00arc intersectargs$^$^   namespace script$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstscriptfstclass.h$^include fstscriptprune.h$^include fstscriptscriptimpl.h$^$^namespace fst $^namespace script $^$^void pruneconst fstclass ifst mutablefstclass ofst$^           const weightclass weightthreshold$^           int00 statethreshold float delta $^  if internalarctypesmatchifst ofst prune $^      ofstweighttypesmatchweightthreshold prune $^    ofstsetpropertieskerror kerror$^    return$^  $^  pruneargs0 argsifst ofst weightthreshold statethreshold delta$^  applyoperationpruneargs0prune ifst.arctype args$^$^$^void prunemutablefstclass fst const weightclass weightthreshold$^           int00 statethreshold float delta $^  if fstweighttypesmatchweightthreshold prune $^    fstsetpropertieskerror kerror$^    return$^  $^  pruneargs0 argsfst weightthreshold statethreshold delta$^  applyoperationpruneargs0prune fstarctype args$^$^$^registerfstoperationprune stdarc pruneargs0$^registerfstoperationprune logarc pruneargs0$^registerfstoperationprune log00arc pruneargs0$^$^registerfstoperationprune stdarc pruneargs0$^registerfstoperationprune logarc pruneargs0$^registerfstoperationprune log00arc pruneargs0$^$^   namespace script$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstscriptfstclass.h$^include fstscriptepsnormalize.h$^include fstscriptscriptimpl.h$^$^namespace fst $^namespace script $^$^void epsnormalizeconst fstclass ifst mutablefstclass ofst$^                  epsnormalizetype normtype $^  if internalarctypesmatchifst ofst epsnormalize $^    ofstsetpropertieskerror kerror$^    return$^  $^  epsnormalizeargs argsifst ofst normtype$^  applyoperationepsnormalizeargsepsnormalize ifst.arctype args$^$^$^registerfstoperationepsnormalize stdarc epsnormalizeargs$^registerfstoperationepsnormalize logarc epsnormalizeargs$^registerfstoperationepsnormalize log00arc epsnormalizeargs$^$^   namespace script$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstscriptfstclass.h$^include fstscriptscriptimpl.h$^include fstscripttopsort.h$^$^namespace fst $^namespace script $^$^bool topsortmutablefstclass fst $^  topsortargs argsfst$^  applyoperationtopsortargstopsort fstarctype args$^  return args.retval$^$^$^registerfstoperationtopsort stdarc topsortargs$^registerfstoperationtopsort logarc topsortargs$^registerfstoperationtopsort log00arc topsortargs$^$^   namespace script$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstscriptfstclass.h$^include fstscriptrandequivalent.h$^include fstscriptscriptimpl.h$^$^namespace fst $^namespace script $^$^bool randequivalentconst fstclass fst0 const fstclass fst0 int00 npath$^                    float delta timet seed$^                    const randgenoptionsrandarcselection opts $^  if internalarctypesmatchfst0 fst0 randequivalent return false$^  randequivalentinnerargs iargsfst0 fst0 npath delta seed opts$^  randequivalentargs argsiargs$^  applyoperationrandequivalentargsrandequivalent fst0.arctype args$^  return args.retval$^$^$^registerfstoperationrandequivalent stdarc randequivalentargs$^registerfstoperationrandequivalent logarc randequivalentargs$^registerfstoperationrandequivalent log00arc randequivalentargs$^$^   namespace script$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include istream$^include string$^$^include fstscriptcompile.h$^include fstscriptfstclass.h$^include fstscriptscriptimpl.h$^$^namespace fst $^namespace script $^$^void compilefststdistream istrm const string source const string dest$^                const string fsttype const string arctype$^                const symboltable isyms const symboltable osyms$^                const symboltable ssyms bool accep bool ikeep bool okeep$^                bool nkeep bool allownegativelabels $^  stduniqueptrfstclass fst$^      compilefstinternalistrm source fsttype arctype isyms osyms ssyms$^                         accep ikeep okeep nkeep allownegativelabels$^  fstwritedest$^$^$^fstclass compilefstinternalstdistream istrm const string source$^                             const string fsttype const string arctype$^                             const symboltable isyms const symboltable osyms$^                             const symboltable ssyms bool accep bool ikeep$^                             bool okeep bool nkeep$^                             bool allownegativelabels $^  compilefstinnerargs iargsistrm source fsttype isyms osyms ssyms accep$^                            ikeep okeep nkeep allownegativelabels$^  compilefstargs argsiargs$^  applyoperationcompilefstargscompilefstinternal arctype args$^  return args.retval$^$^$^ this registers 0 0 does not require registration.$^registerfstoperationcompilefstinternal stdarc compilefstargs$^registerfstoperationcompilefstinternal logarc compilefstargs$^registerfstoperationcompilefstinternal log00arc compilefstargs$^$^   namespace script$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include ostream$^include string$^$^include fstscriptfstclass.h$^include fstscriptprint.h$^include fstscriptscriptimpl.h$^$^namespace fst $^namespace script $^$^void printfstconst fstclass fst stdostream ostrm const string dest$^              const symboltable isyms const symboltable osyms$^              const symboltable ssyms bool accept bool showweightone$^              const string missingsym $^  const auto sep  flagsfstfieldseparator.substr0 0$^  fstprinterargs argsfst isyms osyms ssyms accept showweightone ostrm$^                      dest sep missingsym$^  applyoperationfstprinterargsprintfst fst.arctype args$^$^$^registerfstoperationprintfst stdarc fstprinterargs$^registerfstoperationprintfst logarc fstprinterargs$^registerfstoperationprintfst log00arc fstprinterargs$^$^   namespace script$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstscriptfstclass.h$^include fstscriptrandgen.h$^include fstscriptscriptimpl.h$^$^namespace fst $^namespace script $^$^void randgenconst fstclass ifst mutablefstclass ofst timet seed$^             const randgenoptionsrandarcselection opts $^  if internalarctypesmatchifst ofst randgen $^    ofstsetpropertieskerror kerror$^    return$^  $^  randgenargs argsifst ofst seed opts$^  applyoperationrandgenargsrandgen ifst.arctype args$^$^$^registerfstoperationrandgen stdarc randgenargs$^registerfstoperationrandgen logarc randgenargs$^registerfstoperationrandgen log00arc randgenargs$^$^   namespace script$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstscriptfstclass.h$^include fstscriptdisambiguate.h$^include fstscriptscriptimpl.h$^$^namespace fst $^namespace script $^$^void disambiguateconst fstclass ifst mutablefstclass ofst$^                  const disambiguateoptions opts $^  if internalarctypesmatchifst ofst disambiguate $^      ofstweighttypesmatchopts.weightthreshold disambiguate $^    ofstsetpropertieskerror kerror$^    return$^  $^  disambiguateargs argsifst ofst opts$^  applyoperationdisambiguateargsdisambiguate ifst.arctype args$^$^$^registerfstoperationdisambiguate stdarc disambiguateargs$^registerfstoperationdisambiguate logarc disambiguateargs$^registerfstoperationdisambiguate log00arc disambiguateargs$^$^   namespace script$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstscriptfstclass.h$^include fstscriptscriptimpl.h$^include fstscriptsynchronize.h$^$^namespace fst $^namespace script $^$^void synchronizeconst fstclass ifst mutablefstclass ofst $^  if internalarctypesmatchifst ofst synchronize $^    ofstsetpropertieskerror kerror$^    return$^  $^  synchronizeargs argsifst ofst$^  applyoperationsynchronizeargssynchronize ifst.arctype args$^$^$^registerfstoperationsynchronize stdarc synchronizeargs$^registerfstoperationsynchronize logarc synchronizeargs$^registerfstoperationsynchronize log00arc synchronizeargs$^$^   namespace script$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstscriptencodemapperclass.h$^include fstscriptscriptimpl.h$^$^namespace fst $^namespace script $^$^encodemapperclassencodemapperclassconst string arctype uint00 flags$^                                      encodetype type  implnullptr $^  initencodemapperclassargs argsflags type this$^  applyoperationinitencodemapperclassargsinitencodemapperclass$^                                              arctype args$^$^$^registerfstoperationinitencodemapperclass stdarc$^                       initencodemapperclassargs$^registerfstoperationinitencodemapperclass logarc$^                       initencodemapperclassargs$^registerfstoperationinitencodemapperclass log00arc$^                       initencodemapperclassargs$^$^   namespace script$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstscriptfstclass.h$^include fstscriptconvert.h$^include fstscriptscriptimpl.h$^$^namespace fst $^namespace script $^$^fstclass convertconst fstclass ifst const string newtype $^  convertinnerargs iargsifst newtype$^  convertargs argsiargs$^  applyoperationconvertargsconvert ifst.arctype args$^  return args.retval$^$^$^registerfstoperationconvert stdarc convertargs$^registerfstoperationconvert logarc convertargs$^registerfstoperationconvert log00arc convertargs$^$^   namespace script$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstscriptfstclass.h$^include fstscriptreverse.h$^include fstscriptscriptimpl.h$^$^namespace fst $^namespace script $^$^void reverseconst fstclass ifst mutablefstclass ofst$^             bool requiresuperinitial $^  if internalarctypesmatchifst ofst reverse $^    ofstsetpropertieskerror kerror$^    return$^  $^  reverseargs argsifst ofst requiresuperinitial$^  applyoperationreverseargsreverse ifst.arctype args$^$^$^registerfstoperationreverse stdarc reverseargs$^registerfstoperationreverse logarc reverseargs$^registerfstoperationreverse log00arc reverseargs$^$^   namespace script$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstscriptfstclass.h$^include fstscriptrelabel.h$^include fstscriptscriptimpl.h$^$^namespace fst $^namespace script $^$^void relabelmutablefstclass ofst$^             const symboltable oldisyms const symboltable relabelisyms$^             const string unknownisymbol bool attachnewisyms$^             const symboltable oldosyms const symboltable relabelosyms$^             const string unknownosymbol bool attachnewosyms $^  relabelargs0 argsofst oldisyms relabelisyms unknownisymbol$^                    attachnewisyms oldosyms relabelosyms$^                    unknownosymbol attachnewosyms$^  applyoperationrelabelargs0relabel ofstarctype args$^$^$^void relabelmutablefstclass ofst const stdvectorlabelpair ipairs$^             const stdvectorlabelpair opairs $^  relabelargs0 argsofst ipairs opairs$^  applyoperationrelabelargs0relabel ofstarctype args$^$^$^registerfstoperationrelabel stdarc relabelargs0$^registerfstoperationrelabel logarc relabelargs0$^registerfstoperationrelabel log00arc relabelargs0$^$^registerfstoperationrelabel stdarc relabelargs0$^registerfstoperationrelabel logarc relabelargs0$^registerfstoperationrelabel log00arc relabelargs0$^$^   namespace script$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstscriptfstclass.h$^include fstscriptarcsort.h$^include fstscriptscriptimpl.h$^$^namespace fst $^namespace script $^$^void arcsortmutablefstclass fst arcsorttype sorttype $^  arcsortargs argsfst sorttype$^  applyoperationarcsortargsarcsort fstarctype args$^$^$^registerfstoperationarcsort stdarc arcsortargs$^registerfstoperationarcsort logarc arcsortargs$^registerfstoperationarcsort log00arc arcsortargs$^$^   namespace script$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstscriptfstclass.h$^include fstscriptscriptimpl.h$^include fstscriptshortestdistance.h$^$^namespace fst $^namespace script $^$^void shortestdistanceconst fstclass fst stdvectorweightclass distance$^                      const shortestdistanceoptions opts $^  shortestdistanceargs0 argsfst distance opts$^  applyoperationshortestdistanceargs0shortestdistance fst.arctype$^                                          args$^$^$^void shortestdistanceconst fstclass ifst stdvectorweightclass distance$^                      bool reverse double delta $^  shortestdistanceargs0 argsifst distance reverse delta$^  applyoperationshortestdistanceargs0shortestdistance ifst.arctype$^                                          args$^$^$^registerfstoperationshortestdistance stdarc shortestdistanceargs0$^registerfstoperationshortestdistance logarc shortestdistanceargs0$^registerfstoperationshortestdistance log00arc shortestdistanceargs0$^$^registerfstoperationshortestdistance stdarc shortestdistanceargs0$^registerfstoperationshortestdistance logarc shortestdistanceargs0$^registerfstoperationshortestdistance log00arc shortestdistanceargs0$^$^   namespace script$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstscriptarciteratorclass.h$^include fstscriptscriptimpl.h$^$^namespace fst $^namespace script $^$^arciteratorclassarciteratorclassconst fstclass fst int00 s$^     implnullptr $^  initarciteratorclassargs argsfst s this$^  applyoperationinitarciteratorclassargsinitarciteratorclass$^                                             fst.arctype args$^$^$^mutablearciteratorclassmutablearciteratorclassmutablefstclass fst$^                                                 int00 s  implnullptr $^  initmutablearciteratorclassargs argsfst s this$^  applyoperationinitmutablearciteratorclassargs$^      initmutablearciteratorclass fstarctype args$^$^$^registerfstoperationinitarciteratorclass stdarc initarciteratorclassargs$^registerfstoperationinitarciteratorclass logarc initarciteratorclassargs$^registerfstoperationinitarciteratorclass log00arc$^                       initarciteratorclassargs$^$^registerfstoperationinitmutablearciteratorclass stdarc$^                       initmutablearciteratorclassargs$^registerfstoperationinitmutablearciteratorclass logarc$^                       initmutablearciteratorclassargs$^registerfstoperationinitmutablearciteratorclass log00arc$^                       initmutablearciteratorclassargs$^$^   namespace script$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstscriptfstclass.h$^include fstscriptisomorphic.h$^include fstscriptscriptimpl.h$^$^namespace fst $^namespace script $^$^bool isomorphicconst fstclass fst0 const fstclass fst0 float delta $^  if internalarctypesmatchfst0 fst0 isomorphic return false$^  isomorphicinnerargs iargsfst0 fst0 delta$^  isomorphicargs argsiargs$^  applyoperationisomorphicargsisomorphic fst0.arctype args$^  return args.retval$^$^$^registerfstoperationisomorphic stdarc isomorphicargs$^registerfstoperationisomorphic logarc isomorphicargs$^registerfstoperationisomorphic log00arc isomorphicargs$^$^   namespace script$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^ these classes are only recommended for use in highlevel scripting$^ applications. most users should use the lowerlevel templated versions$^ corresponding to these classes.$^$^include istream$^$^include fstlog.h$^$^include fstequal.h$^include fstfstdecl.h$^include fstreverse.h$^include fstunion.h$^include fstscriptfstclass.h$^include fstscriptregister.h$^$^namespace fst $^namespace script $^$^ registration.$^$^registerfstclassesstdarc$^registerfstclasseslogarc$^registerfstclasseslog00arc$^$^ helper functions.$^$^namespace $^$^template class f$^f readfstclassstdistream istrm const string fname $^  if istrm $^    logerror  readfstclass cant open file   fname$^    return nullptr$^  $^  fstheader hdr$^  if hdr.readistrm fname return nullptr$^  const fstreadoptions readoptionsfname hdr$^  const auto arctype  hdr.arctype$^  static const auto ioregister  ioregistrationfregistergetregister$^  const auto reader  ioregistergetreaderarctype$^  if reader $^    logerror  readfstclass unknown arc type   arctype$^    return nullptr$^  $^  return readeristrm readoptions$^$^$^template class f$^fstclassimplbase createfstclassconst string arctype $^  static const auto ioregister $^      ioregistrationfregistergetregister$^  auto creator  ioregistergetcreatorarctype$^  if creator $^    fsterror  createfstclass unknown arc type   arctype$^    return nullptr$^  $^  return creator$^$^$^template class f$^fstclassimplbase convertfstclassconst fstclass other $^  static const auto ioregister $^      ioregistrationfregistergetregister$^  auto converter  ioregistergetconverterother.arctype$^  if converter $^    fsterror  convertfstclass unknown arc type   other.arctype$^    return nullptr$^  $^  return converterother$^$^$^   namespace$^$^$^ fstclass methods.$^$^fstclass fstclassreadconst string fname $^  if fname.empty $^    stdifstream istrmfname stdiosbasein  stdiosbasebinary$^    return readfstclassfstclassistrm fname$^   else $^    return readfstclassfstclassstdcin standard input$^  $^$^$^fstclass fstclassreadstdistream istrm const string source $^  return readfstclassfstclassistrm source$^$^$^bool fstclassweighttypesmatchconst weightclass weight$^                                const string opname const $^  if weighttype  weight.type $^    fsterror  fst and weight with nonmatching weight types passed to $^                opname     weighttype   and   weight.type$^    return false$^  $^  return true$^$^$^ mutablefstclass methods.$^$^mutablefstclass mutablefstclassreadconst string fname bool convert $^  if convert  false $^    if fname.empty $^      stdifstream infname stdiosbasein  stdiosbasebinary$^      return readfstclassmutablefstclassin fname$^     else $^      return readfstclassmutablefstclassstdcin standard input$^    $^   else    converts to vectorfstclass if not mutable.$^    stduniqueptrfstclass ifstfstclassreadfname$^    if ifst return nullptr$^    if ifstpropertieskmutable false  kmutable $^      return staticcastmutablefstclass ifst.release$^     else $^      return new vectorfstclassifst.release$^    $^  $^$^$^ vectorfstclass methods.$^$^vectorfstclass vectorfstclassreadconst string fname $^  if fname.empty $^    stdifstream infname stdiosbasein  stdiosbasebinary$^    return readfstclassvectorfstclassin fname$^   else $^    return readfstclassvectorfstclassstdcin standard input$^  $^$^$^vectorfstclassvectorfstclassconst string arctype$^     mutablefstclasscreatefstclassvectorfstclassarctype $^$^$^vectorfstclassvectorfstclassconst fstclass other$^     mutablefstclassconvertfstclassvectorfstclassother $^$^   namespace script$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstscriptfstclass.h$^include fstscriptequivalent.h$^include fstscriptscriptimpl.h$^$^namespace fst $^namespace script $^$^bool equivalentconst fstclass fst0 const fstclass fst0 float delta $^  if internalarctypesmatchfst0 fst0 equivalent return false$^  equivalentinnerargs iargsfst0 fst0 delta$^  equivalentargs argsiargs$^  applyoperationequivalentargsequivalent fst0.arctype args$^  return args.retval$^$^$^registerfstoperationequivalent stdarc equivalentargs$^registerfstoperationequivalent logarc equivalentargs$^registerfstoperationequivalent log00arc equivalentargs$^$^   namespace script$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstscriptfstclass.h$^include fstscriptminimize.h$^include fstscriptscriptimpl.h$^$^namespace fst $^namespace script $^$^void minimizemutablefstclass ofst0 mutablefstclass ofst0 float delta$^              bool allownondet $^  if ofst0  internalarctypesmatchofst0 ofst0 minimize $^    ofst0setpropertieskerror kerror$^    ofst0setpropertieskerror kerror$^    return$^  $^  minimizeargs argsofst0 ofst0 delta allownondet$^  applyoperationminimizeargsminimize ofst0arctype args$^$^$^registerfstoperationminimize stdarc minimizeargs$^registerfstoperationminimize logarc minimizeargs$^registerfstoperationminimize log00arc minimizeargs$^$^   namespace script$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstscriptfstclass.h$^include fstscriptdeterminize.h$^include fstscriptscriptimpl.h$^$^namespace fst $^namespace script $^$^void determinizeconst fstclass ifst mutablefstclass ofst$^                 const determinizeoptions opts $^  if internalarctypesmatchifst ofst determinize $^      ofstweighttypesmatchopts.weightthreshold determinize $^    ofstsetpropertieskerror kerror$^    return$^  $^  determinizeargs argsifst ofst opts$^  applyoperationdeterminizeargsdeterminize ifst.arctype args$^$^$^registerfstoperationdeterminize stdarc determinizeargs$^registerfstoperationdeterminize logarc determinizeargs$^registerfstoperationdeterminize log00arc determinizeargs$^$^   namespace script$^   namespace fst$^include fstscriptgetters.h$^$^namespace fst $^namespace script $^$^bool getarcsorttypeconst string str arcsorttype sorttype $^  if str  ilabel $^    sorttype  ilabelsort$^   else if str  olabel $^    sorttype  olabelsort$^   else $^    return false$^  $^  return true$^$^$^bool getcomposefilterconst string str composefilter composefilter $^  if str  altsequence $^    composefilter  altsequencefilter$^   else if str  auto $^    composefilter  autofilter$^   else if str  match $^    composefilter  matchfilter$^   else if str  null $^    composefilter  nullfilter$^   else if str  sequence $^    composefilter  sequencefilter$^   else if str  trivial $^    composefilter  trivialfilter$^   else $^    return false$^  $^  return true$^$^$^bool getdeterminizetypeconst string str determinizetype dettype $^  if str  functional $^    dettype  determinizefunctional$^   else if str  nonfunctional $^    dettype  determinizenonfunctional$^   else if str  disambiguate $^    dettype  determinizedisambiguate$^   else $^    return false$^  $^  return true$^$^$^bool getmaptypeconst string str maptype maptype $^  if str  arcsum $^    maptype  arcsummapper$^   else if str  arcunique $^    maptype  arcuniquemapper$^   else if str  identity $^    maptype  identitymapper$^   else if str  inputepsilon $^    maptype  inputepsilonmapper$^   else if str  invert $^    maptype  invertmapper$^   else if str  outputepsilon $^    maptype  outputepsilonmapper$^   else if str  plus $^    maptype  plusmapper$^   else if str  power $^    maptype  powermapper$^   else if str  quantize $^    maptype  quantizemapper$^   else if str  rmweight $^    maptype  rmweightmapper$^   else if str  superfinal $^    maptype  superfinalmapper$^   else if str  times $^    maptype  timesmapper$^   else if str  tolog $^    maptype  tologmapper$^   else if str  tolog00 $^    maptype  tolog00mapper$^   else if str  tostd  str  tostandard $^    maptype  tostdmapper$^   else $^    return false$^  $^  return true$^$^$^bool getrandarcselectionconst string str randarcselection ras $^  if str  uniform $^    ras  uniformarcselector$^   else if str  logprob $^    ras  logprobarcselector$^   else if str  fastlogprob $^    ras  fastlogprobarcselector$^   else $^    return false$^  $^  return true$^$^$^bool getqueuetypeconst string str queuetype queuetype $^  if str  auto $^    queuetype  autoqueue$^   else if str  fifo $^    queuetype  fifoqueue$^   else if str  lifo $^    queuetype  lifoqueue$^   else if str  shortest $^    queuetype  shortestfirstqueue$^   else if str  state $^    queuetype  stateorderqueue$^   else if str  top $^    queuetype  toporderqueue$^   else $^    return false$^  $^  return true$^$^$^bool getreplacelabeltypeconst string str bool epsilononreplace$^                         replacelabeltype rlt $^  if epsilononreplace  str  neither $^    rlt  replacelabelneither$^   else if str  input $^    rlt  replacelabelinput$^   else if str  output $^    rlt  replacelabeloutput$^   else if str  both $^    rlt  replacelabelboth$^   else $^    return false$^  $^  return true$^$^$^   namespace script$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstscriptfstclass.h$^include fstscriptscriptimpl.h$^include fstscriptshortestpath.h$^$^namespace fst $^namespace script $^$^void shortestpathconst fstclass ifst mutablefstclass ofst$^                  const shortestpathoptions opts $^  if internalarctypesmatchifst ofst shortestpath $^    ofstsetpropertieskerror kerror$^    return$^  $^  shortestpathargs argsifst ofst opts$^  applyoperationshortestpathargsshortestpath ifst.arctype args$^$^$^registerfstoperationshortestpath stdarc shortestpathargs$^registerfstoperationshortestpath logarc shortestpathargs$^registerfstoperationshortestpath log00arc shortestpathargs$^$^   namespace script$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstscriptfstclass.h$^include fstscriptconnect.h$^include fstscriptscriptimpl.h$^$^namespace fst $^namespace script $^$^void connectmutablefstclass fst $^  applyoperationmutablefstclassconnect fstarctype fst$^$^$^registerfstoperationconnect stdarc mutablefstclass$^registerfstoperationconnect logarc mutablefstclass$^registerfstoperationconnect log00arc mutablefstclass$^$^   namespace script$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstscriptfstclass.h$^include fstscriptconcat.h$^include fstscriptscriptimpl.h$^$^namespace fst $^namespace script $^$^ 0$^void concatmutablefstclass ofst const fstclass ifst $^  if internalarctypesmatchofst ifst concat $^    ofstsetpropertieskerror kerror$^    return$^  $^  concatargs0 argsofst ifst$^  applyoperationconcatargs0concat ofstarctype args$^$^$^ 0$^void concatconst fstclass ifst mutablefstclass ofst $^  if internalarctypesmatchifst ofst concat $^    ofstsetpropertieskerror kerror$^    return$^  $^  concatargs0 argsifst ofst$^  applyoperationconcatargs0concat ofstarctype args$^$^$^registerfstoperationconcat stdarc concatargs0$^registerfstoperationconcat logarc concatargs0$^registerfstoperationconcat log00arc concatargs0$^$^registerfstoperationconcat stdarc concatargs0$^registerfstoperationconcat logarc concatargs0$^registerfstoperationconcat log00arc concatargs0$^$^   namespace script$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstscriptfstclass.h$^include fstscriptcompose.h$^include fstscriptscriptimpl.h$^$^namespace fst $^namespace script $^$^void composeconst fstclass ifst0 const fstclass ifst0$^             mutablefstclass ofst const composeoptions opts $^  if internalarctypesmatchifst0 ifst0 compose $^      internalarctypesmatchofst ifst0 compose $^    ofstsetpropertieskerror kerror$^    return$^  $^  composeargs argsifst0 ifst0 ofst opts$^  applyoperationcomposeargscompose ifst0.arctype args$^$^$^registerfstoperationcompose stdarc composeargs$^registerfstoperationcompose logarc composeargs$^registerfstoperationcompose log00arc composeargs$^$^   namespace script$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstscriptfstclass.h$^include fstscriptdifference.h$^include fstscriptscriptimpl.h$^$^namespace fst $^namespace script $^$^void differenceconst fstclass ifst0 const fstclass ifst0$^                mutablefstclass ofst const composeoptions opts $^  if internalarctypesmatchifst0 ifst0 difference $^      internalarctypesmatchofst ifst0 difference $^    ofstsetpropertieskerror kerror$^    return$^  $^  differenceargs argsifst0 ifst0 ofst opts$^  applyoperationdifferenceargsdifference ifst0.arctype args$^$^$^registerfstoperationdifference stdarc differenceargs$^registerfstoperationdifference logarc differenceargs$^registerfstoperationdifference log00arc differenceargs$^$^   namespace script$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstscriptfstclass.h$^include fstencode.h$^include fstscriptencode.h$^include fstscriptscriptimpl.h$^$^namespace fst $^namespace script $^$^void encodemutablefstclass fst uint00 flags bool reuseencoder$^            const string coderfname $^  encodeargs0 argsfst flags reuseencoder coderfname$^  applyoperationencodeargs0encode fstarctype args$^$^$^void encodemutablefstclass fst encodemapperclass encoder $^  if internalarctypesmatchfst encoder encode $^    fstsetpropertieskerror kerror$^    return$^  $^  encodeargs0 argsfst encoder$^  applyoperationencodeargs0encode fstarctype args$^$^$^registerfstoperationencode stdarc encodeargs0$^registerfstoperationencode logarc encodeargs0$^registerfstoperationencode log00arc encodeargs0$^$^registerfstoperationencode stdarc encodeargs0$^registerfstoperationencode logarc encodeargs0$^registerfstoperationencode log00arc encodeargs0$^$^   namespace script$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstscriptfstclass.h$^include fstscriptequal.h$^include fstscriptscriptimpl.h$^$^namespace fst $^namespace script $^$^bool equalconst fstclass fst0 const fstclass fst0 float delta $^  if internalarctypesmatchfst0 fst0 equal return false$^  equalinnerargs iargsfst0 fst0 delta$^  equalargs argsiargs$^  applyoperationequalargsequal fst0.arctype args$^  return args.retval$^$^$^registerfstoperationequal stdarc equalargs$^registerfstoperationequal logarc equalargs$^registerfstoperationequal log00arc equalargs$^$^   namespace script$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^ generates a random fst according to a classspecific transition model.$^$^include cstdlib$^include cstring$^include ctime$^include memory$^include string$^$^include fstflags.h$^include fstlog.h$^include fstextensionscompressrandmod.h$^include fstfstlib.h$^$^defineint00seed time0 random seed$^defineint00states 00  of states$^defineint00labels 0  of labels$^defineint00classes 0  of probability distributions$^definebooltransducer false output a transducer$^defineboolweights false output a weighted fst$^$^int mainint argc char argv $^  using fststdvectorfst$^  using fststdarc$^  using fsttropicalweight$^  using fstweightgenerate$^$^  string usage  generates a random fst.nn  usage $^  usage  argv0$^  usage  out.fstn$^$^  stdsetnewhandlerfailednewhandler$^  setflagsusage.cstr argc argv true$^  if argc  0 $^    showusage$^    return 0$^  $^$^  string outname  argc  0  strcmpargv0   0  argv0  $^$^  srandflagsseed$^$^  int numstates  rand  flagsstates  0     nolint$^  int numclasses  rand  flagsclasses  0   nolint$^  int numlabels  rand  flagslabels  0     nolint$^$^  stdvectorfst fst$^  using tropicalweightgenerate  weightgeneratetropicalweight$^  stduniqueptrtropicalweightgenerate generateflagsweights $^      new tropicalweightgeneratefalse  nullptr$^  fstrandmodstdarc tropicalweightgenerate randmodnumstates$^      numclasses numlabels flagstransducer generate.get$^  randmod.generatefst$^  fst.writeoutname$^  return 0$^$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^ definitions of scriptable versions of compression operations that is$^ those that can be called with fstclasstype arguments.$^$^ see comments in nlpfstscriptscriptimpl.h for how the registration$^ mechanism allows these to work with various arc types.$^$^include fstextensionscompresscompressscript.h$^$^include fstarcmap.h$^include fstscriptscriptimpl.h$^$^namespace fst $^namespace script $^$^void compressconst fstclass fst const string filename const bool gzip $^  compressargs argsfst filename gzip$^  applyoperationcompressargscompress fst.arctype args$^$^$^void decompressconst string filename mutablefstclass fst const bool gzip $^  decompressargs argsfilename fst gzip$^  applyoperationdecompressargsdecompress fstarctype args$^$^$^ register operations for common arc types.$^$^registerfstoperationcompress stdarc compressargs$^registerfstoperationcompress logarc compressargs$^registerfstoperationcompress log00arc compressargs$^$^registerfstoperationdecompress stdarc decompressargs$^registerfstoperationdecompress logarc decompressargs$^registerfstoperationdecompress log00arc decompressargs$^$^   namespace script$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^ compressesdecompresses an fst.$^$^include cstring$^include memory$^include string$^$^include fstflags.h$^include fstlog.h$^include fstextensionscompresscompressscript.h$^include fstscriptargpacks.h$^include fstscriptfstclass.h$^$^definestringarctype standard output arc type$^definebooldecode false decode$^defineboolgzip false$^            applies gzip compression after lza compression and $^            gzip decompression before lza decompression $^            recommended$^            $^$^int mainint argc char argv $^  namespace s  fstscript$^$^  using sfstclass$^  using svectorfstclass$^$^  string usage  compressesdecompresses an fst.nn  usage $^  usage  argv0$^  usage   in.fst out.fstzn$^  usage   decode in.fstz out.fstn$^$^  stdsetnewhandlerfailednewhandler$^  setflagsusage.cstr argc argv true$^  if argc  0 $^    showusage$^    return 0$^  $^$^  string inname  argc  0  strcmpargv0   0  argv0  $^  string outname  argc  0  argv0  $^$^  if flagsdecode  false $^    stduniqueptrfstclass ifstfstclassreadinname$^    if ifst return 0$^    scompressifst outname flagsgzip$^   else $^    vectorfstclass ofstflagsarctype$^    sdecompressinname ofst flagsgzip$^    ofst.writeoutname$^  $^  return 0$^$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstfst.h$^include fstcompactfst.h$^$^namespace fst $^$^static fstregisterer$^    compactunweightedacceptorfststdarc uint0$^    compactunweightedacceptorfststdarcuint0registerer$^static fstregisterer$^    compactunweightedacceptorfstlogarc uint0$^    compactunweightedacceptorfstlogarcuint0registerer$^$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstfst.h$^include fstcompactfst.h$^$^namespace fst $^$^static fstregisterercompactacceptorfststdarc uint00$^    compactacceptorfststdarcuint00registerer$^static fstregisterercompactacceptorfstlogarc uint00$^    compactacceptorfstlogarcuint00registerer$^$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstfst.h$^include fstcompactfst.h$^$^namespace fst $^$^static fstregisterercompactstringfststdarc uint00$^    compactstringfststdarcuint00registerer$^static fstregisterercompactstringfstlogarc uint00$^    compactstringfstlogarcuint00registerer$^$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstfst.h$^include fstcompactfst.h$^$^namespace fst $^$^static fstregisterercompactacceptorfststdarc uint00$^    compactacceptorfststdarcuint00registerer$^$^static fstregisterercompactacceptorfstlogarc uint00$^    compactacceptorfstlogarcuint00registerer$^$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstfst.h$^include fstcompactfst.h$^$^namespace fst $^$^static fstregisterercompactunweightedfststdarc uint00$^    compactunweightedfststdarcuint00registerer$^static fstregisterercompactunweightedfstlogarc uint00$^    compactunweightedfstlogarcuint00registerer$^$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstfst.h$^include fstcompactfst.h$^$^namespace fst $^$^static fstregisterer$^    compactunweightedacceptorfststdarc uint00$^    compactunweightedacceptorfststdarcuint00registerer$^static fstregisterer$^    compactunweightedacceptorfstlogarc uint00$^    compactunweightedacceptorfstlogarcuint00registerer$^$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstfst.h$^include fstcompactfst.h$^$^namespace fst $^$^static fstregisterer$^    compactweightedstringfststdarc uint00$^    compactweightedstringfststdarcuint00registerer$^static fstregisterer$^    compactweightedstringfstlogarc uint00$^    compactweightedstringfstlogarcuint00registerer$^$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstfst.h$^include fstcompactfst.h$^$^namespace fst $^$^static fstregisterercompactunweightedfststdarc uint00$^    compactunweightedfststdarcuint00registerer$^static fstregisterercompactunweightedfstlogarc uint00$^    compactunweightedfstlogarcuint00registerer$^$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstfst.h$^include fstcompactfst.h$^$^namespace fst $^$^static fstregisterercompactstringfststdarc uint00$^    compactstringfststdarcuint00registerer$^static fstregisterercompactstringfstlogarc uint00$^    compactstringfstlogarcuint00registerer$^$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstfst.h$^include fstcompactfst.h$^$^namespace fst $^$^static fstregisterer$^    compactweightedstringfststdarc uint00$^    compactweightedstringfststdarcuint00registerer$^$^static fstregisterer$^    compactweightedstringfstlogarc uint00$^    compactweightedstringfstlogarcuint00registerer$^$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstfst.h$^include fstcompactfst.h$^$^namespace fst $^$^static fstregisterer$^    compactweightedstringfststdarc uint0$^    compactweightedstringfststdarcuint0registerer$^static fstregisterer$^    compactweightedstringfstlogarc uint0$^    compactweightedstringfstlogarcuint0registerer$^$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstfst.h$^include fstcompactfst.h$^$^namespace fst $^$^static fstregisterercompactacceptorfststdarc uint0$^    compactacceptorfststdarcuint0registerer$^static fstregisterercompactacceptorfstlogarc uint0$^    compactacceptorfstlogarcuint0registerer$^$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstfst.h$^include fstcompactfst.h$^$^namespace fst $^$^static fstregisterercompactstringfststdarc uint0$^    compactstringfststdarcuint0registerer$^static fstregisterercompactstringfstlogarc uint0$^    compactstringfstlogarcuint0registerer$^$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstfst.h$^include fstcompactfst.h$^$^namespace fst $^$^static fstregisterer$^    compactunweightedacceptorfststdarc uint00$^    compactunweightedacceptorfststdarcuint00registerer$^static fstregisterer$^    compactunweightedacceptorfstlogarc uint00$^    compactunweightedacceptorfstlogarcuint00registerer$^$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstfst.h$^include fstcompactfst.h$^$^namespace fst $^$^static fstregisterercompactunweightedfststdarc uint0$^    compactunweightedfststdarcuint0registerer$^static fstregisterercompactunweightedfstlogarc uint0$^    compactunweightedfstlogarcuint0registerer$^$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstfst.h$^include fstmatcherfst.h$^$^namespace fst $^$^static fstregistererstdarclookaheadfst arclookaheadfststdarcregisterer$^static fstregisterermatcherfst$^    constfstlogarc arclookaheadmatchersortedmatcherconstfstlogarc$^    arclookaheadfsttype$^    arclookaheadfstlogarcregisterer$^static fstregisterermatcherfst$^    constfstlog00arc arclookaheadmatchersortedmatcherconstfstlog00arc$^    arclookaheadfsttype$^    arclookaheadfstlog00arcregisterer$^$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstfst.h$^include fstmatcherfst.h$^$^namespace fst $^$^static fstregistererstdolabellookaheadfst$^    olabellookaheadfststdarcregisterer$^static fstregisterermatcherfst$^    constfstlogarc$^    labellookaheadmatchersortedmatcherconstfstlogarc$^                          olabellookaheadflags fastlogaccumulatorlogarc$^    olabellookaheadfsttype labellookaheadrelabelerlogarc$^    olabellookaheadfstlogarcregisterer$^static fstregisterermatcherfst$^    constfstlog00arc$^    labellookaheadmatchersortedmatcherconstfstlog00arc$^                          olabellookaheadflags fastlogaccumulatorlog00arc$^    olabellookaheadfsttype labellookaheadrelabelerlog00arc$^    olabellookaheadfstlog00arcregisterer$^$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstfst.h$^include fstmatcherfst.h$^$^namespace fst $^$^static fstregistererstdilabellookaheadfst$^    ilabellookaheadfststdarcregisterer$^static fstregisterermatcherfst$^    constfstlogarc$^    labellookaheadmatchersortedmatcherconstfstlogarc$^                          ilabellookaheadflags fastlogaccumulatorlogarc$^    ilabellookaheadfsttype labellookaheadrelabelerlogarc$^    ilabellookaheadfstlogarcregisterer$^static fstregisterermatcherfst$^    constfstlog00arc$^    labellookaheadmatchersortedmatcherconstfstlog00arc$^                          ilabellookaheadflags fastlogaccumulatorlog00arc$^    ilabellookaheadfsttype labellookaheadrelabelerlog00arc$^    ilabellookaheadfstlog00arcregisterer$^$^   namespace fst$^ generated by cython 0.00.0 $^$^define pyssizetclean$^include python.h$^ifndef pypythonh$^    error python headers needed to compile c extensions please install development version of python.$^elif pyversionhex  0x00000000  0x00000000  pyversionhex  pyversionhex  0x00000000$^    error cython requires python 0.0 or python 0.0.$^else$^define cythonabi 0000$^define cythonfuturedivision 0$^include stddef.h$^ifndef offsetof$^  define offsetoftype member  sizet  type0  member $^endif$^if definedwin00  definedmswindows$^  ifndef stdcall$^    define stdcall$^  endif$^  ifndef cdecl$^    define cdecl$^  endif$^  ifndef fastcall$^    define fastcall$^  endif$^endif$^ifndef dlimport$^  define dlimportt t$^endif$^ifndef dlexport$^  define dlexportt t$^endif$^define pyxcomma $^ifndef havelonglong$^  if pyversionhex  0x00000000$^    define havelonglong$^  endif$^endif$^ifndef pylonglong$^  define pylonglong longlong$^endif$^ifndef pyhugeval$^  define pyhugeval hugeval$^endif$^ifdef pypyversion$^  define cythoncompilinginpypy 0$^  define cythoncompilinginpyston 0$^  define cythoncompilingincpython 0$^  undef cythonusetypeslots$^  define cythonusetypeslots 0$^  undef cythonusepytypelookup$^  define cythonusepytypelookup 0$^  if pyversionhex  0x00000000$^    undef cythonuseasyncslots$^    define cythonuseasyncslots 0$^  elif definedcythonuseasyncslots$^    define cythonuseasyncslots 0$^  endif$^  undef cythonusepylistinternals$^  define cythonusepylistinternals 0$^  undef cythonuseunicodeinternals$^  define cythonuseunicodeinternals 0$^  undef cythonuseunicodewriter$^  define cythonuseunicodewriter 0$^  undef cythonusepylonginternals$^  define cythonusepylonginternals 0$^  undef cythonavoidborrowedrefs$^  define cythonavoidborrowedrefs 0$^  undef cythonassumesafemacros$^  define cythonassumesafemacros 0$^  undef cythonunpackmethods$^  define cythonunpackmethods 0$^  undef cythonfastthreadstate$^  define cythonfastthreadstate 0$^  undef cythonfastpycall$^  define cythonfastpycall 0$^  undef cythonpep000multiphaseinit$^  define cythonpep000multiphaseinit 0$^  undef cythonusetpfinalize$^  define cythonusetpfinalize 0$^elif definedpystonversion$^  define cythoncompilinginpypy 0$^  define cythoncompilinginpyston 0$^  define cythoncompilingincpython 0$^  ifndef cythonusetypeslots$^    define cythonusetypeslots 0$^  endif$^  undef cythonusepytypelookup$^  define cythonusepytypelookup 0$^  undef cythonuseasyncslots$^  define cythonuseasyncslots 0$^  undef cythonusepylistinternals$^  define cythonusepylistinternals 0$^  ifndef cythonuseunicodeinternals$^    define cythonuseunicodeinternals 0$^  endif$^  undef cythonuseunicodewriter$^  define cythonuseunicodewriter 0$^  undef cythonusepylonginternals$^  define cythonusepylonginternals 0$^  ifndef cythonavoidborrowedrefs$^    define cythonavoidborrowedrefs 0$^  endif$^  ifndef cythonassumesafemacros$^    define cythonassumesafemacros 0$^  endif$^  ifndef cythonunpackmethods$^    define cythonunpackmethods 0$^  endif$^  undef cythonfastthreadstate$^  define cythonfastthreadstate 0$^  undef cythonfastpycall$^  define cythonfastpycall 0$^  undef cythonpep000multiphaseinit$^  define cythonpep000multiphaseinit 0$^  undef cythonusetpfinalize$^  define cythonusetpfinalize 0$^else$^  define cythoncompilinginpypy 0$^  define cythoncompilinginpyston 0$^  define cythoncompilingincpython 0$^  ifndef cythonusetypeslots$^    define cythonusetypeslots 0$^  endif$^  if pyversionhex  0x00000000$^    undef cythonusepytypelookup$^    define cythonusepytypelookup 0$^  elif definedcythonusepytypelookup$^    define cythonusepytypelookup 0$^  endif$^  if pymajorversion  0$^    undef cythonuseasyncslots$^    define cythonuseasyncslots 0$^  elif definedcythonuseasyncslots$^    define cythonuseasyncslots 0$^  endif$^  if pyversionhex  0x00000000$^    undef cythonusepylonginternals$^    define cythonusepylonginternals 0$^  elif definedcythonusepylonginternals$^    define cythonusepylonginternals 0$^  endif$^  ifndef cythonusepylistinternals$^    define cythonusepylistinternals 0$^  endif$^  ifndef cythonuseunicodeinternals$^    define cythonuseunicodeinternals 0$^  endif$^  if pyversionhex  0x000000f0$^    undef cythonuseunicodewriter$^    define cythonuseunicodewriter 0$^  elif definedcythonuseunicodewriter$^    define cythonuseunicodewriter 0$^  endif$^  ifndef cythonavoidborrowedrefs$^    define cythonavoidborrowedrefs 0$^  endif$^  ifndef cythonassumesafemacros$^    define cythonassumesafemacros 0$^  endif$^  ifndef cythonunpackmethods$^    define cythonunpackmethods 0$^  endif$^  ifndef cythonfastthreadstate$^    define cythonfastthreadstate 0$^  endif$^  ifndef cythonfastpycall$^    define cythonfastpycall 0$^  endif$^  ifndef cythonpep000multiphaseinit$^    define cythonpep000multiphaseinit 0  pyversionhex  0x00000000$^  endif$^  ifndef cythonusetpfinalize$^    define cythonusetpfinalize pyversionhex  0x000000a0$^  endif$^endif$^if definedcythonfastpyccall$^define cythonfastpyccall  cythonfastpycall  pyversionhex  0x000000b0$^endif$^if cythonusepylonginternals$^  include longintrepr.h$^  undef shift$^  undef base$^  undef mask$^endif$^ifndef hasattribute$^  define hasattributex 0$^endif$^ifndef hascppattribute$^  define hascppattributex 0$^endif$^ifndef cythonrestrict$^  if definedgnuc$^    define cythonrestrict restrict$^  elif definedmscver  mscver  0000$^    define cythonrestrict restrict$^  elif defined stdcversion  stdcversion  000000l$^    define cythonrestrict restrict$^  else$^    define cythonrestrict$^  endif$^endif$^ifndef cythonunused$^ if definedgnuc$^   if definedcplusplus  gnuc  0  gnuc  0  gnucminor  0$^     define cythonunused attribute unused$^   else$^     define cythonunused$^   endif$^ elif definedicc  definedintelcompiler  definedmscver$^   define cythonunused attribute unused$^ else$^   define cythonunused$^ endif$^endif$^ifndef cythonmaybeunusedvar$^  if definedcplusplus$^     templateclass t void cythonmaybeunusedvar const t   $^  else$^    define cythonmaybeunusedvarx voidx$^  endif$^endif$^ifndef cythonncpunused$^ if cythoncompilingincpython$^  define cythonncpunused$^ else$^  define cythonncpunused cythonunused$^ endif$^endif$^define pyxvoidtononevoidresult voidvoidresult pyincrefpynone pynone$^ifdef mscver$^    ifndef mscstdinth$^        if mscver  0000$^           typedef unsigned char     uint0t$^           typedef unsigned int      uint00t$^        else$^           typedef unsigned int0   uint0t$^           typedef unsigned int00  uint00t$^        endif$^    endif$^else$^   include stdint.h$^endif$^ifndef cythonfallthrough$^  if definedcplusplus  cplusplus  000000l$^    if hascppattributefallthrough$^      define cythonfallthrough fallthrough$^    elif hascppattributeclangfallthrough$^      define cythonfallthrough clangfallthrough$^    elif hascppattributegnufallthrough$^      define cythonfallthrough gnufallthrough$^    endif$^  endif$^  ifndef cythonfallthrough$^    if hasattributefallthrough$^      define cythonfallthrough attributefallthrough$^    else$^      define cythonfallthrough$^    endif$^  endif$^  if definedclang   definedapplebuildversion$^    if applebuildversion  0000000$^      undef  cythonfallthrough$^      define cythonfallthrough$^    endif$^  endif$^endif$^$^ifndef cplusplus$^  error cython files generated with the c option must be compiled with a c compiler.$^endif$^ifndef cythoninline$^  if definedclang$^    define cythoninline inline attribute unused$^  else$^    define cythoninline inline$^  endif$^endif$^templatetypename t$^void pyxcalldestructort x $^    x.t$^$^templatetypename t$^class pyxfakereference $^  public$^    pyxfakereference  ptrnull  $^    pyxfakereferenceconst t ref  ptrconstcasttref  $^    t operator  return ptr $^    t operator  return ptr $^    operator t  return ptr $^    templatetypename u bool operator u other  return ptr  other $^    templatetypename u bool operator u other  return ptr  other $^  private$^    t ptr$^$^$^if cythoncompilinginpypy  pyversionhex  0x00000000  definedpyoptimizeflag$^  define pyoptimizeflag 0$^endif$^define pyxbuildpyssizet n$^define cythonformatssizet z$^if pymajorversion  0$^  define pyxbuiltinmodulename builtin$^  define pyxpycodenewa k l s f code c n v fv cell fn name fline lnos$^          pycodenewak l s f code c n v fv cell fn name fline lnos$^  define pyxdefaultclasstype pyclasstype$^else$^  define pyxbuiltinmodulename builtins$^  define pyxpycodenewa k l s f code c n v fv cell fn name fline lnos$^          pycodenewa k l s f code c n v fv cell fn name fline lnos$^  define pyxdefaultclasstype pytypetype$^endif$^ifndef pytpflagschecktypes$^  define pytpflagschecktypes 0$^endif$^ifndef pytpflagshaveindex$^  define pytpflagshaveindex 0$^endif$^ifndef pytpflagshavenewbuffer$^  define pytpflagshavenewbuffer 0$^endif$^ifndef pytpflagshavefinalize$^  define pytpflagshavefinalize 0$^endif$^if pyversionhex  0x000000a0  definedmethfastcall$^  ifndef methfastcall$^     define methfastcall 0x00$^  endif$^  typedef pyobject pyxpycfunctionfast pyobject self pyobject const args pyssizet nargs$^  typedef pyobject pyxpycfunctionfastwithkeywords pyobject self pyobject const args$^                                                          pyssizet nargs pyobject kwnames$^else$^  define pyxpycfunctionfast pycfunctionfast$^  define pyxpycfunctionfastwithkeywords pycfunctionfastwithkeywords$^endif$^if cythonfastpyccall$^define pyxpyfastcfunctioncheckfunc$^    pycfunctioncheckfunc  methfastcall  pycfunctiongetflagsfunc  methclass  methstatic  methcoexist  methkeywords$^else$^define pyxpyfastcfunctioncheckfunc 0$^endif$^if cythoncompilinginpypy  definedpyobjectmalloc$^  define pyobjectmallocs   pymemmallocs$^  define pyobjectfreep     pymemfreep$^  define pyobjectreallocp  pymemreallocp$^endif$^if cythoncompilinginpyston$^  define pyxpycodehasfreevarsco  pycodehasfreevarsco$^  define pyxpyframesetlinenumberframe lineno pyframesetlinenumberframe lineno$^else$^  define pyxpycodehasfreevarsco  pycodegetnumfreeco  0$^  define pyxpyframesetlinenumberframe lineno  frameflineno  lineno$^endif$^if cythonfastthreadstate  pyversionhex  0x00000000$^  define pyxpythreadstatecurrent pythreadstateget$^elif pyversionhex  0x00000000$^  define pyxpythreadstatecurrent pythreadstateuncheckedget$^elif pyversionhex  0x00000000$^  define pyxpythreadstatecurrent pythreadstateget$^else$^  define pyxpythreadstatecurrent pythreadstatecurrent$^endif$^if pyversionhex  0x000000a0  definedpythreadtsscreate  definedpytssneedsinit$^include pythread.h$^define pytssneedsinit 0$^typedef int pytsst$^static cythoninline int pythreadtsscreatepytsst key $^  key  pythreadcreatekey$^  return 0  pythreadcreatekey reports success always$^$^static cythoninline pytsst  pythreadtssallocvoid $^  pytsst key  pytsst pyobjectmallocsizeofpytsst$^  key  pytssneedsinit$^  return key$^$^static cythoninline void pythreadtssfreepytsst key $^  pyobjectfreekey$^$^static cythoninline int pythreadtssiscreatedpytsst key $^  return key  pytssneedsinit$^$^static cythoninline void pythreadtssdeletepytsst key $^  pythreaddeletekeykey$^  key  pytssneedsinit$^$^static cythoninline int pythreadtsssetpytsst key void value $^  return pythreadsetkeyvaluekey value$^$^static cythoninline void  pythreadtssgetpytsst key $^  return pythreadgetkeyvaluekey$^$^endif  tss thread specific storage api$^if cythoncompilingincpython  definedpydictnewpresized$^define pyxpydictnewpresizedn  n  0  pydictnew  pydictnewpresizedn$^else$^define pyxpydictnewpresizedn  pydictnew$^endif$^if pymajorversion  0  cythonfuturedivision$^  define pyxpynumberdividexy         pynumbertruedividexy$^  define pyxpynumberinplacedividexy  pynumberinplacetruedividexy$^else$^  define pyxpynumberdividexy         pynumberdividexy$^  define pyxpynumberinplacedividexy  pynumberinplacedividexy$^endif$^if cythoncompilingincpython  pyversionhex  0x000000a0  cythonuseunicodeinternals$^define pyxpydictgetitemstrdict name  pydictgetitemknownhashdict name pyasciiobject  namehash$^else$^define pyxpydictgetitemstrdict name  pydictgetitemdict name$^endif$^if pyversionhex  0x00000000  definedpyunicodekind$^  define cythonpep000enabled 0$^  define pyxpyunicodereadyop       likelypyunicodeisreadyop $^                                              0  pyunicodereadypyobject op$^  define pyxpyunicodegetlengthu   pyunicodegetlengthu$^  define pyxpyunicodereadcharu i pyunicodereadcharu i$^  define pyxpyunicodemaxcharvalueu   pyunicodemaxcharvalueu$^  define pyxpyunicodekindu         pyunicodekindu$^  define pyxpyunicodedatau         pyunicodedatau$^  define pyxpyunicodereadk d i   pyunicodereadk d i$^  define pyxpyunicodewritek d i ch  pyunicodewritek d i ch$^  define pyxpyunicodeistrueu      0  likelypyunicodeisreadyu  pyunicodegetlengthu  pyunicodegetsizeu$^else$^  define cythonpep000enabled 0$^  define pyunicode0bytekind  0$^  define pyunicode0bytekind  0$^  define pyunicode0bytekind  0$^  define pyxpyunicodereadyop       0$^  define pyxpyunicodegetlengthu   pyunicodegetsizeu$^  define pyxpyunicodereadcharu i pyucs0pyunicodeasunicodeui$^  define pyxpyunicodemaxcharvalueu   sizeofpyunicode  0  00000  0000000$^  define pyxpyunicodekindu         sizeofpyunicode$^  define pyxpyunicodedatau         voidpyunicodeasunicodeu$^  define pyxpyunicodereadk d i   voidk pyucs0pyunicodedi$^  define pyxpyunicodewritek d i ch  voidk pyunicodedi  ch$^  define pyxpyunicodeistrueu      0  pyunicodegetsizeu$^endif$^if cythoncompilinginpypy$^  define pyxpyunicodeconcata b      pynumberadda b$^  define pyxpyunicodeconcatsafea b  pynumberadda b$^else$^  define pyxpyunicodeconcata b      pyunicodeconcata b$^  define pyxpyunicodeconcatsafea b  unlikelya  pynone  unlikelyb  pynone $^      pynumberadda b  pyxpyunicodeconcata b$^endif$^if cythoncompilinginpypy  definedpyunicodecontains$^  define pyunicodecontainsu s  pysequencecontainsu s$^endif$^if cythoncompilinginpypy  definedpybytearraycheck$^  define pybytearraycheckobj  pyobjecttypecheckobj pybytearraytype$^endif$^if cythoncompilinginpypy  definedpyobjectformat$^  define pyobjectformatobj fmt  pyobjectcallmethodobj format o fmt$^endif$^define pyxpystringformatsafea b   unlikelya  pynone  pynumberremaindera b  pyxpystringformata b$^define pyxpyunicodeformatsafea b  unlikelya  pynone  pynumberremaindera b  pyunicodeformata b$^if pymajorversion  0$^  define pyxpystringformata b  pyunicodeformata b$^else$^  define pyxpystringformata b  pystringformata b$^endif$^if pymajorversion  0  definedpyobjectascii$^  define pyobjectasciio            pyobjectrepro$^endif$^if pymajorversion  0$^  define pybasestringtype            pyunicodetype$^  define pystringobject               pyunicodeobject$^  define pystringtype                pyunicodetype$^  define pystringcheck               pyunicodecheck$^  define pystringcheckexact          pyunicodecheckexact$^  define pyobjectunicode             pyobjectstr$^endif$^if pymajorversion  0$^  define pyxpybasestringcheckobj pyunicodecheckobj$^  define pyxpybasestringcheckexactobj pyunicodecheckexactobj$^else$^  define pyxpybasestringcheckobj pystringcheckobj  pyunicodecheckobj$^  define pyxpybasestringcheckexactobj pystringcheckexactobj  pyunicodecheckexactobj$^endif$^ifndef pysetcheckexact$^  define pysetcheckexactobj        pytypeobj  pysettype$^endif$^if cythonassumesafemacros$^  define pyxpysequencesizeseq  pysizeseq$^else$^  define pyxpysequencesizeseq  pysequencesizeseq$^endif$^if pymajorversion  0$^  define pyintobject                  pylongobject$^  define pyinttype                   pylongtype$^  define pyintcheckop              pylongcheckop$^  define pyintcheckexactop         pylongcheckexactop$^  define pyintfromstring             pylongfromstring$^  define pyintfromunicode            pylongfromunicode$^  define pyintfromlong               pylongfromlong$^  define pyintfromsizet             pylongfromsizet$^  define pyintfromssizet            pylongfromssizet$^  define pyintaslong                 pylongaslong$^  define pyintaslong                pylongaslong$^  define pyintasssizet              pylongasssizet$^  define pyintasunsignedlongmask     pylongasunsignedlongmask$^  define pyintasunsignedlonglongmask pylongasunsignedlonglongmask$^  define pynumberint                 pynumberlong$^endif$^if pymajorversion  0$^  define pyboolobject                 pylongobject$^endif$^if pymajorversion  0  cythoncompilinginpypy$^  ifndef pyunicodeinternfromstring$^    define pyunicodeinternfromstrings pyunicodefromstrings$^  endif$^endif$^if pyversionhex  0x000000a0$^  typedef long pyhasht$^  define pyxpyintfromhasht pyintfromlong$^  define pyxpyintashasht   pyintaslong$^else$^  define pyxpyintfromhasht pyintfromssizet$^  define pyxpyintashasht   pyintasssizet$^endif$^if pymajorversion  0$^  define pyxpymethodnewfunc self klass self  pymethodnewfunc self  pyincreffunc func$^else$^  define pyxpymethodnewfunc self klass pymethodnewfunc self klass$^endif$^if cythonuseasyncslots$^  if pyversionhex  0x000000b0$^    define pyxpyasyncmethodsstruct pyasyncmethods$^    define pyxpytypeasasyncobj pytypeobjtpasasync$^  else$^    define pyxpytypeasasyncobj pyxpyasyncmethodsstruct pytypeobjtpreserved$^  endif$^else$^  define pyxpytypeasasyncobj null$^endif$^ifndef pyxpyasyncmethodsstruct$^    typedef struct $^        unaryfunc amawait$^        unaryfunc amaiter$^        unaryfunc amanext$^     pyxpyasyncmethodsstruct$^endif$^$^if definedwin00  definedmswindows$^  define usemathdefines$^endif$^include math.h$^ifdef nan$^define pyxnan float nan$^else$^static cythoninline float pyxnan $^  float value$^  memsetvalue 0xff sizeofvalue$^  return value$^$^endif$^if definedcygwin  definedldbleqdbl$^define pyxtruncl trunc$^else$^define pyxtruncl truncl$^endif$^$^$^define pyxerrfindex lineno lnerror $^ $^  pyxfilename  pyxffindex pyxlineno  lineno pyxclineno  line goto lnerror $^$^$^ifndef pyxexternc$^  ifdef cplusplus$^    define pyxexternc extern c$^  else$^    define pyxexternc extern$^  endif$^endif$^$^define pyxhavepywrapfst$^define pyxhaveapipywrapfst$^ early includes $^include stddef.h$^include time.h$^include ios$^include new$^include stdexcept$^include typeinfo$^include memory$^include utility$^include vector$^include string.h$^include string$^include stdint.h$^include iostream$^include fstream$^include sstream$^include fstutil.h$^include fstfstlib.h$^include fstscriptfstscript.h$^include fstscriptgetters.h$^include fstextensionsfarfar.h$^include fstextensionsfargetters.h$^include fstextensionsfarfarclass.h$^include systypes.h$^include unistd.h$^ifdef openmp$^include omp.h$^endif  openmp $^$^if definedpyrexwithoutassertions  definedcythonwithoutassertions$^define cythonwithoutassertions$^endif$^$^typedef struct pyobject p const char s const pyssizet n const char encoding$^                const char isunicode const char isstr const char intern  pyxstringtabentry$^$^define pyxdefaultstringencodingisascii 0$^define pyxdefaultstringencodingisdefault 0$^define pyxdefaultstringencoding $^define pyxpyobjectfromstring pyxpybytesfromstring$^define pyxpyobjectfromstringandsize pyxpybytesfromstringandsize$^define pyxucharcastc unsigned charc$^define pyxlongcastx longx$^define pyxfitspyssizetv type issigned  $^    sizeoftype  sizeofpyssizet  $^    sizeoftype  sizeofpyssizet $^          likelyv  typepyssizetmax $^                 v  typepyssizetmax  $^          issigned  likelyv  typepyssizetmin $^                                v  typepyssizetmin  $^    sizeoftype  sizeofpyssizet $^          issigned  likelyv  typepyssizetmax $^                               v  typepyssizetmax  $^if defined cplusplus  cplusplus  000000l$^    include cstdlib$^    define pyxsstabsvalue stdabsvalue$^elif sizeofint  sizeofsizet$^    define pyxsstabsvalue absvalue$^elif sizeoflong  sizeofsizet$^    define pyxsstabsvalue labsvalue$^elif defined mscver$^    define pyxsstabsvalue pyssizetabs00value$^elif defined stdcversion  stdcversion  000000l$^    define pyxsstabsvalue llabsvalue$^elif defined gnuc$^    define pyxsstabsvalue builtinllabsvalue$^else$^    define pyxsstabsvalue value0  value  value$^endif$^static cythoninline const char pyxpyobjectasstringpyobject$^static cythoninline const char pyxpyobjectasstringandsizepyobject pyssizet length$^define pyxpybytearrayfromstrings pybytearrayfromstringandsizeconst chars strlenconst chars$^define pyxpybytearrayfromstringandsizes l pybytearrayfromstringandsizeconst chars l$^define pyxpybytesfromstring        pybytesfromstring$^define pyxpybytesfromstringandsize pybytesfromstringandsize$^static cythoninline pyobject pyxpyunicodefromstringconst char$^if pymajorversion  0$^    define pyxpystrfromstring        pyxpybytesfromstring$^    define pyxpystrfromstringandsize pyxpybytesfromstringandsize$^else$^    define pyxpystrfromstring        pyxpyunicodefromstring$^    define pyxpystrfromstringandsize pyxpyunicodefromstringandsize$^endif$^define pyxpybytesaswritablestrings     char pybytesasstrings$^define pyxpybytesaswritablesstrings    signed char pybytesasstrings$^define pyxpybytesaswritableustrings    unsigned char pybytesasstrings$^define pyxpybytesasstrings     const char pybytesasstrings$^define pyxpybytesassstrings    const signed char pybytesasstrings$^define pyxpybytesasustrings    const unsigned char pybytesasstrings$^define pyxpyobjectaswritablestrings    char pyxpyobjectasstrings$^define pyxpyobjectaswritablesstrings    signed char pyxpyobjectasstrings$^define pyxpyobjectaswritableustrings    unsigned char pyxpyobjectasstrings$^define pyxpyobjectassstrings    const signed char pyxpyobjectasstrings$^define pyxpyobjectasustrings    const unsigned char pyxpyobjectasstrings$^define pyxpyobjectfromcstrings  pyxpyobjectfromstringconst chars$^define pyxpybytesfromcstrings   pyxpybytesfromstringconst chars$^define pyxpybytearrayfromcstrings   pyxpybytearrayfromstringconst chars$^define pyxpystrfromcstrings     pyxpystrfromstringconst chars$^define pyxpyunicodefromcstrings pyxpyunicodefromstringconst chars$^static cythoninline sizet pyxpyunicodestrlenconst pyunicode u $^    const pyunicode uend  u$^    while uend $^    return sizetuend  u  0$^$^define pyxpyunicodefromunicodeu       pyunicodefromunicodeu pyxpyunicodestrlenu$^define pyxpyunicodefromunicodeandlength pyunicodefromunicode$^define pyxpyunicodeasunicode            pyunicodeasunicode$^define pyxnewrefobj pyincrefobj obj$^define pyxownedpynoneb pyxnewrefpynone$^static cythoninline pyobject  pyxpyboolfromlonglong b$^static cythoninline int pyxpyobjectistruepyobject$^static cythoninline pyobject pyxpynumberintorlongpyobject x$^define pyxpysequencetupleobj$^    likelypytuplecheckexactobj  pyxnewrefobj  pysequencetupleobj$^static cythoninline pyssizet pyxpyindexasssizetpyobject$^static cythoninline pyobject  pyxpyintfromsizetsizet$^if cythonassumesafemacros$^define pyxpyfloatasdoublex pyfloatcheckexactx  pyfloatasdoublex  pyfloatasdoublex$^else$^define pyxpyfloatasdoublex pyfloatasdoublex$^endif$^define pyxpyfloatasfloatx float pyxpyfloatasdoublex$^if pymajorversion  0$^define pyxpynumberintx pylongcheckexactx  pyxnewrefx  pynumberlongx$^else$^define pyxpynumberintx pyintcheckexactx  pyxnewrefx  pynumberintx$^endif$^define pyxpynumberfloatx pyfloatcheckexactx  pyxnewrefx  pynumberfloatx$^if pymajorversion  0  pyxdefaultstringencodingisascii$^static int pyxsysgetdefaultencodingnotascii$^static int pyxinitsysgetdefaultencodingparamsvoid $^    pyobject sys$^    pyobject defaultencoding  null$^    pyobject asciicharsu  null$^    pyobject asciicharsb  null$^    const char defaultencodingc$^    sys  pyimportimportmodulesys$^    if sys goto bad$^    defaultencoding  pyobjectcallmethodsys char getdefaultencoding null$^    pydecrefsys$^    if defaultencoding goto bad$^    defaultencodingc  pybytesasstringdefaultencoding$^    if defaultencodingc goto bad$^    if strcmpdefaultencodingc ascii  0 $^        pyxsysgetdefaultencodingnotascii  0$^     else $^        char asciichars000$^        int c$^        for c  0 c  000 c $^            asciicharsc  c$^        $^        pyxsysgetdefaultencodingnotascii  0$^        asciicharsu  pyunicodedecodeasciiasciichars 000 null$^        if asciicharsu goto bad$^        asciicharsb  pyunicodeasencodedstringasciicharsu defaultencodingc null$^        if asciicharsb  pybytescheckasciicharsb  memcmpasciichars pybytesasstringasciicharsb 000  0 $^            pyerrformat$^                pyexcvalueerror$^                this module compiled with cstringencodingascii but default encoding .000s is not a superset of ascii.$^                defaultencodingc$^            goto bad$^        $^        pydecrefasciicharsu$^        pydecrefasciicharsb$^    $^    pydecrefdefaultencoding$^    return 0$^bad$^    pyxdecrefdefaultencoding$^    pyxdecrefasciicharsu$^    pyxdecrefasciicharsb$^    return 0$^$^endif$^if pyxdefaultstringencodingisdefault  pymajorversion  0$^define pyxpyunicodefromstringandsizecstr size pyunicodedecodeutf0cstr size null$^else$^define pyxpyunicodefromstringandsizecstr size pyunicodedecodecstr size pyxdefaultstringencoding null$^if pyxdefaultstringencodingisdefault$^static char pyxdefaultstringencoding$^static int pyxinitsysgetdefaultencodingparamsvoid $^    pyobject sys$^    pyobject defaultencoding  null$^    char defaultencodingc$^    sys  pyimportimportmodulesys$^    if sys goto bad$^    defaultencoding  pyobjectcallmethodsys char const char getdefaultencoding null$^    pydecrefsys$^    if defaultencoding goto bad$^    defaultencodingc  pybytesasstringdefaultencoding$^    if defaultencodingc goto bad$^    pyxdefaultstringencoding  char mallocstrlendefaultencodingc$^    if pyxdefaultstringencoding goto bad$^    strcpypyxdefaultstringencoding defaultencodingc$^    pydecrefdefaultencoding$^    return 0$^bad$^    pyxdecrefdefaultencoding$^    return 0$^$^endif$^endif$^$^$^ test for gcc  0.00 $^if definedgnuc      gnuc  0  gnuc  0  gnucminor  00$^  define likelyx   builtinexpectx 0$^  define unlikelyx builtinexpectx 0$^else  gnuc or gcc  0.00 $^  define likelyx   x$^  define unlikelyx x$^endif  gnuc $^static cythoninline void pyxpretendtoinitializevoid ptr  voidptr $^$^static pyobject pyxm  null$^static pyobject pyxd$^static pyobject pyxb$^static pyobject pyxcythonruntime  null$^static pyobject pyxemptytuple$^static pyobject pyxemptybytes$^static pyobject pyxemptyunicode$^static int pyxlineno$^static int pyxclineno  0$^static const char  pyxcfilenm file$^static const char pyxfilename$^$^$^static const char pyxf  $^  pywrapfst.pyx$^  stringsource$^$^$^ basictypes.pxd00$^  $^  $^  ctypedef int0t int0              $^  ctypedef int00t int00$^  ctypedef int00t int00$^ $^typedef int0t pyxt00basictypesint0$^$^ basictypes.pxd00$^  $^  ctypedef int0t int0$^  ctypedef int00t int00              $^  ctypedef int00t int00$^  ctypedef int00t int00$^ $^typedef int00t pyxt00basictypesint00$^$^ basictypes.pxd00$^  ctypedef int0t int0$^  ctypedef int00t int00$^  ctypedef int00t int00              $^  ctypedef int00t int00$^  ctypedef uint0t uint0$^ $^typedef int00t pyxt00basictypesint00$^$^ basictypes.pxd00$^  ctypedef int00t int00$^  ctypedef int00t int00$^  ctypedef int00t int00              $^  ctypedef uint0t uint0$^  ctypedef uint00t uint00$^ $^typedef int00t pyxt00basictypesint00$^$^ basictypes.pxd00$^  ctypedef int00t int00$^  ctypedef int00t int00$^  ctypedef uint0t uint0              $^  ctypedef uint00t uint00$^  ctypedef uint00t uint00$^ $^typedef uint0t pyxt00basictypesuint0$^$^ basictypes.pxd00$^  ctypedef int00t int00$^  ctypedef uint0t uint0$^  ctypedef uint00t uint00              $^  ctypedef uint00t uint00$^  ctypedef uint00t uint00$^ $^typedef uint00t pyxt00basictypesuint00$^$^ basictypes.pxd00$^  ctypedef uint0t uint0$^  ctypedef uint00t uint00$^  ctypedef uint00t uint00              $^  ctypedef uint00t uint00$^ $^typedef uint00t pyxt00basictypesuint00$^$^ basictypes.pxd00$^  ctypedef uint00t uint00$^  ctypedef uint00t uint00$^  ctypedef uint00t uint00              $^ $^typedef uint00t pyxt00basictypesuint00$^$^ type declarations $^struct pyxobj0pywrapfstweight$^struct pyxobj0pywrapfstsymboltable$^struct pyxobj0pywrapfstencodemappersymboltable$^struct pyxobj0pywrapfstfstsymboltable$^struct pyxobj0pywrapfstmutablesymboltable$^struct pyxobj0pywrapfstmutablefstsymboltable$^struct pyxobj0pywrapfstsymboltable$^struct pyxobj0pywrapfstsymboltableiterator$^struct pyxobj0pywrapfstencodemapper$^struct pyxobj0pywrapfstfst$^struct pyxobj0pywrapfstmutablefst$^struct pyxobj0pywrapfstarc$^struct pyxobj0pywrapfstarciterator$^struct pyxobj0pywrapfstmutablearciterator$^struct pyxobj0pywrapfststateiterator$^struct pyxobj0pywrapfstcompiler$^struct pyxobj0pywrapfstfarreader$^struct pyxobj0pywrapfstfarwriter$^$^ fst.pxd000$^  $^  $^  ctypedef pairint00 const fstclass  labelfstclasspair              $^  $^  ctypedef pairint00 int00 labelpair$^ $^typedef stdpairpyxt00basictypesint00fstscriptfstclass const   pyxt0fstlabelfstclasspair$^$^ fst.pxd000$^  ctypedef pairint00 const fstclass  labelfstclasspair$^  $^  ctypedef pairint00 int00 labelpair              $^  $^  $^ $^typedef stdpairpyxt00basictypesint00pyxt00basictypesint00  pyxt0fstlabelpair$^struct pyxoptargs0pywrapfsttostring$^struct pyxoptargs0pywrapfstweighttostring$^struct pyxoptargs0pywrapfst00mutablesymboltableaddsymbol$^struct pyxoptargs0pywrapfst0fstdraw$^struct pyxoptargs0pywrapfst0fsttext$^struct pyxoptargs0pywrapfst00mutablefstarcsort$^struct pyxoptargs0pywrapfst00mutablefstclosure$^struct pyxoptargs0pywrapfst00mutablefstdeletearcs$^struct pyxoptargs0pywrapfst00mutablefstdeletestates$^struct pyxoptargs0pywrapfst00mutablefstminimize$^struct pyxoptargs0pywrapfst00mutablefstproject$^struct pyxoptargs0pywrapfst00mutablefstprune$^struct pyxoptargs0pywrapfst00mutablefstpush$^struct pyxoptargs0pywrapfst00mutablefstrelabelpairs$^struct pyxoptargs0pywrapfst00mutablefstrelabeltables$^struct pyxoptargs0pywrapfst00mutablefstreweight$^struct pyxoptargs0pywrapfst00mutablefstrmepsilon$^struct pyxoptargs0pywrapfst00mutablefstsetfinal$^struct pyxoptargs0pywrapfstcreatefst$^struct pyxoptargs0pywrapfstmap$^struct pyxoptargs0pywrapfstarcmap$^struct pyxoptargs0pywrapfstcompose$^struct pyxoptargs0pywrapfstconvert$^struct pyxoptargs0pywrapfstdeterminize$^struct pyxoptargs0pywrapfstdifference$^struct pyxoptargs0pywrapfstdisambiguate$^struct pyxoptargs0pywrapfstepsnormalize$^struct pyxoptargs0pywrapfstequal$^struct pyxoptargs0pywrapfstequivalent$^struct pyxoptargs0pywrapfstintersect$^struct pyxoptargs0pywrapfstisomorphic$^struct pyxoptargs0pywrapfstprune$^struct pyxoptargs0pywrapfstpush$^struct pyxoptargs0pywrapfstrandequivalent$^struct pyxoptargs0pywrapfstrandgen$^struct pyxoptargs0pywrapfstreplace$^struct pyxoptargs0pywrapfstreverse$^struct pyxoptargs0pywrapfstshortestdistance$^struct pyxoptargs0pywrapfstshortestpath$^$^ pywrapfst.pxd00$^  $^  $^  cdef string tostringdata encoding except               $^  $^  cdef string weighttostringdata encoding except $^ $^struct pyxoptargs0pywrapfsttostring $^  int pyxn$^  pyobject encoding$^$^$^ pywrapfst.pxd00$^  cdef string tostringdata encoding except $^  $^  cdef string weighttostringdata encoding except               $^  $^  cdef fst.composefilter getcomposefilter$^ $^struct pyxoptargs0pywrapfstweighttostring $^  int pyxn$^  pyobject encoding$^$^$^ pywrapfst.pxd00$^   symboltable.$^  $^  ctypedef fst.symboltable  symboltableptr              $^  $^  $^ $^typedef fstsymboltable pyxt0pywrapfstsymboltableptr$^$^ pywrapfst.pxd000$^  cdef class mutablesymboltablesymboltable$^  $^    cpdef int00 addsymbolself symbol int00 key              $^  $^    cpdef void addtableself symboltable syms$^ $^struct pyxoptargs0pywrapfst00mutablesymboltableaddsymbol $^  int pyxn$^  pyxt00basictypesint00 key$^$^$^ pywrapfst.pxd000$^  $^  $^  ctypedef fst.fstclass  fstclassptr              $^  ctypedef fst.mutablefstclass  mutablefstclassptr$^  ctypedef fst.vectorfstclass  vectorfstclassptr$^ $^typedef fstscriptfstclass pyxt0pywrapfstfstclassptr$^$^ pywrapfst.pxd000$^  $^  ctypedef fst.fstclass  fstclassptr$^  ctypedef fst.mutablefstclass  mutablefstclassptr              $^  ctypedef fst.vectorfstclass  vectorfstclassptr$^  $^ $^typedef fstscriptmutablefstclass pyxt0pywrapfstmutablefstclassptr$^$^ pywrapfst.pxd000$^  ctypedef fst.fstclass  fstclassptr$^  ctypedef fst.mutablefstclass  mutablefstclassptr$^  ctypedef fst.vectorfstclass  vectorfstclassptr              $^  $^  $^ $^typedef fstscriptvectorfstclass pyxt0pywrapfstvectorfstclassptr$^$^ pywrapfst.pxd000$^    cpdef fst copyself$^  $^    cpdef void drawself filename symboltable isymbols              $^                    symboltable osymbols symboltable ssymbols$^                    bool acceptor title double width$^ $^struct pyxoptargs0pywrapfst0fstdraw $^  int pyxn$^  struct pyxobj0pywrapfstsymboltable isymbols$^  struct pyxobj0pywrapfstsymboltable osymbols$^  struct pyxobj0pywrapfstsymboltable ssymbols$^  bool acceptor$^  pyobject title$^  double width$^  double height$^  bool portrait$^  bool vertical$^  double ranksep$^  double nodesep$^  pyxt00basictypesint00 fontsize$^  pyxt00basictypesint00 precision$^  pyobject floatformat$^  bool showweightone$^$^$^ pywrapfst.pxd000$^    cpdef stateiterator statesself$^  $^    cpdef string textself symboltable isymbols symboltable osymbols              $^                      symboltable ssymbols bool acceptor$^                      bool showweightone missingsym$^ $^struct pyxoptargs0pywrapfst0fsttext $^  int pyxn$^  struct pyxobj0pywrapfstsymboltable isymbols$^  struct pyxobj0pywrapfstsymboltable osymbols$^  struct pyxobj0pywrapfstsymboltable ssymbols$^  bool acceptor$^  bool showweightone$^  pyobject missingsym$^$^$^ pywrapfst.pxd000$^    cpdef int00 addstateself except $^  $^    cdef void arcsortself sorttype except               $^  $^    cdef void closureself bool closureplus except $^ $^struct pyxoptargs0pywrapfst00mutablefstarcsort $^  int pyxn$^  pyobject sorttype$^$^$^ pywrapfst.pxd000$^    cdef void arcsortself sorttype except $^  $^    cdef void closureself bool closureplus except               $^  $^    cdef void concatself fst ifst except $^ $^struct pyxoptargs0pywrapfst00mutablefstclosure $^  int pyxn$^  bool closureplus$^$^$^ pywrapfst.pxd000$^    cdef void decodeself encodemapper except $^  $^    cdef void deletearcsself int00 state sizet n except               $^  $^    cdef void deletestatesself states except $^ $^struct pyxoptargs0pywrapfst00mutablefstdeletearcs $^  int pyxn$^  sizet n$^$^$^ pywrapfst.pxd000$^    cdef void deletearcsself int00 state sizet n except $^  $^    cdef void deletestatesself states except               $^  $^    cdef void encodeself encodemapper except $^ $^struct pyxoptargs0pywrapfst00mutablefstdeletestates $^  int pyxn$^  pyobject states$^$^$^ pywrapfst.pxd000$^    cdef void invertself except $^  $^    cdef void minimizeself float delta bool allownondet except               $^  $^    cpdef mutablearciterator mutablearcsself int00 state$^ $^struct pyxoptargs0pywrapfst00mutablefstminimize $^  int pyxn$^  float delta$^  bool allownondet$^$^$^ pywrapfst.pxd000$^    cpdef int00 numstatesself$^  $^    cdef void projectself bool projectoutput except               $^  $^    cdef void pruneself float delta int00 nstate weight except $^ $^struct pyxoptargs0pywrapfst00mutablefstproject $^  int pyxn$^  bool projectoutput$^$^$^ pywrapfst.pxd000$^    cdef void projectself bool projectoutput except $^  $^    cdef void pruneself float delta int00 nstate weight except               $^  $^    cdef void pushself float delta bool removetotalweight$^ $^struct pyxoptargs0pywrapfst00mutablefstprune $^  int pyxn$^  float delta$^  pyxt00basictypesint00 nstate$^  pyobject weight$^$^$^ pywrapfst.pxd000$^    cdef void pruneself float delta int00 nstate weight except $^  $^    cdef void pushself float delta bool removetotalweight              $^                    bool tofinal except $^  $^ $^struct pyxoptargs0pywrapfst00mutablefstpush $^  int pyxn$^  float delta$^  bool removetotalweight$^  bool tofinal$^$^$^ pywrapfst.pxd000$^                    bool tofinal except $^  $^    cdef void relabelpairsself ipairs opairs except               $^  $^    cdef void relabeltablesself symboltable oldisymbols$^ $^struct pyxoptargs0pywrapfst00mutablefstrelabelpairs $^  int pyxn$^  pyobject ipairs$^  pyobject opairs$^$^$^ pywrapfst.pxd000$^    cdef void relabelpairsself ipairs opairs except $^  $^    cdef void relabeltablesself symboltable oldisymbols              $^        symboltable newisymbols unknownisymbol$^        bool attachnewisymbols$^ $^struct pyxoptargs0pywrapfst00mutablefstrelabeltables $^  int pyxn$^  struct pyxobj0pywrapfstsymboltable oldisymbols$^  struct pyxobj0pywrapfstsymboltable newisymbols$^  pyobject unknownisymbol$^  bool attachnewisymbols$^  struct pyxobj0pywrapfstsymboltable oldosymbols$^  struct pyxobj0pywrapfstsymboltable newosymbols$^  pyobject unknownosymbol$^  bool attachnewosymbols$^$^$^ pywrapfst.pxd000$^    cdef void reservestatesself int00 n except $^  $^    cdef void reweightself potentials bool tofinal except               $^  $^    cdef void rmepsilonself queuetype bool connect weight$^ $^struct pyxoptargs0pywrapfst00mutablefstreweight $^  int pyxn$^  bool tofinal$^$^$^ pywrapfst.pxd000$^    cdef void reweightself potentials bool tofinal except $^  $^    cdef void rmepsilonself queuetype bool connect weight              $^                         int00 nstate float delta except $^  $^ $^struct pyxoptargs0pywrapfst00mutablefstrmepsilon $^  int pyxn$^  pyobject queuetype$^  bool connect$^  pyobject weight$^  pyxt00basictypesint00 nstate$^  float delta$^$^$^ pywrapfst.pxd000$^                         int00 nstate float delta except $^  $^    cdef void setfinalself int00 state weight except               $^  $^    cdef void setpropertiesself uint00 props uint00 mask$^ $^struct pyxoptargs0pywrapfst00mutablefstsetfinal $^  int pyxn$^  pyobject weight$^$^$^ pywrapfst.pxd000$^  cdef fst initxfstfstclassptr tfst$^  $^  cdef mutablefst createfstarctype              $^  $^  cpdef fst readfilename$^ $^struct pyxoptargs0pywrapfstcreatefst $^  int pyxn$^  pyobject arctype$^$^$^ pywrapfst.pxd000$^  $^  $^  cdef fst mapfst ifst float delta maptype double power weight              $^  $^  cpdef fst arcmapfst ifst float delta maptype double power weight$^ $^struct pyxoptargs0pywrapfstmap $^  int pyxn$^  float delta$^  pyobject maptype$^  double power$^  pyobject weight$^$^$^ pywrapfst.pxd000$^  cdef fst mapfst ifst float delta maptype double power weight$^  $^  cpdef fst arcmapfst ifst float delta maptype double power weight              $^  $^  cpdef mutablefst composefst ifst0 fst ifst0 composefilter$^ $^struct pyxoptargs0pywrapfstarcmap $^  int pyxn$^  float delta$^  pyobject maptype$^  double power$^  pyobject weight$^$^$^ pywrapfst.pxd000$^  cpdef fst arcmapfst ifst float delta maptype double power weight$^  $^  cpdef mutablefst composefst ifst0 fst ifst0 composefilter              $^                            bool connect$^  $^ $^struct pyxoptargs0pywrapfstcompose $^  int pyxn$^  pyobject composefilter$^  bool connect$^$^$^ pywrapfst.pxd000$^                            bool connect$^  $^  cpdef fst convertfst ifst fsttype              $^  $^  cpdef mutablefst determinizefst ifst float delta dettype$^ $^struct pyxoptargs0pywrapfstconvert $^  int pyxn$^  pyobject fsttype$^$^$^ pywrapfst.pxd000$^  cpdef fst convertfst ifst fsttype$^  $^  cpdef mutablefst determinizefst ifst float delta dettype              $^                                int00 nstate int00 subsequentiallabel$^                                weight bool incrementsubsequentiallabel$^ $^struct pyxoptargs0pywrapfstdeterminize $^  int pyxn$^  float delta$^  pyobject dettype$^  pyxt00basictypesint00 nstate$^  pyxt00basictypesint00 subsequentiallabel$^  pyobject weight$^  bool incrementsubsequentiallabel$^$^$^ pywrapfst.pxd000$^                                weight bool incrementsubsequentiallabel$^  $^  cpdef mutablefst differencefst ifst0 fst ifst0 composefilter              $^                               bool connect$^  $^ $^struct pyxoptargs0pywrapfstdifference $^  int pyxn$^  pyobject composefilter$^  bool connect$^$^$^ pywrapfst.pxd000$^                               bool connect$^  $^  cpdef mutablefst disambiguatefst ifst float delta int00 nstate              $^                                 int00 subsequentiallabel weight$^  $^ $^struct pyxoptargs0pywrapfstdisambiguate $^  int pyxn$^  float delta$^  pyxt00basictypesint00 nstate$^  pyxt00basictypesint00 subsequentiallabel$^  pyobject weight$^$^$^ pywrapfst.pxd000$^                                 int00 subsequentiallabel weight$^  $^  cpdef mutablefst epsnormalizefst ifst bool epsnormoutput              $^  $^  cpdef bool equalfst ifst0 fst ifst0 float delta$^ $^struct pyxoptargs0pywrapfstepsnormalize $^  int pyxn$^  bool epsnormoutput$^$^$^ pywrapfst.pxd000$^  cpdef mutablefst epsnormalizefst ifst bool epsnormoutput$^  $^  cpdef bool equalfst ifst0 fst ifst0 float delta              $^  $^  cpdef bool equivalentfst ifst0 fst ifst0 float delta except $^ $^struct pyxoptargs0pywrapfstequal $^  int pyxn$^  float delta$^$^$^ pywrapfst.pxd000$^  cpdef bool equalfst ifst0 fst ifst0 float delta$^  $^  cpdef bool equivalentfst ifst0 fst ifst0 float delta except               $^  $^  cpdef mutablefst intersectfst ifst0 fst ifst0 composefilter$^ $^struct pyxoptargs0pywrapfstequivalent $^  int pyxn$^  float delta$^$^$^ pywrapfst.pxd000$^  cpdef bool equivalentfst ifst0 fst ifst0 float delta except $^  $^  cpdef mutablefst intersectfst ifst0 fst ifst0 composefilter              $^                              bool connect$^  $^ $^struct pyxoptargs0pywrapfstintersect $^  int pyxn$^  pyobject composefilter$^  bool connect$^$^$^ pywrapfst.pxd000$^                              bool connect$^  $^  cpdef bool isomorphicfst ifst0 fst ifst0 float delta              $^  $^  cpdef mutablefst prunefst ifst float delta int00 nstate$^ $^struct pyxoptargs0pywrapfstisomorphic $^  int pyxn$^  float delta$^$^$^ pywrapfst.pxd000$^  cpdef bool isomorphicfst ifst0 fst ifst0 float delta$^  $^  cpdef mutablefst prunefst ifst float delta int00 nstate              $^                          weight$^  $^ $^struct pyxoptargs0pywrapfstprune $^  int pyxn$^  float delta$^  pyxt00basictypesint00 nstate$^  pyobject weight$^$^$^ pywrapfst.pxd000$^                          weight$^  $^  cpdef mutablefst pushfst ifst float delta bool pushweights              $^                         bool pushlabels bool removecommonaffix$^                         bool removetotalweight bool tofinal$^ $^struct pyxoptargs0pywrapfstpush $^  int pyxn$^  float delta$^  bool pushweights$^  bool pushlabels$^  bool removecommonaffix$^  bool removetotalweight$^  bool tofinal$^$^$^ pywrapfst.pxd000$^                         bool removetotalweight bool tofinal$^  $^  cpdef bool randequivalentfst ifst0 fst ifst0 int00 npath              $^                            float delta timet seed select$^                            int00 maxlength except $^ $^struct pyxoptargs0pywrapfstrandequivalent $^  int pyxn$^  pyxt00basictypesint00 npath$^  float delta$^  timet seed$^  pyobject select$^  pyxt00basictypesint00 maxlength$^$^$^ pywrapfst.pxd000$^                            int00 maxlength except $^  $^  cpdef mutablefst randgenfst ifst int00 npath timet seed              $^                            select int00 maxlength$^                            bool removetotalweight bool weighted$^ $^struct pyxoptargs0pywrapfstrandgen $^  int pyxn$^  pyxt00basictypesint00 npath$^  timet seed$^  pyobject select$^  pyxt00basictypesint00 maxlength$^  bool removetotalweight$^  bool weighted$^$^$^ pywrapfst.pxd000$^      bool epsilononreplace except $^  $^  cpdef mutablefst replacepairs callarclabeling returnarclabeling              $^                            bool epsilononreplace int00 returnlabel$^  $^ $^struct pyxoptargs0pywrapfstreplace $^  int pyxn$^  pyobject callarclabeling$^  pyobject returnarclabeling$^  bool epsilononreplace$^  pyxt00basictypesint00 returnlabel$^$^$^ pywrapfst.pxd000$^                            bool epsilononreplace int00 returnlabel$^  $^  cpdef mutablefst reversefst ifst bool requiresuperinitial              $^  $^  cdef vectorfst.weightclass shortestdistancefst ifst float delta$^ $^struct pyxoptargs0pywrapfstreverse $^  int pyxn$^  bool requiresuperinitial$^$^$^ pywrapfst.pxd000$^  cpdef mutablefst reversefst ifst bool requiresuperinitial$^  $^  cdef vectorfst.weightclass shortestdistancefst ifst float delta              $^                                                  int00 nstate queuetype$^                                                  bool reverse except $^ $^struct pyxoptargs0pywrapfstshortestdistance $^  int pyxn$^  float delta$^  pyxt00basictypesint00 nstate$^  pyobject queuetype$^  bool reverse$^$^$^ pywrapfst.pxd000$^                                                  bool reverse except $^  $^  cpdef mutablefst shortestpathfst ifst float delta int00 nshortest              $^                                 int00 nstate queuetype bool unique$^                                 weight$^ $^struct pyxoptargs0pywrapfstshortestpath $^  int pyxn$^  float delta$^  pyxt00basictypesint00 nshortest$^  pyxt00basictypesint00 nstate$^  pyobject queuetype$^  bool unique$^  pyobject weight$^$^$^ pywrapfst.pxd00$^  $^  $^  cdef class weightobject              $^  $^    cdef uniqueptrfst.weightclass weight$^ $^struct pyxobj0pywrapfstweight $^  pyobjecthead$^  struct pyxvtabstruct0pywrapfstweight pyxvtab$^  stduniqueptrfstscriptweightclass  weight$^$^$^$^ pywrapfst.pxd000$^  $^  $^  cdef class symboltableobject              $^  $^    cdef fst.symboltable table$^ $^struct pyxobj0pywrapfstsymboltable $^  pyobjecthead$^  struct pyxvtabstruct0pywrapfstsymboltable pyxvtab$^  fstsymboltable table$^$^$^$^ pywrapfst.pxd000$^  $^  $^  cdef class encodemappersymboltablesymboltable              $^  $^    cdef sharedptrfst.encodemapperclass encoder$^ $^struct pyxobj0pywrapfstencodemappersymboltable $^  struct pyxobj0pywrapfstsymboltable pyxbase$^  stdsharedptrfstscriptencodemapperclass  encoder$^$^$^$^ pywrapfst.pxd000$^  $^  $^  cdef class fstsymboltablesymboltable              $^  $^    cdef sharedptrfst.fstclass fst$^ $^struct pyxobj0pywrapfstfstsymboltable $^  struct pyxobj0pywrapfstsymboltable pyxbase$^  stdsharedptrfstscriptfstclass  fst$^$^$^$^ pywrapfst.pxd000$^  $^  $^  cdef class mutablesymboltablesymboltable              $^  $^    cpdef int00 addsymbolself symbol int00 key$^ $^struct pyxobj0pywrapfstmutablesymboltable $^  struct pyxobj0pywrapfstsymboltable pyxbase$^$^$^$^ pywrapfst.pxd000$^  $^  $^  cdef class mutablefstsymboltablemutablesymboltable              $^  $^    cdef sharedptrfst.mutablefstclass mfst$^ $^struct pyxobj0pywrapfstmutablefstsymboltable $^  struct pyxobj0pywrapfstmutablesymboltable pyxbase$^  stdsharedptrfstscriptmutablefstclass  mfst$^$^$^$^ pywrapfst.pxd000$^  $^  $^  cdef class symboltablemutablesymboltable              $^  $^    cdef uniqueptrfst.symboltable smarttable$^ $^struct pyxobj0pywrapfstsymboltable $^  struct pyxobj0pywrapfstmutablesymboltable pyxbase$^  stduniqueptrfstsymboltable  smarttable$^$^$^$^ pywrapfst.pxd000$^  $^  $^  cdef class symboltableiteratorobject              $^  $^    cdef sharedptrfst.symboltable table$^ $^struct pyxobj0pywrapfstsymboltableiterator $^  pyobjecthead$^  struct pyxvtabstruct0pywrapfstsymboltableiterator pyxvtab$^  stdsharedptrfstsymboltable  table$^  stduniqueptrfstsymboltableiterator  siter$^$^$^$^ pywrapfst.pxd000$^  $^  $^  cdef class encodemapperobject              $^  $^    cdef sharedptrfst.encodemapperclass encoder$^ $^struct pyxobj0pywrapfstencodemapper $^  pyobjecthead$^  struct pyxvtabstruct0pywrapfstencodemapper pyxvtab$^  stdsharedptrfstscriptencodemapperclass  encoder$^$^$^$^ pywrapfst.pxd000$^  $^  $^  cdef class fstobject              $^  $^    cdef sharedptrfst.fstclass fst$^ $^struct pyxobj0pywrapfstfst $^  pyobjecthead$^  struct pyxvtabstruct0pywrapfstfst pyxvtab$^  stdsharedptrfstscriptfstclass  fst$^$^$^$^ pywrapfst.pxd000$^  $^  $^  cdef class mutablefstfst              $^  $^    cdef sharedptrfst.mutablefstclass mfst$^ $^struct pyxobj0pywrapfstmutablefst $^  struct pyxobj0pywrapfstfst pyxbase$^  stdsharedptrfstscriptmutablefstclass  mfst$^$^$^$^ pywrapfst.pxd000$^  $^  $^  cdef class arcobject              $^  $^    cdef uniqueptrfst.arcclass arc$^ $^struct pyxobj0pywrapfstarc $^  pyobjecthead$^  struct pyxvtabstruct0pywrapfstarc pyxvtab$^  stduniqueptrfstscriptarcclass  arc$^$^$^$^ pywrapfst.pxd000$^  $^  $^  cdef class arciteratorobject              $^  $^    cdef sharedptrfst.fstclass fst$^ $^struct pyxobj0pywrapfstarciterator $^  pyobjecthead$^  struct pyxvtabstruct0pywrapfstarciterator pyxvtab$^  stdsharedptrfstscriptfstclass  fst$^  stduniqueptrfstscriptarciteratorclass  aiter$^$^$^$^ pywrapfst.pxd000$^  $^  $^  cdef class mutablearciteratorobject              $^  $^    cdef sharedptrfst.mutablefstclass mfst$^ $^struct pyxobj0pywrapfstmutablearciterator $^  pyobjecthead$^  struct pyxvtabstruct0pywrapfstmutablearciterator pyxvtab$^  stdsharedptrfstscriptmutablefstclass  mfst$^  stduniqueptrfstscriptmutablearciteratorclass  aiter$^$^$^$^ pywrapfst.pxd000$^  $^  $^  cdef class stateiteratorobject              $^  $^    cdef sharedptrfst.fstclass fst$^ $^struct pyxobj0pywrapfststateiterator $^  pyobjecthead$^  struct pyxvtabstruct0pywrapfststateiterator pyxvtab$^  stdsharedptrfstscriptfstclass  fst$^  stduniqueptrfstscriptstateiteratorclass  siter$^$^$^$^ pywrapfst.pxd000$^  $^  $^  cdef class compilerobject              $^  $^    cdef uniqueptrstringstream sstrm$^ $^struct pyxobj0pywrapfstcompiler $^  pyobjecthead$^  struct pyxvtabstruct0pywrapfstcompiler pyxvtab$^  stduniqueptrstdstringstream  sstrm$^  stdstring fsttype$^  stdstring arctype$^  fstsymboltable const isymbols$^  fstsymboltable const osymbols$^  fstsymboltable const ssymbols$^  bool acceptor$^  bool keepisymbols$^  bool keeposymbols$^  bool keepstatenumbering$^  bool allownegativelabels$^$^$^$^ pywrapfst.pxd000$^   farreader.$^  $^  cdef class farreaderobject              $^  $^    cdef uniqueptrfst.farreaderclass reader$^ $^struct pyxobj0pywrapfstfarreader $^  pyobjecthead$^  struct pyxvtabstruct0pywrapfstfarreader pyxvtab$^  stduniqueptrfstscriptfarreaderclass  reader$^$^$^$^ pywrapfst.pxd000$^   farwriter.$^  $^  cdef class farwriterobject              $^  $^    cdef uniqueptrfst.farwriterclass writer$^ $^struct pyxobj0pywrapfstfarwriter $^  pyobjecthead$^  struct pyxvtabstruct0pywrapfstfarwriter pyxvtab$^  stduniqueptrfstscriptfarwriterclass  writer$^$^$^$^$^ pywrapfst.pyx000$^  $^  $^  cdef class weightobject              $^  $^    $^ $^$^struct pyxvtabstruct0pywrapfstweight $^  void checkweightstruct pyxobj0pywrapfstweight $^  struct pyxobj0pywrapfstweight copystruct pyxobj0pywrapfstweight  int pyxskipdispatch$^  stdstring tostringstruct pyxobj0pywrapfstweight  int pyxskipdispatch$^  stdstring typestruct pyxobj0pywrapfstweight  int pyxskipdispatch$^$^static struct pyxvtabstruct0pywrapfstweight pyxvtabptr0pywrapfstweight$^$^$^ pywrapfst.pyx000$^  $^  $^  cdef class symboltableobject              $^  $^    $^ $^$^struct pyxvtabstruct0pywrapfstsymboltable $^  pyxt00basictypesint00 availablekeystruct pyxobj0pywrapfstsymboltable  int pyxskipdispatch$^  stdstring checksumstruct pyxobj0pywrapfstsymboltable  int pyxskipdispatch$^  struct pyxobj0pywrapfstsymboltable copystruct pyxobj0pywrapfstsymboltable  int pyxskipdispatch$^  pyxt00basictypesint00 getnthkeystruct pyxobj0pywrapfstsymboltable  pyssizet int pyxskipdispatch$^  stdstring labeledchecksumstruct pyxobj0pywrapfstsymboltable  int pyxskipdispatch$^  bool memberstruct pyxobj0pywrapfstsymboltable  pyobject  int pyxskipdispatch$^  stdstring namestruct pyxobj0pywrapfstsymboltable  int pyxskipdispatch$^  sizet numsymbolsstruct pyxobj0pywrapfstsymboltable  int pyxskipdispatch$^  void writestruct pyxobj0pywrapfstsymboltable  pyobject  int pyxskipdispatch$^  void writetextstruct pyxobj0pywrapfstsymboltable  pyobject  int pyxskipdispatch$^$^static struct pyxvtabstruct0pywrapfstsymboltable pyxvtabptr0pywrapfstsymboltable$^$^$^ pywrapfst.pyx000$^  $^  $^  cdef class encodemappersymboltablesymboltable              $^  $^    $^ $^$^struct pyxvtabstruct0pywrapfstencodemappersymboltable $^  struct pyxvtabstruct0pywrapfstsymboltable pyxbase$^$^static struct pyxvtabstruct0pywrapfstencodemappersymboltable pyxvtabptr0pywrapfstencodemappersymboltable$^$^$^ pywrapfst.pyx000$^  $^  $^  cdef class fstsymboltablesymboltable              $^  $^    $^ $^$^struct pyxvtabstruct0pywrapfstfstsymboltable $^  struct pyxvtabstruct0pywrapfstsymboltable pyxbase$^$^static struct pyxvtabstruct0pywrapfstfstsymboltable pyxvtabptr0pywrapfstfstsymboltable$^$^$^ pywrapfst.pyx000$^  $^  $^  cdef class mutablesymboltablesymboltable              $^  $^    $^ $^$^struct pyxvtabstruct0pywrapfstmutablesymboltable $^  struct pyxvtabstruct0pywrapfstsymboltable pyxbase$^  pyxt00basictypesint00 addsymbolstruct pyxobj0pywrapfstmutablesymboltable  pyobject  int pyxskipdispatch struct pyxoptargs0pywrapfst00mutablesymboltableaddsymbol pyxoptionalargs$^  void addtablestruct pyxobj0pywrapfstmutablesymboltable  struct pyxobj0pywrapfstsymboltable  int pyxskipdispatch$^  void setnamestruct pyxobj0pywrapfstmutablesymboltable  pyobject  int pyxskipdispatch$^$^static struct pyxvtabstruct0pywrapfstmutablesymboltable pyxvtabptr0pywrapfstmutablesymboltable$^$^$^ pywrapfst.pyx000$^  $^  $^  cdef class mutablefstsymboltablemutablesymboltable              $^    $^    no constructor.$^ $^$^struct pyxvtabstruct0pywrapfstmutablefstsymboltable $^  struct pyxvtabstruct0pywrapfstmutablesymboltable pyxbase$^$^static struct pyxvtabstruct0pywrapfstmutablefstsymboltable pyxvtabptr0pywrapfstmutablefstsymboltable$^$^$^ pywrapfst.pyx000$^  $^  $^  cdef class symboltablemutablesymboltable              $^  $^    $^ $^$^struct pyxvtabstruct0pywrapfstsymboltable $^  struct pyxvtabstruct0pywrapfstmutablesymboltable pyxbase$^$^static struct pyxvtabstruct0pywrapfstsymboltable pyxvtabptr0pywrapfstsymboltable$^$^$^ pywrapfst.pyx0000$^  $^  $^  cdef class symboltableiteratorobject              $^  $^    $^ $^$^struct pyxvtabstruct0pywrapfstsymboltableiterator $^  bool donestruct pyxobj0pywrapfstsymboltableiterator  int pyxskipdispatch$^  void nextstruct pyxobj0pywrapfstsymboltableiterator  int pyxskipdispatch$^  void resetstruct pyxobj0pywrapfstsymboltableiterator  int pyxskipdispatch$^  stdstring symbolstruct pyxobj0pywrapfstsymboltableiterator  int pyxskipdispatch$^  pyxt00basictypesint00 valuestruct pyxobj0pywrapfstsymboltableiterator  int pyxskipdispatch$^$^static struct pyxvtabstruct0pywrapfstsymboltableiterator pyxvtabptr0pywrapfstsymboltableiterator$^$^$^ pywrapfst.pyx0000$^  $^  $^  cdef class encodemapperobject              $^  $^    $^ $^$^struct pyxvtabstruct0pywrapfstencodemapper $^  stdstring arctypestruct pyxobj0pywrapfstencodemapper  int pyxskipdispatch$^  pyxt00basictypesuint00 flagsstruct pyxobj0pywrapfstencodemapper  int pyxskipdispatch$^  struct pyxobj0pywrapfstencodemappersymboltable inputsymbolsstruct pyxobj0pywrapfstencodemapper  int pyxskipdispatch$^  struct pyxobj0pywrapfstencodemappersymboltable outputsymbolsstruct pyxobj0pywrapfstencodemapper  int pyxskipdispatch$^  pyxt00basictypesuint00 propertiesstruct pyxobj0pywrapfstencodemapper  pyxt00basictypesuint00 int pyxskipdispatch$^  void setinputsymbolsstruct pyxobj0pywrapfstencodemapper  struct pyxobj0pywrapfstsymboltable  int pyxskipdispatch$^  void setoutputsymbolsstruct pyxobj0pywrapfstencodemapper  struct pyxobj0pywrapfstsymboltable  int pyxskipdispatch$^  stdstring weighttypestruct pyxobj0pywrapfstencodemapper  int pyxskipdispatch$^$^static struct pyxvtabstruct0pywrapfstencodemapper pyxvtabptr0pywrapfstencodemapper$^$^$^ pywrapfst.pyx0000$^  $^  $^  cdef class fstobject              $^  $^    $^ $^$^struct pyxvtabstruct0pywrapfstfst $^  stdstring arctypestruct pyxobj0pywrapfstfst  int pyxskipdispatch$^  struct pyxobj0pywrapfstarciterator arcsstruct pyxobj0pywrapfstfst  pyxt00basictypesint00 int pyxskipdispatch$^  struct pyxobj0pywrapfstfst copystruct pyxobj0pywrapfstfst  int pyxskipdispatch$^  void drawstruct pyxobj0pywrapfstfst  pyobject  int pyxskipdispatch struct pyxoptargs0pywrapfst0fstdraw pyxoptionalargs$^  struct pyxobj0pywrapfstweight finalstruct pyxobj0pywrapfstfst  pyxt00basictypesint00 int pyxskipdispatch$^  stdstring fsttypestruct pyxobj0pywrapfstfst  int pyxskipdispatch$^  struct pyxobj0pywrapfstfstsymboltable inputsymbolsstruct pyxobj0pywrapfstfst  int pyxskipdispatch$^  sizet numarcsstruct pyxobj0pywrapfstfst  pyxt00basictypesint00 int pyxskipdispatch$^  sizet numinputepsilonsstruct pyxobj0pywrapfstfst  pyxt00basictypesint00 int pyxskipdispatch$^  sizet numoutputepsilonsstruct pyxobj0pywrapfstfst  pyxt00basictypesint00 int pyxskipdispatch$^  struct pyxobj0pywrapfstfstsymboltable outputsymbolsstruct pyxobj0pywrapfstfst  int pyxskipdispatch$^  pyxt00basictypesuint00 propertiesstruct pyxobj0pywrapfstfst  pyxt00basictypesuint00 bool int pyxskipdispatch$^  pyxt00basictypesint00 startstruct pyxobj0pywrapfstfst  int pyxskipdispatch$^  struct pyxobj0pywrapfststateiterator statesstruct pyxobj0pywrapfstfst  int pyxskipdispatch$^  stdstring textstruct pyxobj0pywrapfstfst  int pyxskipdispatch struct pyxoptargs0pywrapfst0fsttext pyxoptionalargs$^  bool verifystruct pyxobj0pywrapfstfst  int pyxskipdispatch$^  stdstring weighttypestruct pyxobj0pywrapfstfst  int pyxskipdispatch$^  void writestruct pyxobj0pywrapfstfst  pyobject  int pyxskipdispatch$^  stdstring writetostringstruct pyxobj0pywrapfstfst  int pyxskipdispatch$^$^static struct pyxvtabstruct0pywrapfstfst pyxvtabptr0pywrapfstfst$^$^$^ pywrapfst.pyx0000$^  $^  $^  cdef class mutablefstfst              $^  $^    $^ $^$^struct pyxvtabstruct0pywrapfstmutablefst $^  struct pyxvtabstruct0pywrapfstfst pyxbase$^  void checkmutatingimethodstruct pyxobj0pywrapfstmutablefst $^  void addarcstruct pyxobj0pywrapfstmutablefst  pyxt00basictypesint00 struct pyxobj0pywrapfstarc $^  pyxt00basictypesint00 addstatestruct pyxobj0pywrapfstmutablefst  int pyxskipdispatch$^  void arcsortstruct pyxobj0pywrapfstmutablefst  struct pyxoptargs0pywrapfst00mutablefstarcsort pyxoptionalargs$^  void closurestruct pyxobj0pywrapfstmutablefst  struct pyxoptargs0pywrapfst00mutablefstclosure pyxoptionalargs$^  void concatstruct pyxobj0pywrapfstmutablefst  struct pyxobj0pywrapfstfst $^  void connectstruct pyxobj0pywrapfstmutablefst $^  void decodestruct pyxobj0pywrapfstmutablefst  struct pyxobj0pywrapfstencodemapper $^  void deletearcsstruct pyxobj0pywrapfstmutablefst  pyxt00basictypesint00 struct pyxoptargs0pywrapfst00mutablefstdeletearcs pyxoptionalargs$^  void deletestatesstruct pyxobj0pywrapfstmutablefst  struct pyxoptargs0pywrapfst00mutablefstdeletestates pyxoptionalargs$^  void encodestruct pyxobj0pywrapfstmutablefst  struct pyxobj0pywrapfstencodemapper $^  void invertstruct pyxobj0pywrapfstmutablefst $^  void minimizestruct pyxobj0pywrapfstmutablefst  struct pyxoptargs0pywrapfst00mutablefstminimize pyxoptionalargs$^  struct pyxobj0pywrapfstmutablearciterator mutablearcsstruct pyxobj0pywrapfstmutablefst  pyxt00basictypesint00 int pyxskipdispatch$^  pyxt00basictypesint00 numstatesstruct pyxobj0pywrapfstmutablefst  int pyxskipdispatch$^  void projectstruct pyxobj0pywrapfstmutablefst  struct pyxoptargs0pywrapfst00mutablefstproject pyxoptionalargs$^  void prunestruct pyxobj0pywrapfstmutablefst  struct pyxoptargs0pywrapfst00mutablefstprune pyxoptionalargs$^  void pushstruct pyxobj0pywrapfstmutablefst  struct pyxoptargs0pywrapfst00mutablefstpush pyxoptionalargs$^  void relabelpairsstruct pyxobj0pywrapfstmutablefst  struct pyxoptargs0pywrapfst00mutablefstrelabelpairs pyxoptionalargs$^  void relabeltablesstruct pyxobj0pywrapfstmutablefst  struct pyxoptargs0pywrapfst00mutablefstrelabeltables pyxoptionalargs$^  void reservearcsstruct pyxobj0pywrapfstmutablefst  pyxt00basictypesint00 sizet$^  void reservestatesstruct pyxobj0pywrapfstmutablefst  pyxt00basictypesint00$^  void reweightstruct pyxobj0pywrapfstmutablefst  pyobject  struct pyxoptargs0pywrapfst00mutablefstreweight pyxoptionalargs$^  void rmepsilonstruct pyxobj0pywrapfstmutablefst  struct pyxoptargs0pywrapfst00mutablefstrmepsilon pyxoptionalargs$^  void setfinalstruct pyxobj0pywrapfstmutablefst  pyxt00basictypesint00 struct pyxoptargs0pywrapfst00mutablefstsetfinal pyxoptionalargs$^  void setpropertiesstruct pyxobj0pywrapfstmutablefst  pyxt00basictypesuint00 pyxt00basictypesuint00$^  void setstartstruct pyxobj0pywrapfstmutablefst  pyxt00basictypesint00$^  void setinputsymbolsstruct pyxobj0pywrapfstmutablefst  struct pyxobj0pywrapfstsymboltable $^  void setoutputsymbolsstruct pyxobj0pywrapfstmutablefst  struct pyxobj0pywrapfstsymboltable $^  void topsortstruct pyxobj0pywrapfstmutablefst $^  void unionstruct pyxobj0pywrapfstmutablefst  struct pyxobj0pywrapfstfst $^$^static struct pyxvtabstruct0pywrapfstmutablefst pyxvtabptr0pywrapfstmutablefst$^$^$^ pywrapfst.pyx0000$^  $^  $^  cdef class arcobject              $^  $^    $^ $^$^struct pyxvtabstruct0pywrapfstarc $^  struct pyxobj0pywrapfstarc copystruct pyxobj0pywrapfstarc  int pyxskipdispatch$^$^static struct pyxvtabstruct0pywrapfstarc pyxvtabptr0pywrapfstarc$^$^$^ pywrapfst.pyx0000$^  $^  $^  cdef class arciteratorobject              $^  $^    $^ $^$^struct pyxvtabstruct0pywrapfstarciterator $^  bool donestruct pyxobj0pywrapfstarciterator  int pyxskipdispatch$^  pyxt00basictypesuint00 flagsstruct pyxobj0pywrapfstarciterator  int pyxskipdispatch$^  void nextstruct pyxobj0pywrapfstarciterator  int pyxskipdispatch$^  sizet positionstruct pyxobj0pywrapfstarciterator  int pyxskipdispatch$^  void resetstruct pyxobj0pywrapfstarciterator  int pyxskipdispatch$^  void seekstruct pyxobj0pywrapfstarciterator  sizet int pyxskipdispatch$^  void setflagsstruct pyxobj0pywrapfstarciterator  pyxt00basictypesuint00 pyxt00basictypesuint00 int pyxskipdispatch$^  pyobject valuestruct pyxobj0pywrapfstarciterator  int pyxskipdispatch$^$^static struct pyxvtabstruct0pywrapfstarciterator pyxvtabptr0pywrapfstarciterator$^$^$^ pywrapfst.pyx0000$^  $^  $^  cdef class mutablearciteratorobject              $^  $^    $^ $^$^struct pyxvtabstruct0pywrapfstmutablearciterator $^  bool donestruct pyxobj0pywrapfstmutablearciterator  int pyxskipdispatch$^  pyxt00basictypesuint00 flagsstruct pyxobj0pywrapfstmutablearciterator  int pyxskipdispatch$^  void nextstruct pyxobj0pywrapfstmutablearciterator  int pyxskipdispatch$^  sizet positionstruct pyxobj0pywrapfstmutablearciterator  int pyxskipdispatch$^  void resetstruct pyxobj0pywrapfstmutablearciterator  int pyxskipdispatch$^  void seekstruct pyxobj0pywrapfstmutablearciterator  sizet int pyxskipdispatch$^  void setflagsstruct pyxobj0pywrapfstmutablearciterator  pyxt00basictypesuint00 pyxt00basictypesuint00 int pyxskipdispatch$^  void setvaluestruct pyxobj0pywrapfstmutablearciterator  struct pyxobj0pywrapfstarc  int pyxskipdispatch$^  pyobject valuestruct pyxobj0pywrapfstmutablearciterator  int pyxskipdispatch$^$^static struct pyxvtabstruct0pywrapfstmutablearciterator pyxvtabptr0pywrapfstmutablearciterator$^$^$^ pywrapfst.pyx0000$^  $^  $^  cdef class stateiteratorobject              $^  $^    $^ $^$^struct pyxvtabstruct0pywrapfststateiterator $^  bool donestruct pyxobj0pywrapfststateiterator  int pyxskipdispatch$^  void nextstruct pyxobj0pywrapfststateiterator  int pyxskipdispatch$^  void resetstruct pyxobj0pywrapfststateiterator  int pyxskipdispatch$^  pyxt00basictypesint00 valuestruct pyxobj0pywrapfststateiterator  int pyxskipdispatch$^$^static struct pyxvtabstruct0pywrapfststateiterator pyxvtabptr0pywrapfststateiterator$^$^$^ pywrapfst.pyx0000$^  $^  $^  cdef class compilerobject              $^  $^    $^ $^$^struct pyxvtabstruct0pywrapfstcompiler $^  struct pyxobj0pywrapfstfst compilestruct pyxobj0pywrapfstcompiler  int pyxskipdispatch$^  void writestruct pyxobj0pywrapfstcompiler  pyobject  int pyxskipdispatch$^$^static struct pyxvtabstruct0pywrapfstcompiler pyxvtabptr0pywrapfstcompiler$^$^$^ pywrapfst.pyx0000$^  $^  $^  cdef class farreaderobject              $^  $^    $^ $^$^struct pyxvtabstruct0pywrapfstfarreader $^  stdstring arctypestruct pyxobj0pywrapfstfarreader  int pyxskipdispatch$^  bool donestruct pyxobj0pywrapfstfarreader  int pyxskipdispatch$^  bool errorstruct pyxobj0pywrapfstfarreader  int pyxskipdispatch$^  stdstring fartypestruct pyxobj0pywrapfstfarreader  int pyxskipdispatch$^  bool findstruct pyxobj0pywrapfstfarreader  pyobject  int pyxskipdispatch$^  struct pyxobj0pywrapfstfst getfststruct pyxobj0pywrapfstfarreader  int pyxskipdispatch$^  stdstring getkeystruct pyxobj0pywrapfstfarreader  int pyxskipdispatch$^  void nextstruct pyxobj0pywrapfstfarreader  int pyxskipdispatch$^  void resetstruct pyxobj0pywrapfstfarreader  int pyxskipdispatch$^$^static struct pyxvtabstruct0pywrapfstfarreader pyxvtabptr0pywrapfstfarreader$^$^$^ pywrapfst.pyx0000$^  $^  $^  cdef class farwriterobject              $^  $^    $^ $^$^struct pyxvtabstruct0pywrapfstfarwriter $^  stdstring arctypestruct pyxobj0pywrapfstfarwriter  int pyxskipdispatch$^  void closestruct pyxobj0pywrapfstfarwriter $^  void addstruct pyxobj0pywrapfstfarwriter  pyobject  struct pyxobj0pywrapfstfst  int pyxskipdispatch$^  bool errorstruct pyxobj0pywrapfstfarwriter  int pyxskipdispatch$^  stdstring fartypestruct pyxobj0pywrapfstfarwriter  int pyxskipdispatch$^$^static struct pyxvtabstruct0pywrapfstfarwriter pyxvtabptr0pywrapfstfarwriter$^$^  runtime support code head  $^ refnanny.proto $^ifndef cythonrefnanny$^  define cythonrefnanny 0$^endif$^if cythonrefnanny$^  typedef struct $^    void increfvoid pyobject int$^    void decrefvoid pyobject int$^    void gotrefvoid pyobject int$^    void giverefvoid pyobject int$^    void setupcontextconst char int const char$^    void finishcontextvoid$^   pyxrefnannyapistruct$^  static pyxrefnannyapistruct pyxrefnanny  null$^  static pyxrefnannyapistruct pyxrefnannyimportapiconst char modname$^  define pyxrefnannydeclarations void pyxrefnanny  null$^ifdef withthread$^  define pyxrefnannysetupcontextname acquiregil$^          if acquiregil $^              pygilstatestate pyxgilstatesave  pygilstateensure$^              pyxrefnanny  pyxrefnannysetupcontextname line file$^              pygilstatereleasepyxgilstatesave$^           else $^              pyxrefnanny  pyxrefnannysetupcontextname line file$^          $^else$^  define pyxrefnannysetupcontextname acquiregil$^          pyxrefnanny  pyxrefnannysetupcontextname line file$^endif$^  define pyxrefnannyfinishcontext$^          pyxrefnannyfinishcontextpyxrefnanny$^  define pyxincrefr  pyxrefnannyincrefpyxrefnanny pyobject r line$^  define pyxdecrefr  pyxrefnannydecrefpyxrefnanny pyobject r line$^  define pyxgotrefr  pyxrefnannygotrefpyxrefnanny pyobject r line$^  define pyxgiverefr pyxrefnannygiverefpyxrefnanny pyobject r line$^  define pyxxincrefr  do  ifr  null pyxincrefr  while0$^  define pyxxdecrefr  do  ifr  null pyxdecrefr  while0$^  define pyxxgotrefr  do  ifr  null pyxgotrefr  while0$^  define pyxxgiverefr do  ifr  null pyxgiverefr while0$^else$^  define pyxrefnannydeclarations$^  define pyxrefnannysetupcontextname acquiregil$^  define pyxrefnannyfinishcontext$^  define pyxincrefr pyincrefr$^  define pyxdecrefr pydecrefr$^  define pyxgotrefr$^  define pyxgiverefr$^  define pyxxincrefr pyxincrefr$^  define pyxxdecrefr pyxdecrefr$^  define pyxxgotrefr$^  define pyxxgiverefr$^endif$^define pyxxdecrefsetr v do $^        pyobject tmp  pyobject  r$^        r  v pyxxdecreftmp$^     while 0$^define pyxdecrefsetr v do $^        pyobject tmp  pyobject  r$^        r  v pyxdecreftmp$^     while 0$^define pyxclearr    do  pyobject tmp  pyobjectr r  null pyxdecreftmp while0$^define pyxxclearr   do  ifr  null pyobject tmp  pyobjectr r  null pyxdecreftmp while0$^$^ pyobjectgetattrstr.proto $^if cythonusetypeslots$^static cythoninline pyobject pyxpyobjectgetattrstrpyobject obj pyobject attrname$^else$^define pyxpyobjectgetattrstron pyobjectgetattron$^endif$^$^ getbuiltinname.proto $^static pyobject pyxgetbuiltinnamepyobject name$^$^ pycfunctionfastcall.proto $^if cythonfastpyccall$^static cythoninline pyobject pyxpycfunctionfastcallpyobject func pyobject args pyssizet nargs$^else$^define pyxpycfunctionfastcallfunc args nargs  assert0 null$^endif$^$^ pyfunctionfastcall.proto $^if cythonfastpycall$^define pyxpyfunctionfastcallfunc args nargs$^    pyxpyfunctionfastcalldictfunc args nargs null$^if 0  pyversionhex  0x000000b0$^static pyobject pyxpyfunctionfastcalldictpyobject func pyobject args int nargs pyobject kwargs$^else$^define pyxpyfunctionfastcalldictfunc args nargs kwargs pyfunctionfastcalldictfunc args nargs kwargs$^endif$^endif$^$^ pyobjectcall.proto $^if cythoncompilingincpython$^static cythoninline pyobject pyxpyobjectcallpyobject func pyobject arg pyobject kw$^else$^define pyxpyobjectcallfunc arg kw pyobjectcallfunc arg kw$^endif$^$^ pyobjectcallmetho.proto $^if cythoncompilingincpython$^static cythoninline pyobject pyxpyobjectcallmethopyobject func pyobject arg$^endif$^$^ pyobjectcallonearg.proto $^static cythoninline pyobject pyxpyobjectcalloneargpyobject func pyobject arg$^$^ getmoduleglobalname.proto $^static cythoninline pyobject pyxgetmoduleglobalnamepyobject name$^$^ pythreadstateget.proto $^if cythonfastthreadstate$^define pyxpythreadstatedeclare  pythreadstate pyxtstate$^define pyxpythreadstateassign  pyxtstate  pyxpythreadstatecurrent$^define pyxpyerroccurred  pyxtstatecurexctype$^else$^define pyxpythreadstatedeclare$^define pyxpythreadstateassign$^define pyxpyerroccurred  pyerroccurred$^endif$^$^ pyerrfetchrestore.proto $^if cythonfastthreadstate$^define pyxpyerrclear pyxerrrestorenull null null$^define pyxerrrestorewithstatetype value tb  pyxerrrestoreinstatepythreadstateget type value tb$^define pyxerrfetchwithstatetype value tb    pyxerrfetchinstatepythreadstateget type value tb$^define pyxerrrestoretype value tb  pyxerrrestoreinstatepyxtstate type value tb$^define pyxerrfetchtype value tb    pyxerrfetchinstatepyxtstate type value tb$^static cythoninline void pyxerrrestoreinstatepythreadstate tstate pyobject type pyobject value pyobject tb$^static cythoninline void pyxerrfetchinstatepythreadstate tstate pyobject type pyobject value pyobject tb$^if cythoncompilingincpython$^define pyxpyerrsetnoneexc pyincrefexc pyxerrrestoreexc null null$^else$^define pyxpyerrsetnoneexc pyerrsetnoneexc$^endif$^else$^define pyxpyerrclear pyerrclear$^define pyxpyerrsetnoneexc pyerrsetnoneexc$^define pyxerrrestorewithstatetype value tb  pyerrrestoretype value tb$^define pyxerrfetchwithstatetype value tb  pyerrfetchtype value tb$^define pyxerrrestoreinstatetstate type value tb  pyerrrestoretype value tb$^define pyxerrfetchinstatetstate type value tb  pyerrfetchtype value tb$^define pyxerrrestoretype value tb  pyerrrestoretype value tb$^define pyxerrfetchtype value tb  pyerrfetchtype value tb$^endif$^$^ raiseexception.proto $^static void pyxraisepyobject type pyobject value pyobject tb pyobject cause$^$^ raiseargtupleinvalid.proto $^static void pyxraiseargtupleinvalidconst char funcname int exact$^    pyssizet nummin pyssizet nummax pyssizet numfound$^$^ raisedoublekeywords.proto $^static void pyxraisedoublekeywordserrorconst char funcname pyobject kwname$^$^ parsekeywords.proto $^static int pyxparseoptionalkeywordspyobject kwds pyobject argnames$^    pyobject kwds0 pyobject values pyssizet numposargs$^    const char functionname$^$^ pyobjectcallnoarg.proto $^if cythoncompilingincpython$^static cythoninline pyobject pyxpyobjectcallnoargpyobject func$^else$^define pyxpyobjectcallnoargfunc pyxpyobjectcallfunc pyxemptytuple null$^endif$^$^ exttypetest.proto $^static cythoninline int pyxtypetestpyobject obj pytypeobject type$^$^ argtypetest.proto $^define pyxargtypetestobj type noneallowed name exact$^    likelypytypeobj  type  noneallowed  obj  pynone  0 $^        pyxargtypetestobj type name exact$^static int pyxargtypetestpyobject obj pytypeobject type const char name int exact$^$^ writeunraisableexception.proto $^static void pyxwriteunraisableconst char name int clineno$^                                  int lineno const char filename$^                                  int fulltraceback int nogil$^$^ keywordstringcheck.proto $^static int pyxcheckkeywordstringspyobject kwdict const char functionname int kwallowed$^$^ saveresetexception.proto $^if cythonfastthreadstate$^define pyxexceptionsavetype value tb  pyxexceptionsavepyxtstate type value tb$^static cythoninline void pyxexceptionsavepythreadstate tstate pyobject type pyobject value pyobject tb$^define pyxexceptionresettype value tb  pyxexceptionresetpyxtstate type value tb$^static cythoninline void pyxexceptionresetpythreadstate tstate pyobject type pyobject value pyobject tb$^else$^define pyxexceptionsavetype value tb   pyerrgetexcinfotype value tb$^define pyxexceptionresettype value tb  pyerrsetexcinfotype value tb$^endif$^$^ fasttypechecks.proto $^if cythoncompilingincpython$^define pyxtypecheckobj type pyxissubtypepytypeobj pytypeobject type$^static cythoninline int pyxissubtypepytypeobject a pytypeobject b$^static cythoninline int pyxpyerrgivenexceptionmatchespyobject err pyobject type$^static cythoninline int pyxpyerrgivenexceptionmatches0pyobject err pyobject type0 pyobject type0$^else$^define pyxtypecheckobj type pyobjecttypecheckobj pytypeobject type$^define pyxpyerrgivenexceptionmatcheserr type pyerrgivenexceptionmatcheserr type$^define pyxpyerrgivenexceptionmatches0err type0 type0 pyerrgivenexceptionmatcheserr type0  pyerrgivenexceptionmatcheserr type0$^endif$^define pyxpyexceptioncheckobj pyxtypecheckobj pyexcexception$^$^ getexception.proto $^if cythonfastthreadstate$^define pyxgetexceptiontype value tb  pyxgetexceptionpyxtstate type value tb$^static int pyxgetexceptionpythreadstate tstate pyobject type pyobject value pyobject tb$^else$^static int pyxgetexceptionpyobject type pyobject value pyobject tb$^endif$^$^ raisetoomanyvaluestounpack.proto $^static cythoninline void pyxraisetoomanyvalueserrorpyssizet expected$^$^ raiseneedmorevaluestounpack.proto $^static cythoninline void pyxraiseneedmorevalueserrorpyssizet index$^$^ iterfinish.proto $^static cythoninline int pyxiterfinishvoid$^$^ unpackitemendcheck.proto $^static int pyxiternextunpackendcheckpyobject retval pyssizet expected$^$^ iternext.proto $^define pyxpyiternextobj pyxpyiternext0obj null$^static cythoninline pyobject pyxpyiternext0pyobject  pyobject $^$^ listcompappend.proto $^if cythonusepylistinternals  cythonassumesafemacros$^static cythoninline int pyxlistcompappendpyobject list pyobject x $^    pylistobject l  pylistobject list$^    pyssizet len  pysizelist$^    if likelylallocated  len $^        pyincrefx$^        pylistsetitemlist len x$^        pysizelist  len0$^        return 0$^    $^    return pylistappendlist x$^$^else$^define pyxlistcompappendlx pylistappendlx$^endif$^$^ pyobjectgenericgetattrnodict.proto $^if cythonusetypeslots  cythonusepytypelookup  pyversionhex  0x00000000$^static cythoninline pyobject pyxpyobjectgenericgetattrnodictpyobject obj pyobject attrname$^else$^define pyxpyobjectgenericgetattrnodict pyobjectgenericgetattr$^endif$^$^ pyobjectgenericgetattr.proto $^if cythonusetypeslots  cythonusepytypelookup  pyversionhex  0x00000000$^static pyobject pyxpyobjectgenericgetattrpyobject obj pyobject attrname$^else$^define pyxpyobjectgenericgetattr pyobjectgenericgetattr$^endif$^$^ setvtable.proto $^static int pyxsetvtablepyobject dict void vtable$^$^ setupreduce.proto $^static int pyxsetupreducepyobject typeobj$^$^ import.proto $^static pyobject pyximportpyobject name pyobject fromlist int level$^$^ calculatemetaclass.proto $^static pyobject pyxcalculatemetaclasspytypeobject metaclass pyobject bases$^$^ py0classcreate.proto $^static pyobject pyxpy0metaclasspreparepyobject metaclass pyobject bases pyobject name pyobject qualname$^                                           pyobject mkw pyobject modname pyobject doc$^static pyobject pyxpy0classcreatepyobject metaclass pyobject name pyobject bases pyobject dict$^                                      pyobject mkw int calculatemetaclass int allowpy0metaclass$^$^ classmethod.proto $^include descrobject.h$^static pyobject pyxmethodclassmethodpyobject method$^$^ pyerrexceptionmatches.proto $^if cythonfastthreadstate$^define pyxpyerrexceptionmatcheserr pyxpyerrexceptionmatchesinstatepyxtstate err$^static cythoninline int pyxpyerrexceptionmatchesinstatepythreadstate tstate pyobject err$^else$^define pyxpyerrexceptionmatcheserr  pyerrexceptionmatcheserr$^endif$^$^ getnameinclass.proto $^static pyobject pyxgetnameinclasspyobject nmspace pyobject name$^$^ fetchcommontype.proto $^static pytypeobject pyxfetchcommontypepytypeobject type$^$^ cythonfunction.proto $^define pyxcyfunctionused 0$^define pyxcyfunctionstaticmethod  0x00$^define pyxcyfunctionclassmethod   0x00$^define pyxcyfunctioncclass        0x00$^define pyxcyfunctiongetclosuref$^    pyxcyfunctionobject  ffuncclosure$^define pyxcyfunctiongetclassobjf$^    pyxcyfunctionobject  ffuncclassobj$^define pyxcyfunctiondefaultstype f$^    type pyxcyfunctionobject  fdefaults$^define pyxcyfunctionsetdefaultsgetterf g$^    pyxcyfunctionobject  fdefaultsgetter  g$^typedef struct $^    pycfunctionobject func$^if pyversionhex  0x000000a0$^    pyobject funcweakreflist$^endif$^    pyobject funcdict$^    pyobject funcname$^    pyobject funcqualname$^    pyobject funcdoc$^    pyobject funcglobals$^    pyobject funccode$^    pyobject funcclosure$^    pyobject funcclassobj$^    void defaults$^    int defaultspyobjects$^    int flags$^    pyobject defaultstuple$^    pyobject defaultskwdict$^    pyobject defaultsgetterpyobject $^    pyobject funcannotations$^ pyxcyfunctionobject$^static pytypeobject pyxcyfunctiontype  0$^define pyxcyfunctionnewexml flags qualname self module globals code$^    pyxcyfunctionnewpyxcyfunctiontype ml flags qualname self module globals code$^static pyobject pyxcyfunctionnewpytypeobject  pymethoddef ml$^                                      int flags pyobject qualname$^                                      pyobject self$^                                      pyobject module pyobject globals$^                                      pyobject code$^static cythoninline void pyxcyfunctioninitdefaultspyobject m$^                                                         sizet size$^                                                         int pyobjects$^static cythoninline void pyxcyfunctionsetdefaultstuplepyobject m$^                                                            pyobject tuple$^static cythoninline void pyxcyfunctionsetdefaultskwdictpyobject m$^                                                             pyobject dict$^static cythoninline void pyxcyfunctionsetannotationsdictpyobject m$^                                                              pyobject dict$^static int pyxcyfunctioninitvoid$^$^ setnameinclass.proto $^if cythoncompilingincpython  pyversionhex  0x000000a0$^define pyxsetnameinclassns name value$^    likelypydictcheckexactns  pydictsetitemknownhashns name value pyasciiobject  namehash  pyobjectsetitemns name value$^elif cythoncompilingincpython$^define pyxsetnameinclassns name value$^    likelypydictcheckexactns  pydictsetitemns name value  pyobjectsetitemns name value$^else$^define pyxsetnameinclassns name value  pyobjectsetitemns name value$^endif$^$^ clineintraceback.proto $^ifdef cythonclineintraceback$^define pyxclinefortracebacktstate cline  cythonclineintraceback  cline  0$^else$^static int pyxclinefortracebackpythreadstate tstate int cline$^endif$^$^ codeobjectcache.proto $^typedef struct $^    pycodeobject codeobject$^    int codeline$^ pyxcodeobjectcacheentry$^struct pyxcodeobjectcache $^    int count$^    int maxcount$^    pyxcodeobjectcacheentry entries$^$^static struct pyxcodeobjectcache pyxcodecache  00null$^static int pyxbisectcodeobjectspyxcodeobjectcacheentry entries int count int codeline$^static pycodeobject pyxfindcodeobjectint codeline$^static void pyxinsertcodeobjectint codeline pycodeobject codeobject$^$^ addtraceback.proto $^static void pyxaddtracebackconst char funcname int cline$^                               int pyline const char filename$^$^ none.proto $^include new$^$^ cinttopy.proto $^static cythoninline pyobject pyxpyintfromintint value$^$^ cinttopy.proto $^static cythoninline pyobject pyxpyintfromuint00tuint00t value$^$^ cinttopy.proto $^static cythoninline pyobject pyxpyintfromuint00tuint00t value$^$^ cinttopy.proto $^static cythoninline pyobject pyxpyintfromint00tint00t value$^$^ cinttopy.proto $^static cythoninline pyobject pyxpyintfromint00tint00t value$^$^ cppexceptionconversion.proto $^ifndef pyxcppexn0pyerr$^include new$^include typeinfo$^include stdexcept$^include ios$^static void pyxcppexn0pyerr $^  try $^    if pyerroccurred$^        let the latest python exn pass through and ignore the current one$^    else$^      throw$^   catch const stdbadalloc exn $^    pyerrsetstringpyexcmemoryerror exn.what$^   catch const stdbadcast exn $^    pyerrsetstringpyexctypeerror exn.what$^   catch const stdbadtypeid exn $^    pyerrsetstringpyexctypeerror exn.what$^   catch const stddomainerror exn $^    pyerrsetstringpyexcvalueerror exn.what$^   catch const stdinvalidargument exn $^    pyerrsetstringpyexcvalueerror exn.what$^   catch const stdiosbasefailure exn $^    pyerrsetstringpyexcioerror exn.what$^   catch const stdoutofrange exn $^    pyerrsetstringpyexcindexerror exn.what$^   catch const stdoverflowerror exn $^    pyerrsetstringpyexcoverflowerror exn.what$^   catch const stdrangeerror exn $^    pyerrsetstringpyexcarithmeticerror exn.what$^   catch const stdunderflowerror exn $^    pyerrsetstringpyexcarithmeticerror exn.what$^   catch const stdexception exn $^    pyerrsetstringpyexcruntimeerror exn.what$^  $^  catch ...$^  $^    pyerrsetstringpyexcruntimeerror unknown exception$^  $^$^endif$^$^ cintfrompy.proto $^static cythoninline sizet pyxpyintassizetpyobject $^$^ cintfrompy.proto $^static cythoninline int00t pyxpyintasint00tpyobject $^$^ cintfrompy.proto $^static cythoninline uint00t pyxpyintasuint00tpyobject $^$^ cintfrompy.proto $^static cythoninline int00t pyxpyintasint00tpyobject $^$^ cintfrompy.proto $^static cythoninline uint00t pyxpyintasuint00tpyobject $^$^ cintfrompy.proto $^static cythoninline timet pyxpyintastimetpyobject $^$^ cinttopy.proto $^static cythoninline pyobject pyxpyintfromlonglong value$^$^ cintfrompy.proto $^static cythoninline long pyxpyintaslongpyobject $^$^ cintfrompy.proto $^static cythoninline int pyxpyintasintpyobject $^$^ checkbinaryversion.proto $^static int pyxcheckbinaryversionvoid$^$^ functionexport.proto $^static int pyxexportfunctionconst char name void fvoid const char sig$^$^ initstrings.proto $^static int pyxinitstringspyxstringtabentry t$^$^static void pyxf0pywrapfst0weightcheckweightstruct pyxobj0pywrapfstweight pyxvself  proto$^static struct pyxobj0pywrapfstweight pyxf0pywrapfst0weightcopystruct pyxobj0pywrapfstweight pyxvself int pyxskipdispatch  proto$^static stdstring pyxf0pywrapfst0weighttostringstruct pyxobj0pywrapfstweight pyxvself int pyxskipdispatch  proto$^static stdstring pyxf0pywrapfst0weighttypestruct pyxobj0pywrapfstweight pyxvself int pyxskipdispatch  proto$^static pyxt00basictypesint00 pyxf0pywrapfst00symboltableavailablekeystruct pyxobj0pywrapfstsymboltable pyxvself int pyxskipdispatch  proto$^static stdstring pyxf0pywrapfst00symboltablechecksumstruct pyxobj0pywrapfstsymboltable pyxvself int pyxskipdispatch  proto$^static struct pyxobj0pywrapfstsymboltable pyxf0pywrapfst00symboltablecopystruct pyxobj0pywrapfstsymboltable pyxvself int pyxskipdispatch  proto$^static pyxt00basictypesint00 pyxf0pywrapfst00symboltablegetnthkeystruct pyxobj0pywrapfstsymboltable pyxvself pyssizet pyxvpos int pyxskipdispatch  proto$^static stdstring pyxf0pywrapfst00symboltablelabeledchecksumstruct pyxobj0pywrapfstsymboltable pyxvself int pyxskipdispatch  proto$^static bool pyxf0pywrapfst00symboltablememberstruct pyxobj0pywrapfstsymboltable pyxvself pyobject pyxvkey int pyxskipdispatch  proto$^static stdstring pyxf0pywrapfst00symboltablenamestruct pyxobj0pywrapfstsymboltable pyxvself int pyxskipdispatch  proto$^static sizet pyxf0pywrapfst00symboltablenumsymbolsstruct pyxobj0pywrapfstsymboltable pyxvself int pyxskipdispatch  proto$^static void pyxf0pywrapfst00symboltablewritestruct pyxobj0pywrapfstsymboltable pyxvself pyobject pyxvfilename int pyxskipdispatch  proto$^static void pyxf0pywrapfst00symboltablewritetextstruct pyxobj0pywrapfstsymboltable pyxvself pyobject pyxvfilename int pyxskipdispatch  proto$^static pyxt00basictypesint00 pyxf0pywrapfst00mutablesymboltableaddsymbolstruct pyxobj0pywrapfstmutablesymboltable pyxvself pyobject pyxvsymbol int pyxskipdispatch struct pyxoptargs0pywrapfst00mutablesymboltableaddsymbol pyxoptionalargs  proto$^static void pyxf0pywrapfst00mutablesymboltableaddtablestruct pyxobj0pywrapfstmutablesymboltable pyxvself struct pyxobj0pywrapfstsymboltable pyxvsyms int pyxskipdispatch  proto$^static void pyxf0pywrapfst00mutablesymboltablesetnamestruct pyxobj0pywrapfstmutablesymboltable pyxvself pyobject pyxvnewname int pyxskipdispatch  proto$^static bool pyxf0pywrapfst00symboltableiteratordonestruct pyxobj0pywrapfstsymboltableiterator pyxvself int pyxskipdispatch  proto$^static void pyxf0pywrapfst00symboltableiteratornextstruct pyxobj0pywrapfstsymboltableiterator pyxvself int pyxskipdispatch  proto$^static void pyxf0pywrapfst00symboltableiteratorresetstruct pyxobj0pywrapfstsymboltableiterator pyxvself int pyxskipdispatch  proto$^static stdstring pyxf0pywrapfst00symboltableiteratorsymbolstruct pyxobj0pywrapfstsymboltableiterator pyxvself int pyxskipdispatch  proto$^static pyxt00basictypesint00 pyxf0pywrapfst00symboltableiteratorvaluestruct pyxobj0pywrapfstsymboltableiterator pyxvself int pyxskipdispatch  proto$^static stdstring pyxf0pywrapfst00encodemapperarctypestruct pyxobj0pywrapfstencodemapper pyxvself int pyxskipdispatch  proto$^static pyxt00basictypesuint00 pyxf0pywrapfst00encodemapperflagsstruct pyxobj0pywrapfstencodemapper pyxvself int pyxskipdispatch  proto$^static struct pyxobj0pywrapfstencodemappersymboltable pyxf0pywrapfst00encodemapperinputsymbolsstruct pyxobj0pywrapfstencodemapper pyxvself int pyxskipdispatch  proto$^static struct pyxobj0pywrapfstencodemappersymboltable pyxf0pywrapfst00encodemapperoutputsymbolsstruct pyxobj0pywrapfstencodemapper pyxvself int pyxskipdispatch  proto$^static pyxt00basictypesuint00 pyxf0pywrapfst00encodemapperpropertiesstruct pyxobj0pywrapfstencodemapper pyxvself pyxt00basictypesuint00 pyxvmask int pyxskipdispatch  proto$^static void pyxf0pywrapfst00encodemappersetinputsymbolsstruct pyxobj0pywrapfstencodemapper pyxvself struct pyxobj0pywrapfstsymboltable pyxvsyms int pyxskipdispatch  proto$^static void pyxf0pywrapfst00encodemappersetoutputsymbolsstruct pyxobj0pywrapfstencodemapper pyxvself struct pyxobj0pywrapfstsymboltable pyxvsyms int pyxskipdispatch  proto$^static stdstring pyxf0pywrapfst00encodemapperweighttypestruct pyxobj0pywrapfstencodemapper pyxvself int pyxskipdispatch  proto$^static stdstring pyxf0pywrapfst0fstarctypestruct pyxobj0pywrapfstfst pyxvself int pyxskipdispatch  proto$^static struct pyxobj0pywrapfstarciterator pyxf0pywrapfst0fstarcsstruct pyxobj0pywrapfstfst pyxvself pyxt00basictypesint00 pyxvstate int pyxskipdispatch  proto$^static struct pyxobj0pywrapfstfst pyxf0pywrapfst0fstcopystruct pyxobj0pywrapfstfst pyxvself int pyxskipdispatch  proto$^static void pyxf0pywrapfst0fstdrawstruct pyxobj0pywrapfstfst pyxvself pyobject pyxvfilename int pyxskipdispatch struct pyxoptargs0pywrapfst0fstdraw pyxoptionalargs  proto$^static struct pyxobj0pywrapfstweight pyxf0pywrapfst0fstfinalstruct pyxobj0pywrapfstfst pyxvself pyxt00basictypesint00 pyxvstate int pyxskipdispatch  proto$^static stdstring pyxf0pywrapfst0fstfsttypestruct pyxobj0pywrapfstfst pyxvself int pyxskipdispatch  proto$^static struct pyxobj0pywrapfstfstsymboltable pyxf0pywrapfst0fstinputsymbolsstruct pyxobj0pywrapfstfst pyxvself int pyxskipdispatch  proto$^static sizet pyxf0pywrapfst0fstnumarcsstruct pyxobj0pywrapfstfst pyxvself pyxt00basictypesint00 pyxvstate int pyxskipdispatch  proto$^static sizet pyxf0pywrapfst0fstnuminputepsilonsstruct pyxobj0pywrapfstfst pyxvself pyxt00basictypesint00 pyxvstate int pyxskipdispatch  proto$^static sizet pyxf0pywrapfst0fstnumoutputepsilonsstruct pyxobj0pywrapfstfst pyxvself pyxt00basictypesint00 pyxvstate int pyxskipdispatch  proto$^static struct pyxobj0pywrapfstfstsymboltable pyxf0pywrapfst0fstoutputsymbolsstruct pyxobj0pywrapfstfst pyxvself int pyxskipdispatch  proto$^static pyxt00basictypesuint00 pyxf0pywrapfst0fstpropertiesstruct pyxobj0pywrapfstfst pyxvself pyxt00basictypesuint00 pyxvmask bool pyxvtest int pyxskipdispatch  proto$^static pyxt00basictypesint00 pyxf0pywrapfst0fststartstruct pyxobj0pywrapfstfst pyxvself int pyxskipdispatch  proto$^static struct pyxobj0pywrapfststateiterator pyxf0pywrapfst0fststatesstruct pyxobj0pywrapfstfst pyxvself int pyxskipdispatch  proto$^static stdstring pyxf0pywrapfst0fsttextstruct pyxobj0pywrapfstfst pyxvself int pyxskipdispatch struct pyxoptargs0pywrapfst0fsttext pyxoptionalargs  proto$^static bool pyxf0pywrapfst0fstverifystruct pyxobj0pywrapfstfst pyxvself int pyxskipdispatch  proto$^static stdstring pyxf0pywrapfst0fstweighttypestruct pyxobj0pywrapfstfst pyxvself int pyxskipdispatch  proto$^static void pyxf0pywrapfst0fstwritestruct pyxobj0pywrapfstfst pyxvself pyobject pyxvfilename int pyxskipdispatch  proto$^static stdstring pyxf0pywrapfst0fstwritetostringstruct pyxobj0pywrapfstfst pyxvself int pyxskipdispatch  proto$^static void pyxf0pywrapfst00mutablefstcheckmutatingimethodstruct pyxobj0pywrapfstmutablefst pyxvself  proto$^static void pyxf0pywrapfst00mutablefstaddarcstruct pyxobj0pywrapfstmutablefst pyxvself pyxt00basictypesint00 pyxvstate struct pyxobj0pywrapfstarc pyxvarc  proto$^static pyxt00basictypesint00 pyxf0pywrapfst00mutablefstaddstatestruct pyxobj0pywrapfstmutablefst pyxvself int pyxskipdispatch  proto$^static void pyxf0pywrapfst00mutablefstarcsortstruct pyxobj0pywrapfstmutablefst pyxvself struct pyxoptargs0pywrapfst00mutablefstarcsort pyxoptionalargs  proto$^static void pyxf0pywrapfst00mutablefstclosurestruct pyxobj0pywrapfstmutablefst pyxvself struct pyxoptargs0pywrapfst00mutablefstclosure pyxoptionalargs  proto$^static void pyxf0pywrapfst00mutablefstconcatstruct pyxobj0pywrapfstmutablefst pyxvself struct pyxobj0pywrapfstfst pyxvifst  proto$^static void pyxf0pywrapfst00mutablefstconnectstruct pyxobj0pywrapfstmutablefst pyxvself  proto$^static void pyxf0pywrapfst00mutablefstdecodestruct pyxobj0pywrapfstmutablefst pyxvself struct pyxobj0pywrapfstencodemapper pyxvencoder  proto$^static void pyxf0pywrapfst00mutablefstdeletearcsstruct pyxobj0pywrapfstmutablefst pyxvself pyxt00basictypesint00 pyxvstate struct pyxoptargs0pywrapfst00mutablefstdeletearcs pyxoptionalargs  proto$^static void pyxf0pywrapfst00mutablefstdeletestatesstruct pyxobj0pywrapfstmutablefst pyxvself struct pyxoptargs0pywrapfst00mutablefstdeletestates pyxoptionalargs  proto$^static void pyxf0pywrapfst00mutablefstencodestruct pyxobj0pywrapfstmutablefst pyxvself struct pyxobj0pywrapfstencodemapper pyxvencoder  proto$^static void pyxf0pywrapfst00mutablefstinvertstruct pyxobj0pywrapfstmutablefst pyxvself  proto$^static void pyxf0pywrapfst00mutablefstminimizestruct pyxobj0pywrapfstmutablefst pyxvself struct pyxoptargs0pywrapfst00mutablefstminimize pyxoptionalargs  proto$^static struct pyxobj0pywrapfstmutablearciterator pyxf0pywrapfst00mutablefstmutablearcsstruct pyxobj0pywrapfstmutablefst pyxvself pyxt00basictypesint00 pyxvstate int pyxskipdispatch  proto$^static pyxt00basictypesint00 pyxf0pywrapfst00mutablefstnumstatesstruct pyxobj0pywrapfstmutablefst pyxvself int pyxskipdispatch  proto$^static void pyxf0pywrapfst00mutablefstprojectstruct pyxobj0pywrapfstmutablefst pyxvself struct pyxoptargs0pywrapfst00mutablefstproject pyxoptionalargs  proto$^static void pyxf0pywrapfst00mutablefstprunestruct pyxobj0pywrapfstmutablefst pyxvself struct pyxoptargs0pywrapfst00mutablefstprune pyxoptionalargs  proto$^static void pyxf0pywrapfst00mutablefstpushstruct pyxobj0pywrapfstmutablefst pyxvself struct pyxoptargs0pywrapfst00mutablefstpush pyxoptionalargs  proto$^static void pyxf0pywrapfst00mutablefstrelabelpairsstruct pyxobj0pywrapfstmutablefst pyxvself struct pyxoptargs0pywrapfst00mutablefstrelabelpairs pyxoptionalargs  proto$^static void pyxf0pywrapfst00mutablefstrelabeltablesstruct pyxobj0pywrapfstmutablefst pyxvself struct pyxoptargs0pywrapfst00mutablefstrelabeltables pyxoptionalargs  proto$^static void pyxf0pywrapfst00mutablefstreservearcsstruct pyxobj0pywrapfstmutablefst pyxvself pyxt00basictypesint00 pyxvstate sizet pyxvn  proto$^static void pyxf0pywrapfst00mutablefstreservestatesstruct pyxobj0pywrapfstmutablefst pyxvself pyxt00basictypesint00 pyxvn  proto$^static void pyxf0pywrapfst00mutablefstreweightstruct pyxobj0pywrapfstmutablefst pyxvself pyobject pyxvpotentials struct pyxoptargs0pywrapfst00mutablefstreweight pyxoptionalargs  proto$^static void pyxf0pywrapfst00mutablefstrmepsilonstruct pyxobj0pywrapfstmutablefst pyxvself struct pyxoptargs0pywrapfst00mutablefstrmepsilon pyxoptionalargs  proto$^static void pyxf0pywrapfst00mutablefstsetfinalstruct pyxobj0pywrapfstmutablefst pyxvself pyxt00basictypesint00 pyxvstate struct pyxoptargs0pywrapfst00mutablefstsetfinal pyxoptionalargs  proto$^static void pyxf0pywrapfst00mutablefstsetinputsymbolsstruct pyxobj0pywrapfstmutablefst pyxvself struct pyxobj0pywrapfstsymboltable pyxvsyms  proto$^static void pyxf0pywrapfst00mutablefstsetoutputsymbolsstruct pyxobj0pywrapfstmutablefst pyxvself struct pyxobj0pywrapfstsymboltable pyxvsyms  proto$^static void pyxf0pywrapfst00mutablefstsetpropertiesstruct pyxobj0pywrapfstmutablefst pyxvself pyxt00basictypesuint00 pyxvprops pyxt00basictypesuint00 pyxvmask  proto$^static void pyxf0pywrapfst00mutablefstsetstartstruct pyxobj0pywrapfstmutablefst pyxvself pyxt00basictypesint00 pyxvstate  proto$^static void pyxf0pywrapfst00mutablefsttopsortstruct pyxobj0pywrapfstmutablefst pyxvself  proto$^static void pyxf0pywrapfst00mutablefstunionstruct pyxobj0pywrapfstmutablefst pyxvself struct pyxobj0pywrapfstfst pyxvifst  proto$^static struct pyxobj0pywrapfstarc pyxf0pywrapfst0arccopystruct pyxobj0pywrapfstarc pyxvself int pyxskipdispatch  proto$^static bool pyxf0pywrapfst00arciteratordonestruct pyxobj0pywrapfstarciterator pyxvself int pyxskipdispatch  proto$^static pyxt00basictypesuint00 pyxf0pywrapfst00arciteratorflagsstruct pyxobj0pywrapfstarciterator pyxvself int pyxskipdispatch  proto$^static void pyxf0pywrapfst00arciteratornextstruct pyxobj0pywrapfstarciterator pyxvself int pyxskipdispatch  proto$^static sizet pyxf0pywrapfst00arciteratorpositionstruct pyxobj0pywrapfstarciterator pyxvself int pyxskipdispatch  proto$^static void pyxf0pywrapfst00arciteratorresetstruct pyxobj0pywrapfstarciterator pyxvself int pyxskipdispatch  proto$^static void pyxf0pywrapfst00arciteratorseekstruct pyxobj0pywrapfstarciterator pyxvself sizet pyxva int pyxskipdispatch  proto$^static void pyxf0pywrapfst00arciteratorsetflagsstruct pyxobj0pywrapfstarciterator pyxvself pyxt00basictypesuint00 pyxvflags pyxt00basictypesuint00 pyxvmask int pyxskipdispatch  proto$^static pyobject pyxf0pywrapfst00arciteratorvaluestruct pyxobj0pywrapfstarciterator pyxvself int pyxskipdispatch  proto$^static bool pyxf0pywrapfst00mutablearciteratordonestruct pyxobj0pywrapfstmutablearciterator pyxvself int pyxskipdispatch  proto$^static pyxt00basictypesuint00 pyxf0pywrapfst00mutablearciteratorflagsstruct pyxobj0pywrapfstmutablearciterator pyxvself int pyxskipdispatch  proto$^static void pyxf0pywrapfst00mutablearciteratornextstruct pyxobj0pywrapfstmutablearciterator pyxvself int pyxskipdispatch  proto$^static sizet pyxf0pywrapfst00mutablearciteratorpositionstruct pyxobj0pywrapfstmutablearciterator pyxvself int pyxskipdispatch  proto$^static void pyxf0pywrapfst00mutablearciteratorresetstruct pyxobj0pywrapfstmutablearciterator pyxvself int pyxskipdispatch  proto$^static void pyxf0pywrapfst00mutablearciteratorseekstruct pyxobj0pywrapfstmutablearciterator pyxvself sizet pyxva int pyxskipdispatch  proto$^static void pyxf0pywrapfst00mutablearciteratorsetflagsstruct pyxobj0pywrapfstmutablearciterator pyxvself pyxt00basictypesuint00 pyxvflags pyxt00basictypesuint00 pyxvmask int pyxskipdispatch  proto$^static void pyxf0pywrapfst00mutablearciteratorsetvaluestruct pyxobj0pywrapfstmutablearciterator pyxvself struct pyxobj0pywrapfstarc pyxvarc int pyxskipdispatch  proto$^static pyobject pyxf0pywrapfst00mutablearciteratorvaluestruct pyxobj0pywrapfstmutablearciterator pyxvself int pyxskipdispatch  proto$^static bool pyxf0pywrapfst00stateiteratordonestruct pyxobj0pywrapfststateiterator pyxvself int pyxskipdispatch  proto$^static void pyxf0pywrapfst00stateiteratornextstruct pyxobj0pywrapfststateiterator pyxvself int pyxskipdispatch  proto$^static void pyxf0pywrapfst00stateiteratorresetstruct pyxobj0pywrapfststateiterator pyxvself int pyxskipdispatch  proto$^static pyxt00basictypesint00 pyxf0pywrapfst00stateiteratorvaluestruct pyxobj0pywrapfststateiterator pyxvself int pyxskipdispatch  proto$^static struct pyxobj0pywrapfstfst pyxf0pywrapfst0compilercompilestruct pyxobj0pywrapfstcompiler pyxvself int pyxskipdispatch  proto$^static void pyxf0pywrapfst0compilerwritestruct pyxobj0pywrapfstcompiler pyxvself pyobject pyxvexpression int pyxskipdispatch  proto$^static stdstring pyxf0pywrapfst0farreaderarctypestruct pyxobj0pywrapfstfarreader pyxvself int pyxskipdispatch  proto$^static bool pyxf0pywrapfst0farreaderdonestruct pyxobj0pywrapfstfarreader pyxvself int pyxskipdispatch  proto$^static bool pyxf0pywrapfst0farreadererrorstruct pyxobj0pywrapfstfarreader pyxvself int pyxskipdispatch  proto$^static stdstring pyxf0pywrapfst0farreaderfartypestruct pyxobj0pywrapfstfarreader pyxvself int pyxskipdispatch  proto$^static bool pyxf0pywrapfst0farreaderfindstruct pyxobj0pywrapfstfarreader pyxvself pyobject pyxvkey int pyxskipdispatch  proto$^static struct pyxobj0pywrapfstfst pyxf0pywrapfst0farreadergetfststruct pyxobj0pywrapfstfarreader pyxvself int pyxskipdispatch  proto$^static stdstring pyxf0pywrapfst0farreadergetkeystruct pyxobj0pywrapfstfarreader pyxvself int pyxskipdispatch  proto$^static void pyxf0pywrapfst0farreadernextstruct pyxobj0pywrapfstfarreader pyxvself int pyxskipdispatch  proto$^static void pyxf0pywrapfst0farreaderresetstruct pyxobj0pywrapfstfarreader pyxvself int pyxskipdispatch  proto$^static void pyxf0pywrapfst0farwriterclosestruct pyxobj0pywrapfstfarwriter pyxvself  proto$^static void pyxf0pywrapfst0farwriteraddstruct pyxobj0pywrapfstfarwriter pyxvself pyobject pyxvkey struct pyxobj0pywrapfstfst pyxvifst int pyxskipdispatch  proto$^static stdstring pyxf0pywrapfst0farwriterarctypestruct pyxobj0pywrapfstfarwriter pyxvself int pyxskipdispatch  proto$^static bool pyxf0pywrapfst0farwritererrorstruct pyxobj0pywrapfstfarwriter pyxvself int pyxskipdispatch  proto$^static stdstring pyxf0pywrapfst0farwriterfartypestruct pyxobj0pywrapfstfarwriter pyxvself int pyxskipdispatch  proto$^$^ module declarations from libc.stddef $^$^ module declarations from libc.time $^$^ module declarations from libcpp $^$^ module declarations from libcpp.memory $^$^ module declarations from libcpp.utility $^$^ module declarations from libcpp.vector $^$^ module declarations from libc.string $^$^ module declarations from libcpp.string $^$^ module declarations from libc.stdint $^$^ module declarations from basictypes $^$^ module declarations from ios $^$^ module declarations from fst $^$^ module declarations from posix.types $^$^ module declarations from posix.unistd $^$^ module declarations from libcpp.cast $^$^ module declarations from memory $^$^ module declarations from pywrapfst $^static pytypeobject pyxptype0pywrapfstweight  0$^static pytypeobject pyxptype0pywrapfstsymboltable  0$^static pytypeobject pyxptype0pywrapfstencodemappersymboltable  0$^static pytypeobject pyxptype0pywrapfstfstsymboltable  0$^static pytypeobject pyxptype0pywrapfstmutablesymboltable  0$^static pytypeobject pyxptype0pywrapfstmutablefstsymboltable  0$^static pytypeobject pyxptype0pywrapfstsymboltable  0$^static pytypeobject pyxptype0pywrapfstsymboltableiterator  0$^static pytypeobject pyxptype0pywrapfstencodemapper  0$^static pytypeobject pyxptype0pywrapfstfst  0$^static pytypeobject pyxptype0pywrapfstmutablefst  0$^static pytypeobject pyxptype0pywrapfstarc  0$^static pytypeobject pyxptype0pywrapfstarciterator  0$^static pytypeobject pyxptype0pywrapfstmutablearciterator  0$^static pytypeobject pyxptype0pywrapfststateiterator  0$^static pytypeobject pyxptype0pywrapfstcompiler  0$^static pytypeobject pyxptype0pywrapfstfarreader  0$^static pytypeobject pyxptype0pywrapfstfarwriter  0$^static stdstring pyxf0pywrapfsttostringpyobject  struct pyxoptargs0pywrapfsttostring pyxoptionalargs proto$^static stdstring pyxf0pywrapfstweighttostringpyobject  struct pyxoptargs0pywrapfstweighttostring pyxoptionalargs proto$^static enum fstcomposefilter pyxf0pywrapfstgetcomposefilterstdstring const  proto$^static enum fstqueuetype pyxf0pywrapfstgetqueuetypestdstring const  proto$^static enum fstscriptrandarcselection pyxf0pywrapfstgetrandarcselectionstdstring const  proto$^static enum fstreplacelabeltype pyxf0pywrapfstgetreplacelabeltypestdstring const  bool proto$^static fstscriptweightclass pyxf0pywrapfstgetweightclassoronestdstring const  pyobject  proto$^static fstscriptweightclass pyxf0pywrapfstgetweightclassorzerostdstring const  pyobject  proto$^static struct pyxobj0pywrapfstweight pyxf0pywrapfstzeropyobject  proto$^static struct pyxobj0pywrapfstweight pyxf0pywrapfstonepyobject  proto$^static struct pyxobj0pywrapfstweight pyxf0pywrapfstnoweightpyobject  proto$^static struct pyxobj0pywrapfstweight pyxf0pywrapfstplusstruct pyxobj0pywrapfstweight  struct pyxobj0pywrapfstweight  proto$^static struct pyxobj0pywrapfstweight pyxf0pywrapfsttimesstruct pyxobj0pywrapfstweight  struct pyxobj0pywrapfstweight  proto$^static struct pyxobj0pywrapfstweight pyxf0pywrapfstdividestruct pyxobj0pywrapfstweight  struct pyxobj0pywrapfstweight  proto$^static struct pyxobj0pywrapfstweight pyxf0pywrapfstpowerstruct pyxobj0pywrapfstweight  sizet proto$^static struct pyxobj0pywrapfstencodemappersymboltable pyxf0pywrapfstinitencodemappersymboltablefstsymboltable  stdsharedptrfstscriptencodemapperclass  proto$^static struct pyxobj0pywrapfstfstsymboltable pyxf0pywrapfstinitfstsymboltablefstsymboltable  stdsharedptrfstscriptfstclass  proto$^static struct pyxobj0pywrapfstmutablefstsymboltable pyxf0pywrapfstinitmutablefstsymboltablefstsymboltable  stdsharedptrfstscriptmutablefstclass  proto$^static struct pyxobj0pywrapfstsymboltable pyxf0pywrapfstinitsymboltablefstsymboltable  proto$^static struct pyxobj0pywrapfstfst pyxf0pywrapfstinitfstpyxt0pywrapfstfstclassptr proto$^static struct pyxobj0pywrapfstmutablefst pyxf0pywrapfstinitmutablefstpyxt0pywrapfstmutablefstclassptr proto$^static struct pyxobj0pywrapfstfst pyxf0pywrapfstinitxfstpyxt0pywrapfstfstclassptr proto$^static struct pyxobj0pywrapfstmutablefst pyxf0pywrapfstcreatefststruct pyxoptargs0pywrapfstcreatefst pyxoptionalargs proto$^static struct pyxobj0pywrapfstfst pyxf0pywrapfstreadpyobject  int pyxskipdispatch proto$^static struct pyxobj0pywrapfstfst pyxf0pywrapfstreadfromstringpyobject  int pyxskipdispatch proto$^static struct pyxobj0pywrapfstarc pyxf0pywrapfstinitarcfstscriptarcclass const  proto$^static struct pyxobj0pywrapfstfst pyxf0pywrapfstmapstruct pyxobj0pywrapfstfst  struct pyxoptargs0pywrapfstmap pyxoptionalargs proto$^static struct pyxobj0pywrapfstfst pyxf0pywrapfstarcmapstruct pyxobj0pywrapfstfst  int pyxskipdispatch struct pyxoptargs0pywrapfstarcmap pyxoptionalargs proto$^static struct pyxobj0pywrapfstmutablefst pyxf0pywrapfstcomposestruct pyxobj0pywrapfstfst  struct pyxobj0pywrapfstfst  int pyxskipdispatch struct pyxoptargs0pywrapfstcompose pyxoptionalargs proto$^static struct pyxobj0pywrapfstfst pyxf0pywrapfstconvertstruct pyxobj0pywrapfstfst  int pyxskipdispatch struct pyxoptargs0pywrapfstconvert pyxoptionalargs proto$^static struct pyxobj0pywrapfstmutablefst pyxf0pywrapfstdeterminizestruct pyxobj0pywrapfstfst  int pyxskipdispatch struct pyxoptargs0pywrapfstdeterminize pyxoptionalargs proto$^static struct pyxobj0pywrapfstmutablefst pyxf0pywrapfstdifferencestruct pyxobj0pywrapfstfst  struct pyxobj0pywrapfstfst  int pyxskipdispatch struct pyxoptargs0pywrapfstdifference pyxoptionalargs proto$^static struct pyxobj0pywrapfstmutablefst pyxf0pywrapfstdisambiguatestruct pyxobj0pywrapfstfst  int pyxskipdispatch struct pyxoptargs0pywrapfstdisambiguate pyxoptionalargs proto$^static struct pyxobj0pywrapfstmutablefst pyxf0pywrapfstepsnormalizestruct pyxobj0pywrapfstfst  int pyxskipdispatch struct pyxoptargs0pywrapfstepsnormalize pyxoptionalargs proto$^static bool pyxf0pywrapfstequalstruct pyxobj0pywrapfstfst  struct pyxobj0pywrapfstfst  int pyxskipdispatch struct pyxoptargs0pywrapfstequal pyxoptionalargs proto$^static bool pyxf0pywrapfstequivalentstruct pyxobj0pywrapfstfst  struct pyxobj0pywrapfstfst  int pyxskipdispatch struct pyxoptargs0pywrapfstequivalent pyxoptionalargs proto$^static struct pyxobj0pywrapfstmutablefst pyxf0pywrapfstintersectstruct pyxobj0pywrapfstfst  struct pyxobj0pywrapfstfst  int pyxskipdispatch struct pyxoptargs0pywrapfstintersect pyxoptionalargs proto$^static bool pyxf0pywrapfstisomorphicstruct pyxobj0pywrapfstfst  struct pyxobj0pywrapfstfst  int pyxskipdispatch struct pyxoptargs0pywrapfstisomorphic pyxoptionalargs proto$^static struct pyxobj0pywrapfstmutablefst pyxf0pywrapfstprunestruct pyxobj0pywrapfstfst  int pyxskipdispatch struct pyxoptargs0pywrapfstprune pyxoptionalargs proto$^static struct pyxobj0pywrapfstmutablefst pyxf0pywrapfstpushstruct pyxobj0pywrapfstfst  int pyxskipdispatch struct pyxoptargs0pywrapfstpush pyxoptionalargs proto$^static bool pyxf0pywrapfstrandequivalentstruct pyxobj0pywrapfstfst  struct pyxobj0pywrapfstfst  int pyxskipdispatch struct pyxoptargs0pywrapfstrandequivalent pyxoptionalargs proto$^static struct pyxobj0pywrapfstmutablefst pyxf0pywrapfstrandgenstruct pyxobj0pywrapfstfst  int pyxskipdispatch struct pyxoptargs0pywrapfstrandgen pyxoptionalargs proto$^static struct pyxobj0pywrapfstmutablefst pyxf0pywrapfstreplacepyobject  int pyxskipdispatch struct pyxoptargs0pywrapfstreplace pyxoptionalargs proto$^static struct pyxobj0pywrapfstmutablefst pyxf0pywrapfstreversestruct pyxobj0pywrapfstfst  int pyxskipdispatch struct pyxoptargs0pywrapfstreverse pyxoptionalargs proto$^static stdvectorfstscriptweightclass  pyxf0pywrapfstshortestdistancestruct pyxobj0pywrapfstfst  struct pyxoptargs0pywrapfstshortestdistance pyxoptionalargs proto$^static struct pyxobj0pywrapfstmutablefst pyxf0pywrapfstshortestpathstruct pyxobj0pywrapfstfst  int pyxskipdispatch struct pyxoptargs0pywrapfstshortestpath pyxoptionalargs proto$^static struct pyxobj0pywrapfstfst pyxf0pywrapfststatemapstruct pyxobj0pywrapfstfst  pyobject  int pyxskipdispatch proto$^static struct pyxobj0pywrapfstmutablefst pyxf0pywrapfstsynchronizestruct pyxobj0pywrapfstfst  int pyxskipdispatch proto$^static struct pyxobj0pywrapfstsymboltable pyxf0pywrapfstcompactsymboltablestruct pyxobj0pywrapfstsymboltable  int pyxskipdispatch proto$^static struct pyxobj0pywrapfstsymboltable pyxf0pywrapfstmergesymboltablestruct pyxobj0pywrapfstsymboltable  struct pyxobj0pywrapfstsymboltable  int pyxskipdispatch proto$^static stdstring pyxconvertstringfrompystdinstringpyobject  proto$^static cythoninline pyobject pyxconvertpyobjectstringtopystdinstringstdstring const  proto$^static cythoninline pyobject pyxconvertpyunicodestringtopystdinstringstdstring const  proto$^static cythoninline pyobject pyxconvertpystrstringtopystdinstringstdstring const  proto$^static cythoninline pyobject pyxconvertpybytesstringtopystdinstringstdstring const  proto$^static cythoninline pyobject pyxconvertpybytearraystringtopystdinstringstdstring const  proto$^static stdvectorpyxt00basictypesint00  pyxconvertvectorfrompypyxt00basictypesint00pyobject  proto$^static stdvectorstdstring  pyxconvertvectorfrompystd0a0astringpyobject  proto$^define pyxmodulename pywrapfst$^extern int pyxmoduleismainpywrapfst$^int pyxmoduleismainpywrapfst  0$^$^ implementation of pywrapfst $^static pyobject pyxbuiltinvalueerror$^static pyobject pyxbuiltinruntimeerror$^static pyobject pyxbuiltinindexerror$^static pyobject pyxbuiltinioerror$^static pyobject pyxbuiltinobject$^static pyobject pyxbuiltinstaticmethod$^static pyobject pyxbuiltinid$^static pyobject pyxbuiltintypeerror$^static pyobject pyxbuiltinstopiteration$^static pyobject pyxbuiltinkeyerror$^static const char pyxkg  g$^static const char pyxkn  n$^static const char pyxkw  w$^static const char pyxkid  id$^static const char pyxkfst  fst$^static const char pyxkone  one$^static const char pyxk00  $^static const char pyxkadd  add$^static const char pyxkarc  arc$^static const char pyxkcls  cls$^static const char pyxkdoc  doc$^static const char pyxkdot  dot$^static const char pyxkkey  key$^static const char pyxklhs  lhs$^static const char pyxknew  new$^static const char pyxkrhs  rhs$^static const char pyxkpipe  pipe$^static const char pyxktsvg  tsvg$^static const char pyxkzero  zero$^static const char pyxkarcs  arcs$^static const char pyxkauto  auto$^static const char pyxkcopy  copy$^static const char pyxkdone  done$^static const char pyxkdraw  draw$^static const char pyxkfind  find$^static const char pyxkifst  ifst$^static const char pyxkmain  main$^static const char pyxkmask  mask$^static const char pyxkname  name$^static const char pyxknext  next$^static const char pyxkopen  open$^static const char pyxkplus  plus$^static const char pyxkread  read$^static const char pyxkseed  seed$^static const char pyxkseek  seek$^static const char pyxksyms  syms$^static const char pyxktest  test$^static const char pyxktext  text$^static const char pyxktype  type$^static const char pyxkutf0  utf0$^static const char pyxkerror  error$^static const char pyxkpopen  popen$^static const char pyxkclass  class$^static const char pyxkdelta  delta$^static const char pyxkerror  error$^static const char pyxkfinal  final$^static const char pyxkflags  flags$^static const char pyxkifst0  ifst0$^static const char pyxkifst0  ifst0$^static const char pyxkinput  input$^static const char pyxknpath  npath$^static const char pyxkpairs  pairs$^static const char pyxkpower  power$^static const char pyxkprops  props$^static const char pyxkreset  reset$^static const char pyxkstart  start$^static const char pyxkstate  state$^static const char pyxkstdin  stdin$^static const char pyxktimes  times$^static const char pyxktitle  title$^static const char pyxkvalue  value$^static const char pyxkwidth  width$^static const char pyxkwrite  write$^static const char pyxkcyclic  cyclic$^static const char pyxknumber  number$^static const char pyxkstring  string$^static const char pyxkatexit  atexit$^static const char pyxkcreate  create$^static const char pyxkdecode  decode$^static const char pyxkdivide  divide$^static const char pyxkencode  encode$^static const char pyxkformat  format$^static const char pyxkheight  height$^static const char pyxkilabel  ilabel$^static const char pyxkimport  import$^static const char pyxkipairs  ipairs$^static const char pyxkmember  member$^static const char pyxkmodule  module$^static const char pyxkname0  name$^static const char pyxknstate  nstate$^static const char pyxkobject  object$^static const char pyxkolabel  olabel$^static const char pyxkopairs  opairs$^static const char pyxkreduce  reduce$^static const char pyxkresult  result$^static const char pyxkselect  select$^static const char pyxkstates  states$^static const char pyxkstderr  stderr$^static const char pyxkstdout  stdout$^static const char pyxksymbol  symbol$^static const char pyxktest0  test$^static const char pyxkunique  unique$^static const char pyxkvector  vector$^static const char pyxkverify  verify$^static const char pyxkweight  weight$^static const char pyxkacyclic  acyclic$^static const char pyxkioerror  ioerror$^static const char pyxkmutable  mutable$^static const char pyxkcompile  compile$^static const char pyxkconnect  connect$^static const char pyxkdefault  default$^static const char pyxkgetfst  getfst$^static const char pyxkgetkey  getkey$^static const char pyxklogging  logging$^static const char pyxkneither  neither$^static const char pyxknodesep  nodesep$^static const char pyxknumbers  numbers$^static const char pyxkprepare  prepare$^static const char pyxkranksep  ranksep$^static const char pyxkreverse  reverse$^static const char pyxkuniform  uniform$^static const char pyxkwarning  warning$^static const char pyxkacceptor  acceptor$^static const char pyxkdottsvg  dottsvg$^static const char pyxkepsilons  epsilons$^static const char pyxkexpanded  expanded$^static const char pyxkfsterror  fsterror$^static const char pyxkfstread  fst.read$^static const char pyxkkeyerror  keyerror$^static const char pyxknolabel  nolabel$^static const char pyxknoweight  noweight$^static const char pyxkweighted  weighted$^static const char pyxkacceptor  acceptor$^static const char pyxkarctype  arctype$^static const char pyxkchecksum  checksum$^static const char pyxkdettype  dettype$^static const char pyxkdistance  distance$^static const char pyxkfartype  fartype$^static const char pyxkfilename  filename$^static const char pyxkfontsize  fontsize$^static const char pyxkfsttype  fsttype$^static const char pyxkgetstate  getstate$^static const char pyxkidentity  identity$^static const char pyxkisymbols  isymbols$^static const char pyxkmaptype  maptype$^static const char pyxknumarcs  numarcs$^static const char pyxkosymbols  osymbols$^static const char pyxkportrait  portrait$^static const char pyxkposition  position$^static const char pyxkqualname  qualname$^static const char pyxkreadfst  readfst$^static const char pyxkregister  register$^static const char pyxkreprsvg  reprsvg$^static const char pyxksetname  setname$^static const char pyxksetstate  setstate$^static const char pyxkssymbols  ssymbols$^static const char pyxkstandard  standard$^static const char pyxktofinal  tofinal$^static const char pyxktropical  tropical$^static const char pyxkvertical  vertical$^static const char pyxkweighted  weighted$^static const char pyxkarcflags  arcflags$^static const char pyxkfstnew  fst.new$^static const char pyxknosymbol  nosymbol$^static const char pyxktypeerror  typeerror$^static const char pyxkaddstate  addstate$^static const char pyxkaddtable  addtable$^static const char pyxkknosymbol  knosymbol$^static const char pyxkmetaclass  metaclass$^static const char pyxknextstate  nextstate$^static const char pyxknshortest  nshortest$^static const char pyxkprecision  precision$^static const char pyxkpywrapfst  pywrapfst$^static const char pyxkreadtext  readtext$^static const char pyxkreduceex  reduceex$^static const char pyxksetflags  setflags$^static const char pyxksetvalue  setvalue$^static const char pyxksorttype  sorttype$^static const char pyxktostring  tostring$^static const char pyxkaccessible  accessible$^static const char pyxkfstioerror  fstioerror$^static const char pyxkfstoperror  fstoperror$^static const char pyxkiepsilons  iepsilons$^static const char pyxkindexerror  indexerror$^static const char pyxknotstring  notstring$^static const char pyxkoepsilons  oepsilons$^static const char pyxktopsorted  topsorted$^static const char pyxkunweighted  unweighted$^static const char pyxkvalueerror  valueerror$^static const char pyxkaddsymbol  addsymbol$^static const char pyxkfunctional  functional$^static const char pyxkmaxlength  maxlength$^static const char pyxknumstates  numstates$^static const char pyxkpotentials  potentials$^static const char pyxkproperties  properties$^static const char pyxkpyxvtable  pyxvtable$^static const char pyxkqueuetype  queuetype$^static const char pyxkreturncode  returncode$^static const char pyxksubprocess  subprocess$^static const char pyxkwritetext  writetext$^static const char pyxkarcat0xx  arc at 0xx$^static const char pyxkfstargerror  fstargerror$^static const char pyxkfstat0xx   fst at 0xx$^static const char pyxknoepsilons  noepsilons$^static const char pyxknostateid  nostateid$^static const char pyxkcommunicate  communicate$^static const char pyxkgetnthkey  getnthkey$^static const char pyxkinputtable  inputtable$^static const char pyxkmissingsym  missingsym$^static const char pyxknumsymbols  numsymbols$^static const char pyxkpushlabels  pushlabels$^static const char pyxkpywrapfst0  pywrapfst$^static const char pyxkunspecified  unspecified$^static const char pyxkweighttype  weighttype$^static const char pyxkarcnocache  arcnocache$^static const char pyxkcoaccessible  coaccessible$^static const char pyxkencodeflags  encodeflags$^static const char pyxknotacceptor  notacceptor$^static const char pyxkruntimeerror  runtimeerror$^static const char pyxkallownondet  allownondet$^static const char pyxkclosureplus  closureplus$^static const char pyxkfloatformat  floatformat$^static const char pyxkmutablearcs  mutablearcs$^static const char pyxknewisymbols  newisymbols$^static const char pyxknewosymbols  newosymbols$^static const char pyxkoldisymbols  oldisymbols$^static const char pyxkoldosymbols  oldosymbols$^static const char pyxkpushweights  pushweights$^static const char pyxkreturnlabel  returnlabel$^static const char pyxkstaticmethod  staticmethod$^static const char pyxkencodelabels  encodelabels$^static const char pyxkfstindexerror  fstindexerror$^static const char pyxknoiepsilons  noiepsilons$^static const char pyxknooepsilons  nooepsilons$^static const char pyxkopenfailedr  open failed r$^static const char pyxkreadfailedr  read failed r$^static const char pyxkstopiteration  stopiteration$^static const char pyxkavailablekey  availablekey$^static const char pyxkencodelabels  encodelabels$^static const char pyxkinputsymbols  inputsymbols$^static const char pyxkkeepisymbols  keepisymbols$^static const char pyxkkeeposymbols  keeposymbols$^static const char pyxkpywrapfstpyx  pywrapfst.pyx$^static const char pyxkreducecython  reducecython$^static const char pyxkencodeweights  encodeweights$^static const char pyxkfstproperties  fstproperties$^static const char pyxkinitialcyclic  initialcyclic$^static const char pyxkilabelsorted  ilabelsorted$^static const char pyxkinvalidweight  invalid weight$^static const char pyxknotaccessible  notaccessible$^static const char pyxknottopsorted  nottopsorted$^static const char pyxkolabelsorted  olabelsorted$^static const char pyxkweightat0xx   weight  at 0xx$^static const char pyxkwritefailedr  write failed r$^static const char pyxkcomposefilter  composefilter$^static const char pyxkencodeweights  encodeweights$^static const char pyxkoutputsymbols  outputsymbols$^static const char pyxkprojectoutput  projectoutput$^static const char pyxkarcvalueflags  arcvalueflags$^static const char pyxkcopyproperties  copyproperties$^static const char pyxkinitialacyclic  initialacyclic$^static const char pyxkideterministic  ideterministic$^static const char pyxknullproperties  nullproperties$^static const char pyxkodeterministic  odeterministic$^static const char pyxkweightedcycles  weightedcycles$^static const char pyxkepsnormoutput  epsnormoutput$^static const char pyxksetstatecython  setstatecython$^static const char pyxkshowweightone  showweightone$^static const char pyxkunknownisymbol  unknownisymbol$^static const char pyxkunknownosymbol  unknownosymbol$^static const char pyxkwritetostring  writetostring$^static const char pyxkarcweightvalue  arcweightvalue$^static const char pyxkcannotconstruct  cannot construct $^static const char pyxkkeyoutoforder  key out of order$^static const char pyxknotcoaccessible  notcoaccessible$^static const char pyxkoperationfailed  operation failed$^static const char pyxklabeledchecksum  labeledchecksum$^static const char pyxkreadfromstring  readfromstring$^static const char pyxkshortestdistance  shortestdistance$^static const char pyxkarcilabelvalue  arcilabelvalue$^static const char pyxkarcolabelvalue  arcolabelvalue$^static const char pyxkbinaryproperties  binaryproperties$^static const char pyxkfarreaderat0xx   farreader at 0xx$^static const char pyxkfarwriterat0xx   farwriter at 0xx$^static const char pyxkfstbadweighterror  fstbadweighterror$^static const char pyxkunweightedcycles  unweightedcycles$^static const char pyxkcallarclabeling  callarclabeling$^static const char pyxksetinputsymbols  setinputsymbols$^static const char pyxkaddarcproperties  addarcproperties$^static const char pyxkcalledprocesserror  calledprocesserror$^static const char pyxkcompilationfailed  compilation failed$^static const char pyxknotilabelsorted  notilabelsorted$^static const char pyxknotolabelsorted  notolabelsorted$^static const char pyxkreadfailedstring  read failed string$^static const char pyxksetarcproperties  setarcproperties$^static const char pyxktrinaryproperties  trinaryproperties$^static const char pyxkunknownarctyper  unknown arc type r$^static const char pyxkunknownmaptyper  unknown map type r$^static const char pyxkclineintraceback  clineintraceback$^static const char pyxkepsilononreplace  epsilononreplace$^static const char pyxknuminputepsilons  numinputepsilons$^static const char pyxkreadfromstring0  readfromstring$^static const char pyxksetoutputsymbols  setoutputsymbols$^static const char pyxkarcsortproperties  arcsortproperties$^static const char pyxkarciteratorat0xx  arciterator at 0xx$^static const char pyxknonideterministic  nonideterministic$^static const char pyxknonodeterministic  nonodeterministic$^static const char pyxkunknownsorttyper  unknown sort type r$^static const char pyxkattachnewisymbols  attachnewisymbols$^static const char pyxkattachnewosymbols  attachnewosymbols$^static const char pyxkfsterrorfatalold  fsterrorfatalold$^static const char pyxknumoutputepsilons  numoutputepsilons$^static const char pyxkremovecommonaffix  removecommonaffix$^static const char pyxkremovetotalweight  removetotalweight$^static const char pyxkreturnarclabeling  returnarclabeling$^static const char pyxksubsequentiallabel  subsequentiallabel$^static const char pyxkaddstateproperties  addstateproperties$^static const char pyxkarcnextstatevalue  arcnextstatevalue$^static const char pyxkextrinsicproperties  extrinsicproperties$^static const char pyxkencodemapperat0xx  encodemapper at 0xx$^static const char pyxkfstreadfromstring  fst.readfromstring$^static const char pyxkintrinsicproperties  intrinsicproperties$^static const char pyxksetfinalproperties  setfinalproperties$^static const char pyxksetstartproperties  setstartproperties$^static const char pyxkunknownqueuetyper  unknown queue type r$^static const char pyxkkeepstatenumbering  keepstatenumbering$^static const char pyxkrequiresuperinitial  requiresuperinitial$^static const char pyxkdeletearcproperties  deletearcproperties$^static const char pyxkstatesortproperties  statesortproperties$^static const char pyxkstateiteratorat0xx  stateiterator at 0xx$^static const char pyxksymboltablerat0xx  symboltable r at 0xx$^static const char pyxkweighttypenotfound  weight type not found$^static const char pyxkallownegativelabels  allownegativelabels$^static const char pyxkresetfsterrorfatal  resetfsterrorfatal$^static const char pyxkconversiontorfailed  conversion to r failed$^static const char pyxknegtrinaryproperties  negtrinaryproperties$^static const char pyxkpostrinaryproperties  postrinaryproperties$^static const char pyxkwritetostringfailed  write to string failed$^static const char pyxkdeletestateproperties  deletestateproperties$^static const char pyxkrmsuperfinalproperties  rmsuperfinalproperties$^static const char pyxkstateindexoutofrange  state index out of range$^static const char pyxkaddsuperfinalproperties  addsuperfinalproperties$^static const char pyxkcannotencodeasstringr  cannot encode as string r$^static const char pyxkcannottopsortcyclicfst  cannot topsort cyclic fst.$^static const char pyxkfstsymboltablerat0xx  fst symboltable r at 0xx$^static const char pyxkfstdeletedconstructorerror  fstdeletedconstructorerror$^static const char pyxkmutablearciteratorat0xx  mutablearciterator at 0xx$^static const char pyxksymboltableiteratorat0xx  symboltableiterator at 0xx$^static const char pyxkweightinvariantproperties  weightinvariantproperties$^static const char pyxkilabelinvariantproperties  ilabelinvariantproperties$^static const char pyxkolabelinvariantproperties  olabelinvariantproperties$^static const char pyxkunknownreplacelabeltyper  unknown replace label type r$^static const char pyxknonewsymboltablesspecified  no new symboltables specified$^static const char pyxknorelabelingpairsspecified  no relabeling pairs specified.$^static const char pyxkunknowncomposefiltertyper  unknown compose filter type r$^static const char pyxkincrementsubsequentiallabel  incrementsubsequentiallabel$^static const char pyxkincompatibleorinvalidweight  incompatible or invalid weight$^static const char pyxkunknowndeterminizationtyper  unknown determinization type r$^static const char pyxkconstencodemappersymboltable  const encodemapper symboltable r at 0xx$^static const char pyxkfstarctypestandardconstruct  n   fstarctypestandardnn   constructs an empty fst.nn   argsn     arctype a string indicating the arc type.nn   raisesn     fsterror unknown arc type.nn   raisesn     fstoperror operation failed.n   $^static const char pyxkconstfstsymboltablerat0xx  const fst symboltable r at 0xx$^static const char pyxkselfaiterselffstcannotbe  self.aiterself.fst cannot be converted to a python object for pickling$^static const char pyxkselffstselfsitercannotbe  self.fstself.siter cannot be converted to a python object for pickling$^static const char pyxkselffstselftablecannotbe  self.fstself.table cannot be converted to a python object for pickling$^static const char pyxkselftablecannotbeconverted  self.table cannot be converted to a python object for pickling$^static const char pyxkincompatibleorinvalidarctype  incompatible or invalid arc type$^static const char pyxkincompatibleorinvalidweightt  incompatible or invalid weight type$^static const char pyxkpythoninterfacetothefstscri  python interface to the fst scripting api.nnoperations which construct new fsts are implemented as traditional functions asnare twoargument boolean functions like equal and equivalent. destructivenoperationsthose that mutate an fst in placeare instance methods as isnwrite. operator overloading is not used. the following example based onnmohri et al. 0000 shows the construction of an asr system given a pronunciationnlexicon l grammar g a transducer from contextdependent phones toncontextindependent phones c and an hmm set hnn  l  fst.fst.readl.fstn  g  fst.fst.readg.fstn  c  fst.fst.readc.fstn  h  fst.fst.readh.fstn  lg  fst.determinizefst.composel gn  clg  fst.determinizefst.composec lgn  hclg  fst.determinizefst.composeh clgn  hclg.minimize                                       nb works inplace.nnpython variables here use snakecase and constants are in all caps minus thennormal k prefix.n$^static const char pyxkunknownrandomarcselectiontyp  unknown random arc selection type r$^static const char pyxknodefaultreduceduetonon  no default reduce due to nontrivial cinit$^static const char pyxkselfaiterselfmfstcannotbe  self.aiterself.mfst cannot be converted to a python object for pickling$^static const char pyxkselfarccannotbeconvertedto  self.arc cannot be converted to a python object for pickling$^static const char pyxkselfencodercannotbeconverte  self.encoder cannot be converted to a python object for pickling$^static const char pyxkselfencoderselftablecannot  self.encoderself.table cannot be converted to a python object for pickling$^static const char pyxkselfmfstselftablecannotbe  self.mfstself.table cannot be converted to a python object for pickling$^static const char pyxkselfreadercannotbeconverted  self.reader cannot be converted to a python object for pickling$^static const char pyxkselfsiterselftablecannotb  self.siterself.table cannot be converted to a python object for pickling$^static const char pyxkselfsmarttableselftableca  self.smarttableself.table cannot be converted to a python object for pickling$^static const char pyxkselfweightcannotbeconverted  self.weight cannot be converted to a python object for pickling$^static const char pyxkselfwritercannotbeconverted  self.writer cannot be converted to a python object for pickling$^static pyobject pyxnsacceptor$^static pyobject pyxnsaccessible$^static pyobject pyxnsacyclic$^static pyobject pyxnsaddarcproperties$^static pyobject pyxnsaddstateproperties$^static pyobject pyxnsaddsuperfinalproperties$^static pyobject pyxnsarcflags$^static pyobject pyxnsarcilabelvalue$^static pyobject pyxnsarcnextstatevalue$^static pyobject pyxnsarcnocache$^static pyobject pyxnsarcolabelvalue$^static pyobject pyxnsarcsortproperties$^static pyobject pyxnsarcvalueflags$^static pyobject pyxnsarcweightvalue$^static pyobject pyxkpsarciteratorat0xx$^static pyobject pyxkpsarcat0xx$^static pyobject pyxnsbinaryproperties$^static pyobject pyxnscoaccessible$^static pyobject pyxnscopyproperties$^static pyobject pyxnscyclic$^static pyobject pyxnscalledprocesserror$^static pyobject pyxkpscannotconstruct$^static pyobject pyxkpscannotencodeasstringr$^static pyobject pyxkpscannottopsortcyclicfst$^static pyobject pyxkpscompilationfailed$^static pyobject pyxkpsconversiontorfailed$^static pyobject pyxnsdeletearcproperties$^static pyobject pyxnsdeletestateproperties$^static pyobject pyxnsdottsvg$^static pyobject pyxnsencodeflags$^static pyobject pyxnsencodelabels$^static pyobject pyxnsencodeweights$^static pyobject pyxnsepsilons$^static pyobject pyxnserror$^static pyobject pyxnsexpanded$^static pyobject pyxnsextrinsicproperties$^static pyobject pyxkpsencodemapperat0xx$^static pyobject pyxnsfstproperties$^static pyobject pyxkpsfarreaderat0xx$^static pyobject pyxkpsfarwriterat0xx$^static pyobject pyxnsfst$^static pyobject pyxnsfstargerror$^static pyobject pyxnsfstbadweighterror$^static pyobject pyxnsfstdeletedconstructorerror$^static pyobject pyxnsfsterror$^static pyobject pyxnsfstioerror$^static pyobject pyxnsfstindexerror$^static pyobject pyxnsfstoperror$^static pyobject pyxkpsfstsymboltablerat0xx$^static pyobject pyxnsfstnew$^static pyobject pyxkpsfstarctypestandardconstruct$^static pyobject pyxkpsfstat0xx$^static pyobject pyxnsfstread$^static pyobject pyxnsfstreadfromstring$^static pyobject pyxnsinitialacyclic$^static pyobject pyxnsinitialcyclic$^static pyobject pyxnsintrinsicproperties$^static pyobject pyxnsioerror$^static pyobject pyxnsideterministic$^static pyobject pyxnsiepsilons$^static pyobject pyxnsilabelinvariantproperties$^static pyobject pyxnsilabelsorted$^static pyobject pyxkpsincompatibleorinvalidarctype$^static pyobject pyxkpsincompatibleorinvalidweight$^static pyobject pyxkpsincompatibleorinvalidweightt$^static pyobject pyxnsindexerror$^static pyobject pyxkpsinvalidweight$^static pyobject pyxnskeyerror$^static pyobject pyxkpskeyoutoforder$^static pyobject pyxnsmutable$^static pyobject pyxkpsmutablearciteratorat0xx$^static pyobject pyxnsnegtrinaryproperties$^static pyobject pyxnsnonideterministic$^static pyobject pyxnsnonodeterministic$^static pyobject pyxnsnotacceptor$^static pyobject pyxnsnotaccessible$^static pyobject pyxnsnotcoaccessible$^static pyobject pyxnsnotilabelsorted$^static pyobject pyxnsnotolabelsorted$^static pyobject pyxnsnotstring$^static pyobject pyxnsnottopsorted$^static pyobject pyxnsnoepsilons$^static pyobject pyxnsnoiepsilons$^static pyobject pyxnsnolabel$^static pyobject pyxnsnooepsilons$^static pyobject pyxnsnostateid$^static pyobject pyxnsnosymbol$^static pyobject pyxnsnullproperties$^static pyobject pyxnsnoweight$^static pyobject pyxkpsnonewsymboltablesspecified$^static pyobject pyxkpsnorelabelingpairsspecified$^static pyobject pyxnsnumber$^static pyobject pyxnsodeterministic$^static pyobject pyxnsoepsilons$^static pyobject pyxnsolabelinvariantproperties$^static pyobject pyxnsolabelsorted$^static pyobject pyxnsone$^static pyobject pyxkpsopenfailedr$^static pyobject pyxkpsoperationfailed$^static pyobject pyxnspipe$^static pyobject pyxnspostrinaryproperties$^static pyobject pyxnspopen$^static pyobject pyxnsrmsuperfinalproperties$^static pyobject pyxkpsreadfailedr$^static pyobject pyxkpsreadfailedstring$^static pyobject pyxnsruntimeerror$^static pyobject pyxnssetarcproperties$^static pyobject pyxnssetfinalproperties$^static pyobject pyxnssetstartproperties$^static pyobject pyxnsstatesortproperties$^static pyobject pyxnsstring$^static pyobject pyxkpsstateiteratorat0xx$^static pyobject pyxkpsstateindexoutofrange$^static pyobject pyxnsstopiteration$^static pyobject pyxkpssymboltableiteratorat0xx$^static pyobject pyxkpssymboltablerat0xx$^static pyobject pyxnstopsorted$^static pyobject pyxnstrinaryproperties$^static pyobject pyxkpstsvg$^static pyobject pyxnstypeerror$^static pyobject pyxnsunweighted$^static pyobject pyxnsunweightedcycles$^static pyobject pyxkpsunknownarctyper$^static pyobject pyxkpsunknowncomposefiltertyper$^static pyobject pyxkpsunknowndeterminizationtyper$^static pyobject pyxkpsunknownmaptyper$^static pyobject pyxkpsunknownqueuetyper$^static pyobject pyxkpsunknownrandomarcselectiontyp$^static pyobject pyxkpsunknownreplacelabeltyper$^static pyobject pyxkpsunknownsorttyper$^static pyobject pyxnsvalueerror$^static pyobject pyxnsweighted$^static pyobject pyxnsweightedcycles$^static pyobject pyxnsweightinvariantproperties$^static pyobject pyxkpsweightat0xx$^static pyobject pyxkpsweighttypenotfound$^static pyobject pyxkpswritefailedr$^static pyobject pyxkpswritetostringfailed$^static pyobject pyxnszero$^static pyobject pyxkpb00$^static pyobject pyxnsacceptor$^static pyobject pyxnsadd$^static pyobject pyxnsaddstate$^static pyobject pyxnsaddsymbol$^static pyobject pyxnsaddtable$^static pyobject pyxnsallownegativelabels$^static pyobject pyxnsallownondet$^static pyobject pyxnsarc$^static pyobject pyxnsarctype$^static pyobject pyxnsarcs$^static pyobject pyxnsatexit$^static pyobject pyxnsattachnewisymbols$^static pyobject pyxnsattachnewosymbols$^static pyobject pyxnbauto$^static pyobject pyxnsavailablekey$^static pyobject pyxnscallarclabeling$^static pyobject pyxnschecksum$^static pyobject pyxnsclass$^static pyobject pyxnsclineintraceback$^static pyobject pyxnsclosureplus$^static pyobject pyxnscls$^static pyobject pyxnscommunicate$^static pyobject pyxnscompile$^static pyobject pyxnscomposefilter$^static pyobject pyxnsconnect$^static pyobject pyxkpsconstencodemappersymboltable$^static pyobject pyxkpsconstfstsymboltablerat0xx$^static pyobject pyxnscopy$^static pyobject pyxnscreate$^static pyobject pyxnsdecode$^static pyobject pyxnbdefault$^static pyobject pyxnsdelta$^static pyobject pyxnsdettype$^static pyobject pyxnsdistance$^static pyobject pyxnsdivide$^static pyobject pyxnsdoc$^static pyobject pyxnsdone$^static pyobject pyxnsdot$^static pyobject pyxnsdraw$^static pyobject pyxnsencode$^static pyobject pyxnsencodelabels$^static pyobject pyxnsencodeweights$^static pyobject pyxnsepsnormoutput$^static pyobject pyxnsepsilononreplace$^static pyobject pyxnserror$^static pyobject pyxnsfartype$^static pyobject pyxnsfilename$^static pyobject pyxnsfinal$^static pyobject pyxnsfind$^static pyobject pyxnsflags$^static pyobject pyxnsfloatformat$^static pyobject pyxnsfontsize$^static pyobject pyxnsformat$^static pyobject pyxnsfsterrorfatalold$^static pyobject pyxnsfsttype$^static pyobject pyxnbfunctional$^static pyobject pyxnbg$^static pyobject pyxnsgetfst$^static pyobject pyxnsgetkey$^static pyobject pyxnsgetnthkey$^static pyobject pyxnsgetstate$^static pyobject pyxnsheight$^static pyobject pyxnsid$^static pyobject pyxnbidentity$^static pyobject pyxnsifst$^static pyobject pyxnsifst0$^static pyobject pyxnsifst0$^static pyobject pyxnbilabel$^static pyobject pyxnsilabel$^static pyobject pyxnsimport$^static pyobject pyxnsincrementsubsequentiallabel$^static pyobject pyxnbinput$^static pyobject pyxnsinputsymbols$^static pyobject pyxnsinputtable$^static pyobject pyxnsipairs$^static pyobject pyxnsisymbols$^static pyobject pyxnsknosymbol$^static pyobject pyxnskeepisymbols$^static pyobject pyxnskeeposymbols$^static pyobject pyxnskeepstatenumbering$^static pyobject pyxnskey$^static pyobject pyxnslabeledchecksum$^static pyobject pyxnslhs$^static pyobject pyxnslogging$^static pyobject pyxnsmain$^static pyobject pyxnsmaptype$^static pyobject pyxnsmask$^static pyobject pyxnsmaxlength$^static pyobject pyxnsmember$^static pyobject pyxnsmetaclass$^static pyobject pyxnsmissingsym$^static pyobject pyxnsmodule$^static pyobject pyxnsmutablearcs$^static pyobject pyxnsn$^static pyobject pyxnsname$^static pyobject pyxnsname0$^static pyobject pyxnbneither$^static pyobject pyxnsnew$^static pyobject pyxnsnewisymbols$^static pyobject pyxnsnewosymbols$^static pyobject pyxnsnext$^static pyobject pyxnsnextstate$^static pyobject pyxkpsnodefaultreduceduetonon$^static pyobject pyxnsnodesep$^static pyobject pyxnsnpath$^static pyobject pyxnsnshortest$^static pyobject pyxnsnstate$^static pyobject pyxnsnumarcs$^static pyobject pyxnsnuminputepsilons$^static pyobject pyxnsnumoutputepsilons$^static pyobject pyxnsnumstates$^static pyobject pyxnsnumsymbols$^static pyobject pyxnsnumbers$^static pyobject pyxnsobject$^static pyobject pyxnsolabel$^static pyobject pyxnsoldisymbols$^static pyobject pyxnsoldosymbols$^static pyobject pyxnsopairs$^static pyobject pyxnsopen$^static pyobject pyxnsosymbols$^static pyobject pyxnsoutputsymbols$^static pyobject pyxnspairs$^static pyobject pyxnsplus$^static pyobject pyxnsportrait$^static pyobject pyxnsposition$^static pyobject pyxnspotentials$^static pyobject pyxnspower$^static pyobject pyxnsprecision$^static pyobject pyxnsprepare$^static pyobject pyxnsprojectoutput$^static pyobject pyxnsproperties$^static pyobject pyxnsprops$^static pyobject pyxnspushlabels$^static pyobject pyxnspushweights$^static pyobject pyxnspywrapfst0$^static pyobject pyxkpspywrapfstpyx$^static pyobject pyxnspyxvtable$^static pyobject pyxnsqualname$^static pyobject pyxnsqueuetype$^static pyobject pyxnsranksep$^static pyobject pyxnsread$^static pyobject pyxnsreadfromstring$^static pyobject pyxnsreadfromstring0$^static pyobject pyxnsreadfst$^static pyobject pyxnsreadtext$^static pyobject pyxnsreduce$^static pyobject pyxnsreducecython$^static pyobject pyxnsreduceex$^static pyobject pyxnsregister$^static pyobject pyxnsremovecommonaffix$^static pyobject pyxnsremovetotalweight$^static pyobject pyxnsrequiresuperinitial$^static pyobject pyxnsreset$^static pyobject pyxnsresetfsterrorfatal$^static pyobject pyxnsresult$^static pyobject pyxnsreturnarclabeling$^static pyobject pyxnsreturnlabel$^static pyobject pyxnsreturncode$^static pyobject pyxnsreverse$^static pyobject pyxnsrhs$^static pyobject pyxnsseed$^static pyobject pyxnsseek$^static pyobject pyxnsselect$^static pyobject pyxkpsselfaiterselffstcannotbe$^static pyobject pyxkpsselfaiterselfmfstcannotbe$^static pyobject pyxkpsselfarccannotbeconvertedto$^static pyobject pyxkpsselfencodercannotbeconverte$^static pyobject pyxkpsselfencoderselftablecannot$^static pyobject pyxkpsselffstselfsitercannotbe$^static pyobject pyxkpsselffstselftablecannotbe$^static pyobject pyxkpsselfmfstselftablecannotbe$^static pyobject pyxkpsselfreadercannotbeconverted$^static pyobject pyxkpsselfsiterselftablecannotb$^static pyobject pyxkpsselfsmarttableselftableca$^static pyobject pyxkpsselftablecannotbeconverted$^static pyobject pyxkpsselfweightcannotbeconverted$^static pyobject pyxkpsselfwritercannotbeconverted$^static pyobject pyxnssetflags$^static pyobject pyxnssetinputsymbols$^static pyobject pyxnssetname$^static pyobject pyxnssetoutputsymbols$^static pyobject pyxnssetvalue$^static pyobject pyxnssetstate$^static pyobject pyxnssetstatecython$^static pyobject pyxnsshortestdistance$^static pyobject pyxnsshowweightone$^static pyobject pyxnssorttype$^static pyobject pyxnsssymbols$^static pyobject pyxnbstandard$^static pyobject pyxnsstart$^static pyobject pyxnsstate$^static pyobject pyxnsstates$^static pyobject pyxnsstaticmethod$^static pyobject pyxnsstderr$^static pyobject pyxnsstdin$^static pyobject pyxnsstdout$^static pyobject pyxnssubprocess$^static pyobject pyxnssubsequentiallabel$^static pyobject pyxnssymbol$^static pyobject pyxnssyms$^static pyobject pyxnstest$^static pyobject pyxnstest0$^static pyobject pyxnstext$^static pyobject pyxnstimes$^static pyobject pyxnstitle$^static pyobject pyxnstofinal$^static pyobject pyxnstostring$^static pyobject pyxnstype$^static pyobject pyxnbuniform$^static pyobject pyxnsunique$^static pyobject pyxnsunknownisymbol$^static pyobject pyxnsunknownosymbol$^static pyobject pyxkpbunspecified$^static pyobject pyxnsutf0$^static pyobject pyxnsvalue$^static pyobject pyxnbvector$^static pyobject pyxnsverify$^static pyobject pyxnsvertical$^static pyobject pyxnsw$^static pyobject pyxnswarning$^static pyobject pyxnsweight$^static pyobject pyxnsweighttype$^static pyobject pyxnsweighted$^static pyobject pyxnswidth$^static pyobject pyxnswrite$^static pyobject pyxnswritetext$^static pyobject pyxnswritetostring$^static pyobject pyxpf0pywrapfst0weightreprstruct pyxobj0pywrapfstweight pyxvself  proto $^static pyobject pyxpf0pywrapfst0weight0strstruct pyxobj0pywrapfstweight pyxvself  proto $^static pyobject pyxpf0pywrapfst0weight0floatstruct pyxobj0pywrapfstweight pyxvself  proto $^static int pyxpf0pywrapfst0weight0initstruct pyxobj0pywrapfstweight pyxvself pyobject pyxvweighttype pyobject pyxvweight  proto $^static pyobject pyxpf0pywrapfst0weight0copystruct pyxobj0pywrapfstweight pyxvself  proto $^static pyobject pyxpf0pywrapfst0weight00zerocythonunused pytypeobject pyxvcls pyobject pyxvweighttype  proto $^static pyobject pyxpf0pywrapfst0weight00onecythonunused pytypeobject pyxvcls pyobject pyxvweighttype  proto $^static pyobject pyxpf0pywrapfst0weight00noweightcythonunused pytypeobject pyxvcls pyobject pyxvweighttype  proto $^static pyobject pyxpf0pywrapfst0weight00eqstruct pyxobj0pywrapfstweight pyxvw0 struct pyxobj0pywrapfstweight pyxvw0  proto $^static pyobject pyxpf0pywrapfst0weight00nestruct pyxobj0pywrapfstweight pyxvw0 struct pyxobj0pywrapfstweight pyxvw0  proto $^static pyobject pyxpf0pywrapfst0weight00tostringstruct pyxobj0pywrapfstweight pyxvself  proto $^static pyobject pyxpf0pywrapfst0weight00typestruct pyxobj0pywrapfstweight pyxvself  proto $^static pyobject pyxpf0pywrapfst0weight00reducecythoncythonunused struct pyxobj0pywrapfstweight pyxvself  proto $^static pyobject pyxpf0pywrapfst0weight00setstatecythoncythonunused struct pyxobj0pywrapfstweight pyxvself cythonunused pyobject pyxvpyxstate  proto $^static pyobject pyxpf0pywrapfstpluscythonunused pyobject pyxself struct pyxobj0pywrapfstweight pyxvlhs struct pyxobj0pywrapfstweight pyxvrhs  proto $^static pyobject pyxpf0pywrapfst0timescythonunused pyobject pyxself struct pyxobj0pywrapfstweight pyxvlhs struct pyxobj0pywrapfstweight pyxvrhs  proto $^static pyobject pyxpf0pywrapfst0dividecythonunused pyobject pyxself struct pyxobj0pywrapfstweight pyxvlhs struct pyxobj0pywrapfstweight pyxvrhs  proto $^static pyobject pyxpf0pywrapfst0powercythonunused pyobject pyxself struct pyxobj0pywrapfstweight pyxvw sizet pyxvn  proto $^static int pyxpf0pywrapfst00symboltableinitstruct pyxobj0pywrapfstsymboltable pyxvself  proto $^static pyobject pyxpf0pywrapfst00symboltable0iterstruct pyxobj0pywrapfstsymboltable pyxvself  proto $^static pyobject pyxpf0pywrapfst00symboltable0availablekeystruct pyxobj0pywrapfstsymboltable pyxvself  proto $^static pyobject pyxpf0pywrapfst00symboltable0checksumstruct pyxobj0pywrapfstsymboltable pyxvself  proto $^static pyobject pyxpf0pywrapfst00symboltable0copystruct pyxobj0pywrapfstsymboltable pyxvself  proto $^static pyobject pyxpf0pywrapfst00symboltable00findstruct pyxobj0pywrapfstsymboltable pyxvself pyobject pyxvkey  proto $^static pyobject pyxpf0pywrapfst00symboltable00getnthkeystruct pyxobj0pywrapfstsymboltable pyxvself pyssizet pyxvpos  proto $^static pyobject pyxpf0pywrapfst00symboltable00labeledchecksumstruct pyxobj0pywrapfstsymboltable pyxvself  proto $^static pyobject pyxpf0pywrapfst00symboltable00memberstruct pyxobj0pywrapfstsymboltable pyxvself pyobject pyxvkey  proto $^static int pyxpf0pywrapfst00symboltable00containsstruct pyxobj0pywrapfstsymboltable pyxvself pyobject pyxvkey  proto $^static pyobject pyxpf0pywrapfst00symboltable00namestruct pyxobj0pywrapfstsymboltable pyxvself  proto $^static pyobject pyxpf0pywrapfst00symboltable00numsymbolsstruct pyxobj0pywrapfstsymboltable pyxvself  proto $^static pyobject pyxpf0pywrapfst00symboltable00writestruct pyxobj0pywrapfstsymboltable pyxvself pyobject pyxvfilename  proto $^static pyobject pyxpf0pywrapfst00symboltable00writetextstruct pyxobj0pywrapfstsymboltable pyxvself pyobject pyxvfilename  proto $^static pyobject pyxpf0pywrapfst00symboltable00reducecythoncythonunused struct pyxobj0pywrapfstsymboltable pyxvself  proto $^static pyobject pyxpf0pywrapfst00symboltable00setstatecythoncythonunused struct pyxobj0pywrapfstsymboltable pyxvself cythonunused pyobject pyxvpyxstate  proto $^static pyobject pyxpf0pywrapfst00encodemappersymboltablereprstruct pyxobj0pywrapfstencodemappersymboltable pyxvself  proto $^static pyobject pyxpf0pywrapfst00encodemappersymboltable0reducecythoncythonunused struct pyxobj0pywrapfstencodemappersymboltable pyxvself  proto $^static pyobject pyxpf0pywrapfst00encodemappersymboltable0setstatecythoncythonunused struct pyxobj0pywrapfstencodemappersymboltable pyxvself cythonunused pyobject pyxvpyxstate  proto $^static pyobject pyxpf0pywrapfst00fstsymboltablereprstruct pyxobj0pywrapfstfstsymboltable pyxvself  proto $^static pyobject pyxpf0pywrapfst00fstsymboltable0reducecythoncythonunused struct pyxobj0pywrapfstfstsymboltable pyxvself  proto $^static pyobject pyxpf0pywrapfst00fstsymboltable0setstatecythoncythonunused struct pyxobj0pywrapfstfstsymboltable pyxvself cythonunused pyobject pyxvpyxstate  proto $^static pyobject pyxpf0pywrapfst00mutablesymboltableaddsymbolstruct pyxobj0pywrapfstmutablesymboltable pyxvself pyobject pyxvsymbol pyxt00basictypesint00 pyxvkey  proto $^static pyobject pyxpf0pywrapfst00mutablesymboltable0addtablestruct pyxobj0pywrapfstmutablesymboltable pyxvself struct pyxobj0pywrapfstsymboltable pyxvsyms  proto $^static pyobject pyxpf0pywrapfst00mutablesymboltable0setnamestruct pyxobj0pywrapfstmutablesymboltable pyxvself pyobject pyxvnewname  proto $^static pyobject pyxpf0pywrapfst00mutablesymboltable0reducecythoncythonunused struct pyxobj0pywrapfstmutablesymboltable pyxvself  proto $^static pyobject pyxpf0pywrapfst00mutablesymboltable0setstatecythoncythonunused struct pyxobj0pywrapfstmutablesymboltable pyxvself cythonunused pyobject pyxvpyxstate  proto $^static pyobject pyxpf0pywrapfst00mutablefstsymboltablereprstruct pyxobj0pywrapfstmutablefstsymboltable pyxvself  proto $^static pyobject pyxpf0pywrapfst00mutablefstsymboltable0reducecythoncythonunused struct pyxobj0pywrapfstmutablefstsymboltable pyxvself  proto $^static pyobject pyxpf0pywrapfst00mutablefstsymboltable0setstatecythoncythonunused struct pyxobj0pywrapfstmutablefstsymboltable pyxvself cythonunused pyobject pyxvpyxstate  proto $^static pyobject pyxpf0pywrapfst00symboltablereprstruct pyxobj0pywrapfstsymboltable pyxvself  proto $^static int pyxpf0pywrapfst00symboltable0initstruct pyxobj0pywrapfstsymboltable pyxvself pyobject pyxvname  proto $^static pyobject pyxpf0pywrapfst00symboltable0readcythonunused pytypeobject pyxvcls pyobject pyxvfilename  proto $^static pyobject pyxpf0pywrapfst00symboltable0readtextcythonunused pytypeobject pyxvcls pyobject pyxvfilename bool pyxvallownegativelabels  proto $^static pyobject pyxpf0pywrapfst00symboltable0readfstcythonunused pytypeobject pyxvcls pyobject pyxvfilename bool pyxvinputtable  proto $^static pyobject pyxpf0pywrapfst00symboltable00reducecythoncythonunused struct pyxobj0pywrapfstsymboltable pyxvself  proto $^static pyobject pyxpf0pywrapfst00symboltable00setstatecythoncythonunused struct pyxobj0pywrapfstsymboltable pyxvself cythonunused pyobject pyxvpyxstate  proto $^static pyobject pyxpf0pywrapfst0compactsymboltablecythonunused pyobject pyxself struct pyxobj0pywrapfstsymboltable pyxvsyms  proto $^static pyobject pyxpf0pywrapfst00mergesymboltablecythonunused pyobject pyxself struct pyxobj0pywrapfstsymboltable pyxvlhs struct pyxobj0pywrapfstsymboltable pyxvrhs  proto $^static pyobject pyxpf0pywrapfst00symboltableiteratorreprstruct pyxobj0pywrapfstsymboltableiterator pyxvself  proto $^static int pyxpf0pywrapfst00symboltableiterator0initstruct pyxobj0pywrapfstsymboltableiterator pyxvself struct pyxobj0pywrapfstsymboltable pyxvsyms  proto $^static pyobject pyxpf0pywrapfst00symboltableiterator0iterstruct pyxobj0pywrapfstsymboltableiterator pyxvself  proto $^static pyobject pyxpf0pywrapfst00symboltableiterator0nextstruct pyxobj0pywrapfstsymboltableiterator pyxvself  proto $^static pyobject pyxpf0pywrapfst00symboltableiterator0donestruct pyxobj0pywrapfstsymboltableiterator pyxvself  proto $^static pyobject pyxpf0pywrapfst00symboltableiterator00nextstruct pyxobj0pywrapfstsymboltableiterator pyxvself  proto $^static pyobject pyxpf0pywrapfst00symboltableiterator00resetstruct pyxobj0pywrapfstsymboltableiterator pyxvself  proto $^static pyobject pyxpf0pywrapfst00symboltableiterator00symbolstruct pyxobj0pywrapfstsymboltableiterator pyxvself  proto $^static pyobject pyxpf0pywrapfst00symboltableiterator00valuestruct pyxobj0pywrapfstsymboltableiterator pyxvself  proto $^static pyobject pyxpf0pywrapfst00symboltableiterator00reducecythoncythonunused struct pyxobj0pywrapfstsymboltableiterator pyxvself  proto $^static pyobject pyxpf0pywrapfst00symboltableiterator00setstatecythoncythonunused struct pyxobj0pywrapfstsymboltableiterator pyxvself cythonunused pyobject pyxvpyxstate  proto $^static pyobject pyxpf0pywrapfst00encodemapperreprstruct pyxobj0pywrapfstencodemapper pyxvself  proto $^static int pyxpf0pywrapfst00encodemapper0initstruct pyxobj0pywrapfstencodemapper pyxvself pyobject pyxvarctype bool pyxvencodelabels bool pyxvencodeweights  proto $^static pyobject pyxpf0pywrapfst00encodemapper0arctypestruct pyxobj0pywrapfstencodemapper pyxvself  proto $^static pyobject pyxpf0pywrapfst00encodemapper0callstruct pyxobj0pywrapfstencodemapper pyxvself struct pyxobj0pywrapfstarc pyxvarc  proto $^static pyobject pyxpf0pywrapfst00encodemapper0flagsstruct pyxobj0pywrapfstencodemapper pyxvself  proto $^static pyobject pyxpf0pywrapfst00encodemapper00inputsymbolsstruct pyxobj0pywrapfstencodemapper pyxvself  proto $^static pyobject pyxpf0pywrapfst00encodemapper00outputsymbolsstruct pyxobj0pywrapfstencodemapper pyxvself  proto $^static pyobject pyxpf0pywrapfst00encodemapper00propertiesstruct pyxobj0pywrapfstencodemapper pyxvself pyxt00basictypesuint00 pyxvmask  proto $^static pyobject pyxpf0pywrapfst00encodemapper00setinputsymbolsstruct pyxobj0pywrapfstencodemapper pyxvself struct pyxobj0pywrapfstsymboltable pyxvsyms  proto $^static pyobject pyxpf0pywrapfst00encodemapper00setoutputsymbolsstruct pyxobj0pywrapfstencodemapper pyxvself struct pyxobj0pywrapfstsymboltable pyxvsyms  proto $^static pyobject pyxpf0pywrapfst00encodemapper00weighttypestruct pyxobj0pywrapfstencodemapper pyxvself  proto $^static pyobject pyxpf0pywrapfst00encodemapper00reducecythoncythonunused struct pyxobj0pywrapfstencodemapper pyxvself  proto $^static pyobject pyxpf0pywrapfst00encodemapper00setstatecythoncythonunused struct pyxobj0pywrapfstencodemapper pyxvself cythonunused pyobject pyxvpyxstate  proto $^static pyobject pyxpf0pywrapfst0fstreprsvgstruct pyxobj0pywrapfstfst pyxvself  proto $^static pyobject pyxpf0pywrapfst0fst0reprstruct pyxobj0pywrapfstfst pyxvself  proto $^static int pyxpf0pywrapfst0fst0initstruct pyxobj0pywrapfstfst pyxvself  proto $^static pyobject pyxpf0pywrapfst0fst0strstruct pyxobj0pywrapfstfst pyxvself  proto $^static pyobject pyxpf0pywrapfst0fst0reducestruct pyxobj0pywrapfstfst pyxvself  proto $^static pyobject pyxpf0pywrapfst0fst00arctypestruct pyxobj0pywrapfstfst pyxvself  proto $^static pyobject pyxpf0pywrapfst0fst00arcsstruct pyxobj0pywrapfstfst pyxvself pyxt00basictypesint00 pyxvstate  proto $^static pyobject pyxpf0pywrapfst0fst00copystruct pyxobj0pywrapfstfst pyxvself  proto $^static pyobject pyxpf0pywrapfst0fst00drawstruct pyxobj0pywrapfstfst pyxvself pyobject pyxvfilename struct pyxobj0pywrapfstsymboltable pyxvisymbols struct pyxobj0pywrapfstsymboltable pyxvosymbols struct pyxobj0pywrapfstsymboltable pyxvssymbols bool pyxvacceptor pyobject pyxvtitle double pyxvwidth double pyxvheight bool pyxvportrait bool pyxvvertical double pyxvranksep double pyxvnodesep pyxt00basictypesint00 pyxvfontsize pyxt00basictypesint00 pyxvprecision pyobject pyxvfloatformat bool pyxvshowweightone  proto $^static pyobject pyxpf0pywrapfst0fst00finalstruct pyxobj0pywrapfstfst pyxvself pyxt00basictypesint00 pyxvstate  proto $^static pyobject pyxpf0pywrapfst0fst00fsttypestruct pyxobj0pywrapfstfst pyxvself  proto $^static pyobject pyxpf0pywrapfst0fst00inputsymbolsstruct pyxobj0pywrapfstfst pyxvself  proto $^static pyobject pyxpf0pywrapfst0fst00numarcsstruct pyxobj0pywrapfstfst pyxvself pyxt00basictypesint00 pyxvstate  proto $^static pyobject pyxpf0pywrapfst0fst00numinputepsilonsstruct pyxobj0pywrapfstfst pyxvself pyxt00basictypesint00 pyxvstate  proto $^static pyobject pyxpf0pywrapfst0fst00numoutputepsilonsstruct pyxobj0pywrapfstfst pyxvself pyxt00basictypesint00 pyxvstate  proto $^static pyobject pyxpf0pywrapfst0fst00outputsymbolsstruct pyxobj0pywrapfstfst pyxvself  proto $^static pyobject pyxpf0pywrapfst0fst00propertiesstruct pyxobj0pywrapfstfst pyxvself pyxt00basictypesuint00 pyxvmask bool pyxvtest  proto $^static pyobject pyxpf0pywrapfst0fst00startstruct pyxobj0pywrapfstfst pyxvself  proto $^static pyobject pyxpf0pywrapfst0fst00statesstruct pyxobj0pywrapfstfst pyxvself  proto $^static pyobject pyxpf0pywrapfst0fst00textstruct pyxobj0pywrapfstfst pyxvself struct pyxobj0pywrapfstsymboltable pyxvisymbols struct pyxobj0pywrapfstsymboltable pyxvosymbols struct pyxobj0pywrapfstsymboltable pyxvssymbols bool pyxvacceptor bool pyxvshowweightone pyobject pyxvmissingsym  proto $^static pyobject pyxpf0pywrapfst0fst00verifystruct pyxobj0pywrapfstfst pyxvself  proto $^static pyobject pyxpf0pywrapfst0fst00weighttypestruct pyxobj0pywrapfstfst pyxvself  proto $^static pyobject pyxpf0pywrapfst0fst00writestruct pyxobj0pywrapfstfst pyxvself pyobject pyxvfilename  proto $^static pyobject pyxpf0pywrapfst0fst00writetostringstruct pyxobj0pywrapfstfst pyxvself  proto $^static pyobject pyxpf0pywrapfst00mutablefstaddarcstruct pyxobj0pywrapfstmutablefst pyxvself pyxt00basictypesint00 pyxvstate struct pyxobj0pywrapfstarc pyxvarc  proto $^static pyobject pyxpf0pywrapfst00mutablefst0addstatestruct pyxobj0pywrapfstmutablefst pyxvself  proto $^static pyobject pyxpf0pywrapfst00mutablefst0arcsortstruct pyxobj0pywrapfstmutablefst pyxvself pyobject pyxvsorttype  proto $^static pyobject pyxpf0pywrapfst00mutablefst0closurestruct pyxobj0pywrapfstmutablefst pyxvself bool pyxvclosureplus  proto $^static pyobject pyxpf0pywrapfst00mutablefst0concatstruct pyxobj0pywrapfstmutablefst pyxvself struct pyxobj0pywrapfstfst pyxvifst  proto $^static pyobject pyxpf0pywrapfst00mutablefst00connectstruct pyxobj0pywrapfstmutablefst pyxvself  proto $^static pyobject pyxpf0pywrapfst00mutablefst00decodestruct pyxobj0pywrapfstmutablefst pyxvself struct pyxobj0pywrapfstencodemapper pyxvencoder  proto $^static pyobject pyxpf0pywrapfst00mutablefst00deletearcsstruct pyxobj0pywrapfstmutablefst pyxvself pyxt00basictypesint00 pyxvstate sizet pyxvn  proto $^static pyobject pyxpf0pywrapfst00mutablefst00deletestatesstruct pyxobj0pywrapfstmutablefst pyxvself pyobject pyxvstates  proto $^static pyobject pyxpf0pywrapfst00mutablefst00encodestruct pyxobj0pywrapfstmutablefst pyxvself struct pyxobj0pywrapfstencodemapper pyxvencoder  proto $^static pyobject pyxpf0pywrapfst00mutablefst00invertstruct pyxobj0pywrapfstmutablefst pyxvself  proto $^static pyobject pyxpf0pywrapfst00mutablefst00minimizestruct pyxobj0pywrapfstmutablefst pyxvself float pyxvdelta bool pyxvallownondet  proto $^static pyobject pyxpf0pywrapfst00mutablefst00mutablearcsstruct pyxobj0pywrapfstmutablefst pyxvself pyxt00basictypesint00 pyxvstate  proto $^static pyobject pyxpf0pywrapfst00mutablefst00mutableinputsymbolsstruct pyxobj0pywrapfstmutablefst pyxvself  proto $^static pyobject pyxpf0pywrapfst00mutablefst00mutableoutputsymbolsstruct pyxobj0pywrapfstmutablefst pyxvself  proto $^static pyobject pyxpf0pywrapfst00mutablefst00numstatesstruct pyxobj0pywrapfstmutablefst pyxvself  proto $^static pyobject pyxpf0pywrapfst00mutablefst00projectstruct pyxobj0pywrapfstmutablefst pyxvself bool pyxvprojectoutput  proto $^static pyobject pyxpf0pywrapfst00mutablefst00prunestruct pyxobj0pywrapfstmutablefst pyxvself float pyxvdelta pyxt00basictypesint00 pyxvnstate pyobject pyxvweight  proto $^static pyobject pyxpf0pywrapfst00mutablefst00pushstruct pyxobj0pywrapfstmutablefst pyxvself float pyxvdelta bool pyxvremovetotalweight bool pyxvtofinal  proto $^static pyobject pyxpf0pywrapfst00mutablefst00relabelpairsstruct pyxobj0pywrapfstmutablefst pyxvself pyobject pyxvipairs pyobject pyxvopairs  proto $^static pyobject pyxpf0pywrapfst00mutablefst00relabeltablesstruct pyxobj0pywrapfstmutablefst pyxvself struct pyxobj0pywrapfstsymboltable pyxvoldisymbols struct pyxobj0pywrapfstsymboltable pyxvnewisymbols pyobject pyxvunknownisymbol bool pyxvattachnewisymbols struct pyxobj0pywrapfstsymboltable pyxvoldosymbols struct pyxobj0pywrapfstsymboltable pyxvnewosymbols pyobject pyxvunknownosymbol bool pyxvattachnewosymbols  proto $^static pyobject pyxpf0pywrapfst00mutablefst00reservearcsstruct pyxobj0pywrapfstmutablefst pyxvself pyxt00basictypesint00 pyxvstate sizet pyxvn  proto $^static pyobject pyxpf0pywrapfst00mutablefst00reservestatesstruct pyxobj0pywrapfstmutablefst pyxvself pyxt00basictypesint00 pyxvn  proto $^static pyobject pyxpf0pywrapfst00mutablefst00reweightstruct pyxobj0pywrapfstmutablefst pyxvself pyobject pyxvpotentials bool pyxvtofinal  proto $^static pyobject pyxpf0pywrapfst00mutablefst00rmepsilonstruct pyxobj0pywrapfstmutablefst pyxvself pyobject pyxvqueuetype bool pyxvconnect pyobject pyxvweight pyxt00basictypesint00 pyxvnstate float pyxvdelta  proto $^static pyobject pyxpf0pywrapfst00mutablefst00setfinalstruct pyxobj0pywrapfstmutablefst pyxvself pyxt00basictypesint00 pyxvstate pyobject pyxvweight  proto $^static pyobject pyxpf0pywrapfst00mutablefst00setinputsymbolsstruct pyxobj0pywrapfstmutablefst pyxvself struct pyxobj0pywrapfstsymboltable pyxvsyms  proto $^static pyobject pyxpf0pywrapfst00mutablefst00setoutputsymbolsstruct pyxobj0pywrapfstmutablefst pyxvself struct pyxobj0pywrapfstsymboltable pyxvsyms  proto $^static pyobject pyxpf0pywrapfst00mutablefst00setpropertiesstruct pyxobj0pywrapfstmutablefst pyxvself pyxt00basictypesuint00 pyxvprops pyxt00basictypesuint00 pyxvmask  proto $^static pyobject pyxpf0pywrapfst00mutablefst00setstartstruct pyxobj0pywrapfstmutablefst pyxvself pyxt00basictypesint00 pyxvstate  proto $^static pyobject pyxpf0pywrapfst00mutablefst00topsortstruct pyxobj0pywrapfstmutablefst pyxvself  proto $^static pyobject pyxpf0pywrapfst00mutablefst00unionstruct pyxobj0pywrapfstmutablefst pyxvself struct pyxobj0pywrapfstfst pyxvifst  proto $^static pyobject pyxpf0pywrapfst00readcythonunused pyobject pyxself pyobject pyxvfilename  proto $^static pyobject pyxpf0pywrapfst00readfromstringcythonunused pyobject pyxself pyobject pyxvstate  proto $^static pyobject pyxpf0pywrapfst0fstnewcythonunused pyobject pyxself cythonunused pyobject pyxvcls pyobject pyxvarctype  proto $^static pyobject pyxpf0pywrapfst0fst0readcythonunused pyobject pyxself pyobject pyxvfilename  proto $^static pyobject pyxpf0pywrapfst0fst0readfromstringcythonunused pyobject pyxself pyobject pyxvstate  proto $^static pyobject pyxpf0pywrapfst0arcreprstruct pyxobj0pywrapfstarc pyxvself  proto $^static int pyxpf0pywrapfst0arc0initstruct pyxobj0pywrapfstarc pyxvself pyxt00basictypesint00 pyxvilabel pyxt00basictypesint00 pyxvolabel pyobject pyxvweight pyxt00basictypesint00 pyxvnextstate  proto $^static pyobject pyxpf0pywrapfst0arc0copystruct pyxobj0pywrapfstarc pyxvself  proto $^static pyobject pyxpf0pywrapfst0arc0ilabelgetstruct pyxobj0pywrapfstarc pyxvself  proto $^static int pyxpf0pywrapfst0arc0ilabel0setstruct pyxobj0pywrapfstarc pyxvself pyxt00basictypesint00 pyxvvalue  proto $^static pyobject pyxpf0pywrapfst0arc0olabelgetstruct pyxobj0pywrapfstarc pyxvself  proto $^static int pyxpf0pywrapfst0arc0olabel0setstruct pyxobj0pywrapfstarc pyxvself pyxt00basictypesint00 pyxvvalue  proto $^static pyobject pyxpf0pywrapfst0arc0weightgetstruct pyxobj0pywrapfstarc pyxvself  proto $^static int pyxpf0pywrapfst0arc0weight0setstruct pyxobj0pywrapfstarc pyxvself pyobject pyxvweight  proto $^static pyobject pyxpf0pywrapfst0arc0nextstategetstruct pyxobj0pywrapfstarc pyxvself  proto $^static int pyxpf0pywrapfst0arc0nextstate0setstruct pyxobj0pywrapfstarc pyxvself pyxt00basictypesint00 pyxvvalue  proto $^static pyobject pyxpf0pywrapfst0arc0reducecythoncythonunused struct pyxobj0pywrapfstarc pyxvself  proto $^static pyobject pyxpf0pywrapfst0arc0setstatecythoncythonunused struct pyxobj0pywrapfstarc pyxvself cythonunused pyobject pyxvpyxstate  proto $^static pyobject pyxpf0pywrapfst00arciteratorreprstruct pyxobj0pywrapfstarciterator pyxvself  proto $^static int pyxpf0pywrapfst00arciterator0initstruct pyxobj0pywrapfstarciterator pyxvself struct pyxobj0pywrapfstfst pyxvifst pyxt00basictypesint00 pyxvstate  proto $^static pyobject pyxpf0pywrapfst00arciterator0iterstruct pyxobj0pywrapfstarciterator pyxvself  proto $^static pyobject pyxpf0pywrapfst00arciterator0nextstruct pyxobj0pywrapfstarciterator pyxvself  proto $^static pyobject pyxpf0pywrapfst00arciterator0donestruct pyxobj0pywrapfstarciterator pyxvself  proto $^static pyobject pyxpf0pywrapfst00arciterator00flagsstruct pyxobj0pywrapfstarciterator pyxvself  proto $^static pyobject pyxpf0pywrapfst00arciterator00nextstruct pyxobj0pywrapfstarciterator pyxvself  proto $^static pyobject pyxpf0pywrapfst00arciterator00positionstruct pyxobj0pywrapfstarciterator pyxvself  proto $^static pyobject pyxpf0pywrapfst00arciterator00resetstruct pyxobj0pywrapfstarciterator pyxvself  proto $^static pyobject pyxpf0pywrapfst00arciterator00seekstruct pyxobj0pywrapfstarciterator pyxvself sizet pyxva  proto $^static pyobject pyxpf0pywrapfst00arciterator00setflagsstruct pyxobj0pywrapfstarciterator pyxvself pyxt00basictypesuint00 pyxvflags pyxt00basictypesuint00 pyxvmask  proto $^static pyobject pyxpf0pywrapfst00arciterator00valuestruct pyxobj0pywrapfstarciterator pyxvself  proto $^static pyobject pyxpf0pywrapfst00arciterator00reducecythoncythonunused struct pyxobj0pywrapfstarciterator pyxvself  proto $^static pyobject pyxpf0pywrapfst00arciterator00setstatecythoncythonunused struct pyxobj0pywrapfstarciterator pyxvself cythonunused pyobject pyxvpyxstate  proto $^static pyobject pyxpf0pywrapfst00mutablearciteratorreprstruct pyxobj0pywrapfstmutablearciterator pyxvself  proto $^static int pyxpf0pywrapfst00mutablearciterator0initstruct pyxobj0pywrapfstmutablearciterator pyxvself struct pyxobj0pywrapfstmutablefst pyxvifst pyxt00basictypesint00 pyxvstate  proto $^static pyobject pyxpf0pywrapfst00mutablearciterator0donestruct pyxobj0pywrapfstmutablearciterator pyxvself  proto $^static pyobject pyxpf0pywrapfst00mutablearciterator0flagsstruct pyxobj0pywrapfstmutablearciterator pyxvself  proto $^static pyobject pyxpf0pywrapfst00mutablearciterator0nextstruct pyxobj0pywrapfstmutablearciterator pyxvself  proto $^static pyobject pyxpf0pywrapfst00mutablearciterator00positionstruct pyxobj0pywrapfstmutablearciterator pyxvself  proto $^static pyobject pyxpf0pywrapfst00mutablearciterator00resetstruct pyxobj0pywrapfstmutablearciterator pyxvself  proto $^static pyobject pyxpf0pywrapfst00mutablearciterator00seekstruct pyxobj0pywrapfstmutablearciterator pyxvself sizet pyxva  proto $^static pyobject pyxpf0pywrapfst00mutablearciterator00setflagsstruct pyxobj0pywrapfstmutablearciterator pyxvself pyxt00basictypesuint00 pyxvflags pyxt00basictypesuint00 pyxvmask  proto $^static pyobject pyxpf0pywrapfst00mutablearciterator00setvaluestruct pyxobj0pywrapfstmutablearciterator pyxvself struct pyxobj0pywrapfstarc pyxvarc  proto $^static pyobject pyxpf0pywrapfst00mutablearciterator00valuestruct pyxobj0pywrapfstmutablearciterator pyxvself  proto $^static pyobject pyxpf0pywrapfst00mutablearciterator00reducecythoncythonunused struct pyxobj0pywrapfstmutablearciterator pyxvself  proto $^static pyobject pyxpf0pywrapfst00mutablearciterator00setstatecythoncythonunused struct pyxobj0pywrapfstmutablearciterator pyxvself cythonunused pyobject pyxvpyxstate  proto $^static pyobject pyxpf0pywrapfst00stateiteratorreprstruct pyxobj0pywrapfststateiterator pyxvself  proto $^static int pyxpf0pywrapfst00stateiterator0initstruct pyxobj0pywrapfststateiterator pyxvself struct pyxobj0pywrapfstfst pyxvifst  proto $^static pyobject pyxpf0pywrapfst00stateiterator0iterstruct pyxobj0pywrapfststateiterator pyxvself  proto $^static pyobject pyxpf0pywrapfst00stateiterator0nextstruct pyxobj0pywrapfststateiterator pyxvself  proto $^static pyobject pyxpf0pywrapfst00stateiterator0donestruct pyxobj0pywrapfststateiterator pyxvself  proto $^static pyobject pyxpf0pywrapfst00stateiterator00nextstruct pyxobj0pywrapfststateiterator pyxvself  proto $^static pyobject pyxpf0pywrapfst00stateiterator00resetstruct pyxobj0pywrapfststateiterator pyxvself  proto $^static pyobject pyxpf0pywrapfst00stateiterator00valuestruct pyxobj0pywrapfststateiterator pyxvself  proto $^static pyobject pyxpf0pywrapfst00stateiterator00reducecythoncythonunused struct pyxobj0pywrapfststateiterator pyxvself  proto $^static pyobject pyxpf0pywrapfst00stateiterator00setstatecythoncythonunused struct pyxobj0pywrapfststateiterator pyxvself cythonunused pyobject pyxvpyxstate  proto $^static pyobject pyxpf0pywrapfst00arcmapcythonunused pyobject pyxself struct pyxobj0pywrapfstfst pyxvifst float pyxvdelta pyobject pyxvmaptype double pyxvpower pyobject pyxvweight  proto $^static pyobject pyxpf0pywrapfst00composecythonunused pyobject pyxself struct pyxobj0pywrapfstfst pyxvifst0 struct pyxobj0pywrapfstfst pyxvifst0 pyobject pyxvcomposefilter bool pyxvconnect  proto $^static pyobject pyxpf0pywrapfst00convertcythonunused pyobject pyxself struct pyxobj0pywrapfstfst pyxvifst pyobject pyxvfsttype  proto $^static pyobject pyxpf0pywrapfst00determinizecythonunused pyobject pyxself struct pyxobj0pywrapfstfst pyxvifst float pyxvdelta pyobject pyxvdettype pyxt00basictypesint00 pyxvnstate pyxt00basictypesint00 pyxvsubsequentiallabel pyobject pyxvweight bool pyxvincrementsubsequentiallabel  proto $^static pyobject pyxpf0pywrapfst00differencecythonunused pyobject pyxself struct pyxobj0pywrapfstfst pyxvifst0 struct pyxobj0pywrapfstfst pyxvifst0 pyobject pyxvcomposefilter bool pyxvconnect  proto $^static pyobject pyxpf0pywrapfst00disambiguatecythonunused pyobject pyxself struct pyxobj0pywrapfstfst pyxvifst float pyxvdelta pyxt00basictypesint00 pyxvnstate pyxt00basictypesint00 pyxvsubsequentiallabel pyobject pyxvweight  proto $^static pyobject pyxpf0pywrapfst00epsnormalizecythonunused pyobject pyxself struct pyxobj0pywrapfstfst pyxvifst bool pyxvepsnormoutput  proto $^static pyobject pyxpf0pywrapfst00equalcythonunused pyobject pyxself struct pyxobj0pywrapfstfst pyxvifst0 struct pyxobj0pywrapfstfst pyxvifst0 float pyxvdelta  proto $^static pyobject pyxpf0pywrapfst00equivalentcythonunused pyobject pyxself struct pyxobj0pywrapfstfst pyxvifst0 struct pyxobj0pywrapfstfst pyxvifst0 float pyxvdelta  proto $^static pyobject pyxpf0pywrapfst00intersectcythonunused pyobject pyxself struct pyxobj0pywrapfstfst pyxvifst0 struct pyxobj0pywrapfstfst pyxvifst0 pyobject pyxvcomposefilter bool pyxvconnect  proto $^static pyobject pyxpf0pywrapfst00isomorphiccythonunused pyobject pyxself struct pyxobj0pywrapfstfst pyxvifst0 struct pyxobj0pywrapfstfst pyxvifst0 float pyxvdelta  proto $^static pyobject pyxpf0pywrapfst00prunecythonunused pyobject pyxself struct pyxobj0pywrapfstfst pyxvifst float pyxvdelta pyxt00basictypesint00 pyxvnstate pyobject pyxvweight  proto $^static pyobject pyxpf0pywrapfst00pushcythonunused pyobject pyxself struct pyxobj0pywrapfstfst pyxvifst float pyxvdelta bool pyxvpushweights bool pyxvpushlabels bool pyxvremovecommonaffix bool pyxvremovetotalweight bool pyxvtofinal  proto $^static pyobject pyxpf0pywrapfst00randequivalentcythonunused pyobject pyxself struct pyxobj0pywrapfstfst pyxvifst0 struct pyxobj0pywrapfstfst pyxvifst0 pyxt00basictypesint00 pyxvnpath float pyxvdelta timet pyxvseed pyobject pyxvselect pyxt00basictypesint00 pyxvmaxlength  proto $^static pyobject pyxpf0pywrapfst00randgencythonunused pyobject pyxself struct pyxobj0pywrapfstfst pyxvifst pyxt00basictypesint00 pyxvnpath timet pyxvseed pyobject pyxvselect pyxt00basictypesint00 pyxvmaxlength bool pyxvweighted bool pyxvremovetotalweight  proto $^static pyobject pyxpf0pywrapfst00replacecythonunused pyobject pyxself pyobject pyxvpairs pyobject pyxvcallarclabeling pyobject pyxvreturnarclabeling bool pyxvepsilononreplace pyxt00basictypesint00 pyxvreturnlabel  proto $^static pyobject pyxpf0pywrapfst00reversecythonunused pyobject pyxself struct pyxobj0pywrapfstfst pyxvifst bool pyxvrequiresuperinitial  proto $^static pyobject pyxpf0pywrapfst00shortestdistancecythonunused pyobject pyxself struct pyxobj0pywrapfstfst pyxvifst float pyxvdelta pyxt00basictypesint00 pyxvnstate pyobject pyxvqueuetype bool pyxvreverse  proto $^static pyobject pyxpf0pywrapfst00shortestpathcythonunused pyobject pyxself struct pyxobj0pywrapfstfst pyxvifst float pyxvdelta pyxt00basictypesint00 pyxvnshortest pyxt00basictypesint00 pyxvnstate pyobject pyxvqueuetype bool pyxvunique pyobject pyxvweight  proto $^static pyobject pyxpf0pywrapfst00statemapcythonunused pyobject pyxself struct pyxobj0pywrapfstfst pyxvifst pyobject pyxvmaptype  proto $^static pyobject pyxpf0pywrapfst00synchronizecythonunused pyobject pyxself struct pyxobj0pywrapfstfst pyxvifst  proto $^static int pyxpf0pywrapfst0compilercinitstruct pyxobj0pywrapfstcompiler pyxvself stdstring pyxvfsttype stdstring pyxvarctype struct pyxobj0pywrapfstsymboltable pyxvisymbols struct pyxobj0pywrapfstsymboltable pyxvosymbols struct pyxobj0pywrapfstsymboltable pyxvssymbols bool pyxvacceptor bool pyxvkeepisymbols bool pyxvkeeposymbols bool pyxvkeepstatenumbering bool pyxvallownegativelabels  proto $^static pyobject pyxpf0pywrapfst0compiler0compilestruct pyxobj0pywrapfstcompiler pyxvself  proto $^static pyobject pyxpf0pywrapfst0compiler0writestruct pyxobj0pywrapfstcompiler pyxvself pyobject pyxvexpression  proto $^static pyobject pyxpf0pywrapfst0compiler0reducecythoncythonunused struct pyxobj0pywrapfstcompiler pyxvself  proto $^static pyobject pyxpf0pywrapfst0compiler0setstatecythoncythonunused struct pyxobj0pywrapfstcompiler pyxvself cythonunused pyobject pyxvpyxstate  proto $^static int pyxpf0pywrapfst0farreaderinitstruct pyxobj0pywrapfstfarreader pyxvself  proto $^static pyobject pyxpf0pywrapfst0farreader0reprstruct pyxobj0pywrapfstfarreader pyxvself  proto $^static pyobject pyxpf0pywrapfst0farreader0opencythonunused pytypeobject pyxvcls pyobject pyxvfilenames  proto $^static pyobject pyxpf0pywrapfst0farreader0arctypestruct pyxobj0pywrapfstfarreader pyxvself  proto $^static pyobject pyxpf0pywrapfst0farreader0donestruct pyxobj0pywrapfstfarreader pyxvself  proto $^static pyobject pyxpf0pywrapfst0farreader00errorstruct pyxobj0pywrapfstfarreader pyxvself  proto $^static pyobject pyxpf0pywrapfst0farreader00fartypestruct pyxobj0pywrapfstfarreader pyxvself  proto $^static pyobject pyxpf0pywrapfst0farreader00findstruct pyxobj0pywrapfstfarreader pyxvself pyobject pyxvkey  proto $^static pyobject pyxpf0pywrapfst0farreader00getfststruct pyxobj0pywrapfstfarreader pyxvself  proto $^static pyobject pyxpf0pywrapfst0farreader00getkeystruct pyxobj0pywrapfstfarreader pyxvself  proto $^static pyobject pyxpf0pywrapfst0farreader00nextstruct pyxobj0pywrapfstfarreader pyxvself  proto $^static pyobject pyxpf0pywrapfst0farreader00resetstruct pyxobj0pywrapfstfarreader pyxvself  proto $^static pyobject pyxpf0pywrapfst0farreader00getitemstruct pyxobj0pywrapfstfarreader pyxvself pyobject pyxvkey  proto $^static pyobject pyxpf0pywrapfst0farreader00reducecythoncythonunused struct pyxobj0pywrapfstfarreader pyxvself  proto $^static pyobject pyxpf0pywrapfst0farreader00setstatecythoncythonunused struct pyxobj0pywrapfstfarreader pyxvself cythonunused pyobject pyxvpyxstate  proto $^static int pyxpf0pywrapfst0farwriterinitstruct pyxobj0pywrapfstfarwriter pyxvself  proto $^static pyobject pyxpf0pywrapfst0farwriter0reprstruct pyxobj0pywrapfstfarwriter pyxvself  proto $^static pyobject pyxpf0pywrapfst0farwriter0createcythonunused pytypeobject pyxvcls pyobject pyxvfilename pyobject pyxvarctype pyobject pyxvfartype  proto $^static pyobject pyxpf0pywrapfst0farwriter0addstruct pyxobj0pywrapfstfarwriter pyxvself pyobject pyxvkey struct pyxobj0pywrapfstfst pyxvifst  proto $^static pyobject pyxpf0pywrapfst0farwriter0arctypestruct pyxobj0pywrapfstfarwriter pyxvself  proto $^static pyobject pyxpf0pywrapfst0farwriter00errorstruct pyxobj0pywrapfstfarwriter pyxvself  proto $^static pyobject pyxpf0pywrapfst0farwriter00fartypestruct pyxobj0pywrapfstfarwriter pyxvself  proto $^static int pyxpf0pywrapfst0farwriter00setitemstruct pyxobj0pywrapfstfarwriter pyxvself pyobject pyxvkey struct pyxobj0pywrapfstfst pyxvfst  proto $^static pyobject pyxpf0pywrapfst0farwriter00reducecythoncythonunused struct pyxobj0pywrapfstfarwriter pyxvself  proto $^static pyobject pyxpf0pywrapfst0farwriter00setstatecythoncythonunused struct pyxobj0pywrapfstfarwriter pyxvself cythonunused pyobject pyxvpyxstate  proto $^static pyobject pyxpf0pywrapfst00resetfsterrorfatalcythonunused pyobject pyxself  proto $^static pyobject pyxtpnew0pywrapfstweightpytypeobject t pyobject a pyobject k proto$^static pyobject pyxtpnew0pywrapfstsymboltablepytypeobject t pyobject a pyobject k proto$^static pyobject pyxtpnew0pywrapfstencodemappersymboltablepytypeobject t pyobject a pyobject k proto$^static pyobject pyxtpnew0pywrapfstfstsymboltablepytypeobject t pyobject a pyobject k proto$^static pyobject pyxtpnew0pywrapfstmutablesymboltablepytypeobject t pyobject a pyobject k proto$^static pyobject pyxtpnew0pywrapfstmutablefstsymboltablepytypeobject t pyobject a pyobject k proto$^static pyobject pyxtpnew0pywrapfstsymboltablepytypeobject t pyobject a pyobject k proto$^static pyobject pyxtpnew0pywrapfstsymboltableiteratorpytypeobject t pyobject a pyobject k proto$^static pyobject pyxtpnew0pywrapfstencodemapperpytypeobject t pyobject a pyobject k proto$^static pyobject pyxtpnew0pywrapfstfstpytypeobject t pyobject a pyobject k proto$^static pyobject pyxtpnew0pywrapfstmutablefstpytypeobject t pyobject a pyobject k proto$^static pyobject pyxtpnew0pywrapfstarcpytypeobject t pyobject a pyobject k proto$^static pyobject pyxtpnew0pywrapfstarciteratorpytypeobject t pyobject a pyobject k proto$^static pyobject pyxtpnew0pywrapfstmutablearciteratorpytypeobject t pyobject a pyobject k proto$^static pyobject pyxtpnew0pywrapfststateiteratorpytypeobject t pyobject a pyobject k proto$^static pyobject pyxtpnew0pywrapfstcompilerpytypeobject t pyobject a pyobject k proto$^static pyobject pyxtpnew0pywrapfstfarreaderpytypeobject t pyobject a pyobject k proto$^static pyobject pyxtpnew0pywrapfstfarwriterpytypeobject t pyobject a pyobject k proto$^static pyobject pyxint0$^static pyobject pyxintneg0$^static pyxt00basictypesint00 pyxk00$^static float pyxk00$^static float pyxk00$^static float pyxk00$^static pyxt00basictypesint00 pyxk00$^static float pyxk00$^static pyxt00basictypesint00 pyxk00$^static float pyxk00$^static float pyxk00$^static pyxt00basictypesint00 pyxk00$^static float pyxk00$^static pyxt00basictypesint00 pyxk00$^static float pyxk00$^static float pyxk00$^static float pyxk00$^static float pyxk00$^static pyxt00basictypesint00 pyxk00$^static float pyxk00$^static pyxt00basictypesint00 pyxk00$^static float pyxk00$^static float pyxk00$^static float pyxk00$^static float pyxk00$^static pyxt00basictypesint00 pyxk00$^static float pyxk00$^static float pyxk00$^static pyxt00basictypesint00 pyxk00$^static pyxt00basictypesint00 pyxk00$^static float pyxk00$^static pyxt00basictypesint00 pyxk00$^static float pyxk00$^static pyxt00basictypesint00 pyxk00$^static float pyxk00$^static pyxt00basictypesint00 pyxk00$^static stdstring pyxk00$^static stdstring pyxk00$^static pyobject pyxtuple$^static pyobject pyxtuple0$^static pyobject pyxtuple0$^static pyobject pyxtuple0$^static pyobject pyxtuple0$^static pyobject pyxtuple0$^static pyobject pyxtuple0$^static pyobject pyxtuple0$^static pyobject pyxtuple0$^static pyobject pyxtuple00$^static pyobject pyxtuple00$^static pyobject pyxtuple00$^static pyobject pyxtuple00$^static pyobject pyxtuple00$^static pyobject pyxtuple00$^static pyobject pyxtuple00$^static pyobject pyxtuple00$^static pyobject pyxtuple00$^static pyobject pyxtuple00$^static pyobject pyxtuple00$^static pyobject pyxtuple00$^static pyobject pyxtuple00$^static pyobject pyxtuple00$^static pyobject pyxtuple00$^static pyobject pyxtuple00$^static pyobject pyxtuple00$^static pyobject pyxtuple00$^static pyobject pyxtuple00$^static pyobject pyxtuple00$^static pyobject pyxtuple00$^static pyobject pyxtuple00$^static pyobject pyxtuple00$^static pyobject pyxtuple00$^static pyobject pyxtuple00$^static pyobject pyxtuple00$^static pyobject pyxtuple00$^static pyobject pyxtuple00$^static pyobject pyxtuple00$^static pyobject pyxtuple00$^static pyobject pyxtuple00$^static pyobject pyxtuple00$^static pyobject pyxtuple00$^static pyobject pyxtuple00$^static pyobject pyxtuple00$^static pyobject pyxtuple00$^static pyobject pyxtuple00$^static pyobject pyxtuple00$^static pyobject pyxtuple00$^static pyobject pyxtuple00$^static pyobject pyxtuple00$^static pyobject pyxtuple00$^static pyobject pyxtuple00$^static pyobject pyxtuple00$^static pyobject pyxtuple00$^static pyobject pyxtuple00$^static pyobject pyxtuple00$^static pyobject pyxtuple00$^static pyobject pyxtuple00$^static pyobject pyxtuple00$^static pyobject pyxtuple00$^static pyobject pyxtuple00$^static pyobject pyxtuple00$^static pyobject pyxtuple000$^static pyobject pyxtuple000$^static pyobject pyxtuple000$^static pyobject pyxtuple000$^static pyobject pyxtuple000$^static pyobject pyxtuple000$^static pyobject pyxtuple000$^static pyobject pyxtuple000$^static pyobject pyxtuple000$^static pyobject pyxcodeobj000$^static pyobject pyxcodeobj000$^static pyobject pyxcodeobj000$^static pyobject pyxcodeobj000$^static pyobject pyxcodeobj000$^static pyobject pyxcodeobj000$^static pyobject pyxcodeobj000$^static pyobject pyxcodeobj000$^static pyobject pyxcodeobj000$^ late includes $^$^ pywrapfst.pyx000$^  $^  $^  cdef string tostringdata encodingutf0 except               $^    converts strings to bytestrings.$^  $^ $^$^static stdstring pyxf0pywrapfsttostringpyobject pyxvdata struct pyxoptargs0pywrapfsttostring pyxoptionalargs $^  pyobject pyxvencoding  pyobject pyxnsutf0$^  stdstring pyxr$^  pyxrefnannydeclarations$^  int pyxt0$^  int pyxt0$^  stdstring pyxt0$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxrefnannysetupcontexttostring 0$^  if pyxoptionalargs $^    if pyxoptionalargspyxn  0 $^      pyxvencoding  pyxoptionalargsencoding$^    $^  $^$^   pywrapfst.pyx000$^    $^     a python bytestring can be implicitly cast to a c string.$^    if isinstancedata bytes              $^      return data$^    elif isinstancedata unicode$^ $^  pyxt0  pybytescheckpyxvdata $^  pyxt0  pyxt0  0$^  if pyxt0 $^$^     pywrapfst.pyx000$^     a python bytestring can be implicitly cast to a c string.$^    if isinstancedata bytes$^      return data              $^    elif isinstancedata unicode$^      return data.encodeencoding$^ $^    pyxt0  pyxconvertstringfrompystdinstringpyxvdata if unlikelypyerroccurred pyxerr0 000 pyxl0error$^    pyxr  pyxt0$^    goto pyxl0$^$^     pywrapfst.pyx000$^    $^     a python bytestring can be implicitly cast to a c string.$^    if isinstancedata bytes              $^      return data$^    elif isinstancedata unicode$^ $^  $^$^   pywrapfst.pyx000$^    if isinstancedata bytes$^      return data$^    elif isinstancedata unicode              $^      return data.encodeencoding$^    raise fstargerrorcannot encode as string r.formatdata$^ $^  pyxt0  pyunicodecheckpyxvdata $^  pyxt0  pyxt0  0$^  if pyxt0 $^$^     pywrapfst.pyx000$^      return data$^    elif isinstancedata unicode$^      return data.encodeencoding              $^    raise fstargerrorcannot encode as string r.formatdata$^  $^ $^    pyxt0  pyxpyobjectgetattrstrpyxvdata pyxnsencode if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  null$^    if cythonunpackmethods  likelypymethodcheckpyxt0 $^      pyxt0  pymethodgetselfpyxt0$^      if likelypyxt0 $^        pyobject function  pymethodgetfunctionpyxt0$^        pyxincrefpyxt0$^        pyxincreffunction$^        pyxdecrefsetpyxt0 function$^      $^    $^    if pyxt0 $^      pyxt0  pyxpyobjectcalloneargpyxt0 pyxvencoding if unlikelypyxt0 pyxerr0 000 pyxl0error$^      pyxgotrefpyxt0$^     else $^      if cythonfastpycall$^      if pyfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxvencoding$^        pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^       else$^      endif$^      if cythonfastpyccall$^      if pyxpyfastcfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxvencoding$^        pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^       else$^      endif$^      $^        pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxgotrefpyxt0$^        pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^        pyxincrefpyxvencoding$^        pyxgiverefpyxvencoding$^        pytuplesetitempyxt0 00 pyxvencoding$^        pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^      $^    $^    pyxdecrefpyxt0 pyxt0  0$^    pyxt0  pyxconvertstringfrompystdinstringpyxt0 if unlikelypyerroccurred pyxerr0 000 pyxl0error$^    pyxdecrefpyxt0 pyxt0  0$^    pyxr  pyxt0$^    goto pyxl0$^$^     pywrapfst.pyx000$^    if isinstancedata bytes$^      return data$^    elif isinstancedata unicode              $^      return data.encodeencoding$^    raise fstargerrorcannot encode as string r.formatdata$^ $^  $^$^   pywrapfst.pyx000$^    elif isinstancedata unicode$^      return data.encodeencoding$^    raise fstargerrorcannot encode as string r.formatdata              $^  $^  $^ $^  pyxt0  pyxgetmoduleglobalnamepyxnsfstargerror if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxt0  pyxpyobjectgetattrstrpyxkpscannotencodeasstringr pyxnsformat if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxt0  null$^  if cythonunpackmethods  likelypymethodcheckpyxt0 $^    pyxt0  pymethodgetselfpyxt0$^    if likelypyxt0 $^      pyobject function  pymethodgetfunctionpyxt0$^      pyxincrefpyxt0$^      pyxincreffunction$^      pyxdecrefsetpyxt0 function$^    $^  $^  if pyxt0 $^    pyxt0  pyxpyobjectcalloneargpyxt0 pyxvdata if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxgotrefpyxt0$^   else $^    if cythonfastpycall$^    if pyfunctioncheckpyxt0 $^      pyobject pyxtemp0  pyxt0 pyxvdata$^      pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^      pyxxdecrefpyxt0 pyxt0  0$^      pyxgotrefpyxt0$^     else$^    endif$^    if cythonfastpyccall$^    if pyxpyfastcfunctioncheckpyxt0 $^      pyobject pyxtemp0  pyxt0 pyxvdata$^      pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^      pyxxdecrefpyxt0 pyxt0  0$^      pyxgotrefpyxt0$^     else$^    endif$^    $^      pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^      pyxgotrefpyxt0$^      pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^      pyxincrefpyxvdata$^      pyxgiverefpyxvdata$^      pytuplesetitempyxt0 00 pyxvdata$^      pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 000 pyxl0error$^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^    $^  $^  pyxdecrefpyxt0 pyxt0  0$^  pyxt0  null$^  if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^    pyxt0  pymethodgetselfpyxt0$^    if likelypyxt0 $^      pyobject function  pymethodgetfunctionpyxt0$^      pyxincrefpyxt0$^      pyxincreffunction$^      pyxdecrefsetpyxt0 function$^    $^  $^  if pyxt0 $^    pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxdecrefpyxt0 pyxt0  0$^    pyxgotrefpyxt0$^   else $^    if cythonfastpycall$^    if pyfunctioncheckpyxt0 $^      pyobject pyxtemp0  pyxt0 pyxt0$^      pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^      pyxxdecrefpyxt0 pyxt0  0$^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^     else$^    endif$^    if cythonfastpyccall$^    if pyxpyfastcfunctioncheckpyxt0 $^      pyobject pyxtemp0  pyxt0 pyxt0$^      pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^      pyxxdecrefpyxt0 pyxt0  0$^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^     else$^    endif$^    $^      pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^      pyxgotrefpyxt0$^      pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^      pyxgiverefpyxt0$^      pytuplesetitempyxt0 00 pyxt0$^      pyxt0  0$^      pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 000 pyxl0error$^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^    $^  $^  pyxdecrefpyxt0 pyxt0  0$^  pyxraisepyxt0 0 0 0$^  pyxdecrefpyxt0 pyxt0  0$^  pyxerr0 000 pyxl0error$^$^   pywrapfst.pyx000$^  $^  $^  cdef string tostringdata encodingutf0 except               $^    converts strings to bytestrings.$^  $^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.tostring pyxclineno pyxlineno pyxfilename$^  pyxpretendtoinitializepyxr$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx000$^  $^  $^  cdef string weighttostringdata encodingutf0 except               $^    converts strings or numerics to bytestrings.$^  $^ $^$^static stdstring pyxf0pywrapfstweighttostringpyobject pyxvdata struct pyxoptargs0pywrapfstweighttostring pyxoptionalargs $^  pyobject pyxvencoding  pyobject pyxnsutf0$^  stdstring pyxr$^  pyxrefnannydeclarations$^  int pyxt0$^  int pyxt0$^  stdstring pyxt0$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextweighttostring 0$^  if pyxoptionalargs $^    if pyxoptionalargspyxn  0 $^      pyxvencoding  pyxoptionalargsencoding$^    $^  $^$^   pywrapfst.pyx000$^    $^     a python bytestring can be implicitly cast to a c string.$^    if isinstancedata bytes              $^      return data$^    elif isinstancedata unicode$^ $^  pyxt0  pybytescheckpyxvdata $^  pyxt0  pyxt0  0$^  if pyxt0 $^$^     pywrapfst.pyx000$^     a python bytestring can be implicitly cast to a c string.$^    if isinstancedata bytes$^      return data              $^    elif isinstancedata unicode$^      return data.encodeencoding$^ $^    pyxt0  pyxconvertstringfrompystdinstringpyxvdata if unlikelypyerroccurred pyxerr0 000 pyxl0error$^    pyxr  pyxt0$^    goto pyxl0$^$^     pywrapfst.pyx000$^    $^     a python bytestring can be implicitly cast to a c string.$^    if isinstancedata bytes              $^      return data$^    elif isinstancedata unicode$^ $^  $^$^   pywrapfst.pyx000$^    if isinstancedata bytes$^      return data$^    elif isinstancedata unicode              $^      return data.encodeencoding$^    elif isinstancedata numbers.number$^ $^  pyxt0  pyunicodecheckpyxvdata $^  pyxt0  pyxt0  0$^  if pyxt0 $^$^     pywrapfst.pyx000$^      return data$^    elif isinstancedata unicode$^      return data.encodeencoding              $^    elif isinstancedata numbers.number$^      return strdata.encodeencoding$^ $^    pyxt0  pyxpyobjectgetattrstrpyxvdata pyxnsencode if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  null$^    if cythonunpackmethods  likelypymethodcheckpyxt0 $^      pyxt0  pymethodgetselfpyxt0$^      if likelypyxt0 $^        pyobject function  pymethodgetfunctionpyxt0$^        pyxincrefpyxt0$^        pyxincreffunction$^        pyxdecrefsetpyxt0 function$^      $^    $^    if pyxt0 $^      pyxt0  pyxpyobjectcalloneargpyxt0 pyxvencoding if unlikelypyxt0 pyxerr0 000 pyxl0error$^      pyxgotrefpyxt0$^     else $^      if cythonfastpycall$^      if pyfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxvencoding$^        pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^       else$^      endif$^      if cythonfastpyccall$^      if pyxpyfastcfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxvencoding$^        pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^       else$^      endif$^      $^        pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxgotrefpyxt0$^        pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^        pyxincrefpyxvencoding$^        pyxgiverefpyxvencoding$^        pytuplesetitempyxt0 00 pyxvencoding$^        pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^      $^    $^    pyxdecrefpyxt0 pyxt0  0$^    pyxt0  pyxconvertstringfrompystdinstringpyxt0 if unlikelypyerroccurred pyxerr0 000 pyxl0error$^    pyxdecrefpyxt0 pyxt0  0$^    pyxr  pyxt0$^    goto pyxl0$^$^     pywrapfst.pyx000$^    if isinstancedata bytes$^      return data$^    elif isinstancedata unicode              $^      return data.encodeencoding$^    elif isinstancedata numbers.number$^ $^  $^$^   pywrapfst.pyx000$^    elif isinstancedata unicode$^      return data.encodeencoding$^    elif isinstancedata numbers.number              $^      return strdata.encodeencoding$^    raise fstargerrorcannot encode as string r.formatdata$^ $^  pyxt0  pyxgetmoduleglobalnamepyxnsnumbers if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxt0  pyxpyobjectgetattrstrpyxt0 pyxnsnumber if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxdecrefpyxt0 pyxt0  0$^  pyxt0  pyobjectisinstancepyxvdata pyxt0 if unlikelypyxt0  int0 pyxerr0 000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^  pyxt0  pyxt0  0$^  if pyxt0 $^$^     pywrapfst.pyx000$^      return data.encodeencoding$^    elif isinstancedata numbers.number$^      return strdata.encodeencoding              $^    raise fstargerrorcannot encode as string r.formatdata$^  $^ $^    pyxt0  pyxpyobjectcalloneargpyobject pystringtype pyxvdata if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  pyxpyobjectgetattrstrpyxt0 pyxnsencode if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxgotrefpyxt0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxt0  null$^    if cythonunpackmethods  likelypymethodcheckpyxt0 $^      pyxt0  pymethodgetselfpyxt0$^      if likelypyxt0 $^        pyobject function  pymethodgetfunctionpyxt0$^        pyxincrefpyxt0$^        pyxincreffunction$^        pyxdecrefsetpyxt0 function$^      $^    $^    if pyxt0 $^      pyxt0  pyxpyobjectcalloneargpyxt0 pyxvencoding if unlikelypyxt0 pyxerr0 000 pyxl0error$^      pyxgotrefpyxt0$^     else $^      if cythonfastpycall$^      if pyfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxvencoding$^        pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^       else$^      endif$^      if cythonfastpyccall$^      if pyxpyfastcfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxvencoding$^        pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^       else$^      endif$^      $^        pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxgotrefpyxt0$^        pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^        pyxincrefpyxvencoding$^        pyxgiverefpyxvencoding$^        pytuplesetitempyxt0 00 pyxvencoding$^        pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^      $^    $^    pyxdecrefpyxt0 pyxt0  0$^    pyxt0  pyxconvertstringfrompystdinstringpyxt0 if unlikelypyerroccurred pyxerr0 000 pyxl0error$^    pyxdecrefpyxt0 pyxt0  0$^    pyxr  pyxt0$^    goto pyxl0$^$^     pywrapfst.pyx000$^    elif isinstancedata unicode$^      return data.encodeencoding$^    elif isinstancedata numbers.number              $^      return strdata.encodeencoding$^    raise fstargerrorcannot encode as string r.formatdata$^ $^  $^$^   pywrapfst.pyx000$^    elif isinstancedata numbers.number$^      return strdata.encodeencoding$^    raise fstargerrorcannot encode as string r.formatdata              $^  $^  $^ $^  pyxt0  pyxgetmoduleglobalnamepyxnsfstargerror if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxt0  pyxpyobjectgetattrstrpyxkpscannotencodeasstringr pyxnsformat if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxt0  null$^  if cythonunpackmethods  likelypymethodcheckpyxt0 $^    pyxt0  pymethodgetselfpyxt0$^    if likelypyxt0 $^      pyobject function  pymethodgetfunctionpyxt0$^      pyxincrefpyxt0$^      pyxincreffunction$^      pyxdecrefsetpyxt0 function$^    $^  $^  if pyxt0 $^    pyxt0  pyxpyobjectcalloneargpyxt0 pyxvdata if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxgotrefpyxt0$^   else $^    if cythonfastpycall$^    if pyfunctioncheckpyxt0 $^      pyobject pyxtemp0  pyxt0 pyxvdata$^      pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^      pyxxdecrefpyxt0 pyxt0  0$^      pyxgotrefpyxt0$^     else$^    endif$^    if cythonfastpyccall$^    if pyxpyfastcfunctioncheckpyxt0 $^      pyobject pyxtemp0  pyxt0 pyxvdata$^      pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^      pyxxdecrefpyxt0 pyxt0  0$^      pyxgotrefpyxt0$^     else$^    endif$^    $^      pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^      pyxgotrefpyxt0$^      pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^      pyxincrefpyxvdata$^      pyxgiverefpyxvdata$^      pytuplesetitempyxt0 00 pyxvdata$^      pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 000 pyxl0error$^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^    $^  $^  pyxdecrefpyxt0 pyxt0  0$^  pyxt0  null$^  if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^    pyxt0  pymethodgetselfpyxt0$^    if likelypyxt0 $^      pyobject function  pymethodgetfunctionpyxt0$^      pyxincrefpyxt0$^      pyxincreffunction$^      pyxdecrefsetpyxt0 function$^    $^  $^  if pyxt0 $^    pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxdecrefpyxt0 pyxt0  0$^    pyxgotrefpyxt0$^   else $^    if cythonfastpycall$^    if pyfunctioncheckpyxt0 $^      pyobject pyxtemp0  pyxt0 pyxt0$^      pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^      pyxxdecrefpyxt0 pyxt0  0$^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^     else$^    endif$^    if cythonfastpyccall$^    if pyxpyfastcfunctioncheckpyxt0 $^      pyobject pyxtemp0  pyxt0 pyxt0$^      pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^      pyxxdecrefpyxt0 pyxt0  0$^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^     else$^    endif$^    $^      pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^      pyxgotrefpyxt0$^      pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^      pyxgiverefpyxt0$^      pytuplesetitempyxt0 00 pyxt0$^      pyxt0  0$^      pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 000 pyxl0error$^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^    $^  $^  pyxdecrefpyxt0 pyxt0  0$^  pyxraisepyxt0 0 0 0$^  pyxdecrefpyxt0 pyxt0  0$^  pyxerr0 000 pyxl0error$^$^   pywrapfst.pyx000$^  $^  $^  cdef string weighttostringdata encodingutf0 except               $^    converts strings or numerics to bytestrings.$^  $^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.weighttostring pyxclineno pyxlineno pyxfilename$^  pyxpretendtoinitializepyxr$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx000$^  $^  $^  cdef fst.composefilter getcomposefilter              $^      const string composefilter except $^    matches string with the appropriate composefilter enum value.$^ $^$^static enum fstcomposefilter pyxf0pywrapfstgetcomposefilterstdstring const pyxvcomposefilter $^  enum fstcomposefilter pyxvcomposefilterenum$^  enum fstcomposefilter pyxr$^  pyxrefnannydeclarations$^  int pyxt0$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextgetcomposefilter 0$^$^   pywrapfst.pyx000$^    $^    cdef fst.composefilter composefilterenum$^    if not fst.getcomposefiltercomposefilter addrcomposefilterenum              $^      raise fstargerrorunknown compose filter type r.format$^          composefilter$^ $^  pyxt0  fstscriptgetcomposefilterpyxvcomposefilter pyxvcomposefilterenum  0  0$^  if unlikelypyxt0 $^$^     pywrapfst.pyx000$^    cdef fst.composefilter composefilterenum$^    if not fst.getcomposefiltercomposefilter addrcomposefilterenum$^      raise fstargerrorunknown compose filter type r.format              $^          composefilter$^    return composefilterenum$^ $^    pyxt0  pyxgetmoduleglobalnamepyxnsfstargerror if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  pyxpyobjectgetattrstrpyxkpsunknowncomposefiltertyper pyxnsformat if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxgotrefpyxt0$^$^     pywrapfst.pyx000$^    if not fst.getcomposefiltercomposefilter addrcomposefilterenum$^      raise fstargerrorunknown compose filter type r.format$^          composefilter              $^    return composefilterenum$^  $^ $^    pyxt0  pyxconvertpybytesstringtopystdinstringpyxvcomposefilter if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  null$^    if cythonunpackmethods  likelypymethodcheckpyxt0 $^      pyxt0  pymethodgetselfpyxt0$^      if likelypyxt0 $^        pyobject function  pymethodgetfunctionpyxt0$^        pyxincrefpyxt0$^        pyxincreffunction$^        pyxdecrefsetpyxt0 function$^      $^    $^    if pyxt0 $^      pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxgotrefpyxt0$^     else $^      if cythonfastpycall$^      if pyfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxt0$^        pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^       else$^      endif$^      if cythonfastpyccall$^      if pyxpyfastcfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxt0$^        pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^       else$^      endif$^      $^        pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxgotrefpyxt0$^        pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^        pyxgiverefpyxt0$^        pytuplesetitempyxt0 00 pyxt0$^        pyxt0  0$^        pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^      $^    $^    pyxdecrefpyxt0 pyxt0  0$^    pyxt0  null$^    if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^      pyxt0  pymethodgetselfpyxt0$^      if likelypyxt0 $^        pyobject function  pymethodgetfunctionpyxt0$^        pyxincrefpyxt0$^        pyxincreffunction$^        pyxdecrefsetpyxt0 function$^      $^    $^    if pyxt0 $^      pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxgotrefpyxt0$^     else $^      if cythonfastpycall$^      if pyfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxt0$^        pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^       else$^      endif$^      if cythonfastpyccall$^      if pyxpyfastcfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxt0$^        pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^       else$^      endif$^      $^        pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxgotrefpyxt0$^        pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^        pyxgiverefpyxt0$^        pytuplesetitempyxt0 00 pyxt0$^        pyxt0  0$^        pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^      $^    $^    pyxdecrefpyxt0 pyxt0  0$^    pyxraisepyxt0 0 0 0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxerr0 000 pyxl0error$^$^     pywrapfst.pyx000$^    $^    cdef fst.composefilter composefilterenum$^    if not fst.getcomposefiltercomposefilter addrcomposefilterenum              $^      raise fstargerrorunknown compose filter type r.format$^          composefilter$^ $^  $^$^   pywrapfst.pyx000$^      raise fstargerrorunknown compose filter type r.format$^          composefilter$^    return composefilterenum              $^  $^  $^ $^  pyxr  pyxvcomposefilterenum$^  goto pyxl0$^$^   pywrapfst.pyx000$^  $^  $^  cdef fst.composefilter getcomposefilter              $^      const string composefilter except $^    matches string with the appropriate composefilter enum value.$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.getcomposefilter pyxclineno pyxlineno pyxfilename$^  pyxr  enum fstcomposefilter 0$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx000$^  $^  $^  cdef fst.determinizetype getdeterminizetypeconst string dettype except               $^    matches string with the appropriate determinizetype enum value.$^  $^ $^$^static enum fstdeterminizetype pyxf0pywrapfstgetdeterminizetypestdstring const pyxvdettype $^  enum fstdeterminizetype pyxvdettypeenum$^  enum fstdeterminizetype pyxr$^  pyxrefnannydeclarations$^  int pyxt0$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextgetdeterminizetype 0$^$^   pywrapfst.pyx000$^    $^    cdef fst.determinizetype dettypeenum$^    if not fst.getdeterminizetypedettype addrdettypeenum              $^      raise fstargerrorunknown determinization type r.formatdettype$^    return dettypeenum$^ $^  pyxt0  fstscriptgetdeterminizetypepyxvdettype pyxvdettypeenum  0  0$^  if unlikelypyxt0 $^$^     pywrapfst.pyx000$^    cdef fst.determinizetype dettypeenum$^    if not fst.getdeterminizetypedettype addrdettypeenum$^      raise fstargerrorunknown determinization type r.formatdettype              $^    return dettypeenum$^  $^ $^    pyxt0  pyxgetmoduleglobalnamepyxnsfstargerror if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  pyxpyobjectgetattrstrpyxkpsunknowndeterminizationtyper pyxnsformat if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  pyxconvertpybytesstringtopystdinstringpyxvdettype if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  null$^    if cythonunpackmethods  likelypymethodcheckpyxt0 $^      pyxt0  pymethodgetselfpyxt0$^      if likelypyxt0 $^        pyobject function  pymethodgetfunctionpyxt0$^        pyxincrefpyxt0$^        pyxincreffunction$^        pyxdecrefsetpyxt0 function$^      $^    $^    if pyxt0 $^      pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxgotrefpyxt0$^     else $^      if cythonfastpycall$^      if pyfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxt0$^        pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^       else$^      endif$^      if cythonfastpyccall$^      if pyxpyfastcfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxt0$^        pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^       else$^      endif$^      $^        pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxgotrefpyxt0$^        pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^        pyxgiverefpyxt0$^        pytuplesetitempyxt0 00 pyxt0$^        pyxt0  0$^        pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^      $^    $^    pyxdecrefpyxt0 pyxt0  0$^    pyxt0  null$^    if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^      pyxt0  pymethodgetselfpyxt0$^      if likelypyxt0 $^        pyobject function  pymethodgetfunctionpyxt0$^        pyxincrefpyxt0$^        pyxincreffunction$^        pyxdecrefsetpyxt0 function$^      $^    $^    if pyxt0 $^      pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxgotrefpyxt0$^     else $^      if cythonfastpycall$^      if pyfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxt0$^        pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^       else$^      endif$^      if cythonfastpyccall$^      if pyxpyfastcfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxt0$^        pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^       else$^      endif$^      $^        pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxgotrefpyxt0$^        pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^        pyxgiverefpyxt0$^        pytuplesetitempyxt0 00 pyxt0$^        pyxt0  0$^        pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^      $^    $^    pyxdecrefpyxt0 pyxt0  0$^    pyxraisepyxt0 0 0 0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxerr0 000 pyxl0error$^$^     pywrapfst.pyx000$^    $^    cdef fst.determinizetype dettypeenum$^    if not fst.getdeterminizetypedettype addrdettypeenum              $^      raise fstargerrorunknown determinization type r.formatdettype$^    return dettypeenum$^ $^  $^$^   pywrapfst.pyx000$^    if not fst.getdeterminizetypedettype addrdettypeenum$^      raise fstargerrorunknown determinization type r.formatdettype$^    return dettypeenum              $^  $^  $^ $^  pyxr  pyxvdettypeenum$^  goto pyxl0$^$^   pywrapfst.pyx000$^  $^  $^  cdef fst.determinizetype getdeterminizetypeconst string dettype except               $^    matches string with the appropriate determinizetype enum value.$^  $^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.getdeterminizetype pyxclineno pyxlineno pyxfilename$^  pyxr  enum fstdeterminizetype 0$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx000$^  $^  $^  cdef fst.queuetype getqueuetypeconst string queuetype except               $^    matches string with the appropriate queuetype enum value.$^  $^ $^$^static enum fstqueuetype pyxf0pywrapfstgetqueuetypestdstring const pyxvqueuetype $^  enum fstqueuetype pyxvqueuetypeenum$^  enum fstqueuetype pyxr$^  pyxrefnannydeclarations$^  int pyxt0$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextgetqueuetype 0$^$^   pywrapfst.pyx000$^    $^    cdef fst.queuetype queuetypeenum$^    if not fst.getqueuetypequeuetype addrqueuetypeenum              $^      raise fstargerrorunknown queue type r.formatqueuetype$^    return queuetypeenum$^ $^  pyxt0  fstscriptgetqueuetypepyxvqueuetype pyxvqueuetypeenum  0  0$^  if unlikelypyxt0 $^$^     pywrapfst.pyx000$^    cdef fst.queuetype queuetypeenum$^    if not fst.getqueuetypequeuetype addrqueuetypeenum$^      raise fstargerrorunknown queue type r.formatqueuetype              $^    return queuetypeenum$^  $^ $^    pyxt0  pyxgetmoduleglobalnamepyxnsfstargerror if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  pyxpyobjectgetattrstrpyxkpsunknownqueuetyper pyxnsformat if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  pyxconvertpybytesstringtopystdinstringpyxvqueuetype if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  null$^    if cythonunpackmethods  likelypymethodcheckpyxt0 $^      pyxt0  pymethodgetselfpyxt0$^      if likelypyxt0 $^        pyobject function  pymethodgetfunctionpyxt0$^        pyxincrefpyxt0$^        pyxincreffunction$^        pyxdecrefsetpyxt0 function$^      $^    $^    if pyxt0 $^      pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxgotrefpyxt0$^     else $^      if cythonfastpycall$^      if pyfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxt0$^        pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^       else$^      endif$^      if cythonfastpyccall$^      if pyxpyfastcfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxt0$^        pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^       else$^      endif$^      $^        pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxgotrefpyxt0$^        pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^        pyxgiverefpyxt0$^        pytuplesetitempyxt0 00 pyxt0$^        pyxt0  0$^        pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^      $^    $^    pyxdecrefpyxt0 pyxt0  0$^    pyxt0  null$^    if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^      pyxt0  pymethodgetselfpyxt0$^      if likelypyxt0 $^        pyobject function  pymethodgetfunctionpyxt0$^        pyxincrefpyxt0$^        pyxincreffunction$^        pyxdecrefsetpyxt0 function$^      $^    $^    if pyxt0 $^      pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxgotrefpyxt0$^     else $^      if cythonfastpycall$^      if pyfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxt0$^        pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^       else$^      endif$^      if cythonfastpyccall$^      if pyxpyfastcfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxt0$^        pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^       else$^      endif$^      $^        pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxgotrefpyxt0$^        pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^        pyxgiverefpyxt0$^        pytuplesetitempyxt0 00 pyxt0$^        pyxt0  0$^        pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^      $^    $^    pyxdecrefpyxt0 pyxt0  0$^    pyxraisepyxt0 0 0 0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxerr0 000 pyxl0error$^$^     pywrapfst.pyx000$^    $^    cdef fst.queuetype queuetypeenum$^    if not fst.getqueuetypequeuetype addrqueuetypeenum              $^      raise fstargerrorunknown queue type r.formatqueuetype$^    return queuetypeenum$^ $^  $^$^   pywrapfst.pyx000$^    if not fst.getqueuetypequeuetype addrqueuetypeenum$^      raise fstargerrorunknown queue type r.formatqueuetype$^    return queuetypeenum              $^  $^  $^ $^  pyxr  pyxvqueuetypeenum$^  goto pyxl0$^$^   pywrapfst.pyx000$^  $^  $^  cdef fst.queuetype getqueuetypeconst string queuetype except               $^    matches string with the appropriate queuetype enum value.$^  $^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.getqueuetype pyxclineno pyxlineno pyxfilename$^  pyxr  enum fstqueuetype 0$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx000$^  $^  $^  cdef fst.randarcselection getrandarcselection              $^      const string select except $^    matches string with the appropriate randarcselection enum value.$^ $^$^static enum fstscriptrandarcselection pyxf0pywrapfstgetrandarcselectionstdstring const pyxvselect $^  enum fstscriptrandarcselection pyxvselectenum$^  enum fstscriptrandarcselection pyxr$^  pyxrefnannydeclarations$^  int pyxt0$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextgetrandarcselection 0$^$^   pywrapfst.pyx000$^    $^    cdef fst.randarcselection selectenum$^    if not fst.getrandarcselectionselect addrselectenum              $^      raise fstargerrorunknown random arc selection type r.formatselect$^    return selectenum$^ $^  pyxt0  fstscriptgetrandarcselectionpyxvselect pyxvselectenum  0  0$^  if unlikelypyxt0 $^$^     pywrapfst.pyx000$^    cdef fst.randarcselection selectenum$^    if not fst.getrandarcselectionselect addrselectenum$^      raise fstargerrorunknown random arc selection type r.formatselect              $^    return selectenum$^  $^ $^    pyxt0  pyxgetmoduleglobalnamepyxnsfstargerror if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  pyxpyobjectgetattrstrpyxkpsunknownrandomarcselectiontyp pyxnsformat if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  pyxconvertpybytesstringtopystdinstringpyxvselect if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  null$^    if cythonunpackmethods  likelypymethodcheckpyxt0 $^      pyxt0  pymethodgetselfpyxt0$^      if likelypyxt0 $^        pyobject function  pymethodgetfunctionpyxt0$^        pyxincrefpyxt0$^        pyxincreffunction$^        pyxdecrefsetpyxt0 function$^      $^    $^    if pyxt0 $^      pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxgotrefpyxt0$^     else $^      if cythonfastpycall$^      if pyfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxt0$^        pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^       else$^      endif$^      if cythonfastpyccall$^      if pyxpyfastcfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxt0$^        pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^       else$^      endif$^      $^        pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxgotrefpyxt0$^        pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^        pyxgiverefpyxt0$^        pytuplesetitempyxt0 00 pyxt0$^        pyxt0  0$^        pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^      $^    $^    pyxdecrefpyxt0 pyxt0  0$^    pyxt0  null$^    if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^      pyxt0  pymethodgetselfpyxt0$^      if likelypyxt0 $^        pyobject function  pymethodgetfunctionpyxt0$^        pyxincrefpyxt0$^        pyxincreffunction$^        pyxdecrefsetpyxt0 function$^      $^    $^    if pyxt0 $^      pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxgotrefpyxt0$^     else $^      if cythonfastpycall$^      if pyfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxt0$^        pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^       else$^      endif$^      if cythonfastpyccall$^      if pyxpyfastcfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxt0$^        pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^       else$^      endif$^      $^        pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxgotrefpyxt0$^        pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^        pyxgiverefpyxt0$^        pytuplesetitempyxt0 00 pyxt0$^        pyxt0  0$^        pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^      $^    $^    pyxdecrefpyxt0 pyxt0  0$^    pyxraisepyxt0 0 0 0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxerr0 000 pyxl0error$^$^     pywrapfst.pyx000$^    $^    cdef fst.randarcselection selectenum$^    if not fst.getrandarcselectionselect addrselectenum              $^      raise fstargerrorunknown random arc selection type r.formatselect$^    return selectenum$^ $^  $^$^   pywrapfst.pyx000$^    if not fst.getrandarcselectionselect addrselectenum$^      raise fstargerrorunknown random arc selection type r.formatselect$^    return selectenum              $^  $^  $^ $^  pyxr  pyxvselectenum$^  goto pyxl0$^$^   pywrapfst.pyx000$^  $^  $^  cdef fst.randarcselection getrandarcselection              $^      const string select except $^    matches string with the appropriate randarcselection enum value.$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.getrandarcselection pyxclineno pyxlineno pyxfilename$^  pyxr  enum fstscriptrandarcselection 0$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx000$^  $^  $^  cdef fst.replacelabeltype getreplacelabeltype              $^      const string replacelabeltype bool epsilononreplace except $^    matches string with the appropriate replacelabeltype enum value.$^ $^$^static enum fstreplacelabeltype pyxf0pywrapfstgetreplacelabeltypestdstring const pyxvreplacelabeltype bool pyxvepsilononreplace $^  enum fstreplacelabeltype pyxvreplacelabeltypeenum$^  enum fstreplacelabeltype pyxr$^  pyxrefnannydeclarations$^  int pyxt0$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextgetreplacelabeltype 0$^$^   pywrapfst.pyx000$^    $^    cdef fst.replacelabeltype replacelabeltypeenum$^    if not fst.getreplacelabeltypereplacelabeltype epsilononreplace              $^                                   addrreplacelabeltypeenum$^      raise fstargerrorunknown replace label type r.format$^ $^  pyxt0  fstscriptgetreplacelabeltypepyxvreplacelabeltype pyxvepsilononreplace pyxvreplacelabeltypeenum  0  0$^  if unlikelypyxt0 $^$^     pywrapfst.pyx000$^    if not fst.getreplacelabeltypereplacelabeltype epsilononreplace$^                                   addrreplacelabeltypeenum$^      raise fstargerrorunknown replace label type r.format              $^                        replacelabeltype$^    return replacelabeltypeenum$^ $^    pyxt0  pyxgetmoduleglobalnamepyxnsfstargerror if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  pyxpyobjectgetattrstrpyxkpsunknownreplacelabeltyper pyxnsformat if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxgotrefpyxt0$^$^     pywrapfst.pyx000$^                                   addrreplacelabeltypeenum$^      raise fstargerrorunknown replace label type r.format$^                        replacelabeltype              $^    return replacelabeltypeenum$^  $^ $^    pyxt0  pyxconvertpybytesstringtopystdinstringpyxvreplacelabeltype if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  null$^    if cythonunpackmethods  likelypymethodcheckpyxt0 $^      pyxt0  pymethodgetselfpyxt0$^      if likelypyxt0 $^        pyobject function  pymethodgetfunctionpyxt0$^        pyxincrefpyxt0$^        pyxincreffunction$^        pyxdecrefsetpyxt0 function$^      $^    $^    if pyxt0 $^      pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxgotrefpyxt0$^     else $^      if cythonfastpycall$^      if pyfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxt0$^        pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^       else$^      endif$^      if cythonfastpyccall$^      if pyxpyfastcfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxt0$^        pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^       else$^      endif$^      $^        pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxgotrefpyxt0$^        pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^        pyxgiverefpyxt0$^        pytuplesetitempyxt0 00 pyxt0$^        pyxt0  0$^        pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^      $^    $^    pyxdecrefpyxt0 pyxt0  0$^    pyxt0  null$^    if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^      pyxt0  pymethodgetselfpyxt0$^      if likelypyxt0 $^        pyobject function  pymethodgetfunctionpyxt0$^        pyxincrefpyxt0$^        pyxincreffunction$^        pyxdecrefsetpyxt0 function$^      $^    $^    if pyxt0 $^      pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxgotrefpyxt0$^     else $^      if cythonfastpycall$^      if pyfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxt0$^        pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^       else$^      endif$^      if cythonfastpyccall$^      if pyxpyfastcfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxt0$^        pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^       else$^      endif$^      $^        pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxgotrefpyxt0$^        pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^        pyxgiverefpyxt0$^        pytuplesetitempyxt0 00 pyxt0$^        pyxt0  0$^        pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^      $^    $^    pyxdecrefpyxt0 pyxt0  0$^    pyxraisepyxt0 0 0 0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxerr0 000 pyxl0error$^$^     pywrapfst.pyx000$^    $^    cdef fst.replacelabeltype replacelabeltypeenum$^    if not fst.getreplacelabeltypereplacelabeltype epsilononreplace              $^                                   addrreplacelabeltypeenum$^      raise fstargerrorunknown replace label type r.format$^ $^  $^$^   pywrapfst.pyx000$^      raise fstargerrorunknown replace label type r.format$^                        replacelabeltype$^    return replacelabeltypeenum              $^  $^  $^ $^  pyxr  pyxvreplacelabeltypeenum$^  goto pyxl0$^$^   pywrapfst.pyx000$^  $^  $^  cdef fst.replacelabeltype getreplacelabeltype              $^      const string replacelabeltype bool epsilononreplace except $^    matches string with the appropriate replacelabeltype enum value.$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.getreplacelabeltype pyxclineno pyxlineno pyxfilename$^  pyxr  enum fstreplacelabeltype 0$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx000$^    $^  $^    def reprself              $^      return  weight  at 0xx.formatself.type self.tostring$^                                               idself$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst0weight0reprpyobject pyxvself proto$^static pyobject pyxpw0pywrapfst0weight0reprpyobject pyxvself $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextrepr wrapper 0$^  pyxr  pyxpf0pywrapfst0weightreprstruct pyxobj0pywrapfstweight pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst0weightreprstruct pyxobj0pywrapfstweight pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  int pyxt0$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextrepr 0$^$^   pywrapfst.pyx000$^  $^    def reprself$^      return  weight  at 0xx.formatself.type self.tostring              $^                                               idself$^  $^ $^  pyxxdecrefpyxr$^  pyxt0  pyxpyobjectgetattrstrpyxkpsweightat0xx pyxnsformat if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s type$^    pyxerr0 000 pyxl0error$^  $^  pyxt0  pyxconvertpybytesstringtopystdinstringstruct pyxvtabstruct0pywrapfstweight pyxvselfpyxvtabtypepyxvself 0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s tostring$^    pyxerr0 000 pyxl0error$^  $^  pyxt0  pyxconvertpybytesstringtopystdinstringstruct pyxvtabstruct0pywrapfstweight pyxvselfpyxvtabtostringpyxvself 0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^$^   pywrapfst.pyx000$^    def reprself$^      return  weight  at 0xx.formatself.type self.tostring$^                                               idself              $^  $^    def strself$^ $^  pyxt0  pyxpyobjectcalloneargpyxbuiltinid pyobject pyxvself if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxt0  null$^  pyxt0  0$^  if cythonunpackmethods  likelypymethodcheckpyxt0 $^    pyxt0  pymethodgetselfpyxt0$^    if likelypyxt0 $^      pyobject function  pymethodgetfunctionpyxt0$^      pyxincrefpyxt0$^      pyxincreffunction$^      pyxdecrefsetpyxt0 function$^      pyxt0  0$^    $^  $^  if cythonfastpycall$^  if pyfunctioncheckpyxt0 $^    pyobject pyxtemp0  pyxt0 pyxt0 pyxt0 pyxt0$^    pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp0pyxt0 0pyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxxdecrefpyxt0 pyxt0  0$^    pyxgotrefpyxt0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxdecrefpyxt0 pyxt0  0$^   else$^  endif$^  if cythonfastpyccall$^  if pyxpyfastcfunctioncheckpyxt0 $^    pyobject pyxtemp0  pyxt0 pyxt0 pyxt0 pyxt0$^    pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp0pyxt0 0pyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxxdecrefpyxt0 pyxt0  0$^    pyxgotrefpyxt0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxdecrefpyxt0 pyxt0  0$^   else$^  endif$^  $^    pyxt0  pytuplenew0pyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxgotrefpyxt0$^    if pyxt0 $^      pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^    $^    pyxgiverefpyxt0$^    pytuplesetitempyxt0 0pyxt0 pyxt0$^    pyxgiverefpyxt0$^    pytuplesetitempyxt0 0pyxt0 pyxt0$^    pyxgiverefpyxt0$^    pytuplesetitempyxt0 0pyxt0 pyxt0$^    pyxt0  0$^    pyxt0  0$^    pyxt0  0$^    pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxgotrefpyxt0$^    pyxdecrefpyxt0 pyxt0  0$^  $^  pyxdecrefpyxt0 pyxt0  0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   pywrapfst.pyx000$^    $^  $^    def reprself              $^      return  weight  at 0xx.formatself.type self.tostring$^                                               idself$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.weight.repr pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx000$^                                               idself$^  $^    def strself              $^      return self.tostring$^  $^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst0weight0strpyobject pyxvself proto$^static pyobject pyxpw0pywrapfst0weight0strpyobject pyxvself $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextstr wrapper 0$^  pyxr  pyxpf0pywrapfst0weight0strstruct pyxobj0pywrapfstweight pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst0weight0strstruct pyxobj0pywrapfstweight pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextstr 0$^$^   pywrapfst.pyx000$^  $^    def strself$^      return self.tostring              $^  $^     this attempts to convert the string form into a float raising$^ $^  pyxxdecrefpyxr$^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s tostring$^    pyxerr0 000 pyxl0error$^  $^  pyxt0  pyxconvertpybytesstringtopystdinstringstruct pyxvtabstruct0pywrapfstweight pyxvselfpyxvtabtostringpyxvself 0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   pywrapfst.pyx000$^                                               idself$^  $^    def strself              $^      return self.tostring$^  $^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.weight.str pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx000$^     valueerror when that is not appropriate.$^  $^    def floatself              $^      return floatself.tostring$^  $^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst0weight0floatpyobject pyxvself proto$^static pyobject pyxpw0pywrapfst0weight0floatpyobject pyxvself $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextfloat wrapper 0$^  pyxr  pyxpf0pywrapfst0weight0floatstruct pyxobj0pywrapfstweight pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst0weight0floatstruct pyxobj0pywrapfstweight pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextfloat 0$^$^   pywrapfst.pyx000$^  $^    def floatself$^      return floatself.tostring              $^  $^    def initself weighttype weight$^ $^  pyxxdecrefpyxr$^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s tostring$^    pyxerr0 000 pyxl0error$^  $^  pyxt0  pyxconvertpybytesstringtopystdinstringstruct pyxvtabstruct0pywrapfstweight pyxvselfpyxvtabtostringpyxvself 0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxt0  pyxpynumberfloatpyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxdecrefpyxt0 pyxt0  0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   pywrapfst.pyx000$^     valueerror when that is not appropriate.$^  $^    def floatself              $^      return floatself.tostring$^  $^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.weight.float pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx000$^      return floatself.tostring$^  $^    def initself weighttype weight              $^      self.weight.resetnew fst.weightclasstostringweighttype$^                                             weighttostringweight$^ $^$^ python wrapper $^static int pyxpw0pywrapfst0weight0initpyobject pyxvself pyobject pyxargs pyobject pyxkwds proto$^static int pyxpw0pywrapfst0weight0initpyobject pyxvself pyobject pyxargs pyobject pyxkwds $^  pyobject pyxvweighttype  0$^  pyobject pyxvweight  0$^  int pyxr$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextinit wrapper 0$^  $^    static pyobject pyxpyargnames  pyxnsweighttypepyxnsweight0$^    pyobject values0  00$^    if unlikelypyxkwds $^      pyssizet kwargs$^      const pyssizet posargs  pytuplegetsizepyxargs$^      switch posargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 break$^        default goto pyxl0argtupleerror$^      $^      kwargs  pydictsizepyxkwds$^      switch posargs $^        case  0$^        if likelyvalues0  pyxpydictgetitemstrpyxkwds pyxnsweighttype  0 kwargs$^        else goto pyxl0argtupleerror$^        cythonfallthrough$^        case  0$^        if likelyvalues0  pyxpydictgetitemstrpyxkwds pyxnsweight  0 kwargs$^        else $^          pyxraiseargtupleinvalidinit 0 0 0 0 pyxerr0 000 pyxl0error$^        $^      $^      if unlikelykwargs  0 $^        if unlikelypyxparseoptionalkeywordspyxkwds pyxpyargnames 0 values posargs init  0 pyxerr0 000 pyxl0error$^      $^     else if pytuplegetsizepyxargs  0 $^      goto pyxl0argtupleerror$^     else $^      values0  pytuplegetitempyxargs 0$^      values0  pytuplegetitempyxargs 0$^    $^    pyxvweighttype  values0$^    pyxvweight  values0$^  $^  goto pyxl0argumentunpackingdone$^  pyxl0argtupleerror$^  pyxraiseargtupleinvalidinit 0 0 0 pytuplegetsizepyxargs pyxerr0 000 pyxl0error$^  pyxl0error$^  pyxaddtracebackpywrapfst.weight.init pyxclineno pyxlineno pyxfilename$^  pyxrefnannyfinishcontext$^  return 0$^  pyxl0argumentunpackingdone$^  pyxr  pyxpf0pywrapfst0weight0initstruct pyxobj0pywrapfstweight pyxvself pyxvweighttype pyxvweight$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static int pyxpf0pywrapfst0weight0initstruct pyxobj0pywrapfstweight pyxvself pyobject pyxvweighttype pyobject pyxvweight $^  int pyxr$^  pyxrefnannydeclarations$^  stdstring pyxt0$^  stdstring pyxt0$^  pyxrefnannysetupcontextinit 0$^$^   pywrapfst.pyx000$^  $^    def initself weighttype weight$^      self.weight.resetnew fst.weightclasstostringweighttype              $^                                             weighttostringweight$^      self.checkweight$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s weight$^    pyxerr0 000 pyxl0error$^  $^  pyxt0  pyxf0pywrapfsttostringpyxvweighttype null if unlikelypyerroccurred pyxerr0 000 pyxl0error$^$^   pywrapfst.pyx000$^    def initself weighttype weight$^      self.weight.resetnew fst.weightclasstostringweighttype$^                                             weighttostringweight              $^      self.checkweight$^  $^ $^  pyxt0  pyxf0pywrapfstweighttostringpyxvweight null if unlikelypyerroccurred pyxerr0 000 pyxl0error$^$^   pywrapfst.pyx000$^  $^    def initself weighttype weight$^      self.weight.resetnew fst.weightclasstostringweighttype              $^                                             weighttostringweight$^      self.checkweight$^ $^  pyxvselfweight.resetnew fstscriptweightclasspyxt0 pyxt0$^$^   pywrapfst.pyx000$^      self.weight.resetnew fst.weightclasstostringweighttype$^                                             weighttostringweight$^      self.checkweight              $^  $^    cdef void checkweightself except $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s checkweight$^    pyxerr0 000 pyxl0error$^  $^  struct pyxvtabstruct0pywrapfstweight pyxvselfpyxvtabcheckweightpyxvself if unlikelypyerroccurred pyxerr0 000 pyxl0error$^$^   pywrapfst.pyx000$^      return floatself.tostring$^  $^    def initself weighttype weight              $^      self.weight.resetnew fst.weightclasstostringweighttype$^                                             weighttostringweight$^ $^$^   function exit code $^  pyxr  0$^  goto pyxl0$^  pyxl0error$^  pyxaddtracebackpywrapfst.weight.init pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx000$^      self.checkweight$^  $^    cdef void checkweightself except               $^      if self.type  bnone$^        raise fstargerrorweight type not found$^ $^$^static void pyxf0pywrapfst0weightcheckweightstruct pyxobj0pywrapfstweight pyxvself $^  pyxrefnannydeclarations$^  int pyxt0$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextcheckweight 0$^$^   pywrapfst.pyx000$^  $^    cdef void checkweightself except $^      if self.type  bnone              $^        raise fstargerrorweight type not found$^      if self.tostring  bbadnumber$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s type$^    pyxerr0 000 pyxl0error$^  $^  pyxt0  struct pyxvtabstruct0pywrapfstweight pyxvselfpyxvtabtypepyxvself 0  char const none  0$^  if unlikelypyxt0 $^$^     pywrapfst.pyx000$^    cdef void checkweightself except $^      if self.type  bnone$^        raise fstargerrorweight type not found              $^      if self.tostring  bbadnumber$^        raise fstbadweighterrorinvalid weight$^ $^    pyxt0  pyxgetmoduleglobalnamepyxnsfstargerror if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  pyxpyobjectcallpyxt0 pyxtuple null if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxgotrefpyxt0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxraisepyxt0 0 0 0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxerr0 000 pyxl0error$^$^     pywrapfst.pyx000$^  $^    cdef void checkweightself except $^      if self.type  bnone              $^        raise fstargerrorweight type not found$^      if self.tostring  bbadnumber$^ $^  $^$^   pywrapfst.pyx000$^      if self.type  bnone$^        raise fstargerrorweight type not found$^      if self.tostring  bbadnumber              $^        raise fstbadweighterrorinvalid weight$^  $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s tostring$^    pyxerr0 000 pyxl0error$^  $^  pyxt0  struct pyxvtabstruct0pywrapfstweight pyxvselfpyxvtabtostringpyxvself 0  char const badnumber  0$^  if unlikelypyxt0 $^$^     pywrapfst.pyx000$^        raise fstargerrorweight type not found$^      if self.tostring  bbadnumber$^        raise fstbadweighterrorinvalid weight              $^  $^    cpdef weight copyself$^ $^    pyxt0  pyxgetmoduleglobalnamepyxnsfstbadweighterror if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  pyxpyobjectcallpyxt0 pyxtuple0 null if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxgotrefpyxt0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxraisepyxt0 0 0 0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxerr0 000 pyxl0error$^$^     pywrapfst.pyx000$^      if self.type  bnone$^        raise fstargerrorweight type not found$^      if self.tostring  bbadnumber              $^        raise fstbadweighterrorinvalid weight$^  $^ $^  $^$^   pywrapfst.pyx000$^      self.checkweight$^  $^    cdef void checkweightself except               $^      if self.type  bnone$^        raise fstargerrorweight type not found$^ $^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.weight.checkweight pyxclineno pyxlineno pyxfilename$^  pyxl0$^  pyxrefnannyfinishcontext$^$^$^ pywrapfst.pyx000$^        raise fstbadweighterrorinvalid weight$^  $^    cpdef weight copyself              $^      $^      copyself$^ $^$^static pyobject pyxpw0pywrapfst0weight0copypyobject pyxvself cythonunused pyobject unused proto$^static struct pyxobj0pywrapfstweight pyxf0pywrapfst0weightcopystruct pyxobj0pywrapfstweight pyxvself int pyxskipdispatch $^  struct pyxobj0pywrapfstweight pyxvresult  0$^  struct pyxobj0pywrapfstweight pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextcopy 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnscopy if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst0weight0copy $^      pyxxdecrefpyobject pyxr$^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxdecrefpyxt0 pyxt0  0$^       else $^        pyxt0  pyxpyobjectcallnoargpyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^      $^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      if likelypyxt0  pynone  likelypyxtypetestpyxt0 pyxptype0pywrapfstweight pyxerr0 000 pyxl0error$^      pyxr  struct pyxobj0pywrapfstweight pyxt0$^      pyxt0  0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx000$^      returns a copy of the weight.$^      $^      cdef weight result  weight.newweight              $^      result.weight.resetnew fst.weightclassderefself.weight$^      return result$^ $^  pyxt0  pyobject pyxtpnew0pywrapfstweightpytypeobject pyxptype0pywrapfstweight pyxemptytuple null if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyobject pyxt0$^  pyxvresult  struct pyxobj0pywrapfstweight pyxt0$^  pyxt0  0$^$^   pywrapfst.pyx000$^      $^      cdef weight result  weight.newweight$^      result.weight.resetnew fst.weightclassderefself.weight              $^      return result$^  $^ $^  if unlikelypyobject pyxvresult  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s weight$^    pyxerr0 000 pyxl0error$^  $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s weight$^    pyxerr0 000 pyxl0error$^  $^  pyxvresultweight.resetnew fstscriptweightclasspyxvselfweight$^$^   pywrapfst.pyx000$^      cdef weight result  weight.newweight$^      result.weight.resetnew fst.weightclassderefself.weight$^      return result              $^  $^     to get around the inability to declare cdef class methods we define the$^ $^  pyxxdecrefpyobject pyxr$^  pyxincrefpyobject pyxvresult$^  pyxr  pyxvresult$^  goto pyxl0$^$^   pywrapfst.pyx000$^        raise fstbadweighterrorinvalid weight$^  $^    cpdef weight copyself              $^      $^      copyself$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.weight.copy pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxl0$^  pyxxdecrefpyobject pyxvresult$^  pyxxgiverefpyobject pyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst0weight0copypyobject pyxvself cythonunused pyobject unused proto$^static char pyxdoc0pywrapfst0weight0copy  n    copyselfnn    returns a copy of the weight.n    $^static pyobject pyxpw0pywrapfst0weight0copypyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextcopy wrapper 0$^  pyxr  pyxpf0pywrapfst0weight0copystruct pyxobj0pywrapfstweight pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst0weight0copystruct pyxobj0pywrapfstweight pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextcopy 0$^  pyxxdecrefpyxr$^  pyxt0  pyobject pyxf0pywrapfst0weightcopypyxvself 0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.weight.copy pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx000$^  $^    classmethod$^    def zerocls weighttype              $^      $^      weight.zeroweighttype$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst0weight00zeropyobject pyxvcls pyobject pyxvweighttype proto$^static char pyxdoc0pywrapfst0weight00zero  n    weight.zeroweighttypenn    constructs semiring zero.n    $^static pyobject pyxpw0pywrapfst0weight00zeropyobject pyxvcls pyobject pyxvweighttype $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextzero wrapper 0$^  pyxr  pyxpf0pywrapfst0weight00zeropytypeobjectpyxvcls pyobject pyxvweighttype$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst0weight00zerocythonunused pytypeobject pyxvcls pyobject pyxvweighttype $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextzero 0$^$^   pywrapfst.pyx000$^      constructs semiring zero.$^      $^      return zeroweighttype              $^  $^    classmethod$^ $^  pyxxdecrefpyxr$^  pyxt0  pyobject pyxf0pywrapfstzeropyxvweighttype if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   pywrapfst.pyx000$^  $^    classmethod$^    def zerocls weighttype              $^      $^      weight.zeroweighttype$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.weight.zero pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx000$^  $^    classmethod$^    def onecls weighttype              $^      $^      weight.oneweighttype$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst0weight00onepyobject pyxvcls pyobject pyxvweighttype proto$^static char pyxdoc0pywrapfst0weight00one  n    weight.oneweighttypenn    constructs semiring one.n    $^static pyobject pyxpw0pywrapfst0weight00onepyobject pyxvcls pyobject pyxvweighttype $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextone wrapper 0$^  pyxr  pyxpf0pywrapfst0weight00onepytypeobjectpyxvcls pyobject pyxvweighttype$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst0weight00onecythonunused pytypeobject pyxvcls pyobject pyxvweighttype $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextone 0$^$^   pywrapfst.pyx000$^      constructs semiring one.$^      $^      return oneweighttype              $^  $^    classmethod$^ $^  pyxxdecrefpyxr$^  pyxt0  pyobject pyxf0pywrapfstonepyxvweighttype if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   pywrapfst.pyx000$^  $^    classmethod$^    def onecls weighttype              $^      $^      weight.oneweighttype$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.weight.one pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx000$^  $^    classmethod$^    def noweightcls weighttype              $^      $^      weight.noweightweighttype$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst0weight00noweightpyobject pyxvcls pyobject pyxvweighttype proto$^static char pyxdoc0pywrapfst0weight00noweight  n    weight.noweightweighttypenn    constructs a nonmember weight in the semiring.n    $^static pyobject pyxpw0pywrapfst0weight00noweightpyobject pyxvcls pyobject pyxvweighttype $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextnoweight wrapper 0$^  pyxr  pyxpf0pywrapfst0weight00noweightpytypeobjectpyxvcls pyobject pyxvweighttype$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst0weight00noweightcythonunused pytypeobject pyxvcls pyobject pyxvweighttype $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextnoweight 0$^$^   pywrapfst.pyx000$^      constructs a nonmember weight in the semiring.$^      $^      return noweightweighttype              $^  $^    def eqweight w0 weight w0$^ $^  pyxxdecrefpyxr$^  pyxt0  pyobject pyxf0pywrapfstnoweightpyxvweighttype if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   pywrapfst.pyx000$^  $^    classmethod$^    def noweightcls weighttype              $^      $^      weight.noweightweighttype$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.weight.noweight pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx000$^      return noweightweighttype$^  $^    def eqweight w0 weight w0              $^      return fst.eqderefw0.weight derefw0.weight$^  $^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst0weight00eqpyobject pyxvw0 pyobject pyxvw0 proto$^static pyobject pyxpw0pywrapfst0weight00eqpyobject pyxvw0 pyobject pyxvw0 $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontexteq wrapper 0$^  if unlikelypyxargtypetestpyobject pyxvw0 pyxptype0pywrapfstweight 0 w0 0 pyxerr0 000 pyxl0error$^  pyxr  pyxpf0pywrapfst0weight00eqstruct pyxobj0pywrapfstweight pyxvw0 struct pyxobj0pywrapfstweight pyxvw0$^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxr  null$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst0weight00eqstruct pyxobj0pywrapfstweight pyxvw0 struct pyxobj0pywrapfstweight pyxvw0 $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontexteq 0$^$^   pywrapfst.pyx000$^  $^    def eqweight w0 weight w0$^      return fst.eqderefw0.weight derefw0.weight              $^  $^    def neweight w0 weight w0$^ $^  pyxxdecrefpyxr$^  if unlikelypyobject pyxvw0  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s weight$^    pyxerr0 000 pyxl0error$^  $^  if unlikelypyobject pyxvw0  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s weight$^    pyxerr0 000 pyxl0error$^  $^  pyxt0  pyxpyboolfromlongoperatorpyxvw0weight pyxvw0weight if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   pywrapfst.pyx000$^      return noweightweighttype$^  $^    def eqweight w0 weight w0              $^      return fst.eqderefw0.weight derefw0.weight$^  $^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.weight.eq pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx000$^      return fst.eqderefw0.weight derefw0.weight$^  $^    def neweight w0 weight w0              $^      return not w0  w0$^  $^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst0weight00nepyobject pyxvw0 pyobject pyxvw0 proto$^static pyobject pyxpw0pywrapfst0weight00nepyobject pyxvw0 pyobject pyxvw0 $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextne wrapper 0$^  if unlikelypyxargtypetestpyobject pyxvw0 pyxptype0pywrapfstweight 0 w0 0 pyxerr0 000 pyxl0error$^  pyxr  pyxpf0pywrapfst0weight00nestruct pyxobj0pywrapfstweight pyxvw0 struct pyxobj0pywrapfstweight pyxvw0$^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxr  null$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst0weight00nestruct pyxobj0pywrapfstweight pyxvw0 struct pyxobj0pywrapfstweight pyxvw0 $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  int pyxt0$^  pyxrefnannysetupcontextne 0$^$^   pywrapfst.pyx000$^  $^    def neweight w0 weight w0$^      return not w0  w0              $^  $^    cpdef string tostringself$^ $^  pyxxdecrefpyxr$^  pyxt0  pyobjectrichcomparepyobject pyxvw0 pyobject pyxvw0 pyeq pyxxgotrefpyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxt0  pyxpyobjectistruepyxt0 if unlikelypyxt0  0 pyxerr0 000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^  pyxt0  pyxpyboolfromlongpyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   pywrapfst.pyx000$^      return fst.eqderefw0.weight derefw0.weight$^  $^    def neweight w0 weight w0              $^      return not w0  w0$^  $^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.weight.ne pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx000$^      return not w0  w0$^  $^    cpdef string tostringself              $^      return self.weight.get.tostring$^  $^ $^$^static pyobject pyxpw0pywrapfst0weight00tostringpyobject pyxvself cythonunused pyobject unused proto$^static stdstring pyxf0pywrapfst0weighttostringstruct pyxobj0pywrapfstweight pyxvself int pyxskipdispatch $^  stdstring pyxr$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  stdstring pyxt0$^  pyxrefnannysetupcontexttostring 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnstostring if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst0weight00tostring $^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxdecrefpyxt0 pyxt0  0$^       else $^        pyxt0  pyxpyobjectcallnoargpyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^      $^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxt0  pyxconvertstringfrompystdinstringpyxt0 if unlikelypyerroccurred pyxerr0 000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxr  pyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx000$^  $^    cpdef string tostringself$^      return self.weight.get.tostring              $^  $^    cpdef string typeself$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s weight$^    pyxerr0 000 pyxl0error$^  $^  pyxr  pyxvselfweight.gettostring$^  goto pyxl0$^$^   pywrapfst.pyx000$^      return not w0  w0$^  $^    cpdef string tostringself              $^      return self.weight.get.tostring$^  $^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxwriteunraisablepywrapfst.weight.tostring pyxclineno pyxlineno pyxfilename 0 0$^  pyxpretendtoinitializepyxr$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst0weight00tostringpyobject pyxvself cythonunused pyobject unused proto$^static pyobject pyxpw0pywrapfst0weight00tostringpyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontexttostring wrapper 0$^  pyxr  pyxpf0pywrapfst0weight00tostringstruct pyxobj0pywrapfstweight pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst0weight00tostringstruct pyxobj0pywrapfstweight pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontexttostring 0$^  pyxxdecrefpyxr$^  pyxt0  pyxconvertpybytesstringtopystdinstringpyxf0pywrapfst0weighttostringpyxvself 0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.weight.tostring pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx000$^      return self.weight.get.tostring$^  $^    cpdef string typeself              $^      typeself$^  $^ $^$^static pyobject pyxpw0pywrapfst0weight00typepyobject pyxvself cythonunused pyobject unused proto$^static stdstring pyxf0pywrapfst0weighttypestruct pyxobj0pywrapfstweight pyxvself int pyxskipdispatch $^  stdstring pyxr$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  stdstring pyxt0$^  pyxrefnannysetupcontexttype 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnstype if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst0weight00type $^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxdecrefpyxt0 pyxt0  0$^       else $^        pyxt0  pyxpyobjectcallnoargpyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^      $^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxt0  pyxconvertstringfrompystdinstringpyxt0 if unlikelypyerroccurred pyxerr0 000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxr  pyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx000$^      returns a string indicating the weight type.$^      $^      return self.weight.get.type              $^  $^  $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s weight$^    pyxerr0 000 pyxl0error$^  $^  pyxr  pyxvselfweight.gettype$^  goto pyxl0$^$^   pywrapfst.pyx000$^      return self.weight.get.tostring$^  $^    cpdef string typeself              $^      typeself$^  $^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxwriteunraisablepywrapfst.weight.type pyxclineno pyxlineno pyxfilename 0 0$^  pyxpretendtoinitializepyxr$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst0weight00typepyobject pyxvself cythonunused pyobject unused proto$^static char pyxdoc0pywrapfst0weight00type  typeselfnn    returns a string indicating the weight type.n    $^static pyobject pyxpw0pywrapfst0weight00typepyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontexttype wrapper 0$^  pyxr  pyxpf0pywrapfst0weight00typestruct pyxobj0pywrapfstweight pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst0weight00typestruct pyxobj0pywrapfstweight pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontexttype 0$^  pyxxdecrefpyxr$^  pyxt0  pyxconvertpybytesstringtopystdinstringpyxf0pywrapfst0weighttypepyxvself 0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.weight.type pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ tree fragment0$^  def reducecythonself              $^      raise typeerrorself.weight cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst0weight00reducecythonpyobject pyxvself cythonunused pyobject unused proto$^static pyobject pyxpw0pywrapfst0weight00reducecythonpyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextreducecython wrapper 0$^  pyxr  pyxpf0pywrapfst0weight00reducecythonstruct pyxobj0pywrapfstweight pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst0weight00reducecythoncythonunused struct pyxobj0pywrapfstweight pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextreducecython 0$^$^   tree fragment0$^  def reducecythonself$^      raise typeerrorself.weight cannot be converted to a python object for pickling              $^  def setstatecythonself pyxstate$^      raise typeerrorself.weight cannot be converted to a python object for pickling$^ $^  pyxt0  pyxpyobjectcallpyxbuiltintypeerror pyxtuple0 null if unlikelypyxt0 pyxerr0 0 pyxl0error$^  pyxgotrefpyxt0$^  pyxraisepyxt0 0 0 0$^  pyxdecrefpyxt0 pyxt0  0$^  pyxerr0 0 pyxl0error$^$^   tree fragment0$^  def reducecythonself              $^      raise typeerrorself.weight cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.weight.reducecython pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ tree fragment0$^  def reducecythonself$^      raise typeerrorself.weight cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate              $^      raise typeerrorself.weight cannot be converted to a python object for pickling$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst0weight00setstatecythonpyobject pyxvself pyobject pyxvpyxstate proto$^static pyobject pyxpw0pywrapfst0weight00setstatecythonpyobject pyxvself pyobject pyxvpyxstate $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextsetstatecython wrapper 0$^  pyxr  pyxpf0pywrapfst0weight00setstatecythonstruct pyxobj0pywrapfstweight pyxvself pyobject pyxvpyxstate$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst0weight00setstatecythoncythonunused struct pyxobj0pywrapfstweight pyxvself cythonunused pyobject pyxvpyxstate $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextsetstatecython 0$^$^   tree fragment0$^      raise typeerrorself.weight cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate$^      raise typeerrorself.weight cannot be converted to a python object for pickling              $^ $^  pyxt0  pyxpyobjectcallpyxbuiltintypeerror pyxtuple0 null if unlikelypyxt0 pyxerr0 0 pyxl0error$^  pyxgotrefpyxt0$^  pyxraisepyxt0 0 0 0$^  pyxdecrefpyxt0 pyxt0  0$^  pyxerr0 0 pyxl0error$^$^   tree fragment0$^  def reducecythonself$^      raise typeerrorself.weight cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate              $^      raise typeerrorself.weight cannot be converted to a python object for pickling$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.weight.setstatecython pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx000$^  $^  $^  cdef weight plusweight lhs weight rhs              $^    cdef weight result  weight.newweight$^    result.weight.resetnew fst.weightclassfst.plusdereflhs.weight$^ $^$^static struct pyxobj0pywrapfstweight pyxf0pywrapfstplusstruct pyxobj0pywrapfstweight pyxvlhs struct pyxobj0pywrapfstweight pyxvrhs $^  struct pyxobj0pywrapfstweight pyxvresult  0$^  struct pyxobj0pywrapfstweight pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextplus 0$^$^   pywrapfst.pyx000$^  $^  cdef weight plusweight lhs weight rhs$^    cdef weight result  weight.newweight              $^    result.weight.resetnew fst.weightclassfst.plusdereflhs.weight$^                                                      derefrhs.weight$^ $^  pyxt0  pyobject pyxtpnew0pywrapfstweightpytypeobject pyxptype0pywrapfstweight pyxemptytuple null if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyobject pyxt0$^  pyxvresult  struct pyxobj0pywrapfstweight pyxt0$^  pyxt0  0$^$^   pywrapfst.pyx000$^  cdef weight plusweight lhs weight rhs$^    cdef weight result  weight.newweight$^    result.weight.resetnew fst.weightclassfst.plusdereflhs.weight              $^                                                      derefrhs.weight$^    return result$^ $^  if unlikelypyobject pyxvresult  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s weight$^    pyxerr0 000 pyxl0error$^  $^  if unlikelypyobject pyxvlhs  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s weight$^    pyxerr0 000 pyxl0error$^  $^$^   pywrapfst.pyx000$^    cdef weight result  weight.newweight$^    result.weight.resetnew fst.weightclassfst.plusdereflhs.weight$^                                                      derefrhs.weight              $^    return result$^  $^ $^  if unlikelypyobject pyxvrhs  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s weight$^    pyxerr0 000 pyxl0error$^  $^$^   pywrapfst.pyx000$^  cdef weight plusweight lhs weight rhs$^    cdef weight result  weight.newweight$^    result.weight.resetnew fst.weightclassfst.plusdereflhs.weight              $^                                                      derefrhs.weight$^    return result$^ $^  pyxvresultweight.resetnew fstscriptweightclassfstscriptpluspyxvlhsweight pyxvrhsweight$^$^   pywrapfst.pyx000$^    result.weight.resetnew fst.weightclassfst.plusdereflhs.weight$^                                                      derefrhs.weight$^    return result              $^  $^  $^ $^  pyxxdecrefpyobject pyxr$^  pyxincrefpyobject pyxvresult$^  pyxr  pyxvresult$^  goto pyxl0$^$^   pywrapfst.pyx000$^  $^  $^  cdef weight plusweight lhs weight rhs              $^    cdef weight result  weight.newweight$^    result.weight.resetnew fst.weightclassfst.plusdereflhs.weight$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.plus pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxl0$^  pyxxdecrefpyobject pyxvresult$^  pyxxgiverefpyobject pyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx000$^  $^  $^  def plusweight lhs weight rhs              $^    $^    pluslhs rhs$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst0pluspyobject pyxself pyobject pyxargs pyobject pyxkwds proto$^static char pyxdoc0pywrapfstplus  n  pluslhs rhsnn  computes the sum of two weights in the same semiring.nn  this function computes lhs oplus rhs raising an exception if lhs and rhsn  are not in the same semiring.nn  argsn     lhs lefthand side weight.n     rhs righthand side weight.nn  returnsn    a weight object.nn  raisesn    fstargerror weight type not found or not in same semiring.n    fstbadweighterror invalid weight.n  $^static pymethoddef pyxmdef0pywrapfst0plus  plus pycfunctionpyxpw0pywrapfst0plus methvarargsmethkeywords pyxdoc0pywrapfstplus$^static pyobject pyxpw0pywrapfst0pluspyobject pyxself pyobject pyxargs pyobject pyxkwds $^  struct pyxobj0pywrapfstweight pyxvlhs  0$^  struct pyxobj0pywrapfstweight pyxvrhs  0$^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextplus wrapper 0$^  $^    static pyobject pyxpyargnames  pyxnslhspyxnsrhs0$^    pyobject values0  00$^    if unlikelypyxkwds $^      pyssizet kwargs$^      const pyssizet posargs  pytuplegetsizepyxargs$^      switch posargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 break$^        default goto pyxl0argtupleerror$^      $^      kwargs  pydictsizepyxkwds$^      switch posargs $^        case  0$^        if likelyvalues0  pyxpydictgetitemstrpyxkwds pyxnslhs  0 kwargs$^        else goto pyxl0argtupleerror$^        cythonfallthrough$^        case  0$^        if likelyvalues0  pyxpydictgetitemstrpyxkwds pyxnsrhs  0 kwargs$^        else $^          pyxraiseargtupleinvalidplus 0 0 0 0 pyxerr0 000 pyxl0error$^        $^      $^      if unlikelykwargs  0 $^        if unlikelypyxparseoptionalkeywordspyxkwds pyxpyargnames 0 values posargs plus  0 pyxerr0 000 pyxl0error$^      $^     else if pytuplegetsizepyxargs  0 $^      goto pyxl0argtupleerror$^     else $^      values0  pytuplegetitempyxargs 0$^      values0  pytuplegetitempyxargs 0$^    $^    pyxvlhs  struct pyxobj0pywrapfstweight values0$^    pyxvrhs  struct pyxobj0pywrapfstweight values0$^  $^  goto pyxl0argumentunpackingdone$^  pyxl0argtupleerror$^  pyxraiseargtupleinvalidplus 0 0 0 pytuplegetsizepyxargs pyxerr0 000 pyxl0error$^  pyxl0error$^  pyxaddtracebackpywrapfst.plus pyxclineno pyxlineno pyxfilename$^  pyxrefnannyfinishcontext$^  return null$^  pyxl0argumentunpackingdone$^  if unlikelypyxargtypetestpyobject pyxvlhs pyxptype0pywrapfstweight 0 lhs 0 pyxerr0 000 pyxl0error$^  if unlikelypyxargtypetestpyobject pyxvrhs pyxptype0pywrapfstweight 0 rhs 0 pyxerr0 000 pyxl0error$^  pyxr  pyxpf0pywrapfstpluspyxself pyxvlhs pyxvrhs$^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxr  null$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfstpluscythonunused pyobject pyxself struct pyxobj0pywrapfstweight pyxvlhs struct pyxobj0pywrapfstweight pyxvrhs $^  struct pyxobj0pywrapfstweight pyxvresult  0$^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextplus 0$^$^   pywrapfst.pyx000$^      fstbadweighterror invalid weight.$^    $^    cdef weight result  pluslhs rhs              $^    result.checkweight$^    return result$^ $^  pyxt0  pyobject pyxf0pywrapfstpluspyxvlhs pyxvrhs if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxvresult  struct pyxobj0pywrapfstweight pyxt0$^  pyxt0  0$^$^   pywrapfst.pyx000$^    $^    cdef weight result  pluslhs rhs$^    result.checkweight              $^    return result$^  $^ $^  if unlikelypyobject pyxvresult  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s checkweight$^    pyxerr0 000 pyxl0error$^  $^  struct pyxvtabstruct0pywrapfstweight pyxvresultpyxvtabcheckweightpyxvresult if unlikelypyerroccurred pyxerr0 000 pyxl0error$^$^   pywrapfst.pyx000$^    cdef weight result  pluslhs rhs$^    result.checkweight$^    return result              $^  $^  $^ $^  pyxxdecrefpyxr$^  pyxincrefpyobject pyxvresult$^  pyxr  pyobject pyxvresult$^  goto pyxl0$^$^   pywrapfst.pyx000$^  $^  $^  def plusweight lhs weight rhs              $^    $^    pluslhs rhs$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.plus pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxdecrefpyobject pyxvresult$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx000$^  $^  $^  cdef weight timesweight lhs weight rhs              $^    cdef weight result  weight.newweight$^    result.weight.resetnew fst.weightclassfst.timesdereflhs.weight$^ $^$^static struct pyxobj0pywrapfstweight pyxf0pywrapfsttimesstruct pyxobj0pywrapfstweight pyxvlhs struct pyxobj0pywrapfstweight pyxvrhs $^  struct pyxobj0pywrapfstweight pyxvresult  0$^  struct pyxobj0pywrapfstweight pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontexttimes 0$^$^   pywrapfst.pyx000$^  $^  cdef weight timesweight lhs weight rhs$^    cdef weight result  weight.newweight              $^    result.weight.resetnew fst.weightclassfst.timesdereflhs.weight$^                                                       derefrhs.weight$^ $^  pyxt0  pyobject pyxtpnew0pywrapfstweightpytypeobject pyxptype0pywrapfstweight pyxemptytuple null if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyobject pyxt0$^  pyxvresult  struct pyxobj0pywrapfstweight pyxt0$^  pyxt0  0$^$^   pywrapfst.pyx000$^  cdef weight timesweight lhs weight rhs$^    cdef weight result  weight.newweight$^    result.weight.resetnew fst.weightclassfst.timesdereflhs.weight              $^                                                       derefrhs.weight$^    return result$^ $^  if unlikelypyobject pyxvresult  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s weight$^    pyxerr0 000 pyxl0error$^  $^  if unlikelypyobject pyxvlhs  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s weight$^    pyxerr0 000 pyxl0error$^  $^$^   pywrapfst.pyx000$^    cdef weight result  weight.newweight$^    result.weight.resetnew fst.weightclassfst.timesdereflhs.weight$^                                                       derefrhs.weight              $^    return result$^  $^ $^  if unlikelypyobject pyxvrhs  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s weight$^    pyxerr0 000 pyxl0error$^  $^$^   pywrapfst.pyx000$^  cdef weight timesweight lhs weight rhs$^    cdef weight result  weight.newweight$^    result.weight.resetnew fst.weightclassfst.timesdereflhs.weight              $^                                                       derefrhs.weight$^    return result$^ $^  pyxvresultweight.resetnew fstscriptweightclassfstscripttimespyxvlhsweight pyxvrhsweight$^$^   pywrapfst.pyx000$^    result.weight.resetnew fst.weightclassfst.timesdereflhs.weight$^                                                       derefrhs.weight$^    return result              $^  $^  $^ $^  pyxxdecrefpyobject pyxr$^  pyxincrefpyobject pyxvresult$^  pyxr  pyxvresult$^  goto pyxl0$^$^   pywrapfst.pyx000$^  $^  $^  cdef weight timesweight lhs weight rhs              $^    cdef weight result  weight.newweight$^    result.weight.resetnew fst.weightclassfst.timesdereflhs.weight$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.times pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxl0$^  pyxxdecrefpyobject pyxvresult$^  pyxxgiverefpyobject pyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx000$^  $^  $^  def timesweight lhs weight rhs              $^    $^    timeslhs rhs$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst0timespyobject pyxself pyobject pyxargs pyobject pyxkwds proto$^static char pyxdoc0pywrapfst0times  n  timeslhs rhsnn  computes the product of two weights in the same semiring.nn  this function computes lhs otimes rhs raising an exception if lhs and rhsn  are not in the same semiring.nn  argsn     lhs lefthand side weight.n     rhs righthand side weight.nn  returnsn    a weight object.nn  raisesn    fstargerror weight type not found or not in same semiring.n    fstbadweighterror invalid weight.n  $^static pymethoddef pyxmdef0pywrapfst0times  times pycfunctionpyxpw0pywrapfst0times methvarargsmethkeywords pyxdoc0pywrapfst0times$^static pyobject pyxpw0pywrapfst0timespyobject pyxself pyobject pyxargs pyobject pyxkwds $^  struct pyxobj0pywrapfstweight pyxvlhs  0$^  struct pyxobj0pywrapfstweight pyxvrhs  0$^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontexttimes wrapper 0$^  $^    static pyobject pyxpyargnames  pyxnslhspyxnsrhs0$^    pyobject values0  00$^    if unlikelypyxkwds $^      pyssizet kwargs$^      const pyssizet posargs  pytuplegetsizepyxargs$^      switch posargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 break$^        default goto pyxl0argtupleerror$^      $^      kwargs  pydictsizepyxkwds$^      switch posargs $^        case  0$^        if likelyvalues0  pyxpydictgetitemstrpyxkwds pyxnslhs  0 kwargs$^        else goto pyxl0argtupleerror$^        cythonfallthrough$^        case  0$^        if likelyvalues0  pyxpydictgetitemstrpyxkwds pyxnsrhs  0 kwargs$^        else $^          pyxraiseargtupleinvalidtimes 0 0 0 0 pyxerr0 000 pyxl0error$^        $^      $^      if unlikelykwargs  0 $^        if unlikelypyxparseoptionalkeywordspyxkwds pyxpyargnames 0 values posargs times  0 pyxerr0 000 pyxl0error$^      $^     else if pytuplegetsizepyxargs  0 $^      goto pyxl0argtupleerror$^     else $^      values0  pytuplegetitempyxargs 0$^      values0  pytuplegetitempyxargs 0$^    $^    pyxvlhs  struct pyxobj0pywrapfstweight values0$^    pyxvrhs  struct pyxobj0pywrapfstweight values0$^  $^  goto pyxl0argumentunpackingdone$^  pyxl0argtupleerror$^  pyxraiseargtupleinvalidtimes 0 0 0 pytuplegetsizepyxargs pyxerr0 000 pyxl0error$^  pyxl0error$^  pyxaddtracebackpywrapfst.times pyxclineno pyxlineno pyxfilename$^  pyxrefnannyfinishcontext$^  return null$^  pyxl0argumentunpackingdone$^  if unlikelypyxargtypetestpyobject pyxvlhs pyxptype0pywrapfstweight 0 lhs 0 pyxerr0 000 pyxl0error$^  if unlikelypyxargtypetestpyobject pyxvrhs pyxptype0pywrapfstweight 0 rhs 0 pyxerr0 000 pyxl0error$^  pyxr  pyxpf0pywrapfst0timespyxself pyxvlhs pyxvrhs$^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxr  null$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst0timescythonunused pyobject pyxself struct pyxobj0pywrapfstweight pyxvlhs struct pyxobj0pywrapfstweight pyxvrhs $^  struct pyxobj0pywrapfstweight pyxvresult  0$^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontexttimes 0$^$^   pywrapfst.pyx000$^      fstbadweighterror invalid weight.$^    $^    cdef weight result  timeslhs rhs              $^    result.checkweight$^    return result$^ $^  pyxt0  pyobject pyxf0pywrapfsttimespyxvlhs pyxvrhs if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxvresult  struct pyxobj0pywrapfstweight pyxt0$^  pyxt0  0$^$^   pywrapfst.pyx000$^    $^    cdef weight result  timeslhs rhs$^    result.checkweight              $^    return result$^  $^ $^  if unlikelypyobject pyxvresult  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s checkweight$^    pyxerr0 000 pyxl0error$^  $^  struct pyxvtabstruct0pywrapfstweight pyxvresultpyxvtabcheckweightpyxvresult if unlikelypyerroccurred pyxerr0 000 pyxl0error$^$^   pywrapfst.pyx000$^    cdef weight result  timeslhs rhs$^    result.checkweight$^    return result              $^  $^  $^ $^  pyxxdecrefpyxr$^  pyxincrefpyobject pyxvresult$^  pyxr  pyobject pyxvresult$^  goto pyxl0$^$^   pywrapfst.pyx000$^  $^  $^  def timesweight lhs weight rhs              $^    $^    timeslhs rhs$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.times pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxdecrefpyobject pyxvresult$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx000$^  $^  $^  cdef weight divideweight lhs weight rhs              $^    cdef weight result  weight.newweight$^    result.weight.resetnew fst.weightclassfst.dividedereflhs.weight$^ $^$^static struct pyxobj0pywrapfstweight pyxf0pywrapfstdividestruct pyxobj0pywrapfstweight pyxvlhs struct pyxobj0pywrapfstweight pyxvrhs $^  struct pyxobj0pywrapfstweight pyxvresult  0$^  struct pyxobj0pywrapfstweight pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextdivide 0$^$^   pywrapfst.pyx000$^  $^  cdef weight divideweight lhs weight rhs$^    cdef weight result  weight.newweight              $^    result.weight.resetnew fst.weightclassfst.dividedereflhs.weight$^                                                        derefrhs.weight$^ $^  pyxt0  pyobject pyxtpnew0pywrapfstweightpytypeobject pyxptype0pywrapfstweight pyxemptytuple null if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyobject pyxt0$^  pyxvresult  struct pyxobj0pywrapfstweight pyxt0$^  pyxt0  0$^$^   pywrapfst.pyx000$^  cdef weight divideweight lhs weight rhs$^    cdef weight result  weight.newweight$^    result.weight.resetnew fst.weightclassfst.dividedereflhs.weight              $^                                                        derefrhs.weight$^    return result$^ $^  if unlikelypyobject pyxvresult  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s weight$^    pyxerr0 000 pyxl0error$^  $^  if unlikelypyobject pyxvlhs  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s weight$^    pyxerr0 000 pyxl0error$^  $^$^   pywrapfst.pyx000$^    cdef weight result  weight.newweight$^    result.weight.resetnew fst.weightclassfst.dividedereflhs.weight$^                                                        derefrhs.weight              $^    return result$^  $^ $^  if unlikelypyobject pyxvrhs  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s weight$^    pyxerr0 000 pyxl0error$^  $^$^   pywrapfst.pyx000$^  cdef weight divideweight lhs weight rhs$^    cdef weight result  weight.newweight$^    result.weight.resetnew fst.weightclassfst.dividedereflhs.weight              $^                                                        derefrhs.weight$^    return result$^ $^  pyxvresultweight.resetnew fstscriptweightclassfstscriptdividepyxvlhsweight pyxvrhsweight$^$^   pywrapfst.pyx000$^    result.weight.resetnew fst.weightclassfst.dividedereflhs.weight$^                                                        derefrhs.weight$^    return result              $^  $^  $^ $^  pyxxdecrefpyobject pyxr$^  pyxincrefpyobject pyxvresult$^  pyxr  pyxvresult$^  goto pyxl0$^$^   pywrapfst.pyx000$^  $^  $^  cdef weight divideweight lhs weight rhs              $^    cdef weight result  weight.newweight$^    result.weight.resetnew fst.weightclassfst.dividedereflhs.weight$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.divide pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxl0$^  pyxxdecrefpyobject pyxvresult$^  pyxxgiverefpyobject pyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx000$^  $^  $^  def divideweight lhs weight rhs              $^    $^    dividelhs rhs$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst0dividepyobject pyxself pyobject pyxargs pyobject pyxkwds proto$^static char pyxdoc0pywrapfst0divide  n  dividelhs rhsnn  computes the quotient of two weights in the same semiring.nn  this function computes lhs oslash rhs raising an exception if lhs and rhsn  are not in the same semiring. as there is no way to specify whether to usen  left vs. right division this assumes a commutative semiring in which thesen  are equivalent operations.nn  argsn     lhs lefthand side weight.n     rhs righthand side weight.nn  returnsn    a weight object.nn  raisesn    fstargerror weight type not found or not in same semiring.n    fstbadweighterror invalid weight.n  $^static pymethoddef pyxmdef0pywrapfst0divide  divide pycfunctionpyxpw0pywrapfst0divide methvarargsmethkeywords pyxdoc0pywrapfst0divide$^static pyobject pyxpw0pywrapfst0dividepyobject pyxself pyobject pyxargs pyobject pyxkwds $^  struct pyxobj0pywrapfstweight pyxvlhs  0$^  struct pyxobj0pywrapfstweight pyxvrhs  0$^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextdivide wrapper 0$^  $^    static pyobject pyxpyargnames  pyxnslhspyxnsrhs0$^    pyobject values0  00$^    if unlikelypyxkwds $^      pyssizet kwargs$^      const pyssizet posargs  pytuplegetsizepyxargs$^      switch posargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 break$^        default goto pyxl0argtupleerror$^      $^      kwargs  pydictsizepyxkwds$^      switch posargs $^        case  0$^        if likelyvalues0  pyxpydictgetitemstrpyxkwds pyxnslhs  0 kwargs$^        else goto pyxl0argtupleerror$^        cythonfallthrough$^        case  0$^        if likelyvalues0  pyxpydictgetitemstrpyxkwds pyxnsrhs  0 kwargs$^        else $^          pyxraiseargtupleinvaliddivide 0 0 0 0 pyxerr0 000 pyxl0error$^        $^      $^      if unlikelykwargs  0 $^        if unlikelypyxparseoptionalkeywordspyxkwds pyxpyargnames 0 values posargs divide  0 pyxerr0 000 pyxl0error$^      $^     else if pytuplegetsizepyxargs  0 $^      goto pyxl0argtupleerror$^     else $^      values0  pytuplegetitempyxargs 0$^      values0  pytuplegetitempyxargs 0$^    $^    pyxvlhs  struct pyxobj0pywrapfstweight values0$^    pyxvrhs  struct pyxobj0pywrapfstweight values0$^  $^  goto pyxl0argumentunpackingdone$^  pyxl0argtupleerror$^  pyxraiseargtupleinvaliddivide 0 0 0 pytuplegetsizepyxargs pyxerr0 000 pyxl0error$^  pyxl0error$^  pyxaddtracebackpywrapfst.divide pyxclineno pyxlineno pyxfilename$^  pyxrefnannyfinishcontext$^  return null$^  pyxl0argumentunpackingdone$^  if unlikelypyxargtypetestpyobject pyxvlhs pyxptype0pywrapfstweight 0 lhs 0 pyxerr0 000 pyxl0error$^  if unlikelypyxargtypetestpyobject pyxvrhs pyxptype0pywrapfstweight 0 rhs 0 pyxerr0 000 pyxl0error$^  pyxr  pyxpf0pywrapfst0dividepyxself pyxvlhs pyxvrhs$^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxr  null$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst0dividecythonunused pyobject pyxself struct pyxobj0pywrapfstweight pyxvlhs struct pyxobj0pywrapfstweight pyxvrhs $^  struct pyxobj0pywrapfstweight pyxvresult  0$^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextdivide 0$^$^   pywrapfst.pyx000$^      fstbadweighterror invalid weight.$^    $^    cdef weight result  dividelhs rhs              $^    result.checkweight$^    return result$^ $^  pyxt0  pyobject pyxf0pywrapfstdividepyxvlhs pyxvrhs if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxvresult  struct pyxobj0pywrapfstweight pyxt0$^  pyxt0  0$^$^   pywrapfst.pyx000$^    $^    cdef weight result  dividelhs rhs$^    result.checkweight              $^    return result$^  $^ $^  if unlikelypyobject pyxvresult  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s checkweight$^    pyxerr0 000 pyxl0error$^  $^  struct pyxvtabstruct0pywrapfstweight pyxvresultpyxvtabcheckweightpyxvresult if unlikelypyerroccurred pyxerr0 000 pyxl0error$^$^   pywrapfst.pyx000$^    cdef weight result  dividelhs rhs$^    result.checkweight$^    return result              $^  $^  $^ $^  pyxxdecrefpyxr$^  pyxincrefpyobject pyxvresult$^  pyxr  pyobject pyxvresult$^  goto pyxl0$^$^   pywrapfst.pyx000$^  $^  $^  def divideweight lhs weight rhs              $^    $^    dividelhs rhs$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.divide pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxdecrefpyobject pyxvresult$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx000$^  $^  $^  cdef weight powerweight w sizet n              $^    cdef weight result  weight.newweight$^    result.weight.resetnew fst.weightclassfst.powerderefw.weight n$^ $^$^static struct pyxobj0pywrapfstweight pyxf0pywrapfstpowerstruct pyxobj0pywrapfstweight pyxvw sizet pyxvn $^  struct pyxobj0pywrapfstweight pyxvresult  0$^  struct pyxobj0pywrapfstweight pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextpower 0$^$^   pywrapfst.pyx000$^  $^  cdef weight powerweight w sizet n$^    cdef weight result  weight.newweight              $^    result.weight.resetnew fst.weightclassfst.powerderefw.weight n$^    return result$^ $^  pyxt0  pyobject pyxtpnew0pywrapfstweightpytypeobject pyxptype0pywrapfstweight pyxemptytuple null if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyobject pyxt0$^  pyxvresult  struct pyxobj0pywrapfstweight pyxt0$^  pyxt0  0$^$^   pywrapfst.pyx000$^  cdef weight powerweight w sizet n$^    cdef weight result  weight.newweight$^    result.weight.resetnew fst.weightclassfst.powerderefw.weight n              $^    return result$^  $^ $^  if unlikelypyobject pyxvresult  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s weight$^    pyxerr0 000 pyxl0error$^  $^  if unlikelypyobject pyxvw  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s weight$^    pyxerr0 000 pyxl0error$^  $^  pyxvresultweight.resetnew fstscriptweightclassfstscriptpowerpyxvwweight pyxvn$^$^   pywrapfst.pyx000$^    cdef weight result  weight.newweight$^    result.weight.resetnew fst.weightclassfst.powerderefw.weight n$^    return result              $^  $^  $^ $^  pyxxdecrefpyobject pyxr$^  pyxincrefpyobject pyxvresult$^  pyxr  pyxvresult$^  goto pyxl0$^$^   pywrapfst.pyx000$^  $^  $^  cdef weight powerweight w sizet n              $^    cdef weight result  weight.newweight$^    result.weight.resetnew fst.weightclassfst.powerderefw.weight n$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.power pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxl0$^  pyxxdecrefpyobject pyxvresult$^  pyxxgiverefpyobject pyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx000$^  $^  $^  def powerweight w sizet n              $^    $^    powerlhs rhs$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst0powerpyobject pyxself pyobject pyxargs pyobject pyxkwds proto$^static char pyxdoc0pywrapfst0power  n  powerlhs rhsnn  computes the iterated product of a weight.nn  argsn     w the weight.n     n the power.nn  returnsn    a weight object.nn  raisesn    fstargerror weight type not found or not in same semiring.n    fstbadweighterror invalid weight.n  $^static pymethoddef pyxmdef0pywrapfst0power  power pycfunctionpyxpw0pywrapfst0power methvarargsmethkeywords pyxdoc0pywrapfst0power$^static pyobject pyxpw0pywrapfst0powerpyobject pyxself pyobject pyxargs pyobject pyxkwds $^  struct pyxobj0pywrapfstweight pyxvw  0$^  sizet pyxvn$^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextpower wrapper 0$^  $^    static pyobject pyxpyargnames  pyxnswpyxnsn0$^    pyobject values0  00$^    if unlikelypyxkwds $^      pyssizet kwargs$^      const pyssizet posargs  pytuplegetsizepyxargs$^      switch posargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 break$^        default goto pyxl0argtupleerror$^      $^      kwargs  pydictsizepyxkwds$^      switch posargs $^        case  0$^        if likelyvalues0  pyxpydictgetitemstrpyxkwds pyxnsw  0 kwargs$^        else goto pyxl0argtupleerror$^        cythonfallthrough$^        case  0$^        if likelyvalues0  pyxpydictgetitemstrpyxkwds pyxnsn  0 kwargs$^        else $^          pyxraiseargtupleinvalidpower 0 0 0 0 pyxerr0 000 pyxl0error$^        $^      $^      if unlikelykwargs  0 $^        if unlikelypyxparseoptionalkeywordspyxkwds pyxpyargnames 0 values posargs power  0 pyxerr0 000 pyxl0error$^      $^     else if pytuplegetsizepyxargs  0 $^      goto pyxl0argtupleerror$^     else $^      values0  pytuplegetitempyxargs 0$^      values0  pytuplegetitempyxargs 0$^    $^    pyxvw  struct pyxobj0pywrapfstweight values0$^    pyxvn  pyxpyintassizetvalues0 if unlikelypyxvn  sizet0  pyerroccurred pyxerr0 000 pyxl0error$^  $^  goto pyxl0argumentunpackingdone$^  pyxl0argtupleerror$^  pyxraiseargtupleinvalidpower 0 0 0 pytuplegetsizepyxargs pyxerr0 000 pyxl0error$^  pyxl0error$^  pyxaddtracebackpywrapfst.power pyxclineno pyxlineno pyxfilename$^  pyxrefnannyfinishcontext$^  return null$^  pyxl0argumentunpackingdone$^  if unlikelypyxargtypetestpyobject pyxvw pyxptype0pywrapfstweight 0 w 0 pyxerr0 000 pyxl0error$^  pyxr  pyxpf0pywrapfst0powerpyxself pyxvw pyxvn$^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxr  null$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst0powercythonunused pyobject pyxself struct pyxobj0pywrapfstweight pyxvw sizet pyxvn $^  struct pyxobj0pywrapfstweight pyxvresult  0$^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextpower 0$^$^   pywrapfst.pyx000$^      fstbadweighterror invalid weight.$^    $^    cdef weight result  powerw n              $^    result.checkweight$^    return result$^ $^  pyxt0  pyobject pyxf0pywrapfstpowerpyxvw pyxvn if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxvresult  struct pyxobj0pywrapfstweight pyxt0$^  pyxt0  0$^$^   pywrapfst.pyx000$^    $^    cdef weight result  powerw n$^    result.checkweight              $^    return result$^  $^ $^  if unlikelypyobject pyxvresult  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s checkweight$^    pyxerr0 000 pyxl0error$^  $^  struct pyxvtabstruct0pywrapfstweight pyxvresultpyxvtabcheckweightpyxvresult if unlikelypyerroccurred pyxerr0 000 pyxl0error$^$^   pywrapfst.pyx000$^    cdef weight result  powerw n$^    result.checkweight$^    return result              $^  $^  $^ $^  pyxxdecrefpyxr$^  pyxincrefpyobject pyxvresult$^  pyxr  pyobject pyxvresult$^  goto pyxl0$^$^   pywrapfst.pyx000$^  $^  $^  def powerweight w sizet n              $^    $^    powerlhs rhs$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.power pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxdecrefpyobject pyxvresult$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx000$^  $^  $^  cdef fst.weightclass getweightclassorzeroconst string weighttype              $^                                                weight except $^    converts weight string to a weightclass.$^ $^$^static fstscriptweightclass pyxf0pywrapfstgetweightclassorzerostdstring const pyxvweighttype pyobject pyxvweight $^  fstscriptweightclass pyxvresult$^  fstscriptweightclass pyxr$^  pyxrefnannydeclarations$^  int pyxt0$^  int pyxt0$^  stdstring pyxt0$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextgetweightclassorzero 0$^$^   pywrapfst.pyx000$^    $^    cdef fst.weightclass result$^    if weight is none              $^      result  fst.weightclass.zeroweighttype$^    elif isinstanceweight weight$^ $^  pyxt0  pyxvweight  pynone$^  pyxt0  pyxt0  0$^  if pyxt0 $^$^     pywrapfst.pyx000$^    cdef fst.weightclass result$^    if weight is none$^      result  fst.weightclass.zeroweighttype              $^    elif isinstanceweight weight$^      result  dereffst.weightclass  weight weight.weight.get$^ $^    pyxvresult  fstscriptweightclasszeropyxvweighttype$^$^     pywrapfst.pyx000$^    $^    cdef fst.weightclass result$^    if weight is none              $^      result  fst.weightclass.zeroweighttype$^    elif isinstanceweight weight$^ $^    goto pyxl0$^  $^$^   pywrapfst.pyx000$^    if weight is none$^      result  fst.weightclass.zeroweighttype$^    elif isinstanceweight weight              $^      result  dereffst.weightclass  weight weight.weight.get$^    else$^ $^  pyxt0  pyxtypecheckpyxvweight pyxptype0pywrapfstweight $^  pyxt0  pyxt0  0$^  if pyxt0 $^$^     pywrapfst.pyx000$^      result  fst.weightclass.zeroweighttype$^    elif isinstanceweight weight$^      result  dereffst.weightclass  weight weight.weight.get              $^    else$^      result  fst.weightclassweighttype weighttostringweight$^ $^    if unlikelypyxvweight  pynone $^      pyerrformatpyexcattributeerror nonetype object has no attribute .00s weight$^      pyxerr0 000 pyxl0error$^    $^    pyxvresult  fstscriptweightclass struct pyxobj0pywrapfstweight pyxvweightweight.get$^$^     pywrapfst.pyx000$^    if weight is none$^      result  fst.weightclass.zeroweighttype$^    elif isinstanceweight weight              $^      result  dereffst.weightclass  weight weight.weight.get$^    else$^ $^    goto pyxl0$^  $^$^   pywrapfst.pyx000$^      result  dereffst.weightclass  weight weight.weight.get$^    else$^      result  fst.weightclassweighttype weighttostringweight              $^      if result.tostring  bbadnumber$^        raise fstbadweighterrorweighttostringweight$^ $^  else $^    pyxt0  pyxf0pywrapfstweighttostringpyxvweight null if unlikelypyerroccurred pyxerr0 000 pyxl0error$^    pyxvresult  fstscriptweightclasspyxvweighttype pyxt0$^$^     pywrapfst.pyx000$^    else$^      result  fst.weightclassweighttype weighttostringweight$^      if result.tostring  bbadnumber              $^        raise fstbadweighterrorweighttostringweight$^    return result$^ $^    pyxt0  pyxvresult.tostring  char const badnumber  0$^    if unlikelypyxt0 $^$^       pywrapfst.pyx000$^      result  fst.weightclassweighttype weighttostringweight$^      if result.tostring  bbadnumber$^        raise fstbadweighterrorweighttostringweight              $^    return result$^  $^ $^      pyxt0  pyxgetmoduleglobalnamepyxnsfstbadweighterror if unlikelypyxt0 pyxerr0 000 pyxl0error$^      pyxgotrefpyxt0$^      pyxt0  pyxf0pywrapfstweighttostringpyxvweight null if unlikelypyerroccurred pyxerr0 000 pyxl0error$^      pyxt0  pyxconvertpybytesstringtopystdinstringpyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^      pyxgotrefpyxt0$^      pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^       else $^        if cythonfastpycall$^        if pyfunctioncheckpyxt0 $^          pyobject pyxtemp0  pyxt0 pyxt0$^          pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^          pyxxdecrefpyxt0 pyxt0  0$^          pyxgotrefpyxt0$^          pyxdecrefpyxt0 pyxt0  0$^         else$^        endif$^        if cythonfastpyccall$^        if pyxpyfastcfunctioncheckpyxt0 $^          pyobject pyxtemp0  pyxt0 pyxt0$^          pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^          pyxxdecrefpyxt0 pyxt0  0$^          pyxgotrefpyxt0$^          pyxdecrefpyxt0 pyxt0  0$^         else$^        endif$^        $^          pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^          pyxgotrefpyxt0$^          pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^          pyxgiverefpyxt0$^          pytuplesetitempyxt0 00 pyxt0$^          pyxt0  0$^          pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 000 pyxl0error$^          pyxgotrefpyxt0$^          pyxdecrefpyxt0 pyxt0  0$^        $^      $^      pyxdecrefpyxt0 pyxt0  0$^      pyxraisepyxt0 0 0 0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxerr0 000 pyxl0error$^$^       pywrapfst.pyx000$^    else$^      result  fst.weightclassweighttype weighttostringweight$^      if result.tostring  bbadnumber              $^        raise fstbadweighterrorweighttostringweight$^    return result$^ $^    $^  $^  pyxl0$^$^   pywrapfst.pyx000$^      if result.tostring  bbadnumber$^        raise fstbadweighterrorweighttostringweight$^    return result              $^  $^  $^ $^  pyxr  pyxvresult$^  goto pyxl0$^$^   pywrapfst.pyx000$^  $^  $^  cdef fst.weightclass getweightclassorzeroconst string weighttype              $^                                                weight except $^    converts weight string to a weightclass.$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.getweightclassorzero pyxclineno pyxlineno pyxfilename$^  pyxpretendtoinitializepyxr$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx000$^  $^  $^  cdef fst.weightclass getweightclassoroneconst string weighttype              $^                                               weight except $^    converts weight string to a weightclass.$^ $^$^static fstscriptweightclass pyxf0pywrapfstgetweightclassoronestdstring const pyxvweighttype pyobject pyxvweight $^  fstscriptweightclass pyxvresult$^  fstscriptweightclass pyxr$^  pyxrefnannydeclarations$^  int pyxt0$^  int pyxt0$^  stdstring pyxt0$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextgetweightclassorone 0$^$^   pywrapfst.pyx000$^    $^    cdef fst.weightclass result$^    if weight is none              $^      result  fst.weightclass.oneweighttype$^    elif isinstanceweight weight$^ $^  pyxt0  pyxvweight  pynone$^  pyxt0  pyxt0  0$^  if pyxt0 $^$^     pywrapfst.pyx000$^    cdef fst.weightclass result$^    if weight is none$^      result  fst.weightclass.oneweighttype              $^    elif isinstanceweight weight$^      result  dereffst.weightclass  weight weight.weight.get$^ $^    pyxvresult  fstscriptweightclassonepyxvweighttype$^$^     pywrapfst.pyx000$^    $^    cdef fst.weightclass result$^    if weight is none              $^      result  fst.weightclass.oneweighttype$^    elif isinstanceweight weight$^ $^    goto pyxl0$^  $^$^   pywrapfst.pyx000$^    if weight is none$^      result  fst.weightclass.oneweighttype$^    elif isinstanceweight weight              $^      result  dereffst.weightclass  weight weight.weight.get$^    else$^ $^  pyxt0  pyxtypecheckpyxvweight pyxptype0pywrapfstweight $^  pyxt0  pyxt0  0$^  if pyxt0 $^$^     pywrapfst.pyx000$^      result  fst.weightclass.oneweighttype$^    elif isinstanceweight weight$^      result  dereffst.weightclass  weight weight.weight.get              $^    else$^      result  fst.weightclassweighttype weighttostringweight$^ $^    if unlikelypyxvweight  pynone $^      pyerrformatpyexcattributeerror nonetype object has no attribute .00s weight$^      pyxerr0 000 pyxl0error$^    $^    pyxvresult  fstscriptweightclass struct pyxobj0pywrapfstweight pyxvweightweight.get$^$^     pywrapfst.pyx000$^    if weight is none$^      result  fst.weightclass.oneweighttype$^    elif isinstanceweight weight              $^      result  dereffst.weightclass  weight weight.weight.get$^    else$^ $^    goto pyxl0$^  $^$^   pywrapfst.pyx000$^      result  dereffst.weightclass  weight weight.weight.get$^    else$^      result  fst.weightclassweighttype weighttostringweight              $^      if result.tostring  bbadnumber$^        raise fstbadweighterrorweighttostringweight$^ $^  else $^    pyxt0  pyxf0pywrapfstweighttostringpyxvweight null if unlikelypyerroccurred pyxerr0 000 pyxl0error$^    pyxvresult  fstscriptweightclasspyxvweighttype pyxt0$^$^     pywrapfst.pyx000$^    else$^      result  fst.weightclassweighttype weighttostringweight$^      if result.tostring  bbadnumber              $^        raise fstbadweighterrorweighttostringweight$^    return result$^ $^    pyxt0  pyxvresult.tostring  char const badnumber  0$^    if unlikelypyxt0 $^$^       pywrapfst.pyx000$^      result  fst.weightclassweighttype weighttostringweight$^      if result.tostring  bbadnumber$^        raise fstbadweighterrorweighttostringweight              $^    return result$^  $^ $^      pyxt0  pyxgetmoduleglobalnamepyxnsfstbadweighterror if unlikelypyxt0 pyxerr0 000 pyxl0error$^      pyxgotrefpyxt0$^      pyxt0  pyxf0pywrapfstweighttostringpyxvweight null if unlikelypyerroccurred pyxerr0 000 pyxl0error$^      pyxt0  pyxconvertpybytesstringtopystdinstringpyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^      pyxgotrefpyxt0$^      pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^       else $^        if cythonfastpycall$^        if pyfunctioncheckpyxt0 $^          pyobject pyxtemp0  pyxt0 pyxt0$^          pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^          pyxxdecrefpyxt0 pyxt0  0$^          pyxgotrefpyxt0$^          pyxdecrefpyxt0 pyxt0  0$^         else$^        endif$^        if cythonfastpyccall$^        if pyxpyfastcfunctioncheckpyxt0 $^          pyobject pyxtemp0  pyxt0 pyxt0$^          pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^          pyxxdecrefpyxt0 pyxt0  0$^          pyxgotrefpyxt0$^          pyxdecrefpyxt0 pyxt0  0$^         else$^        endif$^        $^          pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^          pyxgotrefpyxt0$^          pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^          pyxgiverefpyxt0$^          pytuplesetitempyxt0 00 pyxt0$^          pyxt0  0$^          pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 000 pyxl0error$^          pyxgotrefpyxt0$^          pyxdecrefpyxt0 pyxt0  0$^        $^      $^      pyxdecrefpyxt0 pyxt0  0$^      pyxraisepyxt0 0 0 0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxerr0 000 pyxl0error$^$^       pywrapfst.pyx000$^    else$^      result  fst.weightclassweighttype weighttostringweight$^      if result.tostring  bbadnumber              $^        raise fstbadweighterrorweighttostringweight$^    return result$^ $^    $^  $^  pyxl0$^$^   pywrapfst.pyx000$^      if result.tostring  bbadnumber$^        raise fstbadweighterrorweighttostringweight$^    return result              $^  $^  $^ $^  pyxr  pyxvresult$^  goto pyxl0$^$^   pywrapfst.pyx000$^  $^  $^  cdef fst.weightclass getweightclassoroneconst string weighttype              $^                                               weight except $^    converts weight string to a weightclass.$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.getweightclassorone pyxclineno pyxlineno pyxfilename$^  pyxpretendtoinitializepyxr$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx000$^  $^  $^  cdef weight zeroweighttype              $^    cdef weight result  weight.newweight$^    result.weight.resetnew fst.weightclassfst.weightclass.zero$^ $^$^static struct pyxobj0pywrapfstweight pyxf0pywrapfstzeropyobject pyxvweighttype $^  struct pyxobj0pywrapfstweight pyxvresult  0$^  struct pyxobj0pywrapfstweight pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  stdstring pyxt0$^  int pyxt0$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextzero 0$^$^   pywrapfst.pyx000$^  $^  cdef weight zeroweighttype$^    cdef weight result  weight.newweight              $^    result.weight.resetnew fst.weightclassfst.weightclass.zero$^        tostringweighttype$^ $^  pyxt0  pyobject pyxtpnew0pywrapfstweightpytypeobject pyxptype0pywrapfstweight pyxemptytuple null if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyobject pyxt0$^  pyxvresult  struct pyxobj0pywrapfstweight pyxt0$^  pyxt0  0$^$^   pywrapfst.pyx000$^  cdef weight zeroweighttype$^    cdef weight result  weight.newweight$^    result.weight.resetnew fst.weightclassfst.weightclass.zero              $^        tostringweighttype$^    if result.weight.get.type  bnone$^ $^  if unlikelypyobject pyxvresult  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s weight$^    pyxerr0 000 pyxl0error$^  $^$^   pywrapfst.pyx000$^    cdef weight result  weight.newweight$^    result.weight.resetnew fst.weightclassfst.weightclass.zero$^        tostringweighttype              $^    if result.weight.get.type  bnone$^      raise fstargerrorweight type not found$^ $^  pyxt0  pyxf0pywrapfsttostringpyxvweighttype null if unlikelypyerroccurred pyxerr0 000 pyxl0error$^$^   pywrapfst.pyx000$^  cdef weight zeroweighttype$^    cdef weight result  weight.newweight$^    result.weight.resetnew fst.weightclassfst.weightclass.zero              $^        tostringweighttype$^    if result.weight.get.type  bnone$^ $^  pyxvresultweight.resetnew fstscriptweightclassfstscriptweightclasszeropyxt0$^$^   pywrapfst.pyx000$^    result.weight.resetnew fst.weightclassfst.weightclass.zero$^        tostringweighttype$^    if result.weight.get.type  bnone              $^      raise fstargerrorweight type not found$^    return result$^ $^  if unlikelypyobject pyxvresult  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s weight$^    pyxerr0 000 pyxl0error$^  $^  pyxt0  pyxvresultweight.gettype  char const none  0$^  if unlikelypyxt0 $^$^     pywrapfst.pyx000$^        tostringweighttype$^    if result.weight.get.type  bnone$^      raise fstargerrorweight type not found              $^    return result$^  $^ $^    pyxt0  pyxgetmoduleglobalnamepyxnsfstargerror if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  pyxpyobjectcallpyxt0 pyxtuple0 null if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxgotrefpyxt0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxraisepyxt0 0 0 0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxerr0 000 pyxl0error$^$^     pywrapfst.pyx000$^    result.weight.resetnew fst.weightclassfst.weightclass.zero$^        tostringweighttype$^    if result.weight.get.type  bnone              $^      raise fstargerrorweight type not found$^    return result$^ $^  $^$^   pywrapfst.pyx000$^    if result.weight.get.type  bnone$^      raise fstargerrorweight type not found$^    return result              $^  $^  $^ $^  pyxxdecrefpyobject pyxr$^  pyxincrefpyobject pyxvresult$^  pyxr  pyxvresult$^  goto pyxl0$^$^   pywrapfst.pyx000$^  $^  $^  cdef weight zeroweighttype              $^    cdef weight result  weight.newweight$^    result.weight.resetnew fst.weightclassfst.weightclass.zero$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.zero pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxl0$^  pyxxdecrefpyobject pyxvresult$^  pyxxgiverefpyobject pyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx000$^  $^  $^  cdef weight oneweighttype              $^    cdef weight result  weight.newweight$^    result.weight.resetnew fst.weightclass$^ $^$^static struct pyxobj0pywrapfstweight pyxf0pywrapfstonepyobject pyxvweighttype $^  struct pyxobj0pywrapfstweight pyxvresult  0$^  struct pyxobj0pywrapfstweight pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  stdstring pyxt0$^  int pyxt0$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextone 0$^$^   pywrapfst.pyx000$^  $^  cdef weight oneweighttype$^    cdef weight result  weight.newweight              $^    result.weight.resetnew fst.weightclass$^          fst.weightclass.onetostringweighttype$^ $^  pyxt0  pyobject pyxtpnew0pywrapfstweightpytypeobject pyxptype0pywrapfstweight pyxemptytuple null if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyobject pyxt0$^  pyxvresult  struct pyxobj0pywrapfstweight pyxt0$^  pyxt0  0$^$^   pywrapfst.pyx000$^  cdef weight oneweighttype$^    cdef weight result  weight.newweight$^    result.weight.resetnew fst.weightclass              $^          fst.weightclass.onetostringweighttype$^    if result.weight.get.type  bnone$^ $^  if unlikelypyobject pyxvresult  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s weight$^    pyxerr0 000 pyxl0error$^  $^$^   pywrapfst.pyx000$^    cdef weight result  weight.newweight$^    result.weight.resetnew fst.weightclass$^          fst.weightclass.onetostringweighttype              $^    if result.weight.get.type  bnone$^      raise fstargerrorweight type not found$^ $^  pyxt0  pyxf0pywrapfsttostringpyxvweighttype null if unlikelypyerroccurred pyxerr0 000 pyxl0error$^$^   pywrapfst.pyx000$^  cdef weight oneweighttype$^    cdef weight result  weight.newweight$^    result.weight.resetnew fst.weightclass              $^          fst.weightclass.onetostringweighttype$^    if result.weight.get.type  bnone$^ $^  pyxvresultweight.resetnew fstscriptweightclassfstscriptweightclassonepyxt0$^$^   pywrapfst.pyx000$^    result.weight.resetnew fst.weightclass$^          fst.weightclass.onetostringweighttype$^    if result.weight.get.type  bnone              $^      raise fstargerrorweight type not found$^    return result$^ $^  if unlikelypyobject pyxvresult  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s weight$^    pyxerr0 000 pyxl0error$^  $^  pyxt0  pyxvresultweight.gettype  char const none  0$^  if unlikelypyxt0 $^$^     pywrapfst.pyx000$^          fst.weightclass.onetostringweighttype$^    if result.weight.get.type  bnone$^      raise fstargerrorweight type not found              $^    return result$^  $^ $^    pyxt0  pyxgetmoduleglobalnamepyxnsfstargerror if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  pyxpyobjectcallpyxt0 pyxtuple0 null if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxgotrefpyxt0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxraisepyxt0 0 0 0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxerr0 000 pyxl0error$^$^     pywrapfst.pyx000$^    result.weight.resetnew fst.weightclass$^          fst.weightclass.onetostringweighttype$^    if result.weight.get.type  bnone              $^      raise fstargerrorweight type not found$^    return result$^ $^  $^$^   pywrapfst.pyx000$^    if result.weight.get.type  bnone$^      raise fstargerrorweight type not found$^    return result              $^  $^  $^ $^  pyxxdecrefpyobject pyxr$^  pyxincrefpyobject pyxvresult$^  pyxr  pyxvresult$^  goto pyxl0$^$^   pywrapfst.pyx000$^  $^  $^  cdef weight oneweighttype              $^    cdef weight result  weight.newweight$^    result.weight.resetnew fst.weightclass$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.one pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxl0$^  pyxxdecrefpyobject pyxvresult$^  pyxxgiverefpyobject pyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx000$^  $^  $^  cdef weight noweightweighttype              $^    cdef weight result  weight.newweight$^    result.weight.resetnew fst.weightclass$^ $^$^static struct pyxobj0pywrapfstweight pyxf0pywrapfstnoweightpyobject pyxvweighttype $^  struct pyxobj0pywrapfstweight pyxvresult  0$^  struct pyxobj0pywrapfstweight pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  stdstring pyxt0$^  pyxrefnannysetupcontextnoweight 0$^$^   pywrapfst.pyx000$^  $^  cdef weight noweightweighttype$^    cdef weight result  weight.newweight              $^    result.weight.resetnew fst.weightclass$^          fst.weightclass.noweighttostringweighttype$^ $^  pyxt0  pyobject pyxtpnew0pywrapfstweightpytypeobject pyxptype0pywrapfstweight pyxemptytuple null if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyobject pyxt0$^  pyxvresult  struct pyxobj0pywrapfstweight pyxt0$^  pyxt0  0$^$^   pywrapfst.pyx000$^  cdef weight noweightweighttype$^    cdef weight result  weight.newweight$^    result.weight.resetnew fst.weightclass              $^          fst.weightclass.noweighttostringweighttype$^    return result$^ $^  if unlikelypyobject pyxvresult  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s weight$^    pyxerr0 000 pyxl0error$^  $^$^   pywrapfst.pyx000$^    cdef weight result  weight.newweight$^    result.weight.resetnew fst.weightclass$^          fst.weightclass.noweighttostringweighttype              $^    return result$^  $^ $^  pyxt0  pyxf0pywrapfsttostringpyxvweighttype null if unlikelypyerroccurred pyxerr0 000 pyxl0error$^$^   pywrapfst.pyx000$^  cdef weight noweightweighttype$^    cdef weight result  weight.newweight$^    result.weight.resetnew fst.weightclass              $^          fst.weightclass.noweighttostringweighttype$^    return result$^ $^  pyxvresultweight.resetnew fstscriptweightclassfstscriptweightclassnoweightpyxt0$^$^   pywrapfst.pyx000$^    result.weight.resetnew fst.weightclass$^          fst.weightclass.noweighttostringweighttype$^    return result              $^  $^  $^ $^  pyxxdecrefpyobject pyxr$^  pyxincrefpyobject pyxvresult$^  pyxr  pyxvresult$^  goto pyxl0$^$^   pywrapfst.pyx000$^  $^  $^  cdef weight noweightweighttype              $^    cdef weight result  weight.newweight$^    result.weight.resetnew fst.weightclass$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.noweight pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxl0$^  pyxxdecrefpyobject pyxvresult$^  pyxxgiverefpyobject pyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx000$^     doing so will allow undefined behavior.$^  $^    def initself              $^      raise fstdeletedconstructorerror$^          cannot construct .formatself.class.name$^ $^$^ python wrapper $^static int pyxpw0pywrapfst00symboltable0initpyobject pyxvself pyobject pyxargs pyobject pyxkwds proto$^static int pyxpw0pywrapfst00symboltable0initpyobject pyxvself pyobject pyxargs pyobject pyxkwds $^  int pyxr$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextinit wrapper 0$^  if unlikelypytuplegetsizepyxargs  0 $^    pyxraiseargtupleinvalidinit 0 0 0 pytuplegetsizepyxargs return 0$^  if unlikelypyxkwds  unlikelypydictsizepyxkwds  0  unlikelypyxcheckkeywordstringspyxkwds init 0 return 0$^  pyxr  pyxpf0pywrapfst00symboltableinitstruct pyxobj0pywrapfstsymboltable pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static int pyxpf0pywrapfst00symboltableinitstruct pyxobj0pywrapfstsymboltable pyxvself $^  int pyxr$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextinit 0$^$^   pywrapfst.pyx000$^  $^    def initself$^      raise fstdeletedconstructorerror              $^          cannot construct .formatself.class.name$^  $^ $^  pyxt0  pyxgetmoduleglobalnamepyxnsfstdeletedconstructorerror if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^$^   pywrapfst.pyx000$^    def initself$^      raise fstdeletedconstructorerror$^          cannot construct .formatself.class.name              $^  $^    def iterself$^ $^  pyxt0  pyxpyobjectgetattrstrpyxkpscannotconstruct pyxnsformat if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnsclass if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxt0  pyxpyobjectgetattrstrpyxt0 pyxnsname if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxdecrefpyxt0 pyxt0  0$^  pyxt0  null$^  if cythonunpackmethods  likelypymethodcheckpyxt0 $^    pyxt0  pymethodgetselfpyxt0$^    if likelypyxt0 $^      pyobject function  pymethodgetfunctionpyxt0$^      pyxincrefpyxt0$^      pyxincreffunction$^      pyxdecrefsetpyxt0 function$^    $^  $^  if pyxt0 $^    pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxdecrefpyxt0 pyxt0  0$^    pyxgotrefpyxt0$^   else $^    if cythonfastpycall$^    if pyfunctioncheckpyxt0 $^      pyobject pyxtemp0  pyxt0 pyxt0$^      pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^      pyxxdecrefpyxt0 pyxt0  0$^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^     else$^    endif$^    if cythonfastpyccall$^    if pyxpyfastcfunctioncheckpyxt0 $^      pyobject pyxtemp0  pyxt0 pyxt0$^      pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^      pyxxdecrefpyxt0 pyxt0  0$^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^     else$^    endif$^    $^      pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^      pyxgotrefpyxt0$^      pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^      pyxgiverefpyxt0$^      pytuplesetitempyxt0 00 pyxt0$^      pyxt0  0$^      pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 000 pyxl0error$^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^    $^  $^  pyxdecrefpyxt0 pyxt0  0$^  pyxt0  null$^  if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^    pyxt0  pymethodgetselfpyxt0$^    if likelypyxt0 $^      pyobject function  pymethodgetfunctionpyxt0$^      pyxincrefpyxt0$^      pyxincreffunction$^      pyxdecrefsetpyxt0 function$^    $^  $^  if pyxt0 $^    pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxdecrefpyxt0 pyxt0  0$^    pyxgotrefpyxt0$^   else $^    if cythonfastpycall$^    if pyfunctioncheckpyxt0 $^      pyobject pyxtemp0  pyxt0 pyxt0$^      pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^      pyxxdecrefpyxt0 pyxt0  0$^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^     else$^    endif$^    if cythonfastpyccall$^    if pyxpyfastcfunctioncheckpyxt0 $^      pyobject pyxtemp0  pyxt0 pyxt0$^      pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^      pyxxdecrefpyxt0 pyxt0  0$^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^     else$^    endif$^    $^      pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^      pyxgotrefpyxt0$^      pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^      pyxgiverefpyxt0$^      pytuplesetitempyxt0 00 pyxt0$^      pyxt0  0$^      pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 000 pyxl0error$^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^    $^  $^  pyxdecrefpyxt0 pyxt0  0$^  pyxraisepyxt0 0 0 0$^  pyxdecrefpyxt0 pyxt0  0$^  pyxerr0 000 pyxl0error$^$^   pywrapfst.pyx000$^     doing so will allow undefined behavior.$^  $^    def initself              $^      raise fstdeletedconstructorerror$^          cannot construct .formatself.class.name$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.symboltable.init pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx000$^          cannot construct .formatself.class.name$^  $^    def iterself              $^      return symboltableiteratorself$^  $^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00symboltable0iterpyobject pyxvself proto$^static pyobject pyxpw0pywrapfst00symboltable0iterpyobject pyxvself $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextiter wrapper 0$^  pyxr  pyxpf0pywrapfst00symboltable0iterstruct pyxobj0pywrapfstsymboltable pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00symboltable0iterstruct pyxobj0pywrapfstsymboltable pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextiter 0$^$^   pywrapfst.pyx000$^  $^    def iterself$^      return symboltableiteratorself              $^  $^    cpdef int00 availablekeyself$^ $^  pyxxdecrefpyxr$^  pyxt0  pyxpyobjectcalloneargpyobject pyxptype0pywrapfstsymboltableiterator pyobject pyxvself if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   pywrapfst.pyx000$^          cannot construct .formatself.class.name$^  $^    def iterself              $^      return symboltableiteratorself$^  $^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.symboltable.iter pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx000$^      return symboltableiteratorself$^  $^    cpdef int00 availablekeyself              $^      $^      availablekeyself$^ $^$^static pyobject pyxpw0pywrapfst00symboltable0availablekeypyobject pyxvself cythonunused pyobject unused proto$^static pyxt00basictypesint00 pyxf0pywrapfst00symboltableavailablekeystruct pyxobj0pywrapfstsymboltable pyxvself int pyxskipdispatch $^  pyxt00basictypesint00 pyxr$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxt00basictypesint00 pyxt0$^  pyxrefnannysetupcontextavailablekey 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnsavailablekey if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst00symboltable0availablekey $^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxdecrefpyxt0 pyxt0  0$^       else $^        pyxt0  pyxpyobjectcallnoargpyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^      $^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxt0  pyxpyintasint00tpyxt0 if unlikelypyxt0  int00t0  pyerroccurred pyxerr0 000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxr  pyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx000$^      returns an integer indicating the next available key index in the table.$^      $^      return self.table.availablekey              $^  $^    cpdef string checksumself$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s table$^    pyxerr0 000 pyxl0error$^  $^  pyxr  pyxvselftableavailablekey$^  goto pyxl0$^$^   pywrapfst.pyx000$^      return symboltableiteratorself$^  $^    cpdef int00 availablekeyself              $^      $^      availablekeyself$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxwriteunraisablepywrapfst.symboltable.availablekey pyxclineno pyxlineno pyxfilename 0 0$^  pyxr  0$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst00symboltable0availablekeypyobject pyxvself cythonunused pyobject unused proto$^static char pyxdoc0pywrapfst00symboltable0availablekey  n    availablekeyselfnn    returns an integer indicating the next available key index in the table.n    $^static pyobject pyxpw0pywrapfst00symboltable0availablekeypyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextavailablekey wrapper 0$^  pyxr  pyxpf0pywrapfst00symboltable0availablekeystruct pyxobj0pywrapfstsymboltable pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00symboltable0availablekeystruct pyxobj0pywrapfstsymboltable pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextavailablekey 0$^  pyxxdecrefpyxr$^  pyxt0  pyxpyintfromint00tpyxf0pywrapfst00symboltableavailablekeypyxvself 0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.symboltable.availablekey pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx000$^      return self.table.availablekey$^  $^    cpdef string checksumself              $^      $^      checksumself$^ $^$^static pyobject pyxpw0pywrapfst00symboltable0checksumpyobject pyxvself cythonunused pyobject unused proto$^static stdstring pyxf0pywrapfst00symboltablechecksumstruct pyxobj0pywrapfstsymboltable pyxvself int pyxskipdispatch $^  stdstring pyxr$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  stdstring pyxt0$^  pyxrefnannysetupcontextchecksum 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnschecksum if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst00symboltable0checksum $^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxdecrefpyxt0 pyxt0  0$^       else $^        pyxt0  pyxpyobjectcallnoargpyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^      $^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxt0  pyxconvertstringfrompystdinstringpyxt0 if unlikelypyerroccurred pyxerr0 000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxr  pyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx000$^      returns a string indicating the labelagnostic md0 checksum for the table.$^      $^      return self.table.checksum              $^  $^    cpdef symboltable copyself$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s table$^    pyxerr0 000 pyxl0error$^  $^  pyxr  pyxvselftablechecksum$^  goto pyxl0$^$^   pywrapfst.pyx000$^      return self.table.availablekey$^  $^    cpdef string checksumself              $^      $^      checksumself$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxwriteunraisablepywrapfst.symboltable.checksum pyxclineno pyxlineno pyxfilename 0 0$^  pyxpretendtoinitializepyxr$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst00symboltable0checksumpyobject pyxvself cythonunused pyobject unused proto$^static char pyxdoc0pywrapfst00symboltable0checksum  n    checksumselfnn    returns a string indicating the labelagnostic md0 checksum for the table.n    $^static pyobject pyxpw0pywrapfst00symboltable0checksumpyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextchecksum wrapper 0$^  pyxr  pyxpf0pywrapfst00symboltable0checksumstruct pyxobj0pywrapfstsymboltable pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00symboltable0checksumstruct pyxobj0pywrapfstsymboltable pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextchecksum 0$^  pyxxdecrefpyxr$^  pyxt0  pyxconvertpybytesstringtopystdinstringpyxf0pywrapfst00symboltablechecksumpyxvself 0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.symboltable.checksum pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx000$^      return self.table.checksum$^  $^    cpdef symboltable copyself              $^      $^      copyself$^ $^$^static pyobject pyxpw0pywrapfst00symboltable0copypyobject pyxvself cythonunused pyobject unused proto$^static struct pyxobj0pywrapfstsymboltable pyxf0pywrapfst00symboltablecopystruct pyxobj0pywrapfstsymboltable pyxvself int pyxskipdispatch $^  struct pyxobj0pywrapfstsymboltable pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextcopy 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnscopy if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst00symboltable0copy $^      pyxxdecrefpyobject pyxr$^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxdecrefpyxt0 pyxt0  0$^       else $^        pyxt0  pyxpyobjectcallnoargpyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^      $^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      if likelypyxt0  pynone  likelypyxtypetestpyxt0 pyxptype0pywrapfstsymboltable pyxerr0 000 pyxl0error$^      pyxr  struct pyxobj0pywrapfstsymboltable pyxt0$^      pyxt0  0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx000$^      returns a mutable copy of the symboltable.$^      $^      return initsymboltableself.table.copy              $^  $^    def findself key$^ $^  pyxxdecrefpyobject pyxr$^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s table$^    pyxerr0 000 pyxl0error$^  $^  pyxt0  pyobject pyxf0pywrapfstinitsymboltablepyxvselftablecopy if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  struct pyxobj0pywrapfstsymboltable pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   pywrapfst.pyx000$^      return self.table.checksum$^  $^    cpdef symboltable copyself              $^      $^      copyself$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.symboltable.copy pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxl0$^  pyxxgiverefpyobject pyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst00symboltable0copypyobject pyxvself cythonunused pyobject unused proto$^static char pyxdoc0pywrapfst00symboltable0copy  n    copyselfnn    returns a mutable copy of the symboltable.n    $^static pyobject pyxpw0pywrapfst00symboltable0copypyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextcopy wrapper 0$^  pyxr  pyxpf0pywrapfst00symboltable0copystruct pyxobj0pywrapfstsymboltable pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00symboltable0copystruct pyxobj0pywrapfstsymboltable pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextcopy 0$^  pyxxdecrefpyxr$^  pyxt0  pyobject pyxf0pywrapfst00symboltablecopypyxvself 0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.symboltable.copy pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx000$^      return initsymboltableself.table.copy$^  $^    def findself key              $^      $^      findself key$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00symboltable00findpyobject pyxvself pyobject pyxvkey proto$^static char pyxdoc0pywrapfst00symboltable00find  n    findself keynn    given a symbol or index finds the other one.nn    this method returns the index associated with a symbol key or the symboln    associated with a index key.nn    argsn      key either a string or an index.nn    returnsn      if the key is a string the associated index or nolabel if not found ifn          the key is an integer the associated symbol or an empty string ifn          not found.n    $^static pyobject pyxpw0pywrapfst00symboltable00findpyobject pyxvself pyobject pyxvkey $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextfind wrapper 0$^  pyxr  pyxpf0pywrapfst00symboltable00findstruct pyxobj0pywrapfstsymboltable pyxvself pyobject pyxvkey$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00symboltable00findstruct pyxobj0pywrapfstsymboltable pyxvself pyobject pyxvkey $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  stdstring pyxt0$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  int pyxt0$^  pyxt00basictypesint00 pyxt00$^  pyxrefnannysetupcontextfind 0$^$^   pywrapfst.pyx000$^            not found.$^      $^      try              $^        return self.table.findindextostringkey$^      except fstargerror$^ $^  $^    pyxpythreadstatedeclare$^    pyxpythreadstateassign$^    pyxexceptionsavepyxt0 pyxt0 pyxt0$^    pyxxgotrefpyxt0$^    pyxxgotrefpyxt0$^    pyxxgotrefpyxt0$^    try $^$^       pywrapfst.pyx000$^      $^      try$^        return self.table.findindextostringkey              $^      except fstargerror$^        return self.table.findsymbolkey$^ $^      pyxxdecrefpyxr$^      if unlikelypyobject pyxvself  pynone $^        pyerrformatpyexcattributeerror nonetype object has no attribute .00s table$^        pyxerr0 000 pyxl0error$^      $^      pyxt0  pyxf0pywrapfsttostringpyxvkey null if unlikelypyerroccurred pyxerr0 000 pyxl0error$^      pyxt0  pyxpyintfromint00tpyxvselftablefindpyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^      pyxgotrefpyxt0$^      pyxr  pyxt0$^      pyxt0  0$^      goto pyxl0tryreturn$^$^       pywrapfst.pyx000$^            not found.$^      $^      try              $^        return self.table.findindextostringkey$^      except fstargerror$^ $^    $^    pyxl0error$^    pyxxdecrefpyxt0 pyxt0  0$^$^     pywrapfst.pyx000$^      try$^        return self.table.findindextostringkey$^      except fstargerror              $^        return self.table.findsymbolkey$^  $^ $^    pyxerrfetchpyxt0 pyxt0 pyxt0$^    pyxt0  pyxgetmoduleglobalnamepyxnsfstargerror if unlikelypyxt0 pyxerr0 000 pyxl0excepterror$^    pyxgotrefpyxt0$^    pyxt0  pyxpyerrgivenexceptionmatchespyxt0 pyxt0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxerrrestorepyxt0 pyxt0 pyxt0$^    pyxt0  0 pyxt0  0 pyxt0  0$^    if pyxt0 $^      pyxaddtracebackpywrapfst.symboltable.find pyxclineno pyxlineno pyxfilename$^      if pyxgetexceptionpyxt0 pyxt0 pyxt0  0 pyxerr0 000 pyxl0excepterror$^      pyxgotrefpyxt0$^      pyxgotrefpyxt0$^      pyxgotrefpyxt0$^$^       pywrapfst.pyx000$^        return self.table.findindextostringkey$^      except fstargerror$^        return self.table.findsymbolkey              $^  $^    cpdef int00 getnthkeyself ssizet pos except $^ $^      pyxxdecrefpyxr$^      if unlikelypyobject pyxvself  pynone $^        pyerrformatpyexcattributeerror nonetype object has no attribute .00s table$^        pyxerr0 000 pyxl0excepterror$^      $^      pyxt00  pyxpyintasint00tpyxvkey if unlikelypyxt00  int00t0  pyerroccurred pyxerr0 000 pyxl0excepterror$^      pyxt0  pyxconvertpybytesstringtopystdinstringpyxvselftablefindpyxt00 if unlikelypyxt0 pyxerr0 000 pyxl0excepterror$^      pyxgotrefpyxt0$^      pyxr  pyxt0$^      pyxt0  0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0exceptreturn$^    $^    goto pyxl0excepterror$^    pyxl0excepterror$^$^     pywrapfst.pyx000$^            not found.$^      $^      try              $^        return self.table.findindextostringkey$^      except fstargerror$^ $^    pyxxgiverefpyxt0$^    pyxxgiverefpyxt0$^    pyxxgiverefpyxt0$^    pyxexceptionresetpyxt0 pyxt0 pyxt0$^    goto pyxl0error$^    pyxl0tryreturn$^    pyxxgiverefpyxt0$^    pyxxgiverefpyxt0$^    pyxxgiverefpyxt0$^    pyxexceptionresetpyxt0 pyxt0 pyxt0$^    goto pyxl0$^    pyxl0exceptreturn$^    pyxxgiverefpyxt0$^    pyxxgiverefpyxt0$^    pyxxgiverefpyxt0$^    pyxexceptionresetpyxt0 pyxt0 pyxt0$^    goto pyxl0$^  $^$^   pywrapfst.pyx000$^      return initsymboltableself.table.copy$^  $^    def findself key              $^      $^      findself key$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.symboltable.find pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx000$^        return self.table.findsymbolkey$^  $^    cpdef int00 getnthkeyself ssizet pos except               $^      $^      getnthkeyself pos$^ $^$^static pyobject pyxpw0pywrapfst00symboltable00getnthkeypyobject pyxvself pyobject pyxargpos proto$^static pyxt00basictypesint00 pyxf0pywrapfst00symboltablegetnthkeystruct pyxobj0pywrapfstsymboltable pyxvself pyssizet pyxvpos int pyxskipdispatch $^  pyxt00basictypesint00 pyxr$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxt00basictypesint00 pyxt0$^  pyxrefnannysetupcontextgetnthkey 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnsgetnthkey if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst00symboltable00getnthkey $^      pyxt0  pyintfromssizetpyxvpos if unlikelypyxt0 pyxerr0 000 pyxl0error$^      pyxgotrefpyxt0$^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^       else $^        if cythonfastpycall$^        if pyfunctioncheckpyxt0 $^          pyobject pyxtemp0  pyxt0 pyxt0$^          pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^          pyxxdecrefpyxt0 pyxt0  0$^          pyxgotrefpyxt0$^          pyxdecrefpyxt0 pyxt0  0$^         else$^        endif$^        if cythonfastpyccall$^        if pyxpyfastcfunctioncheckpyxt0 $^          pyobject pyxtemp0  pyxt0 pyxt0$^          pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^          pyxxdecrefpyxt0 pyxt0  0$^          pyxgotrefpyxt0$^          pyxdecrefpyxt0 pyxt0  0$^         else$^        endif$^        $^          pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^          pyxgotrefpyxt0$^          pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^          pyxgiverefpyxt0$^          pytuplesetitempyxt0 00 pyxt0$^          pyxt0  0$^          pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 000 pyxl0error$^          pyxgotrefpyxt0$^          pyxdecrefpyxt0 pyxt0  0$^        $^      $^      pyxdecrefpyxt0 pyxt0  0$^      pyxt0  pyxpyintasint00tpyxt0 if unlikelypyxt0  int00t0  pyerroccurred pyxerr0 000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxr  pyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx000$^        the integer index of the nth key or nolabel if not found.$^      $^      return self.table.getnthkeypos              $^  $^    cpdef string labeledchecksumself$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s table$^    pyxerr0 000 pyxl0error$^  $^  pyxr  pyxvselftablegetnthkeypyxvpos$^  goto pyxl0$^$^   pywrapfst.pyx000$^        return self.table.findsymbolkey$^  $^    cpdef int00 getnthkeyself ssizet pos except               $^      $^      getnthkeyself pos$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.symboltable.getnthkey pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst00symboltable00getnthkeypyobject pyxvself pyobject pyxargpos proto$^static char pyxdoc0pywrapfst00symboltable00getnthkey  n    getnthkeyself posnn    retrieves the integer index of the nth key in the table.nn    argsn      pos the nth key to retrieve.nn    returnsn      the integer index of the nth key or nolabel if not found.n    $^static pyobject pyxpw0pywrapfst00symboltable00getnthkeypyobject pyxvself pyobject pyxargpos $^  pyssizet pyxvpos$^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextgetnthkey wrapper 0$^  assertpyxargpos $^    pyxvpos  pyintasssizetpyxargpos if unlikelypyxvpos  pyssizet0  pyerroccurred pyxerr0 000 pyxl0error$^  $^  goto pyxl0argumentunpackingdone$^  pyxl0error$^  pyxaddtracebackpywrapfst.symboltable.getnthkey pyxclineno pyxlineno pyxfilename$^  pyxrefnannyfinishcontext$^  return null$^  pyxl0argumentunpackingdone$^  pyxr  pyxpf0pywrapfst00symboltable00getnthkeystruct pyxobj0pywrapfstsymboltable pyxvself pyssizetpyxvpos$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00symboltable00getnthkeystruct pyxobj0pywrapfstsymboltable pyxvself pyssizet pyxvpos $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyxt00basictypesint00 pyxt0$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextgetnthkey 0$^  pyxxdecrefpyxr$^  pyxt0  pyxf0pywrapfst00symboltablegetnthkeypyxvself pyxvpos 0 if unlikelypyerroccurred pyxerr0 000 pyxl0error$^  pyxt0  pyxpyintfromint00tpyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.symboltable.getnthkey pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx000$^      return self.table.getnthkeypos$^  $^    cpdef string labeledchecksumself              $^      $^      labeledchecksumself$^ $^$^static pyobject pyxpw0pywrapfst00symboltable00labeledchecksumpyobject pyxvself cythonunused pyobject unused proto$^static stdstring pyxf0pywrapfst00symboltablelabeledchecksumstruct pyxobj0pywrapfstsymboltable pyxvself int pyxskipdispatch $^  stdstring pyxr$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  stdstring pyxt0$^  pyxrefnannysetupcontextlabeledchecksum 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnslabeledchecksum if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst00symboltable00labeledchecksum $^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxdecrefpyxt0 pyxt0  0$^       else $^        pyxt0  pyxpyobjectcallnoargpyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^      $^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxt0  pyxconvertstringfrompystdinstringpyxt0 if unlikelypyerroccurred pyxerr0 000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxr  pyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx000$^      returns a string indicating the labeldependent md0 checksum for the table.$^      $^      return self.table.labeledchecksum              $^  $^    cpdef bool memberself key$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s table$^    pyxerr0 000 pyxl0error$^  $^  pyxr  pyxvselftablelabeledchecksum$^  goto pyxl0$^$^   pywrapfst.pyx000$^      return self.table.getnthkeypos$^  $^    cpdef string labeledchecksumself              $^      $^      labeledchecksumself$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxwriteunraisablepywrapfst.symboltable.labeledchecksum pyxclineno pyxlineno pyxfilename 0 0$^  pyxpretendtoinitializepyxr$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst00symboltable00labeledchecksumpyobject pyxvself cythonunused pyobject unused proto$^static char pyxdoc0pywrapfst00symboltable00labeledchecksum  n    labeledchecksumselfnn    returns a string indicating the labeldependent md0 checksum for the table.n    $^static pyobject pyxpw0pywrapfst00symboltable00labeledchecksumpyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextlabeledchecksum wrapper 0$^  pyxr  pyxpf0pywrapfst00symboltable00labeledchecksumstruct pyxobj0pywrapfstsymboltable pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00symboltable00labeledchecksumstruct pyxobj0pywrapfstsymboltable pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextlabeledchecksum 0$^  pyxxdecrefpyxr$^  pyxt0  pyxconvertpybytesstringtopystdinstringpyxf0pywrapfst00symboltablelabeledchecksumpyxvself 0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.symboltable.labeledchecksum pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx000$^      return self.table.labeledchecksum$^  $^    cpdef bool memberself key              $^      $^      memberself key$^ $^$^static pyobject pyxpw0pywrapfst00symboltable00memberpyobject pyxvself pyobject pyxvkey proto$^static bool pyxf0pywrapfst00symboltablememberstruct pyxobj0pywrapfstsymboltable pyxvself pyobject pyxvkey int pyxskipdispatch $^  bool pyxr$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  bool pyxt0$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  stdstring pyxt00$^  int pyxt00$^  pyxt00basictypesint00 pyxt00$^  pyxrefnannysetupcontextmember 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnsmember if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst00symboltable00member $^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxvkey if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxgotrefpyxt0$^       else $^        if cythonfastpycall$^        if pyfunctioncheckpyxt0 $^          pyobject pyxtemp0  pyxt0 pyxvkey$^          pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^          pyxxdecrefpyxt0 pyxt0  0$^          pyxgotrefpyxt0$^         else$^        endif$^        if cythonfastpyccall$^        if pyxpyfastcfunctioncheckpyxt0 $^          pyobject pyxtemp0  pyxt0 pyxvkey$^          pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^          pyxxdecrefpyxt0 pyxt0  0$^          pyxgotrefpyxt0$^         else$^        endif$^        $^          pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^          pyxgotrefpyxt0$^          pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^          pyxincrefpyxvkey$^          pyxgiverefpyxvkey$^          pytuplesetitempyxt0 00 pyxvkey$^          pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 000 pyxl0error$^          pyxgotrefpyxt0$^          pyxdecrefpyxt0 pyxt0  0$^        $^      $^      pyxdecrefpyxt0 pyxt0  0$^      pyxt0  pyxpyobjectistruepyxt0 if unlikelypyxt0  bool0  pyerroccurred pyxerr0 000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxr  pyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx000$^        whether or not the key is present as a string or a index in the table.$^      $^      try              $^        return self.table.membersymboltostringkey$^      except fstargerror$^ $^  $^    pyxpythreadstatedeclare$^    pyxpythreadstateassign$^    pyxexceptionsavepyxt0 pyxt0 pyxt0$^    pyxxgotrefpyxt0$^    pyxxgotrefpyxt0$^    pyxxgotrefpyxt0$^    try $^$^       pywrapfst.pyx000$^      $^      try$^        return self.table.membersymboltostringkey              $^      except fstargerror$^        return self.table.memberindexkey$^ $^      if unlikelypyobject pyxvself  pynone $^        pyerrformatpyexcattributeerror nonetype object has no attribute .00s table$^        pyxerr0 000 pyxl0error$^      $^      pyxt00  pyxf0pywrapfsttostringpyxvkey null if unlikelypyerroccurred pyxerr0 000 pyxl0error$^      pyxr  pyxvselftablememberpyxt00$^      goto pyxl0tryreturn$^$^       pywrapfst.pyx000$^        whether or not the key is present as a string or a index in the table.$^      $^      try              $^        return self.table.membersymboltostringkey$^      except fstargerror$^ $^    $^    pyxl0error$^    pyxxdecrefpyxt0 pyxt0  0$^    pyxxdecrefpyxt0 pyxt0  0$^    pyxxdecrefpyxt0 pyxt0  0$^    pyxxdecrefpyxt0 pyxt0  0$^    pyxxdecrefpyxt0 pyxt0  0$^$^     pywrapfst.pyx000$^      try$^        return self.table.membersymboltostringkey$^      except fstargerror              $^        return self.table.memberindexkey$^  $^ $^    pyxerrfetchpyxt0 pyxt0 pyxt0$^    pyxt0  pyxgetmoduleglobalnamepyxnsfstargerror if unlikelypyxt0 pyxerr0 000 pyxl0excepterror$^    pyxgotrefpyxt0$^    pyxt00  pyxpyerrgivenexceptionmatchespyxt0 pyxt0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxerrrestorepyxt0 pyxt0 pyxt0$^    pyxt0  0 pyxt0  0 pyxt0  0$^    if pyxt00 $^      pyxaddtracebackpywrapfst.symboltable.member pyxclineno pyxlineno pyxfilename$^      if pyxgetexceptionpyxt0 pyxt0 pyxt0  0 pyxerr0 000 pyxl0excepterror$^      pyxgotrefpyxt0$^      pyxgotrefpyxt0$^      pyxgotrefpyxt0$^$^       pywrapfst.pyx000$^        return self.table.membersymboltostringkey$^      except fstargerror$^        return self.table.memberindexkey              $^  $^    def containsself key$^ $^      if unlikelypyobject pyxvself  pynone $^        pyerrformatpyexcattributeerror nonetype object has no attribute .00s table$^        pyxerr0 000 pyxl0excepterror$^      $^      pyxt00  pyxpyintasint00tpyxvkey if unlikelypyxt00  int00t0  pyerroccurred pyxerr0 000 pyxl0excepterror$^      pyxr  pyxvselftablememberpyxt00$^      pyxdecrefpyxt0 pyxt0  0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0exceptreturn$^    $^    goto pyxl0excepterror$^    pyxl0excepterror$^$^     pywrapfst.pyx000$^        whether or not the key is present as a string or a index in the table.$^      $^      try              $^        return self.table.membersymboltostringkey$^      except fstargerror$^ $^    pyxxgiverefpyxt0$^    pyxxgiverefpyxt0$^    pyxxgiverefpyxt0$^    pyxexceptionresetpyxt0 pyxt0 pyxt0$^    goto pyxl0error$^    pyxl0tryreturn$^    pyxxgiverefpyxt0$^    pyxxgiverefpyxt0$^    pyxxgiverefpyxt0$^    pyxexceptionresetpyxt0 pyxt0 pyxt0$^    goto pyxl0$^    pyxl0exceptreturn$^    pyxxgiverefpyxt0$^    pyxxgiverefpyxt0$^    pyxxgiverefpyxt0$^    pyxexceptionresetpyxt0 pyxt0 pyxt0$^    goto pyxl0$^  $^$^   pywrapfst.pyx000$^      return self.table.labeledchecksum$^  $^    cpdef bool memberself key              $^      $^      memberself key$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxwriteunraisablepywrapfst.symboltable.member pyxclineno pyxlineno pyxfilename 0 0$^  pyxr  0$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst00symboltable00memberpyobject pyxvself pyobject pyxvkey proto$^static char pyxdoc0pywrapfst00symboltable00member  n    memberself keynn    given a symbol or index returns whether it is found in the table.nn    this method returns a boolean indicating whether the given symbol or indexn    is present in the table. if one intends to perform subsequent lookup it isn    better to simply call the find method catching the keyerror.nn    argsn      key either a string or an index.nn    returnsn      whether or not the key is present as a string or a index in the table.n    $^static pyobject pyxpw0pywrapfst00symboltable00memberpyobject pyxvself pyobject pyxvkey $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextmember wrapper 0$^  pyxr  pyxpf0pywrapfst00symboltable00memberstruct pyxobj0pywrapfstsymboltable pyxvself pyobject pyxvkey$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00symboltable00memberstruct pyxobj0pywrapfstsymboltable pyxvself pyobject pyxvkey $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextmember 0$^  pyxxdecrefpyxr$^  pyxt0  pyxpyboolfromlongpyxf0pywrapfst00symboltablememberpyxvself pyxvkey 0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.symboltable.member pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx000$^        return self.table.memberindexkey$^  $^    def containsself key              $^      return self.memberkey$^  $^ $^$^ python wrapper $^static int pyxpw0pywrapfst00symboltable00containspyobject pyxvself pyobject pyxvkey proto$^static int pyxpw0pywrapfst00symboltable00containspyobject pyxvself pyobject pyxvkey $^  int pyxr$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextcontains wrapper 0$^  pyxr  pyxpf0pywrapfst00symboltable00containsstruct pyxobj0pywrapfstsymboltable pyxvself pyobject pyxvkey$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static int pyxpf0pywrapfst00symboltable00containsstruct pyxobj0pywrapfstsymboltable pyxvself pyobject pyxvkey $^  int pyxr$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextcontains 0$^$^   pywrapfst.pyx000$^  $^    def containsself key$^      return self.memberkey              $^  $^    cpdef string nameself$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s member$^    pyxerr0 000 pyxl0error$^  $^  pyxr  struct pyxvtabstruct0pywrapfstsymboltable pyxvselfpyxvtabmemberpyxvself pyxvkey 0$^  goto pyxl0$^$^   pywrapfst.pyx000$^        return self.table.memberindexkey$^  $^    def containsself key              $^      return self.memberkey$^  $^ $^$^   function exit code $^  pyxl0error$^  pyxaddtracebackpywrapfst.symboltable.contains pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx000$^      return self.memberkey$^  $^    cpdef string nameself              $^      $^      nameself$^ $^$^static pyobject pyxpw0pywrapfst00symboltable00namepyobject pyxvself cythonunused pyobject unused proto$^static stdstring pyxf0pywrapfst00symboltablenamestruct pyxobj0pywrapfstsymboltable pyxvself int pyxskipdispatch $^  stdstring pyxr$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  stdstring pyxt0$^  pyxrefnannysetupcontextname 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnsname0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst00symboltable00name $^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxdecrefpyxt0 pyxt0  0$^       else $^        pyxt0  pyxpyobjectcallnoargpyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^      $^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxt0  pyxconvertstringfrompystdinstringpyxt0 if unlikelypyerroccurred pyxerr0 000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxr  pyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx000$^      returns the symbol tables name.$^      $^      return self.table.name              $^  $^    cpdef sizet numsymbolsself$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s table$^    pyxerr0 000 pyxl0error$^  $^  pyxr  pyxvselftablename$^  goto pyxl0$^$^   pywrapfst.pyx000$^      return self.memberkey$^  $^    cpdef string nameself              $^      $^      nameself$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxwriteunraisablepywrapfst.symboltable.name pyxclineno pyxlineno pyxfilename 0 0$^  pyxpretendtoinitializepyxr$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst00symboltable00namepyobject pyxvself cythonunused pyobject unused proto$^static char pyxdoc0pywrapfst00symboltable00name  n    nameselfnn    returns the symbol tables name.n    $^static pyobject pyxpw0pywrapfst00symboltable00namepyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextname wrapper 0$^  pyxr  pyxpf0pywrapfst00symboltable00namestruct pyxobj0pywrapfstsymboltable pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00symboltable00namestruct pyxobj0pywrapfstsymboltable pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextname 0$^  pyxxdecrefpyxr$^  pyxt0  pyxconvertpybytesstringtopystdinstringpyxf0pywrapfst00symboltablenamepyxvself 0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.symboltable.name pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx000$^      return self.table.name$^  $^    cpdef sizet numsymbolsself              $^      $^      numsymbolsself$^ $^$^static pyobject pyxpw0pywrapfst00symboltable00numsymbolspyobject pyxvself cythonunused pyobject unused proto$^static sizet pyxf0pywrapfst00symboltablenumsymbolsstruct pyxobj0pywrapfstsymboltable pyxvself int pyxskipdispatch $^  sizet pyxr$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  sizet pyxt0$^  pyxrefnannysetupcontextnumsymbols 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnsnumsymbols if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst00symboltable00numsymbols $^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxdecrefpyxt0 pyxt0  0$^       else $^        pyxt0  pyxpyobjectcallnoargpyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^      $^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxt0  pyxpyintassizetpyxt0 if unlikelypyxt0  sizet0  pyerroccurred pyxerr0 000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxr  pyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx000$^      returns the number of symbols in the symbol table.$^      $^      return self.table.numsymbols              $^  $^    cpdef void writeself filename except $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s table$^    pyxerr0 000 pyxl0error$^  $^  pyxr  pyxvselftablenumsymbols$^  goto pyxl0$^$^   pywrapfst.pyx000$^      return self.table.name$^  $^    cpdef sizet numsymbolsself              $^      $^      numsymbolsself$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxwriteunraisablepywrapfst.symboltable.numsymbols pyxclineno pyxlineno pyxfilename 0 0$^  pyxr  0$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst00symboltable00numsymbolspyobject pyxvself cythonunused pyobject unused proto$^static char pyxdoc0pywrapfst00symboltable00numsymbols  n    numsymbolsselfnn    returns the number of symbols in the symbol table.n    $^static pyobject pyxpw0pywrapfst00symboltable00numsymbolspyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextnumsymbols wrapper 0$^  pyxr  pyxpf0pywrapfst00symboltable00numsymbolsstruct pyxobj0pywrapfstsymboltable pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00symboltable00numsymbolsstruct pyxobj0pywrapfstsymboltable pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextnumsymbols 0$^  pyxxdecrefpyxr$^  pyxt0  pyxpyintfromsizetpyxf0pywrapfst00symboltablenumsymbolspyxvself 0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.symboltable.numsymbols pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx000$^      return self.table.numsymbols$^  $^    cpdef void writeself filename except               $^      $^      writeself filename$^ $^$^static pyobject pyxpw0pywrapfst00symboltable00writepyobject pyxvself pyobject pyxvfilename proto$^static void pyxf0pywrapfst00symboltablewritestruct pyxobj0pywrapfstsymboltable pyxvself pyobject pyxvfilename int pyxskipdispatch $^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  stdstring pyxt0$^  int pyxt0$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextwrite 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnswrite if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst00symboltable00write $^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxvfilename if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxgotrefpyxt0$^       else $^        if cythonfastpycall$^        if pyfunctioncheckpyxt0 $^          pyobject pyxtemp0  pyxt0 pyxvfilename$^          pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^          pyxxdecrefpyxt0 pyxt0  0$^          pyxgotrefpyxt0$^         else$^        endif$^        if cythonfastpyccall$^        if pyxpyfastcfunctioncheckpyxt0 $^          pyobject pyxtemp0  pyxt0 pyxvfilename$^          pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^          pyxxdecrefpyxt0 pyxt0  0$^          pyxgotrefpyxt0$^         else$^        endif$^        $^          pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^          pyxgotrefpyxt0$^          pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^          pyxincrefpyxvfilename$^          pyxgiverefpyxvfilename$^          pytuplesetitempyxt0 00 pyxvfilename$^          pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 000 pyxl0error$^          pyxgotrefpyxt0$^          pyxdecrefpyxt0 pyxt0  0$^        $^      $^      pyxdecrefpyxt0 pyxt0  0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx000$^        fstioerror write failed.$^      $^      if not self.table.writetostringfilename              $^        raise fstioerrorwrite failed r.formatfilename$^  $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s table$^    pyxerr0 000 pyxl0error$^  $^  pyxt0  pyxf0pywrapfsttostringpyxvfilename null if unlikelypyerroccurred pyxerr0 000 pyxl0error$^  pyxt0  pyxvselftablewritepyxt0  0  0$^  if unlikelypyxt0 $^$^     pywrapfst.pyx000$^      $^      if not self.table.writetostringfilename$^        raise fstioerrorwrite failed r.formatfilename              $^  $^    cpdef void writetextself filename except $^ $^    pyxt0  pyxgetmoduleglobalnamepyxnsfstioerror if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  pyxpyobjectgetattrstrpyxkpswritefailedr pyxnsformat if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  null$^    if cythonunpackmethods  likelypymethodcheckpyxt0 $^      pyxt0  pymethodgetselfpyxt0$^      if likelypyxt0 $^        pyobject function  pymethodgetfunctionpyxt0$^        pyxincrefpyxt0$^        pyxincreffunction$^        pyxdecrefsetpyxt0 function$^      $^    $^    if pyxt0 $^      pyxt0  pyxpyobjectcalloneargpyxt0 pyxvfilename if unlikelypyxt0 pyxerr0 000 pyxl0error$^      pyxgotrefpyxt0$^     else $^      if cythonfastpycall$^      if pyfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxvfilename$^        pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^       else$^      endif$^      if cythonfastpyccall$^      if pyxpyfastcfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxvfilename$^        pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^       else$^      endif$^      $^        pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxgotrefpyxt0$^        pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^        pyxincrefpyxvfilename$^        pyxgiverefpyxvfilename$^        pytuplesetitempyxt0 00 pyxvfilename$^        pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^      $^    $^    pyxdecrefpyxt0 pyxt0  0$^    pyxt0  null$^    if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^      pyxt0  pymethodgetselfpyxt0$^      if likelypyxt0 $^        pyobject function  pymethodgetfunctionpyxt0$^        pyxincrefpyxt0$^        pyxincreffunction$^        pyxdecrefsetpyxt0 function$^      $^    $^    if pyxt0 $^      pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxgotrefpyxt0$^     else $^      if cythonfastpycall$^      if pyfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxt0$^        pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^       else$^      endif$^      if cythonfastpyccall$^      if pyxpyfastcfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxt0$^        pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^       else$^      endif$^      $^        pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxgotrefpyxt0$^        pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^        pyxgiverefpyxt0$^        pytuplesetitempyxt0 00 pyxt0$^        pyxt0  0$^        pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^      $^    $^    pyxdecrefpyxt0 pyxt0  0$^    pyxraisepyxt0 0 0 0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxerr0 000 pyxl0error$^$^     pywrapfst.pyx000$^        fstioerror write failed.$^      $^      if not self.table.writetostringfilename              $^        raise fstioerrorwrite failed r.formatfilename$^  $^ $^  $^$^   pywrapfst.pyx000$^      return self.table.numsymbols$^  $^    cpdef void writeself filename except               $^      $^      writeself filename$^ $^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.symboltable.write pyxclineno pyxlineno pyxfilename$^  pyxl0$^  pyxrefnannyfinishcontext$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst00symboltable00writepyobject pyxvself pyobject pyxvfilename proto$^static char pyxdoc0pywrapfst00symboltable00write  n    writeself filenamenn    serializes symbol table to a file.nn    this methods writes the symboltable to a file in binary format.nn    argsn      filename the string location of the output file.nn    raisesn      fstioerror write failed.n    $^static pyobject pyxpw0pywrapfst00symboltable00writepyobject pyxvself pyobject pyxvfilename $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextwrite wrapper 0$^  pyxr  pyxpf0pywrapfst00symboltable00writestruct pyxobj0pywrapfstsymboltable pyxvself pyobject pyxvfilename$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00symboltable00writestruct pyxobj0pywrapfstsymboltable pyxvself pyobject pyxvfilename $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextwrite 0$^  pyxxdecrefpyxr$^  pyxf0pywrapfst00symboltablewritepyxvself pyxvfilename 0 if unlikelypyerroccurred pyxerr0 000 pyxl0error$^  pyxt0  pyxvoidtononenull if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.symboltable.write pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx000$^        raise fstioerrorwrite failed r.formatfilename$^  $^    cpdef void writetextself filename except               $^      $^      writetextself filename$^ $^$^static pyobject pyxpw0pywrapfst00symboltable00writetextpyobject pyxvself pyobject pyxvfilename proto$^static void pyxf0pywrapfst00symboltablewritetextstruct pyxobj0pywrapfstsymboltable pyxvself pyobject pyxvfilename int pyxskipdispatch $^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  stdstring pyxt0$^  int pyxt0$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextwritetext 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnswritetext if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst00symboltable00writetext $^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxvfilename if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxgotrefpyxt0$^       else $^        if cythonfastpycall$^        if pyfunctioncheckpyxt0 $^          pyobject pyxtemp0  pyxt0 pyxvfilename$^          pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^          pyxxdecrefpyxt0 pyxt0  0$^          pyxgotrefpyxt0$^         else$^        endif$^        if cythonfastpyccall$^        if pyxpyfastcfunctioncheckpyxt0 $^          pyobject pyxtemp0  pyxt0 pyxvfilename$^          pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^          pyxxdecrefpyxt0 pyxt0  0$^          pyxgotrefpyxt0$^         else$^        endif$^        $^          pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^          pyxgotrefpyxt0$^          pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^          pyxincrefpyxvfilename$^          pyxgiverefpyxvfilename$^          pytuplesetitempyxt0 00 pyxvfilename$^          pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 000 pyxl0error$^          pyxgotrefpyxt0$^          pyxdecrefpyxt0 pyxt0  0$^        $^      $^      pyxdecrefpyxt0 pyxt0  0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx000$^        fstioerror write failed.$^      $^      if not self.table.writetexttostringfilename              $^        raise fstioerrorwrite failed r.formatfilename$^  $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s table$^    pyxerr0 000 pyxl0error$^  $^  pyxt0  pyxf0pywrapfsttostringpyxvfilename null if unlikelypyerroccurred pyxerr0 000 pyxl0error$^  pyxt0  pyxvselftablewritetextpyxt0  0  0$^  if unlikelypyxt0 $^$^     pywrapfst.pyx000$^      $^      if not self.table.writetexttostringfilename$^        raise fstioerrorwrite failed r.formatfilename              $^  $^  $^ $^    pyxt0  pyxgetmoduleglobalnamepyxnsfstioerror if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  pyxpyobjectgetattrstrpyxkpswritefailedr pyxnsformat if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  null$^    if cythonunpackmethods  likelypymethodcheckpyxt0 $^      pyxt0  pymethodgetselfpyxt0$^      if likelypyxt0 $^        pyobject function  pymethodgetfunctionpyxt0$^        pyxincrefpyxt0$^        pyxincreffunction$^        pyxdecrefsetpyxt0 function$^      $^    $^    if pyxt0 $^      pyxt0  pyxpyobjectcalloneargpyxt0 pyxvfilename if unlikelypyxt0 pyxerr0 000 pyxl0error$^      pyxgotrefpyxt0$^     else $^      if cythonfastpycall$^      if pyfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxvfilename$^        pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^       else$^      endif$^      if cythonfastpyccall$^      if pyxpyfastcfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxvfilename$^        pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^       else$^      endif$^      $^        pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxgotrefpyxt0$^        pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^        pyxincrefpyxvfilename$^        pyxgiverefpyxvfilename$^        pytuplesetitempyxt0 00 pyxvfilename$^        pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^      $^    $^    pyxdecrefpyxt0 pyxt0  0$^    pyxt0  null$^    if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^      pyxt0  pymethodgetselfpyxt0$^      if likelypyxt0 $^        pyobject function  pymethodgetfunctionpyxt0$^        pyxincrefpyxt0$^        pyxincreffunction$^        pyxdecrefsetpyxt0 function$^      $^    $^    if pyxt0 $^      pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxgotrefpyxt0$^     else $^      if cythonfastpycall$^      if pyfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxt0$^        pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^       else$^      endif$^      if cythonfastpyccall$^      if pyxpyfastcfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxt0$^        pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^       else$^      endif$^      $^        pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxgotrefpyxt0$^        pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^        pyxgiverefpyxt0$^        pytuplesetitempyxt0 00 pyxt0$^        pyxt0  0$^        pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^      $^    $^    pyxdecrefpyxt0 pyxt0  0$^    pyxraisepyxt0 0 0 0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxerr0 000 pyxl0error$^$^     pywrapfst.pyx000$^        fstioerror write failed.$^      $^      if not self.table.writetexttostringfilename              $^        raise fstioerrorwrite failed r.formatfilename$^  $^ $^  $^$^   pywrapfst.pyx000$^        raise fstioerrorwrite failed r.formatfilename$^  $^    cpdef void writetextself filename except               $^      $^      writetextself filename$^ $^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.symboltable.writetext pyxclineno pyxlineno pyxfilename$^  pyxl0$^  pyxrefnannyfinishcontext$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst00symboltable00writetextpyobject pyxvself pyobject pyxvfilename proto$^static char pyxdoc0pywrapfst00symboltable00writetext  n    writetextself filenamenn    writes symbol table to text file.nn    this method writes the symboltable to a file in humanreadable format.nn    argsn      filename the string location of the output file.nn    raisesn      fstioerror write failed.n    $^static pyobject pyxpw0pywrapfst00symboltable00writetextpyobject pyxvself pyobject pyxvfilename $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextwritetext wrapper 0$^  pyxr  pyxpf0pywrapfst00symboltable00writetextstruct pyxobj0pywrapfstsymboltable pyxvself pyobject pyxvfilename$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00symboltable00writetextstruct pyxobj0pywrapfstsymboltable pyxvself pyobject pyxvfilename $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextwritetext 0$^  pyxxdecrefpyxr$^  pyxf0pywrapfst00symboltablewritetextpyxvself pyxvfilename 0 if unlikelypyerroccurred pyxerr0 000 pyxl0error$^  pyxt0  pyxvoidtononenull if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.symboltable.writetext pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ tree fragment0$^  def reducecythonself              $^      raise typeerrorself.table cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00symboltable00reducecythonpyobject pyxvself cythonunused pyobject unused proto$^static pyobject pyxpw0pywrapfst00symboltable00reducecythonpyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextreducecython wrapper 0$^  pyxr  pyxpf0pywrapfst00symboltable00reducecythonstruct pyxobj0pywrapfstsymboltable pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00symboltable00reducecythoncythonunused struct pyxobj0pywrapfstsymboltable pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextreducecython 0$^$^   tree fragment0$^  def reducecythonself$^      raise typeerrorself.table cannot be converted to a python object for pickling              $^  def setstatecythonself pyxstate$^      raise typeerrorself.table cannot be converted to a python object for pickling$^ $^  pyxt0  pyxpyobjectcallpyxbuiltintypeerror pyxtuple0 null if unlikelypyxt0 pyxerr0 0 pyxl0error$^  pyxgotrefpyxt0$^  pyxraisepyxt0 0 0 0$^  pyxdecrefpyxt0 pyxt0  0$^  pyxerr0 0 pyxl0error$^$^   tree fragment0$^  def reducecythonself              $^      raise typeerrorself.table cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.symboltable.reducecython pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ tree fragment0$^  def reducecythonself$^      raise typeerrorself.table cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate              $^      raise typeerrorself.table cannot be converted to a python object for pickling$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00symboltable00setstatecythonpyobject pyxvself pyobject pyxvpyxstate proto$^static pyobject pyxpw0pywrapfst00symboltable00setstatecythonpyobject pyxvself pyobject pyxvpyxstate $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextsetstatecython wrapper 0$^  pyxr  pyxpf0pywrapfst00symboltable00setstatecythonstruct pyxobj0pywrapfstsymboltable pyxvself pyobject pyxvpyxstate$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00symboltable00setstatecythoncythonunused struct pyxobj0pywrapfstsymboltable pyxvself cythonunused pyobject pyxvpyxstate $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextsetstatecython 0$^$^   tree fragment0$^      raise typeerrorself.table cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate$^      raise typeerrorself.table cannot be converted to a python object for pickling              $^ $^  pyxt0  pyxpyobjectcallpyxbuiltintypeerror pyxtuple0 null if unlikelypyxt0 pyxerr0 0 pyxl0error$^  pyxgotrefpyxt0$^  pyxraisepyxt0 0 0 0$^  pyxdecrefpyxt0 pyxt0  0$^  pyxerr0 0 pyxl0error$^$^   tree fragment0$^  def reducecythonself$^      raise typeerrorself.table cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate              $^      raise typeerrorself.table cannot be converted to a python object for pickling$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.symboltable.setstatecython pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx000$^     doing so will allow undefined behavior.$^  $^    def reprself              $^      return const encodemapper symboltable r at 0xx.formatself.name$^                                                                      idself$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00encodemappersymboltable0reprpyobject pyxvself proto$^static pyobject pyxpw0pywrapfst00encodemappersymboltable0reprpyobject pyxvself $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextrepr wrapper 0$^  pyxr  pyxpf0pywrapfst00encodemappersymboltablereprstruct pyxobj0pywrapfstencodemappersymboltable pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00encodemappersymboltablereprstruct pyxobj0pywrapfstencodemappersymboltable pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  int pyxt0$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextrepr 0$^$^   pywrapfst.pyx000$^  $^    def reprself$^      return const encodemapper symboltable r at 0xx.formatself.name              $^                                                                      idself$^  $^ $^  pyxxdecrefpyxr$^  pyxt0  pyxpyobjectgetattrstrpyxkpsconstencodemappersymboltable pyxnsformat if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s name$^    pyxerr0 000 pyxl0error$^  $^  pyxt0  pyxconvertpybytesstringtopystdinstringstruct pyxvtabstruct0pywrapfstencodemappersymboltable pyxvselfpyxbase.pyxvtabpyxbase.namestruct pyxobj0pywrapfstsymboltable pyxvself 0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^$^   pywrapfst.pyx000$^    def reprself$^      return const encodemapper symboltable r at 0xx.formatself.name$^                                                                      idself              $^  $^  $^ $^  pyxt0  pyxpyobjectcalloneargpyxbuiltinid pyobject pyxvself if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxt0  null$^  pyxt0  0$^  if cythonunpackmethods  likelypymethodcheckpyxt0 $^    pyxt0  pymethodgetselfpyxt0$^    if likelypyxt0 $^      pyobject function  pymethodgetfunctionpyxt0$^      pyxincrefpyxt0$^      pyxincreffunction$^      pyxdecrefsetpyxt0 function$^      pyxt0  0$^    $^  $^  if cythonfastpycall$^  if pyfunctioncheckpyxt0 $^    pyobject pyxtemp0  pyxt0 pyxt0 pyxt0$^    pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp0pyxt0 0pyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxxdecrefpyxt0 pyxt0  0$^    pyxgotrefpyxt0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxdecrefpyxt0 pyxt0  0$^   else$^  endif$^  if cythonfastpyccall$^  if pyxpyfastcfunctioncheckpyxt0 $^    pyobject pyxtemp0  pyxt0 pyxt0 pyxt0$^    pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp0pyxt0 0pyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxxdecrefpyxt0 pyxt0  0$^    pyxgotrefpyxt0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxdecrefpyxt0 pyxt0  0$^   else$^  endif$^  $^    pyxt0  pytuplenew0pyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxgotrefpyxt0$^    if pyxt0 $^      pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^    $^    pyxgiverefpyxt0$^    pytuplesetitempyxt0 0pyxt0 pyxt0$^    pyxgiverefpyxt0$^    pytuplesetitempyxt0 0pyxt0 pyxt0$^    pyxt0  0$^    pyxt0  0$^    pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxgotrefpyxt0$^    pyxdecrefpyxt0 pyxt0  0$^  $^  pyxdecrefpyxt0 pyxt0  0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   pywrapfst.pyx000$^     doing so will allow undefined behavior.$^  $^    def reprself              $^      return const encodemapper symboltable r at 0xx.formatself.name$^                                                                      idself$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.encodemappersymboltable.repr pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ tree fragment0$^  def reducecythonself              $^      raise typeerrorself.encoderself.table cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00encodemappersymboltable0reducecythonpyobject pyxvself cythonunused pyobject unused proto$^static pyobject pyxpw0pywrapfst00encodemappersymboltable0reducecythonpyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextreducecython wrapper 0$^  pyxr  pyxpf0pywrapfst00encodemappersymboltable0reducecythonstruct pyxobj0pywrapfstencodemappersymboltable pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00encodemappersymboltable0reducecythoncythonunused struct pyxobj0pywrapfstencodemappersymboltable pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextreducecython 0$^$^   tree fragment0$^  def reducecythonself$^      raise typeerrorself.encoderself.table cannot be converted to a python object for pickling              $^  def setstatecythonself pyxstate$^      raise typeerrorself.encoderself.table cannot be converted to a python object for pickling$^ $^  pyxt0  pyxpyobjectcallpyxbuiltintypeerror pyxtuple0 null if unlikelypyxt0 pyxerr0 0 pyxl0error$^  pyxgotrefpyxt0$^  pyxraisepyxt0 0 0 0$^  pyxdecrefpyxt0 pyxt0  0$^  pyxerr0 0 pyxl0error$^$^   tree fragment0$^  def reducecythonself              $^      raise typeerrorself.encoderself.table cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.encodemappersymboltable.reducecython pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ tree fragment0$^  def reducecythonself$^      raise typeerrorself.encoderself.table cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate              $^      raise typeerrorself.encoderself.table cannot be converted to a python object for pickling$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00encodemappersymboltable0setstatecythonpyobject pyxvself pyobject pyxvpyxstate proto$^static pyobject pyxpw0pywrapfst00encodemappersymboltable0setstatecythonpyobject pyxvself pyobject pyxvpyxstate $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextsetstatecython wrapper 0$^  pyxr  pyxpf0pywrapfst00encodemappersymboltable0setstatecythonstruct pyxobj0pywrapfstencodemappersymboltable pyxvself pyobject pyxvpyxstate$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00encodemappersymboltable0setstatecythoncythonunused struct pyxobj0pywrapfstencodemappersymboltable pyxvself cythonunused pyobject pyxvpyxstate $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextsetstatecython 0$^$^   tree fragment0$^      raise typeerrorself.encoderself.table cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate$^      raise typeerrorself.encoderself.table cannot be converted to a python object for pickling              $^ $^  pyxt0  pyxpyobjectcallpyxbuiltintypeerror pyxtuple00 null if unlikelypyxt0 pyxerr0 0 pyxl0error$^  pyxgotrefpyxt0$^  pyxraisepyxt0 0 0 0$^  pyxdecrefpyxt0 pyxt0  0$^  pyxerr0 0 pyxl0error$^$^   tree fragment0$^  def reducecythonself$^      raise typeerrorself.encoderself.table cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate              $^      raise typeerrorself.encoderself.table cannot be converted to a python object for pickling$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.encodemappersymboltable.setstatecython pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx000$^     doing so will allow undefined behavior.$^  $^    def reprself              $^      return const fst symboltable r at 0xx.formatself.name$^                                                             idself$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00fstsymboltable0reprpyobject pyxvself proto$^static pyobject pyxpw0pywrapfst00fstsymboltable0reprpyobject pyxvself $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextrepr wrapper 0$^  pyxr  pyxpf0pywrapfst00fstsymboltablereprstruct pyxobj0pywrapfstfstsymboltable pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00fstsymboltablereprstruct pyxobj0pywrapfstfstsymboltable pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  int pyxt0$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextrepr 0$^$^   pywrapfst.pyx000$^  $^    def reprself$^      return const fst symboltable r at 0xx.formatself.name              $^                                                             idself$^  $^ $^  pyxxdecrefpyxr$^  pyxt0  pyxpyobjectgetattrstrpyxkpsconstfstsymboltablerat0xx pyxnsformat if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s name$^    pyxerr0 000 pyxl0error$^  $^  pyxt0  pyxconvertpybytesstringtopystdinstringstruct pyxvtabstruct0pywrapfstfstsymboltable pyxvselfpyxbase.pyxvtabpyxbase.namestruct pyxobj0pywrapfstsymboltable pyxvself 0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^$^   pywrapfst.pyx000$^    def reprself$^      return const fst symboltable r at 0xx.formatself.name$^                                                             idself              $^  $^  $^ $^  pyxt0  pyxpyobjectcalloneargpyxbuiltinid pyobject pyxvself if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxt0  null$^  pyxt0  0$^  if cythonunpackmethods  likelypymethodcheckpyxt0 $^    pyxt0  pymethodgetselfpyxt0$^    if likelypyxt0 $^      pyobject function  pymethodgetfunctionpyxt0$^      pyxincrefpyxt0$^      pyxincreffunction$^      pyxdecrefsetpyxt0 function$^      pyxt0  0$^    $^  $^  if cythonfastpycall$^  if pyfunctioncheckpyxt0 $^    pyobject pyxtemp0  pyxt0 pyxt0 pyxt0$^    pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp0pyxt0 0pyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxxdecrefpyxt0 pyxt0  0$^    pyxgotrefpyxt0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxdecrefpyxt0 pyxt0  0$^   else$^  endif$^  if cythonfastpyccall$^  if pyxpyfastcfunctioncheckpyxt0 $^    pyobject pyxtemp0  pyxt0 pyxt0 pyxt0$^    pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp0pyxt0 0pyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxxdecrefpyxt0 pyxt0  0$^    pyxgotrefpyxt0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxdecrefpyxt0 pyxt0  0$^   else$^  endif$^  $^    pyxt0  pytuplenew0pyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxgotrefpyxt0$^    if pyxt0 $^      pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^    $^    pyxgiverefpyxt0$^    pytuplesetitempyxt0 0pyxt0 pyxt0$^    pyxgiverefpyxt0$^    pytuplesetitempyxt0 0pyxt0 pyxt0$^    pyxt0  0$^    pyxt0  0$^    pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxgotrefpyxt0$^    pyxdecrefpyxt0 pyxt0  0$^  $^  pyxdecrefpyxt0 pyxt0  0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   pywrapfst.pyx000$^     doing so will allow undefined behavior.$^  $^    def reprself              $^      return const fst symboltable r at 0xx.formatself.name$^                                                             idself$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.fstsymboltable.repr pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ tree fragment0$^  def reducecythonself              $^      raise typeerrorself.fstself.table cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00fstsymboltable0reducecythonpyobject pyxvself cythonunused pyobject unused proto$^static pyobject pyxpw0pywrapfst00fstsymboltable0reducecythonpyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextreducecython wrapper 0$^  pyxr  pyxpf0pywrapfst00fstsymboltable0reducecythonstruct pyxobj0pywrapfstfstsymboltable pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00fstsymboltable0reducecythoncythonunused struct pyxobj0pywrapfstfstsymboltable pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextreducecython 0$^$^   tree fragment0$^  def reducecythonself$^      raise typeerrorself.fstself.table cannot be converted to a python object for pickling              $^  def setstatecythonself pyxstate$^      raise typeerrorself.fstself.table cannot be converted to a python object for pickling$^ $^  pyxt0  pyxpyobjectcallpyxbuiltintypeerror pyxtuple00 null if unlikelypyxt0 pyxerr0 0 pyxl0error$^  pyxgotrefpyxt0$^  pyxraisepyxt0 0 0 0$^  pyxdecrefpyxt0 pyxt0  0$^  pyxerr0 0 pyxl0error$^$^   tree fragment0$^  def reducecythonself              $^      raise typeerrorself.fstself.table cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.fstsymboltable.reducecython pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ tree fragment0$^  def reducecythonself$^      raise typeerrorself.fstself.table cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate              $^      raise typeerrorself.fstself.table cannot be converted to a python object for pickling$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00fstsymboltable0setstatecythonpyobject pyxvself pyobject pyxvpyxstate proto$^static pyobject pyxpw0pywrapfst00fstsymboltable0setstatecythonpyobject pyxvself pyobject pyxvpyxstate $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextsetstatecython wrapper 0$^  pyxr  pyxpf0pywrapfst00fstsymboltable0setstatecythonstruct pyxobj0pywrapfstfstsymboltable pyxvself pyobject pyxvpyxstate$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00fstsymboltable0setstatecythoncythonunused struct pyxobj0pywrapfstfstsymboltable pyxvself cythonunused pyobject pyxvpyxstate $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextsetstatecython 0$^$^   tree fragment0$^      raise typeerrorself.fstself.table cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate$^      raise typeerrorself.fstself.table cannot be converted to a python object for pickling              $^ $^  pyxt0  pyxpyobjectcallpyxbuiltintypeerror pyxtuple00 null if unlikelypyxt0 pyxerr0 0 pyxl0error$^  pyxgotrefpyxt0$^  pyxraisepyxt0 0 0 0$^  pyxdecrefpyxt0 pyxt0  0$^  pyxerr0 0 pyxl0error$^$^   tree fragment0$^  def reducecythonself$^      raise typeerrorself.fstself.table cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate              $^      raise typeerrorself.fstself.table cannot be converted to a python object for pickling$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.fstsymboltable.setstatecython pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx000$^    $^  $^    cpdef int00 addsymbolself symbol int00 keyknosymbol              $^      $^      addsymbolself symbol keynosymbol$^ $^$^static pyobject pyxpw0pywrapfst00mutablesymboltable0addsymbolpyobject pyxvself pyobject pyxargs pyobject pyxkwds proto$^static pyxt00basictypesint00 pyxf0pywrapfst00mutablesymboltableaddsymbolstruct pyxobj0pywrapfstmutablesymboltable pyxvself pyobject pyxvsymbol int pyxskipdispatch struct pyxoptargs0pywrapfst00mutablesymboltableaddsymbol pyxoptionalargs $^  pyxt00basictypesint00 pyxvkey  pyxk00$^  stdstring pyxvsymbolstring$^  pyxt00basictypesint00 pyxr$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  int pyxt0$^  pyobject pyxt0  null$^  pyxt00basictypesint00 pyxt0$^  stdstring pyxt0$^  int pyxt00$^  pyxrefnannysetupcontextaddsymbol 0$^  if pyxoptionalargs $^    if pyxoptionalargspyxn  0 $^      pyxvkey  pyxoptionalargskey$^    $^  $^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnsaddsymbol if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst00mutablesymboltable0addsymbol $^      pyxt0  pyxpyintfromint00tpyxvkey if unlikelypyxt0 pyxerr0 000 pyxl0error$^      pyxgotrefpyxt0$^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      pyxt0  0$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^          pyxt0  0$^        $^      $^      if cythonfastpycall$^      if pyfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxvsymbol pyxt0$^        pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp0pyxt0 0pyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^       else$^      endif$^      if cythonfastpyccall$^      if pyxpyfastcfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxvsymbol pyxt0$^        pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp0pyxt0 0pyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^       else$^      endif$^      $^        pyxt0  pytuplenew0pyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxgotrefpyxt0$^        if pyxt0 $^          pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^        $^        pyxincrefpyxvsymbol$^        pyxgiverefpyxvsymbol$^        pytuplesetitempyxt0 0pyxt0 pyxvsymbol$^        pyxgiverefpyxt0$^        pytuplesetitempyxt0 0pyxt0 pyxt0$^        pyxt0  0$^        pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^      $^      pyxdecrefpyxt0 pyxt0  0$^      pyxt0  pyxpyintasint00tpyxt0 if unlikelypyxt0  int00t0  pyerroccurred pyxerr0 000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxr  pyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx000$^        the integer key of the new symbol.$^      $^      cdef string symbolstring  tostringsymbol              $^      if key  knosymbol$^        return self.table.addsymbolsymbolstring key$^ $^  pyxt0  pyxf0pywrapfsttostringpyxvsymbol null if unlikelypyerroccurred pyxerr0 000 pyxl0error$^  pyxvsymbolstring  pyxt0$^$^   pywrapfst.pyx000$^      $^      cdef string symbolstring  tostringsymbol$^      if key  knosymbol              $^        return self.table.addsymbolsymbolstring key$^      else$^ $^  pyxt0  pyxpyintfromint00tpyxvkey if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxt0  pyxgetmoduleglobalnamepyxnsknosymbol if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxt0  pyobjectrichcomparepyxt0 pyxt0 pyne pyxxgotrefpyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^  pyxdecrefpyxt0 pyxt0  0$^  pyxt00  pyxpyobjectistruepyxt0 if unlikelypyxt00  0 pyxerr0 000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^  if pyxt00 $^$^     pywrapfst.pyx000$^      cdef string symbolstring  tostringsymbol$^      if key  knosymbol$^        return self.table.addsymbolsymbolstring key              $^      else$^        return self.table.addsymbolsymbolstring$^ $^    if unlikelypyobject pyxvself  pynone $^      pyerrformatpyexcattributeerror nonetype object has no attribute .00s table$^      pyxerr0 000 pyxl0error$^    $^    pyxr  pyxvselfpyxbase.tableaddsymbolpyxvsymbolstring pyxvkey$^    goto pyxl0$^$^     pywrapfst.pyx000$^      $^      cdef string symbolstring  tostringsymbol$^      if key  knosymbol              $^        return self.table.addsymbolsymbolstring key$^      else$^ $^  $^$^   pywrapfst.pyx000$^        return self.table.addsymbolsymbolstring key$^      else$^        return self.table.addsymbolsymbolstring              $^  $^    cpdef void addtableself symboltable syms$^ $^  else $^    if unlikelypyobject pyxvself  pynone $^      pyerrformatpyexcattributeerror nonetype object has no attribute .00s table$^      pyxerr0 000 pyxl0error$^    $^    pyxr  pyxvselfpyxbase.tableaddsymbolpyxvsymbolstring$^    goto pyxl0$^  $^$^   pywrapfst.pyx000$^    $^  $^    cpdef int00 addsymbolself symbol int00 keyknosymbol              $^      $^      addsymbolself symbol keynosymbol$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxwriteunraisablepywrapfst.mutablesymboltable.addsymbol pyxclineno pyxlineno pyxfilename 0 0$^  pyxr  0$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst00mutablesymboltable0addsymbolpyobject pyxvself pyobject pyxargs pyobject pyxkwds proto$^static char pyxdoc0pywrapfst00mutablesymboltableaddsymbol  n    addsymbolself symbol keynosymbolnn    adds a symbol to the table and returns the index.nn    this method adds a symbol to the table. the caller can optionallyn    specify a nonnegative integer index for the key.nn    argsn      symbol a symbol string.n      key an index for the symbol if not specified the next index will ben          used.nn    returnsn      the integer key of the new symbol.n    $^static pyobject pyxpw0pywrapfst00mutablesymboltable0addsymbolpyobject pyxvself pyobject pyxargs pyobject pyxkwds $^  pyobject pyxvsymbol  0$^  pyxt00basictypesint00 pyxvkey$^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextaddsymbol wrapper 0$^  $^    static pyobject pyxpyargnames  pyxnssymbolpyxnskey0$^    pyobject values0  00$^    if unlikelypyxkwds $^      pyssizet kwargs$^      const pyssizet posargs  pytuplegetsizepyxargs$^      switch posargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 break$^        default goto pyxl0argtupleerror$^      $^      kwargs  pydictsizepyxkwds$^      switch posargs $^        case  0$^        if likelyvalues0  pyxpydictgetitemstrpyxkwds pyxnssymbol  0 kwargs$^        else goto pyxl0argtupleerror$^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnskey$^          if value  values0  value kwargs $^        $^      $^      if unlikelykwargs  0 $^        if unlikelypyxparseoptionalkeywordspyxkwds pyxpyargnames 0 values posargs addsymbol  0 pyxerr0 000 pyxl0error$^      $^     else $^      switch pytuplegetsizepyxargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        break$^        default goto pyxl0argtupleerror$^      $^    $^    pyxvsymbol  values0$^    if values0 $^      pyxvkey  pyxpyintasint00tvalues0 if unlikelypyxvkey  int00t0  pyerroccurred pyxerr0 000 pyxl0error$^     else $^      pyxvkey  pyxk00$^    $^  $^  goto pyxl0argumentunpackingdone$^  pyxl0argtupleerror$^  pyxraiseargtupleinvalidaddsymbol 0 0 0 pytuplegetsizepyxargs pyxerr0 000 pyxl0error$^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablesymboltable.addsymbol pyxclineno pyxlineno pyxfilename$^  pyxrefnannyfinishcontext$^  return null$^  pyxl0argumentunpackingdone$^  pyxr  pyxpf0pywrapfst00mutablesymboltableaddsymbolstruct pyxobj0pywrapfstmutablesymboltable pyxvself pyxvsymbol pyxvkey$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00mutablesymboltableaddsymbolstruct pyxobj0pywrapfstmutablesymboltable pyxvself pyobject pyxvsymbol pyxt00basictypesint00 pyxvkey $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyxt00basictypesint00 pyxt0$^  struct pyxoptargs0pywrapfst00mutablesymboltableaddsymbol pyxt0$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextaddsymbol 0$^  pyxxdecrefpyxr$^  pyxt0.pyxn  0$^  pyxt0.key  pyxvkey$^  pyxt0  pyxvtabptr0pywrapfstmutablesymboltableaddsymbolpyxvself pyxvsymbol 0 pyxt0 $^  pyxt0  pyxpyintfromint00tpyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.mutablesymboltable.addsymbol pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx000$^        return self.table.addsymbolsymbolstring$^  $^    cpdef void addtableself symboltable syms              $^      $^      addtableself syms$^ $^$^static pyobject pyxpw0pywrapfst00mutablesymboltable0addtablepyobject pyxvself pyobject pyxvsyms proto$^static void pyxf0pywrapfst00mutablesymboltableaddtablestruct pyxobj0pywrapfstmutablesymboltable pyxvself struct pyxobj0pywrapfstsymboltable pyxvsyms int pyxskipdispatch $^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextaddtable 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnsaddtable if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst00mutablesymboltable0addtable $^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyobject pyxvsyms if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxgotrefpyxt0$^       else $^        if cythonfastpycall$^        if pyfunctioncheckpyxt0 $^          pyobject pyxtemp0  pyxt0 pyobject pyxvsyms$^          pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^          pyxxdecrefpyxt0 pyxt0  0$^          pyxgotrefpyxt0$^         else$^        endif$^        if cythonfastpyccall$^        if pyxpyfastcfunctioncheckpyxt0 $^          pyobject pyxtemp0  pyxt0 pyobject pyxvsyms$^          pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^          pyxxdecrefpyxt0 pyxt0  0$^          pyxgotrefpyxt0$^         else$^        endif$^        $^          pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^          pyxgotrefpyxt0$^          pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^          pyxincrefpyobject pyxvsyms$^          pyxgiverefpyobject pyxvsyms$^          pytuplesetitempyxt0 00 pyobject pyxvsyms$^          pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 000 pyxl0error$^          pyxgotrefpyxt0$^          pyxdecrefpyxt0 pyxt0  0$^        $^      $^      pyxdecrefpyxt0 pyxt0  0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx000$^        syms a symboltable to be merged with the current table.$^      $^      self.table.addtablederefsyms.table              $^  $^    cpdef void setnameself newname except $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s table$^    pyxerr0 000 pyxl0error$^  $^  if unlikelypyobject pyxvsyms  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s table$^    pyxerr0 000 pyxl0error$^  $^  pyxvselfpyxbase.tableaddtablepyxvsymstable$^$^   pywrapfst.pyx000$^        return self.table.addsymbolsymbolstring$^  $^    cpdef void addtableself symboltable syms              $^      $^      addtableself syms$^ $^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxwriteunraisablepywrapfst.mutablesymboltable.addtable pyxclineno pyxlineno pyxfilename 0 0$^  pyxl0$^  pyxrefnannyfinishcontext$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst00mutablesymboltable0addtablepyobject pyxvself pyobject pyxvsyms proto$^static char pyxdoc0pywrapfst00mutablesymboltable0addtable  n    addtableself symsnn    adds another symboltable to this table.nn    this method merges another symbol table into the current table. all keyn    values will be offset by the current available key.nn    argsn      syms a symboltable to be merged with the current table.n    $^static pyobject pyxpw0pywrapfst00mutablesymboltable0addtablepyobject pyxvself pyobject pyxvsyms $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextaddtable wrapper 0$^  if unlikelypyxargtypetestpyobject pyxvsyms pyxptype0pywrapfstsymboltable 0 syms 0 pyxerr0 000 pyxl0error$^  pyxr  pyxpf0pywrapfst00mutablesymboltable0addtablestruct pyxobj0pywrapfstmutablesymboltable pyxvself struct pyxobj0pywrapfstsymboltable pyxvsyms$^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxr  null$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00mutablesymboltable0addtablestruct pyxobj0pywrapfstmutablesymboltable pyxvself struct pyxobj0pywrapfstsymboltable pyxvsyms $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextaddtable 0$^  pyxxdecrefpyxr$^  pyxt0  pyxvoidtononepyxf0pywrapfst00mutablesymboltableaddtablepyxvself pyxvsyms 0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.mutablesymboltable.addtable pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx000$^      self.table.addtablederefsyms.table$^  $^    cpdef void setnameself newname except               $^      self.table.setnametostringnewname$^  $^ $^$^static pyobject pyxpw0pywrapfst00mutablesymboltable0setnamepyobject pyxvself pyobject pyxvnewname proto$^static void pyxf0pywrapfst00mutablesymboltablesetnamestruct pyxobj0pywrapfstmutablesymboltable pyxvself pyobject pyxvnewname int pyxskipdispatch $^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  stdstring pyxt0$^  pyxrefnannysetupcontextsetname 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnssetname if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst00mutablesymboltable0setname $^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxvnewname if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxgotrefpyxt0$^       else $^        if cythonfastpycall$^        if pyfunctioncheckpyxt0 $^          pyobject pyxtemp0  pyxt0 pyxvnewname$^          pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^          pyxxdecrefpyxt0 pyxt0  0$^          pyxgotrefpyxt0$^         else$^        endif$^        if cythonfastpyccall$^        if pyxpyfastcfunctioncheckpyxt0 $^          pyobject pyxtemp0  pyxt0 pyxvnewname$^          pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^          pyxxdecrefpyxt0 pyxt0  0$^          pyxgotrefpyxt0$^         else$^        endif$^        $^          pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^          pyxgotrefpyxt0$^          pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^          pyxincrefpyxvnewname$^          pyxgiverefpyxvnewname$^          pytuplesetitempyxt0 00 pyxvnewname$^          pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 000 pyxl0error$^          pyxgotrefpyxt0$^          pyxdecrefpyxt0 pyxt0  0$^        $^      $^      pyxdecrefpyxt0 pyxt0  0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx000$^  $^    cpdef void setnameself newname except $^      self.table.setnametostringnewname              $^  $^  $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s table$^    pyxerr0 000 pyxl0error$^  $^  pyxt0  pyxf0pywrapfsttostringpyxvnewname null if unlikelypyerroccurred pyxerr0 000 pyxl0error$^  pyxvselfpyxbase.tablesetnamepyxt0$^$^   pywrapfst.pyx000$^      self.table.addtablederefsyms.table$^  $^    cpdef void setnameself newname except               $^      self.table.setnametostringnewname$^  $^ $^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.mutablesymboltable.setname pyxclineno pyxlineno pyxfilename$^  pyxl0$^  pyxrefnannyfinishcontext$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst00mutablesymboltable0setnamepyobject pyxvself pyobject pyxvnewname proto$^static pyobject pyxpw0pywrapfst00mutablesymboltable0setnamepyobject pyxvself pyobject pyxvnewname $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextsetname wrapper 0$^  pyxr  pyxpf0pywrapfst00mutablesymboltable0setnamestruct pyxobj0pywrapfstmutablesymboltable pyxvself pyobject pyxvnewname$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00mutablesymboltable0setnamestruct pyxobj0pywrapfstmutablesymboltable pyxvself pyobject pyxvnewname $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextsetname 0$^  pyxxdecrefpyxr$^  pyxf0pywrapfst00mutablesymboltablesetnamepyxvself pyxvnewname 0 if unlikelypyerroccurred pyxerr0 000 pyxl0error$^  pyxt0  pyxvoidtononenull if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.mutablesymboltable.setname pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ tree fragment0$^  def reducecythonself              $^      raise typeerrorself.table cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00mutablesymboltable0reducecythonpyobject pyxvself cythonunused pyobject unused proto$^static pyobject pyxpw0pywrapfst00mutablesymboltable0reducecythonpyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextreducecython wrapper 0$^  pyxr  pyxpf0pywrapfst00mutablesymboltable0reducecythonstruct pyxobj0pywrapfstmutablesymboltable pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00mutablesymboltable0reducecythoncythonunused struct pyxobj0pywrapfstmutablesymboltable pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextreducecython 0$^$^   tree fragment0$^  def reducecythonself$^      raise typeerrorself.table cannot be converted to a python object for pickling              $^  def setstatecythonself pyxstate$^      raise typeerrorself.table cannot be converted to a python object for pickling$^ $^  pyxt0  pyxpyobjectcallpyxbuiltintypeerror pyxtuple00 null if unlikelypyxt0 pyxerr0 0 pyxl0error$^  pyxgotrefpyxt0$^  pyxraisepyxt0 0 0 0$^  pyxdecrefpyxt0 pyxt0  0$^  pyxerr0 0 pyxl0error$^$^   tree fragment0$^  def reducecythonself              $^      raise typeerrorself.table cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.mutablesymboltable.reducecython pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ tree fragment0$^  def reducecythonself$^      raise typeerrorself.table cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate              $^      raise typeerrorself.table cannot be converted to a python object for pickling$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00mutablesymboltable0setstatecythonpyobject pyxvself pyobject pyxvpyxstate proto$^static pyobject pyxpw0pywrapfst00mutablesymboltable0setstatecythonpyobject pyxvself pyobject pyxvpyxstate $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextsetstatecython wrapper 0$^  pyxr  pyxpf0pywrapfst00mutablesymboltable0setstatecythonstruct pyxobj0pywrapfstmutablesymboltable pyxvself pyobject pyxvpyxstate$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00mutablesymboltable0setstatecythoncythonunused struct pyxobj0pywrapfstmutablesymboltable pyxvself cythonunused pyobject pyxvpyxstate $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextsetstatecython 0$^$^   tree fragment0$^      raise typeerrorself.table cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate$^      raise typeerrorself.table cannot be converted to a python object for pickling              $^ $^  pyxt0  pyxpyobjectcallpyxbuiltintypeerror pyxtuple00 null if unlikelypyxt0 pyxerr0 0 pyxl0error$^  pyxgotrefpyxt0$^  pyxraisepyxt0 0 0 0$^  pyxdecrefpyxt0 pyxt0  0$^  pyxerr0 0 pyxl0error$^$^   tree fragment0$^  def reducecythonself$^      raise typeerrorself.table cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate              $^      raise typeerrorself.table cannot be converted to a python object for pickling$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.mutablesymboltable.setstatecython pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx000$^    $^  $^    def reprself              $^      return fst symboltable r at 0xx.formatself.name idself$^  $^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00mutablefstsymboltable0reprpyobject pyxvself proto$^static pyobject pyxpw0pywrapfst00mutablefstsymboltable0reprpyobject pyxvself $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextrepr wrapper 0$^  pyxr  pyxpf0pywrapfst00mutablefstsymboltablereprstruct pyxobj0pywrapfstmutablefstsymboltable pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00mutablefstsymboltablereprstruct pyxobj0pywrapfstmutablefstsymboltable pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  int pyxt0$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextrepr 0$^$^   pywrapfst.pyx000$^  $^    def reprself$^      return fst symboltable r at 0xx.formatself.name idself              $^  $^  $^ $^  pyxxdecrefpyxr$^  pyxt0  pyxpyobjectgetattrstrpyxkpsfstsymboltablerat0xx pyxnsformat if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s name$^    pyxerr0 000 pyxl0error$^  $^  pyxt0  pyxconvertpybytesstringtopystdinstringstruct pyxvtabstruct0pywrapfstmutablefstsymboltable pyxvselfpyxbase.pyxbase.pyxvtabpyxbase.pyxbase.namestruct pyxobj0pywrapfstsymboltable pyxvself 0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxt0  pyxpyobjectcalloneargpyxbuiltinid pyobject pyxvself if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxt0  null$^  pyxt0  0$^  if cythonunpackmethods  likelypymethodcheckpyxt0 $^    pyxt0  pymethodgetselfpyxt0$^    if likelypyxt0 $^      pyobject function  pymethodgetfunctionpyxt0$^      pyxincrefpyxt0$^      pyxincreffunction$^      pyxdecrefsetpyxt0 function$^      pyxt0  0$^    $^  $^  if cythonfastpycall$^  if pyfunctioncheckpyxt0 $^    pyobject pyxtemp0  pyxt0 pyxt0 pyxt0$^    pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp0pyxt0 0pyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxxdecrefpyxt0 pyxt0  0$^    pyxgotrefpyxt0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxdecrefpyxt0 pyxt0  0$^   else$^  endif$^  if cythonfastpyccall$^  if pyxpyfastcfunctioncheckpyxt0 $^    pyobject pyxtemp0  pyxt0 pyxt0 pyxt0$^    pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp0pyxt0 0pyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxxdecrefpyxt0 pyxt0  0$^    pyxgotrefpyxt0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxdecrefpyxt0 pyxt0  0$^   else$^  endif$^  $^    pyxt0  pytuplenew0pyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxgotrefpyxt0$^    if pyxt0 $^      pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^    $^    pyxgiverefpyxt0$^    pytuplesetitempyxt0 0pyxt0 pyxt0$^    pyxgiverefpyxt0$^    pytuplesetitempyxt0 0pyxt0 pyxt0$^    pyxt0  0$^    pyxt0  0$^    pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxgotrefpyxt0$^    pyxdecrefpyxt0 pyxt0  0$^  $^  pyxdecrefpyxt0 pyxt0  0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   pywrapfst.pyx000$^    $^  $^    def reprself              $^      return fst symboltable r at 0xx.formatself.name idself$^  $^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.mutablefstsymboltable.repr pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ tree fragment0$^  def reducecythonself              $^      raise typeerrorself.mfstself.table cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00mutablefstsymboltable0reducecythonpyobject pyxvself cythonunused pyobject unused proto$^static pyobject pyxpw0pywrapfst00mutablefstsymboltable0reducecythonpyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextreducecython wrapper 0$^  pyxr  pyxpf0pywrapfst00mutablefstsymboltable0reducecythonstruct pyxobj0pywrapfstmutablefstsymboltable pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00mutablefstsymboltable0reducecythoncythonunused struct pyxobj0pywrapfstmutablefstsymboltable pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextreducecython 0$^$^   tree fragment0$^  def reducecythonself$^      raise typeerrorself.mfstself.table cannot be converted to a python object for pickling              $^  def setstatecythonself pyxstate$^      raise typeerrorself.mfstself.table cannot be converted to a python object for pickling$^ $^  pyxt0  pyxpyobjectcallpyxbuiltintypeerror pyxtuple00 null if unlikelypyxt0 pyxerr0 0 pyxl0error$^  pyxgotrefpyxt0$^  pyxraisepyxt0 0 0 0$^  pyxdecrefpyxt0 pyxt0  0$^  pyxerr0 0 pyxl0error$^$^   tree fragment0$^  def reducecythonself              $^      raise typeerrorself.mfstself.table cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.mutablefstsymboltable.reducecython pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ tree fragment0$^  def reducecythonself$^      raise typeerrorself.mfstself.table cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate              $^      raise typeerrorself.mfstself.table cannot be converted to a python object for pickling$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00mutablefstsymboltable0setstatecythonpyobject pyxvself pyobject pyxvpyxstate proto$^static pyobject pyxpw0pywrapfst00mutablefstsymboltable0setstatecythonpyobject pyxvself pyobject pyxvpyxstate $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextsetstatecython wrapper 0$^  pyxr  pyxpf0pywrapfst00mutablefstsymboltable0setstatecythonstruct pyxobj0pywrapfstmutablefstsymboltable pyxvself pyobject pyxvpyxstate$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00mutablefstsymboltable0setstatecythoncythonunused struct pyxobj0pywrapfstmutablefstsymboltable pyxvself cythonunused pyobject pyxvpyxstate $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextsetstatecython 0$^$^   tree fragment0$^      raise typeerrorself.mfstself.table cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate$^      raise typeerrorself.mfstself.table cannot be converted to a python object for pickling              $^ $^  pyxt0  pyxpyobjectcallpyxbuiltintypeerror pyxtuple00 null if unlikelypyxt0 pyxerr0 0 pyxl0error$^  pyxgotrefpyxt0$^  pyxraisepyxt0 0 0 0$^  pyxdecrefpyxt0 pyxt0  0$^  pyxerr0 0 pyxl0error$^$^   tree fragment0$^  def reducecythonself$^      raise typeerrorself.mfstself.table cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate              $^      raise typeerrorself.mfstself.table cannot be converted to a python object for pickling$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.mutablefstsymboltable.setstatecython pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx000$^    $^  $^    def reprself              $^      return symboltable r at 0xx.formatself.name idself$^  $^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00symboltable0reprpyobject pyxvself proto$^static pyobject pyxpw0pywrapfst00symboltable0reprpyobject pyxvself $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextrepr wrapper 0$^  pyxr  pyxpf0pywrapfst00symboltablereprstruct pyxobj0pywrapfstsymboltable pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00symboltablereprstruct pyxobj0pywrapfstsymboltable pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  int pyxt0$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextrepr 0$^$^   pywrapfst.pyx000$^  $^    def reprself$^      return symboltable r at 0xx.formatself.name idself              $^  $^    def initself namebunspecified$^ $^  pyxxdecrefpyxr$^  pyxt0  pyxpyobjectgetattrstrpyxkpssymboltablerat0xx pyxnsformat if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s name$^    pyxerr0 000 pyxl0error$^  $^  pyxt0  pyxconvertpybytesstringtopystdinstringstruct pyxvtabstruct0pywrapfstsymboltable pyxvselfpyxbase.pyxbase.pyxvtabpyxbase.pyxbase.namestruct pyxobj0pywrapfstsymboltable pyxvself 0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxt0  pyxpyobjectcalloneargpyxbuiltinid pyobject pyxvself if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxt0  null$^  pyxt0  0$^  if cythonunpackmethods  likelypymethodcheckpyxt0 $^    pyxt0  pymethodgetselfpyxt0$^    if likelypyxt0 $^      pyobject function  pymethodgetfunctionpyxt0$^      pyxincrefpyxt0$^      pyxincreffunction$^      pyxdecrefsetpyxt0 function$^      pyxt0  0$^    $^  $^  if cythonfastpycall$^  if pyfunctioncheckpyxt0 $^    pyobject pyxtemp0  pyxt0 pyxt0 pyxt0$^    pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp0pyxt0 0pyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxxdecrefpyxt0 pyxt0  0$^    pyxgotrefpyxt0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxdecrefpyxt0 pyxt0  0$^   else$^  endif$^  if cythonfastpyccall$^  if pyxpyfastcfunctioncheckpyxt0 $^    pyobject pyxtemp0  pyxt0 pyxt0 pyxt0$^    pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp0pyxt0 0pyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxxdecrefpyxt0 pyxt0  0$^    pyxgotrefpyxt0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxdecrefpyxt0 pyxt0  0$^   else$^  endif$^  $^    pyxt0  pytuplenew0pyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxgotrefpyxt0$^    if pyxt0 $^      pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^    $^    pyxgiverefpyxt0$^    pytuplesetitempyxt0 0pyxt0 pyxt0$^    pyxgiverefpyxt0$^    pytuplesetitempyxt0 0pyxt0 pyxt0$^    pyxt0  0$^    pyxt0  0$^    pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxgotrefpyxt0$^    pyxdecrefpyxt0 pyxt0  0$^  $^  pyxdecrefpyxt0 pyxt0  0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   pywrapfst.pyx000$^    $^  $^    def reprself              $^      return symboltable r at 0xx.formatself.name idself$^  $^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.symboltable.repr pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx000$^      return symboltable r at 0xx.formatself.name idself$^  $^    def initself namebunspecified              $^      self.table  new fst.symboltabletostringname$^      self.smarttable.resetself.table$^ $^$^ python wrapper $^static int pyxpw0pywrapfst00symboltable0initpyobject pyxvself pyobject pyxargs pyobject pyxkwds proto$^static int pyxpw0pywrapfst00symboltable0initpyobject pyxvself pyobject pyxargs pyobject pyxkwds $^  pyobject pyxvname  0$^  int pyxr$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextinit wrapper 0$^  $^    static pyobject pyxpyargnames  pyxnsname00$^    pyobject values0  0$^    values0  pyobject pyxkpbunspecified$^    if unlikelypyxkwds $^      pyssizet kwargs$^      const pyssizet posargs  pytuplegetsizepyxargs$^      switch posargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 break$^        default goto pyxl0argtupleerror$^      $^      kwargs  pydictsizepyxkwds$^      switch posargs $^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnsname0$^          if value  values0  value kwargs $^        $^      $^      if unlikelykwargs  0 $^        if unlikelypyxparseoptionalkeywordspyxkwds pyxpyargnames 0 values posargs init  0 pyxerr0 000 pyxl0error$^      $^     else $^      switch pytuplegetsizepyxargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 break$^        default goto pyxl0argtupleerror$^      $^    $^    pyxvname  values0$^  $^  goto pyxl0argumentunpackingdone$^  pyxl0argtupleerror$^  pyxraiseargtupleinvalidinit 0 0 0 pytuplegetsizepyxargs pyxerr0 000 pyxl0error$^  pyxl0error$^  pyxaddtracebackpywrapfst.symboltable.init pyxclineno pyxlineno pyxfilename$^  pyxrefnannyfinishcontext$^  return 0$^  pyxl0argumentunpackingdone$^  pyxr  pyxpf0pywrapfst00symboltable0initstruct pyxobj0pywrapfstsymboltable pyxvself pyxvname$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static int pyxpf0pywrapfst00symboltable0initstruct pyxobj0pywrapfstsymboltable pyxvself pyobject pyxvname $^  int pyxr$^  pyxrefnannydeclarations$^  stdstring pyxt0$^  pyxrefnannysetupcontextinit 0$^$^   pywrapfst.pyx000$^  $^    def initself namebunspecified$^      self.table  new fst.symboltabletostringname              $^      self.smarttable.resetself.table$^  $^ $^  pyxt0  pyxf0pywrapfsttostringpyxvname null if unlikelypyerroccurred pyxerr0 000 pyxl0error$^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s table$^    pyxerr0 000 pyxl0error$^  $^  pyxvselfpyxbase.pyxbase.table  new fstsymboltablepyxt0$^$^   pywrapfst.pyx000$^    def initself namebunspecified$^      self.table  new fst.symboltabletostringname$^      self.smarttable.resetself.table              $^  $^    classmethod$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s smarttable$^    pyxerr0 000 pyxl0error$^  $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s table$^    pyxerr0 000 pyxl0error$^  $^  pyxvselfsmarttable.resetpyxvselfpyxbase.pyxbase.table$^$^   pywrapfst.pyx000$^      return symboltable r at 0xx.formatself.name idself$^  $^    def initself namebunspecified              $^      self.table  new fst.symboltabletostringname$^      self.smarttable.resetself.table$^ $^$^   function exit code $^  pyxr  0$^  goto pyxl0$^  pyxl0error$^  pyxaddtracebackpywrapfst.symboltable.init pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx000$^  $^    classmethod$^    def readcls filename              $^      $^      symboltable.readfilename$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00symboltable0readpyobject pyxvcls pyobject pyxvfilename proto$^static char pyxdoc0pywrapfst00symboltable0read  n    symboltable.readfilenamenn    reads symbol table from binary file.nn    this class method creates a new symboltable from a symbol table binary file.nn    argsn      filename the string location of the input binary file.nn    returnsn      a new symboltable instance.nn    see also symboltable.readfst symboltable.readtext.n    $^static pyobject pyxpw0pywrapfst00symboltable0readpyobject pyxvcls pyobject pyxvfilename $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextread wrapper 0$^  pyxr  pyxpf0pywrapfst00symboltable0readpytypeobjectpyxvcls pyobject pyxvfilename$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00symboltable0readcythonunused pytypeobject pyxvcls pyobject pyxvfilename $^  fstsymboltable pyxvtsyms$^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  stdstring pyxt0$^  int pyxt0$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextread 0$^$^   pywrapfst.pyx000$^      see also symboltable.readfst symboltable.readtext.$^      $^      cdef fst.symboltable tsyms  fst.symboltable.readtostringfilename              $^      if tsyms  null$^        raise fstioerrorread failed r.formatfilename$^ $^  pyxt0  pyxf0pywrapfsttostringpyxvfilename null if unlikelypyerroccurred pyxerr0 000 pyxl0error$^  pyxvtsyms  fstsymboltablereadpyxt0$^$^   pywrapfst.pyx000$^      $^      cdef fst.symboltable tsyms  fst.symboltable.readtostringfilename$^      if tsyms  null              $^        raise fstioerrorread failed r.formatfilename$^      return initsymboltabletsyms$^ $^  pyxt0  pyxvtsyms  null  0$^  if unlikelypyxt0 $^$^     pywrapfst.pyx000$^      cdef fst.symboltable tsyms  fst.symboltable.readtostringfilename$^      if tsyms  null$^        raise fstioerrorread failed r.formatfilename              $^      return initsymboltabletsyms$^  $^ $^    pyxt0  pyxgetmoduleglobalnamepyxnsfstioerror if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  pyxpyobjectgetattrstrpyxkpsreadfailedr pyxnsformat if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  null$^    if cythonunpackmethods  likelypymethodcheckpyxt0 $^      pyxt0  pymethodgetselfpyxt0$^      if likelypyxt0 $^        pyobject function  pymethodgetfunctionpyxt0$^        pyxincrefpyxt0$^        pyxincreffunction$^        pyxdecrefsetpyxt0 function$^      $^    $^    if pyxt0 $^      pyxt0  pyxpyobjectcalloneargpyxt0 pyxvfilename if unlikelypyxt0 pyxerr0 000 pyxl0error$^      pyxgotrefpyxt0$^     else $^      if cythonfastpycall$^      if pyfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxvfilename$^        pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^       else$^      endif$^      if cythonfastpyccall$^      if pyxpyfastcfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxvfilename$^        pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^       else$^      endif$^      $^        pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxgotrefpyxt0$^        pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^        pyxincrefpyxvfilename$^        pyxgiverefpyxvfilename$^        pytuplesetitempyxt0 00 pyxvfilename$^        pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^      $^    $^    pyxdecrefpyxt0 pyxt0  0$^    pyxt0  null$^    if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^      pyxt0  pymethodgetselfpyxt0$^      if likelypyxt0 $^        pyobject function  pymethodgetfunctionpyxt0$^        pyxincrefpyxt0$^        pyxincreffunction$^        pyxdecrefsetpyxt0 function$^      $^    $^    if pyxt0 $^      pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxgotrefpyxt0$^     else $^      if cythonfastpycall$^      if pyfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxt0$^        pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^       else$^      endif$^      if cythonfastpyccall$^      if pyxpyfastcfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxt0$^        pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^       else$^      endif$^      $^        pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxgotrefpyxt0$^        pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^        pyxgiverefpyxt0$^        pytuplesetitempyxt0 00 pyxt0$^        pyxt0  0$^        pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^      $^    $^    pyxdecrefpyxt0 pyxt0  0$^    pyxraisepyxt0 0 0 0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxerr0 000 pyxl0error$^$^     pywrapfst.pyx000$^      $^      cdef fst.symboltable tsyms  fst.symboltable.readtostringfilename$^      if tsyms  null              $^        raise fstioerrorread failed r.formatfilename$^      return initsymboltabletsyms$^ $^  $^$^   pywrapfst.pyx000$^      if tsyms  null$^        raise fstioerrorread failed r.formatfilename$^      return initsymboltabletsyms              $^  $^    classmethod$^ $^  pyxxdecrefpyxr$^  pyxt0  pyobject pyxf0pywrapfstinitsymboltablepyxvtsyms if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   pywrapfst.pyx000$^  $^    classmethod$^    def readcls filename              $^      $^      symboltable.readfilename$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.symboltable.read pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx000$^  $^    classmethod$^    def readtextcls filename bool allownegativelabelsfalse              $^      $^      symboltable.readtextfilename$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00symboltable0readtextpyobject pyxvcls pyobject pyxargs pyobject pyxkwds proto$^static char pyxdoc0pywrapfst00symboltable0readtext  n    symboltable.readtextfilenamenn    reads symbol table from text file.nn    this class method creates a new symboltable from a symbol table text file.nn    argsn      filename the string location of the input text file.n      allownegativelabels should negative labels be allowed notn          recommended may cause conflicts.nn    returnsn      a new symboltable instance.nn    see also symboltable.read symboltable.readfst.n    $^static pyobject pyxpw0pywrapfst00symboltable0readtextpyobject pyxvcls pyobject pyxargs pyobject pyxkwds $^  pyobject pyxvfilename  0$^  bool pyxvallownegativelabels$^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextreadtext wrapper 0$^  $^    static pyobject pyxpyargnames  pyxnsfilenamepyxnsallownegativelabels0$^    pyobject values0  00$^    if unlikelypyxkwds $^      pyssizet kwargs$^      const pyssizet posargs  pytuplegetsizepyxargs$^      switch posargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 break$^        default goto pyxl0argtupleerror$^      $^      kwargs  pydictsizepyxkwds$^      switch posargs $^        case  0$^        if likelyvalues0  pyxpydictgetitemstrpyxkwds pyxnsfilename  0 kwargs$^        else goto pyxl0argtupleerror$^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnsallownegativelabels$^          if value  values0  value kwargs $^        $^      $^      if unlikelykwargs  0 $^        if unlikelypyxparseoptionalkeywordspyxkwds pyxpyargnames 0 values posargs readtext  0 pyxerr0 000 pyxl0error$^      $^     else $^      switch pytuplegetsizepyxargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        break$^        default goto pyxl0argtupleerror$^      $^    $^    pyxvfilename  values0$^    if values0 $^      pyxvallownegativelabels  pyxpyobjectistruevalues0 if unlikelypyxvallownegativelabels  bool0  pyerroccurred pyxerr0 000 pyxl0error$^     else $^      pyxvallownegativelabels  bool0$^    $^  $^  goto pyxl0argumentunpackingdone$^  pyxl0argtupleerror$^  pyxraiseargtupleinvalidreadtext 0 0 0 pytuplegetsizepyxargs pyxerr0 000 pyxl0error$^  pyxl0error$^  pyxaddtracebackpywrapfst.symboltable.readtext pyxclineno pyxlineno pyxfilename$^  pyxrefnannyfinishcontext$^  return null$^  pyxl0argumentunpackingdone$^  pyxr  pyxpf0pywrapfst00symboltable0readtextpytypeobjectpyxvcls pyxvfilename pyxvallownegativelabels$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00symboltable0readtextcythonunused pytypeobject pyxvcls pyobject pyxvfilename bool pyxvallownegativelabels $^  stduniqueptrfstsymboltabletextoptions  pyxvopts$^  fstsymboltable pyxvtsyms$^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  stdstring pyxt0$^  int pyxt0$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextreadtext 0$^$^   pywrapfst.pyx0000$^      $^      cdef uniqueptrfst.symboltabletextoptions opts$^      opts.resetnew fst.symboltabletextoptionsallownegativelabels              $^      cdef fst.symboltable tsyms  fst.symboltable.readtexttostringfilename$^                                                             derefopts$^ $^  pyxvopts.resetnew fstsymboltabletextoptionspyxvallownegativelabels$^$^   pywrapfst.pyx0000$^      cdef uniqueptrfst.symboltabletextoptions opts$^      opts.resetnew fst.symboltabletextoptionsallownegativelabels$^      cdef fst.symboltable tsyms  fst.symboltable.readtexttostringfilename              $^                                                             derefopts$^      if tsyms  null$^ $^  pyxt0  pyxf0pywrapfsttostringpyxvfilename null if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^      opts.resetnew fst.symboltabletextoptionsallownegativelabels$^      cdef fst.symboltable tsyms  fst.symboltable.readtexttostringfilename$^                                                             derefopts              $^      if tsyms  null$^        raise fstioerrorread failed r.formatfilename$^ $^  pyxvtsyms  fstsymboltablereadtextpyxt0 pyxvopts$^$^   pywrapfst.pyx0000$^      cdef fst.symboltable tsyms  fst.symboltable.readtexttostringfilename$^                                                             derefopts$^      if tsyms  null              $^        raise fstioerrorread failed r.formatfilename$^      return initsymboltabletsyms$^ $^  pyxt0  pyxvtsyms  null  0$^  if unlikelypyxt0 $^$^     pywrapfst.pyx0000$^                                                             derefopts$^      if tsyms  null$^        raise fstioerrorread failed r.formatfilename              $^      return initsymboltabletsyms$^  $^ $^    pyxt0  pyxgetmoduleglobalnamepyxnsfstioerror if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  pyxpyobjectgetattrstrpyxkpsreadfailedr pyxnsformat if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  null$^    if cythonunpackmethods  likelypymethodcheckpyxt0 $^      pyxt0  pymethodgetselfpyxt0$^      if likelypyxt0 $^        pyobject function  pymethodgetfunctionpyxt0$^        pyxincrefpyxt0$^        pyxincreffunction$^        pyxdecrefsetpyxt0 function$^      $^    $^    if pyxt0 $^      pyxt0  pyxpyobjectcalloneargpyxt0 pyxvfilename if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxgotrefpyxt0$^     else $^      if cythonfastpycall$^      if pyfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxvfilename$^        pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^       else$^      endif$^      if cythonfastpyccall$^      if pyxpyfastcfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxvfilename$^        pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^       else$^      endif$^      $^        pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxgotrefpyxt0$^        pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^        pyxincrefpyxvfilename$^        pyxgiverefpyxvfilename$^        pytuplesetitempyxt0 00 pyxvfilename$^        pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^      $^    $^    pyxdecrefpyxt0 pyxt0  0$^    pyxt0  null$^    if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^      pyxt0  pymethodgetselfpyxt0$^      if likelypyxt0 $^        pyobject function  pymethodgetfunctionpyxt0$^        pyxincrefpyxt0$^        pyxincreffunction$^        pyxdecrefsetpyxt0 function$^      $^    $^    if pyxt0 $^      pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxgotrefpyxt0$^     else $^      if cythonfastpycall$^      if pyfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxt0$^        pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^       else$^      endif$^      if cythonfastpyccall$^      if pyxpyfastcfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxt0$^        pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^       else$^      endif$^      $^        pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxgotrefpyxt0$^        pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^        pyxgiverefpyxt0$^        pytuplesetitempyxt0 00 pyxt0$^        pyxt0  0$^        pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^      $^    $^    pyxdecrefpyxt0 pyxt0  0$^    pyxraisepyxt0 0 0 0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxerr0 0000 pyxl0error$^$^     pywrapfst.pyx0000$^      cdef fst.symboltable tsyms  fst.symboltable.readtexttostringfilename$^                                                             derefopts$^      if tsyms  null              $^        raise fstioerrorread failed r.formatfilename$^      return initsymboltabletsyms$^ $^  $^$^   pywrapfst.pyx0000$^      if tsyms  null$^        raise fstioerrorread failed r.formatfilename$^      return initsymboltabletsyms              $^  $^    classmethod$^ $^  pyxxdecrefpyxr$^  pyxt0  pyobject pyxf0pywrapfstinitsymboltablepyxvtsyms if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   pywrapfst.pyx000$^  $^    classmethod$^    def readtextcls filename bool allownegativelabelsfalse              $^      $^      symboltable.readtextfilename$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.symboltable.readtext pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^  $^    classmethod$^    def readfstcls filename bool inputtable              $^      $^      symboltable.readfstfilename inputtable$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00symboltable0readfstpyobject pyxvcls pyobject pyxargs pyobject pyxkwds proto$^static char pyxdoc0pywrapfst00symboltable0readfst  n    symboltable.readfstfilename inputtablenn    reads symbol table from an fst file without loading the corresponding fst.nn    this class method creates a new symboltable by reading either the input orn    output symbol table from an fst file without loading the corresponding fst.nn    argsn      filename the string location of the input fst file.n      inputtable should the input table be read true or the output tablen          falsenn    returnsn      a new symboltable instance or none if none can be read.nn    raisesn      fstioerror read failed.nn    see also symboltable.read symboltable.readtext.n    $^static pyobject pyxpw0pywrapfst00symboltable0readfstpyobject pyxvcls pyobject pyxargs pyobject pyxkwds $^  pyobject pyxvfilename  0$^  bool pyxvinputtable$^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextreadfst wrapper 0$^  $^    static pyobject pyxpyargnames  pyxnsfilenamepyxnsinputtable0$^    pyobject values0  00$^    if unlikelypyxkwds $^      pyssizet kwargs$^      const pyssizet posargs  pytuplegetsizepyxargs$^      switch posargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 break$^        default goto pyxl0argtupleerror$^      $^      kwargs  pydictsizepyxkwds$^      switch posargs $^        case  0$^        if likelyvalues0  pyxpydictgetitemstrpyxkwds pyxnsfilename  0 kwargs$^        else goto pyxl0argtupleerror$^        cythonfallthrough$^        case  0$^        if likelyvalues0  pyxpydictgetitemstrpyxkwds pyxnsinputtable  0 kwargs$^        else $^          pyxraiseargtupleinvalidreadfst 0 0 0 0 pyxerr0 0000 pyxl0error$^        $^      $^      if unlikelykwargs  0 $^        if unlikelypyxparseoptionalkeywordspyxkwds pyxpyargnames 0 values posargs readfst  0 pyxerr0 0000 pyxl0error$^      $^     else if pytuplegetsizepyxargs  0 $^      goto pyxl0argtupleerror$^     else $^      values0  pytuplegetitempyxargs 0$^      values0  pytuplegetitempyxargs 0$^    $^    pyxvfilename  values0$^    pyxvinputtable  pyxpyobjectistruevalues0 if unlikelypyxvinputtable  bool0  pyerroccurred pyxerr0 0000 pyxl0error$^  $^  goto pyxl0argumentunpackingdone$^  pyxl0argtupleerror$^  pyxraiseargtupleinvalidreadfst 0 0 0 pytuplegetsizepyxargs pyxerr0 0000 pyxl0error$^  pyxl0error$^  pyxaddtracebackpywrapfst.symboltable.readfst pyxclineno pyxlineno pyxfilename$^  pyxrefnannyfinishcontext$^  return null$^  pyxl0argumentunpackingdone$^  pyxr  pyxpf0pywrapfst00symboltable0readfstpytypeobjectpyxvcls pyxvfilename pyxvinputtable$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00symboltable0readfstcythonunused pytypeobject pyxvcls pyobject pyxvfilename bool pyxvinputtable $^  fstsymboltable pyxvtsyms$^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  stdstring pyxt0$^  int pyxt0$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextreadfst 0$^$^   pywrapfst.pyx0000$^      see also symboltable.read symboltable.readtext.$^      $^      cdef fst.symboltable tsyms  fst.fstreadsymbolsfilename inputtable              $^      if tsyms  null$^        raise fstioerrorread failed r.formatfilename$^ $^  pyxt0  pyxconvertstringfrompystdinstringpyxvfilename if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^  pyxvtsyms  fstfstreadsymbolspyxt0 pyxvinputtable$^$^   pywrapfst.pyx0000$^      $^      cdef fst.symboltable tsyms  fst.fstreadsymbolsfilename inputtable$^      if tsyms  null              $^        raise fstioerrorread failed r.formatfilename$^      return initsymboltabletsyms$^ $^  pyxt0  pyxvtsyms  null  0$^  if unlikelypyxt0 $^$^     pywrapfst.pyx0000$^      cdef fst.symboltable tsyms  fst.fstreadsymbolsfilename inputtable$^      if tsyms  null$^        raise fstioerrorread failed r.formatfilename              $^      return initsymboltabletsyms$^  $^ $^    pyxt0  pyxgetmoduleglobalnamepyxnsfstioerror if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  pyxpyobjectgetattrstrpyxkpsreadfailedr pyxnsformat if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  null$^    if cythonunpackmethods  likelypymethodcheckpyxt0 $^      pyxt0  pymethodgetselfpyxt0$^      if likelypyxt0 $^        pyobject function  pymethodgetfunctionpyxt0$^        pyxincrefpyxt0$^        pyxincreffunction$^        pyxdecrefsetpyxt0 function$^      $^    $^    if pyxt0 $^      pyxt0  pyxpyobjectcalloneargpyxt0 pyxvfilename if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxgotrefpyxt0$^     else $^      if cythonfastpycall$^      if pyfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxvfilename$^        pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^       else$^      endif$^      if cythonfastpyccall$^      if pyxpyfastcfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxvfilename$^        pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^       else$^      endif$^      $^        pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxgotrefpyxt0$^        pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^        pyxincrefpyxvfilename$^        pyxgiverefpyxvfilename$^        pytuplesetitempyxt0 00 pyxvfilename$^        pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^      $^    $^    pyxdecrefpyxt0 pyxt0  0$^    pyxt0  null$^    if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^      pyxt0  pymethodgetselfpyxt0$^      if likelypyxt0 $^        pyobject function  pymethodgetfunctionpyxt0$^        pyxincrefpyxt0$^        pyxincreffunction$^        pyxdecrefsetpyxt0 function$^      $^    $^    if pyxt0 $^      pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxgotrefpyxt0$^     else $^      if cythonfastpycall$^      if pyfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxt0$^        pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^       else$^      endif$^      if cythonfastpyccall$^      if pyxpyfastcfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxt0$^        pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^       else$^      endif$^      $^        pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxgotrefpyxt0$^        pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^        pyxgiverefpyxt0$^        pytuplesetitempyxt0 00 pyxt0$^        pyxt0  0$^        pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^      $^    $^    pyxdecrefpyxt0 pyxt0  0$^    pyxraisepyxt0 0 0 0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxerr0 0000 pyxl0error$^$^     pywrapfst.pyx0000$^      $^      cdef fst.symboltable tsyms  fst.fstreadsymbolsfilename inputtable$^      if tsyms  null              $^        raise fstioerrorread failed r.formatfilename$^      return initsymboltabletsyms$^ $^  $^$^   pywrapfst.pyx0000$^      if tsyms  null$^        raise fstioerrorread failed r.formatfilename$^      return initsymboltabletsyms              $^  $^  $^ $^  pyxxdecrefpyxr$^  pyxt0  pyobject pyxf0pywrapfstinitsymboltablepyxvtsyms if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   pywrapfst.pyx0000$^  $^    classmethod$^    def readfstcls filename bool inputtable              $^      $^      symboltable.readfstfilename inputtable$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.symboltable.readfst pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ tree fragment0$^  def reducecythonself              $^      raise typeerrorself.smarttableself.table cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00symboltable00reducecythonpyobject pyxvself cythonunused pyobject unused proto$^static pyobject pyxpw0pywrapfst00symboltable00reducecythonpyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextreducecython wrapper 0$^  pyxr  pyxpf0pywrapfst00symboltable00reducecythonstruct pyxobj0pywrapfstsymboltable pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00symboltable00reducecythoncythonunused struct pyxobj0pywrapfstsymboltable pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextreducecython 0$^$^   tree fragment0$^  def reducecythonself$^      raise typeerrorself.smarttableself.table cannot be converted to a python object for pickling              $^  def setstatecythonself pyxstate$^      raise typeerrorself.smarttableself.table cannot be converted to a python object for pickling$^ $^  pyxt0  pyxpyobjectcallpyxbuiltintypeerror pyxtuple00 null if unlikelypyxt0 pyxerr0 0 pyxl0error$^  pyxgotrefpyxt0$^  pyxraisepyxt0 0 0 0$^  pyxdecrefpyxt0 pyxt0  0$^  pyxerr0 0 pyxl0error$^$^   tree fragment0$^  def reducecythonself              $^      raise typeerrorself.smarttableself.table cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.symboltable.reducecython pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ tree fragment0$^  def reducecythonself$^      raise typeerrorself.smarttableself.table cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate              $^      raise typeerrorself.smarttableself.table cannot be converted to a python object for pickling$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00symboltable00setstatecythonpyobject pyxvself pyobject pyxvpyxstate proto$^static pyobject pyxpw0pywrapfst00symboltable00setstatecythonpyobject pyxvself pyobject pyxvpyxstate $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextsetstatecython wrapper 0$^  pyxr  pyxpf0pywrapfst00symboltable00setstatecythonstruct pyxobj0pywrapfstsymboltable pyxvself pyobject pyxvpyxstate$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00symboltable00setstatecythoncythonunused struct pyxobj0pywrapfstsymboltable pyxvself cythonunused pyobject pyxvpyxstate $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextsetstatecython 0$^$^   tree fragment0$^      raise typeerrorself.smarttableself.table cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate$^      raise typeerrorself.smarttableself.table cannot be converted to a python object for pickling              $^ $^  pyxt0  pyxpyobjectcallpyxbuiltintypeerror pyxtuple00 null if unlikelypyxt0 pyxerr0 0 pyxl0error$^  pyxgotrefpyxt0$^  pyxraisepyxt0 0 0 0$^  pyxdecrefpyxt0 pyxt0  0$^  pyxerr0 0 pyxl0error$^$^   tree fragment0$^  def reducecythonself$^      raise typeerrorself.smarttableself.table cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate              $^      raise typeerrorself.smarttableself.table cannot be converted to a python object for pickling$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.symboltable.setstatecython pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^  $^  $^  cdef encodemappersymboltable initencodemappersymboltable              $^      fst.symboltable table sharedptrfst.encodemapperclass encoder$^    cdef encodemappersymboltable result  $^ $^$^static struct pyxobj0pywrapfstencodemappersymboltable pyxf0pywrapfstinitencodemappersymboltablefstsymboltable pyxvtable stdsharedptrfstscriptencodemapperclass  pyxvencoder $^  struct pyxobj0pywrapfstencodemappersymboltable pyxvresult  0$^  struct pyxobj0pywrapfstencodemappersymboltable pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextinitencodemappersymboltable 0$^$^   pywrapfst.pyx0000$^      fst.symboltable table sharedptrfst.encodemapperclass encoder$^    cdef encodemappersymboltable result  $^        encodemappersymboltable.newencodemappersymboltable              $^    result.table  table$^    result.encoder  encoder$^ $^  pyxt0  pyobject pyxtpnew0pywrapfstencodemappersymboltablepytypeobject pyxptype0pywrapfstencodemappersymboltable pyxemptytuple null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyobject pyxt0$^  pyxvresult  struct pyxobj0pywrapfstencodemappersymboltable pyxt0$^  pyxt0  0$^$^   pywrapfst.pyx0000$^    cdef encodemappersymboltable result  $^        encodemappersymboltable.newencodemappersymboltable$^    result.table  table              $^    result.encoder  encoder$^    return result$^ $^  if unlikelypyobject pyxvresult  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s table$^    pyxerr0 0000 pyxl0error$^  $^  pyxvresultpyxbase.table  pyxvtable$^$^   pywrapfst.pyx0000$^        encodemappersymboltable.newencodemappersymboltable$^    result.table  table$^    result.encoder  encoder              $^    return result$^  $^ $^  if unlikelypyobject pyxvresult  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s encoder$^    pyxerr0 0000 pyxl0error$^  $^  pyxvresultencoder  pyxvencoder$^$^   pywrapfst.pyx0000$^    result.table  table$^    result.encoder  encoder$^    return result              $^  $^  $^ $^  pyxxdecrefpyobject pyxr$^  pyxincrefpyobject pyxvresult$^  pyxr  pyxvresult$^  goto pyxl0$^$^   pywrapfst.pyx0000$^  $^  $^  cdef encodemappersymboltable initencodemappersymboltable              $^      fst.symboltable table sharedptrfst.encodemapperclass encoder$^    cdef encodemappersymboltable result  $^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.initencodemappersymboltable pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxl0$^  pyxxdecrefpyobject pyxvresult$^  pyxxgiverefpyobject pyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^  $^  $^  cdef fstsymboltable initfstsymboltablefst.symboltable table              $^                                            sharedptrfst.fstclass ifst$^    cdef fstsymboltable result  fstsymboltable.newfstsymboltable$^ $^$^static struct pyxobj0pywrapfstfstsymboltable pyxf0pywrapfstinitfstsymboltablefstsymboltable pyxvtable stdsharedptrfstscriptfstclass  pyxvifst $^  struct pyxobj0pywrapfstfstsymboltable pyxvresult  0$^  struct pyxobj0pywrapfstfstsymboltable pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextinitfstsymboltable 0$^$^   pywrapfst.pyx0000$^  cdef fstsymboltable initfstsymboltablefst.symboltable table$^                                            sharedptrfst.fstclass ifst$^    cdef fstsymboltable result  fstsymboltable.newfstsymboltable              $^    result.table  table$^    result.fst  ifst$^ $^  pyxt0  pyobject pyxtpnew0pywrapfstfstsymboltablepytypeobject pyxptype0pywrapfstfstsymboltable pyxemptytuple null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyobject pyxt0$^  pyxvresult  struct pyxobj0pywrapfstfstsymboltable pyxt0$^  pyxt0  0$^$^   pywrapfst.pyx0000$^                                            sharedptrfst.fstclass ifst$^    cdef fstsymboltable result  fstsymboltable.newfstsymboltable$^    result.table  table              $^    result.fst  ifst$^    return result$^ $^  if unlikelypyobject pyxvresult  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s table$^    pyxerr0 0000 pyxl0error$^  $^  pyxvresultpyxbase.table  pyxvtable$^$^   pywrapfst.pyx0000$^    cdef fstsymboltable result  fstsymboltable.newfstsymboltable$^    result.table  table$^    result.fst  ifst              $^    return result$^  $^ $^  if unlikelypyobject pyxvresult  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s fst$^    pyxerr0 0000 pyxl0error$^  $^  pyxvresultfst  pyxvifst$^$^   pywrapfst.pyx0000$^    result.table  table$^    result.fst  ifst$^    return result              $^  $^  $^ $^  pyxxdecrefpyobject pyxr$^  pyxincrefpyobject pyxvresult$^  pyxr  pyxvresult$^  goto pyxl0$^$^   pywrapfst.pyx0000$^  $^  $^  cdef fstsymboltable initfstsymboltablefst.symboltable table              $^                                            sharedptrfst.fstclass ifst$^    cdef fstsymboltable result  fstsymboltable.newfstsymboltable$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.initfstsymboltable pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxl0$^  pyxxdecrefpyobject pyxvresult$^  pyxxgiverefpyobject pyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^  $^  $^  cdef mutablefstsymboltable initmutablefstsymboltablefst.symboltable table              $^      sharedptrfst.mutablefstclass ifst$^    cdef mutablefstsymboltable result  $^ $^$^static struct pyxobj0pywrapfstmutablefstsymboltable pyxf0pywrapfstinitmutablefstsymboltablefstsymboltable pyxvtable stdsharedptrfstscriptmutablefstclass  pyxvifst $^  struct pyxobj0pywrapfstmutablefstsymboltable pyxvresult  0$^  struct pyxobj0pywrapfstmutablefstsymboltable pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextinitmutablefstsymboltable 0$^$^   pywrapfst.pyx0000$^      sharedptrfst.mutablefstclass ifst$^    cdef mutablefstsymboltable result  $^        mutablefstsymboltable.newmutablefstsymboltable              $^    result.table  table$^    result.mfst  ifst$^ $^  pyxt0  pyobject pyxtpnew0pywrapfstmutablefstsymboltablepytypeobject pyxptype0pywrapfstmutablefstsymboltable pyxemptytuple null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyobject pyxt0$^  pyxvresult  struct pyxobj0pywrapfstmutablefstsymboltable pyxt0$^  pyxt0  0$^$^   pywrapfst.pyx0000$^    cdef mutablefstsymboltable result  $^        mutablefstsymboltable.newmutablefstsymboltable$^    result.table  table              $^    result.mfst  ifst$^    return result$^ $^  if unlikelypyobject pyxvresult  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s table$^    pyxerr0 0000 pyxl0error$^  $^  pyxvresultpyxbase.pyxbase.table  pyxvtable$^$^   pywrapfst.pyx0000$^        mutablefstsymboltable.newmutablefstsymboltable$^    result.table  table$^    result.mfst  ifst              $^    return result$^  $^ $^  if unlikelypyobject pyxvresult  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s mfst$^    pyxerr0 0000 pyxl0error$^  $^  pyxvresultmfst  pyxvifst$^$^   pywrapfst.pyx0000$^    result.table  table$^    result.mfst  ifst$^    return result              $^  $^  $^ $^  pyxxdecrefpyobject pyxr$^  pyxincrefpyobject pyxvresult$^  pyxr  pyxvresult$^  goto pyxl0$^$^   pywrapfst.pyx0000$^  $^  $^  cdef mutablefstsymboltable initmutablefstsymboltablefst.symboltable table              $^      sharedptrfst.mutablefstclass ifst$^    cdef mutablefstsymboltable result  $^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.initmutablefstsymboltable pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxl0$^  pyxxdecrefpyobject pyxvresult$^  pyxxgiverefpyobject pyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^  $^  $^  cdef symboltable initsymboltablefst.symboltable table              $^    cdef symboltable result  symboltable.newsymboltable$^    result.table  table$^ $^$^static struct pyxobj0pywrapfstsymboltable pyxf0pywrapfstinitsymboltablefstsymboltable pyxvtable $^  struct pyxobj0pywrapfstsymboltable pyxvresult  0$^  struct pyxobj0pywrapfstsymboltable pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextinitsymboltable 0$^$^   pywrapfst.pyx0000$^  $^  cdef symboltable initsymboltablefst.symboltable table$^    cdef symboltable result  symboltable.newsymboltable              $^    result.table  table$^    return result$^ $^  pyxt0  pyobject pyxtpnew0pywrapfstsymboltablepytypeobject pyxptype0pywrapfstsymboltable pyxemptytuple null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyobject pyxt0$^  pyxvresult  struct pyxobj0pywrapfstsymboltable pyxt0$^  pyxt0  0$^$^   pywrapfst.pyx0000$^  cdef symboltable initsymboltablefst.symboltable table$^    cdef symboltable result  symboltable.newsymboltable$^    result.table  table              $^    return result$^  $^ $^  if unlikelypyobject pyxvresult  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s table$^    pyxerr0 0000 pyxl0error$^  $^  pyxvresultpyxbase.pyxbase.table  pyxvtable$^$^   pywrapfst.pyx0000$^    cdef symboltable result  symboltable.newsymboltable$^    result.table  table$^    return result              $^  $^  $^ $^  pyxxdecrefpyobject pyxr$^  pyxincrefpyobject pyxvresult$^  pyxr  pyxvresult$^  goto pyxl0$^$^   pywrapfst.pyx0000$^  $^  $^  cdef symboltable initsymboltablefst.symboltable table              $^    cdef symboltable result  symboltable.newsymboltable$^    result.table  table$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.initsymboltable pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxl0$^  pyxxdecrefpyobject pyxvresult$^  pyxxgiverefpyobject pyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^  $^  $^  cpdef symboltable compactsymboltablesymboltable syms              $^    $^    compactsymboltablesyms$^ $^$^static pyobject pyxpw0pywrapfst0compactsymboltablepyobject pyxself pyobject pyxvsyms proto$^static struct pyxobj0pywrapfstsymboltable pyxf0pywrapfstcompactsymboltablestruct pyxobj0pywrapfstsymboltable pyxvsyms cythonunused int pyxskipdispatch $^  struct pyxobj0pywrapfstsymboltable pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextcompactsymboltable 0$^$^   pywrapfst.pyx0000$^      a new compacted symboltable.$^    $^    return initsymboltablefst.compactsymboltablederefsyms.table              $^  $^  $^ $^  pyxxdecrefpyobject pyxr$^  if unlikelypyobject pyxvsyms  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s table$^    pyxerr0 0000 pyxl0error$^  $^  pyxt0  pyobject pyxf0pywrapfstinitsymboltablefstcompactsymboltablepyxvsymstable if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  struct pyxobj0pywrapfstsymboltable pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   pywrapfst.pyx0000$^  $^  $^  cpdef symboltable compactsymboltablesymboltable syms              $^    $^    compactsymboltablesyms$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.compactsymboltable pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxl0$^  pyxxgiverefpyobject pyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst0compactsymboltablepyobject pyxself pyobject pyxvsyms proto$^static char pyxdoc0pywrapfst0compactsymboltable  n  compactsymboltablesymsnn  constructively relabels a symboltable to make it a contiguous mapping.nn  argsn    syms input symboltable.nn  returnsn    a new compacted symboltable.n  $^static pyobject pyxpw0pywrapfst0compactsymboltablepyobject pyxself pyobject pyxvsyms $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextcompactsymboltable wrapper 0$^  if unlikelypyxargtypetestpyobject pyxvsyms pyxptype0pywrapfstsymboltable 0 syms 0 pyxerr0 0000 pyxl0error$^  pyxr  pyxpf0pywrapfst0compactsymboltablepyxself struct pyxobj0pywrapfstsymboltable pyxvsyms$^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxr  null$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst0compactsymboltablecythonunused pyobject pyxself struct pyxobj0pywrapfstsymboltable pyxvsyms $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextcompactsymboltable 0$^  pyxxdecrefpyxr$^  pyxt0  pyobject pyxf0pywrapfstcompactsymboltablepyxvsyms 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.compactsymboltable pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^  $^  $^  cpdef symboltable mergesymboltablesymboltable lhs symboltable rhs              $^    $^    mergesymboltablelhs rhs$^ $^$^static pyobject pyxpw0pywrapfst00mergesymboltablepyobject pyxself pyobject pyxargs pyobject pyxkwds proto$^static struct pyxobj0pywrapfstsymboltable pyxf0pywrapfstmergesymboltablestruct pyxobj0pywrapfstsymboltable pyxvlhs struct pyxobj0pywrapfstsymboltable pyxvrhs cythonunused int pyxskipdispatch $^  struct pyxobj0pywrapfstsymboltable pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextmergesymboltable 0$^$^   pywrapfst.pyx0000$^    see also relabelsymbols.$^    $^    return initsymboltablefst.mergesymboltabledereflhs.table              $^                                                  derefrhs.table null$^  $^ $^  pyxxdecrefpyobject pyxr$^  if unlikelypyobject pyxvlhs  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s table$^    pyxerr0 0000 pyxl0error$^  $^$^   pywrapfst.pyx0000$^    $^    return initsymboltablefst.mergesymboltabledereflhs.table$^                                                  derefrhs.table null              $^  $^  $^ $^  if unlikelypyobject pyxvrhs  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s table$^    pyxerr0 0000 pyxl0error$^  $^$^   pywrapfst.pyx0000$^    see also relabelsymbols.$^    $^    return initsymboltablefst.mergesymboltabledereflhs.table              $^                                                  derefrhs.table null$^  $^ $^  pyxt0  pyobject pyxf0pywrapfstinitsymboltablefstmergesymboltablepyxvlhstable pyxvrhstable null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  struct pyxobj0pywrapfstsymboltable pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   pywrapfst.pyx0000$^  $^  $^  cpdef symboltable mergesymboltablesymboltable lhs symboltable rhs              $^    $^    mergesymboltablelhs rhs$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.mergesymboltable pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxl0$^  pyxxgiverefpyobject pyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst00mergesymboltablepyobject pyxself pyobject pyxargs pyobject pyxkwds proto$^static char pyxdoc0pywrapfst00mergesymboltable  n  mergesymboltablelhs rhsnn  merges all symbols from the left table into the right.nn  this function creates a new symboltable which is the merger of the two inputn  symbol tables. symbols in the righthand table that conflict with those in then  lefthand table will be assigned values from the lefthand table. thus then  returned table will never modify symbol assignments from the lefthand siden  but may do so on the right.nn  if the lefthand table is associated with an fst it may be necessary ton  relabel it using the output table.nn  argsn    lhs lefthand side symboltable.n    rhs lefthand side symboltable.nn  returnsn    a new merged symboltable.nn  see also relabelsymbols.n  $^static pyobject pyxpw0pywrapfst00mergesymboltablepyobject pyxself pyobject pyxargs pyobject pyxkwds $^  struct pyxobj0pywrapfstsymboltable pyxvlhs  0$^  struct pyxobj0pywrapfstsymboltable pyxvrhs  0$^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextmergesymboltable wrapper 0$^  $^    static pyobject pyxpyargnames  pyxnslhspyxnsrhs0$^    pyobject values0  00$^    if unlikelypyxkwds $^      pyssizet kwargs$^      const pyssizet posargs  pytuplegetsizepyxargs$^      switch posargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 break$^        default goto pyxl0argtupleerror$^      $^      kwargs  pydictsizepyxkwds$^      switch posargs $^        case  0$^        if likelyvalues0  pyxpydictgetitemstrpyxkwds pyxnslhs  0 kwargs$^        else goto pyxl0argtupleerror$^        cythonfallthrough$^        case  0$^        if likelyvalues0  pyxpydictgetitemstrpyxkwds pyxnsrhs  0 kwargs$^        else $^          pyxraiseargtupleinvalidmergesymboltable 0 0 0 0 pyxerr0 0000 pyxl0error$^        $^      $^      if unlikelykwargs  0 $^        if unlikelypyxparseoptionalkeywordspyxkwds pyxpyargnames 0 values posargs mergesymboltable  0 pyxerr0 0000 pyxl0error$^      $^     else if pytuplegetsizepyxargs  0 $^      goto pyxl0argtupleerror$^     else $^      values0  pytuplegetitempyxargs 0$^      values0  pytuplegetitempyxargs 0$^    $^    pyxvlhs  struct pyxobj0pywrapfstsymboltable values0$^    pyxvrhs  struct pyxobj0pywrapfstsymboltable values0$^  $^  goto pyxl0argumentunpackingdone$^  pyxl0argtupleerror$^  pyxraiseargtupleinvalidmergesymboltable 0 0 0 pytuplegetsizepyxargs pyxerr0 0000 pyxl0error$^  pyxl0error$^  pyxaddtracebackpywrapfst.mergesymboltable pyxclineno pyxlineno pyxfilename$^  pyxrefnannyfinishcontext$^  return null$^  pyxl0argumentunpackingdone$^  if unlikelypyxargtypetestpyobject pyxvlhs pyxptype0pywrapfstsymboltable 0 lhs 0 pyxerr0 0000 pyxl0error$^  if unlikelypyxargtypetestpyobject pyxvrhs pyxptype0pywrapfstsymboltable 0 rhs 0 pyxerr0 0000 pyxl0error$^  pyxr  pyxpf0pywrapfst00mergesymboltablepyxself pyxvlhs pyxvrhs$^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxr  null$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00mergesymboltablecythonunused pyobject pyxself struct pyxobj0pywrapfstsymboltable pyxvlhs struct pyxobj0pywrapfstsymboltable pyxvrhs $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextmergesymboltable 0$^  pyxxdecrefpyxr$^  pyxt0  pyobject pyxf0pywrapfstmergesymboltablepyxvlhs pyxvrhs 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.mergesymboltable pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^    $^  $^    def reprself              $^      return symboltableiterator at 0xx.formatidself$^  $^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00symboltableiterator0reprpyobject pyxvself proto$^static pyobject pyxpw0pywrapfst00symboltableiterator0reprpyobject pyxvself $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextrepr wrapper 0$^  pyxr  pyxpf0pywrapfst00symboltableiteratorreprstruct pyxobj0pywrapfstsymboltableiterator pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00symboltableiteratorreprstruct pyxobj0pywrapfstsymboltableiterator pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextrepr 0$^$^   pywrapfst.pyx0000$^  $^    def reprself$^      return symboltableiterator at 0xx.formatidself              $^  $^    def initself symboltable syms$^ $^  pyxxdecrefpyxr$^  pyxt0  pyxpyobjectgetattrstrpyxkpssymboltableiteratorat0xx pyxnsformat if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxt0  pyxpyobjectcalloneargpyxbuiltinid pyobject pyxvself if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxt0  null$^  if cythonunpackmethods  likelypymethodcheckpyxt0 $^    pyxt0  pymethodgetselfpyxt0$^    if likelypyxt0 $^      pyobject function  pymethodgetfunctionpyxt0$^      pyxincrefpyxt0$^      pyxincreffunction$^      pyxdecrefsetpyxt0 function$^    $^  $^  if pyxt0 $^    pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxdecrefpyxt0 pyxt0  0$^    pyxgotrefpyxt0$^   else $^    if cythonfastpycall$^    if pyfunctioncheckpyxt0 $^      pyobject pyxtemp0  pyxt0 pyxt0$^      pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxxdecrefpyxt0 pyxt0  0$^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^     else$^    endif$^    if cythonfastpyccall$^    if pyxpyfastcfunctioncheckpyxt0 $^      pyobject pyxtemp0  pyxt0 pyxt0$^      pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxxdecrefpyxt0 pyxt0  0$^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^     else$^    endif$^    $^      pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxgotrefpyxt0$^      pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^      pyxgiverefpyxt0$^      pytuplesetitempyxt0 00 pyxt0$^      pyxt0  0$^      pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^    $^  $^  pyxdecrefpyxt0 pyxt0  0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   pywrapfst.pyx0000$^    $^  $^    def reprself              $^      return symboltableiterator at 0xx.formatidself$^  $^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.symboltableiterator.repr pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return symboltableiterator at 0xx.formatidself$^  $^    def initself symboltable syms              $^      self.siter.resetnew fst.symboltableiteratorderefsyms.table$^  $^ $^$^ python wrapper $^static int pyxpw0pywrapfst00symboltableiterator0initpyobject pyxvself pyobject pyxargs pyobject pyxkwds proto$^static int pyxpw0pywrapfst00symboltableiterator0initpyobject pyxvself pyobject pyxargs pyobject pyxkwds $^  struct pyxobj0pywrapfstsymboltable pyxvsyms  0$^  int pyxr$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextinit wrapper 0$^  $^    static pyobject pyxpyargnames  pyxnssyms0$^    pyobject values0  0$^    if unlikelypyxkwds $^      pyssizet kwargs$^      const pyssizet posargs  pytuplegetsizepyxargs$^      switch posargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 break$^        default goto pyxl0argtupleerror$^      $^      kwargs  pydictsizepyxkwds$^      switch posargs $^        case  0$^        if likelyvalues0  pyxpydictgetitemstrpyxkwds pyxnssyms  0 kwargs$^        else goto pyxl0argtupleerror$^      $^      if unlikelykwargs  0 $^        if unlikelypyxparseoptionalkeywordspyxkwds pyxpyargnames 0 values posargs init  0 pyxerr0 0000 pyxl0error$^      $^     else if pytuplegetsizepyxargs  0 $^      goto pyxl0argtupleerror$^     else $^      values0  pytuplegetitempyxargs 0$^    $^    pyxvsyms  struct pyxobj0pywrapfstsymboltable values0$^  $^  goto pyxl0argumentunpackingdone$^  pyxl0argtupleerror$^  pyxraiseargtupleinvalidinit 0 0 0 pytuplegetsizepyxargs pyxerr0 0000 pyxl0error$^  pyxl0error$^  pyxaddtracebackpywrapfst.symboltableiterator.init pyxclineno pyxlineno pyxfilename$^  pyxrefnannyfinishcontext$^  return 0$^  pyxl0argumentunpackingdone$^  if unlikelypyxargtypetestpyobject pyxvsyms pyxptype0pywrapfstsymboltable 0 syms 0 pyxerr0 0000 pyxl0error$^  pyxr  pyxpf0pywrapfst00symboltableiterator0initstruct pyxobj0pywrapfstsymboltableiterator pyxvself pyxvsyms$^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxr  0$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static int pyxpf0pywrapfst00symboltableiterator0initstruct pyxobj0pywrapfstsymboltableiterator pyxvself struct pyxobj0pywrapfstsymboltable pyxvsyms $^  int pyxr$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextinit 0$^$^   pywrapfst.pyx0000$^  $^    def initself symboltable syms$^      self.siter.resetnew fst.symboltableiteratorderefsyms.table              $^  $^     this just registers this class as a possible iterator.$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s siter$^    pyxerr0 0000 pyxl0error$^  $^  if unlikelypyobject pyxvsyms  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s table$^    pyxerr0 0000 pyxl0error$^  $^  pyxvselfsiter.resetnew fstsymboltableiteratorpyxvsymstable$^$^   pywrapfst.pyx0000$^      return symboltableiterator at 0xx.formatidself$^  $^    def initself symboltable syms              $^      self.siter.resetnew fst.symboltableiteratorderefsyms.table$^  $^ $^$^   function exit code $^  pyxr  0$^  goto pyxl0$^  pyxl0error$^  pyxaddtracebackpywrapfst.symboltableiterator.init pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^  $^     this just registers this class as a possible iterator.$^    def iterself              $^      return self$^  $^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00symboltableiterator0iterpyobject pyxvself proto$^static pyobject pyxpw0pywrapfst00symboltableiterator0iterpyobject pyxvself $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextiter wrapper 0$^  pyxr  pyxpf0pywrapfst00symboltableiterator0iterstruct pyxobj0pywrapfstsymboltableiterator pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00symboltableiterator0iterstruct pyxobj0pywrapfstsymboltableiterator pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextiter 0$^$^   pywrapfst.pyx0000$^     this just registers this class as a possible iterator.$^    def iterself$^      return self              $^  $^     magic method used to get a pythonic api out of the c api.$^ $^  pyxxdecrefpyxr$^  pyxincrefpyobject pyxvself$^  pyxr  pyobject pyxvself$^  goto pyxl0$^$^   pywrapfst.pyx0000$^  $^     this just registers this class as a possible iterator.$^    def iterself              $^      return self$^  $^ $^$^   function exit code $^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^  $^     magic method used to get a pythonic api out of the c api.$^    def nextself              $^      if self.done$^        raise stopiteration$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00symboltableiterator0nextpyobject pyxvself proto$^static pyobject pyxpw0pywrapfst00symboltableiterator0nextpyobject pyxvself $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextnext wrapper 0$^  pyxr  pyxpf0pywrapfst00symboltableiterator0nextstruct pyxobj0pywrapfstsymboltableiterator pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00symboltableiterator0nextstruct pyxobj0pywrapfstsymboltableiterator pyxvself $^  pyxt00basictypesint00 pyxvvalue$^  stdstring pyxvsymbol$^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  int pyxt0$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextnext 0$^$^   pywrapfst.pyx0000$^     magic method used to get a pythonic api out of the c api.$^    def nextself$^      if self.done              $^        raise stopiteration$^      cdef int00 value  self.value$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s done$^    pyxerr0 0000 pyxl0error$^  $^  pyxt0  struct pyxvtabstruct0pywrapfstsymboltableiterator pyxvselfpyxvtabdonepyxvself 0  0$^  if unlikelypyxt0 $^$^     pywrapfst.pyx0000$^    def nextself$^      if self.done$^        raise stopiteration              $^      cdef int00 value  self.value$^      cdef string symbol  self.symbol$^ $^    pyxraisepyxbuiltinstopiteration 0 0 0$^    pyxerr0 0000 pyxl0error$^$^     pywrapfst.pyx0000$^     magic method used to get a pythonic api out of the c api.$^    def nextself$^      if self.done              $^        raise stopiteration$^      cdef int00 value  self.value$^ $^  $^$^   pywrapfst.pyx0000$^      if self.done$^        raise stopiteration$^      cdef int00 value  self.value              $^      cdef string symbol  self.symbol$^      self.next$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s value$^    pyxerr0 0000 pyxl0error$^  $^  pyxvvalue  struct pyxvtabstruct0pywrapfstsymboltableiterator pyxvselfpyxvtabvaluepyxvself 0$^$^   pywrapfst.pyx0000$^        raise stopiteration$^      cdef int00 value  self.value$^      cdef string symbol  self.symbol              $^      self.next$^      return value symbol$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s symbol$^    pyxerr0 0000 pyxl0error$^  $^  pyxvsymbol  struct pyxvtabstruct0pywrapfstsymboltableiterator pyxvselfpyxvtabsymbolpyxvself 0$^$^   pywrapfst.pyx0000$^      cdef int00 value  self.value$^      cdef string symbol  self.symbol$^      self.next              $^      return value symbol$^  $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s next$^    pyxerr0 0000 pyxl0error$^  $^  struct pyxvtabstruct0pywrapfstsymboltableiterator pyxvselfpyxvtabnextpyxvself 0$^$^   pywrapfst.pyx0000$^      cdef string symbol  self.symbol$^      self.next$^      return value symbol              $^  $^    cpdef bool doneself$^ $^  pyxxdecrefpyxr$^  pyxt0  pyxpyintfromint00tpyxvvalue if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxt0  pyxconvertpybytesstringtopystdinstringpyxvsymbol if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxt0  pytuplenew0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxgiverefpyxt0$^  pytuplesetitempyxt0 0 pyxt0$^  pyxgiverefpyxt0$^  pytuplesetitempyxt0 0 pyxt0$^  pyxt0  0$^  pyxt0  0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   pywrapfst.pyx0000$^  $^     magic method used to get a pythonic api out of the c api.$^    def nextself              $^      if self.done$^        raise stopiteration$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.symboltableiterator.next pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return value symbol$^  $^    cpdef bool doneself              $^      $^      doneself$^ $^$^static pyobject pyxpw0pywrapfst00symboltableiterator0donepyobject pyxvself cythonunused pyobject unused proto$^static bool pyxf0pywrapfst00symboltableiteratordonestruct pyxobj0pywrapfstsymboltableiterator pyxvself int pyxskipdispatch $^  bool pyxr$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  bool pyxt0$^  pyxrefnannysetupcontextdone 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnsdone if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst00symboltableiterator0done $^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxdecrefpyxt0 pyxt0  0$^       else $^        pyxt0  pyxpyobjectcallnoargpyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      $^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxt0  pyxpyobjectistruepyxt0 if unlikelypyxt0  bool0  pyerroccurred pyxerr0 0000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxr  pyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx0000$^        true if the iterator is exhausted false otherwise.$^      $^      return self.siter.get.done              $^  $^    cpdef void nextself$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s siter$^    pyxerr0 0000 pyxl0error$^  $^  pyxr  pyxvselfsiter.getdone$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      return value symbol$^  $^    cpdef bool doneself              $^      $^      doneself$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxwriteunraisablepywrapfst.symboltableiterator.done pyxclineno pyxlineno pyxfilename 0 0$^  pyxr  0$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst00symboltableiterator0donepyobject pyxvself cythonunused pyobject unused proto$^static char pyxdoc0pywrapfst00symboltableiterator0done  n    doneselfnn    indicates whether the iterator is exhausted or not.nn    returnsn      true if the iterator is exhausted false otherwise.n    $^static pyobject pyxpw0pywrapfst00symboltableiterator0donepyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextdone wrapper 0$^  pyxr  pyxpf0pywrapfst00symboltableiterator0donestruct pyxobj0pywrapfstsymboltableiterator pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00symboltableiterator0donestruct pyxobj0pywrapfstsymboltableiterator pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextdone 0$^  pyxxdecrefpyxr$^  pyxt0  pyxpyboolfromlongpyxf0pywrapfst00symboltableiteratordonepyxvself 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.symboltableiterator.done pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return self.siter.get.done$^  $^    cpdef void nextself              $^      $^      nextself$^ $^$^static pyobject pyxpw0pywrapfst00symboltableiterator00nextpyobject pyxvself cythonunused pyobject unused proto$^static void pyxf0pywrapfst00symboltableiteratornextstruct pyxobj0pywrapfstsymboltableiterator pyxvself int pyxskipdispatch $^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextnext 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnsnext if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst00symboltableiterator00next $^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxdecrefpyxt0 pyxt0  0$^       else $^        pyxt0  pyxpyobjectcallnoargpyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      $^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx0000$^      advances the iterator.$^      $^      self.siter.get.next              $^  $^    cpdef void resetself$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s siter$^    pyxerr0 0000 pyxl0error$^  $^  pyxvselfsiter.getnext$^$^   pywrapfst.pyx0000$^      return self.siter.get.done$^  $^    cpdef void nextself              $^      $^      nextself$^ $^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxwriteunraisablepywrapfst.symboltableiterator.next pyxclineno pyxlineno pyxfilename 0 0$^  pyxl0$^  pyxrefnannyfinishcontext$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst00symboltableiterator00nextpyobject pyxvself cythonunused pyobject unused proto$^static char pyxdoc0pywrapfst00symboltableiterator00next  n    nextselfnn    advances the iterator.n    $^static pyobject pyxpw0pywrapfst00symboltableiterator00nextpyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextnext wrapper 0$^  pyxr  pyxpf0pywrapfst00symboltableiterator00nextstruct pyxobj0pywrapfstsymboltableiterator pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00symboltableiterator00nextstruct pyxobj0pywrapfstsymboltableiterator pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextnext 0$^  pyxxdecrefpyxr$^  pyxt0  pyxvoidtononepyxf0pywrapfst00symboltableiteratornextpyxvself 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.symboltableiterator.next pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      self.siter.get.next$^  $^    cpdef void resetself              $^      $^      resetself$^ $^$^static pyobject pyxpw0pywrapfst00symboltableiterator00resetpyobject pyxvself cythonunused pyobject unused proto$^static void pyxf0pywrapfst00symboltableiteratorresetstruct pyxobj0pywrapfstsymboltableiterator pyxvself int pyxskipdispatch $^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextreset 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnsreset if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst00symboltableiterator00reset $^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxdecrefpyxt0 pyxt0  0$^       else $^        pyxt0  pyxpyobjectcallnoargpyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      $^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx0000$^      resets the iterator to the initial position.$^      $^      self.siter.get.reset              $^  $^    cpdef string symbolself$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s siter$^    pyxerr0 0000 pyxl0error$^  $^  pyxvselfsiter.getreset$^$^   pywrapfst.pyx0000$^      self.siter.get.next$^  $^    cpdef void resetself              $^      $^      resetself$^ $^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxwriteunraisablepywrapfst.symboltableiterator.reset pyxclineno pyxlineno pyxfilename 0 0$^  pyxl0$^  pyxrefnannyfinishcontext$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst00symboltableiterator00resetpyobject pyxvself cythonunused pyobject unused proto$^static char pyxdoc0pywrapfst00symboltableiterator00reset  n    resetselfnn    resets the iterator to the initial position.n    $^static pyobject pyxpw0pywrapfst00symboltableiterator00resetpyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextreset wrapper 0$^  pyxr  pyxpf0pywrapfst00symboltableiterator00resetstruct pyxobj0pywrapfstsymboltableiterator pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00symboltableiterator00resetstruct pyxobj0pywrapfstsymboltableiterator pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextreset 0$^  pyxxdecrefpyxr$^  pyxt0  pyxvoidtononepyxf0pywrapfst00symboltableiteratorresetpyxvself 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.symboltableiterator.reset pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      self.siter.get.reset$^  $^    cpdef string symbolself              $^      $^      symbolself$^ $^$^static pyobject pyxpw0pywrapfst00symboltableiterator00symbolpyobject pyxvself cythonunused pyobject unused proto$^static stdstring pyxf0pywrapfst00symboltableiteratorsymbolstruct pyxobj0pywrapfstsymboltableiterator pyxvself int pyxskipdispatch $^  stdstring pyxr$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  stdstring pyxt0$^  pyxrefnannysetupcontextsymbol 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnssymbol if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst00symboltableiterator00symbol $^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxdecrefpyxt0 pyxt0  0$^       else $^        pyxt0  pyxpyobjectcallnoargpyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      $^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxt0  pyxconvertstringfrompystdinstringpyxt0 if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxr  pyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx0000$^        a symbol string.$^      $^      return self.siter.get.symbol              $^  $^    cpdef int00 valueself$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s siter$^    pyxerr0 0000 pyxl0error$^  $^  pyxr  pyxvselfsiter.getsymbol$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      self.siter.get.reset$^  $^    cpdef string symbolself              $^      $^      symbolself$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxwriteunraisablepywrapfst.symboltableiterator.symbol pyxclineno pyxlineno pyxfilename 0 0$^  pyxpretendtoinitializepyxr$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst00symboltableiterator00symbolpyobject pyxvself cythonunused pyobject unused proto$^static char pyxdoc0pywrapfst00symboltableiterator00symbol  n    symbolselfnn    returns the current symbol string.nn    this method returns the current symbol string at this point in the table.nn    returnsn      a symbol string.n    $^static pyobject pyxpw0pywrapfst00symboltableiterator00symbolpyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextsymbol wrapper 0$^  pyxr  pyxpf0pywrapfst00symboltableiterator00symbolstruct pyxobj0pywrapfstsymboltableiterator pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00symboltableiterator00symbolstruct pyxobj0pywrapfstsymboltableiterator pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextsymbol 0$^  pyxxdecrefpyxr$^  pyxt0  pyxconvertpybytesstringtopystdinstringpyxf0pywrapfst00symboltableiteratorsymbolpyxvself 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.symboltableiterator.symbol pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return self.siter.get.symbol$^  $^    cpdef int00 valueself              $^      $^      valueself$^ $^$^static pyobject pyxpw0pywrapfst00symboltableiterator00valuepyobject pyxvself cythonunused pyobject unused proto$^static pyxt00basictypesint00 pyxf0pywrapfst00symboltableiteratorvaluestruct pyxobj0pywrapfstsymboltableiterator pyxvself int pyxskipdispatch $^  pyxt00basictypesint00 pyxr$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxt00basictypesint00 pyxt0$^  pyxrefnannysetupcontextvalue 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnsvalue if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst00symboltableiterator00value $^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxdecrefpyxt0 pyxt0  0$^       else $^        pyxt0  pyxpyobjectcallnoargpyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      $^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxt0  pyxpyintasint00tpyxt0 if unlikelypyxt0  int00t0  pyerroccurred pyxerr0 0000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxr  pyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx0000$^        an integer index.$^      $^      return self.siter.get.value              $^  $^  $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s siter$^    pyxerr0 0000 pyxl0error$^  $^  pyxr  pyxvselfsiter.getvalue$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      return self.siter.get.symbol$^  $^    cpdef int00 valueself              $^      $^      valueself$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxwriteunraisablepywrapfst.symboltableiterator.value pyxclineno pyxlineno pyxfilename 0 0$^  pyxr  0$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst00symboltableiterator00valuepyobject pyxvself cythonunused pyobject unused proto$^static char pyxdoc0pywrapfst00symboltableiterator00value  n    valueselfnn    returns the current integer index of the symbol.nn    returnsn      an integer index.n    $^static pyobject pyxpw0pywrapfst00symboltableiterator00valuepyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextvalue wrapper 0$^  pyxr  pyxpf0pywrapfst00symboltableiterator00valuestruct pyxobj0pywrapfstsymboltableiterator pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00symboltableiterator00valuestruct pyxobj0pywrapfstsymboltableiterator pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextvalue 0$^  pyxxdecrefpyxr$^  pyxt0  pyxpyintfromint00tpyxf0pywrapfst00symboltableiteratorvaluepyxvself 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.symboltableiterator.value pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ tree fragment0$^  def reducecythonself              $^      raise typeerrorself.siterself.table cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00symboltableiterator00reducecythonpyobject pyxvself cythonunused pyobject unused proto$^static pyobject pyxpw0pywrapfst00symboltableiterator00reducecythonpyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextreducecython wrapper 0$^  pyxr  pyxpf0pywrapfst00symboltableiterator00reducecythonstruct pyxobj0pywrapfstsymboltableiterator pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00symboltableiterator00reducecythoncythonunused struct pyxobj0pywrapfstsymboltableiterator pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextreducecython 0$^$^   tree fragment0$^  def reducecythonself$^      raise typeerrorself.siterself.table cannot be converted to a python object for pickling              $^  def setstatecythonself pyxstate$^      raise typeerrorself.siterself.table cannot be converted to a python object for pickling$^ $^  pyxt0  pyxpyobjectcallpyxbuiltintypeerror pyxtuple00 null if unlikelypyxt0 pyxerr0 0 pyxl0error$^  pyxgotrefpyxt0$^  pyxraisepyxt0 0 0 0$^  pyxdecrefpyxt0 pyxt0  0$^  pyxerr0 0 pyxl0error$^$^   tree fragment0$^  def reducecythonself              $^      raise typeerrorself.siterself.table cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.symboltableiterator.reducecython pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ tree fragment0$^  def reducecythonself$^      raise typeerrorself.siterself.table cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate              $^      raise typeerrorself.siterself.table cannot be converted to a python object for pickling$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00symboltableiterator00setstatecythonpyobject pyxvself pyobject pyxvpyxstate proto$^static pyobject pyxpw0pywrapfst00symboltableiterator00setstatecythonpyobject pyxvself pyobject pyxvpyxstate $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextsetstatecython wrapper 0$^  pyxr  pyxpf0pywrapfst00symboltableiterator00setstatecythonstruct pyxobj0pywrapfstsymboltableiterator pyxvself pyobject pyxvpyxstate$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00symboltableiterator00setstatecythoncythonunused struct pyxobj0pywrapfstsymboltableiterator pyxvself cythonunused pyobject pyxvpyxstate $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextsetstatecython 0$^$^   tree fragment0$^      raise typeerrorself.siterself.table cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate$^      raise typeerrorself.siterself.table cannot be converted to a python object for pickling              $^ $^  pyxt0  pyxpyobjectcallpyxbuiltintypeerror pyxtuple00 null if unlikelypyxt0 pyxerr0 0 pyxl0error$^  pyxgotrefpyxt0$^  pyxraisepyxt0 0 0 0$^  pyxdecrefpyxt0 pyxt0  0$^  pyxerr0 0 pyxl0error$^$^   tree fragment0$^  def reducecythonself$^      raise typeerrorself.siterself.table cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate              $^      raise typeerrorself.siterself.table cannot be converted to a python object for pickling$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.symboltableiterator.setstatecython pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^    $^  $^    def reprself              $^      return encodemapper at 0xx.formatidself$^  $^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00encodemapper0reprpyobject pyxvself proto$^static pyobject pyxpw0pywrapfst00encodemapper0reprpyobject pyxvself $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextrepr wrapper 0$^  pyxr  pyxpf0pywrapfst00encodemapperreprstruct pyxobj0pywrapfstencodemapper pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00encodemapperreprstruct pyxobj0pywrapfstencodemapper pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextrepr 0$^$^   pywrapfst.pyx0000$^  $^    def reprself$^      return encodemapper at 0xx.formatidself              $^  $^    def initself$^ $^  pyxxdecrefpyxr$^  pyxt0  pyxpyobjectgetattrstrpyxkpsencodemapperat0xx pyxnsformat if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxt0  pyxpyobjectcalloneargpyxbuiltinid pyobject pyxvself if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxt0  null$^  if cythonunpackmethods  likelypymethodcheckpyxt0 $^    pyxt0  pymethodgetselfpyxt0$^    if likelypyxt0 $^      pyobject function  pymethodgetfunctionpyxt0$^      pyxincrefpyxt0$^      pyxincreffunction$^      pyxdecrefsetpyxt0 function$^    $^  $^  if pyxt0 $^    pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxdecrefpyxt0 pyxt0  0$^    pyxgotrefpyxt0$^   else $^    if cythonfastpycall$^    if pyfunctioncheckpyxt0 $^      pyobject pyxtemp0  pyxt0 pyxt0$^      pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxxdecrefpyxt0 pyxt0  0$^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^     else$^    endif$^    if cythonfastpyccall$^    if pyxpyfastcfunctioncheckpyxt0 $^      pyobject pyxtemp0  pyxt0 pyxt0$^      pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxxdecrefpyxt0 pyxt0  0$^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^     else$^    endif$^    $^      pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxgotrefpyxt0$^      pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^      pyxgiverefpyxt0$^      pytuplesetitempyxt0 00 pyxt0$^      pyxt0  0$^      pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^    $^  $^  pyxdecrefpyxt0 pyxt0  0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   pywrapfst.pyx0000$^    $^  $^    def reprself              $^      return encodemapper at 0xx.formatidself$^  $^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.encodemapper.repr pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return encodemapper at 0xx.formatidself$^  $^    def initself              $^                 arctypebstandard$^                 bool encodelabelsfalse$^ $^$^ python wrapper $^static int pyxpw0pywrapfst00encodemapper0initpyobject pyxvself pyobject pyxargs pyobject pyxkwds proto$^static int pyxpw0pywrapfst00encodemapper0initpyobject pyxvself pyobject pyxargs pyobject pyxkwds $^  pyobject pyxvarctype  0$^  bool pyxvencodelabels$^  bool pyxvencodeweights$^  int pyxr$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextinit wrapper 0$^  $^    static pyobject pyxpyargnames  pyxnsarctypepyxnsencodelabelspyxnsencodeweights0$^    pyobject values0  000$^    values0  pyobject pyxnbstandard$^    if unlikelypyxkwds $^      pyssizet kwargs$^      const pyssizet posargs  pytuplegetsizepyxargs$^      switch posargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 break$^        default goto pyxl0argtupleerror$^      $^      kwargs  pydictsizepyxkwds$^      switch posargs $^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnsarctype$^          if value  values0  value kwargs $^        $^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnsencodelabels$^          if value  values0  value kwargs $^        $^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnsencodeweights$^          if value  values0  value kwargs $^        $^      $^      if unlikelykwargs  0 $^        if unlikelypyxparseoptionalkeywordspyxkwds pyxpyargnames 0 values posargs init  0 pyxerr0 0000 pyxl0error$^      $^     else $^      switch pytuplegetsizepyxargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 break$^        default goto pyxl0argtupleerror$^      $^    $^    pyxvarctype  values0$^    if values0 $^      pyxvencodelabels  pyxpyobjectistruevalues0 if unlikelypyxvencodelabels  bool0  pyerroccurred pyxerr0 0000 pyxl0error$^     else $^$^       pywrapfst.pyx0000$^    def initself$^                 arctypebstandard$^                 bool encodelabelsfalse              $^                 bool encodeweightsfalse$^      cdef uint00 flags  fst.getencodeflagsencodelabels encodeweights$^ $^      pyxvencodelabels  bool0$^    $^    if values0 $^      pyxvencodeweights  pyxpyobjectistruevalues0 if unlikelypyxvencodeweights  bool0  pyerroccurred pyxerr0 0000 pyxl0error$^     else $^$^       pywrapfst.pyx0000$^                 arctypebstandard$^                 bool encodelabelsfalse$^                 bool encodeweightsfalse              $^      cdef uint00 flags  fst.getencodeflagsencodelabels encodeweights$^      self.encoder.resetnew fst.encodemapperclasstostringarctype flags$^ $^      pyxvencodeweights  bool0$^    $^  $^  goto pyxl0argumentunpackingdone$^  pyxl0argtupleerror$^  pyxraiseargtupleinvalidinit 0 0 0 pytuplegetsizepyxargs pyxerr0 0000 pyxl0error$^  pyxl0error$^  pyxaddtracebackpywrapfst.encodemapper.init pyxclineno pyxlineno pyxfilename$^  pyxrefnannyfinishcontext$^  return 0$^  pyxl0argumentunpackingdone$^  pyxr  pyxpf0pywrapfst00encodemapper0initstruct pyxobj0pywrapfstencodemapper pyxvself pyxvarctype pyxvencodelabels pyxvencodeweights$^$^   pywrapfst.pyx0000$^      return encodemapper at 0xx.formatidself$^  $^    def initself              $^                 arctypebstandard$^                 bool encodelabelsfalse$^ $^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static int pyxpf0pywrapfst00encodemapper0initstruct pyxobj0pywrapfstencodemapper pyxvself pyobject pyxvarctype bool pyxvencodelabels bool pyxvencodeweights $^  pyxt00basictypesuint00 pyxvflags$^  int pyxr$^  pyxrefnannydeclarations$^  stdstring pyxt0$^  int pyxt0$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextinit 0$^$^   pywrapfst.pyx0000$^                 bool encodelabelsfalse$^                 bool encodeweightsfalse$^      cdef uint00 flags  fst.getencodeflagsencodelabels encodeweights              $^      self.encoder.resetnew fst.encodemapperclasstostringarctype flags$^                                                    fst.encode$^ $^  pyxvflags  fstscriptgetencodeflagspyxvencodelabels pyxvencodeweights$^$^   pywrapfst.pyx0000$^                 bool encodeweightsfalse$^      cdef uint00 flags  fst.getencodeflagsencodelabels encodeweights$^      self.encoder.resetnew fst.encodemapperclasstostringarctype flags              $^                                                    fst.encode$^      if not self.encoder$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s encoder$^    pyxerr0 0000 pyxl0error$^  $^  pyxt0  pyxf0pywrapfsttostringpyxvarctype null if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^      cdef uint00 flags  fst.getencodeflagsencodelabels encodeweights$^      self.encoder.resetnew fst.encodemapperclasstostringarctype flags$^                                                    fst.encode              $^      if not self.encoder$^        raise fstoperrorunknown arc type r.formatarctype$^ $^  pyxvselfencoder.resetnew fstscriptencodemapperclasspyxt0 pyxvflags fstencode$^$^   pywrapfst.pyx0000$^      self.encoder.resetnew fst.encodemapperclasstostringarctype flags$^                                                    fst.encode$^      if not self.encoder              $^        raise fstoperrorunknown arc type r.formatarctype$^  $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s encoder$^    pyxerr0 0000 pyxl0error$^  $^  pyxt0  pyxvselfencoder  0$^  if unlikelypyxt0 $^$^     pywrapfst.pyx0000$^                                                    fst.encode$^      if not self.encoder$^        raise fstoperrorunknown arc type r.formatarctype              $^  $^    cpdef string arctypeself$^ $^    pyxt0  pyxgetmoduleglobalnamepyxnsfstoperror if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  pyxpyobjectgetattrstrpyxkpsunknownarctyper pyxnsformat if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  null$^    if cythonunpackmethods  likelypymethodcheckpyxt0 $^      pyxt0  pymethodgetselfpyxt0$^      if likelypyxt0 $^        pyobject function  pymethodgetfunctionpyxt0$^        pyxincrefpyxt0$^        pyxincreffunction$^        pyxdecrefsetpyxt0 function$^      $^    $^    if pyxt0 $^      pyxt0  pyxpyobjectcalloneargpyxt0 pyxvarctype if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxgotrefpyxt0$^     else $^      if cythonfastpycall$^      if pyfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxvarctype$^        pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^       else$^      endif$^      if cythonfastpyccall$^      if pyxpyfastcfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxvarctype$^        pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^       else$^      endif$^      $^        pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxgotrefpyxt0$^        pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^        pyxincrefpyxvarctype$^        pyxgiverefpyxvarctype$^        pytuplesetitempyxt0 00 pyxvarctype$^        pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^      $^    $^    pyxdecrefpyxt0 pyxt0  0$^    pyxt0  null$^    if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^      pyxt0  pymethodgetselfpyxt0$^      if likelypyxt0 $^        pyobject function  pymethodgetfunctionpyxt0$^        pyxincrefpyxt0$^        pyxincreffunction$^        pyxdecrefsetpyxt0 function$^      $^    $^    if pyxt0 $^      pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxgotrefpyxt0$^     else $^      if cythonfastpycall$^      if pyfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxt0$^        pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^       else$^      endif$^      if cythonfastpyccall$^      if pyxpyfastcfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxt0$^        pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^       else$^      endif$^      $^        pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxgotrefpyxt0$^        pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^        pyxgiverefpyxt0$^        pytuplesetitempyxt0 00 pyxt0$^        pyxt0  0$^        pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^      $^    $^    pyxdecrefpyxt0 pyxt0  0$^    pyxraisepyxt0 0 0 0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxerr0 0000 pyxl0error$^$^     pywrapfst.pyx0000$^      self.encoder.resetnew fst.encodemapperclasstostringarctype flags$^                                                    fst.encode$^      if not self.encoder              $^        raise fstoperrorunknown arc type r.formatarctype$^  $^ $^  $^$^   pywrapfst.pyx0000$^      return encodemapper at 0xx.formatidself$^  $^    def initself              $^                 arctypebstandard$^                 bool encodelabelsfalse$^ $^$^   function exit code $^  pyxr  0$^  goto pyxl0$^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.encodemapper.init pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^        raise fstoperrorunknown arc type r.formatarctype$^  $^    cpdef string arctypeself              $^      $^      arctypeself$^ $^$^static pyobject pyxpw0pywrapfst00encodemapper0arctypepyobject pyxvself cythonunused pyobject unused proto$^static stdstring pyxf0pywrapfst00encodemapperarctypestruct pyxobj0pywrapfstencodemapper pyxvself int pyxskipdispatch $^  stdstring pyxr$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  stdstring pyxt0$^  pyxrefnannysetupcontextarctype 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnsarctype if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst00encodemapper0arctype $^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxdecrefpyxt0 pyxt0  0$^       else $^        pyxt0  pyxpyobjectcallnoargpyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      $^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxt0  pyxconvertstringfrompystdinstringpyxt0 if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxr  pyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx0000$^      returns a string indicating the arc type.$^      $^      return self.encoder.get.arctype              $^  $^     pythons equivalent to operator.$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s encoder$^    pyxerr0 0000 pyxl0error$^  $^  pyxr  pyxvselfencoder.getarctype$^  goto pyxl0$^$^   pywrapfst.pyx0000$^        raise fstoperrorunknown arc type r.formatarctype$^  $^    cpdef string arctypeself              $^      $^      arctypeself$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxwriteunraisablepywrapfst.encodemapper.arctype pyxclineno pyxlineno pyxfilename 0 0$^  pyxpretendtoinitializepyxr$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst00encodemapper0arctypepyobject pyxvself cythonunused pyobject unused proto$^static char pyxdoc0pywrapfst00encodemapper0arctype  n    arctypeselfnn    returns a string indicating the arc type.n    $^static pyobject pyxpw0pywrapfst00encodemapper0arctypepyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextarctype wrapper 0$^  pyxr  pyxpf0pywrapfst00encodemapper0arctypestruct pyxobj0pywrapfstencodemapper pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00encodemapper0arctypestruct pyxobj0pywrapfstencodemapper pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextarctype 0$^  pyxxdecrefpyxr$^  pyxt0  pyxconvertpybytesstringtopystdinstringpyxf0pywrapfst00encodemapperarctypepyxvself 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.encodemapper.arctype pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^     pythons equivalent to operator.$^  $^    def callself arc arc              $^      $^      selfstate ilabel olabel weight nextstate$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00encodemapper0callpyobject pyxvself pyobject pyxargs pyobject pyxkwds proto$^static char pyxdoc0pywrapfst00encodemapper0call  n    selfstate ilabel olabel weight nextstatenn    uses the encoder to encode an arc.nn    argsn      ilabel the integer index of the input label.n      olabel the integer index of the output label.n      weight a weight or weight string indicating the desired final weight ifn        null it is set to semiring one.n      nextstate the integer index of the destination state.nn    raisesn      fstoperror incompatible or invalid weight.n    $^if cythoncompilingincpython$^struct wrapperbase pyxwrapperbase0pywrapfst00encodemapper0call$^endif$^static pyobject pyxpw0pywrapfst00encodemapper0callpyobject pyxvself pyobject pyxargs pyobject pyxkwds $^  struct pyxobj0pywrapfstarc pyxvarc  0$^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextcall wrapper 0$^  $^    static pyobject pyxpyargnames  pyxnsarc0$^    pyobject values0  0$^    if unlikelypyxkwds $^      pyssizet kwargs$^      const pyssizet posargs  pytuplegetsizepyxargs$^      switch posargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 break$^        default goto pyxl0argtupleerror$^      $^      kwargs  pydictsizepyxkwds$^      switch posargs $^        case  0$^        if likelyvalues0  pyxpydictgetitemstrpyxkwds pyxnsarc  0 kwargs$^        else goto pyxl0argtupleerror$^      $^      if unlikelykwargs  0 $^        if unlikelypyxparseoptionalkeywordspyxkwds pyxpyargnames 0 values posargs call  0 pyxerr0 0000 pyxl0error$^      $^     else if pytuplegetsizepyxargs  0 $^      goto pyxl0argtupleerror$^     else $^      values0  pytuplegetitempyxargs 0$^    $^    pyxvarc  struct pyxobj0pywrapfstarc values0$^  $^  goto pyxl0argumentunpackingdone$^  pyxl0argtupleerror$^  pyxraiseargtupleinvalidcall 0 0 0 pytuplegetsizepyxargs pyxerr0 0000 pyxl0error$^  pyxl0error$^  pyxaddtracebackpywrapfst.encodemapper.call pyxclineno pyxlineno pyxfilename$^  pyxrefnannyfinishcontext$^  return null$^  pyxl0argumentunpackingdone$^  if unlikelypyxargtypetestpyobject pyxvarc pyxptype0pywrapfstarc 0 arc 0 pyxerr0 0000 pyxl0error$^  pyxr  pyxpf0pywrapfst00encodemapper0callstruct pyxobj0pywrapfstencodemapper pyxvself pyxvarc$^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxr  null$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00encodemapper0callstruct pyxobj0pywrapfstencodemapper pyxvself struct pyxobj0pywrapfstarc pyxvarc $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextcall 0$^$^   pywrapfst.pyx0000$^        fstoperror incompatible or invalid weight.$^      $^      return initarcself.encoder.get.callderefarc.arc              $^  $^    cpdef uint00 flagsself$^ $^  pyxxdecrefpyxr$^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s encoder$^    pyxerr0 0000 pyxl0error$^  $^  if unlikelypyobject pyxvarc  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s arc$^    pyxerr0 0000 pyxl0error$^  $^  pyxt0  pyobject pyxf0pywrapfstinitarcpyxvselfencoder.getoperatorpyxvarcarc if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   pywrapfst.pyx0000$^     pythons equivalent to operator.$^  $^    def callself arc arc              $^      $^      selfstate ilabel olabel weight nextstate$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.encodemapper.call pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return initarcself.encoder.get.callderefarc.arc$^  $^    cpdef uint00 flagsself              $^      $^      flagsself$^ $^$^static pyobject pyxpw0pywrapfst00encodemapper0flagspyobject pyxvself cythonunused pyobject unused proto$^static pyxt00basictypesuint00 pyxf0pywrapfst00encodemapperflagsstruct pyxobj0pywrapfstencodemapper pyxvself int pyxskipdispatch $^  pyxt00basictypesuint00 pyxr$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxt00basictypesuint00 pyxt0$^  pyxrefnannysetupcontextflags 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnsflags if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst00encodemapper0flags $^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxdecrefpyxt0 pyxt0  0$^       else $^        pyxt0  pyxpyobjectcallnoargpyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      $^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxt0  pyxpyintasuint00tpyxt0 if unlikelypyxt0  uint00t0  pyerroccurred pyxerr0 0000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxr  pyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx0000$^      returns the encoders flags.$^      $^      return self.encoder.get.flags              $^  $^    cpdef encodemappersymboltable inputsymbolsself$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s encoder$^    pyxerr0 0000 pyxl0error$^  $^  pyxr  pyxvselfencoder.getflags$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      return initarcself.encoder.get.callderefarc.arc$^  $^    cpdef uint00 flagsself              $^      $^      flagsself$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxwriteunraisablepywrapfst.encodemapper.flags pyxclineno pyxlineno pyxfilename 0 0$^  pyxr  0$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst00encodemapper0flagspyobject pyxvself cythonunused pyobject unused proto$^static char pyxdoc0pywrapfst00encodemapper0flags  n    flagsselfnn    returns the encoders flags.n    $^static pyobject pyxpw0pywrapfst00encodemapper0flagspyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextflags wrapper 0$^  pyxr  pyxpf0pywrapfst00encodemapper0flagsstruct pyxobj0pywrapfstencodemapper pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00encodemapper0flagsstruct pyxobj0pywrapfstencodemapper pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextflags 0$^  pyxxdecrefpyxr$^  pyxt0  pyxpyintfromuint00tpyxf0pywrapfst00encodemapperflagspyxvself 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.encodemapper.flags pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return self.encoder.get.flags$^  $^    cpdef encodemappersymboltable inputsymbolsself              $^      $^      inputsymbolsself$^ $^$^static pyobject pyxpw0pywrapfst00encodemapper00inputsymbolspyobject pyxvself cythonunused pyobject unused proto$^static struct pyxobj0pywrapfstencodemappersymboltable pyxf0pywrapfst00encodemapperinputsymbolsstruct pyxobj0pywrapfstencodemapper pyxvself int pyxskipdispatch $^  fstsymboltable pyxvsyms$^  struct pyxobj0pywrapfstencodemappersymboltable pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  int pyxt0$^  pyxrefnannysetupcontextinputsymbols 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnsinputsymbols if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst00encodemapper00inputsymbols $^      pyxxdecrefpyobject pyxr$^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxdecrefpyxt0 pyxt0  0$^       else $^        pyxt0  pyxpyobjectcallnoargpyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      $^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      if likelypyxt0  pynone  likelypyxtypetestpyxt0 pyxptype0pywrapfstencodemappersymboltable pyxerr0 0000 pyxl0error$^      pyxr  struct pyxobj0pywrapfstencodemappersymboltable pyxt0$^      pyxt0  0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx0000$^      $^      cdef fst.symboltable syms  constcastsymboltableptr$^          self.encoder.get.inputsymbols              $^      if syms  null$^        return$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s encoder$^    pyxerr0 0000 pyxl0error$^  $^$^   pywrapfst.pyx0000$^      returns the encoders input symbol table or none if none is present.$^      $^      cdef fst.symboltable syms  constcastsymboltableptr              $^          self.encoder.get.inputsymbols$^      if syms  null$^ $^  pyxvsyms  constcastpyxt0pywrapfstsymboltableptrpyxvselfencoder.getinputsymbols$^$^   pywrapfst.pyx0000$^      cdef fst.symboltable syms  constcastsymboltableptr$^          self.encoder.get.inputsymbols$^      if syms  null              $^        return$^      return initencodemappersymboltablesyms self.encoder$^ $^  pyxt0  pyxvsyms  null  0$^  if pyxt0 $^$^     pywrapfst.pyx0000$^          self.encoder.get.inputsymbols$^      if syms  null$^        return              $^      return initencodemappersymboltablesyms self.encoder$^  $^ $^    pyxxdecrefpyobject pyxr$^    pyxr  struct pyxobj0pywrapfstencodemappersymboltable pynone pyxincrefpynone$^    goto pyxl0$^$^     pywrapfst.pyx0000$^      cdef fst.symboltable syms  constcastsymboltableptr$^          self.encoder.get.inputsymbols$^      if syms  null              $^        return$^      return initencodemappersymboltablesyms self.encoder$^ $^  $^$^   pywrapfst.pyx0000$^      if syms  null$^        return$^      return initencodemappersymboltablesyms self.encoder              $^  $^    cpdef encodemappersymboltable outputsymbolsself$^ $^  pyxxdecrefpyobject pyxr$^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s encoder$^    pyxerr0 0000 pyxl0error$^  $^  pyxt0  pyobject pyxf0pywrapfstinitencodemappersymboltablepyxvsyms pyxvselfencoder if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  struct pyxobj0pywrapfstencodemappersymboltable pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      return self.encoder.get.flags$^  $^    cpdef encodemappersymboltable inputsymbolsself              $^      $^      inputsymbolsself$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.encodemapper.inputsymbols pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxl0$^  pyxxgiverefpyobject pyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst00encodemapper00inputsymbolspyobject pyxvself cythonunused pyobject unused proto$^static char pyxdoc0pywrapfst00encodemapper00inputsymbols  n    inputsymbolsselfnn    returns the encoders input symbol table or none if none is present.n    $^static pyobject pyxpw0pywrapfst00encodemapper00inputsymbolspyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextinputsymbols wrapper 0$^  pyxr  pyxpf0pywrapfst00encodemapper00inputsymbolsstruct pyxobj0pywrapfstencodemapper pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00encodemapper00inputsymbolsstruct pyxobj0pywrapfstencodemapper pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextinputsymbols 0$^  pyxxdecrefpyxr$^  pyxt0  pyobject pyxf0pywrapfst00encodemapperinputsymbolspyxvself 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.encodemapper.inputsymbols pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return initencodemappersymboltablesyms self.encoder$^  $^    cpdef encodemappersymboltable outputsymbolsself              $^      $^      outputsymbolsself$^ $^$^static pyobject pyxpw0pywrapfst00encodemapper00outputsymbolspyobject pyxvself cythonunused pyobject unused proto$^static struct pyxobj0pywrapfstencodemappersymboltable pyxf0pywrapfst00encodemapperoutputsymbolsstruct pyxobj0pywrapfstencodemapper pyxvself int pyxskipdispatch $^  fstsymboltable pyxvsyms$^  struct pyxobj0pywrapfstencodemappersymboltable pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  int pyxt0$^  pyxrefnannysetupcontextoutputsymbols 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnsoutputsymbols if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst00encodemapper00outputsymbols $^      pyxxdecrefpyobject pyxr$^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxdecrefpyxt0 pyxt0  0$^       else $^        pyxt0  pyxpyobjectcallnoargpyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      $^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      if likelypyxt0  pynone  likelypyxtypetestpyxt0 pyxptype0pywrapfstencodemappersymboltable pyxerr0 0000 pyxl0error$^      pyxr  struct pyxobj0pywrapfstencodemappersymboltable pyxt0$^      pyxt0  0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx0000$^      $^      cdef fst.symboltable syms  constcastsymboltableptr$^          self.encoder.get.outputsymbols              $^      if syms  null$^        return$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s encoder$^    pyxerr0 0000 pyxl0error$^  $^$^   pywrapfst.pyx0000$^      returns the encoders output symbol table or none if none is present.$^      $^      cdef fst.symboltable syms  constcastsymboltableptr              $^          self.encoder.get.outputsymbols$^      if syms  null$^ $^  pyxvsyms  constcastpyxt0pywrapfstsymboltableptrpyxvselfencoder.getoutputsymbols$^$^   pywrapfst.pyx0000$^      cdef fst.symboltable syms  constcastsymboltableptr$^          self.encoder.get.outputsymbols$^      if syms  null              $^        return$^      return initencodemappersymboltablesyms self.encoder$^ $^  pyxt0  pyxvsyms  null  0$^  if pyxt0 $^$^     pywrapfst.pyx0000$^          self.encoder.get.outputsymbols$^      if syms  null$^        return              $^      return initencodemappersymboltablesyms self.encoder$^  $^ $^    pyxxdecrefpyobject pyxr$^    pyxr  struct pyxobj0pywrapfstencodemappersymboltable pynone pyxincrefpynone$^    goto pyxl0$^$^     pywrapfst.pyx0000$^      cdef fst.symboltable syms  constcastsymboltableptr$^          self.encoder.get.outputsymbols$^      if syms  null              $^        return$^      return initencodemappersymboltablesyms self.encoder$^ $^  $^$^   pywrapfst.pyx0000$^      if syms  null$^        return$^      return initencodemappersymboltablesyms self.encoder              $^  $^    cpdef uint00 propertiesself uint00 mask$^ $^  pyxxdecrefpyobject pyxr$^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s encoder$^    pyxerr0 0000 pyxl0error$^  $^  pyxt0  pyobject pyxf0pywrapfstinitencodemappersymboltablepyxvsyms pyxvselfencoder if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  struct pyxobj0pywrapfstencodemappersymboltable pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      return initencodemappersymboltablesyms self.encoder$^  $^    cpdef encodemappersymboltable outputsymbolsself              $^      $^      outputsymbolsself$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.encodemapper.outputsymbols pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxl0$^  pyxxgiverefpyobject pyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst00encodemapper00outputsymbolspyobject pyxvself cythonunused pyobject unused proto$^static char pyxdoc0pywrapfst00encodemapper00outputsymbols  n    outputsymbolsselfnn    returns the encoders output symbol table or none if none is present.n    $^static pyobject pyxpw0pywrapfst00encodemapper00outputsymbolspyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextoutputsymbols wrapper 0$^  pyxr  pyxpf0pywrapfst00encodemapper00outputsymbolsstruct pyxobj0pywrapfstencodemapper pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00encodemapper00outputsymbolsstruct pyxobj0pywrapfstencodemapper pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextoutputsymbols 0$^  pyxxdecrefpyxr$^  pyxt0  pyobject pyxf0pywrapfst00encodemapperoutputsymbolspyxvself 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.encodemapper.outputsymbols pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return initencodemappersymboltablesyms self.encoder$^  $^    cpdef uint00 propertiesself uint00 mask              $^      $^      propertiesself mask$^ $^$^static pyobject pyxpw0pywrapfst00encodemapper00propertiespyobject pyxvself pyobject pyxargmask proto$^static pyxt00basictypesuint00 pyxf0pywrapfst00encodemapperpropertiesstruct pyxobj0pywrapfstencodemapper pyxvself pyxt00basictypesuint00 pyxvmask int pyxskipdispatch $^  pyxt00basictypesuint00 pyxr$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxt00basictypesuint00 pyxt0$^  pyxrefnannysetupcontextproperties 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnsproperties if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst00encodemapper00properties $^      pyxt0  pyxpyintfromuint00tpyxvmask if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxgotrefpyxt0$^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^       else $^        if cythonfastpycall$^        if pyfunctioncheckpyxt0 $^          pyobject pyxtemp0  pyxt0 pyxt0$^          pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^          pyxxdecrefpyxt0 pyxt0  0$^          pyxgotrefpyxt0$^          pyxdecrefpyxt0 pyxt0  0$^         else$^        endif$^        if cythonfastpyccall$^        if pyxpyfastcfunctioncheckpyxt0 $^          pyobject pyxtemp0  pyxt0 pyxt0$^          pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^          pyxxdecrefpyxt0 pyxt0  0$^          pyxgotrefpyxt0$^          pyxdecrefpyxt0 pyxt0  0$^         else$^        endif$^        $^          pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^          pyxgotrefpyxt0$^          pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^          pyxgiverefpyxt0$^          pytuplesetitempyxt0 00 pyxt0$^          pyxt0  0$^          pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^          pyxgotrefpyxt0$^          pyxdecrefpyxt0 pyxt0  0$^        $^      $^      pyxdecrefpyxt0 pyxt0  0$^      pyxt0  pyxpyintasuint00tpyxt0 if unlikelypyxt0  uint00t0  pyerroccurred pyxerr0 0000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxr  pyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx0000$^        a 00bit bitmask representing the requested properties.$^      $^      return self.encoder.get.propertiesmask              $^  $^    cpdef void setinputsymbolsself symboltable syms except $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s encoder$^    pyxerr0 0000 pyxl0error$^  $^  pyxr  pyxvselfencoder.getpropertiespyxvmask$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      return initencodemappersymboltablesyms self.encoder$^  $^    cpdef uint00 propertiesself uint00 mask              $^      $^      propertiesself mask$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxwriteunraisablepywrapfst.encodemapper.properties pyxclineno pyxlineno pyxfilename 0 0$^  pyxr  0$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst00encodemapper00propertiespyobject pyxvself pyobject pyxargmask proto$^static char pyxdoc0pywrapfst00encodemapper00properties  n    propertiesself masknn    provides property bits.nn    this method provides user access to the properties of the encoder.nn    argsn      mask the property mask to be compared to the encoders properties.nn    returnsn      a 00bit bitmask representing the requested properties.n    $^static pyobject pyxpw0pywrapfst00encodemapper00propertiespyobject pyxvself pyobject pyxargmask $^  pyxt00basictypesuint00 pyxvmask$^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextproperties wrapper 0$^  assertpyxargmask $^    pyxvmask  pyxpyintasuint00tpyxargmask if unlikelypyxvmask  uint00t0  pyerroccurred pyxerr0 0000 pyxl0error$^  $^  goto pyxl0argumentunpackingdone$^  pyxl0error$^  pyxaddtracebackpywrapfst.encodemapper.properties pyxclineno pyxlineno pyxfilename$^  pyxrefnannyfinishcontext$^  return null$^  pyxl0argumentunpackingdone$^  pyxr  pyxpf0pywrapfst00encodemapper00propertiesstruct pyxobj0pywrapfstencodemapper pyxvself pyxt00basictypesuint00pyxvmask$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00encodemapper00propertiesstruct pyxobj0pywrapfstencodemapper pyxvself pyxt00basictypesuint00 pyxvmask $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextproperties 0$^  pyxxdecrefpyxr$^  pyxt0  pyxpyintfromuint00tpyxf0pywrapfst00encodemapperpropertiespyxvself pyxvmask 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.encodemapper.properties pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return self.encoder.get.propertiesmask$^  $^    cpdef void setinputsymbolsself symboltable syms except               $^      $^      setinputsymbolsself syms$^ $^$^static pyobject pyxpw0pywrapfst00encodemapper00setinputsymbolspyobject pyxvself pyobject pyxvsyms proto$^static void pyxf0pywrapfst00encodemappersetinputsymbolsstruct pyxobj0pywrapfstencodemapper pyxvself struct pyxobj0pywrapfstsymboltable pyxvsyms int pyxskipdispatch $^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextsetinputsymbols 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnssetinputsymbols if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst00encodemapper00setinputsymbols $^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyobject pyxvsyms if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxgotrefpyxt0$^       else $^        if cythonfastpycall$^        if pyfunctioncheckpyxt0 $^          pyobject pyxtemp0  pyxt0 pyobject pyxvsyms$^          pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^          pyxxdecrefpyxt0 pyxt0  0$^          pyxgotrefpyxt0$^         else$^        endif$^        if cythonfastpyccall$^        if pyxpyfastcfunctioncheckpyxt0 $^          pyobject pyxtemp0  pyxt0 pyobject pyxvsyms$^          pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^          pyxxdecrefpyxt0 pyxt0  0$^          pyxgotrefpyxt0$^         else$^        endif$^        $^          pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^          pyxgotrefpyxt0$^          pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^          pyxincrefpyobject pyxvsyms$^          pyxgiverefpyobject pyxvsyms$^          pytuplesetitempyxt0 00 pyobject pyxvsyms$^          pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^          pyxgotrefpyxt0$^          pyxdecrefpyxt0 pyxt0  0$^        $^      $^      pyxdecrefpyxt0 pyxt0  0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx0000$^      see also setoutputsymbols.$^      $^      self.encoder.get.setinputsymbolssyms.table              $^  $^    cpdef void setoutputsymbolsself symboltable syms except $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s encoder$^    pyxerr0 0000 pyxl0error$^  $^  if unlikelypyobject pyxvsyms  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s table$^    pyxerr0 0000 pyxl0error$^  $^  pyxvselfencoder.getsetinputsymbolspyxvsymstable$^$^   pywrapfst.pyx0000$^      return self.encoder.get.propertiesmask$^  $^    cpdef void setinputsymbolsself symboltable syms except               $^      $^      setinputsymbolsself syms$^ $^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.encodemapper.setinputsymbols pyxclineno pyxlineno pyxfilename$^  pyxl0$^  pyxrefnannyfinishcontext$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst00encodemapper00setinputsymbolspyobject pyxvself pyobject pyxvsyms proto$^static char pyxdoc0pywrapfst00encodemapper00setinputsymbols  n    setinputsymbolsself symsnn    sets the encoders input symbol table.nn    argsn      syms a symboltable.nn    see also setoutputsymbols.n    $^static pyobject pyxpw0pywrapfst00encodemapper00setinputsymbolspyobject pyxvself pyobject pyxvsyms $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextsetinputsymbols wrapper 0$^  if unlikelypyxargtypetestpyobject pyxvsyms pyxptype0pywrapfstsymboltable 0 syms 0 pyxerr0 0000 pyxl0error$^  pyxr  pyxpf0pywrapfst00encodemapper00setinputsymbolsstruct pyxobj0pywrapfstencodemapper pyxvself struct pyxobj0pywrapfstsymboltable pyxvsyms$^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxr  null$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00encodemapper00setinputsymbolsstruct pyxobj0pywrapfstencodemapper pyxvself struct pyxobj0pywrapfstsymboltable pyxvsyms $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextsetinputsymbols 0$^  pyxxdecrefpyxr$^  pyxf0pywrapfst00encodemappersetinputsymbolspyxvself pyxvsyms 0 if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^  pyxt0  pyxvoidtononenull if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.encodemapper.setinputsymbols pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      self.encoder.get.setinputsymbolssyms.table$^  $^    cpdef void setoutputsymbolsself symboltable syms except               $^      $^      setoutputsymbolsself syms$^ $^$^static pyobject pyxpw0pywrapfst00encodemapper00setoutputsymbolspyobject pyxvself pyobject pyxvsyms proto$^static void pyxf0pywrapfst00encodemappersetoutputsymbolsstruct pyxobj0pywrapfstencodemapper pyxvself struct pyxobj0pywrapfstsymboltable pyxvsyms int pyxskipdispatch $^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextsetoutputsymbols 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnssetoutputsymbols if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst00encodemapper00setoutputsymbols $^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyobject pyxvsyms if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxgotrefpyxt0$^       else $^        if cythonfastpycall$^        if pyfunctioncheckpyxt0 $^          pyobject pyxtemp0  pyxt0 pyobject pyxvsyms$^          pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^          pyxxdecrefpyxt0 pyxt0  0$^          pyxgotrefpyxt0$^         else$^        endif$^        if cythonfastpyccall$^        if pyxpyfastcfunctioncheckpyxt0 $^          pyobject pyxtemp0  pyxt0 pyobject pyxvsyms$^          pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^          pyxxdecrefpyxt0 pyxt0  0$^          pyxgotrefpyxt0$^         else$^        endif$^        $^          pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^          pyxgotrefpyxt0$^          pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^          pyxincrefpyobject pyxvsyms$^          pyxgiverefpyobject pyxvsyms$^          pytuplesetitempyxt0 00 pyobject pyxvsyms$^          pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^          pyxgotrefpyxt0$^          pyxdecrefpyxt0 pyxt0  0$^        $^      $^      pyxdecrefpyxt0 pyxt0  0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx0000$^      see also setinputsymbols.$^      $^      self.encoder.get.setoutputsymbolssyms.table              $^  $^    cpdef string weighttypeself$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s encoder$^    pyxerr0 0000 pyxl0error$^  $^  if unlikelypyobject pyxvsyms  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s table$^    pyxerr0 0000 pyxl0error$^  $^  pyxvselfencoder.getsetoutputsymbolspyxvsymstable$^$^   pywrapfst.pyx0000$^      self.encoder.get.setinputsymbolssyms.table$^  $^    cpdef void setoutputsymbolsself symboltable syms except               $^      $^      setoutputsymbolsself syms$^ $^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.encodemapper.setoutputsymbols pyxclineno pyxlineno pyxfilename$^  pyxl0$^  pyxrefnannyfinishcontext$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst00encodemapper00setoutputsymbolspyobject pyxvself pyobject pyxvsyms proto$^static char pyxdoc0pywrapfst00encodemapper00setoutputsymbols  n    setoutputsymbolsself symsnn    sets the encoders output symbol table.nn    argsn      syms a symboltable.nn    see also setinputsymbols.n    $^static pyobject pyxpw0pywrapfst00encodemapper00setoutputsymbolspyobject pyxvself pyobject pyxvsyms $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextsetoutputsymbols wrapper 0$^  if unlikelypyxargtypetestpyobject pyxvsyms pyxptype0pywrapfstsymboltable 0 syms 0 pyxerr0 0000 pyxl0error$^  pyxr  pyxpf0pywrapfst00encodemapper00setoutputsymbolsstruct pyxobj0pywrapfstencodemapper pyxvself struct pyxobj0pywrapfstsymboltable pyxvsyms$^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxr  null$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00encodemapper00setoutputsymbolsstruct pyxobj0pywrapfstencodemapper pyxvself struct pyxobj0pywrapfstsymboltable pyxvsyms $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextsetoutputsymbols 0$^  pyxxdecrefpyxr$^  pyxf0pywrapfst00encodemappersetoutputsymbolspyxvself pyxvsyms 0 if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^  pyxt0  pyxvoidtononenull if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.encodemapper.setoutputsymbols pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      self.encoder.get.setoutputsymbolssyms.table$^  $^    cpdef string weighttypeself              $^      $^      weighttypeself$^ $^$^static pyobject pyxpw0pywrapfst00encodemapper00weighttypepyobject pyxvself cythonunused pyobject unused proto$^static stdstring pyxf0pywrapfst00encodemapperweighttypestruct pyxobj0pywrapfstencodemapper pyxvself int pyxskipdispatch $^  stdstring pyxr$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  stdstring pyxt0$^  pyxrefnannysetupcontextweighttype 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnsweighttype if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst00encodemapper00weighttype $^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxdecrefpyxt0 pyxt0  0$^       else $^        pyxt0  pyxpyobjectcallnoargpyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      $^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxt0  pyxconvertstringfrompystdinstringpyxt0 if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxr  pyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx0000$^      returns a string indicating the weight type.$^      $^      return self.encoder.get.weighttype              $^  $^  $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s encoder$^    pyxerr0 0000 pyxl0error$^  $^  pyxr  pyxvselfencoder.getweighttype$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      self.encoder.get.setoutputsymbolssyms.table$^  $^    cpdef string weighttypeself              $^      $^      weighttypeself$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxwriteunraisablepywrapfst.encodemapper.weighttype pyxclineno pyxlineno pyxfilename 0 0$^  pyxpretendtoinitializepyxr$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst00encodemapper00weighttypepyobject pyxvself cythonunused pyobject unused proto$^static char pyxdoc0pywrapfst00encodemapper00weighttype  n    weighttypeselfnn    returns a string indicating the weight type.n    $^static pyobject pyxpw0pywrapfst00encodemapper00weighttypepyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextweighttype wrapper 0$^  pyxr  pyxpf0pywrapfst00encodemapper00weighttypestruct pyxobj0pywrapfstencodemapper pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00encodemapper00weighttypestruct pyxobj0pywrapfstencodemapper pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextweighttype 0$^  pyxxdecrefpyxr$^  pyxt0  pyxconvertpybytesstringtopystdinstringpyxf0pywrapfst00encodemapperweighttypepyxvself 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.encodemapper.weighttype pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ tree fragment0$^  def reducecythonself              $^      raise typeerrorself.encoder cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00encodemapper00reducecythonpyobject pyxvself cythonunused pyobject unused proto$^static pyobject pyxpw0pywrapfst00encodemapper00reducecythonpyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextreducecython wrapper 0$^  pyxr  pyxpf0pywrapfst00encodemapper00reducecythonstruct pyxobj0pywrapfstencodemapper pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00encodemapper00reducecythoncythonunused struct pyxobj0pywrapfstencodemapper pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextreducecython 0$^$^   tree fragment0$^  def reducecythonself$^      raise typeerrorself.encoder cannot be converted to a python object for pickling              $^  def setstatecythonself pyxstate$^      raise typeerrorself.encoder cannot be converted to a python object for pickling$^ $^  pyxt0  pyxpyobjectcallpyxbuiltintypeerror pyxtuple00 null if unlikelypyxt0 pyxerr0 0 pyxl0error$^  pyxgotrefpyxt0$^  pyxraisepyxt0 0 0 0$^  pyxdecrefpyxt0 pyxt0  0$^  pyxerr0 0 pyxl0error$^$^   tree fragment0$^  def reducecythonself              $^      raise typeerrorself.encoder cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.encodemapper.reducecython pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ tree fragment0$^  def reducecythonself$^      raise typeerrorself.encoder cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate              $^      raise typeerrorself.encoder cannot be converted to a python object for pickling$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00encodemapper00setstatecythonpyobject pyxvself pyobject pyxvpyxstate proto$^static pyobject pyxpw0pywrapfst00encodemapper00setstatecythonpyobject pyxvself pyobject pyxvpyxstate $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextsetstatecython wrapper 0$^  pyxr  pyxpf0pywrapfst00encodemapper00setstatecythonstruct pyxobj0pywrapfstencodemapper pyxvself pyobject pyxvpyxstate$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00encodemapper00setstatecythoncythonunused struct pyxobj0pywrapfstencodemapper pyxvself cythonunused pyobject pyxvpyxstate $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextsetstatecython 0$^$^   tree fragment0$^      raise typeerrorself.encoder cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate$^      raise typeerrorself.encoder cannot be converted to a python object for pickling              $^ $^  pyxt0  pyxpyobjectcallpyxbuiltintypeerror pyxtuple00 null if unlikelypyxt0 pyxerr0 0 pyxl0error$^  pyxgotrefpyxt0$^  pyxraisepyxt0 0 0 0$^  pyxdecrefpyxt0 pyxt0  0$^  pyxerr0 0 pyxl0error$^$^   tree fragment0$^  def reducecythonself$^      raise typeerrorself.encoder cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate              $^      raise typeerrorself.encoder cannot be converted to a python object for pickling$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.encodemapper.setstatecython pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^  $^     ipython notebook magic to produce an svg of the fst.$^    def reprsvgself              $^      ipython notebook magic to produce an svg of the fst using graphviz.$^  $^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst0fst0reprsvgpyobject pyxvself cythonunused pyobject unused proto$^static char pyxdoc0pywrapfst0fstreprsvg  ipython notebook magic to produce an svg of the fst using graphviz.nn    this method produces an svg of the internal graph. users wishing to createn    publicationquality graphs should instead use the method draw whichn    exposes additional parameters.nn    raisesn      oserror cannot locate the dot executable.n      subprocess.calledprocesserror dot returned nonzero exit code.nn    see also draw text.n    $^static pyobject pyxpw0pywrapfst0fst0reprsvgpyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextreprsvg wrapper 0$^  pyxr  pyxpf0pywrapfst0fstreprsvgstruct pyxobj0pywrapfstfst pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst0fstreprsvgstruct pyxobj0pywrapfstfst pyxvself $^  pyobject pyxvproc  null$^  stdstringstream pyxvsstrm$^  pyobject pyxvsout  null$^  cythonunused pyobject pyxvserr  null$^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0pyobject $^  int pyxt0$^  int pyxt0$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextreprsvg 0$^$^   pywrapfst.pyx0000$^      $^       throws oserror if the dot executable is not found.$^      proc  subprocess.popendot tsvg stdinsubprocess.pipe              $^                              stdoutsubprocess.pipe stderrsubprocess.pipe$^      cdef stringstream sstrm$^ $^  pyxt0  pyxgetmoduleglobalnamepyxnssubprocess if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxt0  pyxpyobjectgetattrstrpyxt0 pyxnspopen if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxdecrefpyxt0 pyxt0  0$^  pyxt0  pylistnew0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxincrefpyxnsdot$^  pyxgiverefpyxnsdot$^  pylistsetitempyxt0 0 pyxnsdot$^  pyxincrefpyxkpstsvg$^  pyxgiverefpyxkpstsvg$^  pylistsetitempyxt0 0 pyxkpstsvg$^  pyxt0  pytuplenew0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxgiverefpyxt0$^  pytuplesetitempyxt0 0 pyxt0$^  pyxt0  0$^  pyxt0  pyxpydictnewpresized0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxt0  pyxgetmoduleglobalnamepyxnssubprocess if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxt0  pyxpyobjectgetattrstrpyxt0 pyxnspipe if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxdecrefpyxt0 pyxt0  0$^  if pydictsetitempyxt0 pyxnsstdin pyxt0  0 pyxerr0 0000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^$^   pywrapfst.pyx0000$^       throws oserror if the dot executable is not found.$^      proc  subprocess.popendot tsvg stdinsubprocess.pipe$^                              stdoutsubprocess.pipe stderrsubprocess.pipe              $^      cdef stringstream sstrm$^      fst.drawfstderefself.fst self.fst.get.inputsymbols$^ $^  pyxt0  pyxgetmoduleglobalnamepyxnssubprocess if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxt0  pyxpyobjectgetattrstrpyxt0 pyxnspipe if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxdecrefpyxt0 pyxt0  0$^  if pydictsetitempyxt0 pyxnsstdout pyxt0  0 pyxerr0 0000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^  pyxt0  pyxgetmoduleglobalnamepyxnssubprocess if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxt0  pyxpyobjectgetattrstrpyxt0 pyxnspipe if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxdecrefpyxt0 pyxt0  0$^  if pydictsetitempyxt0 pyxnsstderr pyxt0  0 pyxerr0 0000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^$^   pywrapfst.pyx0000$^      $^       throws oserror if the dot executable is not found.$^      proc  subprocess.popendot tsvg stdinsubprocess.pipe              $^                              stdoutsubprocess.pipe stderrsubprocess.pipe$^      cdef stringstream sstrm$^ $^  pyxt0  pyxpyobjectcallpyxt0 pyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxdecrefpyxt0 pyxt0  0$^  pyxdecrefpyxt0 pyxt0  0$^  pyxdecrefpyxt0 pyxt0  0$^  pyxvproc  pyxt0$^  pyxt0  0$^$^   pywrapfst.pyx0000$^                              stdoutsubprocess.pipe stderrsubprocess.pipe$^      cdef stringstream sstrm$^      fst.drawfstderefself.fst self.fst.get.inputsymbols              $^                  self.fst.get.outputsymbols null$^                  self.fst.get.propertiesfst.kacceptor true $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s fst$^    pyxerr0 0000 pyxl0error$^  $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s fst$^    pyxerr0 0000 pyxl0error$^  $^$^   pywrapfst.pyx0000$^      cdef stringstream sstrm$^      fst.drawfstderefself.fst self.fst.get.inputsymbols$^                  self.fst.get.outputsymbols null              $^                  self.fst.get.propertiesfst.kacceptor true $^                  fst.kacceptor$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s fst$^    pyxerr0 0000 pyxl0error$^  $^$^   pywrapfst.pyx0000$^      fst.drawfstderefself.fst self.fst.get.inputsymbols$^                  self.fst.get.outputsymbols null$^                  self.fst.get.propertiesfst.kacceptor true               $^                  fst.kacceptor$^                  b 0.0 00 true false 0.0 0.00 00 0 bg false$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s fst$^    pyxerr0 0000 pyxl0error$^  $^$^   pywrapfst.pyx0000$^                              stdoutsubprocess.pipe stderrsubprocess.pipe$^      cdef stringstream sstrm$^      fst.drawfstderefself.fst self.fst.get.inputsymbols              $^                  self.fst.get.outputsymbols null$^                  self.fst.get.propertiesfst.kacceptor true $^ $^  fstscriptdrawfstpyxvselffst pyxvselffst.getinputsymbols pyxvselffst.getoutputsymbols null pyxvselffst.getpropertiesfstkacceptor 0  fstkacceptor pyxk00 0.0 00.0 0 0 0.0 0.00 00 0 pyxkg 0 pyxvsstrm pyxkreprsvg$^$^   pywrapfst.pyx0000$^                  b 0.0 00 true false 0.0 0.00 00 0 bg false$^                  addrsstrm breprsvg$^      sout serr  proc.communicatesstrm.str              $^      if proc.returncode  0   just to be explicit.$^        raise subprocess.calledprocesserrorproc.returncode self.dottsvg$^ $^  pyxt0  pyxpyobjectgetattrstrpyxvproc pyxnscommunicate if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxt0  pyxconvertpybytesstringtopystdinstringpyxvsstrm.str if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxt0  null$^  if cythonunpackmethods  likelypymethodcheckpyxt0 $^    pyxt0  pymethodgetselfpyxt0$^    if likelypyxt0 $^      pyobject function  pymethodgetfunctionpyxt0$^      pyxincrefpyxt0$^      pyxincreffunction$^      pyxdecrefsetpyxt0 function$^    $^  $^  if pyxt0 $^    pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxdecrefpyxt0 pyxt0  0$^    pyxgotrefpyxt0$^   else $^    if cythonfastpycall$^    if pyfunctioncheckpyxt0 $^      pyobject pyxtemp0  pyxt0 pyxt0$^      pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxxdecrefpyxt0 pyxt0  0$^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^     else$^    endif$^    if cythonfastpyccall$^    if pyxpyfastcfunctioncheckpyxt0 $^      pyobject pyxtemp0  pyxt0 pyxt0$^      pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxxdecrefpyxt0 pyxt0  0$^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^     else$^    endif$^    $^      pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxgotrefpyxt0$^      pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^      pyxgiverefpyxt0$^      pytuplesetitempyxt0 00 pyxt0$^      pyxt0  0$^      pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^    $^  $^  pyxdecrefpyxt0 pyxt0  0$^  if likelypytuplecheckexactpyxt0  pylistcheckexactpyxt0 $^    pyobject sequence  pyxt0$^    pyssizet size  pyxpysequencesizesequence$^    if unlikelysize  0 $^      if size  0 pyxraisetoomanyvalueserror0$^      else if size  0 pyxraiseneedmorevalueserrorsize$^      pyxerr0 0000 pyxl0error$^    $^    if cythonassumesafemacros  cythonavoidborrowedrefs$^    if likelypytuplecheckexactsequence $^      pyxt0  pytuplegetitemsequence 0 $^      pyxt0  pytuplegetitemsequence 0 $^     else $^      pyxt0  pylistgetitemsequence 0 $^      pyxt0  pylistgetitemsequence 0 $^    $^    pyxincrefpyxt0$^    pyxincrefpyxt0$^    else$^    pyxt0  pysequenceitemsequence 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  pysequenceitemsequence 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    endif$^    pyxdecrefpyxt0 pyxt0  0$^   else $^    pyssizet index  0$^    pyxt0  pyobjectgetiterpyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxt0  pytypepyxt0tpiternext$^    index  0 pyxt0  pyxt0pyxt0 if unlikelypyxt0 goto pyxl0unpackingfailed$^    pyxgotrefpyxt0$^    index  0 pyxt0  pyxt0pyxt0 if unlikelypyxt0 goto pyxl0unpackingfailed$^    pyxgotrefpyxt0$^    if pyxiternextunpackendcheckpyxt0pyxt0 0  0 pyxerr0 0000 pyxl0error$^    pyxt0  null$^    pyxdecrefpyxt0 pyxt0  0$^    goto pyxl0unpackingdone$^    pyxl0unpackingfailed$^    pyxdecrefpyxt0 pyxt0  0$^    pyxt0  null$^    if pyxiterfinish  0 pyxraiseneedmorevalueserrorindex$^    pyxerr0 0000 pyxl0error$^    pyxl0unpackingdone$^  $^  pyxvsout  pyxt0$^  pyxt0  0$^  pyxvserr  pyxt0$^  pyxt0  0$^$^   pywrapfst.pyx0000$^                  addrsstrm breprsvg$^      sout serr  proc.communicatesstrm.str$^      if proc.returncode  0   just to be explicit.              $^        raise subprocess.calledprocesserrorproc.returncode self.dottsvg$^      return sout.decodeutf0$^ $^  pyxt0  pyxpyobjectgetattrstrpyxvproc pyxnsreturncode if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxt0  pyobjectrichcomparepyxt0 pyxint0 pyne pyxxgotrefpyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^  pyxt0  pyxpyobjectistruepyxt0 if unlikelypyxt0  0 pyxerr0 0000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^  if unlikelypyxt0 $^$^     pywrapfst.pyx0000$^      sout serr  proc.communicatesstrm.str$^      if proc.returncode  0   just to be explicit.$^        raise subprocess.calledprocesserrorproc.returncode self.dottsvg              $^      return sout.decodeutf0$^  $^ $^    pyxt0  pyxgetmoduleglobalnamepyxnssubprocess if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  pyxpyobjectgetattrstrpyxt0 pyxnscalledprocesserror if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxt0  pyxpyobjectgetattrstrpyxvproc pyxnsreturncode if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnsdottsvg if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  null$^    pyxt0  0$^    if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^      pyxt0  pymethodgetselfpyxt0$^      if likelypyxt0 $^        pyobject function  pymethodgetfunctionpyxt0$^        pyxincrefpyxt0$^        pyxincreffunction$^        pyxdecrefsetpyxt0 function$^        pyxt0  0$^      $^    $^    if cythonfastpycall$^    if pyfunctioncheckpyxt0 $^      pyobject pyxtemp0  pyxt0 pyxt0 pyxt0$^      pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp0pyxt0 0pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxxdecrefpyxt0 pyxt0  0$^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxdecrefpyxt0 pyxt0  0$^     else$^    endif$^    if cythonfastpyccall$^    if pyxpyfastcfunctioncheckpyxt0 $^      pyobject pyxtemp0  pyxt0 pyxt0 pyxt0$^      pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp0pyxt0 0pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxxdecrefpyxt0 pyxt0  0$^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxdecrefpyxt0 pyxt0  0$^     else$^    endif$^    $^      pyxt0  pytuplenew0pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxgotrefpyxt0$^      if pyxt0 $^        pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^      $^      pyxgiverefpyxt0$^      pytuplesetitempyxt0 0pyxt0 pyxt0$^      pyxgiverefpyxt0$^      pytuplesetitempyxt0 0pyxt0 pyxt0$^      pyxt0  0$^      pyxt0  0$^      pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^    $^    pyxdecrefpyxt0 pyxt0  0$^    pyxraisepyxt0 0 0 0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxerr0 0000 pyxl0error$^$^     pywrapfst.pyx0000$^                  addrsstrm breprsvg$^      sout serr  proc.communicatesstrm.str$^      if proc.returncode  0   just to be explicit.              $^        raise subprocess.calledprocesserrorproc.returncode self.dottsvg$^      return sout.decodeutf0$^ $^  $^$^   pywrapfst.pyx0000$^      if proc.returncode  0   just to be explicit.$^        raise subprocess.calledprocesserrorproc.returncode self.dottsvg$^      return sout.decodeutf0              $^  $^    def reprself$^ $^  pyxxdecrefpyxr$^  pyxt0  pyxpyobjectgetattrstrpyxvsout pyxnsdecode if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxt0  pyxpyobjectcallpyxt0 pyxtuple00 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxdecrefpyxt0 pyxt0  0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   pywrapfst.pyx0000$^  $^     ipython notebook magic to produce an svg of the fst.$^    def reprsvgself              $^      ipython notebook magic to produce an svg of the fst using graphviz.$^  $^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.fst.reprsvg pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxdecrefpyxvproc$^  pyxxdecrefpyxvsout$^  pyxxdecrefpyxvserr$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return sout.decodeutf0$^  $^    def reprself              $^      return  fst at 0xx.formatself.fsttype idself$^  $^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst0fst0reprpyobject pyxvself proto$^static pyobject pyxpw0pywrapfst0fst0reprpyobject pyxvself $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextrepr wrapper 0$^  pyxr  pyxpf0pywrapfst0fst0reprstruct pyxobj0pywrapfstfst pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst0fst0reprstruct pyxobj0pywrapfstfst pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  int pyxt0$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextrepr 0$^$^   pywrapfst.pyx0000$^  $^    def reprself$^      return  fst at 0xx.formatself.fsttype idself              $^  $^    def initself$^ $^  pyxxdecrefpyxr$^  pyxt0  pyxpyobjectgetattrstrpyxkpsfstat0xx pyxnsformat if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s fsttype$^    pyxerr0 0000 pyxl0error$^  $^  pyxt0  pyxconvertpybytesstringtopystdinstringstruct pyxvtabstruct0pywrapfstfst pyxvselfpyxvtabfsttypepyxvself 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxt0  pyxpyobjectcalloneargpyxbuiltinid pyobject pyxvself if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxt0  null$^  pyxt0  0$^  if cythonunpackmethods  likelypymethodcheckpyxt0 $^    pyxt0  pymethodgetselfpyxt0$^    if likelypyxt0 $^      pyobject function  pymethodgetfunctionpyxt0$^      pyxincrefpyxt0$^      pyxincreffunction$^      pyxdecrefsetpyxt0 function$^      pyxt0  0$^    $^  $^  if cythonfastpycall$^  if pyfunctioncheckpyxt0 $^    pyobject pyxtemp0  pyxt0 pyxt0 pyxt0$^    pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp0pyxt0 0pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxxdecrefpyxt0 pyxt0  0$^    pyxgotrefpyxt0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxdecrefpyxt0 pyxt0  0$^   else$^  endif$^  if cythonfastpyccall$^  if pyxpyfastcfunctioncheckpyxt0 $^    pyobject pyxtemp0  pyxt0 pyxt0 pyxt0$^    pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp0pyxt0 0pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxxdecrefpyxt0 pyxt0  0$^    pyxgotrefpyxt0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxdecrefpyxt0 pyxt0  0$^   else$^  endif$^  $^    pyxt0  pytuplenew0pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    if pyxt0 $^      pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^    $^    pyxgiverefpyxt0$^    pytuplesetitempyxt0 0pyxt0 pyxt0$^    pyxgiverefpyxt0$^    pytuplesetitempyxt0 0pyxt0 pyxt0$^    pyxt0  0$^    pyxt0  0$^    pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxdecrefpyxt0 pyxt0  0$^  $^  pyxdecrefpyxt0 pyxt0  0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      return sout.decodeutf0$^  $^    def reprself              $^      return  fst at 0xx.formatself.fsttype idself$^  $^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.fst.repr pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return  fst at 0xx.formatself.fsttype idself$^  $^    def initself              $^      raise fstdeletedconstructorerror$^          cannot construct .formatself.class.name$^ $^$^ python wrapper $^static int pyxpw0pywrapfst0fst0initpyobject pyxvself pyobject pyxargs pyobject pyxkwds proto$^static int pyxpw0pywrapfst0fst0initpyobject pyxvself pyobject pyxargs pyobject pyxkwds $^  int pyxr$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextinit wrapper 0$^  if unlikelypytuplegetsizepyxargs  0 $^    pyxraiseargtupleinvalidinit 0 0 0 pytuplegetsizepyxargs return 0$^  if unlikelypyxkwds  unlikelypydictsizepyxkwds  0  unlikelypyxcheckkeywordstringspyxkwds init 0 return 0$^  pyxr  pyxpf0pywrapfst0fst0initstruct pyxobj0pywrapfstfst pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static int pyxpf0pywrapfst0fst0initstruct pyxobj0pywrapfstfst pyxvself $^  int pyxr$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextinit 0$^$^   pywrapfst.pyx0000$^  $^    def initself$^      raise fstdeletedconstructorerror              $^          cannot construct .formatself.class.name$^  $^ $^  pyxt0  pyxgetmoduleglobalnamepyxnsfstdeletedconstructorerror if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^$^   pywrapfst.pyx0000$^    def initself$^      raise fstdeletedconstructorerror$^          cannot construct .formatself.class.name              $^  $^    def strself$^ $^  pyxt0  pyxpyobjectgetattrstrpyxkpscannotconstruct pyxnsformat if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnsclass if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxt0  pyxpyobjectgetattrstrpyxt0 pyxnsname if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxdecrefpyxt0 pyxt0  0$^  pyxt0  null$^  if cythonunpackmethods  likelypymethodcheckpyxt0 $^    pyxt0  pymethodgetselfpyxt0$^    if likelypyxt0 $^      pyobject function  pymethodgetfunctionpyxt0$^      pyxincrefpyxt0$^      pyxincreffunction$^      pyxdecrefsetpyxt0 function$^    $^  $^  if pyxt0 $^    pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxdecrefpyxt0 pyxt0  0$^    pyxgotrefpyxt0$^   else $^    if cythonfastpycall$^    if pyfunctioncheckpyxt0 $^      pyobject pyxtemp0  pyxt0 pyxt0$^      pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxxdecrefpyxt0 pyxt0  0$^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^     else$^    endif$^    if cythonfastpyccall$^    if pyxpyfastcfunctioncheckpyxt0 $^      pyobject pyxtemp0  pyxt0 pyxt0$^      pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxxdecrefpyxt0 pyxt0  0$^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^     else$^    endif$^    $^      pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxgotrefpyxt0$^      pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^      pyxgiverefpyxt0$^      pytuplesetitempyxt0 00 pyxt0$^      pyxt0  0$^      pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^    $^  $^  pyxdecrefpyxt0 pyxt0  0$^  pyxt0  null$^  if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^    pyxt0  pymethodgetselfpyxt0$^    if likelypyxt0 $^      pyobject function  pymethodgetfunctionpyxt0$^      pyxincrefpyxt0$^      pyxincreffunction$^      pyxdecrefsetpyxt0 function$^    $^  $^  if pyxt0 $^    pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxdecrefpyxt0 pyxt0  0$^    pyxgotrefpyxt0$^   else $^    if cythonfastpycall$^    if pyfunctioncheckpyxt0 $^      pyobject pyxtemp0  pyxt0 pyxt0$^      pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxxdecrefpyxt0 pyxt0  0$^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^     else$^    endif$^    if cythonfastpyccall$^    if pyxpyfastcfunctioncheckpyxt0 $^      pyobject pyxtemp0  pyxt0 pyxt0$^      pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxxdecrefpyxt0 pyxt0  0$^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^     else$^    endif$^    $^      pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxgotrefpyxt0$^      pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^      pyxgiverefpyxt0$^      pytuplesetitempyxt0 00 pyxt0$^      pyxt0  0$^      pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^    $^  $^  pyxdecrefpyxt0 pyxt0  0$^  pyxraisepyxt0 0 0 0$^  pyxdecrefpyxt0 pyxt0  0$^  pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^      return  fst at 0xx.formatself.fsttype idself$^  $^    def initself              $^      raise fstdeletedconstructorerror$^          cannot construct .formatself.class.name$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.fst.init pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^          cannot construct .formatself.class.name$^  $^    def strself              $^      return self.text$^  $^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst0fst0strpyobject pyxvself proto$^static pyobject pyxpw0pywrapfst0fst0strpyobject pyxvself $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextstr wrapper 0$^  pyxr  pyxpf0pywrapfst0fst0strstruct pyxobj0pywrapfstfst pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst0fst0strstruct pyxobj0pywrapfstfst pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextstr 0$^$^   pywrapfst.pyx0000$^  $^    def strself$^      return self.text              $^  $^     registers the class for pickling must be repeated in any subclass which$^ $^  pyxxdecrefpyxr$^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s text$^    pyxerr0 0000 pyxl0error$^  $^  pyxt0  pyxconvertpybytesstringtopystdinstringstruct pyxvtabstruct0pywrapfstfst pyxvselfpyxvtabtextpyxvself 0 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   pywrapfst.pyx0000$^          cannot construct .formatself.class.name$^  $^    def strself              $^      return self.text$^  $^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.fst.str pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^     cant be derived by initxfst.$^  $^    def reduceself              $^      return readfromstring self.writetostring$^  $^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst0fst0reducepyobject pyxvself cythonunused pyobject unused proto$^static pyobject pyxpw0pywrapfst0fst0reducepyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextreduce wrapper 0$^  pyxr  pyxpf0pywrapfst0fst0reducestruct pyxobj0pywrapfstfst pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst0fst0reducestruct pyxobj0pywrapfstfst pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextreduce 0$^$^   pywrapfst.pyx0000$^  $^    def reduceself$^      return readfromstring self.writetostring              $^  $^    cpdef string arctypeself$^ $^  pyxxdecrefpyxr$^  pyxt0  pyxgetmoduleglobalnamepyxnsreadfromstring if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s writetostring$^    pyxerr0 0000 pyxl0error$^  $^  pyxt0  pyxconvertpybytesstringtopystdinstringstruct pyxvtabstruct0pywrapfstfst pyxvselfpyxvtabwritetostringpyxvself 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxt0  pytuplenew0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxgiverefpyxt0$^  pytuplesetitempyxt0 0 pyxt0$^  pyxt0  0$^  pyxt0  pytuplenew0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxgiverefpyxt0$^  pytuplesetitempyxt0 0 pyxt0$^  pyxgiverefpyxt0$^  pytuplesetitempyxt0 0 pyxt0$^  pyxt0  0$^  pyxt0  0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   pywrapfst.pyx0000$^     cant be derived by initxfst.$^  $^    def reduceself              $^      return readfromstring self.writetostring$^  $^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.fst.reduce pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return readfromstring self.writetostring$^  $^    cpdef string arctypeself              $^      $^      arctypeself$^ $^$^static pyobject pyxpw0pywrapfst0fst00arctypepyobject pyxvself cythonunused pyobject unused proto$^static stdstring pyxf0pywrapfst0fstarctypestruct pyxobj0pywrapfstfst pyxvself int pyxskipdispatch $^  stdstring pyxr$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  stdstring pyxt0$^  pyxrefnannysetupcontextarctype 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnsarctype if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst0fst00arctype $^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxdecrefpyxt0 pyxt0  0$^       else $^        pyxt0  pyxpyobjectcallnoargpyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      $^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxt0  pyxconvertstringfrompystdinstringpyxt0 if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxr  pyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx0000$^      returns a string indicating the arc type.$^      $^      return self.fst.get.arctype              $^  $^    cpdef arciterator arcsself int00 state$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s fst$^    pyxerr0 0000 pyxl0error$^  $^  pyxr  pyxvselffst.getarctype$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      return readfromstring self.writetostring$^  $^    cpdef string arctypeself              $^      $^      arctypeself$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxwriteunraisablepywrapfst.fst.arctype pyxclineno pyxlineno pyxfilename 0 0$^  pyxpretendtoinitializepyxr$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst0fst00arctypepyobject pyxvself cythonunused pyobject unused proto$^static char pyxdoc0pywrapfst0fst00arctype  n    arctypeselfnn    returns a string indicating the arc type.n    $^static pyobject pyxpw0pywrapfst0fst00arctypepyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextarctype wrapper 0$^  pyxr  pyxpf0pywrapfst0fst00arctypestruct pyxobj0pywrapfstfst pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst0fst00arctypestruct pyxobj0pywrapfstfst pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextarctype 0$^  pyxxdecrefpyxr$^  pyxt0  pyxconvertpybytesstringtopystdinstringpyxf0pywrapfst0fstarctypepyxvself 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.fst.arctype pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return self.fst.get.arctype$^  $^    cpdef arciterator arcsself int00 state              $^      $^      arcsself state$^ $^$^static pyobject pyxpw0pywrapfst0fst00arcspyobject pyxvself pyobject pyxargstate proto$^static struct pyxobj0pywrapfstarciterator pyxf0pywrapfst0fstarcsstruct pyxobj0pywrapfstfst pyxvself pyxt00basictypesint00 pyxvstate int pyxskipdispatch $^  struct pyxobj0pywrapfstarciterator pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextarcs 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnsarcs if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst0fst00arcs $^      pyxxdecrefpyobject pyxr$^      pyxt0  pyxpyintfromint00tpyxvstate if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxgotrefpyxt0$^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^       else $^        if cythonfastpycall$^        if pyfunctioncheckpyxt0 $^          pyobject pyxtemp0  pyxt0 pyxt0$^          pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^          pyxxdecrefpyxt0 pyxt0  0$^          pyxgotrefpyxt0$^          pyxdecrefpyxt0 pyxt0  0$^         else$^        endif$^        if cythonfastpyccall$^        if pyxpyfastcfunctioncheckpyxt0 $^          pyobject pyxtemp0  pyxt0 pyxt0$^          pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^          pyxxdecrefpyxt0 pyxt0  0$^          pyxgotrefpyxt0$^          pyxdecrefpyxt0 pyxt0  0$^         else$^        endif$^        $^          pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^          pyxgotrefpyxt0$^          pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^          pyxgiverefpyxt0$^          pytuplesetitempyxt0 00 pyxt0$^          pyxt0  0$^          pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^          pyxgotrefpyxt0$^          pyxdecrefpyxt0 pyxt0  0$^        $^      $^      pyxdecrefpyxt0 pyxt0  0$^      if likelypyxt0  pynone  likelypyxtypetestpyxt0 pyxptype0pywrapfstarciterator pyxerr0 0000 pyxl0error$^      pyxr  struct pyxobj0pywrapfstarciterator pyxt0$^      pyxt0  0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx0000$^      see also mutablearcs states.$^      $^      return arciteratorself state              $^  $^    cpdef fst copyself$^ $^  pyxxdecrefpyobject pyxr$^  pyxt0  pyxpyintfromint00tpyxvstate if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxt0  pytuplenew0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxincrefpyobject pyxvself$^  pyxgiverefpyobject pyxvself$^  pytuplesetitempyxt0 0 pyobject pyxvself$^  pyxgiverefpyxt0$^  pytuplesetitempyxt0 0 pyxt0$^  pyxt0  0$^  pyxt0  pyxpyobjectcallpyobject pyxptype0pywrapfstarciterator pyxt0 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxdecrefpyxt0 pyxt0  0$^  pyxr  struct pyxobj0pywrapfstarciterator pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      return self.fst.get.arctype$^  $^    cpdef arciterator arcsself int00 state              $^      $^      arcsself state$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.fst.arcs pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxl0$^  pyxxgiverefpyobject pyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst0fst00arcspyobject pyxvself pyobject pyxargstate proto$^static char pyxdoc0pywrapfst0fst00arcs  n    arcsself statenn    returns an iterator over arcs leaving the specified state.nn    argsn      state the source state id.nn    returnsn      an arciterator.nn    see also mutablearcs states.n    $^static pyobject pyxpw0pywrapfst0fst00arcspyobject pyxvself pyobject pyxargstate $^  pyxt00basictypesint00 pyxvstate$^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextarcs wrapper 0$^  assertpyxargstate $^    pyxvstate  pyxpyintasint00tpyxargstate if unlikelypyxvstate  int00t0  pyerroccurred pyxerr0 0000 pyxl0error$^  $^  goto pyxl0argumentunpackingdone$^  pyxl0error$^  pyxaddtracebackpywrapfst.fst.arcs pyxclineno pyxlineno pyxfilename$^  pyxrefnannyfinishcontext$^  return null$^  pyxl0argumentunpackingdone$^  pyxr  pyxpf0pywrapfst0fst00arcsstruct pyxobj0pywrapfstfst pyxvself pyxt00basictypesint00pyxvstate$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst0fst00arcsstruct pyxobj0pywrapfstfst pyxvself pyxt00basictypesint00 pyxvstate $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextarcs 0$^  pyxxdecrefpyxr$^  pyxt0  pyobject pyxf0pywrapfst0fstarcspyxvself pyxvstate 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.fst.arcs pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return arciteratorself state$^  $^    cpdef fst copyself              $^      $^      copyself$^ $^$^static pyobject pyxpw0pywrapfst0fst00copypyobject pyxvself cythonunused pyobject unused proto$^static struct pyxobj0pywrapfstfst pyxf0pywrapfst0fstcopystruct pyxobj0pywrapfstfst pyxvself int pyxskipdispatch $^  struct pyxobj0pywrapfstfst pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextcopy 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnscopy if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst0fst00copy $^      pyxxdecrefpyobject pyxr$^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxdecrefpyxt0 pyxt0  0$^       else $^        pyxt0  pyxpyobjectcallnoargpyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      $^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      if likelypyxt0  pynone  likelypyxtypetestpyxt0 pyxptype0pywrapfstfst pyxerr0 0000 pyxl0error$^      pyxr  struct pyxobj0pywrapfstfst pyxt0$^      pyxt0  0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx0000$^      makes a copy of the fst.$^      $^      return initxfstnew fst.fstclassderefself.fst              $^  $^    cpdef void drawself$^ $^  pyxxdecrefpyobject pyxr$^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s fst$^    pyxerr0 0000 pyxl0error$^  $^  pyxt0  pyobject pyxf0pywrapfstinitxfstnew fstscriptfstclasspyxvselffst if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  struct pyxobj0pywrapfstfst pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      return arciteratorself state$^  $^    cpdef fst copyself              $^      $^      copyself$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.fst.copy pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxl0$^  pyxxgiverefpyobject pyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst0fst00copypyobject pyxvself cythonunused pyobject unused proto$^static char pyxdoc0pywrapfst0fst00copy  n    copyselfnn    makes a copy of the fst.n    $^static pyobject pyxpw0pywrapfst0fst00copypyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextcopy wrapper 0$^  pyxr  pyxpf0pywrapfst0fst00copystruct pyxobj0pywrapfstfst pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst0fst00copystruct pyxobj0pywrapfstfst pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextcopy 0$^  pyxxdecrefpyxr$^  pyxt0  pyobject pyxf0pywrapfst0fstcopypyxvself 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.fst.copy pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return initxfstnew fst.fstclassderefself.fst$^  $^    cpdef void drawself              $^                    filename$^                    symboltable isymbolsnone$^ $^$^static pyobject pyxpw0pywrapfst0fst00drawpyobject pyxvself pyobject pyxargs pyobject pyxkwds proto$^static void pyxf0pywrapfst0fstdrawstruct pyxobj0pywrapfstfst pyxvself pyobject pyxvfilename int pyxskipdispatch struct pyxoptargs0pywrapfst0fstdraw pyxoptionalargs $^$^   pywrapfst.pyx0000$^    cpdef void drawself$^                    filename$^                    symboltable isymbolsnone              $^                    symboltable osymbolsnone$^                    symboltable ssymbolsnone$^ $^  struct pyxobj0pywrapfstsymboltable pyxvisymbols  struct pyxobj0pywrapfstsymboltable pynone$^$^   pywrapfst.pyx0000$^                    filename$^                    symboltable isymbolsnone$^                    symboltable osymbolsnone              $^                    symboltable ssymbolsnone$^                    bool acceptorfalse$^ $^  struct pyxobj0pywrapfstsymboltable pyxvosymbols  struct pyxobj0pywrapfstsymboltable pynone$^$^   pywrapfst.pyx0000$^                    symboltable isymbolsnone$^                    symboltable osymbolsnone$^                    symboltable ssymbolsnone              $^                    bool acceptorfalse$^                    titleb$^ $^  struct pyxobj0pywrapfstsymboltable pyxvssymbols  struct pyxobj0pywrapfstsymboltable pynone$^$^   pywrapfst.pyx0000$^                    symboltable osymbolsnone$^                    symboltable ssymbolsnone$^                    bool acceptorfalse              $^                    titleb$^                    double width0.0$^ $^  bool pyxvacceptor  bool0$^  pyobject pyxvtitle  pyobject pyxkpb00$^  double pyxvwidth  double0.0$^  double pyxvheight  double00.0$^$^   pywrapfst.pyx0000$^                    double width0.0$^                    double height00$^                    bool portraitfalse              $^                    bool verticalfalse$^                    double ranksep0.0$^ $^  bool pyxvportrait  bool0$^$^   pywrapfst.pyx0000$^                    double height00$^                    bool portraitfalse$^                    bool verticalfalse              $^                    double ranksep0.0$^                    double nodesep0.00$^ $^  bool pyxvvertical  bool0$^  double pyxvranksep  double0.0$^  double pyxvnodesep  double0.00$^  pyxt00basictypesint00 pyxvfontsize  pyxt00basictypesint0000$^  pyxt00basictypesint00 pyxvprecision  pyxt00basictypesint000$^  pyobject pyxvfloatformat  pyobject pyxnbg$^$^   pywrapfst.pyx0000$^                    int00 precision0$^                    floatformatbg$^                    bool showweightonefalse              $^      $^      drawself filename isymbolsnone osymbolsnone ssymbolsnone$^ $^  bool pyxvshowweightone  bool0$^  stdstring pyxvfilenamestring$^  stduniqueptrstdofstream  pyxvostrm$^  fstsymboltable pyxvssymbolsptr$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt00  null$^  pyobject pyxt00  null$^  pyobject pyxt00  null$^  pyobject pyxt00  null$^  pyobject pyxt00  null$^  int pyxt00$^  pyobject pyxt00  null$^  stdstring pyxt00$^  int pyxt00$^  int pyxt00$^  fstsymboltable pyxt00$^  fstsymboltable const pyxt00$^  fstsymboltable const pyxt00$^  stdstring pyxt00$^  pyxrefnannysetupcontextdraw 0$^  if pyxoptionalargs $^    if pyxoptionalargspyxn  0 $^      pyxvisymbols  pyxoptionalargsisymbols$^      if pyxoptionalargspyxn  0 $^        pyxvosymbols  pyxoptionalargsosymbols$^        if pyxoptionalargspyxn  0 $^          pyxvssymbols  pyxoptionalargsssymbols$^          if pyxoptionalargspyxn  0 $^            pyxvacceptor  pyxoptionalargsacceptor$^            if pyxoptionalargspyxn  0 $^              pyxvtitle  pyxoptionalargstitle$^              if pyxoptionalargspyxn  0 $^                pyxvwidth  pyxoptionalargswidth$^                if pyxoptionalargspyxn  0 $^                  pyxvheight  pyxoptionalargsheight$^                  if pyxoptionalargspyxn  0 $^                    pyxvportrait  pyxoptionalargsportrait$^                    if pyxoptionalargspyxn  0 $^                      pyxvvertical  pyxoptionalargsvertical$^                      if pyxoptionalargspyxn  0 $^                        pyxvranksep  pyxoptionalargsranksep$^                        if pyxoptionalargspyxn  00 $^                          pyxvnodesep  pyxoptionalargsnodesep$^                          if pyxoptionalargspyxn  00 $^                            pyxvfontsize  pyxoptionalargsfontsize$^                            if pyxoptionalargspyxn  00 $^                              pyxvprecision  pyxoptionalargsprecision$^                              if pyxoptionalargspyxn  00 $^                                pyxvfloatformat  pyxoptionalargsfloatformat$^                                if pyxoptionalargspyxn  00 $^                                  pyxvshowweightone  pyxoptionalargsshowweightone$^                                $^                              $^                            $^                          $^                        $^                      $^                    $^                  $^                $^              $^            $^          $^        $^      $^    $^  $^$^   pywrapfst.pyx0000$^      return initxfstnew fst.fstclassderefself.fst$^  $^    cpdef void drawself              $^                    filename$^                    symboltable isymbolsnone$^ $^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnsdraw if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst0fst00draw $^      pyxt0  pyxpyboolfromlongpyxvacceptor if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxgotrefpyxt0$^      pyxt0  pyfloatfromdoublepyxvwidth if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxgotrefpyxt0$^      pyxt0  pyfloatfromdoublepyxvheight if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxgotrefpyxt0$^      pyxt0  pyxpyboolfromlongpyxvportrait if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxgotrefpyxt0$^      pyxt0  pyxpyboolfromlongpyxvvertical if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxgotrefpyxt0$^      pyxt0  pyfloatfromdoublepyxvranksep if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxgotrefpyxt0$^      pyxt0  pyfloatfromdoublepyxvnodesep if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxgotrefpyxt0$^      pyxt00  pyxpyintfromint00tpyxvfontsize if unlikelypyxt00 pyxerr0 0000 pyxl0error$^      pyxgotrefpyxt00$^      pyxt00  pyxpyintfromint00tpyxvprecision if unlikelypyxt00 pyxerr0 0000 pyxl0error$^      pyxgotrefpyxt00$^      pyxt00  pyxpyboolfromlongpyxvshowweightone if unlikelypyxt00 pyxerr0 0000 pyxl0error$^      pyxgotrefpyxt00$^      pyxincrefpyxt0$^      pyxt00  pyxt0 pyxt00  null$^      pyxt00  0$^      if cythonunpackmethods  unlikelypymethodcheckpyxt00 $^        pyxt00  pymethodgetselfpyxt00$^        if likelypyxt00 $^          pyobject function  pymethodgetfunctionpyxt00$^          pyxincrefpyxt00$^          pyxincreffunction$^          pyxdecrefsetpyxt00 function$^          pyxt00  0$^        $^      $^      if cythonfastpycall$^      if pyfunctioncheckpyxt00 $^        pyobject pyxtemp00  pyxt00 pyxvfilename pyobject pyxvisymbols pyobject pyxvosymbols pyobject pyxvssymbols pyxt0 pyxvtitle pyxt0 pyxt0 pyxt0 pyxt0 pyxt0 pyxt0 pyxt00 pyxt00 pyxvfloatformat pyxt00$^        pyxt0  pyxpyfunctionfastcallpyxt00 pyxtemp0pyxt00 00pyxt00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxxdecrefpyxt00 pyxt00  0$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^        pyxdecrefpyxt0 pyxt0  0$^        pyxdecrefpyxt0 pyxt0  0$^        pyxdecrefpyxt0 pyxt0  0$^        pyxdecrefpyxt0 pyxt0  0$^        pyxdecrefpyxt0 pyxt0  0$^        pyxdecrefpyxt0 pyxt0  0$^        pyxdecrefpyxt00 pyxt00  0$^        pyxdecrefpyxt00 pyxt00  0$^        pyxdecrefpyxt00 pyxt00  0$^       else$^      endif$^      if cythonfastpyccall$^      if pyxpyfastcfunctioncheckpyxt00 $^        pyobject pyxtemp00  pyxt00 pyxvfilename pyobject pyxvisymbols pyobject pyxvosymbols pyobject pyxvssymbols pyxt0 pyxvtitle pyxt0 pyxt0 pyxt0 pyxt0 pyxt0 pyxt0 pyxt00 pyxt00 pyxvfloatformat pyxt00$^        pyxt0  pyxpycfunctionfastcallpyxt00 pyxtemp0pyxt00 00pyxt00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxxdecrefpyxt00 pyxt00  0$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^        pyxdecrefpyxt0 pyxt0  0$^        pyxdecrefpyxt0 pyxt0  0$^        pyxdecrefpyxt0 pyxt0  0$^        pyxdecrefpyxt0 pyxt0  0$^        pyxdecrefpyxt0 pyxt0  0$^        pyxdecrefpyxt0 pyxt0  0$^        pyxdecrefpyxt00 pyxt00  0$^        pyxdecrefpyxt00 pyxt00  0$^        pyxdecrefpyxt00 pyxt00  0$^       else$^      endif$^      $^        pyxt00  pytuplenew00pyxt00 if unlikelypyxt00 pyxerr0 0000 pyxl0error$^        pyxgotrefpyxt00$^        if pyxt00 $^          pyxgiverefpyxt00 pytuplesetitempyxt00 0 pyxt00 pyxt00  null$^        $^        pyxincrefpyxvfilename$^        pyxgiverefpyxvfilename$^        pytuplesetitempyxt00 0pyxt00 pyxvfilename$^        pyxincrefpyobject pyxvisymbols$^        pyxgiverefpyobject pyxvisymbols$^        pytuplesetitempyxt00 0pyxt00 pyobject pyxvisymbols$^        pyxincrefpyobject pyxvosymbols$^        pyxgiverefpyobject pyxvosymbols$^        pytuplesetitempyxt00 0pyxt00 pyobject pyxvosymbols$^        pyxincrefpyobject pyxvssymbols$^        pyxgiverefpyobject pyxvssymbols$^        pytuplesetitempyxt00 0pyxt00 pyobject pyxvssymbols$^        pyxgiverefpyxt0$^        pytuplesetitempyxt00 0pyxt00 pyxt0$^        pyxincrefpyxvtitle$^        pyxgiverefpyxvtitle$^        pytuplesetitempyxt00 0pyxt00 pyxvtitle$^        pyxgiverefpyxt0$^        pytuplesetitempyxt00 0pyxt00 pyxt0$^        pyxgiverefpyxt0$^        pytuplesetitempyxt00 0pyxt00 pyxt0$^        pyxgiverefpyxt0$^        pytuplesetitempyxt00 0pyxt00 pyxt0$^        pyxgiverefpyxt0$^        pytuplesetitempyxt00 0pyxt00 pyxt0$^        pyxgiverefpyxt0$^        pytuplesetitempyxt00 00pyxt00 pyxt0$^        pyxgiverefpyxt0$^        pytuplesetitempyxt00 00pyxt00 pyxt0$^        pyxgiverefpyxt00$^        pytuplesetitempyxt00 00pyxt00 pyxt00$^        pyxgiverefpyxt00$^        pytuplesetitempyxt00 00pyxt00 pyxt00$^        pyxincrefpyxvfloatformat$^        pyxgiverefpyxvfloatformat$^        pytuplesetitempyxt00 00pyxt00 pyxvfloatformat$^        pyxgiverefpyxt00$^        pytuplesetitempyxt00 00pyxt00 pyxt00$^        pyxt0  0$^        pyxt0  0$^        pyxt0  0$^        pyxt0  0$^        pyxt0  0$^        pyxt0  0$^        pyxt0  0$^        pyxt00  0$^        pyxt00  0$^        pyxt00  0$^        pyxt0  pyxpyobjectcallpyxt00 pyxt00 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxgotrefpyxt0$^        pyxdecrefpyxt00 pyxt00  0$^      $^      pyxdecrefpyxt00 pyxt00  0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx0000$^      see also text.$^      $^      cdef string filenamestring  tostringfilename              $^      cdef uniqueptrofstream ostrm$^      ostrm.resetnew ofstreamfilenamestring$^ $^  pyxt00  pyxf0pywrapfsttostringpyxvfilename null if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^  pyxvfilenamestring  pyxt00$^$^   pywrapfst.pyx0000$^      cdef string filenamestring  tostringfilename$^      cdef uniqueptrofstream ostrm$^      ostrm.resetnew ofstreamfilenamestring              $^      cdef fst.symboltable ssymbolsptr  null$^      if ssymbols is not none$^ $^  pyxvostrm.resetnew stdofstreampyxvfilenamestring$^$^   pywrapfst.pyx0000$^      cdef uniqueptrofstream ostrm$^      ostrm.resetnew ofstreamfilenamestring$^      cdef fst.symboltable ssymbolsptr  null              $^      if ssymbols is not none$^        ssymbolsptr  ssymbols.table$^ $^  pyxvssymbolsptr  null$^$^   pywrapfst.pyx0000$^      ostrm.resetnew ofstreamfilenamestring$^      cdef fst.symboltable ssymbolsptr  null$^      if ssymbols is not none              $^        ssymbolsptr  ssymbols.table$^      fst.drawfstderefself.fst$^ $^  pyxt00  pyobject pyxvssymbols  pynone$^  pyxt00  pyxt00  0$^  if pyxt00 $^$^     pywrapfst.pyx0000$^      cdef fst.symboltable ssymbolsptr  null$^      if ssymbols is not none$^        ssymbolsptr  ssymbols.table              $^      fst.drawfstderefself.fst$^          self.fst.get.inputsymbols if isymbols is none$^ $^    if unlikelypyobject pyxvssymbols  pynone $^      pyerrformatpyexcattributeerror nonetype object has no attribute .00s table$^      pyxerr0 0000 pyxl0error$^    $^    pyxt00  pyxvssymbolspyxbase.pyxbase.table$^    pyxvssymbolsptr  pyxt00$^$^     pywrapfst.pyx0000$^      ostrm.resetnew ofstreamfilenamestring$^      cdef fst.symboltable ssymbolsptr  null$^      if ssymbols is not none              $^        ssymbolsptr  ssymbols.table$^      fst.drawfstderefself.fst$^ $^  $^$^   pywrapfst.pyx0000$^      if ssymbols is not none$^        ssymbolsptr  ssymbols.table$^      fst.drawfstderefself.fst              $^          self.fst.get.inputsymbols if isymbols is none$^          else isymbols.table$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s fst$^    pyxerr0 0000 pyxl0error$^  $^$^   pywrapfst.pyx0000$^        ssymbolsptr  ssymbols.table$^      fst.drawfstderefself.fst$^          self.fst.get.inputsymbols if isymbols is none              $^          else isymbols.table$^          self.fst.get.outputsymbols if osymbols is none$^ $^  pyxt00  pyobject pyxvisymbols  pynone$^  if pyxt00  0 $^    if unlikelypyobject pyxvself  pynone $^      pyerrformatpyexcattributeerror nonetype object has no attribute .00s fst$^      pyxerr0 0000 pyxl0error$^    $^    pyxt00  pyxvselffst.getinputsymbols$^   else $^$^     pywrapfst.pyx0000$^      fst.drawfstderefself.fst$^          self.fst.get.inputsymbols if isymbols is none$^          else isymbols.table              $^          self.fst.get.outputsymbols if osymbols is none$^          else osymbols.table$^ $^    if unlikelypyobject pyxvisymbols  pynone $^      pyerrformatpyexcattributeerror nonetype object has no attribute .00s table$^      pyxerr0 0000 pyxl0error$^    $^    pyxt00  pyxvisymbolstable$^  $^$^   pywrapfst.pyx0000$^          self.fst.get.inputsymbols if isymbols is none$^          else isymbols.table$^          self.fst.get.outputsymbols if osymbols is none              $^          else osymbols.table$^          ssymbolsptr acceptor tostringtitle width height portrait$^ $^  pyxt00  pyobject pyxvosymbols  pynone$^  if pyxt00  0 $^    if unlikelypyobject pyxvself  pynone $^      pyerrformatpyexcattributeerror nonetype object has no attribute .00s fst$^      pyxerr0 0000 pyxl0error$^    $^    pyxt00  pyxvselffst.getoutputsymbols$^   else $^$^     pywrapfst.pyx0000$^          else isymbols.table$^          self.fst.get.outputsymbols if osymbols is none$^          else osymbols.table              $^          ssymbolsptr acceptor tostringtitle width height portrait$^          vertical ranksep nodesep fontsize precision$^ $^    if unlikelypyobject pyxvosymbols  pynone $^      pyerrformatpyexcattributeerror nonetype object has no attribute .00s table$^      pyxerr0 0000 pyxl0error$^    $^    pyxt00  pyxvosymbolstable$^  $^$^   pywrapfst.pyx0000$^          self.fst.get.outputsymbols if osymbols is none$^          else osymbols.table$^          ssymbolsptr acceptor tostringtitle width height portrait              $^          vertical ranksep nodesep fontsize precision$^          tostringfloatformat showweightone ostrm.get$^ $^  pyxt00  pyxf0pywrapfsttostringpyxvtitle null if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^          ssymbolsptr acceptor tostringtitle width height portrait$^          vertical ranksep nodesep fontsize precision$^          tostringfloatformat showweightone ostrm.get              $^          filenamestring$^  $^ $^  pyxt00  pyxf0pywrapfsttostringpyxvfloatformat null if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^      if ssymbols is not none$^        ssymbolsptr  ssymbols.table$^      fst.drawfstderefself.fst              $^          self.fst.get.inputsymbols if isymbols is none$^          else isymbols.table$^ $^  fstscriptdrawfstpyxvselffst pyxt00 pyxt00 pyxvssymbolsptr pyxvacceptor pyxt00 pyxvwidth pyxvheight pyxvportrait pyxvvertical pyxvranksep pyxvnodesep pyxvfontsize pyxvprecision pyxt00 pyxvshowweightone pyxvostrm.get pyxvfilenamestring$^$^   pywrapfst.pyx0000$^      return initxfstnew fst.fstclassderefself.fst$^  $^    cpdef void drawself              $^                    filename$^                    symboltable isymbolsnone$^ $^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt00$^  pyxxdecrefpyxt00$^  pyxxdecrefpyxt00$^  pyxxdecrefpyxt00$^  pyxxdecrefpyxt00$^  pyxxdecrefpyxt00$^  pyxwriteunraisablepywrapfst.fst.draw pyxclineno pyxlineno pyxfilename 0 0$^  pyxl0$^  pyxrefnannyfinishcontext$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst0fst00drawpyobject pyxvself pyobject pyxargs pyobject pyxkwds proto$^static char pyxdoc0pywrapfst0fst00draw  n    drawself filename isymbolsnone osymbolsnone ssymbolsnonen         acceptorfalse title width0.0 height00 portraitfalsen         verticalfalse ranksep0.0 nodesep0.00 fontsize00n         precision0 floatformatg showweightonefalsenn    writes out the fst in graphviz text format.nn    this method writes out the fst in the dot graph description language. then    graph can be rendered using the dot executable provided by graphviz.nn    argsn      filename the string location of the output dotgraphviz file.n      isymbols an optional symbol table used to label input symbols.n      osymbols an optional symbol table used to label output symbols.n      ssymbols an optional symbol table used to label states.n      acceptor should the figure be rendered in acceptor format if possiblen      title an optional string indicating the figure title.n      width the figure width in inches.n      height the figure height in inches.n      portrait should the figure be rendered in portrait rather thann          landscapen      vertical should the figure be rendered bottomtotop rather thann          lefttorightn      ranksep the minimum separation separation between ranks in inches.n      nodesep the minimum separation between nodes in inches.n      fontsize font size in points.n      precision numeric precision for floats in number of chars.n      floatformat one of e f or g.n      showweightone should weights equivalent to semiring one be printednn    see also text.n    $^static pyobject pyxpw0pywrapfst0fst00drawpyobject pyxvself pyobject pyxargs pyobject pyxkwds $^  pyobject pyxvfilename  0$^  struct pyxobj0pywrapfstsymboltable pyxvisymbols  0$^  struct pyxobj0pywrapfstsymboltable pyxvosymbols  0$^  struct pyxobj0pywrapfstsymboltable pyxvssymbols  0$^  bool pyxvacceptor$^  pyobject pyxvtitle  0$^  double pyxvwidth$^  double pyxvheight$^  bool pyxvportrait$^  bool pyxvvertical$^  double pyxvranksep$^  double pyxvnodesep$^  pyxt00basictypesint00 pyxvfontsize$^  pyxt00basictypesint00 pyxvprecision$^  pyobject pyxvfloatformat  0$^  bool pyxvshowweightone$^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextdraw wrapper 0$^  $^    static pyobject pyxpyargnames  pyxnsfilenamepyxnsisymbolspyxnsosymbolspyxnsssymbolspyxnsacceptorpyxnstitlepyxnswidthpyxnsheightpyxnsportraitpyxnsverticalpyxnsrankseppyxnsnodeseppyxnsfontsizepyxnsprecisionpyxnsfloatformatpyxnsshowweightone0$^    pyobject values00  0000000000000000$^$^     pywrapfst.pyx0000$^    cpdef void drawself$^                    filename$^                    symboltable isymbolsnone              $^                    symboltable osymbolsnone$^                    symboltable ssymbolsnone$^ $^    values0  pyobject struct pyxobj0pywrapfstsymboltable pynone$^$^     pywrapfst.pyx0000$^                    filename$^                    symboltable isymbolsnone$^                    symboltable osymbolsnone              $^                    symboltable ssymbolsnone$^                    bool acceptorfalse$^ $^    values0  pyobject struct pyxobj0pywrapfstsymboltable pynone$^$^     pywrapfst.pyx0000$^                    symboltable isymbolsnone$^                    symboltable osymbolsnone$^                    symboltable ssymbolsnone              $^                    bool acceptorfalse$^                    titleb$^ $^    values0  pyobject struct pyxobj0pywrapfstsymboltable pynone$^    values0  pyobject pyxkpb00$^    values00  pyobject pyxnbg$^    if unlikelypyxkwds $^      pyssizet kwargs$^      const pyssizet posargs  pytuplegetsizepyxargs$^      switch posargs $^        case 00 values00  pytuplegetitempyxargs 00$^        cythonfallthrough$^        case 00 values00  pytuplegetitempyxargs 00$^        cythonfallthrough$^        case 00 values00  pytuplegetitempyxargs 00$^        cythonfallthrough$^        case 00 values00  pytuplegetitempyxargs 00$^        cythonfallthrough$^        case 00 values00  pytuplegetitempyxargs 00$^        cythonfallthrough$^        case 00 values00  pytuplegetitempyxargs 00$^        cythonfallthrough$^        case 00 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 break$^        default goto pyxl0argtupleerror$^      $^      kwargs  pydictsizepyxkwds$^      switch posargs $^        case  0$^        if likelyvalues0  pyxpydictgetitemstrpyxkwds pyxnsfilename  0 kwargs$^        else goto pyxl0argtupleerror$^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnsisymbols$^          if value  values0  value kwargs $^        $^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnsosymbols$^          if value  values0  value kwargs $^        $^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnsssymbols$^          if value  values0  value kwargs $^        $^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnsacceptor$^          if value  values0  value kwargs $^        $^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnstitle$^          if value  values0  value kwargs $^        $^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnswidth$^          if value  values0  value kwargs $^        $^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnsheight$^          if value  values0  value kwargs $^        $^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnsportrait$^          if value  values0  value kwargs $^        $^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnsvertical$^          if value  values0  value kwargs $^        $^        cythonfallthrough$^        case 00$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnsranksep$^          if value  values00  value kwargs $^        $^        cythonfallthrough$^        case 00$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnsnodesep$^          if value  values00  value kwargs $^        $^        cythonfallthrough$^        case 00$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnsfontsize$^          if value  values00  value kwargs $^        $^        cythonfallthrough$^        case 00$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnsprecision$^          if value  values00  value kwargs $^        $^        cythonfallthrough$^        case 00$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnsfloatformat$^          if value  values00  value kwargs $^        $^        cythonfallthrough$^        case 00$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnsshowweightone$^          if value  values00  value kwargs $^        $^      $^      if unlikelykwargs  0 $^        if unlikelypyxparseoptionalkeywordspyxkwds pyxpyargnames 0 values posargs draw  0 pyxerr0 0000 pyxl0error$^      $^     else $^      switch pytuplegetsizepyxargs $^        case 00 values00  pytuplegetitempyxargs 00$^        cythonfallthrough$^        case 00 values00  pytuplegetitempyxargs 00$^        cythonfallthrough$^        case 00 values00  pytuplegetitempyxargs 00$^        cythonfallthrough$^        case 00 values00  pytuplegetitempyxargs 00$^        cythonfallthrough$^        case 00 values00  pytuplegetitempyxargs 00$^        cythonfallthrough$^        case 00 values00  pytuplegetitempyxargs 00$^        cythonfallthrough$^        case 00 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        break$^        default goto pyxl0argtupleerror$^      $^    $^    pyxvfilename  values0$^    pyxvisymbols  struct pyxobj0pywrapfstsymboltable values0$^    pyxvosymbols  struct pyxobj0pywrapfstsymboltable values0$^    pyxvssymbols  struct pyxobj0pywrapfstsymboltable values0$^    if values0 $^      pyxvacceptor  pyxpyobjectistruevalues0 if unlikelypyxvacceptor  bool0  pyerroccurred pyxerr0 0000 pyxl0error$^     else $^$^       pywrapfst.pyx0000$^                    symboltable osymbolsnone$^                    symboltable ssymbolsnone$^                    bool acceptorfalse              $^                    titleb$^                    double width0.0$^ $^      pyxvacceptor  bool0$^    $^    pyxvtitle  values0$^    if values0 $^      pyxvwidth  pyxpyfloatasdoublevalues0 if unlikelypyxvwidth  double0  pyerroccurred pyxerr0 0000 pyxl0error$^     else $^      pyxvwidth  double0.0$^    $^    if values0 $^      pyxvheight  pyxpyfloatasdoublevalues0 if unlikelypyxvheight  double0  pyerroccurred pyxerr0 0000 pyxl0error$^     else $^      pyxvheight  double00.0$^    $^    if values0 $^      pyxvportrait  pyxpyobjectistruevalues0 if unlikelypyxvportrait  bool0  pyerroccurred pyxerr0 0000 pyxl0error$^     else $^$^       pywrapfst.pyx0000$^                    double width0.0$^                    double height00$^                    bool portraitfalse              $^                    bool verticalfalse$^                    double ranksep0.0$^ $^      pyxvportrait  bool0$^    $^    if values0 $^      pyxvvertical  pyxpyobjectistruevalues0 if unlikelypyxvvertical  bool0  pyerroccurred pyxerr0 0000 pyxl0error$^     else $^$^       pywrapfst.pyx0000$^                    double height00$^                    bool portraitfalse$^                    bool verticalfalse              $^                    double ranksep0.0$^                    double nodesep0.00$^ $^      pyxvvertical  bool0$^    $^    if values00 $^      pyxvranksep  pyxpyfloatasdoublevalues00 if unlikelypyxvranksep  double0  pyerroccurred pyxerr0 0000 pyxl0error$^     else $^      pyxvranksep  double0.0$^    $^    if values00 $^      pyxvnodesep  pyxpyfloatasdoublevalues00 if unlikelypyxvnodesep  double0  pyerroccurred pyxerr0 0000 pyxl0error$^     else $^      pyxvnodesep  double0.00$^    $^    if values00 $^      pyxvfontsize  pyxpyintasint00tvalues00 if unlikelypyxvfontsize  int00t0  pyerroccurred pyxerr0 0000 pyxl0error$^     else $^      pyxvfontsize  pyxt00basictypesint0000$^    $^    if values00 $^      pyxvprecision  pyxpyintasint00tvalues00 if unlikelypyxvprecision  int00t0  pyerroccurred pyxerr0 0000 pyxl0error$^     else $^      pyxvprecision  pyxt00basictypesint000$^    $^    pyxvfloatformat  values00$^    if values00 $^      pyxvshowweightone  pyxpyobjectistruevalues00 if unlikelypyxvshowweightone  bool0  pyerroccurred pyxerr0 0000 pyxl0error$^     else $^$^       pywrapfst.pyx0000$^                    int00 precision0$^                    floatformatbg$^                    bool showweightonefalse              $^      $^      drawself filename isymbolsnone osymbolsnone ssymbolsnone$^ $^      pyxvshowweightone  bool0$^    $^  $^  goto pyxl0argumentunpackingdone$^  pyxl0argtupleerror$^  pyxraiseargtupleinvaliddraw 0 0 00 pytuplegetsizepyxargs pyxerr0 0000 pyxl0error$^  pyxl0error$^  pyxaddtracebackpywrapfst.fst.draw pyxclineno pyxlineno pyxfilename$^  pyxrefnannyfinishcontext$^  return null$^  pyxl0argumentunpackingdone$^  if unlikelypyxargtypetestpyobject pyxvisymbols pyxptype0pywrapfstsymboltable 0 isymbols 0 pyxerr0 0000 pyxl0error$^  if unlikelypyxargtypetestpyobject pyxvosymbols pyxptype0pywrapfstsymboltable 0 osymbols 0 pyxerr0 0000 pyxl0error$^  if unlikelypyxargtypetestpyobject pyxvssymbols pyxptype0pywrapfstsymboltable 0 ssymbols 0 pyxerr0 0000 pyxl0error$^  pyxr  pyxpf0pywrapfst0fst00drawstruct pyxobj0pywrapfstfst pyxvself pyxvfilename pyxvisymbols pyxvosymbols pyxvssymbols pyxvacceptor pyxvtitle pyxvwidth pyxvheight pyxvportrait pyxvvertical pyxvranksep pyxvnodesep pyxvfontsize pyxvprecision pyxvfloatformat pyxvshowweightone$^$^   pywrapfst.pyx0000$^      return initxfstnew fst.fstclassderefself.fst$^  $^    cpdef void drawself              $^                    filename$^                    symboltable isymbolsnone$^ $^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxr  null$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst0fst00drawstruct pyxobj0pywrapfstfst pyxvself pyobject pyxvfilename struct pyxobj0pywrapfstsymboltable pyxvisymbols struct pyxobj0pywrapfstsymboltable pyxvosymbols struct pyxobj0pywrapfstsymboltable pyxvssymbols bool pyxvacceptor pyobject pyxvtitle double pyxvwidth double pyxvheight bool pyxvportrait bool pyxvvertical double pyxvranksep double pyxvnodesep pyxt00basictypesint00 pyxvfontsize pyxt00basictypesint00 pyxvprecision pyobject pyxvfloatformat bool pyxvshowweightone $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  struct pyxoptargs0pywrapfst0fstdraw pyxt0$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextdraw 0$^  pyxxdecrefpyxr$^  pyxt0.pyxn  00$^  pyxt0.isymbols  pyxvisymbols$^  pyxt0.osymbols  pyxvosymbols$^  pyxt0.ssymbols  pyxvssymbols$^  pyxt0.acceptor  pyxvacceptor$^  pyxt0.title  pyxvtitle$^  pyxt0.width  pyxvwidth$^  pyxt0.height  pyxvheight$^  pyxt0.portrait  pyxvportrait$^  pyxt0.vertical  pyxvvertical$^  pyxt0.ranksep  pyxvranksep$^  pyxt0.nodesep  pyxvnodesep$^  pyxt0.fontsize  pyxvfontsize$^  pyxt0.precision  pyxvprecision$^  pyxt0.floatformat  pyxvfloatformat$^  pyxt0.showweightone  pyxvshowweightone$^  pyxvtabptr0pywrapfstfstdrawpyxvself pyxvfilename 0 pyxt0 $^  pyxt0  pyxvoidtononenull if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.fst.draw pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^          filenamestring$^  $^    cpdef weight finalself int00 state              $^      $^      finalself state$^ $^$^static pyobject pyxpw0pywrapfst0fst00finalpyobject pyxvself pyobject pyxargstate proto$^static struct pyxobj0pywrapfstweight pyxf0pywrapfst0fstfinalstruct pyxobj0pywrapfstfst pyxvself pyxt00basictypesint00 pyxvstate int pyxskipdispatch $^  struct pyxobj0pywrapfstweight pyxvweight  0$^  struct pyxobj0pywrapfstweight pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextfinal 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnsfinal if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst0fst00final $^      pyxxdecrefpyobject pyxr$^      pyxt0  pyxpyintfromint00tpyxvstate if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxgotrefpyxt0$^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^       else $^        if cythonfastpycall$^        if pyfunctioncheckpyxt0 $^          pyobject pyxtemp0  pyxt0 pyxt0$^          pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^          pyxxdecrefpyxt0 pyxt0  0$^          pyxgotrefpyxt0$^          pyxdecrefpyxt0 pyxt0  0$^         else$^        endif$^        if cythonfastpyccall$^        if pyxpyfastcfunctioncheckpyxt0 $^          pyobject pyxtemp0  pyxt0 pyxt0$^          pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^          pyxxdecrefpyxt0 pyxt0  0$^          pyxgotrefpyxt0$^          pyxdecrefpyxt0 pyxt0  0$^         else$^        endif$^        $^          pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^          pyxgotrefpyxt0$^          pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^          pyxgiverefpyxt0$^          pytuplesetitempyxt0 00 pyxt0$^          pyxt0  0$^          pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^          pyxgotrefpyxt0$^          pyxdecrefpyxt0 pyxt0  0$^        $^      $^      pyxdecrefpyxt0 pyxt0  0$^      if likelypyxt0  pynone  likelypyxtypetestpyxt0 pyxptype0pywrapfstweight pyxerr0 0000 pyxl0error$^      pyxr  struct pyxobj0pywrapfstweight pyxt0$^      pyxt0  0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx0000$^        fstindexerror state index out of range.$^      $^      cdef weight weight  weight.newweight              $^      weight.weight.resetnew fst.weightclassself.fst.get.finalstate$^      return weight$^ $^  pyxt0  pyobject pyxtpnew0pywrapfstweightpytypeobject pyxptype0pywrapfstweight pyxemptytuple null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyobject pyxt0$^  pyxvweight  struct pyxobj0pywrapfstweight pyxt0$^  pyxt0  0$^$^   pywrapfst.pyx0000$^      $^      cdef weight weight  weight.newweight$^      weight.weight.resetnew fst.weightclassself.fst.get.finalstate              $^      return weight$^  $^ $^  if unlikelypyobject pyxvweight  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s weight$^    pyxerr0 0000 pyxl0error$^  $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s fst$^    pyxerr0 0000 pyxl0error$^  $^  pyxvweightweight.resetnew fstscriptweightclasspyxvselffst.getfinalpyxvstate$^$^   pywrapfst.pyx0000$^      cdef weight weight  weight.newweight$^      weight.weight.resetnew fst.weightclassself.fst.get.finalstate$^      return weight              $^  $^    cpdef string fsttypeself$^ $^  pyxxdecrefpyobject pyxr$^  pyxincrefpyobject pyxvweight$^  pyxr  pyxvweight$^  goto pyxl0$^$^   pywrapfst.pyx0000$^          filenamestring$^  $^    cpdef weight finalself int00 state              $^      $^      finalself state$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.fst.final pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxl0$^  pyxxdecrefpyobject pyxvweight$^  pyxxgiverefpyobject pyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst0fst00finalpyobject pyxvself pyobject pyxargstate proto$^static char pyxdoc0pywrapfst0fst00final  n    finalself statenn    returns the final weight of a state.nn    argsn      state the integer index of a state.nn    returnsn      the final weight of that state.nn    raisesn      fstindexerror state index out of range.n    $^static pyobject pyxpw0pywrapfst0fst00finalpyobject pyxvself pyobject pyxargstate $^  pyxt00basictypesint00 pyxvstate$^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextfinal wrapper 0$^  assertpyxargstate $^    pyxvstate  pyxpyintasint00tpyxargstate if unlikelypyxvstate  int00t0  pyerroccurred pyxerr0 0000 pyxl0error$^  $^  goto pyxl0argumentunpackingdone$^  pyxl0error$^  pyxaddtracebackpywrapfst.fst.final pyxclineno pyxlineno pyxfilename$^  pyxrefnannyfinishcontext$^  return null$^  pyxl0argumentunpackingdone$^  pyxr  pyxpf0pywrapfst0fst00finalstruct pyxobj0pywrapfstfst pyxvself pyxt00basictypesint00pyxvstate$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst0fst00finalstruct pyxobj0pywrapfstfst pyxvself pyxt00basictypesint00 pyxvstate $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextfinal 0$^  pyxxdecrefpyxr$^  pyxt0  pyobject pyxf0pywrapfst0fstfinalpyxvself pyxvstate 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.fst.final pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return weight$^  $^    cpdef string fsttypeself              $^      $^      fsttypeself$^ $^$^static pyobject pyxpw0pywrapfst0fst00fsttypepyobject pyxvself cythonunused pyobject unused proto$^static stdstring pyxf0pywrapfst0fstfsttypestruct pyxobj0pywrapfstfst pyxvself int pyxskipdispatch $^  stdstring pyxr$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  stdstring pyxt0$^  pyxrefnannysetupcontextfsttype 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnsfsttype if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst0fst00fsttype $^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxdecrefpyxt0 pyxt0  0$^       else $^        pyxt0  pyxpyobjectcallnoargpyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      $^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxt0  pyxconvertstringfrompystdinstringpyxt0 if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxr  pyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx0000$^      returns a string indicating the fst type.$^      $^      return self.fst.get.fsttype              $^  $^    cpdef fstsymboltable inputsymbolsself$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s fst$^    pyxerr0 0000 pyxl0error$^  $^  pyxr  pyxvselffst.getfsttype$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      return weight$^  $^    cpdef string fsttypeself              $^      $^      fsttypeself$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxwriteunraisablepywrapfst.fst.fsttype pyxclineno pyxlineno pyxfilename 0 0$^  pyxpretendtoinitializepyxr$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst0fst00fsttypepyobject pyxvself cythonunused pyobject unused proto$^static char pyxdoc0pywrapfst0fst00fsttype  n    fsttypeselfnn    returns a string indicating the fst type.n    $^static pyobject pyxpw0pywrapfst0fst00fsttypepyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextfsttype wrapper 0$^  pyxr  pyxpf0pywrapfst0fst00fsttypestruct pyxobj0pywrapfstfst pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst0fst00fsttypestruct pyxobj0pywrapfstfst pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextfsttype 0$^  pyxxdecrefpyxr$^  pyxt0  pyxconvertpybytesstringtopystdinstringpyxf0pywrapfst0fstfsttypepyxvself 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.fst.fsttype pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return self.fst.get.fsttype$^  $^    cpdef fstsymboltable inputsymbolsself              $^      $^      inputsymbolsself$^ $^$^static pyobject pyxpw0pywrapfst0fst00inputsymbolspyobject pyxvself cythonunused pyobject unused proto$^static struct pyxobj0pywrapfstfstsymboltable pyxf0pywrapfst0fstinputsymbolsstruct pyxobj0pywrapfstfst pyxvself int pyxskipdispatch $^  fstsymboltable pyxvsyms$^  struct pyxobj0pywrapfstfstsymboltable pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  int pyxt0$^  pyxrefnannysetupcontextinputsymbols 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnsinputsymbols if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst0fst00inputsymbols $^      pyxxdecrefpyobject pyxr$^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxdecrefpyxt0 pyxt0  0$^       else $^        pyxt0  pyxpyobjectcallnoargpyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      $^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      if likelypyxt0  pynone  likelypyxtypetestpyxt0 pyxptype0pywrapfstfstsymboltable pyxerr0 0000 pyxl0error$^      pyxr  struct pyxobj0pywrapfstfstsymboltable pyxt0$^      pyxt0  0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx0000$^      $^      cdef fst.symboltable syms  constcastsymboltableptr$^        self.fst.get.inputsymbols              $^      if syms  null$^        return$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s fst$^    pyxerr0 0000 pyxl0error$^  $^$^   pywrapfst.pyx0000$^      see also inputsymbols.$^      $^      cdef fst.symboltable syms  constcastsymboltableptr              $^        self.fst.get.inputsymbols$^      if syms  null$^ $^  pyxvsyms  constcastpyxt0pywrapfstsymboltableptrpyxvselffst.getinputsymbols$^$^   pywrapfst.pyx0000$^      cdef fst.symboltable syms  constcastsymboltableptr$^        self.fst.get.inputsymbols$^      if syms  null              $^        return$^      return initfstsymboltablesyms self.fst$^ $^  pyxt0  pyxvsyms  null  0$^  if pyxt0 $^$^     pywrapfst.pyx0000$^        self.fst.get.inputsymbols$^      if syms  null$^        return              $^      return initfstsymboltablesyms self.fst$^  $^ $^    pyxxdecrefpyobject pyxr$^    pyxr  struct pyxobj0pywrapfstfstsymboltable pynone pyxincrefpynone$^    goto pyxl0$^$^     pywrapfst.pyx0000$^      cdef fst.symboltable syms  constcastsymboltableptr$^        self.fst.get.inputsymbols$^      if syms  null              $^        return$^      return initfstsymboltablesyms self.fst$^ $^  $^$^   pywrapfst.pyx0000$^      if syms  null$^        return$^      return initfstsymboltablesyms self.fst              $^  $^    cpdef sizet numarcsself int00 state except $^ $^  pyxxdecrefpyobject pyxr$^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s fst$^    pyxerr0 0000 pyxl0error$^  $^  pyxt0  pyobject pyxf0pywrapfstinitfstsymboltablepyxvsyms pyxvselffst if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  struct pyxobj0pywrapfstfstsymboltable pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      return self.fst.get.fsttype$^  $^    cpdef fstsymboltable inputsymbolsself              $^      $^      inputsymbolsself$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.fst.inputsymbols pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxl0$^  pyxxgiverefpyobject pyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst0fst00inputsymbolspyobject pyxvself cythonunused pyobject unused proto$^static char pyxdoc0pywrapfst0fst00inputsymbols  n    inputsymbolsselfnn    returns the fsts input symbol table or none if none is present.nn    see also inputsymbols.n    $^static pyobject pyxpw0pywrapfst0fst00inputsymbolspyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextinputsymbols wrapper 0$^  pyxr  pyxpf0pywrapfst0fst00inputsymbolsstruct pyxobj0pywrapfstfst pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst0fst00inputsymbolsstruct pyxobj0pywrapfstfst pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextinputsymbols 0$^  pyxxdecrefpyxr$^  pyxt0  pyobject pyxf0pywrapfst0fstinputsymbolspyxvself 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.fst.inputsymbols pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return initfstsymboltablesyms self.fst$^  $^    cpdef sizet numarcsself int00 state except               $^      $^      numarcsself state$^ $^$^static pyobject pyxpw0pywrapfst0fst00numarcspyobject pyxvself pyobject pyxargstate proto$^static sizet pyxf0pywrapfst0fstnumarcsstruct pyxobj0pywrapfstfst pyxvself pyxt00basictypesint00 pyxvstate int pyxskipdispatch $^  sizet pyxvresult$^  sizet pyxr$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  sizet pyxt0$^  int pyxt0$^  pyxrefnannysetupcontextnumarcs 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnsnumarcs if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst0fst00numarcs $^      pyxt0  pyxpyintfromint00tpyxvstate if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxgotrefpyxt0$^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^       else $^        if cythonfastpycall$^        if pyfunctioncheckpyxt0 $^          pyobject pyxtemp0  pyxt0 pyxt0$^          pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^          pyxxdecrefpyxt0 pyxt0  0$^          pyxgotrefpyxt0$^          pyxdecrefpyxt0 pyxt0  0$^         else$^        endif$^        if cythonfastpyccall$^        if pyxpyfastcfunctioncheckpyxt0 $^          pyobject pyxtemp0  pyxt0 pyxt0$^          pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^          pyxxdecrefpyxt0 pyxt0  0$^          pyxgotrefpyxt0$^          pyxdecrefpyxt0 pyxt0  0$^         else$^        endif$^        $^          pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^          pyxgotrefpyxt0$^          pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^          pyxgiverefpyxt0$^          pytuplesetitempyxt0 00 pyxt0$^          pyxt0  0$^          pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^          pyxgotrefpyxt0$^          pyxdecrefpyxt0 pyxt0  0$^        $^      $^      pyxdecrefpyxt0 pyxt0  0$^      pyxt0  pyxpyintassizetpyxt0 if unlikelypyxt0  sizet0  pyerroccurred pyxerr0 0000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxr  pyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx0000$^      see also numstates.$^      $^      cdef sizet result  self.fst.get.numarcsstate              $^      if result  sizemax$^        raise fstindexerrorstate index out of range$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s fst$^    pyxerr0 0000 pyxl0error$^  $^  pyxvresult  pyxvselffst.getnumarcspyxvstate$^$^   pywrapfst.pyx0000$^      $^      cdef sizet result  self.fst.get.numarcsstate$^      if result  sizemax              $^        raise fstindexerrorstate index out of range$^      return result$^ $^  pyxt0  pyxvresult  sizemax  0$^  if unlikelypyxt0 $^$^     pywrapfst.pyx0000$^      cdef sizet result  self.fst.get.numarcsstate$^      if result  sizemax$^        raise fstindexerrorstate index out of range              $^      return result$^  $^ $^    pyxt0  pyxgetmoduleglobalnamepyxnsfstindexerror if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  pyxpyobjectcallpyxt0 pyxtuple00 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxraisepyxt0 0 0 0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxerr0 0000 pyxl0error$^$^     pywrapfst.pyx0000$^      $^      cdef sizet result  self.fst.get.numarcsstate$^      if result  sizemax              $^        raise fstindexerrorstate index out of range$^      return result$^ $^  $^$^   pywrapfst.pyx0000$^      if result  sizemax$^        raise fstindexerrorstate index out of range$^      return result              $^  $^    cpdef sizet numinputepsilonsself int00 state except $^ $^  pyxr  pyxvresult$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      return initfstsymboltablesyms self.fst$^  $^    cpdef sizet numarcsself int00 state except               $^      $^      numarcsself state$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.fst.numarcs pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst0fst00numarcspyobject pyxvself pyobject pyxargstate proto$^static char pyxdoc0pywrapfst0fst00numarcs  n    numarcsself statenn    returns the number of arcs leaving a state.nn    argsn      state the integer index of a state.nn    returnsn      the number of arcs leaving that state.nn    raisesn      fstindexerror state index out of range.nn    see also numstates.n    $^static pyobject pyxpw0pywrapfst0fst00numarcspyobject pyxvself pyobject pyxargstate $^  pyxt00basictypesint00 pyxvstate$^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextnumarcs wrapper 0$^  assertpyxargstate $^    pyxvstate  pyxpyintasint00tpyxargstate if unlikelypyxvstate  int00t0  pyerroccurred pyxerr0 0000 pyxl0error$^  $^  goto pyxl0argumentunpackingdone$^  pyxl0error$^  pyxaddtracebackpywrapfst.fst.numarcs pyxclineno pyxlineno pyxfilename$^  pyxrefnannyfinishcontext$^  return null$^  pyxl0argumentunpackingdone$^  pyxr  pyxpf0pywrapfst0fst00numarcsstruct pyxobj0pywrapfstfst pyxvself pyxt00basictypesint00pyxvstate$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst0fst00numarcsstruct pyxobj0pywrapfstfst pyxvself pyxt00basictypesint00 pyxvstate $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  sizet pyxt0$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextnumarcs 0$^  pyxxdecrefpyxr$^  pyxt0  pyxf0pywrapfst0fstnumarcspyxvself pyxvstate 0 if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^  pyxt0  pyxpyintfromsizetpyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.fst.numarcs pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return result$^  $^    cpdef sizet numinputepsilonsself int00 state except               $^      $^      numinputepsilonsself state$^ $^$^static pyobject pyxpw0pywrapfst0fst00numinputepsilonspyobject pyxvself pyobject pyxargstate proto$^static sizet pyxf0pywrapfst0fstnuminputepsilonsstruct pyxobj0pywrapfstfst pyxvself pyxt00basictypesint00 pyxvstate int pyxskipdispatch $^  sizet pyxvresult$^  sizet pyxr$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  sizet pyxt0$^  int pyxt0$^  pyxrefnannysetupcontextnuminputepsilons 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnsnuminputepsilons if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst0fst00numinputepsilons $^      pyxt0  pyxpyintfromint00tpyxvstate if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxgotrefpyxt0$^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^       else $^        if cythonfastpycall$^        if pyfunctioncheckpyxt0 $^          pyobject pyxtemp0  pyxt0 pyxt0$^          pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^          pyxxdecrefpyxt0 pyxt0  0$^          pyxgotrefpyxt0$^          pyxdecrefpyxt0 pyxt0  0$^         else$^        endif$^        if cythonfastpyccall$^        if pyxpyfastcfunctioncheckpyxt0 $^          pyobject pyxtemp0  pyxt0 pyxt0$^          pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^          pyxxdecrefpyxt0 pyxt0  0$^          pyxgotrefpyxt0$^          pyxdecrefpyxt0 pyxt0  0$^         else$^        endif$^        $^          pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^          pyxgotrefpyxt0$^          pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^          pyxgiverefpyxt0$^          pytuplesetitempyxt0 00 pyxt0$^          pyxt0  0$^          pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^          pyxgotrefpyxt0$^          pyxdecrefpyxt0 pyxt0  0$^        $^      $^      pyxdecrefpyxt0 pyxt0  0$^      pyxt0  pyxpyintassizetpyxt0 if unlikelypyxt0  sizet0  pyerroccurred pyxerr0 0000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxr  pyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx0000$^      see also numoutputepsilons.$^      $^      cdef sizet result  self.fst.get.numinputepsilonsstate              $^      if result  sizemax$^        raise fstindexerrorstate index out of range$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s fst$^    pyxerr0 0000 pyxl0error$^  $^  pyxvresult  pyxvselffst.getnuminputepsilonspyxvstate$^$^   pywrapfst.pyx0000$^      $^      cdef sizet result  self.fst.get.numinputepsilonsstate$^      if result  sizemax              $^        raise fstindexerrorstate index out of range$^      return result$^ $^  pyxt0  pyxvresult  sizemax  0$^  if unlikelypyxt0 $^$^     pywrapfst.pyx0000$^      cdef sizet result  self.fst.get.numinputepsilonsstate$^      if result  sizemax$^        raise fstindexerrorstate index out of range              $^      return result$^  $^ $^    pyxt0  pyxgetmoduleglobalnamepyxnsfstindexerror if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  pyxpyobjectcallpyxt0 pyxtuple00 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxraisepyxt0 0 0 0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxerr0 0000 pyxl0error$^$^     pywrapfst.pyx0000$^      $^      cdef sizet result  self.fst.get.numinputepsilonsstate$^      if result  sizemax              $^        raise fstindexerrorstate index out of range$^      return result$^ $^  $^$^   pywrapfst.pyx0000$^      if result  sizemax$^        raise fstindexerrorstate index out of range$^      return result              $^  $^    cpdef sizet numoutputepsilonsself int00 state except $^ $^  pyxr  pyxvresult$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      return result$^  $^    cpdef sizet numinputepsilonsself int00 state except               $^      $^      numinputepsilonsself state$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.fst.numinputepsilons pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst0fst00numinputepsilonspyobject pyxvself pyobject pyxargstate proto$^static char pyxdoc0pywrapfst0fst00numinputepsilons  n    numinputepsilonsself statenn    returns the number of arcs with epsilon input labels leaving a state.nn    argsn      state the integer index of a state.nn    returnsn      the number of epsiloninputlabeled arcs leaving that state.nn    raisesn      fstindexerror state index out of range.nn    see also numoutputepsilons.n    $^static pyobject pyxpw0pywrapfst0fst00numinputepsilonspyobject pyxvself pyobject pyxargstate $^  pyxt00basictypesint00 pyxvstate$^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextnuminputepsilons wrapper 0$^  assertpyxargstate $^    pyxvstate  pyxpyintasint00tpyxargstate if unlikelypyxvstate  int00t0  pyerroccurred pyxerr0 0000 pyxl0error$^  $^  goto pyxl0argumentunpackingdone$^  pyxl0error$^  pyxaddtracebackpywrapfst.fst.numinputepsilons pyxclineno pyxlineno pyxfilename$^  pyxrefnannyfinishcontext$^  return null$^  pyxl0argumentunpackingdone$^  pyxr  pyxpf0pywrapfst0fst00numinputepsilonsstruct pyxobj0pywrapfstfst pyxvself pyxt00basictypesint00pyxvstate$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst0fst00numinputepsilonsstruct pyxobj0pywrapfstfst pyxvself pyxt00basictypesint00 pyxvstate $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  sizet pyxt0$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextnuminputepsilons 0$^  pyxxdecrefpyxr$^  pyxt0  pyxf0pywrapfst0fstnuminputepsilonspyxvself pyxvstate 0 if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^  pyxt0  pyxpyintfromsizetpyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.fst.numinputepsilons pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return result$^  $^    cpdef sizet numoutputepsilonsself int00 state except               $^      $^      numoutputepsilonsself state$^ $^$^static pyobject pyxpw0pywrapfst0fst00numoutputepsilonspyobject pyxvself pyobject pyxargstate proto$^static sizet pyxf0pywrapfst0fstnumoutputepsilonsstruct pyxobj0pywrapfstfst pyxvself pyxt00basictypesint00 pyxvstate int pyxskipdispatch $^  sizet pyxvresult$^  sizet pyxr$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  sizet pyxt0$^  int pyxt0$^  pyxrefnannysetupcontextnumoutputepsilons 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnsnumoutputepsilons if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst0fst00numoutputepsilons $^      pyxt0  pyxpyintfromint00tpyxvstate if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxgotrefpyxt0$^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^       else $^        if cythonfastpycall$^        if pyfunctioncheckpyxt0 $^          pyobject pyxtemp0  pyxt0 pyxt0$^          pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^          pyxxdecrefpyxt0 pyxt0  0$^          pyxgotrefpyxt0$^          pyxdecrefpyxt0 pyxt0  0$^         else$^        endif$^        if cythonfastpyccall$^        if pyxpyfastcfunctioncheckpyxt0 $^          pyobject pyxtemp0  pyxt0 pyxt0$^          pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^          pyxxdecrefpyxt0 pyxt0  0$^          pyxgotrefpyxt0$^          pyxdecrefpyxt0 pyxt0  0$^         else$^        endif$^        $^          pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^          pyxgotrefpyxt0$^          pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^          pyxgiverefpyxt0$^          pytuplesetitempyxt0 00 pyxt0$^          pyxt0  0$^          pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^          pyxgotrefpyxt0$^          pyxdecrefpyxt0 pyxt0  0$^        $^      $^      pyxdecrefpyxt0 pyxt0  0$^      pyxt0  pyxpyintassizetpyxt0 if unlikelypyxt0  sizet0  pyerroccurred pyxerr0 0000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxr  pyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx0000$^      see also numinputepsilons.$^      $^      cdef sizet result  self.fst.get.numoutputepsilonsstate              $^      if result  sizemax$^        raise fstindexerrorstate index out of range$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s fst$^    pyxerr0 0000 pyxl0error$^  $^  pyxvresult  pyxvselffst.getnumoutputepsilonspyxvstate$^$^   pywrapfst.pyx0000$^      $^      cdef sizet result  self.fst.get.numoutputepsilonsstate$^      if result  sizemax              $^        raise fstindexerrorstate index out of range$^      return result$^ $^  pyxt0  pyxvresult  sizemax  0$^  if unlikelypyxt0 $^$^     pywrapfst.pyx0000$^      cdef sizet result  self.fst.get.numoutputepsilonsstate$^      if result  sizemax$^        raise fstindexerrorstate index out of range              $^      return result$^  $^ $^    pyxt0  pyxgetmoduleglobalnamepyxnsfstindexerror if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  pyxpyobjectcallpyxt0 pyxtuple00 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxraisepyxt0 0 0 0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxerr0 0000 pyxl0error$^$^     pywrapfst.pyx0000$^      $^      cdef sizet result  self.fst.get.numoutputepsilonsstate$^      if result  sizemax              $^        raise fstindexerrorstate index out of range$^      return result$^ $^  $^$^   pywrapfst.pyx0000$^      if result  sizemax$^        raise fstindexerrorstate index out of range$^      return result              $^  $^    cpdef fstsymboltable outputsymbolsself$^ $^  pyxr  pyxvresult$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      return result$^  $^    cpdef sizet numoutputepsilonsself int00 state except               $^      $^      numoutputepsilonsself state$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.fst.numoutputepsilons pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst0fst00numoutputepsilonspyobject pyxvself pyobject pyxargstate proto$^static char pyxdoc0pywrapfst0fst00numoutputepsilons  n    numoutputepsilonsself statenn    returns the number of arcs with epsilon output labels leaving a state.nn    argsn      state the integer index of a state.nn    returnsn      the number of epsilonoutputlabeled arcs leaving that state.nn    raisesn      fstindexerror state index out of range.nn    see also numinputepsilons.n    $^static pyobject pyxpw0pywrapfst0fst00numoutputepsilonspyobject pyxvself pyobject pyxargstate $^  pyxt00basictypesint00 pyxvstate$^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextnumoutputepsilons wrapper 0$^  assertpyxargstate $^    pyxvstate  pyxpyintasint00tpyxargstate if unlikelypyxvstate  int00t0  pyerroccurred pyxerr0 0000 pyxl0error$^  $^  goto pyxl0argumentunpackingdone$^  pyxl0error$^  pyxaddtracebackpywrapfst.fst.numoutputepsilons pyxclineno pyxlineno pyxfilename$^  pyxrefnannyfinishcontext$^  return null$^  pyxl0argumentunpackingdone$^  pyxr  pyxpf0pywrapfst0fst00numoutputepsilonsstruct pyxobj0pywrapfstfst pyxvself pyxt00basictypesint00pyxvstate$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst0fst00numoutputepsilonsstruct pyxobj0pywrapfstfst pyxvself pyxt00basictypesint00 pyxvstate $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  sizet pyxt0$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextnumoutputepsilons 0$^  pyxxdecrefpyxr$^  pyxt0  pyxf0pywrapfst0fstnumoutputepsilonspyxvself pyxvstate 0 if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^  pyxt0  pyxpyintfromsizetpyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.fst.numoutputepsilons pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return result$^  $^    cpdef fstsymboltable outputsymbolsself              $^      $^      outputsymbolsself$^ $^$^static pyobject pyxpw0pywrapfst0fst00outputsymbolspyobject pyxvself cythonunused pyobject unused proto$^static struct pyxobj0pywrapfstfstsymboltable pyxf0pywrapfst0fstoutputsymbolsstruct pyxobj0pywrapfstfst pyxvself int pyxskipdispatch $^  fstsymboltable pyxvsyms$^  struct pyxobj0pywrapfstfstsymboltable pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  int pyxt0$^  pyxrefnannysetupcontextoutputsymbols 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnsoutputsymbols if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst0fst00outputsymbols $^      pyxxdecrefpyobject pyxr$^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxdecrefpyxt0 pyxt0  0$^       else $^        pyxt0  pyxpyobjectcallnoargpyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      $^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      if likelypyxt0  pynone  likelypyxtypetestpyxt0 pyxptype0pywrapfstfstsymboltable pyxerr0 0000 pyxl0error$^      pyxr  struct pyxobj0pywrapfstfstsymboltable pyxt0$^      pyxt0  0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx0000$^      $^      cdef fst.symboltable syms  constcastsymboltableptr$^        self.fst.get.outputsymbols              $^      if syms  null$^        return$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s fst$^    pyxerr0 0000 pyxl0error$^  $^$^   pywrapfst.pyx0000$^      see also inputsymbols.$^      $^      cdef fst.symboltable syms  constcastsymboltableptr              $^        self.fst.get.outputsymbols$^      if syms  null$^ $^  pyxvsyms  constcastpyxt0pywrapfstsymboltableptrpyxvselffst.getoutputsymbols$^$^   pywrapfst.pyx0000$^      cdef fst.symboltable syms  constcastsymboltableptr$^        self.fst.get.outputsymbols$^      if syms  null              $^        return$^      return initfstsymboltablesyms self.fst$^ $^  pyxt0  pyxvsyms  null  0$^  if pyxt0 $^$^     pywrapfst.pyx0000$^        self.fst.get.outputsymbols$^      if syms  null$^        return              $^      return initfstsymboltablesyms self.fst$^  $^ $^    pyxxdecrefpyobject pyxr$^    pyxr  struct pyxobj0pywrapfstfstsymboltable pynone pyxincrefpynone$^    goto pyxl0$^$^     pywrapfst.pyx0000$^      cdef fst.symboltable syms  constcastsymboltableptr$^        self.fst.get.outputsymbols$^      if syms  null              $^        return$^      return initfstsymboltablesyms self.fst$^ $^  $^$^   pywrapfst.pyx0000$^      if syms  null$^        return$^      return initfstsymboltablesyms self.fst              $^  $^    cpdef uint00 propertiesself uint00 mask bool test$^ $^  pyxxdecrefpyobject pyxr$^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s fst$^    pyxerr0 0000 pyxl0error$^  $^  pyxt0  pyobject pyxf0pywrapfstinitfstsymboltablepyxvsyms pyxvselffst if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  struct pyxobj0pywrapfstfstsymboltable pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      return result$^  $^    cpdef fstsymboltable outputsymbolsself              $^      $^      outputsymbolsself$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.fst.outputsymbols pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxl0$^  pyxxgiverefpyobject pyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst0fst00outputsymbolspyobject pyxvself cythonunused pyobject unused proto$^static char pyxdoc0pywrapfst0fst00outputsymbols  n    outputsymbolsselfnn    returns the fsts output symbol table or none if none is present.nn    see also inputsymbols.n    $^static pyobject pyxpw0pywrapfst0fst00outputsymbolspyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextoutputsymbols wrapper 0$^  pyxr  pyxpf0pywrapfst0fst00outputsymbolsstruct pyxobj0pywrapfstfst pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst0fst00outputsymbolsstruct pyxobj0pywrapfstfst pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextoutputsymbols 0$^  pyxxdecrefpyxr$^  pyxt0  pyobject pyxf0pywrapfst0fstoutputsymbolspyxvself 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.fst.outputsymbols pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return initfstsymboltablesyms self.fst$^  $^    cpdef uint00 propertiesself uint00 mask bool test              $^      $^      propertiesself mask test$^ $^$^static pyobject pyxpw0pywrapfst0fst00propertiespyobject pyxvself pyobject pyxargs pyobject pyxkwds proto$^static pyxt00basictypesuint00 pyxf0pywrapfst0fstpropertiesstruct pyxobj0pywrapfstfst pyxvself pyxt00basictypesuint00 pyxvmask bool pyxvtest int pyxskipdispatch $^  pyxt00basictypesuint00 pyxr$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  int pyxt0$^  pyobject pyxt0  null$^  pyxt00basictypesuint00 pyxt0$^  pyxrefnannysetupcontextproperties 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnsproperties if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst0fst00properties $^      pyxt0  pyxpyintfromuint00tpyxvmask if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxgotrefpyxt0$^      pyxt0  pyxpyboolfromlongpyxvtest if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxgotrefpyxt0$^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      pyxt0  0$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^          pyxt0  0$^        $^      $^      if cythonfastpycall$^      if pyfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxt0 pyxt0$^        pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp0pyxt0 0pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^        pyxdecrefpyxt0 pyxt0  0$^       else$^      endif$^      if cythonfastpyccall$^      if pyxpyfastcfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxt0 pyxt0$^        pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp0pyxt0 0pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^        pyxdecrefpyxt0 pyxt0  0$^       else$^      endif$^      $^        pyxt0  pytuplenew0pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxgotrefpyxt0$^        if pyxt0 $^          pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^        $^        pyxgiverefpyxt0$^        pytuplesetitempyxt0 0pyxt0 pyxt0$^        pyxgiverefpyxt0$^        pytuplesetitempyxt0 0pyxt0 pyxt0$^        pyxt0  0$^        pyxt0  0$^        pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^      $^      pyxdecrefpyxt0 pyxt0  0$^      pyxt0  pyxpyintasuint00tpyxt0 if unlikelypyxt0  uint00t0  pyerroccurred pyxerr0 0000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxr  pyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx0000$^        a 00bit bitmask representing the requested properties.$^      $^      return self.fst.get.propertiesmask test              $^  $^    cpdef int00 startself$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s fst$^    pyxerr0 0000 pyxl0error$^  $^  pyxr  pyxvselffst.getpropertiespyxvmask pyxvtest$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      return initfstsymboltablesyms self.fst$^  $^    cpdef uint00 propertiesself uint00 mask bool test              $^      $^      propertiesself mask test$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxwriteunraisablepywrapfst.fst.properties pyxclineno pyxlineno pyxfilename 0 0$^  pyxr  0$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst0fst00propertiespyobject pyxvself pyobject pyxargs pyobject pyxkwds proto$^static char pyxdoc0pywrapfst0fst00properties  n    propertiesself mask testnn    provides property bits.nn    this method provides user access to the properties attributes for the fst.n    the resulting value is a long integer but when it is cast to a booleann    it represents whether or not the fst has the mask property.nn    argsn      mask the property mask to be compared to the fsts properties.n      test should any unknown values be computed before comparing againstn          the masknn    returnsn      a 00bit bitmask representing the requested properties.n    $^static pyobject pyxpw0pywrapfst0fst00propertiespyobject pyxvself pyobject pyxargs pyobject pyxkwds $^  pyxt00basictypesuint00 pyxvmask$^  bool pyxvtest$^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextproperties wrapper 0$^  $^    static pyobject pyxpyargnames  pyxnsmaskpyxnstest0$^    pyobject values0  00$^    if unlikelypyxkwds $^      pyssizet kwargs$^      const pyssizet posargs  pytuplegetsizepyxargs$^      switch posargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 break$^        default goto pyxl0argtupleerror$^      $^      kwargs  pydictsizepyxkwds$^      switch posargs $^        case  0$^        if likelyvalues0  pyxpydictgetitemstrpyxkwds pyxnsmask  0 kwargs$^        else goto pyxl0argtupleerror$^        cythonfallthrough$^        case  0$^        if likelyvalues0  pyxpydictgetitemstrpyxkwds pyxnstest  0 kwargs$^        else $^          pyxraiseargtupleinvalidproperties 0 0 0 0 pyxerr0 0000 pyxl0error$^        $^      $^      if unlikelykwargs  0 $^        if unlikelypyxparseoptionalkeywordspyxkwds pyxpyargnames 0 values posargs properties  0 pyxerr0 0000 pyxl0error$^      $^     else if pytuplegetsizepyxargs  0 $^      goto pyxl0argtupleerror$^     else $^      values0  pytuplegetitempyxargs 0$^      values0  pytuplegetitempyxargs 0$^    $^    pyxvmask  pyxpyintasuint00tvalues0 if unlikelypyxvmask  uint00t0  pyerroccurred pyxerr0 0000 pyxl0error$^    pyxvtest  pyxpyobjectistruevalues0 if unlikelypyxvtest  bool0  pyerroccurred pyxerr0 0000 pyxl0error$^  $^  goto pyxl0argumentunpackingdone$^  pyxl0argtupleerror$^  pyxraiseargtupleinvalidproperties 0 0 0 pytuplegetsizepyxargs pyxerr0 0000 pyxl0error$^  pyxl0error$^  pyxaddtracebackpywrapfst.fst.properties pyxclineno pyxlineno pyxfilename$^  pyxrefnannyfinishcontext$^  return null$^  pyxl0argumentunpackingdone$^  pyxr  pyxpf0pywrapfst0fst00propertiesstruct pyxobj0pywrapfstfst pyxvself pyxvmask pyxvtest$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst0fst00propertiesstruct pyxobj0pywrapfstfst pyxvself pyxt00basictypesuint00 pyxvmask bool pyxvtest $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextproperties 0$^  pyxxdecrefpyxr$^  pyxt0  pyxpyintfromuint00tpyxf0pywrapfst0fstpropertiespyxvself pyxvmask pyxvtest 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.fst.properties pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return self.fst.get.propertiesmask test$^  $^    cpdef int00 startself              $^      $^      startself$^ $^$^static pyobject pyxpw0pywrapfst0fst00startpyobject pyxvself cythonunused pyobject unused proto$^static pyxt00basictypesint00 pyxf0pywrapfst0fststartstruct pyxobj0pywrapfstfst pyxvself int pyxskipdispatch $^  pyxt00basictypesint00 pyxr$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxt00basictypesint00 pyxt0$^  pyxrefnannysetupcontextstart 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnsstart if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst0fst00start $^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxdecrefpyxt0 pyxt0  0$^       else $^        pyxt0  pyxpyobjectcallnoargpyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      $^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxt0  pyxpyintasint00tpyxt0 if unlikelypyxt0  int00t0  pyerroccurred pyxerr0 0000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxr  pyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx0000$^      returns the start state.$^      $^      return self.fst.get.start              $^  $^    cpdef stateiterator statesself$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s fst$^    pyxerr0 0000 pyxl0error$^  $^  pyxr  pyxvselffst.getstart$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      return self.fst.get.propertiesmask test$^  $^    cpdef int00 startself              $^      $^      startself$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxwriteunraisablepywrapfst.fst.start pyxclineno pyxlineno pyxfilename 0 0$^  pyxr  0$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst0fst00startpyobject pyxvself cythonunused pyobject unused proto$^static char pyxdoc0pywrapfst0fst00start  n    startselfnn    returns the start state.n    $^static pyobject pyxpw0pywrapfst0fst00startpyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextstart wrapper 0$^  pyxr  pyxpf0pywrapfst0fst00startstruct pyxobj0pywrapfstfst pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst0fst00startstruct pyxobj0pywrapfstfst pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextstart 0$^  pyxxdecrefpyxr$^  pyxt0  pyxpyintfromint00tpyxf0pywrapfst0fststartpyxvself 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.fst.start pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return self.fst.get.start$^  $^    cpdef stateiterator statesself              $^      $^      statesself$^ $^$^static pyobject pyxpw0pywrapfst0fst00statespyobject pyxvself cythonunused pyobject unused proto$^static struct pyxobj0pywrapfststateiterator pyxf0pywrapfst0fststatesstruct pyxobj0pywrapfstfst pyxvself int pyxskipdispatch $^  struct pyxobj0pywrapfststateiterator pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextstates 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnsstates if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst0fst00states $^      pyxxdecrefpyobject pyxr$^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxdecrefpyxt0 pyxt0  0$^       else $^        pyxt0  pyxpyobjectcallnoargpyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      $^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      if likelypyxt0  pynone  likelypyxtypetestpyxt0 pyxptype0pywrapfststateiterator pyxerr0 0000 pyxl0error$^      pyxr  struct pyxobj0pywrapfststateiterator pyxt0$^      pyxt0  0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx0000$^      see also arcs mutablearcs.$^      $^      return stateiteratorself              $^  $^    cpdef string textself symboltable isymbolsnone$^ $^  pyxxdecrefpyobject pyxr$^  pyxt0  pyxpyobjectcalloneargpyobject pyxptype0pywrapfststateiterator pyobject pyxvself if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  struct pyxobj0pywrapfststateiterator pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      return self.fst.get.start$^  $^    cpdef stateiterator statesself              $^      $^      statesself$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.fst.states pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxl0$^  pyxxgiverefpyobject pyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst0fst00statespyobject pyxvself cythonunused pyobject unused proto$^static char pyxdoc0pywrapfst0fst00states  n    statesselfnn    returns an iterator over all states in the fst.nn    returnsn      a stateiterator object for the fst.nn    see also arcs mutablearcs.n    $^static pyobject pyxpw0pywrapfst0fst00statespyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextstates wrapper 0$^  pyxr  pyxpf0pywrapfst0fst00statesstruct pyxobj0pywrapfstfst pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst0fst00statesstruct pyxobj0pywrapfstfst pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextstates 0$^  pyxxdecrefpyxr$^  pyxt0  pyobject pyxf0pywrapfst0fststatespyxvself 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.fst.states pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return stateiteratorself$^  $^    cpdef string textself symboltable isymbolsnone              $^        symboltable osymbolsnone symboltable ssymbolsnone$^        bool acceptorfalse bool showweightonefalse missingsymb$^ $^$^static pyobject pyxpw0pywrapfst0fst00textpyobject pyxvself pyobject pyxargs pyobject pyxkwds proto$^static stdstring pyxf0pywrapfst0fsttextstruct pyxobj0pywrapfstfst pyxvself int pyxskipdispatch struct pyxoptargs0pywrapfst0fsttext pyxoptionalargs $^  struct pyxobj0pywrapfstsymboltable pyxvisymbols  struct pyxobj0pywrapfstsymboltable pynone$^$^   pywrapfst.pyx0000$^  $^    cpdef string textself symboltable isymbolsnone$^        symboltable osymbolsnone symboltable ssymbolsnone              $^        bool acceptorfalse bool showweightonefalse missingsymb$^      $^ $^  struct pyxobj0pywrapfstsymboltable pyxvosymbols  struct pyxobj0pywrapfstsymboltable pynone$^  struct pyxobj0pywrapfstsymboltable pyxvssymbols  struct pyxobj0pywrapfstsymboltable pynone$^$^   pywrapfst.pyx0000$^    cpdef string textself symboltable isymbolsnone$^        symboltable osymbolsnone symboltable ssymbolsnone$^        bool acceptorfalse bool showweightonefalse missingsymb              $^      $^      textself isymbolsnone osymbolsnone ssymbolsnone acceptorfalse$^ $^  bool pyxvacceptor  bool0$^  bool pyxvshowweightone  bool0$^  pyobject pyxvmissingsym  pyobject pyxkpb00$^  fstsymboltable pyxvssymbolsptr$^  stdstringstream pyxvsstrm$^  stdstring pyxr$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  int pyxt0$^  pyobject pyxt0  null$^  stdstring pyxt0$^  int pyxt00$^  int pyxt00$^  fstsymboltable pyxt00$^  fstsymboltable const pyxt00$^  fstsymboltable const pyxt00$^  pyxrefnannysetupcontexttext 0$^  if pyxoptionalargs $^    if pyxoptionalargspyxn  0 $^      pyxvisymbols  pyxoptionalargsisymbols$^      if pyxoptionalargspyxn  0 $^        pyxvosymbols  pyxoptionalargsosymbols$^        if pyxoptionalargspyxn  0 $^          pyxvssymbols  pyxoptionalargsssymbols$^          if pyxoptionalargspyxn  0 $^            pyxvacceptor  pyxoptionalargsacceptor$^            if pyxoptionalargspyxn  0 $^              pyxvshowweightone  pyxoptionalargsshowweightone$^              if pyxoptionalargspyxn  0 $^                pyxvmissingsym  pyxoptionalargsmissingsym$^              $^            $^          $^        $^      $^    $^  $^$^   pywrapfst.pyx0000$^      return stateiteratorself$^  $^    cpdef string textself symboltable isymbolsnone              $^        symboltable osymbolsnone symboltable ssymbolsnone$^        bool acceptorfalse bool showweightonefalse missingsymb$^ $^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnstext if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst0fst00text $^      pyxt0  pyxpyboolfromlongpyxvacceptor if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxgotrefpyxt0$^      pyxt0  pyxpyboolfromlongpyxvshowweightone if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxgotrefpyxt0$^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      pyxt0  0$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^          pyxt0  0$^        $^      $^      if cythonfastpycall$^      if pyfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyobject pyxvisymbols pyobject pyxvosymbols pyobject pyxvssymbols pyxt0 pyxt0 pyxvmissingsym$^        pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp0pyxt0 0pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^        pyxdecrefpyxt0 pyxt0  0$^       else$^      endif$^      if cythonfastpyccall$^      if pyxpyfastcfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyobject pyxvisymbols pyobject pyxvosymbols pyobject pyxvssymbols pyxt0 pyxt0 pyxvmissingsym$^        pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp0pyxt0 0pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^        pyxdecrefpyxt0 pyxt0  0$^       else$^      endif$^      $^        pyxt0  pytuplenew0pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxgotrefpyxt0$^        if pyxt0 $^          pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^        $^        pyxincrefpyobject pyxvisymbols$^        pyxgiverefpyobject pyxvisymbols$^        pytuplesetitempyxt0 0pyxt0 pyobject pyxvisymbols$^        pyxincrefpyobject pyxvosymbols$^        pyxgiverefpyobject pyxvosymbols$^        pytuplesetitempyxt0 0pyxt0 pyobject pyxvosymbols$^        pyxincrefpyobject pyxvssymbols$^        pyxgiverefpyobject pyxvssymbols$^        pytuplesetitempyxt0 0pyxt0 pyobject pyxvssymbols$^        pyxgiverefpyxt0$^        pytuplesetitempyxt0 0pyxt0 pyxt0$^        pyxgiverefpyxt0$^        pytuplesetitempyxt0 0pyxt0 pyxt0$^        pyxincrefpyxvmissingsym$^        pyxgiverefpyxvmissingsym$^        pytuplesetitempyxt0 0pyxt0 pyxvmissingsym$^        pyxt0  0$^        pyxt0  0$^        pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^      $^      pyxdecrefpyxt0 pyxt0  0$^      pyxt0  pyxconvertstringfrompystdinstringpyxt0 if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxr  pyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx0000$^      $^       prints fst to stringstream then returns resulting string.$^      cdef fst.symboltable ssymbolsptr  null              $^      if ssymbols is not none$^        ssymbolsptr  ssymbols.table$^ $^  pyxvssymbolsptr  null$^$^   pywrapfst.pyx0000$^       prints fst to stringstream then returns resulting string.$^      cdef fst.symboltable ssymbolsptr  null$^      if ssymbols is not none              $^        ssymbolsptr  ssymbols.table$^      cdef stringstream sstrm$^ $^  pyxt00  pyobject pyxvssymbols  pynone$^  pyxt00  pyxt00  0$^  if pyxt00 $^$^     pywrapfst.pyx0000$^      cdef fst.symboltable ssymbolsptr  null$^      if ssymbols is not none$^        ssymbolsptr  ssymbols.table              $^      cdef stringstream sstrm$^      fst.printfstderefself.fst sstrm bpywrapfst$^ $^    if unlikelypyobject pyxvssymbols  pynone $^      pyerrformatpyexcattributeerror nonetype object has no attribute .00s table$^      pyxerr0 0000 pyxl0error$^    $^    pyxt00  pyxvssymbolstable$^    pyxvssymbolsptr  pyxt00$^$^     pywrapfst.pyx0000$^       prints fst to stringstream then returns resulting string.$^      cdef fst.symboltable ssymbolsptr  null$^      if ssymbols is not none              $^        ssymbolsptr  ssymbols.table$^      cdef stringstream sstrm$^ $^  $^$^   pywrapfst.pyx0000$^        ssymbolsptr  ssymbols.table$^      cdef stringstream sstrm$^      fst.printfstderefself.fst sstrm bpywrapfst              $^          self.fst.get.inputsymbols if isymbols is none$^          else isymbols.table$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s fst$^    pyxerr0 0000 pyxl0error$^  $^$^   pywrapfst.pyx0000$^      cdef stringstream sstrm$^      fst.printfstderefself.fst sstrm bpywrapfst$^          self.fst.get.inputsymbols if isymbols is none              $^          else isymbols.table$^          self.fst.get.outputsymbols if osymbols is none$^ $^  pyxt00  pyobject pyxvisymbols  pynone$^  if pyxt00  0 $^    if unlikelypyobject pyxvself  pynone $^      pyerrformatpyexcattributeerror nonetype object has no attribute .00s fst$^      pyxerr0 0000 pyxl0error$^    $^    pyxt00  pyxvselffst.getinputsymbols$^   else $^$^     pywrapfst.pyx0000$^      fst.printfstderefself.fst sstrm bpywrapfst$^          self.fst.get.inputsymbols if isymbols is none$^          else isymbols.table              $^          self.fst.get.outputsymbols if osymbols is none$^          else osymbols.table$^ $^    if unlikelypyobject pyxvisymbols  pynone $^      pyerrformatpyexcattributeerror nonetype object has no attribute .00s table$^      pyxerr0 0000 pyxl0error$^    $^    pyxt00  pyxvisymbolstable$^  $^$^   pywrapfst.pyx0000$^          self.fst.get.inputsymbols if isymbols is none$^          else isymbols.table$^          self.fst.get.outputsymbols if osymbols is none              $^          else osymbols.table$^          ssymbolsptr acceptor showweightone tostringmissingsym$^ $^  pyxt00  pyobject pyxvosymbols  pynone$^  if pyxt00  0 $^    if unlikelypyobject pyxvself  pynone $^      pyerrformatpyexcattributeerror nonetype object has no attribute .00s fst$^      pyxerr0 0000 pyxl0error$^    $^    pyxt00  pyxvselffst.getoutputsymbols$^   else $^$^     pywrapfst.pyx0000$^          else isymbols.table$^          self.fst.get.outputsymbols if osymbols is none$^          else osymbols.table              $^          ssymbolsptr acceptor showweightone tostringmissingsym$^      return sstrm.str$^ $^    if unlikelypyobject pyxvosymbols  pynone $^      pyerrformatpyexcattributeerror nonetype object has no attribute .00s table$^      pyxerr0 0000 pyxl0error$^    $^    pyxt00  pyxvosymbolstable$^  $^$^   pywrapfst.pyx0000$^          self.fst.get.outputsymbols if osymbols is none$^          else osymbols.table$^          ssymbolsptr acceptor showweightone tostringmissingsym              $^      return sstrm.str$^  $^ $^  pyxt0  pyxf0pywrapfsttostringpyxvmissingsym null if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^        ssymbolsptr  ssymbols.table$^      cdef stringstream sstrm$^      fst.printfstderefself.fst sstrm bpywrapfst              $^          self.fst.get.inputsymbols if isymbols is none$^          else isymbols.table$^ $^  fstscriptprintfstpyxvselffst pyxvsstrm pyxkpywrapfst pyxt00 pyxt00 pyxvssymbolsptr pyxvacceptor pyxvshowweightone pyxt0$^$^   pywrapfst.pyx0000$^          else osymbols.table$^          ssymbolsptr acceptor showweightone tostringmissingsym$^      return sstrm.str              $^  $^    cpdef bool verifyself$^ $^  pyxr  pyxvsstrm.str$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      return stateiteratorself$^  $^    cpdef string textself symboltable isymbolsnone              $^        symboltable osymbolsnone symboltable ssymbolsnone$^        bool acceptorfalse bool showweightonefalse missingsymb$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxwriteunraisablepywrapfst.fst.text pyxclineno pyxlineno pyxfilename 0 0$^  pyxpretendtoinitializepyxr$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst0fst00textpyobject pyxvself pyobject pyxargs pyobject pyxkwds proto$^static char pyxdoc0pywrapfst0fst00text  n    textself isymbolsnone osymbolsnone ssymbolsnone acceptorfalsen         showweightonefalse missingsymnn    produces a humanreadable string representation of the fst.nn    this method generates a humanreadable string representation of the fst.n    the caller may optionally specify symboltables used to label input labelsn    output labels or state labels respectively.nn    argsn      isymbols an optional symbol table used to label input symbols.n      osymbols an optional symbol table used to label output symbols.n      ssymbols an optional symbol table used to label states.n      acceptor should the fst be rendered in acceptor format if possiblen      showweightone should weights equivalent to semiring one be printedn      missingsymbol the string to be printed when symbol table lookup fails.nn    returnsn      a formatted string representing the machine.n    $^static pyobject pyxpw0pywrapfst0fst00textpyobject pyxvself pyobject pyxargs pyobject pyxkwds $^  struct pyxobj0pywrapfstsymboltable pyxvisymbols  0$^  struct pyxobj0pywrapfstsymboltable pyxvosymbols  0$^  struct pyxobj0pywrapfstsymboltable pyxvssymbols  0$^  bool pyxvacceptor$^  bool pyxvshowweightone$^  pyobject pyxvmissingsym  0$^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontexttext wrapper 0$^  $^    static pyobject pyxpyargnames  pyxnsisymbolspyxnsosymbolspyxnsssymbolspyxnsacceptorpyxnsshowweightonepyxnsmissingsym0$^    pyobject values0  000000$^    values0  pyobject struct pyxobj0pywrapfstsymboltable pynone$^$^     pywrapfst.pyx0000$^  $^    cpdef string textself symboltable isymbolsnone$^        symboltable osymbolsnone symboltable ssymbolsnone              $^        bool acceptorfalse bool showweightonefalse missingsymb$^      $^ $^    values0  pyobject struct pyxobj0pywrapfstsymboltable pynone$^    values0  pyobject struct pyxobj0pywrapfstsymboltable pynone$^    values0  pyobject pyxkpb00$^    if unlikelypyxkwds $^      pyssizet kwargs$^      const pyssizet posargs  pytuplegetsizepyxargs$^      switch posargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 break$^        default goto pyxl0argtupleerror$^      $^      kwargs  pydictsizepyxkwds$^      switch posargs $^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnsisymbols$^          if value  values0  value kwargs $^        $^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnsosymbols$^          if value  values0  value kwargs $^        $^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnsssymbols$^          if value  values0  value kwargs $^        $^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnsacceptor$^          if value  values0  value kwargs $^        $^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnsshowweightone$^          if value  values0  value kwargs $^        $^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnsmissingsym$^          if value  values0  value kwargs $^        $^      $^      if unlikelykwargs  0 $^        if unlikelypyxparseoptionalkeywordspyxkwds pyxpyargnames 0 values posargs text  0 pyxerr0 0000 pyxl0error$^      $^     else $^      switch pytuplegetsizepyxargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 break$^        default goto pyxl0argtupleerror$^      $^    $^    pyxvisymbols  struct pyxobj0pywrapfstsymboltable values0$^    pyxvosymbols  struct pyxobj0pywrapfstsymboltable values0$^    pyxvssymbols  struct pyxobj0pywrapfstsymboltable values0$^    if values0 $^      pyxvacceptor  pyxpyobjectistruevalues0 if unlikelypyxvacceptor  bool0  pyerroccurred pyxerr0 0000 pyxl0error$^     else $^$^       pywrapfst.pyx0000$^    cpdef string textself symboltable isymbolsnone$^        symboltable osymbolsnone symboltable ssymbolsnone$^        bool acceptorfalse bool showweightonefalse missingsymb              $^      $^      textself isymbolsnone osymbolsnone ssymbolsnone acceptorfalse$^ $^      pyxvacceptor  bool0$^    $^    if values0 $^      pyxvshowweightone  pyxpyobjectistruevalues0 if unlikelypyxvshowweightone  bool0  pyerroccurred pyxerr0 0000 pyxl0error$^     else $^      pyxvshowweightone  bool0$^    $^    pyxvmissingsym  values0$^  $^  goto pyxl0argumentunpackingdone$^  pyxl0argtupleerror$^  pyxraiseargtupleinvalidtext 0 0 0 pytuplegetsizepyxargs pyxerr0 0000 pyxl0error$^  pyxl0error$^  pyxaddtracebackpywrapfst.fst.text pyxclineno pyxlineno pyxfilename$^  pyxrefnannyfinishcontext$^  return null$^  pyxl0argumentunpackingdone$^  if unlikelypyxargtypetestpyobject pyxvisymbols pyxptype0pywrapfstsymboltable 0 isymbols 0 pyxerr0 0000 pyxl0error$^  if unlikelypyxargtypetestpyobject pyxvosymbols pyxptype0pywrapfstsymboltable 0 osymbols 0 pyxerr0 0000 pyxl0error$^  if unlikelypyxargtypetestpyobject pyxvssymbols pyxptype0pywrapfstsymboltable 0 ssymbols 0 pyxerr0 0000 pyxl0error$^  pyxr  pyxpf0pywrapfst0fst00textstruct pyxobj0pywrapfstfst pyxvself pyxvisymbols pyxvosymbols pyxvssymbols pyxvacceptor pyxvshowweightone pyxvmissingsym$^$^   pywrapfst.pyx0000$^      return stateiteratorself$^  $^    cpdef string textself symboltable isymbolsnone              $^        symboltable osymbolsnone symboltable ssymbolsnone$^        bool acceptorfalse bool showweightonefalse missingsymb$^ $^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxr  null$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst0fst00textstruct pyxobj0pywrapfstfst pyxvself struct pyxobj0pywrapfstsymboltable pyxvisymbols struct pyxobj0pywrapfstsymboltable pyxvosymbols struct pyxobj0pywrapfstsymboltable pyxvssymbols bool pyxvacceptor bool pyxvshowweightone pyobject pyxvmissingsym $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  stdstring pyxt0$^  struct pyxoptargs0pywrapfst0fsttext pyxt0$^  pyobject pyxt0  null$^  pyxrefnannysetupcontexttext 0$^  pyxxdecrefpyxr$^  pyxt0.pyxn  0$^  pyxt0.isymbols  pyxvisymbols$^  pyxt0.osymbols  pyxvosymbols$^  pyxt0.ssymbols  pyxvssymbols$^  pyxt0.acceptor  pyxvacceptor$^  pyxt0.showweightone  pyxvshowweightone$^  pyxt0.missingsym  pyxvmissingsym$^  pyxt0  pyxvtabptr0pywrapfstfsttextpyxvself 0 pyxt0 $^  pyxt0  pyxconvertpybytesstringtopystdinstringpyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.fst.text pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return sstrm.str$^  $^    cpdef bool verifyself              $^      $^      verifyself$^ $^$^static pyobject pyxpw0pywrapfst0fst00verifypyobject pyxvself cythonunused pyobject unused proto$^static bool pyxf0pywrapfst0fstverifystruct pyxobj0pywrapfstfst pyxvself int pyxskipdispatch $^  bool pyxr$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  bool pyxt0$^  pyxrefnannysetupcontextverify 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnsverify if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst0fst00verify $^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxdecrefpyxt0 pyxt0  0$^       else $^        pyxt0  pyxpyobjectcallnoargpyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      $^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxt0  pyxpyobjectistruepyxt0 if unlikelypyxt0  bool0  pyerroccurred pyxerr0 0000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxr  pyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx0000$^        true if the contents are sane false otherwise.$^      $^      return fst.verifyderefself.fst              $^  $^    cpdef string weighttypeself$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s fst$^    pyxerr0 0000 pyxl0error$^  $^  pyxr  fstscriptverifypyxvselffst$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      return sstrm.str$^  $^    cpdef bool verifyself              $^      $^      verifyself$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxwriteunraisablepywrapfst.fst.verify pyxclineno pyxlineno pyxfilename 0 0$^  pyxr  0$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst0fst00verifypyobject pyxvself cythonunused pyobject unused proto$^static char pyxdoc0pywrapfst0fst00verify  n    verifyselfnn    verifies that an fsts contents are sane.nn    returnsn      true if the contents are sane false otherwise.n    $^static pyobject pyxpw0pywrapfst0fst00verifypyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextverify wrapper 0$^  pyxr  pyxpf0pywrapfst0fst00verifystruct pyxobj0pywrapfstfst pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst0fst00verifystruct pyxobj0pywrapfstfst pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextverify 0$^  pyxxdecrefpyxr$^  pyxt0  pyxpyboolfromlongpyxf0pywrapfst0fstverifypyxvself 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.fst.verify pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return fst.verifyderefself.fst$^  $^    cpdef string weighttypeself              $^      $^      weighttypeself$^ $^$^static pyobject pyxpw0pywrapfst0fst00weighttypepyobject pyxvself cythonunused pyobject unused proto$^static stdstring pyxf0pywrapfst0fstweighttypestruct pyxobj0pywrapfstfst pyxvself int pyxskipdispatch $^  stdstring pyxr$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  stdstring pyxt0$^  pyxrefnannysetupcontextweighttype 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnsweighttype if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst0fst00weighttype $^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxdecrefpyxt0 pyxt0  0$^       else $^        pyxt0  pyxpyobjectcallnoargpyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      $^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxt0  pyxconvertstringfrompystdinstringpyxt0 if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxr  pyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx0000$^        a string representing the weight type.$^      $^      return self.fst.get.weighttype              $^  $^    cpdef void writeself filename except $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s fst$^    pyxerr0 0000 pyxl0error$^  $^  pyxr  pyxvselffst.getweighttype$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      return fst.verifyderefself.fst$^  $^    cpdef string weighttypeself              $^      $^      weighttypeself$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxwriteunraisablepywrapfst.fst.weighttype pyxclineno pyxlineno pyxfilename 0 0$^  pyxpretendtoinitializepyxr$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst0fst00weighttypepyobject pyxvself cythonunused pyobject unused proto$^static char pyxdoc0pywrapfst0fst00weighttype  n    weighttypeselfnn    provides the fsts weight type.nn    returnsn      a string representing the weight type.n    $^static pyobject pyxpw0pywrapfst0fst00weighttypepyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextweighttype wrapper 0$^  pyxr  pyxpf0pywrapfst0fst00weighttypestruct pyxobj0pywrapfstfst pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst0fst00weighttypestruct pyxobj0pywrapfstfst pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextweighttype 0$^  pyxxdecrefpyxr$^  pyxt0  pyxconvertpybytesstringtopystdinstringpyxf0pywrapfst0fstweighttypepyxvself 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.fst.weighttype pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return self.fst.get.weighttype$^  $^    cpdef void writeself filename except               $^      $^      writeself filename$^ $^$^static pyobject pyxpw0pywrapfst0fst00writepyobject pyxvself pyobject pyxvfilename proto$^static void pyxf0pywrapfst0fstwritestruct pyxobj0pywrapfstfst pyxvself pyobject pyxvfilename int pyxskipdispatch $^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  stdstring pyxt0$^  int pyxt0$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextwrite 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnswrite if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst0fst00write $^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxvfilename if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxgotrefpyxt0$^       else $^        if cythonfastpycall$^        if pyfunctioncheckpyxt0 $^          pyobject pyxtemp0  pyxt0 pyxvfilename$^          pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^          pyxxdecrefpyxt0 pyxt0  0$^          pyxgotrefpyxt0$^         else$^        endif$^        if cythonfastpyccall$^        if pyxpyfastcfunctioncheckpyxt0 $^          pyobject pyxtemp0  pyxt0 pyxvfilename$^          pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^          pyxxdecrefpyxt0 pyxt0  0$^          pyxgotrefpyxt0$^         else$^        endif$^        $^          pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^          pyxgotrefpyxt0$^          pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^          pyxincrefpyxvfilename$^          pyxgiverefpyxvfilename$^          pytuplesetitempyxt0 00 pyxvfilename$^          pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^          pyxgotrefpyxt0$^          pyxdecrefpyxt0 pyxt0  0$^        $^      $^      pyxdecrefpyxt0 pyxt0  0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx0000$^        fstioerror write failed.$^      $^      if not self.fst.get.writetostringfilename              $^        raise fstioerrorwrite failed r.formatfilename$^  $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s fst$^    pyxerr0 0000 pyxl0error$^  $^  pyxt0  pyxf0pywrapfsttostringpyxvfilename null if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^  pyxt0  pyxvselffst.getwritepyxt0  0  0$^  if unlikelypyxt0 $^$^     pywrapfst.pyx0000$^      $^      if not self.fst.get.writetostringfilename$^        raise fstioerrorwrite failed r.formatfilename              $^  $^    cpdef string writetostringself$^ $^    pyxt0  pyxgetmoduleglobalnamepyxnsfstioerror if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  pyxpyobjectgetattrstrpyxkpswritefailedr pyxnsformat if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  null$^    if cythonunpackmethods  likelypymethodcheckpyxt0 $^      pyxt0  pymethodgetselfpyxt0$^      if likelypyxt0 $^        pyobject function  pymethodgetfunctionpyxt0$^        pyxincrefpyxt0$^        pyxincreffunction$^        pyxdecrefsetpyxt0 function$^      $^    $^    if pyxt0 $^      pyxt0  pyxpyobjectcalloneargpyxt0 pyxvfilename if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxgotrefpyxt0$^     else $^      if cythonfastpycall$^      if pyfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxvfilename$^        pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^       else$^      endif$^      if cythonfastpyccall$^      if pyxpyfastcfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxvfilename$^        pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^       else$^      endif$^      $^        pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxgotrefpyxt0$^        pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^        pyxincrefpyxvfilename$^        pyxgiverefpyxvfilename$^        pytuplesetitempyxt0 00 pyxvfilename$^        pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^      $^    $^    pyxdecrefpyxt0 pyxt0  0$^    pyxt0  null$^    if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^      pyxt0  pymethodgetselfpyxt0$^      if likelypyxt0 $^        pyobject function  pymethodgetfunctionpyxt0$^        pyxincrefpyxt0$^        pyxincreffunction$^        pyxdecrefsetpyxt0 function$^      $^    $^    if pyxt0 $^      pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxgotrefpyxt0$^     else $^      if cythonfastpycall$^      if pyfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxt0$^        pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^       else$^      endif$^      if cythonfastpyccall$^      if pyxpyfastcfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxt0$^        pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^       else$^      endif$^      $^        pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxgotrefpyxt0$^        pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^        pyxgiverefpyxt0$^        pytuplesetitempyxt0 00 pyxt0$^        pyxt0  0$^        pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^      $^    $^    pyxdecrefpyxt0 pyxt0  0$^    pyxraisepyxt0 0 0 0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxerr0 0000 pyxl0error$^$^     pywrapfst.pyx0000$^        fstioerror write failed.$^      $^      if not self.fst.get.writetostringfilename              $^        raise fstioerrorwrite failed r.formatfilename$^  $^ $^  $^$^   pywrapfst.pyx0000$^      return self.fst.get.weighttype$^  $^    cpdef void writeself filename except               $^      $^      writeself filename$^ $^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.fst.write pyxclineno pyxlineno pyxfilename$^  pyxl0$^  pyxrefnannyfinishcontext$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst0fst00writepyobject pyxvself pyobject pyxvfilename proto$^static char pyxdoc0pywrapfst0fst00write  n    writeself filenamenn    serializes fst to a file.nn    this method writes the fst to a file in a binary format.nn    argsn      filename the string location of the output file.nn    raisesn      fstioerror write failed.n    $^static pyobject pyxpw0pywrapfst0fst00writepyobject pyxvself pyobject pyxvfilename $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextwrite wrapper 0$^  pyxr  pyxpf0pywrapfst0fst00writestruct pyxobj0pywrapfstfst pyxvself pyobject pyxvfilename$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst0fst00writestruct pyxobj0pywrapfstfst pyxvself pyobject pyxvfilename $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextwrite 0$^  pyxxdecrefpyxr$^  pyxf0pywrapfst0fstwritepyxvself pyxvfilename 0 if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^  pyxt0  pyxvoidtononenull if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.fst.write pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^        raise fstioerrorwrite failed r.formatfilename$^  $^    cpdef string writetostringself              $^      $^      writetostringself$^ $^$^static pyobject pyxpw0pywrapfst0fst00writetostringpyobject pyxvself cythonunused pyobject unused proto$^static stdstring pyxf0pywrapfst0fstwritetostringstruct pyxobj0pywrapfstfst pyxvself int pyxskipdispatch $^  stdstringstream pyxvsstrm$^  stdstring pyxr$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  stdstring pyxt0$^  int pyxt0$^  pyxrefnannysetupcontextwritetostring 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnswritetostring if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst0fst00writetostring $^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxdecrefpyxt0 pyxt0  0$^       else $^        pyxt0  pyxpyobjectcallnoargpyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      $^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxt0  pyxconvertstringfrompystdinstringpyxt0 if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxr  pyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx0000$^      $^      cdef stringstream sstrm$^      if not self.fst.get.writesstrm writetostring              $^        raise fstioerrorwrite to string failed$^      return sstrm.str$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s fst$^    pyxerr0 0000 pyxl0error$^  $^  pyxt0  pyxvselffst.getwritepyxvsstrm pyxkwritetostring  0  0$^  if unlikelypyxt0 $^$^     pywrapfst.pyx0000$^      cdef stringstream sstrm$^      if not self.fst.get.writesstrm writetostring$^        raise fstioerrorwrite to string failed              $^      return sstrm.str$^  $^ $^    pyxt0  pyxgetmoduleglobalnamepyxnsfstioerror if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  pyxpyobjectcallpyxt0 pyxtuple00 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxraisepyxt0 0 0 0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxerr0 0000 pyxl0error$^$^     pywrapfst.pyx0000$^      $^      cdef stringstream sstrm$^      if not self.fst.get.writesstrm writetostring              $^        raise fstioerrorwrite to string failed$^      return sstrm.str$^ $^  $^$^   pywrapfst.pyx0000$^      if not self.fst.get.writesstrm writetostring$^        raise fstioerrorwrite to string failed$^      return sstrm.str              $^  $^  $^ $^  pyxr  pyxvsstrm.str$^  goto pyxl0$^$^   pywrapfst.pyx0000$^        raise fstioerrorwrite failed r.formatfilename$^  $^    cpdef string writetostringself              $^      $^      writetostringself$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxwriteunraisablepywrapfst.fst.writetostring pyxclineno pyxlineno pyxfilename 0 0$^  pyxpretendtoinitializepyxr$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst0fst00writetostringpyobject pyxvself cythonunused pyobject unused proto$^static char pyxdoc0pywrapfst0fst00writetostring  n    writetostringselfnn    serializes fst to a string.nn    returnsn      a string.nn    raisesn      fstioerror write to string failed.nn    see also readfromstring.n    $^static pyobject pyxpw0pywrapfst0fst00writetostringpyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextwritetostring wrapper 0$^  pyxr  pyxpf0pywrapfst0fst00writetostringstruct pyxobj0pywrapfstfst pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst0fst00writetostringstruct pyxobj0pywrapfstfst pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextwritetostring 0$^  pyxxdecrefpyxr$^  pyxt0  pyxconvertpybytesstringtopystdinstringpyxf0pywrapfst0fstwritetostringpyxvself 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.fst.writetostring pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^    $^  $^    cdef void checkmutatingimethodself except               $^      checks whether an operation mutating the fst has produced an error.$^  $^ $^$^static void pyxf0pywrapfst00mutablefstcheckmutatingimethodstruct pyxobj0pywrapfstmutablefst pyxvself $^  pyxrefnannydeclarations$^  int pyxt0$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextcheckmutatingimethod 0$^$^   pywrapfst.pyx0000$^      this function is not visible to python users.$^      $^      if self.fst.get.propertiesfst.kerror true  fst.kerror              $^        raise fstoperroroperation failed$^  $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s fst$^    pyxerr0 0000 pyxl0error$^  $^  pyxt0  pyxvselfpyxbase.fst.getpropertiesfstkerror 0  fstkerror  0$^  if unlikelypyxt0 $^$^     pywrapfst.pyx0000$^      $^      if self.fst.get.propertiesfst.kerror true  fst.kerror$^        raise fstoperroroperation failed              $^  $^    cdef void addarcself int00 state arc arc except $^ $^    pyxt0  pyxgetmoduleglobalnamepyxnsfstoperror if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  pyxpyobjectcallpyxt0 pyxtuple00 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxraisepyxt0 0 0 0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxerr0 0000 pyxl0error$^$^     pywrapfst.pyx0000$^      this function is not visible to python users.$^      $^      if self.fst.get.propertiesfst.kerror true  fst.kerror              $^        raise fstoperroroperation failed$^  $^ $^  $^$^   pywrapfst.pyx0000$^    $^  $^    cdef void checkmutatingimethodself except               $^      checks whether an operation mutating the fst has produced an error.$^  $^ $^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.mutablefst.checkmutatingimethod pyxclineno pyxlineno pyxfilename$^  pyxl0$^  pyxrefnannyfinishcontext$^$^$^ pywrapfst.pyx0000$^        raise fstoperroroperation failed$^  $^    cdef void addarcself int00 state arc arc except               $^      if not self.fst.get.validstateidstate$^        raise fstindexerrorstate index out of range$^ $^$^static void pyxf0pywrapfst00mutablefstaddarcstruct pyxobj0pywrapfstmutablefst pyxvself pyxt00basictypesint00 pyxvstate struct pyxobj0pywrapfstarc pyxvarc $^  pyxrefnannydeclarations$^  int pyxt0$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextaddarc 0$^$^   pywrapfst.pyx0000$^  $^    cdef void addarcself int00 state arc arc except $^      if not self.fst.get.validstateidstate              $^        raise fstindexerrorstate index out of range$^      if not self.mfst.get.addarcstate derefarc.arc$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s fst$^    pyxerr0 0000 pyxl0error$^  $^  pyxt0  pyxvselfpyxbase.fst.getvalidstateidpyxvstate  0  0$^  if unlikelypyxt0 $^$^     pywrapfst.pyx0000$^    cdef void addarcself int00 state arc arc except $^      if not self.fst.get.validstateidstate$^        raise fstindexerrorstate index out of range              $^      if not self.mfst.get.addarcstate derefarc.arc$^        raise fstoperrorincompatible or invalid weight type$^ $^    pyxt0  pyxgetmoduleglobalnamepyxnsfstindexerror if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  pyxpyobjectcallpyxt0 pyxtuple00 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxraisepyxt0 0 0 0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxerr0 0000 pyxl0error$^$^     pywrapfst.pyx0000$^  $^    cdef void addarcself int00 state arc arc except $^      if not self.fst.get.validstateidstate              $^        raise fstindexerrorstate index out of range$^      if not self.mfst.get.addarcstate derefarc.arc$^ $^  $^$^   pywrapfst.pyx0000$^      if not self.fst.get.validstateidstate$^        raise fstindexerrorstate index out of range$^      if not self.mfst.get.addarcstate derefarc.arc              $^        raise fstoperrorincompatible or invalid weight type$^      self.checkmutatingimethod$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s mfst$^    pyxerr0 0000 pyxl0error$^  $^  if unlikelypyobject pyxvarc  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s arc$^    pyxerr0 0000 pyxl0error$^  $^  pyxt0  pyxvselfmfst.getaddarcpyxvstate pyxvarcarc  0  0$^  if unlikelypyxt0 $^$^     pywrapfst.pyx0000$^        raise fstindexerrorstate index out of range$^      if not self.mfst.get.addarcstate derefarc.arc$^        raise fstoperrorincompatible or invalid weight type              $^      self.checkmutatingimethod$^  $^ $^    pyxt0  pyxgetmoduleglobalnamepyxnsfstoperror if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  pyxpyobjectcallpyxt0 pyxtuple00 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxraisepyxt0 0 0 0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxerr0 0000 pyxl0error$^$^     pywrapfst.pyx0000$^      if not self.fst.get.validstateidstate$^        raise fstindexerrorstate index out of range$^      if not self.mfst.get.addarcstate derefarc.arc              $^        raise fstoperrorincompatible or invalid weight type$^      self.checkmutatingimethod$^ $^  $^$^   pywrapfst.pyx0000$^      if not self.mfst.get.addarcstate derefarc.arc$^        raise fstoperrorincompatible or invalid weight type$^      self.checkmutatingimethod              $^  $^    def addarcself int00 state arc arc$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s checkmutatingimethod$^    pyxerr0 0000 pyxl0error$^  $^  struct pyxvtabstruct0pywrapfstmutablefst pyxvselfpyxbase.pyxvtabcheckmutatingimethodpyxvself if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^        raise fstoperroroperation failed$^  $^    cdef void addarcself int00 state arc arc except               $^      if not self.fst.get.validstateidstate$^        raise fstindexerrorstate index out of range$^ $^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.mutablefst.addarc pyxclineno pyxlineno pyxfilename$^  pyxl0$^  pyxrefnannyfinishcontext$^$^$^ pywrapfst.pyx0000$^      self.checkmutatingimethod$^  $^    def addarcself int00 state arc arc              $^      $^      addarcself state arc$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00mutablefst0addarcpyobject pyxvself pyobject pyxargs pyobject pyxkwds proto$^static char pyxdoc0pywrapfst00mutablefstaddarc  n    addarcself state arcnn    adds a new arc to the fst and return self.nn    argsn      state the integer index of the source state.n      arc the arc to add.nn    returnsn      self.nn    raisesn      fstindexerror state index out of range.n      fstopdexerror incompatible or invalid weight type.nn    see also addstate.n    $^static pyobject pyxpw0pywrapfst00mutablefst0addarcpyobject pyxvself pyobject pyxargs pyobject pyxkwds $^  pyxt00basictypesint00 pyxvstate$^  struct pyxobj0pywrapfstarc pyxvarc  0$^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextaddarc wrapper 0$^  $^    static pyobject pyxpyargnames  pyxnsstatepyxnsarc0$^    pyobject values0  00$^    if unlikelypyxkwds $^      pyssizet kwargs$^      const pyssizet posargs  pytuplegetsizepyxargs$^      switch posargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 break$^        default goto pyxl0argtupleerror$^      $^      kwargs  pydictsizepyxkwds$^      switch posargs $^        case  0$^        if likelyvalues0  pyxpydictgetitemstrpyxkwds pyxnsstate  0 kwargs$^        else goto pyxl0argtupleerror$^        cythonfallthrough$^        case  0$^        if likelyvalues0  pyxpydictgetitemstrpyxkwds pyxnsarc  0 kwargs$^        else $^          pyxraiseargtupleinvalidaddarc 0 0 0 0 pyxerr0 0000 pyxl0error$^        $^      $^      if unlikelykwargs  0 $^        if unlikelypyxparseoptionalkeywordspyxkwds pyxpyargnames 0 values posargs addarc  0 pyxerr0 0000 pyxl0error$^      $^     else if pytuplegetsizepyxargs  0 $^      goto pyxl0argtupleerror$^     else $^      values0  pytuplegetitempyxargs 0$^      values0  pytuplegetitempyxargs 0$^    $^    pyxvstate  pyxpyintasint00tvalues0 if unlikelypyxvstate  int00t0  pyerroccurred pyxerr0 0000 pyxl0error$^    pyxvarc  struct pyxobj0pywrapfstarc values0$^  $^  goto pyxl0argumentunpackingdone$^  pyxl0argtupleerror$^  pyxraiseargtupleinvalidaddarc 0 0 0 pytuplegetsizepyxargs pyxerr0 0000 pyxl0error$^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablefst.addarc pyxclineno pyxlineno pyxfilename$^  pyxrefnannyfinishcontext$^  return null$^  pyxl0argumentunpackingdone$^  if unlikelypyxargtypetestpyobject pyxvarc pyxptype0pywrapfstarc 0 arc 0 pyxerr0 0000 pyxl0error$^  pyxr  pyxpf0pywrapfst00mutablefstaddarcstruct pyxobj0pywrapfstmutablefst pyxvself pyxvstate pyxvarc$^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxr  null$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00mutablefstaddarcstruct pyxobj0pywrapfstmutablefst pyxvself pyxt00basictypesint00 pyxvstate struct pyxobj0pywrapfstarc pyxvarc $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextaddarc 0$^$^   pywrapfst.pyx0000$^      see also addstate.$^      $^      self.addarcstate arc              $^      return self$^  $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s addarc$^    pyxerr0 0000 pyxl0error$^  $^  struct pyxvtabstruct0pywrapfstmutablefst pyxvselfpyxbase.pyxvtabaddarcpyxvself pyxvstate pyxvarc if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^      $^      self.addarcstate arc$^      return self              $^  $^    cpdef int00 addstateself except $^ $^  pyxxdecrefpyxr$^  pyxincrefpyobject pyxvself$^  pyxr  pyobject pyxvself$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      self.checkmutatingimethod$^  $^    def addarcself int00 state arc arc              $^      $^      addarcself state arc$^ $^$^   function exit code $^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablefst.addarc pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return self$^  $^    cpdef int00 addstateself except               $^      $^      addstateself$^ $^$^static pyobject pyxpw0pywrapfst00mutablefst0addstatepyobject pyxvself cythonunused pyobject unused proto$^static pyxt00basictypesint00 pyxf0pywrapfst00mutablefstaddstatestruct pyxobj0pywrapfstmutablefst pyxvself int pyxskipdispatch $^  pyxt00basictypesint00 pyxvresult$^  pyxt00basictypesint00 pyxr$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxt00basictypesint00 pyxt0$^  pyxrefnannysetupcontextaddstate 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnsaddstate if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst00mutablefst0addstate $^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxdecrefpyxt0 pyxt0  0$^       else $^        pyxt0  pyxpyobjectcallnoargpyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      $^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxt0  pyxpyintasint00tpyxt0 if unlikelypyxt0  int00t0  pyerroccurred pyxerr0 0000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxr  pyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx0000$^      see also addarc setstart setfinal.$^      $^      cdef int00 result  self.mfst.get.addstate              $^      self.checkmutatingimethod$^      return result$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s mfst$^    pyxerr0 0000 pyxl0error$^  $^  pyxvresult  pyxvselfmfst.getaddstate$^$^   pywrapfst.pyx0000$^      $^      cdef int00 result  self.mfst.get.addstate$^      self.checkmutatingimethod              $^      return result$^  $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s checkmutatingimethod$^    pyxerr0 0000 pyxl0error$^  $^  struct pyxvtabstruct0pywrapfstmutablefst pyxvselfpyxbase.pyxvtabcheckmutatingimethodpyxvself if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^      cdef int00 result  self.mfst.get.addstate$^      self.checkmutatingimethod$^      return result              $^  $^    cdef void arcsortself sorttypebilabel except $^ $^  pyxr  pyxvresult$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      return self$^  $^    cpdef int00 addstateself except               $^      $^      addstateself$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.mutablefst.addstate pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst00mutablefst0addstatepyobject pyxvself cythonunused pyobject unused proto$^static char pyxdoc0pywrapfst00mutablefst0addstate  n    addstateselfnn    adds a new state to the fst and returns the state id.nn    returnsn      the integer index of the new state.nn    see also addarc setstart setfinal.n    $^static pyobject pyxpw0pywrapfst00mutablefst0addstatepyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextaddstate wrapper 0$^  pyxr  pyxpf0pywrapfst00mutablefst0addstatestruct pyxobj0pywrapfstmutablefst pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00mutablefst0addstatestruct pyxobj0pywrapfstmutablefst pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyxt00basictypesint00 pyxt0$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextaddstate 0$^  pyxxdecrefpyxr$^  pyxt0  pyxf0pywrapfst00mutablefstaddstatepyxvself 0 if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^  pyxt0  pyxpyintfromint00tpyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.mutablefst.addstate pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return result$^  $^    cdef void arcsortself sorttypebilabel except               $^      cdef fst.arcsorttype sorttypeenum$^      if not fst.getarcsorttypetostringsorttype addrsorttypeenum$^ $^$^static void pyxf0pywrapfst00mutablefstarcsortstruct pyxobj0pywrapfstmutablefst pyxvself struct pyxoptargs0pywrapfst00mutablefstarcsort pyxoptionalargs $^  pyobject pyxvsorttype  pyobject pyxnbilabel$^  enum fstscriptarcsorttype pyxvsorttypeenum$^  pyxrefnannydeclarations$^  stdstring pyxt0$^  int pyxt0$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextarcsort 0$^  if pyxoptionalargs $^    if pyxoptionalargspyxn  0 $^      pyxvsorttype  pyxoptionalargssorttype$^    $^  $^$^   pywrapfst.pyx0000$^    cdef void arcsortself sorttypebilabel except $^      cdef fst.arcsorttype sorttypeenum$^      if not fst.getarcsorttypetostringsorttype addrsorttypeenum              $^        raise fstargerrorunknown sort type r.formatsorttype$^      fst.arcsortself.mfst.get sorttypeenum$^ $^  pyxt0  pyxf0pywrapfsttostringpyxvsorttype null if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^  pyxt0  fstscriptgetarcsorttypepyxt0 pyxvsorttypeenum  0  0$^  if unlikelypyxt0 $^$^     pywrapfst.pyx0000$^      cdef fst.arcsorttype sorttypeenum$^      if not fst.getarcsorttypetostringsorttype addrsorttypeenum$^        raise fstargerrorunknown sort type r.formatsorttype              $^      fst.arcsortself.mfst.get sorttypeenum$^      self.checkmutatingimethod$^ $^    pyxt0  pyxgetmoduleglobalnamepyxnsfstargerror if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  pyxpyobjectgetattrstrpyxkpsunknownsorttyper pyxnsformat if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  null$^    if cythonunpackmethods  likelypymethodcheckpyxt0 $^      pyxt0  pymethodgetselfpyxt0$^      if likelypyxt0 $^        pyobject function  pymethodgetfunctionpyxt0$^        pyxincrefpyxt0$^        pyxincreffunction$^        pyxdecrefsetpyxt0 function$^      $^    $^    if pyxt0 $^      pyxt0  pyxpyobjectcalloneargpyxt0 pyxvsorttype if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxgotrefpyxt0$^     else $^      if cythonfastpycall$^      if pyfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxvsorttype$^        pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^       else$^      endif$^      if cythonfastpyccall$^      if pyxpyfastcfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxvsorttype$^        pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^       else$^      endif$^      $^        pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxgotrefpyxt0$^        pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^        pyxincrefpyxvsorttype$^        pyxgiverefpyxvsorttype$^        pytuplesetitempyxt0 00 pyxvsorttype$^        pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^      $^    $^    pyxdecrefpyxt0 pyxt0  0$^    pyxt0  null$^    if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^      pyxt0  pymethodgetselfpyxt0$^      if likelypyxt0 $^        pyobject function  pymethodgetfunctionpyxt0$^        pyxincrefpyxt0$^        pyxincreffunction$^        pyxdecrefsetpyxt0 function$^      $^    $^    if pyxt0 $^      pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxgotrefpyxt0$^     else $^      if cythonfastpycall$^      if pyfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxt0$^        pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^       else$^      endif$^      if cythonfastpyccall$^      if pyxpyfastcfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxt0$^        pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^       else$^      endif$^      $^        pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxgotrefpyxt0$^        pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^        pyxgiverefpyxt0$^        pytuplesetitempyxt0 00 pyxt0$^        pyxt0  0$^        pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^      $^    $^    pyxdecrefpyxt0 pyxt0  0$^    pyxraisepyxt0 0 0 0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxerr0 0000 pyxl0error$^$^     pywrapfst.pyx0000$^    cdef void arcsortself sorttypebilabel except $^      cdef fst.arcsorttype sorttypeenum$^      if not fst.getarcsorttypetostringsorttype addrsorttypeenum              $^        raise fstargerrorunknown sort type r.formatsorttype$^      fst.arcsortself.mfst.get sorttypeenum$^ $^  $^$^   pywrapfst.pyx0000$^      if not fst.getarcsorttypetostringsorttype addrsorttypeenum$^        raise fstargerrorunknown sort type r.formatsorttype$^      fst.arcsortself.mfst.get sorttypeenum              $^      self.checkmutatingimethod$^  $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s mfst$^    pyxerr0 0000 pyxl0error$^  $^  fstscriptarcsortpyxvselfmfst.get pyxvsorttypeenum$^$^   pywrapfst.pyx0000$^        raise fstargerrorunknown sort type r.formatsorttype$^      fst.arcsortself.mfst.get sorttypeenum$^      self.checkmutatingimethod              $^  $^    def arcsortself sorttypebilabel$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s checkmutatingimethod$^    pyxerr0 0000 pyxl0error$^  $^  struct pyxvtabstruct0pywrapfstmutablefst pyxvselfpyxbase.pyxvtabcheckmutatingimethodpyxvself if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^      return result$^  $^    cdef void arcsortself sorttypebilabel except               $^      cdef fst.arcsorttype sorttypeenum$^      if not fst.getarcsorttypetostringsorttype addrsorttypeenum$^ $^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.mutablefst.arcsort pyxclineno pyxlineno pyxfilename$^  pyxl0$^  pyxrefnannyfinishcontext$^$^$^ pywrapfst.pyx0000$^      self.checkmutatingimethod$^  $^    def arcsortself sorttypebilabel              $^      $^      arcsortself sorttypeilabel$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00mutablefst0arcsortpyobject pyxvself pyobject pyxargs pyobject pyxkwds proto$^static char pyxdoc0pywrapfst00mutablefst0arcsort  n    arcsortself sorttypeilabelnn    sorts arcs leaving each state of the fst.nn    this operation destructively sorts arcs leaving each state using eithern    input or output labels.nn    argsn      sorttype either ilabel sort arcs according to input labels orn          olabel sort arcs according to output labels.nn    returnsn      self.nn    raisesn      fstargerror unknown sort type.nn    see also topsort.n    $^static pyobject pyxpw0pywrapfst00mutablefst0arcsortpyobject pyxvself pyobject pyxargs pyobject pyxkwds $^  pyobject pyxvsorttype  0$^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextarcsort wrapper 0$^  $^    static pyobject pyxpyargnames  pyxnssorttype0$^    pyobject values0  0$^    values0  pyobject pyxnbilabel$^    if unlikelypyxkwds $^      pyssizet kwargs$^      const pyssizet posargs  pytuplegetsizepyxargs$^      switch posargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 break$^        default goto pyxl0argtupleerror$^      $^      kwargs  pydictsizepyxkwds$^      switch posargs $^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnssorttype$^          if value  values0  value kwargs $^        $^      $^      if unlikelykwargs  0 $^        if unlikelypyxparseoptionalkeywordspyxkwds pyxpyargnames 0 values posargs arcsort  0 pyxerr0 0000 pyxl0error$^      $^     else $^      switch pytuplegetsizepyxargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 break$^        default goto pyxl0argtupleerror$^      $^    $^    pyxvsorttype  values0$^  $^  goto pyxl0argumentunpackingdone$^  pyxl0argtupleerror$^  pyxraiseargtupleinvalidarcsort 0 0 0 pytuplegetsizepyxargs pyxerr0 0000 pyxl0error$^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablefst.arcsort pyxclineno pyxlineno pyxfilename$^  pyxrefnannyfinishcontext$^  return null$^  pyxl0argumentunpackingdone$^  pyxr  pyxpf0pywrapfst00mutablefst0arcsortstruct pyxobj0pywrapfstmutablefst pyxvself pyxvsorttype$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00mutablefst0arcsortstruct pyxobj0pywrapfstmutablefst pyxvself pyobject pyxvsorttype $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  struct pyxoptargs0pywrapfst00mutablefstarcsort pyxt0$^  pyxrefnannysetupcontextarcsort 0$^$^   pywrapfst.pyx0000$^      see also topsort.$^      $^      self.arcsortsorttype              $^      return self$^  $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s arcsort$^    pyxerr0 0000 pyxl0error$^  $^  pyxt0.pyxn  0$^  pyxt0.sorttype  pyxvsorttype$^  struct pyxvtabstruct0pywrapfstmutablefst pyxvselfpyxbase.pyxvtabarcsortpyxvself pyxt0 if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^      $^      self.arcsortsorttype$^      return self              $^  $^    cdef void closureself bool closureplusfalse except $^ $^  pyxxdecrefpyxr$^  pyxincrefpyobject pyxvself$^  pyxr  pyobject pyxvself$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      self.checkmutatingimethod$^  $^    def arcsortself sorttypebilabel              $^      $^      arcsortself sorttypeilabel$^ $^$^   function exit code $^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablefst.arcsort pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return self$^  $^    cdef void closureself bool closureplusfalse except               $^      fst.closureself.mfst.get fst.getclosuretypeclosureplus$^      self.checkmutatingimethod$^ $^$^static void pyxf0pywrapfst00mutablefstclosurestruct pyxobj0pywrapfstmutablefst pyxvself struct pyxoptargs0pywrapfst00mutablefstclosure pyxoptionalargs $^  bool pyxvclosureplus  bool0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextclosure 0$^  if pyxoptionalargs $^    if pyxoptionalargspyxn  0 $^      pyxvclosureplus  pyxoptionalargsclosureplus$^    $^  $^$^   pywrapfst.pyx0000$^  $^    cdef void closureself bool closureplusfalse except $^      fst.closureself.mfst.get fst.getclosuretypeclosureplus              $^      self.checkmutatingimethod$^  $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s mfst$^    pyxerr0 0000 pyxl0error$^  $^  fstscriptclosurepyxvselfmfst.get fstscriptgetclosuretypepyxvclosureplus$^$^   pywrapfst.pyx0000$^    cdef void closureself bool closureplusfalse except $^      fst.closureself.mfst.get fst.getclosuretypeclosureplus$^      self.checkmutatingimethod              $^  $^    def closureself bool closureplusfalse$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s checkmutatingimethod$^    pyxerr0 0000 pyxl0error$^  $^  struct pyxvtabstruct0pywrapfstmutablefst pyxvselfpyxbase.pyxvtabcheckmutatingimethodpyxvself if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^      return self$^  $^    cdef void closureself bool closureplusfalse except               $^      fst.closureself.mfst.get fst.getclosuretypeclosureplus$^      self.checkmutatingimethod$^ $^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablefst.closure pyxclineno pyxlineno pyxfilename$^  pyxl0$^  pyxrefnannyfinishcontext$^$^$^ pywrapfst.pyx0000$^      self.checkmutatingimethod$^  $^    def closureself bool closureplusfalse              $^      $^      closureself closureplusfalse$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00mutablefst0closurepyobject pyxvself pyobject pyxargs pyobject pyxkwds proto$^static char pyxdoc0pywrapfst00mutablefst0closure  n    closureself closureplusfalsenn    computes concatenative closure.nn    this operation destructively converts the fst to its concatenative closure.n    if a transduces string x to y with weight a then the closure transduces xn    to y with weight a xx to yy with weight a otimes a xxx to yyy with weightn    a otimes a otimes a and so on. the empty string is also transduced ton    itself with semiring one if closureplus is false.nn    argsn      closureplus if false do not accept the empty string.nn    returnsn      self.n    $^static pyobject pyxpw0pywrapfst00mutablefst0closurepyobject pyxvself pyobject pyxargs pyobject pyxkwds $^  bool pyxvclosureplus$^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextclosure wrapper 0$^  $^    static pyobject pyxpyargnames  pyxnsclosureplus0$^    pyobject values0  0$^    if unlikelypyxkwds $^      pyssizet kwargs$^      const pyssizet posargs  pytuplegetsizepyxargs$^      switch posargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 break$^        default goto pyxl0argtupleerror$^      $^      kwargs  pydictsizepyxkwds$^      switch posargs $^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnsclosureplus$^          if value  values0  value kwargs $^        $^      $^      if unlikelykwargs  0 $^        if unlikelypyxparseoptionalkeywordspyxkwds pyxpyargnames 0 values posargs closure  0 pyxerr0 0000 pyxl0error$^      $^     else $^      switch pytuplegetsizepyxargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 break$^        default goto pyxl0argtupleerror$^      $^    $^    if values0 $^      pyxvclosureplus  pyxpyobjectistruevalues0 if unlikelypyxvclosureplus  bool0  pyerroccurred pyxerr0 0000 pyxl0error$^     else $^      pyxvclosureplus  bool0$^    $^  $^  goto pyxl0argumentunpackingdone$^  pyxl0argtupleerror$^  pyxraiseargtupleinvalidclosure 0 0 0 pytuplegetsizepyxargs pyxerr0 0000 pyxl0error$^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablefst.closure pyxclineno pyxlineno pyxfilename$^  pyxrefnannyfinishcontext$^  return null$^  pyxl0argumentunpackingdone$^  pyxr  pyxpf0pywrapfst00mutablefst0closurestruct pyxobj0pywrapfstmutablefst pyxvself pyxvclosureplus$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00mutablefst0closurestruct pyxobj0pywrapfstmutablefst pyxvself bool pyxvclosureplus $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  struct pyxoptargs0pywrapfst00mutablefstclosure pyxt0$^  pyxrefnannysetupcontextclosure 0$^$^   pywrapfst.pyx0000$^        self.$^      $^      self.closureclosureplus              $^      return self$^  $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s closure$^    pyxerr0 0000 pyxl0error$^  $^  pyxt0.pyxn  0$^  pyxt0.closureplus  pyxvclosureplus$^  struct pyxvtabstruct0pywrapfstmutablefst pyxvselfpyxbase.pyxvtabclosurepyxvself pyxt0 if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^      $^      self.closureclosureplus$^      return self              $^  $^    cdef void concatself fst ifst except $^ $^  pyxxdecrefpyxr$^  pyxincrefpyobject pyxvself$^  pyxr  pyobject pyxvself$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      self.checkmutatingimethod$^  $^    def closureself bool closureplusfalse              $^      $^      closureself closureplusfalse$^ $^$^   function exit code $^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablefst.closure pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return self$^  $^    cdef void concatself fst ifst except               $^      fst.concatself.mfst.get derefifst.fst$^      self.checkmutatingimethod$^ $^$^static void pyxf0pywrapfst00mutablefstconcatstruct pyxobj0pywrapfstmutablefst pyxvself struct pyxobj0pywrapfstfst pyxvifst $^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextconcat 0$^$^   pywrapfst.pyx0000$^  $^    cdef void concatself fst ifst except $^      fst.concatself.mfst.get derefifst.fst              $^      self.checkmutatingimethod$^  $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s mfst$^    pyxerr0 0000 pyxl0error$^  $^  if unlikelypyobject pyxvifst  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s fst$^    pyxerr0 0000 pyxl0error$^  $^  fstscriptconcatpyxvselfmfst.get pyxvifstfst$^$^   pywrapfst.pyx0000$^    cdef void concatself fst ifst except $^      fst.concatself.mfst.get derefifst.fst$^      self.checkmutatingimethod              $^  $^    def concatself fst ifst$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s checkmutatingimethod$^    pyxerr0 0000 pyxl0error$^  $^  struct pyxvtabstruct0pywrapfstmutablefst pyxvselfpyxbase.pyxvtabcheckmutatingimethodpyxvself if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^      return self$^  $^    cdef void concatself fst ifst except               $^      fst.concatself.mfst.get derefifst.fst$^      self.checkmutatingimethod$^ $^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablefst.concat pyxclineno pyxlineno pyxfilename$^  pyxl0$^  pyxrefnannyfinishcontext$^$^$^ pywrapfst.pyx0000$^      self.checkmutatingimethod$^  $^    def concatself fst ifst              $^      $^      concatself ifst$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00mutablefst0concatpyobject pyxvself pyobject pyxvifst proto$^static char pyxdoc0pywrapfst00mutablefst0concat  n    concatself ifstnn    computes the concatenation product of two fsts.nn    this operation destructively concatenates the fst with a second fst. if an    transduces string x to y with weight a and b transduces string w to v withn    weight b then their concatenation transduces string xw to yv with weight an    otimes b.nn    argsn      ifst the second input fst.nn    returnsn      self.n    $^static pyobject pyxpw0pywrapfst00mutablefst0concatpyobject pyxvself pyobject pyxvifst $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextconcat wrapper 0$^  if unlikelypyxargtypetestpyobject pyxvifst pyxptype0pywrapfstfst 0 ifst 0 pyxerr0 0000 pyxl0error$^  pyxr  pyxpf0pywrapfst00mutablefst0concatstruct pyxobj0pywrapfstmutablefst pyxvself struct pyxobj0pywrapfstfst pyxvifst$^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxr  null$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00mutablefst0concatstruct pyxobj0pywrapfstmutablefst pyxvself struct pyxobj0pywrapfstfst pyxvifst $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextconcat 0$^$^   pywrapfst.pyx0000$^        self.$^      $^      self.concatifst              $^      return self$^  $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s concat$^    pyxerr0 0000 pyxl0error$^  $^  struct pyxvtabstruct0pywrapfstmutablefst pyxvselfpyxbase.pyxvtabconcatpyxvself pyxvifst if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^      $^      self.concatifst$^      return self              $^  $^    cdef void connectself except $^ $^  pyxxdecrefpyxr$^  pyxincrefpyobject pyxvself$^  pyxr  pyobject pyxvself$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      self.checkmutatingimethod$^  $^    def concatself fst ifst              $^      $^      concatself ifst$^ $^$^   function exit code $^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablefst.concat pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return self$^  $^    cdef void connectself except               $^      fst.connectself.mfst.get$^      self.checkmutatingimethod$^ $^$^static void pyxf0pywrapfst00mutablefstconnectstruct pyxobj0pywrapfstmutablefst pyxvself $^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextconnect 0$^$^   pywrapfst.pyx0000$^  $^    cdef void connectself except $^      fst.connectself.mfst.get              $^      self.checkmutatingimethod$^  $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s mfst$^    pyxerr0 0000 pyxl0error$^  $^  fstscriptconnectpyxvselfmfst.get$^$^   pywrapfst.pyx0000$^    cdef void connectself except $^      fst.connectself.mfst.get$^      self.checkmutatingimethod              $^  $^    def connectself$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s checkmutatingimethod$^    pyxerr0 0000 pyxl0error$^  $^  struct pyxvtabstruct0pywrapfstmutablefst pyxvselfpyxbase.pyxvtabcheckmutatingimethodpyxvself if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^      return self$^  $^    cdef void connectself except               $^      fst.connectself.mfst.get$^      self.checkmutatingimethod$^ $^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablefst.connect pyxclineno pyxlineno pyxfilename$^  pyxl0$^  pyxrefnannyfinishcontext$^$^$^ pywrapfst.pyx0000$^      self.checkmutatingimethod$^  $^    def connectself              $^      $^      connectself$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00mutablefst00connectpyobject pyxvself cythonunused pyobject unused proto$^static char pyxdoc0pywrapfst00mutablefst00connect  n    connectselfnn    removes unsuccessful paths.nn    this operation destructively trims the fst removing states and arcs thatn    are not part of any successful path.nn    returnsn      self.n    $^static pyobject pyxpw0pywrapfst00mutablefst00connectpyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextconnect wrapper 0$^  pyxr  pyxpf0pywrapfst00mutablefst00connectstruct pyxobj0pywrapfstmutablefst pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00mutablefst00connectstruct pyxobj0pywrapfstmutablefst pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextconnect 0$^$^   pywrapfst.pyx0000$^        self.$^      $^      self.connect              $^      return self$^  $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s connect$^    pyxerr0 0000 pyxl0error$^  $^  struct pyxvtabstruct0pywrapfstmutablefst pyxvselfpyxbase.pyxvtabconnectpyxvself if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^      $^      self.connect$^      return self              $^  $^    cdef void decodeself encodemapper encoder except $^ $^  pyxxdecrefpyxr$^  pyxincrefpyobject pyxvself$^  pyxr  pyobject pyxvself$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      self.checkmutatingimethod$^  $^    def connectself              $^      $^      connectself$^ $^$^   function exit code $^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablefst.connect pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return self$^  $^    cdef void decodeself encodemapper encoder except               $^      fst.decodeself.mfst.get derefencoder.encoder$^      self.checkmutatingimethod$^ $^$^static void pyxf0pywrapfst00mutablefstdecodestruct pyxobj0pywrapfstmutablefst pyxvself struct pyxobj0pywrapfstencodemapper pyxvencoder $^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextdecode 0$^$^   pywrapfst.pyx0000$^  $^    cdef void decodeself encodemapper encoder except $^      fst.decodeself.mfst.get derefencoder.encoder              $^      self.checkmutatingimethod$^  $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s mfst$^    pyxerr0 0000 pyxl0error$^  $^  if unlikelypyobject pyxvencoder  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s encoder$^    pyxerr0 0000 pyxl0error$^  $^  fstscriptdecodepyxvselfmfst.get pyxvencoderencoder$^$^   pywrapfst.pyx0000$^    cdef void decodeself encodemapper encoder except $^      fst.decodeself.mfst.get derefencoder.encoder$^      self.checkmutatingimethod              $^  $^    def decodeself encodemapper encoder$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s checkmutatingimethod$^    pyxerr0 0000 pyxl0error$^  $^  struct pyxvtabstruct0pywrapfstmutablefst pyxvselfpyxbase.pyxvtabcheckmutatingimethodpyxvself if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^      return self$^  $^    cdef void decodeself encodemapper encoder except               $^      fst.decodeself.mfst.get derefencoder.encoder$^      self.checkmutatingimethod$^ $^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablefst.decode pyxclineno pyxlineno pyxfilename$^  pyxl0$^  pyxrefnannyfinishcontext$^$^$^ pywrapfst.pyx0000$^      self.checkmutatingimethod$^  $^    def decodeself encodemapper encoder              $^      $^      decodeself encoder$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00mutablefst00decodepyobject pyxvself pyobject pyxvencoder proto$^static char pyxdoc0pywrapfst00mutablefst00decode  n    decodeself encodernn    decodes encoded labels andor weights.nn    this operation reverses the encoding performed by encode.nn    argsn      encoder an encodemapper object used to encode the fst.nn    returnsn      self.nn    see also encode.n    $^static pyobject pyxpw0pywrapfst00mutablefst00decodepyobject pyxvself pyobject pyxvencoder $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextdecode wrapper 0$^  if unlikelypyxargtypetestpyobject pyxvencoder pyxptype0pywrapfstencodemapper 0 encoder 0 pyxerr0 0000 pyxl0error$^  pyxr  pyxpf0pywrapfst00mutablefst00decodestruct pyxobj0pywrapfstmutablefst pyxvself struct pyxobj0pywrapfstencodemapper pyxvencoder$^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxr  null$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00mutablefst00decodestruct pyxobj0pywrapfstmutablefst pyxvself struct pyxobj0pywrapfstencodemapper pyxvencoder $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextdecode 0$^$^   pywrapfst.pyx0000$^      see also encode.$^      $^      self.decodeencoder              $^      return self$^  $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s decode$^    pyxerr0 0000 pyxl0error$^  $^  struct pyxvtabstruct0pywrapfstmutablefst pyxvselfpyxbase.pyxvtabdecodepyxvself pyxvencoder if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^      $^      self.decodeencoder$^      return self              $^  $^    cdef void deletearcsself int00 state sizet n0 except $^ $^  pyxxdecrefpyxr$^  pyxincrefpyobject pyxvself$^  pyxr  pyobject pyxvself$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      self.checkmutatingimethod$^  $^    def decodeself encodemapper encoder              $^      $^      decodeself encoder$^ $^$^   function exit code $^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablefst.decode pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return self$^  $^    cdef void deletearcsself int00 state sizet n0 except               $^      if not self.mfst.get.deletearcsstate n if n else$^              self.mfst.get.deletearcsstate$^ $^$^static void pyxf0pywrapfst00mutablefstdeletearcsstruct pyxobj0pywrapfstmutablefst pyxvself pyxt00basictypesint00 pyxvstate struct pyxoptargs0pywrapfst00mutablefstdeletearcs pyxoptionalargs $^  sizet pyxvn  sizet0$^  pyxrefnannydeclarations$^  bool pyxt0$^  int pyxt0$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextdeletearcs 0$^  if pyxoptionalargs $^    if pyxoptionalargspyxn  0 $^      pyxvn  pyxoptionalargsn$^    $^  $^$^   pywrapfst.pyx0000$^  $^    cdef void deletearcsself int00 state sizet n0 except $^      if not self.mfst.get.deletearcsstate n if n else              $^              self.mfst.get.deletearcsstate$^        raise fstindexerrorstate index out of range$^ $^  if pyxvn  0 $^    if unlikelypyobject pyxvself  pynone $^      pyerrformatpyexcattributeerror nonetype object has no attribute .00s mfst$^      pyxerr0 0000 pyxl0error$^    $^    pyxt0  pyxvselfmfst.getdeletearcspyxvstate pyxvn$^   else $^$^     pywrapfst.pyx0000$^    cdef void deletearcsself int00 state sizet n0 except $^      if not self.mfst.get.deletearcsstate n if n else$^              self.mfst.get.deletearcsstate              $^        raise fstindexerrorstate index out of range$^      self.checkmutatingimethod$^ $^    if unlikelypyobject pyxvself  pynone $^      pyerrformatpyexcattributeerror nonetype object has no attribute .00s mfst$^      pyxerr0 0000 pyxl0error$^    $^    pyxt0  pyxvselfmfst.getdeletearcspyxvstate$^  $^$^   pywrapfst.pyx0000$^  $^    cdef void deletearcsself int00 state sizet n0 except $^      if not self.mfst.get.deletearcsstate n if n else              $^              self.mfst.get.deletearcsstate$^        raise fstindexerrorstate index out of range$^ $^  pyxt0  pyxt0  0  0$^  if unlikelypyxt0 $^$^     pywrapfst.pyx0000$^      if not self.mfst.get.deletearcsstate n if n else$^              self.mfst.get.deletearcsstate$^        raise fstindexerrorstate index out of range              $^      self.checkmutatingimethod$^  $^ $^    pyxt0  pyxgetmoduleglobalnamepyxnsfstindexerror if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  pyxpyobjectcallpyxt0 pyxtuple00 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxraisepyxt0 0 0 0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxerr0 0000 pyxl0error$^$^     pywrapfst.pyx0000$^  $^    cdef void deletearcsself int00 state sizet n0 except $^      if not self.mfst.get.deletearcsstate n if n else              $^              self.mfst.get.deletearcsstate$^        raise fstindexerrorstate index out of range$^ $^  $^$^   pywrapfst.pyx0000$^              self.mfst.get.deletearcsstate$^        raise fstindexerrorstate index out of range$^      self.checkmutatingimethod              $^  $^    def deletearcsself int00 state sizet n0$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s checkmutatingimethod$^    pyxerr0 0000 pyxl0error$^  $^  struct pyxvtabstruct0pywrapfstmutablefst pyxvselfpyxbase.pyxvtabcheckmutatingimethodpyxvself if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^      return self$^  $^    cdef void deletearcsself int00 state sizet n0 except               $^      if not self.mfst.get.deletearcsstate n if n else$^              self.mfst.get.deletearcsstate$^ $^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.mutablefst.deletearcs pyxclineno pyxlineno pyxfilename$^  pyxl0$^  pyxrefnannyfinishcontext$^$^$^ pywrapfst.pyx0000$^      self.checkmutatingimethod$^  $^    def deletearcsself int00 state sizet n0              $^      $^      deletearcsself state n0$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00mutablefst00deletearcspyobject pyxvself pyobject pyxargs pyobject pyxkwds proto$^static char pyxdoc0pywrapfst00mutablefst00deletearcs  n    deletearcsself state n0nn    deletes arcs leaving a particular state.nn    argsn      state the integer index of a state.n      n an optional argument indicating how many arcs to be deleted. if thisn          argument is omitted or passed as zero all arcs from this state aren          deleted.nn    returnsn      self.nn    raisesn      fstindexerror state index out of range.nn    see also deletestates.n    $^static pyobject pyxpw0pywrapfst00mutablefst00deletearcspyobject pyxvself pyobject pyxargs pyobject pyxkwds $^  pyxt00basictypesint00 pyxvstate$^  sizet pyxvn$^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextdeletearcs wrapper 0$^  $^    static pyobject pyxpyargnames  pyxnsstatepyxnsn0$^    pyobject values0  00$^    if unlikelypyxkwds $^      pyssizet kwargs$^      const pyssizet posargs  pytuplegetsizepyxargs$^      switch posargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 break$^        default goto pyxl0argtupleerror$^      $^      kwargs  pydictsizepyxkwds$^      switch posargs $^        case  0$^        if likelyvalues0  pyxpydictgetitemstrpyxkwds pyxnsstate  0 kwargs$^        else goto pyxl0argtupleerror$^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnsn$^          if value  values0  value kwargs $^        $^      $^      if unlikelykwargs  0 $^        if unlikelypyxparseoptionalkeywordspyxkwds pyxpyargnames 0 values posargs deletearcs  0 pyxerr0 0000 pyxl0error$^      $^     else $^      switch pytuplegetsizepyxargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        break$^        default goto pyxl0argtupleerror$^      $^    $^    pyxvstate  pyxpyintasint00tvalues0 if unlikelypyxvstate  int00t0  pyerroccurred pyxerr0 0000 pyxl0error$^    if values0 $^      pyxvn  pyxpyintassizetvalues0 if unlikelypyxvn  sizet0  pyerroccurred pyxerr0 0000 pyxl0error$^     else $^      pyxvn  sizet0$^    $^  $^  goto pyxl0argumentunpackingdone$^  pyxl0argtupleerror$^  pyxraiseargtupleinvaliddeletearcs 0 0 0 pytuplegetsizepyxargs pyxerr0 0000 pyxl0error$^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablefst.deletearcs pyxclineno pyxlineno pyxfilename$^  pyxrefnannyfinishcontext$^  return null$^  pyxl0argumentunpackingdone$^  pyxr  pyxpf0pywrapfst00mutablefst00deletearcsstruct pyxobj0pywrapfstmutablefst pyxvself pyxvstate pyxvn$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00mutablefst00deletearcsstruct pyxobj0pywrapfstmutablefst pyxvself pyxt00basictypesint00 pyxvstate sizet pyxvn $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  struct pyxoptargs0pywrapfst00mutablefstdeletearcs pyxt0$^  pyxrefnannysetupcontextdeletearcs 0$^$^   pywrapfst.pyx0000$^      see also deletestates.$^      $^      self.deletearcsstate n              $^      return self$^  $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s deletearcs$^    pyxerr0 0000 pyxl0error$^  $^  pyxt0.pyxn  0$^  pyxt0.n  pyxvn$^  struct pyxvtabstruct0pywrapfstmutablefst pyxvselfpyxbase.pyxvtabdeletearcspyxvself pyxvstate pyxt0 if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^      $^      self.deletearcsstate n$^      return self              $^  $^    cdef void deletestatesself statesnone except $^ $^  pyxxdecrefpyxr$^  pyxincrefpyobject pyxvself$^  pyxr  pyobject pyxvself$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      self.checkmutatingimethod$^  $^    def deletearcsself int00 state sizet n0              $^      $^      deletearcsself state n0$^ $^$^   function exit code $^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablefst.deletearcs pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return self$^  $^    cdef void deletestatesself statesnone except               $^       only the former signature has a possible indexing failure.$^      if states$^ $^$^static void pyxf0pywrapfst00mutablefstdeletestatesstruct pyxobj0pywrapfstmutablefst pyxvself struct pyxoptargs0pywrapfst00mutablefstdeletestates pyxoptionalargs $^  pyobject pyxvstates  pyobject pynone$^  pyxrefnannydeclarations$^  int pyxt0$^  stdvectorpyxt00basictypesint00  pyxt0$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextdeletestates 0$^  if pyxoptionalargs $^    if pyxoptionalargspyxn  0 $^      pyxvstates  pyxoptionalargsstates$^    $^  $^$^   pywrapfst.pyx0000$^    cdef void deletestatesself statesnone except $^       only the former signature has a possible indexing failure.$^      if states              $^        if not self.mfst.get.deletestatesconst vectorint00 states$^          raise fstindexerrorstate index out of range$^ $^  pyxt0  pyxpyobjectistruepyxvstates if unlikelypyxt0  0 pyxerr0 0000 pyxl0error$^  if pyxt0 $^$^     pywrapfst.pyx0000$^       only the former signature has a possible indexing failure.$^      if states$^        if not self.mfst.get.deletestatesconst vectorint00 states              $^          raise fstindexerrorstate index out of range$^      else$^ $^    if unlikelypyobject pyxvself  pynone $^      pyerrformatpyexcattributeerror nonetype object has no attribute .00s mfst$^      pyxerr0 0000 pyxl0error$^    $^    pyxt0  pyxconvertvectorfrompypyxt00basictypesint00pyxvstates if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^    pyxt0  pyxvselfmfst.getdeletestatesstdvectorpyxt00basictypesint00  const pyxt0  0  0$^    if unlikelypyxt0 $^$^       pywrapfst.pyx0000$^      if states$^        if not self.mfst.get.deletestatesconst vectorint00 states$^          raise fstindexerrorstate index out of range              $^      else$^        self.mfst.get.deletestates$^ $^      pyxt0  pyxgetmoduleglobalnamepyxnsfstindexerror if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxgotrefpyxt0$^      pyxt0  pyxpyobjectcallpyxt0 pyxtuple00 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxraisepyxt0 0 0 0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxerr0 0000 pyxl0error$^$^       pywrapfst.pyx0000$^       only the former signature has a possible indexing failure.$^      if states$^        if not self.mfst.get.deletestatesconst vectorint00 states              $^          raise fstindexerrorstate index out of range$^      else$^ $^    $^$^     pywrapfst.pyx0000$^    cdef void deletestatesself statesnone except $^       only the former signature has a possible indexing failure.$^      if states              $^        if not self.mfst.get.deletestatesconst vectorint00 states$^          raise fstindexerrorstate index out of range$^ $^    goto pyxl0$^  $^$^   pywrapfst.pyx0000$^          raise fstindexerrorstate index out of range$^      else$^        self.mfst.get.deletestates              $^      self.checkmutatingimethod$^  $^ $^  else $^    if unlikelypyobject pyxvself  pynone $^      pyerrformatpyexcattributeerror nonetype object has no attribute .00s mfst$^      pyxerr0 0000 pyxl0error$^    $^    pyxvselfmfst.getdeletestates$^  $^  pyxl0$^$^   pywrapfst.pyx0000$^      else$^        self.mfst.get.deletestates$^      self.checkmutatingimethod              $^  $^    def deletestatesself statesnone$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s checkmutatingimethod$^    pyxerr0 0000 pyxl0error$^  $^  struct pyxvtabstruct0pywrapfstmutablefst pyxvselfpyxbase.pyxvtabcheckmutatingimethodpyxvself if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^      return self$^  $^    cdef void deletestatesself statesnone except               $^       only the former signature has a possible indexing failure.$^      if states$^ $^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.mutablefst.deletestates pyxclineno pyxlineno pyxfilename$^  pyxl0$^  pyxrefnannyfinishcontext$^$^$^ pywrapfst.pyx0000$^      self.checkmutatingimethod$^  $^    def deletestatesself statesnone              $^      $^      deletestatesself statesnone$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00mutablefst00deletestatespyobject pyxvself pyobject pyxargs pyobject pyxkwds proto$^static char pyxdoc0pywrapfst00mutablefst00deletestates  n    deletestatesself statesnonenn    deletes states.nn    argsn      states an optional iterable of integer indices of the states to ben          deleted. if this argument is omitted all states are deleted.nn    returnsn      self.nn    raisesn      fstindexerror state index out of range.nn    see also deletearcs.n    $^static pyobject pyxpw0pywrapfst00mutablefst00deletestatespyobject pyxvself pyobject pyxargs pyobject pyxkwds $^  pyobject pyxvstates  0$^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextdeletestates wrapper 0$^  $^    static pyobject pyxpyargnames  pyxnsstates0$^    pyobject values0  0$^    values0  pyobject pynone$^    if unlikelypyxkwds $^      pyssizet kwargs$^      const pyssizet posargs  pytuplegetsizepyxargs$^      switch posargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 break$^        default goto pyxl0argtupleerror$^      $^      kwargs  pydictsizepyxkwds$^      switch posargs $^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnsstates$^          if value  values0  value kwargs $^        $^      $^      if unlikelykwargs  0 $^        if unlikelypyxparseoptionalkeywordspyxkwds pyxpyargnames 0 values posargs deletestates  0 pyxerr0 0000 pyxl0error$^      $^     else $^      switch pytuplegetsizepyxargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 break$^        default goto pyxl0argtupleerror$^      $^    $^    pyxvstates  values0$^  $^  goto pyxl0argumentunpackingdone$^  pyxl0argtupleerror$^  pyxraiseargtupleinvaliddeletestates 0 0 0 pytuplegetsizepyxargs pyxerr0 0000 pyxl0error$^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablefst.deletestates pyxclineno pyxlineno pyxfilename$^  pyxrefnannyfinishcontext$^  return null$^  pyxl0argumentunpackingdone$^  pyxr  pyxpf0pywrapfst00mutablefst00deletestatesstruct pyxobj0pywrapfstmutablefst pyxvself pyxvstates$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00mutablefst00deletestatesstruct pyxobj0pywrapfstmutablefst pyxvself pyobject pyxvstates $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  struct pyxoptargs0pywrapfst00mutablefstdeletestates pyxt0$^  pyxrefnannysetupcontextdeletestates 0$^$^   pywrapfst.pyx0000$^      see also deletearcs.$^      $^      self.deletestatesstates              $^      return self$^  $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s deletestates$^    pyxerr0 0000 pyxl0error$^  $^  pyxt0.pyxn  0$^  pyxt0.states  pyxvstates$^  struct pyxvtabstruct0pywrapfstmutablefst pyxvselfpyxbase.pyxvtabdeletestatespyxvself pyxt0 if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^      $^      self.deletestatesstates$^      return self              $^  $^    cdef void encodeself encodemapper encoder except $^ $^  pyxxdecrefpyxr$^  pyxincrefpyobject pyxvself$^  pyxr  pyobject pyxvself$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      self.checkmutatingimethod$^  $^    def deletestatesself statesnone              $^      $^      deletestatesself statesnone$^ $^$^   function exit code $^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablefst.deletestates pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return self$^  $^    cdef void encodeself encodemapper encoder except               $^      fst.encodeself.mfst.get encoder.encoder.get$^      self.checkmutatingimethod$^ $^$^static void pyxf0pywrapfst00mutablefstencodestruct pyxobj0pywrapfstmutablefst pyxvself struct pyxobj0pywrapfstencodemapper pyxvencoder $^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextencode 0$^$^   pywrapfst.pyx0000$^  $^    cdef void encodeself encodemapper encoder except $^      fst.encodeself.mfst.get encoder.encoder.get              $^      self.checkmutatingimethod$^  $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s mfst$^    pyxerr0 0000 pyxl0error$^  $^  if unlikelypyobject pyxvencoder  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s encoder$^    pyxerr0 0000 pyxl0error$^  $^  fstscriptencodepyxvselfmfst.get pyxvencoderencoder.get$^$^   pywrapfst.pyx0000$^    cdef void encodeself encodemapper encoder except $^      fst.encodeself.mfst.get encoder.encoder.get$^      self.checkmutatingimethod              $^  $^    def encodeself encodemapper encoder$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s checkmutatingimethod$^    pyxerr0 0000 pyxl0error$^  $^  struct pyxvtabstruct0pywrapfstmutablefst pyxvselfpyxbase.pyxvtabcheckmutatingimethodpyxvself if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^      return self$^  $^    cdef void encodeself encodemapper encoder except               $^      fst.encodeself.mfst.get encoder.encoder.get$^      self.checkmutatingimethod$^ $^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablefst.encode pyxclineno pyxlineno pyxfilename$^  pyxl0$^  pyxrefnannyfinishcontext$^$^$^ pywrapfst.pyx0000$^      self.checkmutatingimethod$^  $^    def encodeself encodemapper encoder              $^      $^      encodeself encoder$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00mutablefst00encodepyobject pyxvself pyobject pyxvencoder proto$^static char pyxdoc0pywrapfst00mutablefst00encode  n    encodeself encodernn    encodes labels andor weights.nn    this operation allows for the representation of a weighted transducer as an    weighted acceptor an unweighted transducer or an unweighted acceptor byn    considering the pair input label output label the pair input labeln    weight or the triple input label output label weight as a singlen    label. applying this operation mutates the encodemapper argument whichn    can then be used to decode.nn    argsn      encoder an encodemapper object to be used as the encoder.nn    returnsn      self.nn    see also decode.n    $^static pyobject pyxpw0pywrapfst00mutablefst00encodepyobject pyxvself pyobject pyxvencoder $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextencode wrapper 0$^  if unlikelypyxargtypetestpyobject pyxvencoder pyxptype0pywrapfstencodemapper 0 encoder 0 pyxerr0 0000 pyxl0error$^  pyxr  pyxpf0pywrapfst00mutablefst00encodestruct pyxobj0pywrapfstmutablefst pyxvself struct pyxobj0pywrapfstencodemapper pyxvencoder$^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxr  null$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00mutablefst00encodestruct pyxobj0pywrapfstmutablefst pyxvself struct pyxobj0pywrapfstencodemapper pyxvencoder $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextencode 0$^$^   pywrapfst.pyx0000$^      see also decode.$^      $^      self.encodeencoder              $^      return self$^  $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s encode$^    pyxerr0 0000 pyxl0error$^  $^  struct pyxvtabstruct0pywrapfstmutablefst pyxvselfpyxbase.pyxvtabencodepyxvself pyxvencoder if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^      $^      self.encodeencoder$^      return self              $^  $^    cdef void invertself except $^ $^  pyxxdecrefpyxr$^  pyxincrefpyobject pyxvself$^  pyxr  pyobject pyxvself$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      self.checkmutatingimethod$^  $^    def encodeself encodemapper encoder              $^      $^      encodeself encoder$^ $^$^   function exit code $^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablefst.encode pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return self$^  $^    cdef void invertself except               $^      fst.invertself.mfst.get$^      self.checkmutatingimethod$^ $^$^static void pyxf0pywrapfst00mutablefstinvertstruct pyxobj0pywrapfstmutablefst pyxvself $^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextinvert 0$^$^   pywrapfst.pyx0000$^  $^    cdef void invertself except $^      fst.invertself.mfst.get              $^      self.checkmutatingimethod$^  $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s mfst$^    pyxerr0 0000 pyxl0error$^  $^  fstscriptinvertpyxvselfmfst.get$^$^   pywrapfst.pyx0000$^    cdef void invertself except $^      fst.invertself.mfst.get$^      self.checkmutatingimethod              $^  $^    def invertself$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s checkmutatingimethod$^    pyxerr0 0000 pyxl0error$^  $^  struct pyxvtabstruct0pywrapfstmutablefst pyxvselfpyxbase.pyxvtabcheckmutatingimethodpyxvself if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^      return self$^  $^    cdef void invertself except               $^      fst.invertself.mfst.get$^      self.checkmutatingimethod$^ $^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablefst.invert pyxclineno pyxlineno pyxfilename$^  pyxl0$^  pyxrefnannyfinishcontext$^$^$^ pywrapfst.pyx0000$^      self.checkmutatingimethod$^  $^    def invertself              $^      $^      invertself$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00mutablefst00invertpyobject pyxvself cythonunused pyobject unused proto$^static char pyxdoc0pywrapfst00mutablefst00invert  n    invertselfnn    inverts the fsts transduction.nn    this operation destructively inverts the fsts transduction by exchangingn    input and output labels.nn    returnsn      self.n    $^static pyobject pyxpw0pywrapfst00mutablefst00invertpyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextinvert wrapper 0$^  pyxr  pyxpf0pywrapfst00mutablefst00invertstruct pyxobj0pywrapfstmutablefst pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00mutablefst00invertstruct pyxobj0pywrapfstmutablefst pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextinvert 0$^$^   pywrapfst.pyx0000$^        self.$^      $^      self.invert              $^      return self$^  $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s invert$^    pyxerr0 0000 pyxl0error$^  $^  struct pyxvtabstruct0pywrapfstmutablefst pyxvselfpyxbase.pyxvtabinvertpyxvself if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^      $^      self.invert$^      return self              $^  $^    cdef void minimizeself float deltafst.kshortestdelta$^ $^  pyxxdecrefpyxr$^  pyxincrefpyobject pyxvself$^  pyxr  pyobject pyxvself$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      self.checkmutatingimethod$^  $^    def invertself              $^      $^      invertself$^ $^$^   function exit code $^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablefst.invert pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return self$^  $^    cdef void minimizeself float deltafst.kshortestdelta              $^                        bool allownondetfalse except $^       this runs inplace when the second argument is null.$^ $^$^static void pyxf0pywrapfst00mutablefstminimizestruct pyxobj0pywrapfstmutablefst pyxvself struct pyxoptargs0pywrapfst00mutablefstminimize pyxoptionalargs $^  float pyxvdelta  pyxk00$^$^   pywrapfst.pyx0000$^  $^    cdef void minimizeself float deltafst.kshortestdelta$^                        bool allownondetfalse except               $^       this runs inplace when the second argument is null.$^      fst.minimizeself.mfst.get null delta allownondet$^ $^  bool pyxvallownondet  bool0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextminimize 0$^  if pyxoptionalargs $^    if pyxoptionalargspyxn  0 $^      pyxvdelta  pyxoptionalargsdelta$^      if pyxoptionalargspyxn  0 $^        pyxvallownondet  pyxoptionalargsallownondet$^      $^    $^  $^$^   pywrapfst.pyx0000$^                        bool allownondetfalse except $^       this runs inplace when the second argument is null.$^      fst.minimizeself.mfst.get null delta allownondet              $^      self.checkmutatingimethod$^  $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s mfst$^    pyxerr0 0000 pyxl0error$^  $^  fstscriptminimizepyxvselfmfst.get null pyxvdelta pyxvallownondet$^$^   pywrapfst.pyx0000$^       this runs inplace when the second argument is null.$^      fst.minimizeself.mfst.get null delta allownondet$^      self.checkmutatingimethod              $^  $^    def minimizeself float deltafst.kshortestdelta bool allownondetfalse$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s checkmutatingimethod$^    pyxerr0 0000 pyxl0error$^  $^  struct pyxvtabstruct0pywrapfstmutablefst pyxvselfpyxbase.pyxvtabcheckmutatingimethodpyxvself if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^      return self$^  $^    cdef void minimizeself float deltafst.kshortestdelta              $^                        bool allownondetfalse except $^       this runs inplace when the second argument is null.$^ $^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablefst.minimize pyxclineno pyxlineno pyxfilename$^  pyxl0$^  pyxrefnannyfinishcontext$^$^$^ pywrapfst.pyx0000$^      self.checkmutatingimethod$^  $^    def minimizeself float deltafst.kshortestdelta bool allownondetfalse              $^      $^      minimizeself delta0e0 allownondetfalse$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00mutablefst00minimizepyobject pyxvself pyobject pyxargs pyobject pyxkwds proto$^static char pyxdoc0pywrapfst00mutablefst00minimize  n    minimizeself delta0e0 allownondetfalsenn    minimizes the fst.nn    this operation destructively performs the minimization of deterministicn    weighted automata and transducers. if the input fst a is an acceptor thisn    operation produces the minimal acceptor b equivalent to a i.e. then    acceptor with a minimal number of states that is equivalent to a. if then    input fst a is a transducer this operation internally builds an equivalentn    transducer with a minimal number of states. however this minimality isn    obtained by allowing transition having strings of symbols as output labelsn    this known in the litterature as a realtime transducer. such transducersn    are not directly supported by the library. this function will convert suchn    transducer by expanding each stringlabeled transition into a sequence ofn    transitions. this will results in the creation of new states hence losingn    the minimality property.nn    argsn      delta comparisonquantization delta.n      allownondet attempt minimization of nondeterministic fstnn    returnsn      self.n    $^static pyobject pyxpw0pywrapfst00mutablefst00minimizepyobject pyxvself pyobject pyxargs pyobject pyxkwds $^  float pyxvdelta$^  bool pyxvallownondet$^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextminimize wrapper 0$^  $^    static pyobject pyxpyargnames  pyxnsdeltapyxnsallownondet0$^    pyobject values0  00$^    if unlikelypyxkwds $^      pyssizet kwargs$^      const pyssizet posargs  pytuplegetsizepyxargs$^      switch posargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 break$^        default goto pyxl0argtupleerror$^      $^      kwargs  pydictsizepyxkwds$^      switch posargs $^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnsdelta$^          if value  values0  value kwargs $^        $^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnsallownondet$^          if value  values0  value kwargs $^        $^      $^      if unlikelykwargs  0 $^        if unlikelypyxparseoptionalkeywordspyxkwds pyxpyargnames 0 values posargs minimize  0 pyxerr0 0000 pyxl0error$^      $^     else $^      switch pytuplegetsizepyxargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 break$^        default goto pyxl0argtupleerror$^      $^    $^    if values0 $^      pyxvdelta  pyxpyfloatasfloatvalues0 if unlikelypyxvdelta  float0  pyerroccurred pyxerr0 0000 pyxl0error$^     else $^      pyxvdelta  pyxk00$^    $^    if values0 $^      pyxvallownondet  pyxpyobjectistruevalues0 if unlikelypyxvallownondet  bool0  pyerroccurred pyxerr0 0000 pyxl0error$^     else $^      pyxvallownondet  bool0$^    $^  $^  goto pyxl0argumentunpackingdone$^  pyxl0argtupleerror$^  pyxraiseargtupleinvalidminimize 0 0 0 pytuplegetsizepyxargs pyxerr0 0000 pyxl0error$^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablefst.minimize pyxclineno pyxlineno pyxfilename$^  pyxrefnannyfinishcontext$^  return null$^  pyxl0argumentunpackingdone$^  pyxr  pyxpf0pywrapfst00mutablefst00minimizestruct pyxobj0pywrapfstmutablefst pyxvself pyxvdelta pyxvallownondet$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00mutablefst00minimizestruct pyxobj0pywrapfstmutablefst pyxvself float pyxvdelta bool pyxvallownondet $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  struct pyxoptargs0pywrapfst00mutablefstminimize pyxt0$^  pyxrefnannysetupcontextminimize 0$^$^   pywrapfst.pyx0000$^        self.$^      $^      self.minimizedelta allownondet              $^      return self$^  $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s minimize$^    pyxerr0 0000 pyxl0error$^  $^  pyxt0.pyxn  0$^  pyxt0.delta  pyxvdelta$^  pyxt0.allownondet  pyxvallownondet$^  struct pyxvtabstruct0pywrapfstmutablefst pyxvselfpyxbase.pyxvtabminimizepyxvself pyxt0 if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^      $^      self.minimizedelta allownondet$^      return self              $^  $^    cpdef mutablearciterator mutablearcsself int00 state$^ $^  pyxxdecrefpyxr$^  pyxincrefpyobject pyxvself$^  pyxr  pyobject pyxvself$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      self.checkmutatingimethod$^  $^    def minimizeself float deltafst.kshortestdelta bool allownondetfalse              $^      $^      minimizeself delta0e0 allownondetfalse$^ $^$^   function exit code $^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablefst.minimize pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return self$^  $^    cpdef mutablearciterator mutablearcsself int00 state              $^      $^      mutablearcsself state$^ $^$^static pyobject pyxpw0pywrapfst00mutablefst00mutablearcspyobject pyxvself pyobject pyxargstate proto$^static struct pyxobj0pywrapfstmutablearciterator pyxf0pywrapfst00mutablefstmutablearcsstruct pyxobj0pywrapfstmutablefst pyxvself pyxt00basictypesint00 pyxvstate int pyxskipdispatch $^  struct pyxobj0pywrapfstmutablearciterator pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextmutablearcs 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnsmutablearcs if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst00mutablefst00mutablearcs $^      pyxxdecrefpyobject pyxr$^      pyxt0  pyxpyintfromint00tpyxvstate if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxgotrefpyxt0$^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^       else $^        if cythonfastpycall$^        if pyfunctioncheckpyxt0 $^          pyobject pyxtemp0  pyxt0 pyxt0$^          pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^          pyxxdecrefpyxt0 pyxt0  0$^          pyxgotrefpyxt0$^          pyxdecrefpyxt0 pyxt0  0$^         else$^        endif$^        if cythonfastpyccall$^        if pyxpyfastcfunctioncheckpyxt0 $^          pyobject pyxtemp0  pyxt0 pyxt0$^          pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^          pyxxdecrefpyxt0 pyxt0  0$^          pyxgotrefpyxt0$^          pyxdecrefpyxt0 pyxt0  0$^         else$^        endif$^        $^          pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^          pyxgotrefpyxt0$^          pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^          pyxgiverefpyxt0$^          pytuplesetitempyxt0 00 pyxt0$^          pyxt0  0$^          pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^          pyxgotrefpyxt0$^          pyxdecrefpyxt0 pyxt0  0$^        $^      $^      pyxdecrefpyxt0 pyxt0  0$^      if likelypyxt0  pynone  likelypyxtypetestpyxt0 pyxptype0pywrapfstmutablearciterator pyxerr0 0000 pyxl0error$^      pyxr  struct pyxobj0pywrapfstmutablearciterator pyxt0$^      pyxt0  0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx0000$^      see also arcs states.$^      $^      return mutablearciteratorself state              $^  $^    def mutableinputsymbolsself$^ $^  pyxxdecrefpyobject pyxr$^  pyxt0  pyxpyintfromint00tpyxvstate if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxt0  pytuplenew0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxincrefpyobject pyxvself$^  pyxgiverefpyobject pyxvself$^  pytuplesetitempyxt0 0 pyobject pyxvself$^  pyxgiverefpyxt0$^  pytuplesetitempyxt0 0 pyxt0$^  pyxt0  0$^  pyxt0  pyxpyobjectcallpyobject pyxptype0pywrapfstmutablearciterator pyxt0 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxdecrefpyxt0 pyxt0  0$^  pyxr  struct pyxobj0pywrapfstmutablearciterator pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      return self$^  $^    cpdef mutablearciterator mutablearcsself int00 state              $^      $^      mutablearcsself state$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.mutablefst.mutablearcs pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxl0$^  pyxxgiverefpyobject pyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst00mutablefst00mutablearcspyobject pyxvself pyobject pyxargstate proto$^static char pyxdoc0pywrapfst00mutablefst00mutablearcs  n    mutablearcsself statenn    returns a mutable iterator over arcs leaving the specified state.nn    argsn      state the source state id.nn    returnsn      a mutablearciterator.nn    see also arcs states.n    $^static pyobject pyxpw0pywrapfst00mutablefst00mutablearcspyobject pyxvself pyobject pyxargstate $^  pyxt00basictypesint00 pyxvstate$^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextmutablearcs wrapper 0$^  assertpyxargstate $^    pyxvstate  pyxpyintasint00tpyxargstate if unlikelypyxvstate  int00t0  pyerroccurred pyxerr0 0000 pyxl0error$^  $^  goto pyxl0argumentunpackingdone$^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablefst.mutablearcs pyxclineno pyxlineno pyxfilename$^  pyxrefnannyfinishcontext$^  return null$^  pyxl0argumentunpackingdone$^  pyxr  pyxpf0pywrapfst00mutablefst00mutablearcsstruct pyxobj0pywrapfstmutablefst pyxvself pyxt00basictypesint00pyxvstate$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00mutablefst00mutablearcsstruct pyxobj0pywrapfstmutablefst pyxvself pyxt00basictypesint00 pyxvstate $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextmutablearcs 0$^  pyxxdecrefpyxr$^  pyxt0  pyobject pyxf0pywrapfst00mutablefstmutablearcspyxvself pyxvstate 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.mutablefst.mutablearcs pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return mutablearciteratorself state$^  $^    def mutableinputsymbolsself              $^      $^      mutableinputsymbolsself$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00mutablefst00mutableinputsymbolspyobject pyxvself cythonunused pyobject unused proto$^static char pyxdoc0pywrapfst00mutablefst00mutableinputsymbols  n    mutableinputsymbolsselfnn    returns the fsts mutable input symbol table or none if none is present.n    $^static pyobject pyxpw0pywrapfst00mutablefst00mutableinputsymbolspyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextmutableinputsymbols wrapper 0$^  pyxr  pyxpf0pywrapfst00mutablefst00mutableinputsymbolsstruct pyxobj0pywrapfstmutablefst pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00mutablefst00mutableinputsymbolsstruct pyxobj0pywrapfstmutablefst pyxvself $^  fstsymboltable pyxvtst$^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  int pyxt0$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextmutableinputsymbols 0$^$^   pywrapfst.pyx0000$^      returns the fsts mutable input symbol table or none if none is present.$^      $^      cdef fst.symboltable tst  self.mfst.get.mutableinputsymbols              $^      if tst  null$^        return$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s mfst$^    pyxerr0 0000 pyxl0error$^  $^  pyxvtst  pyxvselfmfst.getmutableinputsymbols$^$^   pywrapfst.pyx0000$^      $^      cdef fst.symboltable tst  self.mfst.get.mutableinputsymbols$^      if tst  null              $^        return$^      return initmutablefstsymboltabletst self.mfst$^ $^  pyxt0  pyxvtst  null  0$^  if pyxt0 $^$^     pywrapfst.pyx0000$^      cdef fst.symboltable tst  self.mfst.get.mutableinputsymbols$^      if tst  null$^        return              $^      return initmutablefstsymboltabletst self.mfst$^  $^ $^    pyxxdecrefpyxr$^    pyxr  pynone pyxincrefpynone$^    goto pyxl0$^$^     pywrapfst.pyx0000$^      $^      cdef fst.symboltable tst  self.mfst.get.mutableinputsymbols$^      if tst  null              $^        return$^      return initmutablefstsymboltabletst self.mfst$^ $^  $^$^   pywrapfst.pyx0000$^      if tst  null$^        return$^      return initmutablefstsymboltabletst self.mfst              $^  $^    def mutableoutputsymbolsself$^ $^  pyxxdecrefpyxr$^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s mfst$^    pyxerr0 0000 pyxl0error$^  $^  pyxt0  pyobject pyxf0pywrapfstinitmutablefstsymboltablepyxvtst pyxvselfmfst if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      return mutablearciteratorself state$^  $^    def mutableinputsymbolsself              $^      $^      mutableinputsymbolsself$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.mutablefst.mutableinputsymbols pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return initmutablefstsymboltabletst self.mfst$^  $^    def mutableoutputsymbolsself              $^      $^      mutableoutputsymbolsself$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00mutablefst00mutableoutputsymbolspyobject pyxvself cythonunused pyobject unused proto$^static char pyxdoc0pywrapfst00mutablefst00mutableoutputsymbols  n    mutableoutputsymbolsselfnn    returns the fsts mutable output symbol table or none if none is present.n    $^static pyobject pyxpw0pywrapfst00mutablefst00mutableoutputsymbolspyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextmutableoutputsymbols wrapper 0$^  pyxr  pyxpf0pywrapfst00mutablefst00mutableoutputsymbolsstruct pyxobj0pywrapfstmutablefst pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00mutablefst00mutableoutputsymbolsstruct pyxobj0pywrapfstmutablefst pyxvself $^  fstsymboltable pyxvtst$^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  int pyxt0$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextmutableoutputsymbols 0$^$^   pywrapfst.pyx0000$^      returns the fsts mutable output symbol table or none if none is present.$^      $^      cdef fst.symboltable tst  self.mfst.get.mutableoutputsymbols              $^      if tst  null$^        return$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s mfst$^    pyxerr0 0000 pyxl0error$^  $^  pyxvtst  pyxvselfmfst.getmutableoutputsymbols$^$^   pywrapfst.pyx0000$^      $^      cdef fst.symboltable tst  self.mfst.get.mutableoutputsymbols$^      if tst  null              $^        return$^      return initmutablefstsymboltabletst self.mfst$^ $^  pyxt0  pyxvtst  null  0$^  if pyxt0 $^$^     pywrapfst.pyx0000$^      cdef fst.symboltable tst  self.mfst.get.mutableoutputsymbols$^      if tst  null$^        return              $^      return initmutablefstsymboltabletst self.mfst$^  $^ $^    pyxxdecrefpyxr$^    pyxr  pynone pyxincrefpynone$^    goto pyxl0$^$^     pywrapfst.pyx0000$^      $^      cdef fst.symboltable tst  self.mfst.get.mutableoutputsymbols$^      if tst  null              $^        return$^      return initmutablefstsymboltabletst self.mfst$^ $^  $^$^   pywrapfst.pyx0000$^      if tst  null$^        return$^      return initmutablefstsymboltabletst self.mfst              $^  $^    cpdef int00 numstatesself$^ $^  pyxxdecrefpyxr$^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s mfst$^    pyxerr0 0000 pyxl0error$^  $^  pyxt0  pyobject pyxf0pywrapfstinitmutablefstsymboltablepyxvtst pyxvselfmfst if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      return initmutablefstsymboltabletst self.mfst$^  $^    def mutableoutputsymbolsself              $^      $^      mutableoutputsymbolsself$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.mutablefst.mutableoutputsymbols pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return initmutablefstsymboltabletst self.mfst$^  $^    cpdef int00 numstatesself              $^      $^      numstatesself$^ $^$^static pyobject pyxpw0pywrapfst00mutablefst00numstatespyobject pyxvself cythonunused pyobject unused proto$^static pyxt00basictypesint00 pyxf0pywrapfst00mutablefstnumstatesstruct pyxobj0pywrapfstmutablefst pyxvself int pyxskipdispatch $^  pyxt00basictypesint00 pyxr$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxt00basictypesint00 pyxt0$^  pyxrefnannysetupcontextnumstates 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnsnumstates if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst00mutablefst00numstates $^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxdecrefpyxt0 pyxt0  0$^       else $^        pyxt0  pyxpyobjectcallnoargpyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      $^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxt0  pyxpyintasint00tpyxt0 if unlikelypyxt0  int00t0  pyerroccurred pyxerr0 0000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxr  pyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx0000$^      returns the number of states.$^      $^      return self.mfst.get.numstates              $^  $^    cdef void projectself bool projectoutputfalse except $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s mfst$^    pyxerr0 0000 pyxl0error$^  $^  pyxr  pyxvselfmfst.getnumstates$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      return initmutablefstsymboltabletst self.mfst$^  $^    cpdef int00 numstatesself              $^      $^      numstatesself$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxwriteunraisablepywrapfst.mutablefst.numstates pyxclineno pyxlineno pyxfilename 0 0$^  pyxr  0$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst00mutablefst00numstatespyobject pyxvself cythonunused pyobject unused proto$^static char pyxdoc0pywrapfst00mutablefst00numstates  n    numstatesselfnn    returns the number of states.n    $^static pyobject pyxpw0pywrapfst00mutablefst00numstatespyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextnumstates wrapper 0$^  pyxr  pyxpf0pywrapfst00mutablefst00numstatesstruct pyxobj0pywrapfstmutablefst pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00mutablefst00numstatesstruct pyxobj0pywrapfstmutablefst pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextnumstates 0$^  pyxxdecrefpyxr$^  pyxt0  pyxpyintfromint00tpyxf0pywrapfst00mutablefstnumstatespyxvself 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.mutablefst.numstates pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return self.mfst.get.numstates$^  $^    cdef void projectself bool projectoutputfalse except               $^      fst.projectself.mfst.get fst.getprojecttypeprojectoutput$^      self.checkmutatingimethod$^ $^$^static void pyxf0pywrapfst00mutablefstprojectstruct pyxobj0pywrapfstmutablefst pyxvself struct pyxoptargs0pywrapfst00mutablefstproject pyxoptionalargs $^  bool pyxvprojectoutput  bool0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextproject 0$^  if pyxoptionalargs $^    if pyxoptionalargspyxn  0 $^      pyxvprojectoutput  pyxoptionalargsprojectoutput$^    $^  $^$^   pywrapfst.pyx0000$^  $^    cdef void projectself bool projectoutputfalse except $^      fst.projectself.mfst.get fst.getprojecttypeprojectoutput              $^      self.checkmutatingimethod$^  $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s mfst$^    pyxerr0 0000 pyxl0error$^  $^  fstscriptprojectpyxvselfmfst.get fstscriptgetprojecttypepyxvprojectoutput$^$^   pywrapfst.pyx0000$^    cdef void projectself bool projectoutputfalse except $^      fst.projectself.mfst.get fst.getprojecttypeprojectoutput$^      self.checkmutatingimethod              $^  $^    def projectself bool projectoutputfalse$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s checkmutatingimethod$^    pyxerr0 0000 pyxl0error$^  $^  struct pyxvtabstruct0pywrapfstmutablefst pyxvselfpyxbase.pyxvtabcheckmutatingimethodpyxvself if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^      return self.mfst.get.numstates$^  $^    cdef void projectself bool projectoutputfalse except               $^      fst.projectself.mfst.get fst.getprojecttypeprojectoutput$^      self.checkmutatingimethod$^ $^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablefst.project pyxclineno pyxlineno pyxfilename$^  pyxl0$^  pyxrefnannyfinishcontext$^$^$^ pywrapfst.pyx0000$^      self.checkmutatingimethod$^  $^    def projectself bool projectoutputfalse              $^      $^      projectself projectoutputfalse$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00mutablefst00projectpyobject pyxvself pyobject pyxargs pyobject pyxkwds proto$^static char pyxdoc0pywrapfst00mutablefst00project  n    projectself projectoutputfalsenn    converts the fst to an acceptor using input or output labels.nn    this operation destructively projects an fst onto its domain or range byn    either copying each arcs input label to its output label the default orn    vice versa.nn    argsn      projectoutput should the output labels be projectednn    returnsn      self.nn    see also decode encode relabelpairs relabelsymbols.n    $^static pyobject pyxpw0pywrapfst00mutablefst00projectpyobject pyxvself pyobject pyxargs pyobject pyxkwds $^  bool pyxvprojectoutput$^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextproject wrapper 0$^  $^    static pyobject pyxpyargnames  pyxnsprojectoutput0$^    pyobject values0  0$^    if unlikelypyxkwds $^      pyssizet kwargs$^      const pyssizet posargs  pytuplegetsizepyxargs$^      switch posargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 break$^        default goto pyxl0argtupleerror$^      $^      kwargs  pydictsizepyxkwds$^      switch posargs $^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnsprojectoutput$^          if value  values0  value kwargs $^        $^      $^      if unlikelykwargs  0 $^        if unlikelypyxparseoptionalkeywordspyxkwds pyxpyargnames 0 values posargs project  0 pyxerr0 0000 pyxl0error$^      $^     else $^      switch pytuplegetsizepyxargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 break$^        default goto pyxl0argtupleerror$^      $^    $^    if values0 $^      pyxvprojectoutput  pyxpyobjectistruevalues0 if unlikelypyxvprojectoutput  bool0  pyerroccurred pyxerr0 0000 pyxl0error$^     else $^      pyxvprojectoutput  bool0$^    $^  $^  goto pyxl0argumentunpackingdone$^  pyxl0argtupleerror$^  pyxraiseargtupleinvalidproject 0 0 0 pytuplegetsizepyxargs pyxerr0 0000 pyxl0error$^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablefst.project pyxclineno pyxlineno pyxfilename$^  pyxrefnannyfinishcontext$^  return null$^  pyxl0argumentunpackingdone$^  pyxr  pyxpf0pywrapfst00mutablefst00projectstruct pyxobj0pywrapfstmutablefst pyxvself pyxvprojectoutput$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00mutablefst00projectstruct pyxobj0pywrapfstmutablefst pyxvself bool pyxvprojectoutput $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  struct pyxoptargs0pywrapfst00mutablefstproject pyxt0$^  pyxrefnannysetupcontextproject 0$^$^   pywrapfst.pyx0000$^      see also decode encode relabelpairs relabelsymbols.$^      $^      self.projectprojectoutput              $^      return self$^  $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s project$^    pyxerr0 0000 pyxl0error$^  $^  pyxt0.pyxn  0$^  pyxt0.projectoutput  pyxvprojectoutput$^  struct pyxvtabstruct0pywrapfstmutablefst pyxvselfpyxbase.pyxvtabprojectpyxvself pyxt0 if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^      $^      self.projectprojectoutput$^      return self              $^  $^    cdef void pruneself float deltafst.kdelta int00 nstatefst.knostateid$^ $^  pyxxdecrefpyxr$^  pyxincrefpyobject pyxvself$^  pyxr  pyobject pyxvself$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      self.checkmutatingimethod$^  $^    def projectself bool projectoutputfalse              $^      $^      projectself projectoutputfalse$^ $^$^   function exit code $^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablefst.project pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return self$^  $^    cdef void pruneself float deltafst.kdelta int00 nstatefst.knostateid              $^                     weightnone except $^       threshold is set to semiring zero no pruning if no weight is specified.$^ $^$^static void pyxf0pywrapfst00mutablefstprunestruct pyxobj0pywrapfstmutablefst pyxvself struct pyxoptargs0pywrapfst00mutablefstprune pyxoptionalargs $^  float pyxvdelta  pyxk00$^  pyxt00basictypesint00 pyxvnstate  pyxk00$^$^   pywrapfst.pyx0000$^  $^    cdef void pruneself float deltafst.kdelta int00 nstatefst.knostateid$^                     weightnone except               $^       threshold is set to semiring zero no pruning if no weight is specified.$^      cdef fst.weightclass wc  getweightclassorzeroself.weighttype$^ $^  pyobject pyxvweight  pyobject pynone$^  fstscriptweightclass pyxvwc$^  pyxrefnannydeclarations$^  fstscriptweightclass pyxt0$^  pyxrefnannysetupcontextprune 0$^  if pyxoptionalargs $^    if pyxoptionalargspyxn  0 $^      pyxvdelta  pyxoptionalargsdelta$^      if pyxoptionalargspyxn  0 $^        pyxvnstate  pyxoptionalargsnstate$^        if pyxoptionalargspyxn  0 $^          pyxvweight  pyxoptionalargsweight$^        $^      $^    $^  $^$^   pywrapfst.pyx0000$^                     weightnone except $^       threshold is set to semiring zero no pruning if no weight is specified.$^      cdef fst.weightclass wc  getweightclassorzeroself.weighttype              $^                                                         weight$^      fst.pruneself.mfst.get wc nstate delta$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s weighttype$^    pyxerr0 0000 pyxl0error$^  $^$^   pywrapfst.pyx0000$^       threshold is set to semiring zero no pruning if no weight is specified.$^      cdef fst.weightclass wc  getweightclassorzeroself.weighttype$^                                                         weight              $^      fst.pruneself.mfst.get wc nstate delta$^      self.checkmutatingimethod$^ $^  pyxt0  pyxf0pywrapfstgetweightclassorzerostruct pyxvtabstruct0pywrapfstmutablefst pyxvselfpyxbase.pyxvtabpyxbase.weighttypestruct pyxobj0pywrapfstfst pyxvself 0 pyxvweight if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^  pyxvwc  pyxt0$^$^   pywrapfst.pyx0000$^      cdef fst.weightclass wc  getweightclassorzeroself.weighttype$^                                                         weight$^      fst.pruneself.mfst.get wc nstate delta              $^      self.checkmutatingimethod$^  $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s mfst$^    pyxerr0 0000 pyxl0error$^  $^  fstscriptprunepyxvselfmfst.get pyxvwc pyxvnstate pyxvdelta$^$^   pywrapfst.pyx0000$^                                                         weight$^      fst.pruneself.mfst.get wc nstate delta$^      self.checkmutatingimethod              $^  $^    def pruneself$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s checkmutatingimethod$^    pyxerr0 0000 pyxl0error$^  $^  struct pyxvtabstruct0pywrapfstmutablefst pyxvselfpyxbase.pyxvtabcheckmutatingimethodpyxvself if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^      return self$^  $^    cdef void pruneself float deltafst.kdelta int00 nstatefst.knostateid              $^                     weightnone except $^       threshold is set to semiring zero no pruning if no weight is specified.$^ $^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablefst.prune pyxclineno pyxlineno pyxfilename$^  pyxl0$^  pyxrefnannyfinishcontext$^$^$^ pywrapfst.pyx0000$^      self.checkmutatingimethod$^  $^    def pruneself              $^              float deltafst.kdelta$^              int00 nstatefst.knostateid$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00mutablefst00prunepyobject pyxvself pyobject pyxargs pyobject pyxkwds proto$^static char pyxdoc0pywrapfst00mutablefst00prune  n    pruneself delta0.0000000000 nstatenostateid weightnonenn    removes paths with weights below a certain threshold.nn    this operation deletes states and arcs in the input fst that do not belongn    to a successful path whose weight is no more w.r.t the natural semiringn    order than the threshold t otimestimes the weight of the shortest path inn    the input fst. weights must be commutative and have the path property.nn    argsn      delta comparisonquantization delta.n      nstate state number threshold.n      weight a weight or weight string indicating the desired weight thresholdn          below which paths are pruned if omitted no paths are pruned.nn    returnsn      self.nn    see also the constructive variant.n    $^static pyobject pyxpw0pywrapfst00mutablefst00prunepyobject pyxvself pyobject pyxargs pyobject pyxkwds $^  float pyxvdelta$^  pyxt00basictypesint00 pyxvnstate$^  pyobject pyxvweight  0$^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextprune wrapper 0$^  $^    static pyobject pyxpyargnames  pyxnsdeltapyxnsnstatepyxnsweight0$^    pyobject values0  000$^$^     pywrapfst.pyx0000$^              float deltafst.kdelta$^              int00 nstatefst.knostateid$^              weightnone              $^      $^      pruneself delta0.0000000000 nstatenostateid weightnone$^ $^    values0  pyobject pynone$^    if unlikelypyxkwds $^      pyssizet kwargs$^      const pyssizet posargs  pytuplegetsizepyxargs$^      switch posargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 break$^        default goto pyxl0argtupleerror$^      $^      kwargs  pydictsizepyxkwds$^      switch posargs $^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnsdelta$^          if value  values0  value kwargs $^        $^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnsnstate$^          if value  values0  value kwargs $^        $^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnsweight$^          if value  values0  value kwargs $^        $^      $^      if unlikelykwargs  0 $^        if unlikelypyxparseoptionalkeywordspyxkwds pyxpyargnames 0 values posargs prune  0 pyxerr0 0000 pyxl0error$^      $^     else $^      switch pytuplegetsizepyxargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 break$^        default goto pyxl0argtupleerror$^      $^    $^    if values0 $^      pyxvdelta  pyxpyfloatasfloatvalues0 if unlikelypyxvdelta  float0  pyerroccurred pyxerr0 0000 pyxl0error$^     else $^      pyxvdelta  pyxk00$^    $^    if values0 $^      pyxvnstate  pyxpyintasint00tvalues0 if unlikelypyxvnstate  int00t0  pyerroccurred pyxerr0 0000 pyxl0error$^     else $^      pyxvnstate  pyxk00$^    $^    pyxvweight  values0$^  $^  goto pyxl0argumentunpackingdone$^  pyxl0argtupleerror$^  pyxraiseargtupleinvalidprune 0 0 0 pytuplegetsizepyxargs pyxerr0 0000 pyxl0error$^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablefst.prune pyxclineno pyxlineno pyxfilename$^  pyxrefnannyfinishcontext$^  return null$^  pyxl0argumentunpackingdone$^  pyxr  pyxpf0pywrapfst00mutablefst00prunestruct pyxobj0pywrapfstmutablefst pyxvself pyxvdelta pyxvnstate pyxvweight$^$^   pywrapfst.pyx0000$^      self.checkmutatingimethod$^  $^    def pruneself              $^              float deltafst.kdelta$^              int00 nstatefst.knostateid$^ $^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00mutablefst00prunestruct pyxobj0pywrapfstmutablefst pyxvself float pyxvdelta pyxt00basictypesint00 pyxvnstate pyobject pyxvweight $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  struct pyxoptargs0pywrapfst00mutablefstprune pyxt0$^  pyxrefnannysetupcontextprune 0$^$^   pywrapfst.pyx0000$^      see also the constructive variant.$^      $^      self.prunedelta nstate weight              $^      return self$^  $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s prune$^    pyxerr0 0000 pyxl0error$^  $^  pyxt0.pyxn  0$^  pyxt0.delta  pyxvdelta$^  pyxt0.nstate  pyxvnstate$^  pyxt0.weight  pyxvweight$^  struct pyxvtabstruct0pywrapfstmutablefst pyxvselfpyxbase.pyxvtabprunepyxvself pyxt0 if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^      $^      self.prunedelta nstate weight$^      return self              $^  $^    cdef void pushself$^ $^  pyxxdecrefpyxr$^  pyxincrefpyobject pyxvself$^  pyxr  pyobject pyxvself$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      self.checkmutatingimethod$^  $^    def pruneself              $^              float deltafst.kdelta$^              int00 nstatefst.knostateid$^ $^$^   function exit code $^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablefst.prune pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return self$^  $^    cdef void pushself              $^                    float deltafst.kdelta$^                    bool removetotalweightfalse$^ $^$^static void pyxf0pywrapfst00mutablefstpushstruct pyxobj0pywrapfstmutablefst pyxvself struct pyxoptargs0pywrapfst00mutablefstpush pyxoptionalargs $^  float pyxvdelta  pyxk00$^$^   pywrapfst.pyx0000$^    cdef void pushself$^                    float deltafst.kdelta$^                    bool removetotalweightfalse              $^                    bool tofinalfalse except $^      fst.pushself.mfst.get fst.getreweighttypetofinal delta$^ $^  bool pyxvremovetotalweight  bool0$^$^   pywrapfst.pyx0000$^                    float deltafst.kdelta$^                    bool removetotalweightfalse$^                    bool tofinalfalse except               $^      fst.pushself.mfst.get fst.getreweighttypetofinal delta$^               removetotalweight$^ $^  bool pyxvtofinal  bool0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextpush 0$^  if pyxoptionalargs $^    if pyxoptionalargspyxn  0 $^      pyxvdelta  pyxoptionalargsdelta$^      if pyxoptionalargspyxn  0 $^        pyxvremovetotalweight  pyxoptionalargsremovetotalweight$^        if pyxoptionalargspyxn  0 $^          pyxvtofinal  pyxoptionalargstofinal$^        $^      $^    $^  $^$^   pywrapfst.pyx0000$^                    bool removetotalweightfalse$^                    bool tofinalfalse except $^      fst.pushself.mfst.get fst.getreweighttypetofinal delta              $^               removetotalweight$^      self.checkmutatingimethod$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s mfst$^    pyxerr0 0000 pyxl0error$^  $^$^   pywrapfst.pyx0000$^                    bool tofinalfalse except $^      fst.pushself.mfst.get fst.getreweighttypetofinal delta$^               removetotalweight              $^      self.checkmutatingimethod$^  $^ $^  fstscriptpushpyxvselfmfst.get fstscriptgetreweighttypepyxvtofinal pyxvdelta pyxvremovetotalweight$^$^   pywrapfst.pyx0000$^      fst.pushself.mfst.get fst.getreweighttypetofinal delta$^               removetotalweight$^      self.checkmutatingimethod              $^  $^    def pushself$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s checkmutatingimethod$^    pyxerr0 0000 pyxl0error$^  $^  struct pyxvtabstruct0pywrapfstmutablefst pyxvselfpyxbase.pyxvtabcheckmutatingimethodpyxvself if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^      return self$^  $^    cdef void pushself              $^                    float deltafst.kdelta$^                    bool removetotalweightfalse$^ $^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablefst.push pyxclineno pyxlineno pyxfilename$^  pyxl0$^  pyxrefnannyfinishcontext$^$^$^ pywrapfst.pyx0000$^      self.checkmutatingimethod$^  $^    def pushself              $^             float deltafst.kdelta$^             bool removetotalweightfalse$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00mutablefst00pushpyobject pyxvself pyobject pyxargs pyobject pyxkwds proto$^static char pyxdoc0pywrapfst00mutablefst00push  n    pushself delta0.0000000000 removetotalweightfalse tofinalfalsenn    pushes weights towards the initial or final states.nn    this operation destructively produces an equivalent transducer by pushingn    the weights towards the initial state or toward the final states. whenn    pushing weights towards the initial state the sum of the weight of then    outgoing transitions and final weight at any noninitial state is equal ton    one in the resulting machine. when pushing weights towards the final statesn    the sum of the weight of the incoming transitions at any state is equal ton    one. weights need to be left distributive when pushing towards the initialn    state and right distributive when pushing towards the final states.nn    argsn      delta comparisonquantization delta.n      removetotalweight if pushing weights should the total weight ben          removedn      tofinal push towards final statesnn    returnsn      self.nn    see also the constructive variant which also supports label pushing.n    $^static pyobject pyxpw0pywrapfst00mutablefst00pushpyobject pyxvself pyobject pyxargs pyobject pyxkwds $^  float pyxvdelta$^  bool pyxvremovetotalweight$^  bool pyxvtofinal$^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextpush wrapper 0$^  $^    static pyobject pyxpyargnames  pyxnsdeltapyxnsremovetotalweightpyxnstofinal0$^    pyobject values0  000$^    if unlikelypyxkwds $^      pyssizet kwargs$^      const pyssizet posargs  pytuplegetsizepyxargs$^      switch posargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 break$^        default goto pyxl0argtupleerror$^      $^      kwargs  pydictsizepyxkwds$^      switch posargs $^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnsdelta$^          if value  values0  value kwargs $^        $^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnsremovetotalweight$^          if value  values0  value kwargs $^        $^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnstofinal$^          if value  values0  value kwargs $^        $^      $^      if unlikelykwargs  0 $^        if unlikelypyxparseoptionalkeywordspyxkwds pyxpyargnames 0 values posargs push  0 pyxerr0 0000 pyxl0error$^      $^     else $^      switch pytuplegetsizepyxargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 break$^        default goto pyxl0argtupleerror$^      $^    $^    if values0 $^      pyxvdelta  pyxpyfloatasfloatvalues0 if unlikelypyxvdelta  float0  pyerroccurred pyxerr0 0000 pyxl0error$^     else $^      pyxvdelta  pyxk00$^    $^    if values0 $^      pyxvremovetotalweight  pyxpyobjectistruevalues0 if unlikelypyxvremovetotalweight  bool0  pyerroccurred pyxerr0 0000 pyxl0error$^     else $^$^       pywrapfst.pyx0000$^    def pushself$^             float deltafst.kdelta$^             bool removetotalweightfalse              $^             bool tofinalfalse$^      $^ $^      pyxvremovetotalweight  bool0$^    $^    if values0 $^      pyxvtofinal  pyxpyobjectistruevalues0 if unlikelypyxvtofinal  bool0  pyerroccurred pyxerr0 0000 pyxl0error$^     else $^$^       pywrapfst.pyx0000$^             float deltafst.kdelta$^             bool removetotalweightfalse$^             bool tofinalfalse              $^      $^      pushself delta0.0000000000 removetotalweightfalse tofinalfalse$^ $^      pyxvtofinal  bool0$^    $^  $^  goto pyxl0argumentunpackingdone$^  pyxl0argtupleerror$^  pyxraiseargtupleinvalidpush 0 0 0 pytuplegetsizepyxargs pyxerr0 0000 pyxl0error$^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablefst.push pyxclineno pyxlineno pyxfilename$^  pyxrefnannyfinishcontext$^  return null$^  pyxl0argumentunpackingdone$^  pyxr  pyxpf0pywrapfst00mutablefst00pushstruct pyxobj0pywrapfstmutablefst pyxvself pyxvdelta pyxvremovetotalweight pyxvtofinal$^$^   pywrapfst.pyx0000$^      self.checkmutatingimethod$^  $^    def pushself              $^             float deltafst.kdelta$^             bool removetotalweightfalse$^ $^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00mutablefst00pushstruct pyxobj0pywrapfstmutablefst pyxvself float pyxvdelta bool pyxvremovetotalweight bool pyxvtofinal $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  struct pyxoptargs0pywrapfst00mutablefstpush pyxt0$^  pyxrefnannysetupcontextpush 0$^$^   pywrapfst.pyx0000$^      see also the constructive variant which also supports label pushing.$^      $^      self.pushdelta removetotalweight tofinal              $^      return self$^  $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s push$^    pyxerr0 0000 pyxl0error$^  $^  pyxt0.pyxn  0$^  pyxt0.delta  pyxvdelta$^  pyxt0.removetotalweight  pyxvremovetotalweight$^  pyxt0.tofinal  pyxvtofinal$^  struct pyxvtabstruct0pywrapfstmutablefst pyxvselfpyxbase.pyxvtabpushpyxvself pyxt0 if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^      $^      self.pushdelta removetotalweight tofinal$^      return self              $^  $^    cdef void relabelpairsself ipairsnone opairsnone except $^ $^  pyxxdecrefpyxr$^  pyxincrefpyobject pyxvself$^  pyxr  pyobject pyxvself$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      self.checkmutatingimethod$^  $^    def pushself              $^             float deltafst.kdelta$^             bool removetotalweightfalse$^ $^$^   function exit code $^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablefst.push pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return self$^  $^    cdef void relabelpairsself ipairsnone opairsnone except               $^      cdef uniqueptrvectorfst.labelpair ipairs$^      ipairs.resetnew vectorfst.labelpair$^ $^$^static void pyxf0pywrapfst00mutablefstrelabelpairsstruct pyxobj0pywrapfstmutablefst pyxvself struct pyxoptargs0pywrapfst00mutablefstrelabelpairs pyxoptionalargs $^  pyobject pyxvipairs  pyobject pynone$^  pyobject pyxvopairs  pyobject pynone$^  stduniqueptrstdvectorpyxt0fstlabelpair   pyxvipairs$^  stduniqueptrstdvectorpyxt0fstlabelpair   pyxvopairs$^  pyxt00basictypesint00 pyxvbefore$^  pyxt00basictypesint00 pyxvafter$^  pyxrefnannydeclarations$^  stdvectorpyxt0fstlabelpair  pyxt0$^  int pyxt0$^  pyobject pyxt0  null$^  pyssizet pyxt0$^  pyobject pyxt0pyobject $^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt00pyobject $^  pyxt00basictypesint00 pyxt00$^  pyxt00basictypesint00 pyxt00$^  pyxt0fstlabelpair pyxt00$^  int pyxt00$^  pyxrefnannysetupcontextrelabelpairs 0$^  if pyxoptionalargs $^    if pyxoptionalargspyxn  0 $^      pyxvipairs  pyxoptionalargsipairs$^      if pyxoptionalargspyxn  0 $^        pyxvopairs  pyxoptionalargsopairs$^      $^    $^  $^$^   pywrapfst.pyx0000$^    cdef void relabelpairsself ipairsnone opairsnone except $^      cdef uniqueptrvectorfst.labelpair ipairs$^      ipairs.resetnew vectorfst.labelpair              $^      cdef uniqueptrvectorfst.labelpair opairs$^      opairs.resetnew vectorfst.labelpair$^ $^  try $^    pyxt0  new stdvectorpyxt0fstlabelpair $^   catch... $^    pyxcppexn0pyerr$^    pyxerr0 0000 pyxl0error$^  $^  pyxvipairs.resetpyxt0$^$^   pywrapfst.pyx0000$^      ipairs.resetnew vectorfst.labelpair$^      cdef uniqueptrvectorfst.labelpair opairs$^      opairs.resetnew vectorfst.labelpair              $^      cdef int00 before$^      cdef int00 after$^ $^  try $^    pyxt0  new stdvectorpyxt0fstlabelpair $^   catch... $^    pyxcppexn0pyerr$^    pyxerr0 0000 pyxl0error$^  $^  pyxvopairs.resetpyxt0$^$^   pywrapfst.pyx0000$^      cdef int00 before$^      cdef int00 after$^      if ipairs              $^        for before after in ipairs$^          ipairs.get.pushbackfst.labelpairbefore after$^ $^  pyxt0  pyxpyobjectistruepyxvipairs if unlikelypyxt0  0 pyxerr0 0000 pyxl0error$^  if pyxt0 $^$^     pywrapfst.pyx0000$^      cdef int00 after$^      if ipairs$^        for before after in ipairs              $^          ipairs.get.pushbackfst.labelpairbefore after$^      if opairs$^ $^    if likelypylistcheckexactpyxvipairs  pytuplecheckexactpyxvipairs $^      pyxt0  pyxvipairs pyxincrefpyxt0 pyxt0  0$^      pyxt0  null$^     else $^      pyxt0  0 pyxt0  pyobjectgetiterpyxvipairs if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxgotrefpyxt0$^      pyxt0  pytypepyxt0tpiternext if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    $^    for  $^      if likelypyxt0 $^        if likelypylistcheckexactpyxt0 $^          if pyxt0  pylistgetsizepyxt0 break$^          if cythonassumesafemacros  cythonavoidborrowedrefs$^          pyxt0  pylistgetitempyxt0 pyxt0 pyxincrefpyxt0 pyxt0 if unlikely0  0 pyxerr0 0000 pyxl0error$^          else$^          pyxt0  pysequenceitempyxt0 pyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^          pyxgotrefpyxt0$^          endif$^         else $^          if pyxt0  pytuplegetsizepyxt0 break$^          if cythonassumesafemacros  cythonavoidborrowedrefs$^          pyxt0  pytuplegetitempyxt0 pyxt0 pyxincrefpyxt0 pyxt0 if unlikely0  0 pyxerr0 0000 pyxl0error$^          else$^          pyxt0  pysequenceitempyxt0 pyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^          pyxgotrefpyxt0$^          endif$^        $^       else $^        pyxt0  pyxt0pyxt0$^        if unlikelypyxt0 $^          pyobject exctype  pyerroccurred$^          if exctype $^            if likelypyxpyerrgivenexceptionmatchesexctype pyexcstopiteration pyerrclear$^            else pyxerr0 0000 pyxl0error$^          $^          break$^        $^        pyxgotrefpyxt0$^      $^      if likelypytuplecheckexactpyxt0  pylistcheckexactpyxt0 $^        pyobject sequence  pyxt0$^        pyssizet size  pyxpysequencesizesequence$^        if unlikelysize  0 $^          if size  0 pyxraisetoomanyvalueserror0$^          else if size  0 pyxraiseneedmorevalueserrorsize$^          pyxerr0 0000 pyxl0error$^        $^        if cythonassumesafemacros  cythonavoidborrowedrefs$^        if likelypytuplecheckexactsequence $^          pyxt0  pytuplegetitemsequence 0 $^          pyxt0  pytuplegetitemsequence 0 $^         else $^          pyxt0  pylistgetitemsequence 0 $^          pyxt0  pylistgetitemsequence 0 $^        $^        pyxincrefpyxt0$^        pyxincrefpyxt0$^        else$^        pyxt0  pysequenceitemsequence 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxgotrefpyxt0$^        pyxt0  pysequenceitemsequence 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxgotrefpyxt0$^        endif$^        pyxdecrefpyxt0 pyxt0  0$^       else $^        pyssizet index  0$^        pyxt0  pyobjectgetiterpyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^        pyxt00  pytypepyxt0tpiternext$^        index  0 pyxt0  pyxt00pyxt0 if unlikelypyxt0 goto pyxl0unpackingfailed$^        pyxgotrefpyxt0$^        index  0 pyxt0  pyxt00pyxt0 if unlikelypyxt0 goto pyxl0unpackingfailed$^        pyxgotrefpyxt0$^        if pyxiternextunpackendcheckpyxt00pyxt0 0  0 pyxerr0 0000 pyxl0error$^        pyxt00  null$^        pyxdecrefpyxt0 pyxt0  0$^        goto pyxl0unpackingdone$^        pyxl0unpackingfailed$^        pyxdecrefpyxt0 pyxt0  0$^        pyxt00  null$^        if pyxiterfinish  0 pyxraiseneedmorevalueserrorindex$^        pyxerr0 0000 pyxl0error$^        pyxl0unpackingdone$^      $^      pyxt00  pyxpyintasint00tpyxt0 if unlikelypyxt00  int00t0  pyerroccurred pyxerr0 0000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxt00  pyxpyintasint00tpyxt0 if unlikelypyxt00  int00t0  pyerroccurred pyxerr0 0000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxvbefore  pyxt00$^      pyxvafter  pyxt00$^$^       pywrapfst.pyx0000$^      if ipairs$^        for before after in ipairs$^          ipairs.get.pushbackfst.labelpairbefore after              $^      if opairs$^        for before after in opairs$^ $^      try $^        pyxt00  pyxt0fstlabelpairpyxvbefore pyxvafter$^       catch... $^        pyxcppexn0pyerr$^        pyxerr0 0000 pyxl0error$^      $^      try $^        pyxvipairs.getpushbackpyxt00$^       catch... $^        pyxcppexn0pyerr$^        pyxerr0 0000 pyxl0error$^      $^$^       pywrapfst.pyx0000$^      cdef int00 after$^      if ipairs$^        for before after in ipairs              $^          ipairs.get.pushbackfst.labelpairbefore after$^      if opairs$^ $^    $^    pyxdecrefpyxt0 pyxt0  0$^$^     pywrapfst.pyx0000$^      cdef int00 before$^      cdef int00 after$^      if ipairs              $^        for before after in ipairs$^          ipairs.get.pushbackfst.labelpairbefore after$^ $^  $^$^   pywrapfst.pyx0000$^        for before after in ipairs$^          ipairs.get.pushbackfst.labelpairbefore after$^      if opairs              $^        for before after in opairs$^          opairs.get.pushbackfst.labelpairbefore after$^ $^  pyxt0  pyxpyobjectistruepyxvopairs if unlikelypyxt0  0 pyxerr0 0000 pyxl0error$^  if pyxt0 $^$^     pywrapfst.pyx0000$^          ipairs.get.pushbackfst.labelpairbefore after$^      if opairs$^        for before after in opairs              $^          opairs.get.pushbackfst.labelpairbefore after$^      if ipairs.get.empty and opairs.get.empty$^ $^    if likelypylistcheckexactpyxvopairs  pytuplecheckexactpyxvopairs $^      pyxt0  pyxvopairs pyxincrefpyxt0 pyxt0  0$^      pyxt0  null$^     else $^      pyxt0  0 pyxt0  pyobjectgetiterpyxvopairs if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxgotrefpyxt0$^      pyxt0  pytypepyxt0tpiternext if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    $^    for  $^      if likelypyxt0 $^        if likelypylistcheckexactpyxt0 $^          if pyxt0  pylistgetsizepyxt0 break$^          if cythonassumesafemacros  cythonavoidborrowedrefs$^          pyxt0  pylistgetitempyxt0 pyxt0 pyxincrefpyxt0 pyxt0 if unlikely0  0 pyxerr0 0000 pyxl0error$^          else$^          pyxt0  pysequenceitempyxt0 pyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^          pyxgotrefpyxt0$^          endif$^         else $^          if pyxt0  pytuplegetsizepyxt0 break$^          if cythonassumesafemacros  cythonavoidborrowedrefs$^          pyxt0  pytuplegetitempyxt0 pyxt0 pyxincrefpyxt0 pyxt0 if unlikely0  0 pyxerr0 0000 pyxl0error$^          else$^          pyxt0  pysequenceitempyxt0 pyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^          pyxgotrefpyxt0$^          endif$^        $^       else $^        pyxt0  pyxt0pyxt0$^        if unlikelypyxt0 $^          pyobject exctype  pyerroccurred$^          if exctype $^            if likelypyxpyerrgivenexceptionmatchesexctype pyexcstopiteration pyerrclear$^            else pyxerr0 0000 pyxl0error$^          $^          break$^        $^        pyxgotrefpyxt0$^      $^      if likelypytuplecheckexactpyxt0  pylistcheckexactpyxt0 $^        pyobject sequence  pyxt0$^        pyssizet size  pyxpysequencesizesequence$^        if unlikelysize  0 $^          if size  0 pyxraisetoomanyvalueserror0$^          else if size  0 pyxraiseneedmorevalueserrorsize$^          pyxerr0 0000 pyxl0error$^        $^        if cythonassumesafemacros  cythonavoidborrowedrefs$^        if likelypytuplecheckexactsequence $^          pyxt0  pytuplegetitemsequence 0 $^          pyxt0  pytuplegetitemsequence 0 $^         else $^          pyxt0  pylistgetitemsequence 0 $^          pyxt0  pylistgetitemsequence 0 $^        $^        pyxincrefpyxt0$^        pyxincrefpyxt0$^        else$^        pyxt0  pysequenceitemsequence 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxgotrefpyxt0$^        pyxt0  pysequenceitemsequence 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxgotrefpyxt0$^        endif$^        pyxdecrefpyxt0 pyxt0  0$^       else $^        pyssizet index  0$^        pyxt0  pyobjectgetiterpyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^        pyxt00  pytypepyxt0tpiternext$^        index  0 pyxt0  pyxt00pyxt0 if unlikelypyxt0 goto pyxl00unpackingfailed$^        pyxgotrefpyxt0$^        index  0 pyxt0  pyxt00pyxt0 if unlikelypyxt0 goto pyxl00unpackingfailed$^        pyxgotrefpyxt0$^        if pyxiternextunpackendcheckpyxt00pyxt0 0  0 pyxerr0 0000 pyxl0error$^        pyxt00  null$^        pyxdecrefpyxt0 pyxt0  0$^        goto pyxl00unpackingdone$^        pyxl00unpackingfailed$^        pyxdecrefpyxt0 pyxt0  0$^        pyxt00  null$^        if pyxiterfinish  0 pyxraiseneedmorevalueserrorindex$^        pyxerr0 0000 pyxl0error$^        pyxl00unpackingdone$^      $^      pyxt00  pyxpyintasint00tpyxt0 if unlikelypyxt00  int00t0  pyerroccurred pyxerr0 0000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxt00  pyxpyintasint00tpyxt0 if unlikelypyxt00  int00t0  pyerroccurred pyxerr0 0000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxvbefore  pyxt00$^      pyxvafter  pyxt00$^$^       pywrapfst.pyx0000$^      if opairs$^        for before after in opairs$^          opairs.get.pushbackfst.labelpairbefore after              $^      if ipairs.get.empty and opairs.get.empty$^        raise fstargerrorno relabeling pairs specified.$^ $^      try $^        pyxt00  pyxt0fstlabelpairpyxvbefore pyxvafter$^       catch... $^        pyxcppexn0pyerr$^        pyxerr0 0000 pyxl0error$^      $^      try $^        pyxvopairs.getpushbackpyxt00$^       catch... $^        pyxcppexn0pyerr$^        pyxerr0 0000 pyxl0error$^      $^$^       pywrapfst.pyx0000$^          ipairs.get.pushbackfst.labelpairbefore after$^      if opairs$^        for before after in opairs              $^          opairs.get.pushbackfst.labelpairbefore after$^      if ipairs.get.empty and opairs.get.empty$^ $^    $^    pyxdecrefpyxt0 pyxt0  0$^$^     pywrapfst.pyx0000$^        for before after in ipairs$^          ipairs.get.pushbackfst.labelpairbefore after$^      if opairs              $^        for before after in opairs$^          opairs.get.pushbackfst.labelpairbefore after$^ $^  $^$^   pywrapfst.pyx0000$^        for before after in opairs$^          opairs.get.pushbackfst.labelpairbefore after$^      if ipairs.get.empty and opairs.get.empty              $^        raise fstargerrorno relabeling pairs specified.$^      fst.relabelself.mfst.get derefipairs derefopairs$^ $^  pyxt00  pyxvipairs.getempty  0$^  if pyxt00 $^   else $^    pyxt0  pyxt00$^    goto pyxl00boolbinopdone$^  $^  pyxt00  pyxvopairs.getempty  0$^  pyxt0  pyxt00$^  pyxl00boolbinopdone$^  if unlikelypyxt0 $^$^     pywrapfst.pyx0000$^          opairs.get.pushbackfst.labelpairbefore after$^      if ipairs.get.empty and opairs.get.empty$^        raise fstargerrorno relabeling pairs specified.              $^      fst.relabelself.mfst.get derefipairs derefopairs$^      self.checkmutatingimethod$^ $^    pyxt0  pyxgetmoduleglobalnamepyxnsfstargerror if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  pyxpyobjectcallpyxt0 pyxtuple00 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxraisepyxt0 0 0 0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxerr0 0000 pyxl0error$^$^     pywrapfst.pyx0000$^        for before after in opairs$^          opairs.get.pushbackfst.labelpairbefore after$^      if ipairs.get.empty and opairs.get.empty              $^        raise fstargerrorno relabeling pairs specified.$^      fst.relabelself.mfst.get derefipairs derefopairs$^ $^  $^$^   pywrapfst.pyx0000$^      if ipairs.get.empty and opairs.get.empty$^        raise fstargerrorno relabeling pairs specified.$^      fst.relabelself.mfst.get derefipairs derefopairs              $^      self.checkmutatingimethod$^  $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s mfst$^    pyxerr0 0000 pyxl0error$^  $^  fstscriptrelabelpyxvselfmfst.get pyxvipairs pyxvopairs$^$^   pywrapfst.pyx0000$^        raise fstargerrorno relabeling pairs specified.$^      fst.relabelself.mfst.get derefipairs derefopairs$^      self.checkmutatingimethod              $^  $^    def relabelpairsself ipairsnone opairsnone$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s checkmutatingimethod$^    pyxerr0 0000 pyxl0error$^  $^  struct pyxvtabstruct0pywrapfstmutablefst pyxvselfpyxbase.pyxvtabcheckmutatingimethodpyxvself if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^      return self$^  $^    cdef void relabelpairsself ipairsnone opairsnone except               $^      cdef uniqueptrvectorfst.labelpair ipairs$^      ipairs.resetnew vectorfst.labelpair$^ $^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.mutablefst.relabelpairs pyxclineno pyxlineno pyxfilename$^  pyxl0$^  pyxrefnannyfinishcontext$^$^$^ pywrapfst.pyx0000$^      self.checkmutatingimethod$^  $^    def relabelpairsself ipairsnone opairsnone              $^      $^      relabelpairsself ipairsnone opairsnone$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00mutablefst00relabelpairspyobject pyxvself pyobject pyxargs pyobject pyxkwds proto$^static char pyxdoc0pywrapfst00mutablefst00relabelpairs  n    relabelpairsself ipairsnone opairsnonenn    replaces input andor output labels using pairs of labels.nn    this operation destructively relabels the input andor output labels of then    fst using pairs of the form oldid newid omitted indices aren    identitymapped.nn    argsn      ipairs an iterable containing older index newer index integer pairs.n      opairs an iterable containing older index newer index integer pairs.nn    returnsn      self.nn    raisesn      fstargerror no relabeling pairs specified.nn    see also decode encode project relabeltables.n    $^static pyobject pyxpw0pywrapfst00mutablefst00relabelpairspyobject pyxvself pyobject pyxargs pyobject pyxkwds $^  pyobject pyxvipairs  0$^  pyobject pyxvopairs  0$^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextrelabelpairs wrapper 0$^  $^    static pyobject pyxpyargnames  pyxnsipairspyxnsopairs0$^    pyobject values0  00$^    values0  pyobject pynone$^    values0  pyobject pynone$^    if unlikelypyxkwds $^      pyssizet kwargs$^      const pyssizet posargs  pytuplegetsizepyxargs$^      switch posargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 break$^        default goto pyxl0argtupleerror$^      $^      kwargs  pydictsizepyxkwds$^      switch posargs $^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnsipairs$^          if value  values0  value kwargs $^        $^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnsopairs$^          if value  values0  value kwargs $^        $^      $^      if unlikelykwargs  0 $^        if unlikelypyxparseoptionalkeywordspyxkwds pyxpyargnames 0 values posargs relabelpairs  0 pyxerr0 0000 pyxl0error$^      $^     else $^      switch pytuplegetsizepyxargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 break$^        default goto pyxl0argtupleerror$^      $^    $^    pyxvipairs  values0$^    pyxvopairs  values0$^  $^  goto pyxl0argumentunpackingdone$^  pyxl0argtupleerror$^  pyxraiseargtupleinvalidrelabelpairs 0 0 0 pytuplegetsizepyxargs pyxerr0 0000 pyxl0error$^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablefst.relabelpairs pyxclineno pyxlineno pyxfilename$^  pyxrefnannyfinishcontext$^  return null$^  pyxl0argumentunpackingdone$^  pyxr  pyxpf0pywrapfst00mutablefst00relabelpairsstruct pyxobj0pywrapfstmutablefst pyxvself pyxvipairs pyxvopairs$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00mutablefst00relabelpairsstruct pyxobj0pywrapfstmutablefst pyxvself pyobject pyxvipairs pyobject pyxvopairs $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  struct pyxoptargs0pywrapfst00mutablefstrelabelpairs pyxt0$^  pyxrefnannysetupcontextrelabelpairs 0$^$^   pywrapfst.pyx0000$^      see also decode encode project relabeltables.$^      $^      self.relabelpairsipairs opairs              $^      return self$^  $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s relabelpairs$^    pyxerr0 0000 pyxl0error$^  $^  pyxt0.pyxn  0$^  pyxt0.ipairs  pyxvipairs$^  pyxt0.opairs  pyxvopairs$^  struct pyxvtabstruct0pywrapfstmutablefst pyxvselfpyxbase.pyxvtabrelabelpairspyxvself pyxt0 if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^      $^      self.relabelpairsipairs opairs$^      return self              $^  $^    cdef void relabeltablesself$^ $^  pyxxdecrefpyxr$^  pyxincrefpyobject pyxvself$^  pyxr  pyobject pyxvself$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      self.checkmutatingimethod$^  $^    def relabelpairsself ipairsnone opairsnone              $^      $^      relabelpairsself ipairsnone opairsnone$^ $^$^   function exit code $^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablefst.relabelpairs pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return self$^  $^    cdef void relabeltablesself              $^                              symboltable oldisymbolsnone$^                              symboltable newisymbolsnone$^ $^$^static void pyxf0pywrapfst00mutablefstrelabeltablesstruct pyxobj0pywrapfstmutablefst pyxvself struct pyxoptargs0pywrapfst00mutablefstrelabeltables pyxoptionalargs $^$^   pywrapfst.pyx0000$^  $^    cdef void relabeltablesself$^                              symboltable oldisymbolsnone              $^                              symboltable newisymbolsnone$^                              unknownisymbolb$^ $^  struct pyxobj0pywrapfstsymboltable pyxvoldisymbols  struct pyxobj0pywrapfstsymboltable pynone$^$^   pywrapfst.pyx0000$^    cdef void relabeltablesself$^                              symboltable oldisymbolsnone$^                              symboltable newisymbolsnone              $^                              unknownisymbolb$^                              bool attachnewisymbolstrue$^ $^  struct pyxobj0pywrapfstsymboltable pyxvnewisymbols  struct pyxobj0pywrapfstsymboltable pynone$^  pyobject pyxvunknownisymbol  pyobject pyxkpb00$^$^   pywrapfst.pyx0000$^                              symboltable newisymbolsnone$^                              unknownisymbolb$^                              bool attachnewisymbolstrue              $^                              symboltable oldosymbolsnone$^                              symboltable newosymbolsnone$^ $^  bool pyxvattachnewisymbols  bool0$^$^   pywrapfst.pyx0000$^                              unknownisymbolb$^                              bool attachnewisymbolstrue$^                              symboltable oldosymbolsnone              $^                              symboltable newosymbolsnone$^                              unknownosymbolb$^ $^  struct pyxobj0pywrapfstsymboltable pyxvoldosymbols  struct pyxobj0pywrapfstsymboltable pynone$^$^   pywrapfst.pyx0000$^                              bool attachnewisymbolstrue$^                              symboltable oldosymbolsnone$^                              symboltable newosymbolsnone              $^                              unknownosymbolb$^                              bool attachnewosymbolstrue except $^ $^  struct pyxobj0pywrapfstsymboltable pyxvnewosymbols  struct pyxobj0pywrapfstsymboltable pynone$^  pyobject pyxvunknownosymbol  pyobject pyxkpb00$^$^   pywrapfst.pyx0000$^                              symboltable newosymbolsnone$^                              unknownosymbolb$^                              bool attachnewosymbolstrue except               $^      if newisymbols is none and newosymbols is none$^        raise fstargerrorno new symboltables specified$^ $^  bool pyxvattachnewosymbols  bool0$^  fstsymboltable pyxvnewisymbolsptr$^  fstsymboltable pyxvnewosymbolsptr$^  pyxrefnannydeclarations$^  int pyxt0$^  int pyxt0$^  int pyxt0$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  fstsymboltable pyxt0$^  fstsymboltable const pyxt0$^  stdstring pyxt0$^  fstsymboltable const pyxt0$^  stdstring pyxt00$^  pyxrefnannysetupcontextrelabeltables 0$^  if pyxoptionalargs $^    if pyxoptionalargspyxn  0 $^      pyxvoldisymbols  pyxoptionalargsoldisymbols$^      if pyxoptionalargspyxn  0 $^        pyxvnewisymbols  pyxoptionalargsnewisymbols$^        if pyxoptionalargspyxn  0 $^          pyxvunknownisymbol  pyxoptionalargsunknownisymbol$^          if pyxoptionalargspyxn  0 $^            pyxvattachnewisymbols  pyxoptionalargsattachnewisymbols$^            if pyxoptionalargspyxn  0 $^              pyxvoldosymbols  pyxoptionalargsoldosymbols$^              if pyxoptionalargspyxn  0 $^                pyxvnewosymbols  pyxoptionalargsnewosymbols$^                if pyxoptionalargspyxn  0 $^                  pyxvunknownosymbol  pyxoptionalargsunknownosymbol$^                  if pyxoptionalargspyxn  0 $^                    pyxvattachnewosymbols  pyxoptionalargsattachnewosymbols$^                  $^                $^              $^            $^          $^        $^      $^    $^  $^$^   pywrapfst.pyx0000$^                              unknownosymbolb$^                              bool attachnewosymbolstrue except $^      if newisymbols is none and newosymbols is none              $^        raise fstargerrorno new symboltables specified$^      cdef fst.symboltable newisymbolsptr  null$^ $^  pyxt0  pyobject pyxvnewisymbols  pynone$^  pyxt0  pyxt0  0$^  if pyxt0 $^   else $^    pyxt0  pyxt0$^    goto pyxl0boolbinopdone$^  $^  pyxt0  pyobject pyxvnewosymbols  pynone$^  pyxt0  pyxt0  0$^  pyxt0  pyxt0$^  pyxl0boolbinopdone$^  if unlikelypyxt0 $^$^     pywrapfst.pyx0000$^                              bool attachnewosymbolstrue except $^      if newisymbols is none and newosymbols is none$^        raise fstargerrorno new symboltables specified              $^      cdef fst.symboltable newisymbolsptr  null$^      if newisymbols is not none$^ $^    pyxt0  pyxgetmoduleglobalnamepyxnsfstargerror if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  pyxpyobjectcallpyxt0 pyxtuple00 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxraisepyxt0 0 0 0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxerr0 0000 pyxl0error$^$^     pywrapfst.pyx0000$^                              unknownosymbolb$^                              bool attachnewosymbolstrue except $^      if newisymbols is none and newosymbols is none              $^        raise fstargerrorno new symboltables specified$^      cdef fst.symboltable newisymbolsptr  null$^ $^  $^$^   pywrapfst.pyx0000$^      if newisymbols is none and newosymbols is none$^        raise fstargerrorno new symboltables specified$^      cdef fst.symboltable newisymbolsptr  null              $^      if newisymbols is not none$^        newisymbolsptr  newisymbols.table$^ $^  pyxvnewisymbolsptr  null$^$^   pywrapfst.pyx0000$^        raise fstargerrorno new symboltables specified$^      cdef fst.symboltable newisymbolsptr  null$^      if newisymbols is not none              $^        newisymbolsptr  newisymbols.table$^      cdef fst.symboltable newosymbolsptr  null$^ $^  pyxt0  pyobject pyxvnewisymbols  pynone$^  pyxt0  pyxt0  0$^  if pyxt0 $^$^     pywrapfst.pyx0000$^      cdef fst.symboltable newisymbolsptr  null$^      if newisymbols is not none$^        newisymbolsptr  newisymbols.table              $^      cdef fst.symboltable newosymbolsptr  null$^      if newosymbols is not none$^ $^    if unlikelypyobject pyxvnewisymbols  pynone $^      pyerrformatpyexcattributeerror nonetype object has no attribute .00s table$^      pyxerr0 0000 pyxl0error$^    $^    pyxt0  pyxvnewisymbolstable$^    pyxvnewisymbolsptr  pyxt0$^$^     pywrapfst.pyx0000$^        raise fstargerrorno new symboltables specified$^      cdef fst.symboltable newisymbolsptr  null$^      if newisymbols is not none              $^        newisymbolsptr  newisymbols.table$^      cdef fst.symboltable newosymbolsptr  null$^ $^  $^$^   pywrapfst.pyx0000$^      if newisymbols is not none$^        newisymbolsptr  newisymbols.table$^      cdef fst.symboltable newosymbolsptr  null              $^      if newosymbols is not none$^        newosymbolsptr  newosymbols.table$^ $^  pyxvnewosymbolsptr  null$^$^   pywrapfst.pyx0000$^        newisymbolsptr  newisymbols.table$^      cdef fst.symboltable newosymbolsptr  null$^      if newosymbols is not none              $^        newosymbolsptr  newosymbols.table$^      fst.relabelself.mfst.get$^ $^  pyxt0  pyobject pyxvnewosymbols  pynone$^  pyxt0  pyxt0  0$^  if pyxt0 $^$^     pywrapfst.pyx0000$^      cdef fst.symboltable newosymbolsptr  null$^      if newosymbols is not none$^        newosymbolsptr  newosymbols.table              $^      fst.relabelself.mfst.get$^          self.fst.get.inputsymbols if oldisymbols is none else$^ $^    if unlikelypyobject pyxvnewosymbols  pynone $^      pyerrformatpyexcattributeerror nonetype object has no attribute .00s table$^      pyxerr0 0000 pyxl0error$^    $^    pyxt0  pyxvnewosymbolstable$^    pyxvnewosymbolsptr  pyxt0$^$^     pywrapfst.pyx0000$^        newisymbolsptr  newisymbols.table$^      cdef fst.symboltable newosymbolsptr  null$^      if newosymbols is not none              $^        newosymbolsptr  newosymbols.table$^      fst.relabelself.mfst.get$^ $^  $^$^   pywrapfst.pyx0000$^      if newosymbols is not none$^        newosymbolsptr  newosymbols.table$^      fst.relabelself.mfst.get              $^          self.fst.get.inputsymbols if oldisymbols is none else$^          oldisymbols.table newisymbolsptr tostringunknownisymbol$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s mfst$^    pyxerr0 0000 pyxl0error$^  $^$^   pywrapfst.pyx0000$^        newosymbolsptr  newosymbols.table$^      fst.relabelself.mfst.get$^          self.fst.get.inputsymbols if oldisymbols is none else              $^          oldisymbols.table newisymbolsptr tostringunknownisymbol$^          attachnewisymbols$^ $^  pyxt0  pyobject pyxvoldisymbols  pynone$^  if pyxt0  0 $^    if unlikelypyobject pyxvself  pynone $^      pyerrformatpyexcattributeerror nonetype object has no attribute .00s fst$^      pyxerr0 0000 pyxl0error$^    $^    pyxt0  pyxvselfpyxbase.fst.getinputsymbols$^   else $^$^     pywrapfst.pyx0000$^      fst.relabelself.mfst.get$^          self.fst.get.inputsymbols if oldisymbols is none else$^          oldisymbols.table newisymbolsptr tostringunknownisymbol              $^          attachnewisymbols$^          self.fst.get.outputsymbols if oldosymbols is none else$^ $^    if unlikelypyobject pyxvoldisymbols  pynone $^      pyerrformatpyexcattributeerror nonetype object has no attribute .00s table$^      pyxerr0 0000 pyxl0error$^    $^    pyxt0  pyxvoldisymbolstable$^  $^  pyxt0  pyxf0pywrapfsttostringpyxvunknownisymbol null if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^          oldisymbols.table newisymbolsptr tostringunknownisymbol$^          attachnewisymbols$^          self.fst.get.outputsymbols if oldosymbols is none else              $^          oldosymbols.table newosymbolsptr tostringunknownosymbol$^          attachnewosymbols$^ $^  pyxt0  pyobject pyxvoldosymbols  pynone$^  if pyxt0  0 $^    if unlikelypyobject pyxvself  pynone $^      pyerrformatpyexcattributeerror nonetype object has no attribute .00s fst$^      pyxerr0 0000 pyxl0error$^    $^    pyxt0  pyxvselfpyxbase.fst.getoutputsymbols$^   else $^$^     pywrapfst.pyx0000$^          attachnewisymbols$^          self.fst.get.outputsymbols if oldosymbols is none else$^          oldosymbols.table newosymbolsptr tostringunknownosymbol              $^          attachnewosymbols$^      self.checkmutatingimethod$^ $^    if unlikelypyobject pyxvoldosymbols  pynone $^      pyerrformatpyexcattributeerror nonetype object has no attribute .00s table$^      pyxerr0 0000 pyxl0error$^    $^    pyxt0  pyxvoldosymbolstable$^  $^  pyxt00  pyxf0pywrapfsttostringpyxvunknownosymbol null if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^      if newosymbols is not none$^        newosymbolsptr  newosymbols.table$^      fst.relabelself.mfst.get              $^          self.fst.get.inputsymbols if oldisymbols is none else$^          oldisymbols.table newisymbolsptr tostringunknownisymbol$^ $^  fstscriptrelabelpyxvselfmfst.get pyxt0 pyxvnewisymbolsptr pyxt0 pyxvattachnewisymbols pyxt0 pyxvnewosymbolsptr pyxt00 pyxvattachnewosymbols$^$^   pywrapfst.pyx0000$^          oldosymbols.table newosymbolsptr tostringunknownosymbol$^          attachnewosymbols$^      self.checkmutatingimethod              $^  $^    def relabeltablesself$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s checkmutatingimethod$^    pyxerr0 0000 pyxl0error$^  $^  struct pyxvtabstruct0pywrapfstmutablefst pyxvselfpyxbase.pyxvtabcheckmutatingimethodpyxvself if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^      return self$^  $^    cdef void relabeltablesself              $^                              symboltable oldisymbolsnone$^                              symboltable newisymbolsnone$^ $^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.mutablefst.relabeltables pyxclineno pyxlineno pyxfilename$^  pyxl0$^  pyxrefnannyfinishcontext$^$^$^ pywrapfst.pyx0000$^      self.checkmutatingimethod$^  $^    def relabeltablesself              $^                       symboltable oldisymbolsnone$^                       symboltable newisymbolsnone$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00mutablefst00relabeltablespyobject pyxvself pyobject pyxargs pyobject pyxkwds proto$^static char pyxdoc0pywrapfst00mutablefst00relabeltables  n    relabeltablesself oldisymbolsnone newisymbolsnonen                   unknownisymbol attachnewisymbolstruen                   oldosymbolsnone newosymbolsnonen                   unknownosymbol attachnewosymbolstruenn    replaces input andor output labels using symboltables.nn    this operation destructively relabels the input andor output labels of then    fst using userspecified symbol tables omitted symbols are identitymapped.nn    argsn       oldisymbols the old symboltable for input labels defaulting to then          fsts input symbol table.n       newisymbols a symboltable used to relabel the input labelsn       unknownisymbol input symbol to use to relabel oovs if emptyn          oovs raise an exceptionn       attachnewisymbols should newisymbols be made the fsts input symboln          tablen       oldosymbols the old symboltable for output labels defaulting to then          fsts output symbol table.n       newosymbols a symboltable used to relabel the output labels.n       unknownosymbol outnput symbol to use to relabel oovs if emptyn          oovs raise an exceptionn       attachnewisymbols should newosymbols be made the fsts output symboln          tablenn    returnsn      self.nn    raisesn      fstargerror no symboltable specified.nn    see also decode encode project relabelpairs.n    $^static pyobject pyxpw0pywrapfst00mutablefst00relabeltablespyobject pyxvself pyobject pyxargs pyobject pyxkwds $^  struct pyxobj0pywrapfstsymboltable pyxvoldisymbols  0$^  struct pyxobj0pywrapfstsymboltable pyxvnewisymbols  0$^  pyobject pyxvunknownisymbol  0$^  bool pyxvattachnewisymbols$^  struct pyxobj0pywrapfstsymboltable pyxvoldosymbols  0$^  struct pyxobj0pywrapfstsymboltable pyxvnewosymbols  0$^  pyobject pyxvunknownosymbol  0$^  bool pyxvattachnewosymbols$^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextrelabeltables wrapper 0$^  $^    static pyobject pyxpyargnames  pyxnsoldisymbolspyxnsnewisymbolspyxnsunknownisymbolpyxnsattachnewisymbolspyxnsoldosymbolspyxnsnewosymbolspyxnsunknownosymbolpyxnsattachnewosymbols0$^    pyobject values0  00000000$^$^     pywrapfst.pyx0000$^  $^    def relabeltablesself$^                       symboltable oldisymbolsnone              $^                       symboltable newisymbolsnone$^                       unknownisymbolb$^ $^    values0  pyobject struct pyxobj0pywrapfstsymboltable pynone$^$^     pywrapfst.pyx0000$^    def relabeltablesself$^                       symboltable oldisymbolsnone$^                       symboltable newisymbolsnone              $^                       unknownisymbolb$^                       bool attachnewisymbolstrue$^ $^    values0  pyobject struct pyxobj0pywrapfstsymboltable pynone$^    values0  pyobject pyxkpb00$^$^     pywrapfst.pyx0000$^                       unknownisymbolb$^                       bool attachnewisymbolstrue$^                       symboltable oldosymbolsnone              $^                       symboltable newosymbolsnone$^                       unknownosymbolb$^ $^    values0  pyobject struct pyxobj0pywrapfstsymboltable pynone$^$^     pywrapfst.pyx0000$^                       bool attachnewisymbolstrue$^                       symboltable oldosymbolsnone$^                       symboltable newosymbolsnone              $^                       unknownosymbolb$^                       bool attachnewosymbolstrue$^ $^    values0  pyobject struct pyxobj0pywrapfstsymboltable pynone$^    values0  pyobject pyxkpb00$^    if unlikelypyxkwds $^      pyssizet kwargs$^      const pyssizet posargs  pytuplegetsizepyxargs$^      switch posargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 break$^        default goto pyxl0argtupleerror$^      $^      kwargs  pydictsizepyxkwds$^      switch posargs $^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnsoldisymbols$^          if value  values0  value kwargs $^        $^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnsnewisymbols$^          if value  values0  value kwargs $^        $^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnsunknownisymbol$^          if value  values0  value kwargs $^        $^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnsattachnewisymbols$^          if value  values0  value kwargs $^        $^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnsoldosymbols$^          if value  values0  value kwargs $^        $^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnsnewosymbols$^          if value  values0  value kwargs $^        $^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnsunknownosymbol$^          if value  values0  value kwargs $^        $^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnsattachnewosymbols$^          if value  values0  value kwargs $^        $^      $^      if unlikelykwargs  0 $^        if unlikelypyxparseoptionalkeywordspyxkwds pyxpyargnames 0 values posargs relabeltables  0 pyxerr0 0000 pyxl0error$^      $^     else $^      switch pytuplegetsizepyxargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 break$^        default goto pyxl0argtupleerror$^      $^    $^    pyxvoldisymbols  struct pyxobj0pywrapfstsymboltable values0$^    pyxvnewisymbols  struct pyxobj0pywrapfstsymboltable values0$^    pyxvunknownisymbol  values0$^    if values0 $^      pyxvattachnewisymbols  pyxpyobjectistruevalues0 if unlikelypyxvattachnewisymbols  bool0  pyerroccurred pyxerr0 0000 pyxl0error$^     else $^$^       pywrapfst.pyx0000$^                       symboltable newisymbolsnone$^                       unknownisymbolb$^                       bool attachnewisymbolstrue              $^                       symboltable oldosymbolsnone$^                       symboltable newosymbolsnone$^ $^      pyxvattachnewisymbols  bool0$^    $^    pyxvoldosymbols  struct pyxobj0pywrapfstsymboltable values0$^    pyxvnewosymbols  struct pyxobj0pywrapfstsymboltable values0$^    pyxvunknownosymbol  values0$^    if values0 $^      pyxvattachnewosymbols  pyxpyobjectistruevalues0 if unlikelypyxvattachnewosymbols  bool0  pyerroccurred pyxerr0 0000 pyxl0error$^     else $^$^       pywrapfst.pyx0000$^                       symboltable newosymbolsnone$^                       unknownosymbolb$^                       bool attachnewosymbolstrue              $^      $^      relabeltablesself oldisymbolsnone newisymbolsnone$^ $^      pyxvattachnewosymbols  bool0$^    $^  $^  goto pyxl0argumentunpackingdone$^  pyxl0argtupleerror$^  pyxraiseargtupleinvalidrelabeltables 0 0 0 pytuplegetsizepyxargs pyxerr0 0000 pyxl0error$^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablefst.relabeltables pyxclineno pyxlineno pyxfilename$^  pyxrefnannyfinishcontext$^  return null$^  pyxl0argumentunpackingdone$^  if unlikelypyxargtypetestpyobject pyxvoldisymbols pyxptype0pywrapfstsymboltable 0 oldisymbols 0 pyxerr0 0000 pyxl0error$^  if unlikelypyxargtypetestpyobject pyxvnewisymbols pyxptype0pywrapfstsymboltable 0 newisymbols 0 pyxerr0 0000 pyxl0error$^  if unlikelypyxargtypetestpyobject pyxvoldosymbols pyxptype0pywrapfstsymboltable 0 oldosymbols 0 pyxerr0 0000 pyxl0error$^  if unlikelypyxargtypetestpyobject pyxvnewosymbols pyxptype0pywrapfstsymboltable 0 newosymbols 0 pyxerr0 0000 pyxl0error$^  pyxr  pyxpf0pywrapfst00mutablefst00relabeltablesstruct pyxobj0pywrapfstmutablefst pyxvself pyxvoldisymbols pyxvnewisymbols pyxvunknownisymbol pyxvattachnewisymbols pyxvoldosymbols pyxvnewosymbols pyxvunknownosymbol pyxvattachnewosymbols$^$^   pywrapfst.pyx0000$^      self.checkmutatingimethod$^  $^    def relabeltablesself              $^                       symboltable oldisymbolsnone$^                       symboltable newisymbolsnone$^ $^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxr  null$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00mutablefst00relabeltablesstruct pyxobj0pywrapfstmutablefst pyxvself struct pyxobj0pywrapfstsymboltable pyxvoldisymbols struct pyxobj0pywrapfstsymboltable pyxvnewisymbols pyobject pyxvunknownisymbol bool pyxvattachnewisymbols struct pyxobj0pywrapfstsymboltable pyxvoldosymbols struct pyxobj0pywrapfstsymboltable pyxvnewosymbols pyobject pyxvunknownosymbol bool pyxvattachnewosymbols $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  struct pyxoptargs0pywrapfst00mutablefstrelabeltables pyxt0$^  pyxrefnannysetupcontextrelabeltables 0$^$^   pywrapfst.pyx0000$^      see also decode encode project relabelpairs.$^      $^      self.relabeltablesoldisymbols newisymbols              $^                           unknownisymbol attachnewisymbols$^                           oldosymbols newosymbols$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s relabeltables$^    pyxerr0 0000 pyxl0error$^  $^$^   pywrapfst.pyx0000$^                           unknownisymbol attachnewisymbols$^                           oldosymbols newosymbols$^                           unknownosymbol attachnewosymbols              $^      return self$^  $^ $^  pyxt0.pyxn  0$^  pyxt0.oldisymbols  pyxvoldisymbols$^  pyxt0.newisymbols  pyxvnewisymbols$^  pyxt0.unknownisymbol  pyxvunknownisymbol$^  pyxt0.attachnewisymbols  pyxvattachnewisymbols$^  pyxt0.oldosymbols  pyxvoldosymbols$^  pyxt0.newosymbols  pyxvnewosymbols$^  pyxt0.unknownosymbol  pyxvunknownosymbol$^  pyxt0.attachnewosymbols  pyxvattachnewosymbols$^  struct pyxvtabstruct0pywrapfstmutablefst pyxvselfpyxbase.pyxvtabrelabeltablespyxvself pyxt0 if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^                           oldosymbols newosymbols$^                           unknownosymbol attachnewosymbols$^      return self              $^  $^    cdef void reservearcsself int00 state sizet n except $^ $^  pyxxdecrefpyxr$^  pyxincrefpyobject pyxvself$^  pyxr  pyobject pyxvself$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      self.checkmutatingimethod$^  $^    def relabeltablesself              $^                       symboltable oldisymbolsnone$^                       symboltable newisymbolsnone$^ $^$^   function exit code $^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablefst.relabeltables pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return self$^  $^    cdef void reservearcsself int00 state sizet n except               $^      if not self.mfst.get.reservearcsstate n$^        raise fstindexerrorstate index out of range$^ $^$^static void pyxf0pywrapfst00mutablefstreservearcsstruct pyxobj0pywrapfstmutablefst pyxvself pyxt00basictypesint00 pyxvstate sizet pyxvn $^  pyxrefnannydeclarations$^  int pyxt0$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextreservearcs 0$^$^   pywrapfst.pyx0000$^  $^    cdef void reservearcsself int00 state sizet n except $^      if not self.mfst.get.reservearcsstate n              $^        raise fstindexerrorstate index out of range$^      self.checkmutatingimethod$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s mfst$^    pyxerr0 0000 pyxl0error$^  $^  pyxt0  pyxvselfmfst.getreservearcspyxvstate pyxvn  0  0$^  if unlikelypyxt0 $^$^     pywrapfst.pyx0000$^    cdef void reservearcsself int00 state sizet n except $^      if not self.mfst.get.reservearcsstate n$^        raise fstindexerrorstate index out of range              $^      self.checkmutatingimethod$^  $^ $^    pyxt0  pyxgetmoduleglobalnamepyxnsfstindexerror if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  pyxpyobjectcallpyxt0 pyxtuple00 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxraisepyxt0 0 0 0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxerr0 0000 pyxl0error$^$^     pywrapfst.pyx0000$^  $^    cdef void reservearcsself int00 state sizet n except $^      if not self.mfst.get.reservearcsstate n              $^        raise fstindexerrorstate index out of range$^      self.checkmutatingimethod$^ $^  $^$^   pywrapfst.pyx0000$^      if not self.mfst.get.reservearcsstate n$^        raise fstindexerrorstate index out of range$^      self.checkmutatingimethod              $^  $^    def reservearcsself int00 state sizet n$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s checkmutatingimethod$^    pyxerr0 0000 pyxl0error$^  $^  struct pyxvtabstruct0pywrapfstmutablefst pyxvselfpyxbase.pyxvtabcheckmutatingimethodpyxvself if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^      return self$^  $^    cdef void reservearcsself int00 state sizet n except               $^      if not self.mfst.get.reservearcsstate n$^        raise fstindexerrorstate index out of range$^ $^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.mutablefst.reservearcs pyxclineno pyxlineno pyxfilename$^  pyxl0$^  pyxrefnannyfinishcontext$^$^$^ pywrapfst.pyx0000$^      self.checkmutatingimethod$^  $^    def reservearcsself int00 state sizet n              $^      $^      reservearcsself state n$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00mutablefst00reservearcspyobject pyxvself pyobject pyxargs pyobject pyxkwds proto$^static char pyxdoc0pywrapfst00mutablefst00reservearcs  n    reservearcsself state nnn    reserve n arcs at a particular state best effort.nn    argsn      state the integer index of a state.n      n the number of arcs to reserve.nn    returnsn      self.nn    raisesn      fstindexerror state index out of range.nn    see also reservestates.n    $^static pyobject pyxpw0pywrapfst00mutablefst00reservearcspyobject pyxvself pyobject pyxargs pyobject pyxkwds $^  pyxt00basictypesint00 pyxvstate$^  sizet pyxvn$^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextreservearcs wrapper 0$^  $^    static pyobject pyxpyargnames  pyxnsstatepyxnsn0$^    pyobject values0  00$^    if unlikelypyxkwds $^      pyssizet kwargs$^      const pyssizet posargs  pytuplegetsizepyxargs$^      switch posargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 break$^        default goto pyxl0argtupleerror$^      $^      kwargs  pydictsizepyxkwds$^      switch posargs $^        case  0$^        if likelyvalues0  pyxpydictgetitemstrpyxkwds pyxnsstate  0 kwargs$^        else goto pyxl0argtupleerror$^        cythonfallthrough$^        case  0$^        if likelyvalues0  pyxpydictgetitemstrpyxkwds pyxnsn  0 kwargs$^        else $^          pyxraiseargtupleinvalidreservearcs 0 0 0 0 pyxerr0 0000 pyxl0error$^        $^      $^      if unlikelykwargs  0 $^        if unlikelypyxparseoptionalkeywordspyxkwds pyxpyargnames 0 values posargs reservearcs  0 pyxerr0 0000 pyxl0error$^      $^     else if pytuplegetsizepyxargs  0 $^      goto pyxl0argtupleerror$^     else $^      values0  pytuplegetitempyxargs 0$^      values0  pytuplegetitempyxargs 0$^    $^    pyxvstate  pyxpyintasint00tvalues0 if unlikelypyxvstate  int00t0  pyerroccurred pyxerr0 0000 pyxl0error$^    pyxvn  pyxpyintassizetvalues0 if unlikelypyxvn  sizet0  pyerroccurred pyxerr0 0000 pyxl0error$^  $^  goto pyxl0argumentunpackingdone$^  pyxl0argtupleerror$^  pyxraiseargtupleinvalidreservearcs 0 0 0 pytuplegetsizepyxargs pyxerr0 0000 pyxl0error$^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablefst.reservearcs pyxclineno pyxlineno pyxfilename$^  pyxrefnannyfinishcontext$^  return null$^  pyxl0argumentunpackingdone$^  pyxr  pyxpf0pywrapfst00mutablefst00reservearcsstruct pyxobj0pywrapfstmutablefst pyxvself pyxvstate pyxvn$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00mutablefst00reservearcsstruct pyxobj0pywrapfstmutablefst pyxvself pyxt00basictypesint00 pyxvstate sizet pyxvn $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextreservearcs 0$^$^   pywrapfst.pyx0000$^      see also reservestates.$^      $^      self.reservearcsstate n              $^      return self$^  $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s reservearcs$^    pyxerr0 0000 pyxl0error$^  $^  struct pyxvtabstruct0pywrapfstmutablefst pyxvselfpyxbase.pyxvtabreservearcspyxvself pyxvstate pyxvn if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^      $^      self.reservearcsstate n$^      return self              $^  $^    cdef void reservestatesself int00 n except $^ $^  pyxxdecrefpyxr$^  pyxincrefpyobject pyxvself$^  pyxr  pyobject pyxvself$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      self.checkmutatingimethod$^  $^    def reservearcsself int00 state sizet n              $^      $^      reservearcsself state n$^ $^$^   function exit code $^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablefst.reservearcs pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return self$^  $^    cdef void reservestatesself int00 n except               $^      self.mfst.get.reservestatesn$^      self.checkmutatingimethod$^ $^$^static void pyxf0pywrapfst00mutablefstreservestatesstruct pyxobj0pywrapfstmutablefst pyxvself pyxt00basictypesint00 pyxvn $^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextreservestates 0$^$^   pywrapfst.pyx0000$^  $^    cdef void reservestatesself int00 n except $^      self.mfst.get.reservestatesn              $^      self.checkmutatingimethod$^  $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s mfst$^    pyxerr0 0000 pyxl0error$^  $^  pyxvselfmfst.getreservestatespyxvn$^$^   pywrapfst.pyx0000$^    cdef void reservestatesself int00 n except $^      self.mfst.get.reservestatesn$^      self.checkmutatingimethod              $^  $^    def reservestatesself int00 n$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s checkmutatingimethod$^    pyxerr0 0000 pyxl0error$^  $^  struct pyxvtabstruct0pywrapfstmutablefst pyxvselfpyxbase.pyxvtabcheckmutatingimethodpyxvself if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^      return self$^  $^    cdef void reservestatesself int00 n except               $^      self.mfst.get.reservestatesn$^      self.checkmutatingimethod$^ $^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablefst.reservestates pyxclineno pyxlineno pyxfilename$^  pyxl0$^  pyxrefnannyfinishcontext$^$^$^ pywrapfst.pyx0000$^      self.checkmutatingimethod$^  $^    def reservestatesself int00 n              $^      $^      reservestatesself n$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00mutablefst00reservestatespyobject pyxvself pyobject pyxargn proto$^static char pyxdoc0pywrapfst00mutablefst00reservestates  n    reservestatesself nnn    reserve n states best effort.nn    argsn      n the number of states to reserve.nn    returnsn      self.nn    see also reservearcs.n    $^static pyobject pyxpw0pywrapfst00mutablefst00reservestatespyobject pyxvself pyobject pyxargn $^  pyxt00basictypesint00 pyxvn$^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextreservestates wrapper 0$^  assertpyxargn $^    pyxvn  pyxpyintasint00tpyxargn if unlikelypyxvn  int00t0  pyerroccurred pyxerr0 0000 pyxl0error$^  $^  goto pyxl0argumentunpackingdone$^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablefst.reservestates pyxclineno pyxlineno pyxfilename$^  pyxrefnannyfinishcontext$^  return null$^  pyxl0argumentunpackingdone$^  pyxr  pyxpf0pywrapfst00mutablefst00reservestatesstruct pyxobj0pywrapfstmutablefst pyxvself pyxt00basictypesint00pyxvn$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00mutablefst00reservestatesstruct pyxobj0pywrapfstmutablefst pyxvself pyxt00basictypesint00 pyxvn $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextreservestates 0$^$^   pywrapfst.pyx0000$^      see also reservearcs.$^      $^      self.reservestatesn              $^      return self$^  $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s reservestates$^    pyxerr0 0000 pyxl0error$^  $^  struct pyxvtabstruct0pywrapfstmutablefst pyxvselfpyxbase.pyxvtabreservestatespyxvself pyxvn if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^      $^      self.reservestatesn$^      return self              $^  $^    cdef void reweightself potentials bool tofinalfalse except $^ $^  pyxxdecrefpyxr$^  pyxincrefpyobject pyxvself$^  pyxr  pyobject pyxvself$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      self.checkmutatingimethod$^  $^    def reservestatesself int00 n              $^      $^      reservestatesself n$^ $^$^   function exit code $^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablefst.reservestates pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return self$^  $^    cdef void reweightself potentials bool tofinalfalse except               $^      cdef uniqueptrvectorfst.weightclass potentials$^      potentials.resetnew vectorfst.weightclass$^ $^$^static void pyxf0pywrapfst00mutablefstreweightstruct pyxobj0pywrapfstmutablefst pyxvself pyobject pyxvpotentials struct pyxoptargs0pywrapfst00mutablefstreweight pyxoptionalargs $^  bool pyxvtofinal  bool0$^  stduniqueptrstdvectorfstscriptweightclass   pyxvpotentials$^  cythonunused stdstring pyxvweighttype$^  pyobject pyxvweight  null$^  pyxrefnannydeclarations$^  stdvectorfstscriptweightclass  pyxt0$^  pyobject pyxt0  null$^  pyssizet pyxt0$^  pyobject pyxt0pyobject $^  pyobject pyxt0  null$^  fstscriptweightclass pyxt0$^  pyxrefnannysetupcontextreweight 0$^  if pyxoptionalargs $^    if pyxoptionalargspyxn  0 $^      pyxvtofinal  pyxoptionalargstofinal$^    $^  $^$^   pywrapfst.pyx0000$^    cdef void reweightself potentials bool tofinalfalse except $^      cdef uniqueptrvectorfst.weightclass potentials$^      potentials.resetnew vectorfst.weightclass              $^      cdef string weighttype  self.weighttype$^      for weight in potentials$^ $^  try $^    pyxt0  new stdvectorfstscriptweightclass $^   catch... $^    pyxcppexn0pyerr$^    pyxerr0 0000 pyxl0error$^  $^  pyxvpotentials.resetpyxt0$^$^   pywrapfst.pyx0000$^      cdef uniqueptrvectorfst.weightclass potentials$^      potentials.resetnew vectorfst.weightclass$^      cdef string weighttype  self.weighttype              $^      for weight in potentials$^          potentials.get.pushbackgetweightclassoroneself.weighttype$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s weighttype$^    pyxerr0 0000 pyxl0error$^  $^  pyxvweighttype  struct pyxvtabstruct0pywrapfstmutablefst pyxvselfpyxbase.pyxvtabpyxbase.weighttypestruct pyxobj0pywrapfstfst pyxvself 0$^$^   pywrapfst.pyx0000$^      potentials.resetnew vectorfst.weightclass$^      cdef string weighttype  self.weighttype$^      for weight in potentials              $^          potentials.get.pushbackgetweightclassoroneself.weighttype$^                                                              weight$^ $^  if likelypylistcheckexactpyxvpotentials  pytuplecheckexactpyxvpotentials $^    pyxt0  pyxvpotentials pyxincrefpyxt0 pyxt0  0$^    pyxt0  null$^   else $^    pyxt0  0 pyxt0  pyobjectgetiterpyxvpotentials if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  pytypepyxt0tpiternext if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  $^  for  $^    if likelypyxt0 $^      if likelypylistcheckexactpyxt0 $^        if pyxt0  pylistgetsizepyxt0 break$^        if cythonassumesafemacros  cythonavoidborrowedrefs$^        pyxt0  pylistgetitempyxt0 pyxt0 pyxincrefpyxt0 pyxt0 if unlikely0  0 pyxerr0 0000 pyxl0error$^        else$^        pyxt0  pysequenceitempyxt0 pyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxgotrefpyxt0$^        endif$^       else $^        if pyxt0  pytuplegetsizepyxt0 break$^        if cythonassumesafemacros  cythonavoidborrowedrefs$^        pyxt0  pytuplegetitempyxt0 pyxt0 pyxincrefpyxt0 pyxt0 if unlikely0  0 pyxerr0 0000 pyxl0error$^        else$^        pyxt0  pysequenceitempyxt0 pyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxgotrefpyxt0$^        endif$^      $^     else $^      pyxt0  pyxt0pyxt0$^      if unlikelypyxt0 $^        pyobject exctype  pyerroccurred$^        if exctype $^          if likelypyxpyerrgivenexceptionmatchesexctype pyexcstopiteration pyerrclear$^          else pyxerr0 0000 pyxl0error$^        $^        break$^      $^      pyxgotrefpyxt0$^    $^    pyxxdecrefsetpyxvweight pyxt0$^    pyxt0  0$^$^     pywrapfst.pyx0000$^      cdef string weighttype  self.weighttype$^      for weight in potentials$^          potentials.get.pushbackgetweightclassoroneself.weighttype              $^                                                              weight$^      fst.reweightself.mfst.get derefpotentials$^ $^    if unlikelypyobject pyxvself  pynone $^      pyerrformatpyexcattributeerror nonetype object has no attribute .00s weighttype$^      pyxerr0 0000 pyxl0error$^    $^$^     pywrapfst.pyx0000$^      for weight in potentials$^          potentials.get.pushbackgetweightclassoroneself.weighttype$^                                                              weight              $^      fst.reweightself.mfst.get derefpotentials$^                   fst.getreweighttypetofinal$^ $^    pyxt0  pyxf0pywrapfstgetweightclassoronestruct pyxvtabstruct0pywrapfstmutablefst pyxvselfpyxbase.pyxvtabpyxbase.weighttypestruct pyxobj0pywrapfstfst pyxvself 0 pyxvweight if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^     pywrapfst.pyx0000$^      cdef string weighttype  self.weighttype$^      for weight in potentials$^          potentials.get.pushbackgetweightclassoroneself.weighttype              $^                                                              weight$^      fst.reweightself.mfst.get derefpotentials$^ $^    try $^      pyxvpotentials.getpushbackpyxt0$^     catch... $^      pyxcppexn0pyerr$^      pyxerr0 0000 pyxl0error$^    $^$^     pywrapfst.pyx0000$^      potentials.resetnew vectorfst.weightclass$^      cdef string weighttype  self.weighttype$^      for weight in potentials              $^          potentials.get.pushbackgetweightclassoroneself.weighttype$^                                                              weight$^ $^  $^  pyxdecrefpyxt0 pyxt0  0$^$^   pywrapfst.pyx0000$^          potentials.get.pushbackgetweightclassoroneself.weighttype$^                                                              weight$^      fst.reweightself.mfst.get derefpotentials              $^                   fst.getreweighttypetofinal$^      self.checkmutatingimethod$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s mfst$^    pyxerr0 0000 pyxl0error$^  $^$^   pywrapfst.pyx0000$^                                                              weight$^      fst.reweightself.mfst.get derefpotentials$^                   fst.getreweighttypetofinal              $^      self.checkmutatingimethod$^  $^ $^  fstscriptreweightpyxvselfmfst.get pyxvpotentials fstscriptgetreweighttypepyxvtofinal$^$^   pywrapfst.pyx0000$^      fst.reweightself.mfst.get derefpotentials$^                   fst.getreweighttypetofinal$^      self.checkmutatingimethod              $^  $^    def reweightself potentials bool tofinalfalse$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s checkmutatingimethod$^    pyxerr0 0000 pyxl0error$^  $^  struct pyxvtabstruct0pywrapfstmutablefst pyxvselfpyxbase.pyxvtabcheckmutatingimethodpyxvself if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^      return self$^  $^    cdef void reweightself potentials bool tofinalfalse except               $^      cdef uniqueptrvectorfst.weightclass potentials$^      potentials.resetnew vectorfst.weightclass$^ $^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.mutablefst.reweight pyxclineno pyxlineno pyxfilename$^  pyxl0$^  pyxxdecrefpyxvweight$^  pyxrefnannyfinishcontext$^$^$^ pywrapfst.pyx0000$^      self.checkmutatingimethod$^  $^    def reweightself potentials bool tofinalfalse              $^      $^      reweightself potentials tofinalfalse$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00mutablefst00reweightpyobject pyxvself pyobject pyxargs pyobject pyxkwds proto$^static char pyxdoc0pywrapfst00mutablefst00reweight  n    reweightself potentials tofinalfalsenn    reweights an fst using an iterable of potentials.nn    this operation destructively reweights an fst according to the potentialsn    and in the direction specified by the user. an arc of weight w with ann    origin state of potential p and destination state of potential q isn    reweighted by p0 otimes w otimes q when reweighting towards then    initial state and by p otimes w otimes q0 when reweighting towardsn    the final states. the weights must be left distributive when reweightingn    towards the initial state and right distributive when reweighting towardsn    the final states e.g. tropicalweight and logweight.nn    argsn      potentials an iterable of weight or weight strings.n      tofinal push towards final statesnn    returnsn      self.n    $^static pyobject pyxpw0pywrapfst00mutablefst00reweightpyobject pyxvself pyobject pyxargs pyobject pyxkwds $^  pyobject pyxvpotentials  0$^  bool pyxvtofinal$^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextreweight wrapper 0$^  $^    static pyobject pyxpyargnames  pyxnspotentialspyxnstofinal0$^    pyobject values0  00$^    if unlikelypyxkwds $^      pyssizet kwargs$^      const pyssizet posargs  pytuplegetsizepyxargs$^      switch posargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 break$^        default goto pyxl0argtupleerror$^      $^      kwargs  pydictsizepyxkwds$^      switch posargs $^        case  0$^        if likelyvalues0  pyxpydictgetitemstrpyxkwds pyxnspotentials  0 kwargs$^        else goto pyxl0argtupleerror$^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnstofinal$^          if value  values0  value kwargs $^        $^      $^      if unlikelykwargs  0 $^        if unlikelypyxparseoptionalkeywordspyxkwds pyxpyargnames 0 values posargs reweight  0 pyxerr0 0000 pyxl0error$^      $^     else $^      switch pytuplegetsizepyxargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        break$^        default goto pyxl0argtupleerror$^      $^    $^    pyxvpotentials  values0$^    if values0 $^      pyxvtofinal  pyxpyobjectistruevalues0 if unlikelypyxvtofinal  bool0  pyerroccurred pyxerr0 0000 pyxl0error$^     else $^      pyxvtofinal  bool0$^    $^  $^  goto pyxl0argumentunpackingdone$^  pyxl0argtupleerror$^  pyxraiseargtupleinvalidreweight 0 0 0 pytuplegetsizepyxargs pyxerr0 0000 pyxl0error$^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablefst.reweight pyxclineno pyxlineno pyxfilename$^  pyxrefnannyfinishcontext$^  return null$^  pyxl0argumentunpackingdone$^  pyxr  pyxpf0pywrapfst00mutablefst00reweightstruct pyxobj0pywrapfstmutablefst pyxvself pyxvpotentials pyxvtofinal$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00mutablefst00reweightstruct pyxobj0pywrapfstmutablefst pyxvself pyobject pyxvpotentials bool pyxvtofinal $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  struct pyxoptargs0pywrapfst00mutablefstreweight pyxt0$^  pyxrefnannysetupcontextreweight 0$^$^   pywrapfst.pyx0000$^        self.$^      $^      self.reweightpotentials tofinal              $^      return self$^  $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s reweight$^    pyxerr0 0000 pyxl0error$^  $^  pyxt0.pyxn  0$^  pyxt0.tofinal  pyxvtofinal$^  struct pyxvtabstruct0pywrapfstmutablefst pyxvselfpyxbase.pyxvtabreweightpyxvself pyxvpotentials pyxt0 if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^      $^      self.reweightpotentials tofinal$^      return self              $^  $^    cdef void rmepsilonself$^ $^  pyxxdecrefpyxr$^  pyxincrefpyobject pyxvself$^  pyxr  pyobject pyxvself$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      self.checkmutatingimethod$^  $^    def reweightself potentials bool tofinalfalse              $^      $^      reweightself potentials tofinalfalse$^ $^$^   function exit code $^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablefst.reweight pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return self$^  $^    cdef void rmepsilonself              $^                         queuetypebauto$^                         bool connecttrue$^ $^$^static void pyxf0pywrapfst00mutablefstrmepsilonstruct pyxobj0pywrapfstmutablefst pyxvself struct pyxoptargs0pywrapfst00mutablefstrmepsilon pyxoptionalargs $^  pyobject pyxvqueuetype  pyobject pyxnbauto$^$^   pywrapfst.pyx0000$^    cdef void rmepsilonself$^                         queuetypebauto$^                         bool connecttrue              $^                         weightnone$^                         int00 nstatefst.knostateid$^ $^  bool pyxvconnect  bool0$^$^   pywrapfst.pyx0000$^                         queuetypebauto$^                         bool connecttrue$^                         weightnone              $^                         int00 nstatefst.knostateid$^                         float deltafst.kshortestdelta except $^ $^  pyobject pyxvweight  pyobject pynone$^  pyxt00basictypesint00 pyxvnstate  pyxk00$^  float pyxvdelta  pyxk00$^  fstscriptweightclass pyxvwc$^  stduniqueptrfstscriptrmepsilonoptions  pyxvopts$^  pyxrefnannydeclarations$^  fstscriptweightclass pyxt0$^  stdstring pyxt0$^  enum fstqueuetype pyxt0$^  pyxrefnannysetupcontextrmepsilon 0$^  if pyxoptionalargs $^    if pyxoptionalargspyxn  0 $^      pyxvqueuetype  pyxoptionalargsqueuetype$^      if pyxoptionalargspyxn  0 $^        pyxvconnect  pyxoptionalargsconnect$^        if pyxoptionalargspyxn  0 $^          pyxvweight  pyxoptionalargsweight$^          if pyxoptionalargspyxn  0 $^            pyxvnstate  pyxoptionalargsnstate$^            if pyxoptionalargspyxn  0 $^              pyxvdelta  pyxoptionalargsdelta$^            $^          $^        $^      $^    $^  $^$^   pywrapfst.pyx0000$^                         int00 nstatefst.knostateid$^                         float deltafst.kshortestdelta except $^      cdef fst.weightclass wc  getweightclassorzeroself.weighttype              $^                                                         weight$^      cdef uniqueptrfst.rmepsilonoptions opts$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s weighttype$^    pyxerr0 0000 pyxl0error$^  $^$^   pywrapfst.pyx0000$^                         float deltafst.kshortestdelta except $^      cdef fst.weightclass wc  getweightclassorzeroself.weighttype$^                                                         weight              $^      cdef uniqueptrfst.rmepsilonoptions opts$^      opts.resetnew fst.rmepsilonoptionsgetqueuetypetostringqueuetype$^ $^  pyxt0  pyxf0pywrapfstgetweightclassorzerostruct pyxvtabstruct0pywrapfstmutablefst pyxvselfpyxbase.pyxvtabpyxbase.weighttypestruct pyxobj0pywrapfstfst pyxvself 0 pyxvweight if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^  pyxvwc  pyxt0$^$^   pywrapfst.pyx0000$^                                                         weight$^      cdef uniqueptrfst.rmepsilonoptions opts$^      opts.resetnew fst.rmepsilonoptionsgetqueuetypetostringqueuetype              $^                                          connect wc nstate delta$^      fst.rmepsilonself.mfst.get derefopts$^ $^  pyxt0  pyxf0pywrapfsttostringpyxvqueuetype null if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^  pyxt0  pyxf0pywrapfstgetqueuetypepyxt0 if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^      cdef uniqueptrfst.rmepsilonoptions opts$^      opts.resetnew fst.rmepsilonoptionsgetqueuetypetostringqueuetype$^                                          connect wc nstate delta              $^      fst.rmepsilonself.mfst.get derefopts$^      self.checkmutatingimethod$^ $^  pyxvopts.resetnew fstscriptrmepsilonoptionspyxt0 pyxvconnect pyxvwc pyxvnstate pyxvdelta$^$^   pywrapfst.pyx0000$^      opts.resetnew fst.rmepsilonoptionsgetqueuetypetostringqueuetype$^                                          connect wc nstate delta$^      fst.rmepsilonself.mfst.get derefopts              $^      self.checkmutatingimethod$^  $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s mfst$^    pyxerr0 0000 pyxl0error$^  $^  fstscriptrmepsilonpyxvselfmfst.get pyxvopts$^$^   pywrapfst.pyx0000$^                                          connect wc nstate delta$^      fst.rmepsilonself.mfst.get derefopts$^      self.checkmutatingimethod              $^  $^    def rmepsilonself$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s checkmutatingimethod$^    pyxerr0 0000 pyxl0error$^  $^  struct pyxvtabstruct0pywrapfstmutablefst pyxvselfpyxbase.pyxvtabcheckmutatingimethodpyxvself if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^      return self$^  $^    cdef void rmepsilonself              $^                         queuetypebauto$^                         bool connecttrue$^ $^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablefst.rmepsilon pyxclineno pyxlineno pyxfilename$^  pyxl0$^  pyxrefnannyfinishcontext$^$^$^ pywrapfst.pyx0000$^      self.checkmutatingimethod$^  $^    def rmepsilonself              $^                  queuetypebauto$^                  bool connecttrue$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00mutablefst00rmepsilonpyobject pyxvself pyobject pyxargs pyobject pyxkwds proto$^static char pyxdoc0pywrapfst00mutablefst00rmepsilon  n    rmepsilonself queuetypeauto connecttrue weightnonen              nstatenostateid delta0e0nn    removes epsilon transitions.nn    this operation destructively removes epsilon transitions i.e. those wheren    both input and output labels are epsilon from an fst.nn    argsn      queuetype a string matching a known queue type one of auto fifon          lifo shortest state top.n      connect should output be trimmedn      weight a weight or weight string indicating the desired weight thresholdn          below which paths are pruned if omitted no paths are pruned.n      nstate state number threshold.n      delta comparisonquantization delta.nn    returnsn      self.n    $^static pyobject pyxpw0pywrapfst00mutablefst00rmepsilonpyobject pyxvself pyobject pyxargs pyobject pyxkwds $^  pyobject pyxvqueuetype  0$^  bool pyxvconnect$^  pyobject pyxvweight  0$^  pyxt00basictypesint00 pyxvnstate$^  float pyxvdelta$^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextrmepsilon wrapper 0$^  $^    static pyobject pyxpyargnames  pyxnsqueuetypepyxnsconnectpyxnsweightpyxnsnstatepyxnsdelta0$^    pyobject values0  00000$^    values0  pyobject pyxnbauto$^$^     pywrapfst.pyx0000$^                  queuetypebauto$^                  bool connecttrue$^                  weightnone              $^                  int00 nstatefst.knostateid$^                  float deltafst.kshortestdelta$^ $^    values0  pyobject pynone$^    if unlikelypyxkwds $^      pyssizet kwargs$^      const pyssizet posargs  pytuplegetsizepyxargs$^      switch posargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 break$^        default goto pyxl0argtupleerror$^      $^      kwargs  pydictsizepyxkwds$^      switch posargs $^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnsqueuetype$^          if value  values0  value kwargs $^        $^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnsconnect$^          if value  values0  value kwargs $^        $^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnsweight$^          if value  values0  value kwargs $^        $^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnsnstate$^          if value  values0  value kwargs $^        $^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnsdelta$^          if value  values0  value kwargs $^        $^      $^      if unlikelykwargs  0 $^        if unlikelypyxparseoptionalkeywordspyxkwds pyxpyargnames 0 values posargs rmepsilon  0 pyxerr0 0000 pyxl0error$^      $^     else $^      switch pytuplegetsizepyxargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 break$^        default goto pyxl0argtupleerror$^      $^    $^    pyxvqueuetype  values0$^    if values0 $^      pyxvconnect  pyxpyobjectistruevalues0 if unlikelypyxvconnect  bool0  pyerroccurred pyxerr0 0000 pyxl0error$^     else $^$^       pywrapfst.pyx0000$^    def rmepsilonself$^                  queuetypebauto$^                  bool connecttrue              $^                  weightnone$^                  int00 nstatefst.knostateid$^ $^      pyxvconnect  bool0$^    $^    pyxvweight  values0$^    if values0 $^      pyxvnstate  pyxpyintasint00tvalues0 if unlikelypyxvnstate  int00t0  pyerroccurred pyxerr0 0000 pyxl0error$^     else $^      pyxvnstate  pyxk00$^    $^    if values0 $^      pyxvdelta  pyxpyfloatasfloatvalues0 if unlikelypyxvdelta  float0  pyerroccurred pyxerr0 0000 pyxl0error$^     else $^      pyxvdelta  pyxk00$^    $^  $^  goto pyxl0argumentunpackingdone$^  pyxl0argtupleerror$^  pyxraiseargtupleinvalidrmepsilon 0 0 0 pytuplegetsizepyxargs pyxerr0 0000 pyxl0error$^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablefst.rmepsilon pyxclineno pyxlineno pyxfilename$^  pyxrefnannyfinishcontext$^  return null$^  pyxl0argumentunpackingdone$^  pyxr  pyxpf0pywrapfst00mutablefst00rmepsilonstruct pyxobj0pywrapfstmutablefst pyxvself pyxvqueuetype pyxvconnect pyxvweight pyxvnstate pyxvdelta$^$^   pywrapfst.pyx0000$^      self.checkmutatingimethod$^  $^    def rmepsilonself              $^                  queuetypebauto$^                  bool connecttrue$^ $^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00mutablefst00rmepsilonstruct pyxobj0pywrapfstmutablefst pyxvself pyobject pyxvqueuetype bool pyxvconnect pyobject pyxvweight pyxt00basictypesint00 pyxvnstate float pyxvdelta $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  struct pyxoptargs0pywrapfst00mutablefstrmepsilon pyxt0$^  pyxrefnannysetupcontextrmepsilon 0$^$^   pywrapfst.pyx0000$^        self.$^      $^      self.rmepsilonqueuetype connect weight nstate delta              $^      return self$^  $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s rmepsilon$^    pyxerr0 0000 pyxl0error$^  $^  pyxt0.pyxn  0$^  pyxt0.queuetype  pyxvqueuetype$^  pyxt0.connect  pyxvconnect$^  pyxt0.weight  pyxvweight$^  pyxt0.nstate  pyxvnstate$^  pyxt0.delta  pyxvdelta$^  struct pyxvtabstruct0pywrapfstmutablefst pyxvselfpyxbase.pyxvtabrmepsilonpyxvself pyxt0 if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^      $^      self.rmepsilonqueuetype connect weight nstate delta$^      return self              $^  $^    cdef void setfinalself int00 state weightnone except $^ $^  pyxxdecrefpyxr$^  pyxincrefpyobject pyxvself$^  pyxr  pyobject pyxvself$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      self.checkmutatingimethod$^  $^    def rmepsilonself              $^                  queuetypebauto$^                  bool connecttrue$^ $^$^   function exit code $^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablefst.rmepsilon pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return self$^  $^    cdef void setfinalself int00 state weightnone except               $^      if not self.mfst.get.validstateidstate$^        raise fstindexerrorstate index out of range$^ $^$^static void pyxf0pywrapfst00mutablefstsetfinalstruct pyxobj0pywrapfstmutablefst pyxvself pyxt00basictypesint00 pyxvstate struct pyxoptargs0pywrapfst00mutablefstsetfinal pyxoptionalargs $^  pyobject pyxvweight  pyobject pynone$^  fstscriptweightclass pyxvwc$^  pyxrefnannydeclarations$^  int pyxt0$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  fstscriptweightclass pyxt0$^  pyxrefnannysetupcontextsetfinal 0$^  if pyxoptionalargs $^    if pyxoptionalargspyxn  0 $^      pyxvweight  pyxoptionalargsweight$^    $^  $^$^   pywrapfst.pyx0000$^  $^    cdef void setfinalself int00 state weightnone except $^      if not self.mfst.get.validstateidstate              $^        raise fstindexerrorstate index out of range$^      cdef fst.weightclass wc  getweightclassoroneself.weighttype$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s mfst$^    pyxerr0 0000 pyxl0error$^  $^  pyxt0  pyxvselfmfst.getvalidstateidpyxvstate  0  0$^  if unlikelypyxt0 $^$^     pywrapfst.pyx0000$^    cdef void setfinalself int00 state weightnone except $^      if not self.mfst.get.validstateidstate$^        raise fstindexerrorstate index out of range              $^      cdef fst.weightclass wc  getweightclassoroneself.weighttype$^                                                        weight$^ $^    pyxt0  pyxgetmoduleglobalnamepyxnsfstindexerror if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  pyxpyobjectcallpyxt0 pyxtuple00 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxraisepyxt0 0 0 0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxerr0 0000 pyxl0error$^$^     pywrapfst.pyx0000$^  $^    cdef void setfinalself int00 state weightnone except $^      if not self.mfst.get.validstateidstate              $^        raise fstindexerrorstate index out of range$^      cdef fst.weightclass wc  getweightclassoroneself.weighttype$^ $^  $^$^   pywrapfst.pyx0000$^      if not self.mfst.get.validstateidstate$^        raise fstindexerrorstate index out of range$^      cdef fst.weightclass wc  getweightclassoroneself.weighttype              $^                                                        weight$^      if not self.mfst.get.setfinalstate wc$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s weighttype$^    pyxerr0 0000 pyxl0error$^  $^$^   pywrapfst.pyx0000$^        raise fstindexerrorstate index out of range$^      cdef fst.weightclass wc  getweightclassoroneself.weighttype$^                                                        weight              $^      if not self.mfst.get.setfinalstate wc$^        raise fstoperrorincompatible or invalid weight$^ $^  pyxt0  pyxf0pywrapfstgetweightclassoronestruct pyxvtabstruct0pywrapfstmutablefst pyxvselfpyxbase.pyxvtabpyxbase.weighttypestruct pyxobj0pywrapfstfst pyxvself 0 pyxvweight if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^  pyxvwc  pyxt0$^$^   pywrapfst.pyx0000$^      cdef fst.weightclass wc  getweightclassoroneself.weighttype$^                                                        weight$^      if not self.mfst.get.setfinalstate wc              $^        raise fstoperrorincompatible or invalid weight$^      self.checkmutatingimethod$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s mfst$^    pyxerr0 0000 pyxl0error$^  $^  pyxt0  pyxvselfmfst.getsetfinalpyxvstate pyxvwc  0  0$^  if unlikelypyxt0 $^$^     pywrapfst.pyx0000$^                                                        weight$^      if not self.mfst.get.setfinalstate wc$^        raise fstoperrorincompatible or invalid weight              $^      self.checkmutatingimethod$^  $^ $^    pyxt0  pyxgetmoduleglobalnamepyxnsfstoperror if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  pyxpyobjectcallpyxt0 pyxtuple00 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxraisepyxt0 0 0 0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxerr0 0000 pyxl0error$^$^     pywrapfst.pyx0000$^      cdef fst.weightclass wc  getweightclassoroneself.weighttype$^                                                        weight$^      if not self.mfst.get.setfinalstate wc              $^        raise fstoperrorincompatible or invalid weight$^      self.checkmutatingimethod$^ $^  $^$^   pywrapfst.pyx0000$^      if not self.mfst.get.setfinalstate wc$^        raise fstoperrorincompatible or invalid weight$^      self.checkmutatingimethod              $^  $^    def setfinalself int00 state weightnone$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s checkmutatingimethod$^    pyxerr0 0000 pyxl0error$^  $^  struct pyxvtabstruct0pywrapfstmutablefst pyxvselfpyxbase.pyxvtabcheckmutatingimethodpyxvself if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^      return self$^  $^    cdef void setfinalself int00 state weightnone except               $^      if not self.mfst.get.validstateidstate$^        raise fstindexerrorstate index out of range$^ $^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.mutablefst.setfinal pyxclineno pyxlineno pyxfilename$^  pyxl0$^  pyxrefnannyfinishcontext$^$^$^ pywrapfst.pyx0000$^      self.checkmutatingimethod$^  $^    def setfinalself int00 state weightnone              $^      $^      setfinalself state weight$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00mutablefst00setfinalpyobject pyxvself pyobject pyxargs pyobject pyxkwds proto$^static char pyxdoc0pywrapfst00mutablefst00setfinal  n    setfinalself state weightnn    sets the final weight for a state.nn    argsn      state the integer index of a state.n      weight a weight or weight string indicating the desired final weight ifn          omitted it is set to semiring one.nn    returnsn      self.nn    raisesn      fstindexerror state index out of range.n      fstoperror incompatible or invalid weight.nn    see also setstart.n    $^static pyobject pyxpw0pywrapfst00mutablefst00setfinalpyobject pyxvself pyobject pyxargs pyobject pyxkwds $^  pyxt00basictypesint00 pyxvstate$^  pyobject pyxvweight  0$^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextsetfinal wrapper 0$^  $^    static pyobject pyxpyargnames  pyxnsstatepyxnsweight0$^    pyobject values0  00$^    values0  pyobject pynone$^    if unlikelypyxkwds $^      pyssizet kwargs$^      const pyssizet posargs  pytuplegetsizepyxargs$^      switch posargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 break$^        default goto pyxl0argtupleerror$^      $^      kwargs  pydictsizepyxkwds$^      switch posargs $^        case  0$^        if likelyvalues0  pyxpydictgetitemstrpyxkwds pyxnsstate  0 kwargs$^        else goto pyxl0argtupleerror$^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnsweight$^          if value  values0  value kwargs $^        $^      $^      if unlikelykwargs  0 $^        if unlikelypyxparseoptionalkeywordspyxkwds pyxpyargnames 0 values posargs setfinal  0 pyxerr0 0000 pyxl0error$^      $^     else $^      switch pytuplegetsizepyxargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        break$^        default goto pyxl0argtupleerror$^      $^    $^    pyxvstate  pyxpyintasint00tvalues0 if unlikelypyxvstate  int00t0  pyerroccurred pyxerr0 0000 pyxl0error$^    pyxvweight  values0$^  $^  goto pyxl0argumentunpackingdone$^  pyxl0argtupleerror$^  pyxraiseargtupleinvalidsetfinal 0 0 0 pytuplegetsizepyxargs pyxerr0 0000 pyxl0error$^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablefst.setfinal pyxclineno pyxlineno pyxfilename$^  pyxrefnannyfinishcontext$^  return null$^  pyxl0argumentunpackingdone$^  pyxr  pyxpf0pywrapfst00mutablefst00setfinalstruct pyxobj0pywrapfstmutablefst pyxvself pyxvstate pyxvweight$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00mutablefst00setfinalstruct pyxobj0pywrapfstmutablefst pyxvself pyxt00basictypesint00 pyxvstate pyobject pyxvweight $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  struct pyxoptargs0pywrapfst00mutablefstsetfinal pyxt0$^  pyxrefnannysetupcontextsetfinal 0$^$^   pywrapfst.pyx0000$^      see also setstart.$^      $^      self.setfinalstate weight              $^      return self$^  $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s setfinal$^    pyxerr0 0000 pyxl0error$^  $^  pyxt0.pyxn  0$^  pyxt0.weight  pyxvweight$^  struct pyxvtabstruct0pywrapfstmutablefst pyxvselfpyxbase.pyxvtabsetfinalpyxvself pyxvstate pyxt0 if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^      $^      self.setfinalstate weight$^      return self              $^  $^    cdef void setinputsymbolsself symboltable syms except $^ $^  pyxxdecrefpyxr$^  pyxincrefpyobject pyxvself$^  pyxr  pyobject pyxvself$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      self.checkmutatingimethod$^  $^    def setfinalself int00 state weightnone              $^      $^      setfinalself state weight$^ $^$^   function exit code $^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablefst.setfinal pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return self$^  $^    cdef void setinputsymbolsself symboltable syms except               $^      if syms is none$^        self.mfst.get.setinputsymbolsnull$^ $^$^static void pyxf0pywrapfst00mutablefstsetinputsymbolsstruct pyxobj0pywrapfstmutablefst pyxvself struct pyxobj0pywrapfstsymboltable pyxvsyms $^  pyxrefnannydeclarations$^  int pyxt0$^  int pyxt0$^  pyxrefnannysetupcontextsetinputsymbols 0$^$^   pywrapfst.pyx0000$^  $^    cdef void setinputsymbolsself symboltable syms except $^      if syms is none              $^        self.mfst.get.setinputsymbolsnull$^        return$^ $^  pyxt0  pyobject pyxvsyms  pynone$^  pyxt0  pyxt0  0$^  if pyxt0 $^$^     pywrapfst.pyx0000$^    cdef void setinputsymbolsself symboltable syms except $^      if syms is none$^        self.mfst.get.setinputsymbolsnull              $^        return$^      self.mfst.get.setinputsymbolssyms.table$^ $^    if unlikelypyobject pyxvself  pynone $^      pyerrformatpyexcattributeerror nonetype object has no attribute .00s mfst$^      pyxerr0 0000 pyxl0error$^    $^    pyxvselfmfst.getsetinputsymbolsnull$^$^     pywrapfst.pyx0000$^      if syms is none$^        self.mfst.get.setinputsymbolsnull$^        return              $^      self.mfst.get.setinputsymbolssyms.table$^      self.checkmutatingimethod$^ $^    goto pyxl0$^$^     pywrapfst.pyx0000$^  $^    cdef void setinputsymbolsself symboltable syms except $^      if syms is none              $^        self.mfst.get.setinputsymbolsnull$^        return$^ $^  $^$^   pywrapfst.pyx0000$^        self.mfst.get.setinputsymbolsnull$^        return$^      self.mfst.get.setinputsymbolssyms.table              $^      self.checkmutatingimethod$^  $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s mfst$^    pyxerr0 0000 pyxl0error$^  $^  if unlikelypyobject pyxvsyms  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s table$^    pyxerr0 0000 pyxl0error$^  $^  pyxvselfmfst.getsetinputsymbolspyxvsymstable$^$^   pywrapfst.pyx0000$^        return$^      self.mfst.get.setinputsymbolssyms.table$^      self.checkmutatingimethod              $^  $^    def setinputsymbolsself symboltable syms$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s checkmutatingimethod$^    pyxerr0 0000 pyxl0error$^  $^  struct pyxvtabstruct0pywrapfstmutablefst pyxvselfpyxbase.pyxvtabcheckmutatingimethodpyxvself if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^      return self$^  $^    cdef void setinputsymbolsself symboltable syms except               $^      if syms is none$^        self.mfst.get.setinputsymbolsnull$^ $^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablefst.setinputsymbols pyxclineno pyxlineno pyxfilename$^  pyxl0$^  pyxrefnannyfinishcontext$^$^$^ pywrapfst.pyx0000$^      self.checkmutatingimethod$^  $^    def setinputsymbolsself symboltable syms              $^      $^      setinputsymbolsself syms$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00mutablefst00setinputsymbolspyobject pyxvself pyobject pyxvsyms proto$^static char pyxdoc0pywrapfst00mutablefst00setinputsymbols  n    setinputsymbolsself symsnn    sets the input symbol table.nn    passing none as a value will delete the input symbol table.nn    argsn      syms a symboltable.nn    returnsn      self.nn    see also setoutputsymbols.n    $^static pyobject pyxpw0pywrapfst00mutablefst00setinputsymbolspyobject pyxvself pyobject pyxvsyms $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextsetinputsymbols wrapper 0$^  if unlikelypyxargtypetestpyobject pyxvsyms pyxptype0pywrapfstsymboltable 0 syms 0 pyxerr0 0000 pyxl0error$^  pyxr  pyxpf0pywrapfst00mutablefst00setinputsymbolsstruct pyxobj0pywrapfstmutablefst pyxvself struct pyxobj0pywrapfstsymboltable pyxvsyms$^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxr  null$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00mutablefst00setinputsymbolsstruct pyxobj0pywrapfstmutablefst pyxvself struct pyxobj0pywrapfstsymboltable pyxvsyms $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextsetinputsymbols 0$^$^   pywrapfst.pyx0000$^      see also setoutputsymbols.$^      $^      self.setinputsymbolssyms              $^      return self$^  $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s setinputsymbols$^    pyxerr0 0000 pyxl0error$^  $^  struct pyxvtabstruct0pywrapfstmutablefst pyxvselfpyxbase.pyxvtabsetinputsymbolspyxvself pyxvsyms if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^      $^      self.setinputsymbolssyms$^      return self              $^  $^    cdef void setoutputsymbolsself symboltable syms except $^ $^  pyxxdecrefpyxr$^  pyxincrefpyobject pyxvself$^  pyxr  pyobject pyxvself$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      self.checkmutatingimethod$^  $^    def setinputsymbolsself symboltable syms              $^      $^      setinputsymbolsself syms$^ $^$^   function exit code $^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablefst.setinputsymbols pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return self$^  $^    cdef void setoutputsymbolsself symboltable syms except               $^      if syms is none$^        self.mfst.get.setoutputsymbolsnull$^ $^$^static void pyxf0pywrapfst00mutablefstsetoutputsymbolsstruct pyxobj0pywrapfstmutablefst pyxvself struct pyxobj0pywrapfstsymboltable pyxvsyms $^  pyxrefnannydeclarations$^  int pyxt0$^  int pyxt0$^  pyxrefnannysetupcontextsetoutputsymbols 0$^$^   pywrapfst.pyx0000$^  $^    cdef void setoutputsymbolsself symboltable syms except $^      if syms is none              $^        self.mfst.get.setoutputsymbolsnull$^        return$^ $^  pyxt0  pyobject pyxvsyms  pynone$^  pyxt0  pyxt0  0$^  if pyxt0 $^$^     pywrapfst.pyx0000$^    cdef void setoutputsymbolsself symboltable syms except $^      if syms is none$^        self.mfst.get.setoutputsymbolsnull              $^        return$^      self.mfst.get.setoutputsymbolssyms.table$^ $^    if unlikelypyobject pyxvself  pynone $^      pyerrformatpyexcattributeerror nonetype object has no attribute .00s mfst$^      pyxerr0 0000 pyxl0error$^    $^    pyxvselfmfst.getsetoutputsymbolsnull$^$^     pywrapfst.pyx0000$^      if syms is none$^        self.mfst.get.setoutputsymbolsnull$^        return              $^      self.mfst.get.setoutputsymbolssyms.table$^      self.checkmutatingimethod$^ $^    goto pyxl0$^$^     pywrapfst.pyx0000$^  $^    cdef void setoutputsymbolsself symboltable syms except $^      if syms is none              $^        self.mfst.get.setoutputsymbolsnull$^        return$^ $^  $^$^   pywrapfst.pyx0000$^        self.mfst.get.setoutputsymbolsnull$^        return$^      self.mfst.get.setoutputsymbolssyms.table              $^      self.checkmutatingimethod$^  $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s mfst$^    pyxerr0 0000 pyxl0error$^  $^  if unlikelypyobject pyxvsyms  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s table$^    pyxerr0 0000 pyxl0error$^  $^  pyxvselfmfst.getsetoutputsymbolspyxvsymstable$^$^   pywrapfst.pyx0000$^        return$^      self.mfst.get.setoutputsymbolssyms.table$^      self.checkmutatingimethod              $^  $^    def setoutputsymbolsself symboltable syms$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s checkmutatingimethod$^    pyxerr0 0000 pyxl0error$^  $^  struct pyxvtabstruct0pywrapfstmutablefst pyxvselfpyxbase.pyxvtabcheckmutatingimethodpyxvself if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^      return self$^  $^    cdef void setoutputsymbolsself symboltable syms except               $^      if syms is none$^        self.mfst.get.setoutputsymbolsnull$^ $^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablefst.setoutputsymbols pyxclineno pyxlineno pyxfilename$^  pyxl0$^  pyxrefnannyfinishcontext$^$^$^ pywrapfst.pyx0000$^      self.checkmutatingimethod$^  $^    def setoutputsymbolsself symboltable syms              $^      $^      setoutputsymbolsself syms$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00mutablefst00setoutputsymbolspyobject pyxvself pyobject pyxvsyms proto$^static char pyxdoc0pywrapfst00mutablefst00setoutputsymbols  n    setoutputsymbolsself symsnn    sets the output symbol table.nn    passing none as a value will delete the output symbol table.nn    argsn      syms a symboltable.nn    returnsn      self.nn    see also setinputsymbols.n    $^static pyobject pyxpw0pywrapfst00mutablefst00setoutputsymbolspyobject pyxvself pyobject pyxvsyms $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextsetoutputsymbols wrapper 0$^  if unlikelypyxargtypetestpyobject pyxvsyms pyxptype0pywrapfstsymboltable 0 syms 0 pyxerr0 0000 pyxl0error$^  pyxr  pyxpf0pywrapfst00mutablefst00setoutputsymbolsstruct pyxobj0pywrapfstmutablefst pyxvself struct pyxobj0pywrapfstsymboltable pyxvsyms$^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxr  null$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00mutablefst00setoutputsymbolsstruct pyxobj0pywrapfstmutablefst pyxvself struct pyxobj0pywrapfstsymboltable pyxvsyms $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextsetoutputsymbols 0$^$^   pywrapfst.pyx0000$^      see also setinputsymbols.$^      $^      self.setoutputsymbolssyms              $^      return self$^  $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s setoutputsymbols$^    pyxerr0 0000 pyxl0error$^  $^  struct pyxvtabstruct0pywrapfstmutablefst pyxvselfpyxbase.pyxvtabsetoutputsymbolspyxvself pyxvsyms if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^      $^      self.setoutputsymbolssyms$^      return self              $^  $^    cdef void setpropertiesself uint00 props uint00 mask$^ $^  pyxxdecrefpyxr$^  pyxincrefpyobject pyxvself$^  pyxr  pyobject pyxvself$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      self.checkmutatingimethod$^  $^    def setoutputsymbolsself symboltable syms              $^      $^      setoutputsymbolsself syms$^ $^$^   function exit code $^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablefst.setoutputsymbols pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return self$^  $^    cdef void setpropertiesself uint00 props uint00 mask              $^      self.mfst.get.setpropertiesprops mask$^  $^ $^$^static void pyxf0pywrapfst00mutablefstsetpropertiesstruct pyxobj0pywrapfstmutablefst pyxvself pyxt00basictypesuint00 pyxvprops pyxt00basictypesuint00 pyxvmask $^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextsetproperties 0$^$^   pywrapfst.pyx0000$^  $^    cdef void setpropertiesself uint00 props uint00 mask$^      self.mfst.get.setpropertiesprops mask              $^  $^    def setpropertiesself uint00 props uint00 mask$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s mfst$^    pyxerr0 0000 pyxl0error$^  $^  pyxvselfmfst.getsetpropertiespyxvprops pyxvmask$^$^   pywrapfst.pyx0000$^      return self$^  $^    cdef void setpropertiesself uint00 props uint00 mask              $^      self.mfst.get.setpropertiesprops mask$^  $^ $^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxwriteunraisablepywrapfst.mutablefst.setproperties pyxclineno pyxlineno pyxfilename 0 0$^  pyxl0$^  pyxrefnannyfinishcontext$^$^$^ pywrapfst.pyx0000$^      self.mfst.get.setpropertiesprops mask$^  $^    def setpropertiesself uint00 props uint00 mask              $^      $^      setpropertiesself props mask$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00mutablefst00setpropertiespyobject pyxvself pyobject pyxargs pyobject pyxkwds proto$^static char pyxdoc0pywrapfst00mutablefst00setproperties  n    setpropertiesself props masknn    sets the properties bits.nn    argsn      props the properties to be set.n      mask a mask to be applied to the props argument before setting then          fsts properties.nn    returnsn      self.n    $^static pyobject pyxpw0pywrapfst00mutablefst00setpropertiespyobject pyxvself pyobject pyxargs pyobject pyxkwds $^  pyxt00basictypesuint00 pyxvprops$^  pyxt00basictypesuint00 pyxvmask$^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextsetproperties wrapper 0$^  $^    static pyobject pyxpyargnames  pyxnspropspyxnsmask0$^    pyobject values0  00$^    if unlikelypyxkwds $^      pyssizet kwargs$^      const pyssizet posargs  pytuplegetsizepyxargs$^      switch posargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 break$^        default goto pyxl0argtupleerror$^      $^      kwargs  pydictsizepyxkwds$^      switch posargs $^        case  0$^        if likelyvalues0  pyxpydictgetitemstrpyxkwds pyxnsprops  0 kwargs$^        else goto pyxl0argtupleerror$^        cythonfallthrough$^        case  0$^        if likelyvalues0  pyxpydictgetitemstrpyxkwds pyxnsmask  0 kwargs$^        else $^          pyxraiseargtupleinvalidsetproperties 0 0 0 0 pyxerr0 0000 pyxl0error$^        $^      $^      if unlikelykwargs  0 $^        if unlikelypyxparseoptionalkeywordspyxkwds pyxpyargnames 0 values posargs setproperties  0 pyxerr0 0000 pyxl0error$^      $^     else if pytuplegetsizepyxargs  0 $^      goto pyxl0argtupleerror$^     else $^      values0  pytuplegetitempyxargs 0$^      values0  pytuplegetitempyxargs 0$^    $^    pyxvprops  pyxpyintasuint00tvalues0 if unlikelypyxvprops  uint00t0  pyerroccurred pyxerr0 0000 pyxl0error$^    pyxvmask  pyxpyintasuint00tvalues0 if unlikelypyxvmask  uint00t0  pyerroccurred pyxerr0 0000 pyxl0error$^  $^  goto pyxl0argumentunpackingdone$^  pyxl0argtupleerror$^  pyxraiseargtupleinvalidsetproperties 0 0 0 pytuplegetsizepyxargs pyxerr0 0000 pyxl0error$^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablefst.setproperties pyxclineno pyxlineno pyxfilename$^  pyxrefnannyfinishcontext$^  return null$^  pyxl0argumentunpackingdone$^  pyxr  pyxpf0pywrapfst00mutablefst00setpropertiesstruct pyxobj0pywrapfstmutablefst pyxvself pyxvprops pyxvmask$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00mutablefst00setpropertiesstruct pyxobj0pywrapfstmutablefst pyxvself pyxt00basictypesuint00 pyxvprops pyxt00basictypesuint00 pyxvmask $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextsetproperties 0$^$^   pywrapfst.pyx0000$^        self.$^      $^      self.setpropertiesprops mask              $^      return self$^  $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s setproperties$^    pyxerr0 0000 pyxl0error$^  $^  struct pyxvtabstruct0pywrapfstmutablefst pyxvselfpyxbase.pyxvtabsetpropertiespyxvself pyxvprops pyxvmask$^$^   pywrapfst.pyx0000$^      $^      self.setpropertiesprops mask$^      return self              $^  $^    cdef void setstartself int00 state except $^ $^  pyxxdecrefpyxr$^  pyxincrefpyobject pyxvself$^  pyxr  pyobject pyxvself$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      self.mfst.get.setpropertiesprops mask$^  $^    def setpropertiesself uint00 props uint00 mask              $^      $^      setpropertiesself props mask$^ $^$^   function exit code $^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablefst.setproperties pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return self$^  $^    cdef void setstartself int00 state except               $^      if not self.mfst.get.setstartstate$^        raise fstindexerrorstate index out of range$^ $^$^static void pyxf0pywrapfst00mutablefstsetstartstruct pyxobj0pywrapfstmutablefst pyxvself pyxt00basictypesint00 pyxvstate $^  pyxrefnannydeclarations$^  int pyxt0$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextsetstart 0$^$^   pywrapfst.pyx0000$^  $^    cdef void setstartself int00 state except $^      if not self.mfst.get.setstartstate              $^        raise fstindexerrorstate index out of range$^      self.checkmutatingimethod$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s mfst$^    pyxerr0 0000 pyxl0error$^  $^  pyxt0  pyxvselfmfst.getsetstartpyxvstate  0  0$^  if unlikelypyxt0 $^$^     pywrapfst.pyx0000$^    cdef void setstartself int00 state except $^      if not self.mfst.get.setstartstate$^        raise fstindexerrorstate index out of range              $^      self.checkmutatingimethod$^  $^ $^    pyxt0  pyxgetmoduleglobalnamepyxnsfstindexerror if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  pyxpyobjectcallpyxt0 pyxtuple00 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxraisepyxt0 0 0 0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxerr0 0000 pyxl0error$^$^     pywrapfst.pyx0000$^  $^    cdef void setstartself int00 state except $^      if not self.mfst.get.setstartstate              $^        raise fstindexerrorstate index out of range$^      self.checkmutatingimethod$^ $^  $^$^   pywrapfst.pyx0000$^      if not self.mfst.get.setstartstate$^        raise fstindexerrorstate index out of range$^      self.checkmutatingimethod              $^  $^    def setstartself int00 state$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s checkmutatingimethod$^    pyxerr0 0000 pyxl0error$^  $^  struct pyxvtabstruct0pywrapfstmutablefst pyxvselfpyxbase.pyxvtabcheckmutatingimethodpyxvself if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^      return self$^  $^    cdef void setstartself int00 state except               $^      if not self.mfst.get.setstartstate$^        raise fstindexerrorstate index out of range$^ $^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.mutablefst.setstart pyxclineno pyxlineno pyxfilename$^  pyxl0$^  pyxrefnannyfinishcontext$^$^$^ pywrapfst.pyx0000$^      self.checkmutatingimethod$^  $^    def setstartself int00 state              $^      $^      setstartself state$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00mutablefst00setstartpyobject pyxvself pyobject pyxargstate proto$^static char pyxdoc0pywrapfst00mutablefst00setstart  n    setstartself statenn    sets a state to be the initial state state.nn    argsn      state the integer index of a state.nn    returnsn      self.nn    raisesn      fstindexerror state index out of range.nn    see also setfinal.n    $^static pyobject pyxpw0pywrapfst00mutablefst00setstartpyobject pyxvself pyobject pyxargstate $^  pyxt00basictypesint00 pyxvstate$^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextsetstart wrapper 0$^  assertpyxargstate $^    pyxvstate  pyxpyintasint00tpyxargstate if unlikelypyxvstate  int00t0  pyerroccurred pyxerr0 0000 pyxl0error$^  $^  goto pyxl0argumentunpackingdone$^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablefst.setstart pyxclineno pyxlineno pyxfilename$^  pyxrefnannyfinishcontext$^  return null$^  pyxl0argumentunpackingdone$^  pyxr  pyxpf0pywrapfst00mutablefst00setstartstruct pyxobj0pywrapfstmutablefst pyxvself pyxt00basictypesint00pyxvstate$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00mutablefst00setstartstruct pyxobj0pywrapfstmutablefst pyxvself pyxt00basictypesint00 pyxvstate $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextsetstart 0$^$^   pywrapfst.pyx0000$^      see also setfinal.$^      $^      self.setstartstate              $^      return self$^  $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s setstart$^    pyxerr0 0000 pyxl0error$^  $^  struct pyxvtabstruct0pywrapfstmutablefst pyxvselfpyxbase.pyxvtabsetstartpyxvself pyxvstate if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^      $^      self.setstartstate$^      return self              $^  $^    cdef void topsortself except $^ $^  pyxxdecrefpyxr$^  pyxincrefpyobject pyxvself$^  pyxr  pyobject pyxvself$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      self.checkmutatingimethod$^  $^    def setstartself int00 state              $^      $^      setstartself state$^ $^$^   function exit code $^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablefst.setstart pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return self$^  $^    cdef void topsortself except               $^       topsort returns false if the fst is cyclic and thus cant be topsorted.$^      if not fst.topsortself.mfst.get$^ $^$^static void pyxf0pywrapfst00mutablefsttopsortstruct pyxobj0pywrapfstmutablefst pyxvself $^  pyxrefnannydeclarations$^  int pyxt0$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxrefnannysetupcontexttopsort 0$^$^   pywrapfst.pyx0000$^    cdef void topsortself except $^       topsort returns false if the fst is cyclic and thus cant be topsorted.$^      if not fst.topsortself.mfst.get              $^        logging.warningcannot topsort cyclic fst.$^      self.checkmutatingimethod$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s mfst$^    pyxerr0 0000 pyxl0error$^  $^  pyxt0  fstscripttopsortpyxvselfmfst.get  0  0$^  if pyxt0 $^$^     pywrapfst.pyx0000$^       topsort returns false if the fst is cyclic and thus cant be topsorted.$^      if not fst.topsortself.mfst.get$^        logging.warningcannot topsort cyclic fst.              $^      self.checkmutatingimethod$^  $^ $^    pyxt0  pyxgetmoduleglobalnamepyxnslogging if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  pyxpyobjectgetattrstrpyxt0 pyxnswarning if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxt0  pyxpyobjectcallpyxt0 pyxtuple00 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxdecrefpyxt0 pyxt0  0$^$^     pywrapfst.pyx0000$^    cdef void topsortself except $^       topsort returns false if the fst is cyclic and thus cant be topsorted.$^      if not fst.topsortself.mfst.get              $^        logging.warningcannot topsort cyclic fst.$^      self.checkmutatingimethod$^ $^  $^$^   pywrapfst.pyx0000$^      if not fst.topsortself.mfst.get$^        logging.warningcannot topsort cyclic fst.$^      self.checkmutatingimethod              $^  $^    def topsortself$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s checkmutatingimethod$^    pyxerr0 0000 pyxl0error$^  $^  struct pyxvtabstruct0pywrapfstmutablefst pyxvselfpyxbase.pyxvtabcheckmutatingimethodpyxvself if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^      return self$^  $^    cdef void topsortself except               $^       topsort returns false if the fst is cyclic and thus cant be topsorted.$^      if not fst.topsortself.mfst.get$^ $^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.mutablefst.topsort pyxclineno pyxlineno pyxfilename$^  pyxl0$^  pyxrefnannyfinishcontext$^$^$^ pywrapfst.pyx0000$^      self.checkmutatingimethod$^  $^    def topsortself              $^      $^      topsortself$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00mutablefst00topsortpyobject pyxvself cythonunused pyobject unused proto$^static char pyxdoc0pywrapfst00mutablefst00topsort  n    topsortselfnn    sorts transitions by state ids.nn    this operation destructively topologically sorts the fst if it is acyclicn    otherwise it remains unchanged. once sorted all transitions are from lowern    state ids to higher state idsnn    returnsn       self.nn    see also arcsort.n    $^static pyobject pyxpw0pywrapfst00mutablefst00topsortpyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontexttopsort wrapper 0$^  pyxr  pyxpf0pywrapfst00mutablefst00topsortstruct pyxobj0pywrapfstmutablefst pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00mutablefst00topsortstruct pyxobj0pywrapfstmutablefst pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontexttopsort 0$^$^   pywrapfst.pyx0000$^      see also arcsort.$^      $^      self.topsort              $^      return self$^  $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s topsort$^    pyxerr0 0000 pyxl0error$^  $^  struct pyxvtabstruct0pywrapfstmutablefst pyxvselfpyxbase.pyxvtabtopsortpyxvself if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^      $^      self.topsort$^      return self              $^  $^    cdef void unionself fst ifst except $^ $^  pyxxdecrefpyxr$^  pyxincrefpyobject pyxvself$^  pyxr  pyobject pyxvself$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      self.checkmutatingimethod$^  $^    def topsortself              $^      $^      topsortself$^ $^$^   function exit code $^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablefst.topsort pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return self$^  $^    cdef void unionself fst ifst except               $^      fst.unionself.mfst.get derefifst.fst$^      self.checkmutatingimethod$^ $^$^static void pyxf0pywrapfst00mutablefstunionstruct pyxobj0pywrapfstmutablefst pyxvself struct pyxobj0pywrapfstfst pyxvifst $^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextunion 0$^$^   pywrapfst.pyx0000$^  $^    cdef void unionself fst ifst except $^      fst.unionself.mfst.get derefifst.fst              $^      self.checkmutatingimethod$^  $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s mfst$^    pyxerr0 0000 pyxl0error$^  $^  if unlikelypyobject pyxvifst  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s fst$^    pyxerr0 0000 pyxl0error$^  $^  fstscriptunionpyxvselfmfst.get pyxvifstfst$^$^   pywrapfst.pyx0000$^    cdef void unionself fst ifst except $^      fst.unionself.mfst.get derefifst.fst$^      self.checkmutatingimethod              $^  $^    def unionself fst ifst$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s checkmutatingimethod$^    pyxerr0 0000 pyxl0error$^  $^  struct pyxvtabstruct0pywrapfstmutablefst pyxvselfpyxbase.pyxvtabcheckmutatingimethodpyxvself if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^      return self$^  $^    cdef void unionself fst ifst except               $^      fst.unionself.mfst.get derefifst.fst$^      self.checkmutatingimethod$^ $^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablefst.union pyxclineno pyxlineno pyxfilename$^  pyxl0$^  pyxrefnannyfinishcontext$^$^$^ pywrapfst.pyx0000$^      self.checkmutatingimethod$^  $^    def unionself fst ifst              $^      $^      unionself ifst$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00mutablefst00unionpyobject pyxvself pyobject pyxvifst proto$^static char pyxdoc0pywrapfst00mutablefst00union  n    unionself ifstnn    computes the union sum of two fsts.nn    this operation computes the union sum of two fsts. if a transduces stringn    x to y with weight a and b transduces string w to v with weight b thenn    their union transduces x to y with weight a and w to v with weight b.nn    argsn      ifst the second input fst.nn    returnsn      self.n    $^static pyobject pyxpw0pywrapfst00mutablefst00unionpyobject pyxvself pyobject pyxvifst $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextunion wrapper 0$^  if unlikelypyxargtypetestpyobject pyxvifst pyxptype0pywrapfstfst 0 ifst 0 pyxerr0 0000 pyxl0error$^  pyxr  pyxpf0pywrapfst00mutablefst00unionstruct pyxobj0pywrapfstmutablefst pyxvself struct pyxobj0pywrapfstfst pyxvifst$^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxr  null$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00mutablefst00unionstruct pyxobj0pywrapfstmutablefst pyxvself struct pyxobj0pywrapfstfst pyxvifst $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextunion 0$^$^   pywrapfst.pyx0000$^        self.$^      $^      self.unionifst              $^      return self$^  $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s union$^    pyxerr0 0000 pyxl0error$^  $^  struct pyxvtabstruct0pywrapfstmutablefst pyxvselfpyxbase.pyxvtabunionpyxvself pyxvifst if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^      $^      self.unionifst$^      return self              $^  $^  $^ $^  pyxxdecrefpyxr$^  pyxincrefpyobject pyxvself$^  pyxr  pyobject pyxvself$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      self.checkmutatingimethod$^  $^    def unionself fst ifst              $^      $^      unionself ifst$^ $^$^   function exit code $^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablefst.union pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^  $^  $^  cdef fst initfstfstclassptr tfst              $^    if tfst.propertiesfst.kerror true$^      raise fstoperroroperation failed$^ $^$^static struct pyxobj0pywrapfstfst pyxf0pywrapfstinitfstpyxt0pywrapfstfstclassptr pyxvtfst $^  struct pyxobj0pywrapfstfst pyxvofst  0$^  struct pyxobj0pywrapfstfst pyxr  null$^  pyxrefnannydeclarations$^  int pyxt0$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextinitfst 0$^$^   pywrapfst.pyx0000$^  $^  cdef fst initfstfstclassptr tfst$^    if tfst.propertiesfst.kerror true              $^      raise fstoperroroperation failed$^    cdef fst ofst  fst.newfst$^ $^  pyxt0  pyxvtfstpropertiesfstkerror 0  0$^  if unlikelypyxt0 $^$^     pywrapfst.pyx0000$^  cdef fst initfstfstclassptr tfst$^    if tfst.propertiesfst.kerror true$^      raise fstoperroroperation failed              $^    cdef fst ofst  fst.newfst$^    ofst.fst.resettfst$^ $^    pyxt0  pyxgetmoduleglobalnamepyxnsfstoperror if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  pyxpyobjectcallpyxt0 pyxtuple00 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxraisepyxt0 0 0 0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxerr0 0000 pyxl0error$^$^     pywrapfst.pyx0000$^  $^  cdef fst initfstfstclassptr tfst$^    if tfst.propertiesfst.kerror true              $^      raise fstoperroroperation failed$^    cdef fst ofst  fst.newfst$^ $^  $^$^   pywrapfst.pyx0000$^    if tfst.propertiesfst.kerror true$^      raise fstoperroroperation failed$^    cdef fst ofst  fst.newfst              $^    ofst.fst.resettfst$^    return ofst$^ $^  pyxt0  pyobject pyxtpnew0pywrapfstfstpytypeobject pyxptype0pywrapfstfst pyxemptytuple null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyobject pyxt0$^  pyxvofst  struct pyxobj0pywrapfstfst pyxt0$^  pyxt0  0$^$^   pywrapfst.pyx0000$^      raise fstoperroroperation failed$^    cdef fst ofst  fst.newfst$^    ofst.fst.resettfst              $^    return ofst$^  $^ $^  if unlikelypyobject pyxvofst  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s fst$^    pyxerr0 0000 pyxl0error$^  $^  pyxvofstfst.resetpyxvtfst$^$^   pywrapfst.pyx0000$^    cdef fst ofst  fst.newfst$^    ofst.fst.resettfst$^    return ofst              $^  $^  $^ $^  pyxxdecrefpyobject pyxr$^  pyxincrefpyobject pyxvofst$^  pyxr  pyxvofst$^  goto pyxl0$^$^   pywrapfst.pyx0000$^  $^  $^  cdef fst initfstfstclassptr tfst              $^    if tfst.propertiesfst.kerror true$^      raise fstoperroroperation failed$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.initfst pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxl0$^  pyxxdecrefpyobject pyxvofst$^  pyxxgiverefpyobject pyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^  $^  $^  cdef mutablefst initmutablefstmutablefstclassptr tfst              $^    if tfst.propertiesfst.kerror true$^      raise fstoperroroperation failed$^ $^$^static struct pyxobj0pywrapfstmutablefst pyxf0pywrapfstinitmutablefstpyxt0pywrapfstmutablefstclassptr pyxvtfst $^  struct pyxobj0pywrapfstmutablefst pyxvofst  0$^  struct pyxobj0pywrapfstmutablefst pyxr  null$^  pyxrefnannydeclarations$^  int pyxt0$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextinitmutablefst 0$^$^   pywrapfst.pyx0000$^  $^  cdef mutablefst initmutablefstmutablefstclassptr tfst$^    if tfst.propertiesfst.kerror true              $^      raise fstoperroroperation failed$^    cdef mutablefst ofst  mutablefst.newmutablefst$^ $^  pyxt0  pyxvtfstpropertiesfstkerror 0  0$^  if unlikelypyxt0 $^$^     pywrapfst.pyx0000$^  cdef mutablefst initmutablefstmutablefstclassptr tfst$^    if tfst.propertiesfst.kerror true$^      raise fstoperroroperation failed              $^    cdef mutablefst ofst  mutablefst.newmutablefst$^    ofst.fst.resettfst$^ $^    pyxt0  pyxgetmoduleglobalnamepyxnsfstoperror if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  pyxpyobjectcallpyxt0 pyxtuple00 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxraisepyxt0 0 0 0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxerr0 0000 pyxl0error$^$^     pywrapfst.pyx0000$^  $^  cdef mutablefst initmutablefstmutablefstclassptr tfst$^    if tfst.propertiesfst.kerror true              $^      raise fstoperroroperation failed$^    cdef mutablefst ofst  mutablefst.newmutablefst$^ $^  $^$^   pywrapfst.pyx0000$^    if tfst.propertiesfst.kerror true$^      raise fstoperroroperation failed$^    cdef mutablefst ofst  mutablefst.newmutablefst              $^    ofst.fst.resettfst$^     makes a copy of it as the derived type cool.$^ $^  pyxt0  pyobject pyxtpnew0pywrapfstmutablefstpytypeobject pyxptype0pywrapfstmutablefst pyxemptytuple null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyobject pyxt0$^  pyxvofst  struct pyxobj0pywrapfstmutablefst pyxt0$^  pyxt0  0$^$^   pywrapfst.pyx0000$^      raise fstoperroroperation failed$^    cdef mutablefst ofst  mutablefst.newmutablefst$^    ofst.fst.resettfst              $^     makes a copy of it as the derived type cool.$^    ofst.mfst  staticpointercastfst.mutablefstclass fst.fstclassofst.fst$^ $^  if unlikelypyobject pyxvofst  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s fst$^    pyxerr0 0000 pyxl0error$^  $^  pyxvofstpyxbase.fst.resetpyxvtfst$^$^   pywrapfst.pyx0000$^    ofst.fst.resettfst$^     makes a copy of it as the derived type cool.$^    ofst.mfst  staticpointercastfst.mutablefstclass fst.fstclassofst.fst              $^    return ofst$^  $^ $^  if unlikelypyobject pyxvofst  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s fst$^    pyxerr0 0000 pyxl0error$^  $^  if unlikelypyobject pyxvofst  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s mfst$^    pyxerr0 0000 pyxl0error$^  $^  pyxvofstmfst  stdstaticpointercastfstscriptmutablefstclassfstscriptfstclasspyxvofstpyxbase.fst$^$^   pywrapfst.pyx0000$^     makes a copy of it as the derived type cool.$^    ofst.mfst  staticpointercastfst.mutablefstclass fst.fstclassofst.fst$^    return ofst              $^  $^  $^ $^  pyxxdecrefpyobject pyxr$^  pyxincrefpyobject pyxvofst$^  pyxr  pyxvofst$^  goto pyxl0$^$^   pywrapfst.pyx0000$^  $^  $^  cdef mutablefst initmutablefstmutablefstclassptr tfst              $^    if tfst.propertiesfst.kerror true$^      raise fstoperroroperation failed$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.initmutablefst pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxl0$^  pyxxdecrefpyobject pyxvofst$^  pyxxgiverefpyobject pyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^  $^  $^  cdef fst initxfstfstclassptr tfst              $^    if tfst.propertiesfst.kmutable true$^      return initmutablefststaticcastmutablefstclassptrtfst$^ $^$^static struct pyxobj0pywrapfstfst pyxf0pywrapfstinitxfstpyxt0pywrapfstfstclassptr pyxvtfst $^  struct pyxobj0pywrapfstfst pyxr  null$^  pyxrefnannydeclarations$^  int pyxt0$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextinitxfst 0$^$^   pywrapfst.pyx0000$^  $^  cdef fst initxfstfstclassptr tfst$^    if tfst.propertiesfst.kmutable true              $^      return initmutablefststaticcastmutablefstclassptrtfst$^    else$^ $^  pyxt0  pyxvtfstpropertiesfstkmutable 0  0$^  if pyxt0 $^$^     pywrapfst.pyx0000$^  cdef fst initxfstfstclassptr tfst$^    if tfst.propertiesfst.kmutable true$^      return initmutablefststaticcastmutablefstclassptrtfst              $^    else$^      return initfsttfst$^ $^    pyxxdecrefpyobject pyxr$^    pyxt0  pyobject pyxf0pywrapfstinitmutablefststaticcastpyxt0pywrapfstmutablefstclassptrpyxvtfst if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxr  struct pyxobj0pywrapfstfst pyxt0$^    pyxt0  0$^    goto pyxl0$^$^     pywrapfst.pyx0000$^  $^  cdef fst initxfstfstclassptr tfst$^    if tfst.propertiesfst.kmutable true              $^      return initmutablefststaticcastmutablefstclassptrtfst$^    else$^ $^  $^$^   pywrapfst.pyx0000$^      return initmutablefststaticcastmutablefstclassptrtfst$^    else$^      return initfsttfst              $^  $^  $^ $^  else $^    pyxxdecrefpyobject pyxr$^    pyxt0  pyobject pyxf0pywrapfstinitfstpyxvtfst if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxr  struct pyxobj0pywrapfstfst pyxt0$^    pyxt0  0$^    goto pyxl0$^  $^$^   pywrapfst.pyx0000$^  $^  $^  cdef fst initxfstfstclassptr tfst              $^    if tfst.propertiesfst.kmutable true$^      return initmutablefststaticcastmutablefstclassptrtfst$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.initxfst pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxl0$^  pyxxgiverefpyobject pyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^  $^  $^  cdef mutablefst createfstarctypebstandard              $^    cdef uniqueptrfst.vectorfstclass tfst$^    tfst.resetnew fst.vectorfstclasstostringarctype$^ $^$^static struct pyxobj0pywrapfstmutablefst pyxf0pywrapfstcreatefststruct pyxoptargs0pywrapfstcreatefst pyxoptionalargs $^  pyobject pyxvarctype  pyobject pyxnbstandard$^  stduniqueptrfstscriptvectorfstclass  pyxvtfst$^  struct pyxobj0pywrapfstmutablefst pyxr  null$^  pyxrefnannydeclarations$^  stdstring pyxt0$^  int pyxt0$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextcreatefst 0$^  if pyxoptionalargs $^    if pyxoptionalargspyxn  0 $^      pyxvarctype  pyxoptionalargsarctype$^    $^  $^$^   pywrapfst.pyx0000$^  cdef mutablefst createfstarctypebstandard$^    cdef uniqueptrfst.vectorfstclass tfst$^    tfst.resetnew fst.vectorfstclasstostringarctype              $^    if tfst.get  null$^      raise fstoperrorunknown arc type r.formatarctype$^ $^  pyxt0  pyxf0pywrapfsttostringpyxvarctype null if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^  pyxvtfst.resetnew fstscriptvectorfstclasspyxt0$^$^   pywrapfst.pyx0000$^    cdef uniqueptrfst.vectorfstclass tfst$^    tfst.resetnew fst.vectorfstclasstostringarctype$^    if tfst.get  null              $^      raise fstoperrorunknown arc type r.formatarctype$^    return initmutablefsttfst.release$^ $^  pyxt0  pyxvtfst.get  null  0$^  if unlikelypyxt0 $^$^     pywrapfst.pyx0000$^    tfst.resetnew fst.vectorfstclasstostringarctype$^    if tfst.get  null$^      raise fstoperrorunknown arc type r.formatarctype              $^    return initmutablefsttfst.release$^  $^ $^    pyxt0  pyxgetmoduleglobalnamepyxnsfstoperror if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  pyxpyobjectgetattrstrpyxkpsunknownarctyper pyxnsformat if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  null$^    if cythonunpackmethods  likelypymethodcheckpyxt0 $^      pyxt0  pymethodgetselfpyxt0$^      if likelypyxt0 $^        pyobject function  pymethodgetfunctionpyxt0$^        pyxincrefpyxt0$^        pyxincreffunction$^        pyxdecrefsetpyxt0 function$^      $^    $^    if pyxt0 $^      pyxt0  pyxpyobjectcalloneargpyxt0 pyxvarctype if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxgotrefpyxt0$^     else $^      if cythonfastpycall$^      if pyfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxvarctype$^        pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^       else$^      endif$^      if cythonfastpyccall$^      if pyxpyfastcfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxvarctype$^        pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^       else$^      endif$^      $^        pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxgotrefpyxt0$^        pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^        pyxincrefpyxvarctype$^        pyxgiverefpyxvarctype$^        pytuplesetitempyxt0 00 pyxvarctype$^        pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^      $^    $^    pyxdecrefpyxt0 pyxt0  0$^    pyxt0  null$^    if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^      pyxt0  pymethodgetselfpyxt0$^      if likelypyxt0 $^        pyobject function  pymethodgetfunctionpyxt0$^        pyxincrefpyxt0$^        pyxincreffunction$^        pyxdecrefsetpyxt0 function$^      $^    $^    if pyxt0 $^      pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxgotrefpyxt0$^     else $^      if cythonfastpycall$^      if pyfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxt0$^        pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^       else$^      endif$^      if cythonfastpyccall$^      if pyxpyfastcfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxt0$^        pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^       else$^      endif$^      $^        pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxgotrefpyxt0$^        pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^        pyxgiverefpyxt0$^        pytuplesetitempyxt0 00 pyxt0$^        pyxt0  0$^        pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^      $^    $^    pyxdecrefpyxt0 pyxt0  0$^    pyxraisepyxt0 0 0 0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxerr0 0000 pyxl0error$^$^     pywrapfst.pyx0000$^    cdef uniqueptrfst.vectorfstclass tfst$^    tfst.resetnew fst.vectorfstclasstostringarctype$^    if tfst.get  null              $^      raise fstoperrorunknown arc type r.formatarctype$^    return initmutablefsttfst.release$^ $^  $^$^   pywrapfst.pyx0000$^    if tfst.get  null$^      raise fstoperrorunknown arc type r.formatarctype$^    return initmutablefsttfst.release              $^  $^  $^ $^  pyxxdecrefpyobject pyxr$^  pyxt0  pyobject pyxf0pywrapfstinitmutablefstpyxvtfst.release if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  struct pyxobj0pywrapfstmutablefst pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   pywrapfst.pyx0000$^  $^  $^  cdef mutablefst createfstarctypebstandard              $^    cdef uniqueptrfst.vectorfstclass tfst$^    tfst.resetnew fst.vectorfstclasstostringarctype$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.createfst pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxl0$^  pyxxgiverefpyobject pyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^  $^  $^  cpdef fst readfilename              $^    cdef uniqueptrfst.fstclass tfst$^    tfst.resetfst.fstclass.readtostringfilename$^ $^$^static pyobject pyxpw0pywrapfst00readpyobject pyxself pyobject pyxvfilename proto$^static struct pyxobj0pywrapfstfst pyxf0pywrapfstreadpyobject pyxvfilename cythonunused int pyxskipdispatch $^  stduniqueptrfstscriptfstclass  pyxvtfst$^  struct pyxobj0pywrapfstfst pyxr  null$^  pyxrefnannydeclarations$^  stdstring pyxt0$^  int pyxt0$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextread 0$^$^   pywrapfst.pyx0000$^  cpdef fst readfilename$^    cdef uniqueptrfst.fstclass tfst$^    tfst.resetfst.fstclass.readtostringfilename              $^    if tfst.get  null$^      raise fstioerrorread failed r.formatfilename$^ $^  pyxt0  pyxf0pywrapfsttostringpyxvfilename null if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^  pyxvtfst.resetfstscriptfstclassreadpyxt0$^$^   pywrapfst.pyx0000$^    cdef uniqueptrfst.fstclass tfst$^    tfst.resetfst.fstclass.readtostringfilename$^    if tfst.get  null              $^      raise fstioerrorread failed r.formatfilename$^    return initxfsttfst.release$^ $^  pyxt0  pyxvtfst.get  null  0$^  if unlikelypyxt0 $^$^     pywrapfst.pyx0000$^    tfst.resetfst.fstclass.readtostringfilename$^    if tfst.get  null$^      raise fstioerrorread failed r.formatfilename              $^    return initxfsttfst.release$^  $^ $^    pyxt0  pyxgetmoduleglobalnamepyxnsfstioerror if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  pyxpyobjectgetattrstrpyxkpsreadfailedr pyxnsformat if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  null$^    if cythonunpackmethods  likelypymethodcheckpyxt0 $^      pyxt0  pymethodgetselfpyxt0$^      if likelypyxt0 $^        pyobject function  pymethodgetfunctionpyxt0$^        pyxincrefpyxt0$^        pyxincreffunction$^        pyxdecrefsetpyxt0 function$^      $^    $^    if pyxt0 $^      pyxt0  pyxpyobjectcalloneargpyxt0 pyxvfilename if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxgotrefpyxt0$^     else $^      if cythonfastpycall$^      if pyfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxvfilename$^        pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^       else$^      endif$^      if cythonfastpyccall$^      if pyxpyfastcfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxvfilename$^        pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^       else$^      endif$^      $^        pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxgotrefpyxt0$^        pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^        pyxincrefpyxvfilename$^        pyxgiverefpyxvfilename$^        pytuplesetitempyxt0 00 pyxvfilename$^        pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^      $^    $^    pyxdecrefpyxt0 pyxt0  0$^    pyxt0  null$^    if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^      pyxt0  pymethodgetselfpyxt0$^      if likelypyxt0 $^        pyobject function  pymethodgetfunctionpyxt0$^        pyxincrefpyxt0$^        pyxincreffunction$^        pyxdecrefsetpyxt0 function$^      $^    $^    if pyxt0 $^      pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxgotrefpyxt0$^     else $^      if cythonfastpycall$^      if pyfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxt0$^        pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^       else$^      endif$^      if cythonfastpyccall$^      if pyxpyfastcfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxt0$^        pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^       else$^      endif$^      $^        pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxgotrefpyxt0$^        pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^        pyxgiverefpyxt0$^        pytuplesetitempyxt0 00 pyxt0$^        pyxt0  0$^        pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^      $^    $^    pyxdecrefpyxt0 pyxt0  0$^    pyxraisepyxt0 0 0 0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxerr0 0000 pyxl0error$^$^     pywrapfst.pyx0000$^    cdef uniqueptrfst.fstclass tfst$^    tfst.resetfst.fstclass.readtostringfilename$^    if tfst.get  null              $^      raise fstioerrorread failed r.formatfilename$^    return initxfsttfst.release$^ $^  $^$^   pywrapfst.pyx0000$^    if tfst.get  null$^      raise fstioerrorread failed r.formatfilename$^    return initxfsttfst.release              $^  $^  $^ $^  pyxxdecrefpyobject pyxr$^  pyxt0  pyobject pyxf0pywrapfstinitxfstpyxvtfst.release if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  struct pyxobj0pywrapfstfst pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   pywrapfst.pyx0000$^  $^  $^  cpdef fst readfilename              $^    cdef uniqueptrfst.fstclass tfst$^    tfst.resetfst.fstclass.readtostringfilename$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.read pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxl0$^  pyxxgiverefpyobject pyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst00readpyobject pyxself pyobject pyxvfilename proto$^static pyobject pyxpw0pywrapfst00readpyobject pyxself pyobject pyxvfilename $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextread wrapper 0$^  pyxr  pyxpf0pywrapfst00readpyxself pyobject pyxvfilename$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00readcythonunused pyobject pyxself pyobject pyxvfilename $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextread 0$^  pyxxdecrefpyxr$^  pyxt0  pyobject pyxf0pywrapfstreadpyxvfilename 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.read pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^  $^  $^  cpdef fst readfromstringstate              $^    cdef stringstream sstrm$^    sstrm  tostringstate$^ $^$^static pyobject pyxpw0pywrapfst00readfromstringpyobject pyxself pyobject pyxvstate proto$^static struct pyxobj0pywrapfstfst pyxf0pywrapfstreadfromstringpyobject pyxvstate cythonunused int pyxskipdispatch $^  stdstringstream pyxvsstrm$^  stduniqueptrfstscriptfstclass  pyxvtfst$^  struct pyxobj0pywrapfstfst pyxr  null$^  pyxrefnannydeclarations$^  stdstring pyxt0$^  int pyxt0$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextreadfromstring 0$^$^   pywrapfst.pyx0000$^  cpdef fst readfromstringstate$^    cdef stringstream sstrm$^    sstrm  tostringstate              $^    cdef uniqueptrfst.fstclass tfst$^    tfst.resetfst.fstclass.readfromstreamsstrm bpywrapfst$^ $^  pyxt0  pyxf0pywrapfsttostringpyxvstate null if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^  voidpyxvsstrm  pyxt0$^$^   pywrapfst.pyx0000$^    sstrm  tostringstate$^    cdef uniqueptrfst.fstclass tfst$^    tfst.resetfst.fstclass.readfromstreamsstrm bpywrapfst              $^    if tfst.get  null$^      raise fstioerrorread failed string$^ $^  pyxvtfst.resetfstscriptfstclassreadpyxvsstrm pyxkpywrapfst$^$^   pywrapfst.pyx0000$^    cdef uniqueptrfst.fstclass tfst$^    tfst.resetfst.fstclass.readfromstreamsstrm bpywrapfst$^    if tfst.get  null              $^      raise fstioerrorread failed string$^    return initxfsttfst.release$^ $^  pyxt0  pyxvtfst.get  null  0$^  if unlikelypyxt0 $^$^     pywrapfst.pyx0000$^    tfst.resetfst.fstclass.readfromstreamsstrm bpywrapfst$^    if tfst.get  null$^      raise fstioerrorread failed string              $^    return initxfsttfst.release$^  $^ $^    pyxt0  pyxgetmoduleglobalnamepyxnsfstioerror if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  pyxpyobjectcallpyxt0 pyxtuple00 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxraisepyxt0 0 0 0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxerr0 0000 pyxl0error$^$^     pywrapfst.pyx0000$^    cdef uniqueptrfst.fstclass tfst$^    tfst.resetfst.fstclass.readfromstreamsstrm bpywrapfst$^    if tfst.get  null              $^      raise fstioerrorread failed string$^    return initxfsttfst.release$^ $^  $^$^   pywrapfst.pyx0000$^    if tfst.get  null$^      raise fstioerrorread failed string$^    return initxfsttfst.release              $^  $^  $^ $^  pyxxdecrefpyobject pyxr$^  pyxt0  pyobject pyxf0pywrapfstinitxfstpyxvtfst.release if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  struct pyxobj0pywrapfstfst pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   pywrapfst.pyx0000$^  $^  $^  cpdef fst readfromstringstate              $^    cdef stringstream sstrm$^    sstrm  tostringstate$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.readfromstring pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxl0$^  pyxxgiverefpyobject pyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst00readfromstringpyobject pyxself pyobject pyxvstate proto$^static pyobject pyxpw0pywrapfst00readfromstringpyobject pyxself pyobject pyxvstate $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextreadfromstring wrapper 0$^  pyxr  pyxpf0pywrapfst00readfromstringpyxself pyobject pyxvstate$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00readfromstringcythonunused pyobject pyxself pyobject pyxvstate $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextreadfromstring 0$^  pyxxdecrefpyxr$^  pyxt0  pyobject pyxf0pywrapfstreadfromstringpyxvstate 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.readfromstring pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^     $^  $^     def newcls arctypebstandard              $^      return createfstarctype$^  $^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst0fst0newpyobject pyxself pyobject pyxargs pyobject pyxkwds proto$^static pymethoddef pyxmdef0pywrapfst0fst0new  new pycfunctionpyxpw0pywrapfst0fst0new methvarargsmethkeywords 0$^static pyobject pyxpw0pywrapfst0fst0newpyobject pyxself pyobject pyxargs pyobject pyxkwds $^  cythonunused pyobject pyxvcls  0$^  pyobject pyxvarctype  0$^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextnew wrapper 0$^  $^    static pyobject pyxpyargnames  pyxnsclspyxnsarctype0$^    pyobject values0  00$^    values0  pyobject pyobjectpyxnbstandard$^    if unlikelypyxkwds $^      pyssizet kwargs$^      const pyssizet posargs  pytuplegetsizepyxargs$^      switch posargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 break$^        default goto pyxl0argtupleerror$^      $^      kwargs  pydictsizepyxkwds$^      switch posargs $^        case  0$^        if likelyvalues0  pyxpydictgetitemstrpyxkwds pyxnscls  0 kwargs$^        else goto pyxl0argtupleerror$^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnsarctype$^          if value  values0  value kwargs $^        $^      $^      if unlikelykwargs  0 $^        if unlikelypyxparseoptionalkeywordspyxkwds pyxpyargnames 0 values posargs new  0 pyxerr0 0000 pyxl0error$^      $^     else $^      switch pytuplegetsizepyxargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        break$^        default goto pyxl0argtupleerror$^      $^    $^    pyxvcls  values0$^    pyxvarctype  values0$^  $^  goto pyxl0argumentunpackingdone$^  pyxl0argtupleerror$^  pyxraiseargtupleinvalidnew 0 0 0 pytuplegetsizepyxargs pyxerr0 0000 pyxl0error$^  pyxl0error$^  pyxaddtracebackpywrapfst.fst.new pyxclineno pyxlineno pyxfilename$^  pyxrefnannyfinishcontext$^  return null$^  pyxl0argumentunpackingdone$^  pyxr  pyxpf0pywrapfst0fstnewpyxself pyxvcls pyxvarctype$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst0fstnewcythonunused pyobject pyxself cythonunused pyobject pyxvcls pyobject pyxvarctype $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  struct pyxoptargs0pywrapfstcreatefst pyxt0$^  pyxrefnannysetupcontextnew 0$^$^   pywrapfst.pyx0000$^  $^     def newcls arctypebstandard$^      return createfstarctype              $^  $^     staticmethod$^ $^  pyxxdecrefpyxr$^  pyxt0.pyxn  0$^  pyxt0.arctype  pyxvarctype$^  pyxt0  pyobject pyxf0pywrapfstcreatefstpyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   pywrapfst.pyx0000$^     $^  $^     def newcls arctypebstandard              $^      return createfstarctype$^  $^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.fst.new pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^  $^     staticmethod$^     def readfilename              $^       $^       readfilename$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst0fst0readpyobject pyxself pyobject pyxvfilename proto$^static char pyxdoc0pywrapfst0fst0read  n     readfilenamenn     reads an fst from a file.nn     argsn       filename the string location of the input file.nn     returnsn       an fst object.nn     raisesn       fstioerror read failed.n     $^static pymethoddef pyxmdef0pywrapfst0fst0read  read pycfunctionpyxpw0pywrapfst0fst0read metho pyxdoc0pywrapfst0fst0read$^static pyobject pyxpw0pywrapfst0fst0readpyobject pyxself pyobject pyxvfilename $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextread wrapper 0$^  pyxr  pyxpf0pywrapfst0fst0readpyxself pyobject pyxvfilename$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst0fst0readcythonunused pyobject pyxself pyobject pyxvfilename $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextread 0$^$^   pywrapfst.pyx0000$^         fstioerror read failed.$^       $^       return readfilename              $^  $^     staticmethod$^ $^  pyxxdecrefpyxr$^  pyxt0  pyobject pyxf0pywrapfstreadpyxvfilename 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   pywrapfst.pyx0000$^  $^     staticmethod$^     def readfilename              $^       $^       readfilename$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.fst.read pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^  $^     staticmethod$^     def readfromstringstate              $^       $^       readfromstringstring fsttypenone$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst0fst0readfromstringpyobject pyxself pyobject pyxvstate proto$^static char pyxdoc0pywrapfst0fst0readfromstring  n     readfromstringstring fsttypenonenn     reads an fst from a serialized string.nn     argsn       state a string containing the serialized fst.nn     returnsn       an fst object.nn     raisesn       fstioerror read failed.n       fstoperror readtime conversion failed.nn     see also writetostring.n     $^static pymethoddef pyxmdef0pywrapfst0fst0readfromstring  readfromstring pycfunctionpyxpw0pywrapfst0fst0readfromstring metho pyxdoc0pywrapfst0fst0readfromstring$^static pyobject pyxpw0pywrapfst0fst0readfromstringpyobject pyxself pyobject pyxvstate $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextreadfromstring wrapper 0$^  pyxr  pyxpf0pywrapfst0fst0readfromstringpyxself pyobject pyxvstate$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst0fst0readfromstringcythonunused pyobject pyxself pyobject pyxvstate $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextreadfromstring 0$^$^   pywrapfst.pyx0000$^       see also writetostring.$^       $^       return readfromstringstate              $^  $^  $^ $^  pyxxdecrefpyxr$^  pyxt0  pyobject pyxf0pywrapfstreadfromstringpyxvstate 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   pywrapfst.pyx0000$^  $^     staticmethod$^     def readfromstringstate              $^       $^       readfromstringstring fsttypenone$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.fst.readfromstring pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^    $^  $^    def reprself              $^      return arc at 0xx.formatidself$^  $^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst0arc0reprpyobject pyxvself proto$^static pyobject pyxpw0pywrapfst0arc0reprpyobject pyxvself $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextrepr wrapper 0$^  pyxr  pyxpf0pywrapfst0arcreprstruct pyxobj0pywrapfstarc pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst0arcreprstruct pyxobj0pywrapfstarc pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextrepr 0$^$^   pywrapfst.pyx0000$^  $^    def reprself$^      return arc at 0xx.formatidself              $^  $^    def initself int00 ilabel int00 olabel weight int00 nextstate$^ $^  pyxxdecrefpyxr$^  pyxt0  pyxpyobjectgetattrstrpyxkpsarcat0xx pyxnsformat if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxt0  pyxpyobjectcalloneargpyxbuiltinid pyobject pyxvself if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxt0  null$^  if cythonunpackmethods  likelypymethodcheckpyxt0 $^    pyxt0  pymethodgetselfpyxt0$^    if likelypyxt0 $^      pyobject function  pymethodgetfunctionpyxt0$^      pyxincrefpyxt0$^      pyxincreffunction$^      pyxdecrefsetpyxt0 function$^    $^  $^  if pyxt0 $^    pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxdecrefpyxt0 pyxt0  0$^    pyxgotrefpyxt0$^   else $^    if cythonfastpycall$^    if pyfunctioncheckpyxt0 $^      pyobject pyxtemp0  pyxt0 pyxt0$^      pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxxdecrefpyxt0 pyxt0  0$^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^     else$^    endif$^    if cythonfastpyccall$^    if pyxpyfastcfunctioncheckpyxt0 $^      pyobject pyxtemp0  pyxt0 pyxt0$^      pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxxdecrefpyxt0 pyxt0  0$^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^     else$^    endif$^    $^      pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxgotrefpyxt0$^      pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^      pyxgiverefpyxt0$^      pytuplesetitempyxt0 00 pyxt0$^      pyxt0  0$^      pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^    $^  $^  pyxdecrefpyxt0 pyxt0  0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   pywrapfst.pyx0000$^    $^  $^    def reprself              $^      return arc at 0xx.formatidself$^  $^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.arc.repr pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return arc at 0xx.formatidself$^  $^    def initself int00 ilabel int00 olabel weight int00 nextstate              $^      cdef fst.weightclass wc  getweightclassoronebtropical weight$^      self.arc.resetnew fst.arcclassilabel olabel wc nextstate$^ $^$^ python wrapper $^static int pyxpw0pywrapfst0arc0initpyobject pyxvself pyobject pyxargs pyobject pyxkwds proto$^static int pyxpw0pywrapfst0arc0initpyobject pyxvself pyobject pyxargs pyobject pyxkwds $^  pyxt00basictypesint00 pyxvilabel$^  pyxt00basictypesint00 pyxvolabel$^  pyobject pyxvweight  0$^  pyxt00basictypesint00 pyxvnextstate$^  int pyxr$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextinit wrapper 0$^  $^    static pyobject pyxpyargnames  pyxnsilabelpyxnsolabelpyxnsweightpyxnsnextstate0$^    pyobject values0  0000$^    if unlikelypyxkwds $^      pyssizet kwargs$^      const pyssizet posargs  pytuplegetsizepyxargs$^      switch posargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 break$^        default goto pyxl0argtupleerror$^      $^      kwargs  pydictsizepyxkwds$^      switch posargs $^        case  0$^        if likelyvalues0  pyxpydictgetitemstrpyxkwds pyxnsilabel  0 kwargs$^        else goto pyxl0argtupleerror$^        cythonfallthrough$^        case  0$^        if likelyvalues0  pyxpydictgetitemstrpyxkwds pyxnsolabel  0 kwargs$^        else $^          pyxraiseargtupleinvalidinit 0 0 0 0 pyxerr0 0000 pyxl0error$^        $^        cythonfallthrough$^        case  0$^        if likelyvalues0  pyxpydictgetitemstrpyxkwds pyxnsweight  0 kwargs$^        else $^          pyxraiseargtupleinvalidinit 0 0 0 0 pyxerr0 0000 pyxl0error$^        $^        cythonfallthrough$^        case  0$^        if likelyvalues0  pyxpydictgetitemstrpyxkwds pyxnsnextstate  0 kwargs$^        else $^          pyxraiseargtupleinvalidinit 0 0 0 0 pyxerr0 0000 pyxl0error$^        $^      $^      if unlikelykwargs  0 $^        if unlikelypyxparseoptionalkeywordspyxkwds pyxpyargnames 0 values posargs init  0 pyxerr0 0000 pyxl0error$^      $^     else if pytuplegetsizepyxargs  0 $^      goto pyxl0argtupleerror$^     else $^      values0  pytuplegetitempyxargs 0$^      values0  pytuplegetitempyxargs 0$^      values0  pytuplegetitempyxargs 0$^      values0  pytuplegetitempyxargs 0$^    $^    pyxvilabel  pyxpyintasint00tvalues0 if unlikelypyxvilabel  int00t0  pyerroccurred pyxerr0 0000 pyxl0error$^    pyxvolabel  pyxpyintasint00tvalues0 if unlikelypyxvolabel  int00t0  pyerroccurred pyxerr0 0000 pyxl0error$^    pyxvweight  values0$^    pyxvnextstate  pyxpyintasint00tvalues0 if unlikelypyxvnextstate  int00t0  pyerroccurred pyxerr0 0000 pyxl0error$^  $^  goto pyxl0argumentunpackingdone$^  pyxl0argtupleerror$^  pyxraiseargtupleinvalidinit 0 0 0 pytuplegetsizepyxargs pyxerr0 0000 pyxl0error$^  pyxl0error$^  pyxaddtracebackpywrapfst.arc.init pyxclineno pyxlineno pyxfilename$^  pyxrefnannyfinishcontext$^  return 0$^  pyxl0argumentunpackingdone$^  pyxr  pyxpf0pywrapfst0arc0initstruct pyxobj0pywrapfstarc pyxvself pyxvilabel pyxvolabel pyxvweight pyxvnextstate$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static int pyxpf0pywrapfst0arc0initstruct pyxobj0pywrapfstarc pyxvself pyxt00basictypesint00 pyxvilabel pyxt00basictypesint00 pyxvolabel pyobject pyxvweight pyxt00basictypesint00 pyxvnextstate $^  fstscriptweightclass pyxvwc$^  int pyxr$^  pyxrefnannydeclarations$^  fstscriptweightclass pyxt0$^  pyxrefnannysetupcontextinit 0$^$^   pywrapfst.pyx0000$^  $^    def initself int00 ilabel int00 olabel weight int00 nextstate$^      cdef fst.weightclass wc  getweightclassoronebtropical weight              $^      self.arc.resetnew fst.arcclassilabel olabel wc nextstate$^  $^ $^  pyxt0  pyxf0pywrapfstgetweightclassoronepyxktropical pyxvweight if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^  pyxvwc  pyxt0$^$^   pywrapfst.pyx0000$^    def initself int00 ilabel int00 olabel weight int00 nextstate$^      cdef fst.weightclass wc  getweightclassoronebtropical weight$^      self.arc.resetnew fst.arcclassilabel olabel wc nextstate              $^  $^    cpdef arc copyself$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s arc$^    pyxerr0 0000 pyxl0error$^  $^  pyxvselfarc.resetnew fstscriptarcclasspyxvilabel pyxvolabel pyxvwc pyxvnextstate$^$^   pywrapfst.pyx0000$^      return arc at 0xx.formatidself$^  $^    def initself int00 ilabel int00 olabel weight int00 nextstate              $^      cdef fst.weightclass wc  getweightclassoronebtropical weight$^      self.arc.resetnew fst.arcclassilabel olabel wc nextstate$^ $^$^   function exit code $^  pyxr  0$^  goto pyxl0$^  pyxl0error$^  pyxaddtracebackpywrapfst.arc.init pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      self.arc.resetnew fst.arcclassilabel olabel wc nextstate$^  $^    cpdef arc copyself              $^      return arcself.ilabel self.olabel self.weight self.nextstate$^  $^ $^$^static pyobject pyxpw0pywrapfst0arc0copypyobject pyxvself cythonunused pyobject unused proto$^static struct pyxobj0pywrapfstarc pyxf0pywrapfst0arccopystruct pyxobj0pywrapfstarc pyxvself int pyxskipdispatch $^  struct pyxobj0pywrapfstarc pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextcopy 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnscopy if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst0arc0copy $^      pyxxdecrefpyobject pyxr$^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxdecrefpyxt0 pyxt0  0$^       else $^        pyxt0  pyxpyobjectcallnoargpyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      $^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      if likelypyxt0  pynone  likelypyxtypetestpyxt0 pyxptype0pywrapfstarc pyxerr0 0000 pyxl0error$^      pyxr  struct pyxobj0pywrapfstarc pyxt0$^      pyxt0  0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx0000$^  $^    cpdef arc copyself$^      return arcself.ilabel self.olabel self.weight self.nextstate              $^  $^    property ilabel$^ $^  pyxxdecrefpyobject pyxr$^  pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnsilabel if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnsolabel if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnsweight if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnsnextstate if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxt0  pytuplenew0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxgiverefpyxt0$^  pytuplesetitempyxt0 0 pyxt0$^  pyxgiverefpyxt0$^  pytuplesetitempyxt0 0 pyxt0$^  pyxgiverefpyxt0$^  pytuplesetitempyxt0 0 pyxt0$^  pyxgiverefpyxt0$^  pytuplesetitempyxt0 0 pyxt0$^  pyxt0  0$^  pyxt0  0$^  pyxt0  0$^  pyxt0  0$^  pyxt0  pyxpyobjectcallpyobject pyxptype0pywrapfstarc pyxt0 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxdecrefpyxt0 pyxt0  0$^  pyxr  struct pyxobj0pywrapfstarc pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      self.arc.resetnew fst.arcclassilabel olabel wc nextstate$^  $^    cpdef arc copyself              $^      return arcself.ilabel self.olabel self.weight self.nextstate$^  $^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.arc.copy pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxl0$^  pyxxgiverefpyobject pyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst0arc0copypyobject pyxvself cythonunused pyobject unused proto$^static pyobject pyxpw0pywrapfst0arc0copypyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextcopy wrapper 0$^  pyxr  pyxpf0pywrapfst0arc0copystruct pyxobj0pywrapfstarc pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst0arc0copystruct pyxobj0pywrapfstarc pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextcopy 0$^  pyxxdecrefpyxr$^  pyxt0  pyobject pyxf0pywrapfst0arccopypyxvself 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.arc.copy pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^    property ilabel$^  $^      def getself              $^        return derefself.arc.ilabel$^  $^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst0arc0ilabel0getpyobject pyxvself proto$^static pyobject pyxpw0pywrapfst0arc0ilabel0getpyobject pyxvself $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextget wrapper 0$^  pyxr  pyxpf0pywrapfst0arc0ilabelgetstruct pyxobj0pywrapfstarc pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst0arc0ilabelgetstruct pyxobj0pywrapfstarc pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextget 0$^$^   pywrapfst.pyx0000$^  $^      def getself$^        return derefself.arc.ilabel              $^  $^      def setself int00 value$^ $^  pyxxdecrefpyxr$^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s arc$^    pyxerr0 0000 pyxl0error$^  $^  pyxt0  pyxpyintfromint00tpyxvselfarc.ilabel if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   pywrapfst.pyx0000$^    property ilabel$^  $^      def getself              $^        return derefself.arc.ilabel$^  $^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.arc.ilabel.get pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^        return derefself.arc.ilabel$^  $^      def setself int00 value              $^        derefself.arc.ilabel  value$^  $^ $^$^ python wrapper $^static int pyxpw0pywrapfst0arc0ilabel0setpyobject pyxvself pyobject pyxargvalue proto$^static int pyxpw0pywrapfst0arc0ilabel0setpyobject pyxvself pyobject pyxargvalue $^  pyxt00basictypesint00 pyxvvalue$^  int pyxr$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextset wrapper 0$^  assertpyxargvalue $^    pyxvvalue  pyxpyintasint00tpyxargvalue if unlikelypyxvvalue  int00t0  pyerroccurred pyxerr0 0000 pyxl0error$^  $^  goto pyxl0argumentunpackingdone$^  pyxl0error$^  pyxaddtracebackpywrapfst.arc.ilabel.set pyxclineno pyxlineno pyxfilename$^  pyxrefnannyfinishcontext$^  return 0$^  pyxl0argumentunpackingdone$^  pyxr  pyxpf0pywrapfst0arc0ilabel0setstruct pyxobj0pywrapfstarc pyxvself pyxt00basictypesint00pyxvvalue$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static int pyxpf0pywrapfst0arc0ilabel0setstruct pyxobj0pywrapfstarc pyxvself pyxt00basictypesint00 pyxvvalue $^  int pyxr$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextset 0$^$^   pywrapfst.pyx0000$^  $^      def setself int00 value$^        derefself.arc.ilabel  value              $^  $^    property olabel$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s arc$^    pyxerr0 0000 pyxl0error$^  $^  pyxvselfarc.ilabel  pyxvvalue$^$^   pywrapfst.pyx0000$^        return derefself.arc.ilabel$^  $^      def setself int00 value              $^        derefself.arc.ilabel  value$^  $^ $^$^   function exit code $^  pyxr  0$^  goto pyxl0$^  pyxl0error$^  pyxaddtracebackpywrapfst.arc.ilabel.set pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^    property olabel$^  $^      def getself              $^        return derefself.arc.olabel$^  $^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst0arc0olabel0getpyobject pyxvself proto$^static pyobject pyxpw0pywrapfst0arc0olabel0getpyobject pyxvself $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextget wrapper 0$^  pyxr  pyxpf0pywrapfst0arc0olabelgetstruct pyxobj0pywrapfstarc pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst0arc0olabelgetstruct pyxobj0pywrapfstarc pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextget 0$^$^   pywrapfst.pyx0000$^  $^      def getself$^        return derefself.arc.olabel              $^  $^      def setself int00 value$^ $^  pyxxdecrefpyxr$^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s arc$^    pyxerr0 0000 pyxl0error$^  $^  pyxt0  pyxpyintfromint00tpyxvselfarc.olabel if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   pywrapfst.pyx0000$^    property olabel$^  $^      def getself              $^        return derefself.arc.olabel$^  $^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.arc.olabel.get pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^        return derefself.arc.olabel$^  $^      def setself int00 value              $^        derefself.arc.olabel  value$^  $^ $^$^ python wrapper $^static int pyxpw0pywrapfst0arc0olabel0setpyobject pyxvself pyobject pyxargvalue proto$^static int pyxpw0pywrapfst0arc0olabel0setpyobject pyxvself pyobject pyxargvalue $^  pyxt00basictypesint00 pyxvvalue$^  int pyxr$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextset wrapper 0$^  assertpyxargvalue $^    pyxvvalue  pyxpyintasint00tpyxargvalue if unlikelypyxvvalue  int00t0  pyerroccurred pyxerr0 0000 pyxl0error$^  $^  goto pyxl0argumentunpackingdone$^  pyxl0error$^  pyxaddtracebackpywrapfst.arc.olabel.set pyxclineno pyxlineno pyxfilename$^  pyxrefnannyfinishcontext$^  return 0$^  pyxl0argumentunpackingdone$^  pyxr  pyxpf0pywrapfst0arc0olabel0setstruct pyxobj0pywrapfstarc pyxvself pyxt00basictypesint00pyxvvalue$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static int pyxpf0pywrapfst0arc0olabel0setstruct pyxobj0pywrapfstarc pyxvself pyxt00basictypesint00 pyxvvalue $^  int pyxr$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextset 0$^$^   pywrapfst.pyx0000$^  $^      def setself int00 value$^        derefself.arc.olabel  value              $^  $^    property weight$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s arc$^    pyxerr0 0000 pyxl0error$^  $^  pyxvselfarc.olabel  pyxvvalue$^$^   pywrapfst.pyx0000$^        return derefself.arc.olabel$^  $^      def setself int00 value              $^        derefself.arc.olabel  value$^  $^ $^$^   function exit code $^  pyxr  0$^  goto pyxl0$^  pyxl0error$^  pyxaddtracebackpywrapfst.arc.olabel.set pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^    property weight$^  $^      def getself              $^        cdef weight weight  weight.newweight$^        weight.weight.resetnew fst.weightclassderefself.arc.weight$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst0arc0weight0getpyobject pyxvself proto$^static pyobject pyxpw0pywrapfst0arc0weight0getpyobject pyxvself $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextget wrapper 0$^  pyxr  pyxpf0pywrapfst0arc0weightgetstruct pyxobj0pywrapfstarc pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst0arc0weightgetstruct pyxobj0pywrapfstarc pyxvself $^  struct pyxobj0pywrapfstweight pyxvweight  0$^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextget 0$^$^   pywrapfst.pyx0000$^  $^      def getself$^        cdef weight weight  weight.newweight              $^        weight.weight.resetnew fst.weightclassderefself.arc.weight$^        return weight$^ $^  pyxt0  pyobject pyxtpnew0pywrapfstweightpytypeobject pyxptype0pywrapfstweight pyxemptytuple null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyobject pyxt0$^  pyxvweight  struct pyxobj0pywrapfstweight pyxt0$^  pyxt0  0$^$^   pywrapfst.pyx0000$^      def getself$^        cdef weight weight  weight.newweight$^        weight.weight.resetnew fst.weightclassderefself.arc.weight              $^        return weight$^  $^ $^  if unlikelypyobject pyxvweight  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s weight$^    pyxerr0 0000 pyxl0error$^  $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s arc$^    pyxerr0 0000 pyxl0error$^  $^  pyxvweightweight.resetnew fstscriptweightclasspyxvselfarc.weight$^$^   pywrapfst.pyx0000$^        cdef weight weight  weight.newweight$^        weight.weight.resetnew fst.weightclassderefself.arc.weight$^        return weight              $^  $^      def setself weight$^ $^  pyxxdecrefpyxr$^  pyxincrefpyobject pyxvweight$^  pyxr  pyobject pyxvweight$^  goto pyxl0$^$^   pywrapfst.pyx0000$^    property weight$^  $^      def getself              $^        cdef weight weight  weight.newweight$^        weight.weight.resetnew fst.weightclassderefself.arc.weight$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.arc.weight.get pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxdecrefpyobject pyxvweight$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^        return weight$^  $^      def setself weight              $^        derefself.arc.weight  getweightclassoronebtropical weight$^  $^ $^$^ python wrapper $^static int pyxpw0pywrapfst0arc0weight0setpyobject pyxvself pyobject pyxvweight proto$^static int pyxpw0pywrapfst0arc0weight0setpyobject pyxvself pyobject pyxvweight $^  int pyxr$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextset wrapper 0$^  pyxr  pyxpf0pywrapfst0arc0weight0setstruct pyxobj0pywrapfstarc pyxvself pyobject pyxvweight$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static int pyxpf0pywrapfst0arc0weight0setstruct pyxobj0pywrapfstarc pyxvself pyobject pyxvweight $^  int pyxr$^  pyxrefnannydeclarations$^  fstscriptweightclass pyxt0$^  pyxrefnannysetupcontextset 0$^$^   pywrapfst.pyx0000$^  $^      def setself weight$^        derefself.arc.weight  getweightclassoronebtropical weight              $^  $^    property nextstate$^ $^  pyxt0  pyxf0pywrapfstgetweightclassoronepyxktropical pyxvweight if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s arc$^    pyxerr0 0000 pyxl0error$^  $^  pyxvselfarc.weight  pyxt0$^$^   pywrapfst.pyx0000$^        return weight$^  $^      def setself weight              $^        derefself.arc.weight  getweightclassoronebtropical weight$^  $^ $^$^   function exit code $^  pyxr  0$^  goto pyxl0$^  pyxl0error$^  pyxaddtracebackpywrapfst.arc.weight.set pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^    property nextstate$^  $^      def getself              $^        return derefself.arc.nextstate$^  $^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst0arc0nextstate0getpyobject pyxvself proto$^static pyobject pyxpw0pywrapfst0arc0nextstate0getpyobject pyxvself $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextget wrapper 0$^  pyxr  pyxpf0pywrapfst0arc0nextstategetstruct pyxobj0pywrapfstarc pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst0arc0nextstategetstruct pyxobj0pywrapfstarc pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextget 0$^$^   pywrapfst.pyx0000$^  $^      def getself$^        return derefself.arc.nextstate              $^  $^      def setself int00 value$^ $^  pyxxdecrefpyxr$^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s arc$^    pyxerr0 0000 pyxl0error$^  $^  pyxt0  pyxpyintfromint00tpyxvselfarc.nextstate if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   pywrapfst.pyx0000$^    property nextstate$^  $^      def getself              $^        return derefself.arc.nextstate$^  $^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.arc.nextstate.get pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^        return derefself.arc.nextstate$^  $^      def setself int00 value              $^        derefself.arc.nextstate  value$^  $^ $^$^ python wrapper $^static int pyxpw0pywrapfst0arc0nextstate0setpyobject pyxvself pyobject pyxargvalue proto$^static int pyxpw0pywrapfst0arc0nextstate0setpyobject pyxvself pyobject pyxargvalue $^  pyxt00basictypesint00 pyxvvalue$^  int pyxr$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextset wrapper 0$^  assertpyxargvalue $^    pyxvvalue  pyxpyintasint00tpyxargvalue if unlikelypyxvvalue  int00t0  pyerroccurred pyxerr0 0000 pyxl0error$^  $^  goto pyxl0argumentunpackingdone$^  pyxl0error$^  pyxaddtracebackpywrapfst.arc.nextstate.set pyxclineno pyxlineno pyxfilename$^  pyxrefnannyfinishcontext$^  return 0$^  pyxl0argumentunpackingdone$^  pyxr  pyxpf0pywrapfst0arc0nextstate0setstruct pyxobj0pywrapfstarc pyxvself pyxt00basictypesint00pyxvvalue$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static int pyxpf0pywrapfst0arc0nextstate0setstruct pyxobj0pywrapfstarc pyxvself pyxt00basictypesint00 pyxvvalue $^  int pyxr$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextset 0$^$^   pywrapfst.pyx0000$^  $^      def setself int00 value$^        derefself.arc.nextstate  value              $^  $^  $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s arc$^    pyxerr0 0000 pyxl0error$^  $^  pyxvselfarc.nextstate  pyxvvalue$^$^   pywrapfst.pyx0000$^        return derefself.arc.nextstate$^  $^      def setself int00 value              $^        derefself.arc.nextstate  value$^  $^ $^$^   function exit code $^  pyxr  0$^  goto pyxl0$^  pyxl0error$^  pyxaddtracebackpywrapfst.arc.nextstate.set pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ tree fragment0$^  def reducecythonself              $^      raise typeerrorself.arc cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst0arc0reducecythonpyobject pyxvself cythonunused pyobject unused proto$^static pyobject pyxpw0pywrapfst0arc0reducecythonpyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextreducecython wrapper 0$^  pyxr  pyxpf0pywrapfst0arc0reducecythonstruct pyxobj0pywrapfstarc pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst0arc0reducecythoncythonunused struct pyxobj0pywrapfstarc pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextreducecython 0$^$^   tree fragment0$^  def reducecythonself$^      raise typeerrorself.arc cannot be converted to a python object for pickling              $^  def setstatecythonself pyxstate$^      raise typeerrorself.arc cannot be converted to a python object for pickling$^ $^  pyxt0  pyxpyobjectcallpyxbuiltintypeerror pyxtuple00 null if unlikelypyxt0 pyxerr0 0 pyxl0error$^  pyxgotrefpyxt0$^  pyxraisepyxt0 0 0 0$^  pyxdecrefpyxt0 pyxt0  0$^  pyxerr0 0 pyxl0error$^$^   tree fragment0$^  def reducecythonself              $^      raise typeerrorself.arc cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.arc.reducecython pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ tree fragment0$^  def reducecythonself$^      raise typeerrorself.arc cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate              $^      raise typeerrorself.arc cannot be converted to a python object for pickling$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst0arc0setstatecythonpyobject pyxvself pyobject pyxvpyxstate proto$^static pyobject pyxpw0pywrapfst0arc0setstatecythonpyobject pyxvself pyobject pyxvpyxstate $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextsetstatecython wrapper 0$^  pyxr  pyxpf0pywrapfst0arc0setstatecythonstruct pyxobj0pywrapfstarc pyxvself pyobject pyxvpyxstate$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst0arc0setstatecythoncythonunused struct pyxobj0pywrapfstarc pyxvself cythonunused pyobject pyxvpyxstate $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextsetstatecython 0$^$^   tree fragment0$^      raise typeerrorself.arc cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate$^      raise typeerrorself.arc cannot be converted to a python object for pickling              $^ $^  pyxt0  pyxpyobjectcallpyxbuiltintypeerror pyxtuple00 null if unlikelypyxt0 pyxerr0 0 pyxl0error$^  pyxgotrefpyxt0$^  pyxraisepyxt0 0 0 0$^  pyxdecrefpyxt0 pyxt0  0$^  pyxerr0 0 pyxl0error$^$^   tree fragment0$^  def reducecythonself$^      raise typeerrorself.arc cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate              $^      raise typeerrorself.arc cannot be converted to a python object for pickling$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.arc.setstatecython pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^  $^  $^  cdef arc initarcconst fst.arcclass arc              $^    cdef weight weight  weight.newweight$^    weight.weight.resetnew fst.weightclassarc.weight$^ $^$^static struct pyxobj0pywrapfstarc pyxf0pywrapfstinitarcfstscriptarcclass const pyxvarc $^  struct pyxobj0pywrapfstweight pyxvweight  0$^  struct pyxobj0pywrapfstarc pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextinitarc 0$^$^   pywrapfst.pyx0000$^  $^  cdef arc initarcconst fst.arcclass arc$^    cdef weight weight  weight.newweight              $^    weight.weight.resetnew fst.weightclassarc.weight$^    return arcarc.ilabel arc.olabel weight arc.nextstate$^ $^  pyxt0  pyobject pyxtpnew0pywrapfstweightpytypeobject pyxptype0pywrapfstweight pyxemptytuple null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyobject pyxt0$^  pyxvweight  struct pyxobj0pywrapfstweight pyxt0$^  pyxt0  0$^$^   pywrapfst.pyx0000$^  cdef arc initarcconst fst.arcclass arc$^    cdef weight weight  weight.newweight$^    weight.weight.resetnew fst.weightclassarc.weight              $^    return arcarc.ilabel arc.olabel weight arc.nextstate$^  $^ $^  if unlikelypyobject pyxvweight  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s weight$^    pyxerr0 0000 pyxl0error$^  $^  pyxvweightweight.resetnew fstscriptweightclasspyxvarc.weight$^$^   pywrapfst.pyx0000$^    cdef weight weight  weight.newweight$^    weight.weight.resetnew fst.weightclassarc.weight$^    return arcarc.ilabel arc.olabel weight arc.nextstate              $^  $^  $^ $^  pyxxdecrefpyobject pyxr$^  pyxt0  pyxpyintfromint00tpyxvarc.ilabel if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxt0  pyxpyintfromint00tpyxvarc.olabel if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxt0  pyxpyintfromint00tpyxvarc.nextstate if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxt0  pytuplenew0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxgiverefpyxt0$^  pytuplesetitempyxt0 0 pyxt0$^  pyxgiverefpyxt0$^  pytuplesetitempyxt0 0 pyxt0$^  pyxincrefpyobject pyxvweight$^  pyxgiverefpyobject pyxvweight$^  pytuplesetitempyxt0 0 pyobject pyxvweight$^  pyxgiverefpyxt0$^  pytuplesetitempyxt0 0 pyxt0$^  pyxt0  0$^  pyxt0  0$^  pyxt0  0$^  pyxt0  pyxpyobjectcallpyobject pyxptype0pywrapfstarc pyxt0 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxdecrefpyxt0 pyxt0  0$^  pyxr  struct pyxobj0pywrapfstarc pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   pywrapfst.pyx0000$^  $^  $^  cdef arc initarcconst fst.arcclass arc              $^    cdef weight weight  weight.newweight$^    weight.weight.resetnew fst.weightclassarc.weight$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.initarc pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxl0$^  pyxxdecrefpyobject pyxvweight$^  pyxxgiverefpyobject pyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^    $^  $^    def reprself              $^      return arciterator at 0xx.formatidself$^  $^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00arciterator0reprpyobject pyxvself proto$^static pyobject pyxpw0pywrapfst00arciterator0reprpyobject pyxvself $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextrepr wrapper 0$^  pyxr  pyxpf0pywrapfst00arciteratorreprstruct pyxobj0pywrapfstarciterator pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00arciteratorreprstruct pyxobj0pywrapfstarciterator pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextrepr 0$^$^   pywrapfst.pyx0000$^  $^    def reprself$^      return arciterator at 0xx.formatidself              $^  $^    def initself fst ifst int00 state$^ $^  pyxxdecrefpyxr$^  pyxt0  pyxpyobjectgetattrstrpyxkpsarciteratorat0xx pyxnsformat if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxt0  pyxpyobjectcalloneargpyxbuiltinid pyobject pyxvself if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxt0  null$^  if cythonunpackmethods  likelypymethodcheckpyxt0 $^    pyxt0  pymethodgetselfpyxt0$^    if likelypyxt0 $^      pyobject function  pymethodgetfunctionpyxt0$^      pyxincrefpyxt0$^      pyxincreffunction$^      pyxdecrefsetpyxt0 function$^    $^  $^  if pyxt0 $^    pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxdecrefpyxt0 pyxt0  0$^    pyxgotrefpyxt0$^   else $^    if cythonfastpycall$^    if pyfunctioncheckpyxt0 $^      pyobject pyxtemp0  pyxt0 pyxt0$^      pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxxdecrefpyxt0 pyxt0  0$^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^     else$^    endif$^    if cythonfastpyccall$^    if pyxpyfastcfunctioncheckpyxt0 $^      pyobject pyxtemp0  pyxt0 pyxt0$^      pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxxdecrefpyxt0 pyxt0  0$^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^     else$^    endif$^    $^      pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxgotrefpyxt0$^      pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^      pyxgiverefpyxt0$^      pytuplesetitempyxt0 00 pyxt0$^      pyxt0  0$^      pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^    $^  $^  pyxdecrefpyxt0 pyxt0  0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   pywrapfst.pyx0000$^    $^  $^    def reprself              $^      return arciterator at 0xx.formatidself$^  $^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.arciterator.repr pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return arciterator at 0xx.formatidself$^  $^    def initself fst ifst int00 state              $^      if not ifst.fst.get.validstateidstate$^        raise fstindexerrorstate index out of range$^ $^$^ python wrapper $^static int pyxpw0pywrapfst00arciterator0initpyobject pyxvself pyobject pyxargs pyobject pyxkwds proto$^static int pyxpw0pywrapfst00arciterator0initpyobject pyxvself pyobject pyxargs pyobject pyxkwds $^  struct pyxobj0pywrapfstfst pyxvifst  0$^  pyxt00basictypesint00 pyxvstate$^  int pyxr$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextinit wrapper 0$^  $^    static pyobject pyxpyargnames  pyxnsifstpyxnsstate0$^    pyobject values0  00$^    if unlikelypyxkwds $^      pyssizet kwargs$^      const pyssizet posargs  pytuplegetsizepyxargs$^      switch posargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 break$^        default goto pyxl0argtupleerror$^      $^      kwargs  pydictsizepyxkwds$^      switch posargs $^        case  0$^        if likelyvalues0  pyxpydictgetitemstrpyxkwds pyxnsifst  0 kwargs$^        else goto pyxl0argtupleerror$^        cythonfallthrough$^        case  0$^        if likelyvalues0  pyxpydictgetitemstrpyxkwds pyxnsstate  0 kwargs$^        else $^          pyxraiseargtupleinvalidinit 0 0 0 0 pyxerr0 0000 pyxl0error$^        $^      $^      if unlikelykwargs  0 $^        if unlikelypyxparseoptionalkeywordspyxkwds pyxpyargnames 0 values posargs init  0 pyxerr0 0000 pyxl0error$^      $^     else if pytuplegetsizepyxargs  0 $^      goto pyxl0argtupleerror$^     else $^      values0  pytuplegetitempyxargs 0$^      values0  pytuplegetitempyxargs 0$^    $^    pyxvifst  struct pyxobj0pywrapfstfst values0$^    pyxvstate  pyxpyintasint00tvalues0 if unlikelypyxvstate  int00t0  pyerroccurred pyxerr0 0000 pyxl0error$^  $^  goto pyxl0argumentunpackingdone$^  pyxl0argtupleerror$^  pyxraiseargtupleinvalidinit 0 0 0 pytuplegetsizepyxargs pyxerr0 0000 pyxl0error$^  pyxl0error$^  pyxaddtracebackpywrapfst.arciterator.init pyxclineno pyxlineno pyxfilename$^  pyxrefnannyfinishcontext$^  return 0$^  pyxl0argumentunpackingdone$^  if unlikelypyxargtypetestpyobject pyxvifst pyxptype0pywrapfstfst 0 ifst 0 pyxerr0 0000 pyxl0error$^  pyxr  pyxpf0pywrapfst00arciterator0initstruct pyxobj0pywrapfstarciterator pyxvself pyxvifst pyxvstate$^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxr  0$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static int pyxpf0pywrapfst00arciterator0initstruct pyxobj0pywrapfstarciterator pyxvself struct pyxobj0pywrapfstfst pyxvifst pyxt00basictypesint00 pyxvstate $^  int pyxr$^  pyxrefnannydeclarations$^  int pyxt0$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  stdsharedptrfstscriptfstclass  pyxt0$^  pyxrefnannysetupcontextinit 0$^$^   pywrapfst.pyx0000$^  $^    def initself fst ifst int00 state$^      if not ifst.fst.get.validstateidstate              $^        raise fstindexerrorstate index out of range$^       makes copy of the sharedptr potentially extending the fsts lifetime.$^ $^  if unlikelypyobject pyxvifst  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s fst$^    pyxerr0 0000 pyxl0error$^  $^  pyxt0  pyxvifstfst.getvalidstateidpyxvstate  0  0$^  if unlikelypyxt0 $^$^     pywrapfst.pyx0000$^    def initself fst ifst int00 state$^      if not ifst.fst.get.validstateidstate$^        raise fstindexerrorstate index out of range              $^       makes copy of the sharedptr potentially extending the fsts lifetime.$^      self.fst  ifst.fst$^ $^    pyxt0  pyxgetmoduleglobalnamepyxnsfstindexerror if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  pyxpyobjectcallpyxt0 pyxtuple00 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxraisepyxt0 0 0 0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxerr0 0000 pyxl0error$^$^     pywrapfst.pyx0000$^  $^    def initself fst ifst int00 state$^      if not ifst.fst.get.validstateidstate              $^        raise fstindexerrorstate index out of range$^       makes copy of the sharedptr potentially extending the fsts lifetime.$^ $^  $^$^   pywrapfst.pyx0000$^        raise fstindexerrorstate index out of range$^       makes copy of the sharedptr potentially extending the fsts lifetime.$^      self.fst  ifst.fst              $^      self.aiter.resetnew fst.arciteratorclassderefself.fst state$^  $^ $^  if unlikelypyobject pyxvifst  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s fst$^    pyxerr0 0000 pyxl0error$^  $^  pyxt0  pyxvifstfst$^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s fst$^    pyxerr0 0000 pyxl0error$^  $^  pyxvselffst  pyxt0$^$^   pywrapfst.pyx0000$^       makes copy of the sharedptr potentially extending the fsts lifetime.$^      self.fst  ifst.fst$^      self.aiter.resetnew fst.arciteratorclassderefself.fst state              $^  $^     this just registers this class as a possible iterator.$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s aiter$^    pyxerr0 0000 pyxl0error$^  $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s fst$^    pyxerr0 0000 pyxl0error$^  $^  pyxvselfaiter.resetnew fstscriptarciteratorclasspyxvselffst pyxvstate$^$^   pywrapfst.pyx0000$^      return arciterator at 0xx.formatidself$^  $^    def initself fst ifst int00 state              $^      if not ifst.fst.get.validstateidstate$^        raise fstindexerrorstate index out of range$^ $^$^   function exit code $^  pyxr  0$^  goto pyxl0$^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.arciterator.init pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^  $^     this just registers this class as a possible iterator.$^    def iterself              $^      return self$^  $^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00arciterator0iterpyobject pyxvself proto$^static pyobject pyxpw0pywrapfst00arciterator0iterpyobject pyxvself $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextiter wrapper 0$^  pyxr  pyxpf0pywrapfst00arciterator0iterstruct pyxobj0pywrapfstarciterator pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00arciterator0iterstruct pyxobj0pywrapfstarciterator pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextiter 0$^$^   pywrapfst.pyx0000$^     this just registers this class as a possible iterator.$^    def iterself$^      return self              $^  $^     magic method used to get a pythonic api out of the c api.$^ $^  pyxxdecrefpyxr$^  pyxincrefpyobject pyxvself$^  pyxr  pyobject pyxvself$^  goto pyxl0$^$^   pywrapfst.pyx0000$^  $^     this just registers this class as a possible iterator.$^    def iterself              $^      return self$^  $^ $^$^   function exit code $^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^  $^     magic method used to get a pythonic api out of the c api.$^    def nextself              $^      if self.done$^        raise stopiteration$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00arciterator0nextpyobject pyxvself proto$^static pyobject pyxpw0pywrapfst00arciterator0nextpyobject pyxvself $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextnext wrapper 0$^  pyxr  pyxpf0pywrapfst00arciterator0nextstruct pyxobj0pywrapfstarciterator pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00arciterator0nextstruct pyxobj0pywrapfstarciterator pyxvself $^  pyobject pyxvresult  null$^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  int pyxt0$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextnext 0$^$^   pywrapfst.pyx0000$^     magic method used to get a pythonic api out of the c api.$^    def nextself$^      if self.done              $^        raise stopiteration$^      result  self.value$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s done$^    pyxerr0 0000 pyxl0error$^  $^  pyxt0  struct pyxvtabstruct0pywrapfstarciterator pyxvselfpyxvtabdonepyxvself 0  0$^  if unlikelypyxt0 $^$^     pywrapfst.pyx0000$^    def nextself$^      if self.done$^        raise stopiteration              $^      result  self.value$^      self.next$^ $^    pyxraisepyxbuiltinstopiteration 0 0 0$^    pyxerr0 0000 pyxl0error$^$^     pywrapfst.pyx0000$^     magic method used to get a pythonic api out of the c api.$^    def nextself$^      if self.done              $^        raise stopiteration$^      result  self.value$^ $^  $^$^   pywrapfst.pyx0000$^      if self.done$^        raise stopiteration$^      result  self.value              $^      self.next$^      return result$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s value$^    pyxerr0 0000 pyxl0error$^  $^  pyxt0  struct pyxvtabstruct0pywrapfstarciterator pyxvselfpyxvtabvaluepyxvself 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxvresult  pyxt0$^  pyxt0  0$^$^   pywrapfst.pyx0000$^        raise stopiteration$^      result  self.value$^      self.next              $^      return result$^  $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s next$^    pyxerr0 0000 pyxl0error$^  $^  struct pyxvtabstruct0pywrapfstarciterator pyxvselfpyxvtabnextpyxvself 0$^$^   pywrapfst.pyx0000$^      result  self.value$^      self.next$^      return result              $^  $^    cpdef bool doneself$^ $^  pyxxdecrefpyxr$^  pyxincrefpyxvresult$^  pyxr  pyxvresult$^  goto pyxl0$^$^   pywrapfst.pyx0000$^  $^     magic method used to get a pythonic api out of the c api.$^    def nextself              $^      if self.done$^        raise stopiteration$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.arciterator.next pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxdecrefpyxvresult$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return result$^  $^    cpdef bool doneself              $^      $^      doneself$^ $^$^static pyobject pyxpw0pywrapfst00arciterator0donepyobject pyxvself cythonunused pyobject unused proto$^static bool pyxf0pywrapfst00arciteratordonestruct pyxobj0pywrapfstarciterator pyxvself int pyxskipdispatch $^  bool pyxr$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  bool pyxt0$^  pyxrefnannysetupcontextdone 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnsdone if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst00arciterator0done $^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxdecrefpyxt0 pyxt0  0$^       else $^        pyxt0  pyxpyobjectcallnoargpyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      $^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxt0  pyxpyobjectistruepyxt0 if unlikelypyxt0  bool0  pyerroccurred pyxerr0 0000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxr  pyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx0000$^        true if the iterator is exhausted false otherwise.$^      $^      return self.aiter.get.done              $^  $^    cpdef uint00 flagsself$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s aiter$^    pyxerr0 0000 pyxl0error$^  $^  pyxr  pyxvselfaiter.getdone$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      return result$^  $^    cpdef bool doneself              $^      $^      doneself$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxwriteunraisablepywrapfst.arciterator.done pyxclineno pyxlineno pyxfilename 0 0$^  pyxr  0$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst00arciterator0donepyobject pyxvself cythonunused pyobject unused proto$^static char pyxdoc0pywrapfst00arciterator0done  n    doneselfnn    indicates whether the iterator is exhausted or not.nn    returnsn      true if the iterator is exhausted false otherwise.n    $^static pyobject pyxpw0pywrapfst00arciterator0donepyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextdone wrapper 0$^  pyxr  pyxpf0pywrapfst00arciterator0donestruct pyxobj0pywrapfstarciterator pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00arciterator0donestruct pyxobj0pywrapfstarciterator pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextdone 0$^  pyxxdecrefpyxr$^  pyxt0  pyxpyboolfromlongpyxf0pywrapfst00arciteratordonepyxvself 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.arciterator.done pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return self.aiter.get.done$^  $^    cpdef uint00 flagsself              $^      $^      flagsself$^ $^$^static pyobject pyxpw0pywrapfst00arciterator00flagspyobject pyxvself cythonunused pyobject unused proto$^static pyxt00basictypesuint00 pyxf0pywrapfst00arciteratorflagsstruct pyxobj0pywrapfstarciterator pyxvself int pyxskipdispatch $^  pyxt00basictypesuint00 pyxr$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxt00basictypesuint00 pyxt0$^  pyxrefnannysetupcontextflags 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnsflags if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst00arciterator00flags $^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxdecrefpyxt0 pyxt0  0$^       else $^        pyxt0  pyxpyobjectcallnoargpyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      $^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxt0  pyxpyintasuint00tpyxt0 if unlikelypyxt0  uint00t0  pyerroccurred pyxerr0 0000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxr  pyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx0000$^        the current iterator behavioral flags as an integer.$^      $^      return self.aiter.get.flags              $^  $^    cpdef void nextself$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s aiter$^    pyxerr0 0000 pyxl0error$^  $^  pyxr  pyxvselfaiter.getflags$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      return self.aiter.get.done$^  $^    cpdef uint00 flagsself              $^      $^      flagsself$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxwriteunraisablepywrapfst.arciterator.flags pyxclineno pyxlineno pyxfilename 0 0$^  pyxr  0$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst00arciterator00flagspyobject pyxvself cythonunused pyobject unused proto$^static char pyxdoc0pywrapfst00arciterator00flags  n    flagsselfnn    returns the current iterator behavioral flags.nn    returnsn      the current iterator behavioral flags as an integer.n    $^static pyobject pyxpw0pywrapfst00arciterator00flagspyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextflags wrapper 0$^  pyxr  pyxpf0pywrapfst00arciterator00flagsstruct pyxobj0pywrapfstarciterator pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00arciterator00flagsstruct pyxobj0pywrapfstarciterator pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextflags 0$^  pyxxdecrefpyxr$^  pyxt0  pyxpyintfromuint00tpyxf0pywrapfst00arciteratorflagspyxvself 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.arciterator.flags pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return self.aiter.get.flags$^  $^    cpdef void nextself              $^      $^      nextself$^ $^$^static pyobject pyxpw0pywrapfst00arciterator00nextpyobject pyxvself cythonunused pyobject unused proto$^static void pyxf0pywrapfst00arciteratornextstruct pyxobj0pywrapfstarciterator pyxvself int pyxskipdispatch $^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextnext 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnsnext if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst00arciterator00next $^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxdecrefpyxt0 pyxt0  0$^       else $^        pyxt0  pyxpyobjectcallnoargpyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      $^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx0000$^      advances the iterator.$^      $^      self.aiter.get.next              $^  $^    cpdef sizet positionself$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s aiter$^    pyxerr0 0000 pyxl0error$^  $^  pyxvselfaiter.getnext$^$^   pywrapfst.pyx0000$^      return self.aiter.get.flags$^  $^    cpdef void nextself              $^      $^      nextself$^ $^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxwriteunraisablepywrapfst.arciterator.next pyxclineno pyxlineno pyxfilename 0 0$^  pyxl0$^  pyxrefnannyfinishcontext$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst00arciterator00nextpyobject pyxvself cythonunused pyobject unused proto$^static char pyxdoc0pywrapfst00arciterator00next  n    nextselfnn    advances the iterator.n    $^static pyobject pyxpw0pywrapfst00arciterator00nextpyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextnext wrapper 0$^  pyxr  pyxpf0pywrapfst00arciterator00nextstruct pyxobj0pywrapfstarciterator pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00arciterator00nextstruct pyxobj0pywrapfstarciterator pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextnext 0$^  pyxxdecrefpyxr$^  pyxt0  pyxvoidtononepyxf0pywrapfst00arciteratornextpyxvself 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.arciterator.next pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      self.aiter.get.next$^  $^    cpdef sizet positionself              $^      $^      positionself$^ $^$^static pyobject pyxpw0pywrapfst00arciterator00positionpyobject pyxvself cythonunused pyobject unused proto$^static sizet pyxf0pywrapfst00arciteratorpositionstruct pyxobj0pywrapfstarciterator pyxvself int pyxskipdispatch $^  sizet pyxr$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  sizet pyxt0$^  pyxrefnannysetupcontextposition 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnsposition if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst00arciterator00position $^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxdecrefpyxt0 pyxt0  0$^       else $^        pyxt0  pyxpyobjectcallnoargpyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      $^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxt0  pyxpyintassizetpyxt0 if unlikelypyxt0  sizet0  pyerroccurred pyxerr0 0000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxr  pyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx0000$^        the iterators position expressed as an integer.$^      $^      return self.aiter.get.position              $^  $^    cpdef void resetself$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s aiter$^    pyxerr0 0000 pyxl0error$^  $^  pyxr  pyxvselfaiter.getposition$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      self.aiter.get.next$^  $^    cpdef sizet positionself              $^      $^      positionself$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxwriteunraisablepywrapfst.arciterator.position pyxclineno pyxlineno pyxfilename 0 0$^  pyxr  0$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst00arciterator00positionpyobject pyxvself cythonunused pyobject unused proto$^static char pyxdoc0pywrapfst00arciterator00position  n    positionselfnn    returns the position of the iterator.nn    returnsn      the iterators position expressed as an integer.n    $^static pyobject pyxpw0pywrapfst00arciterator00positionpyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextposition wrapper 0$^  pyxr  pyxpf0pywrapfst00arciterator00positionstruct pyxobj0pywrapfstarciterator pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00arciterator00positionstruct pyxobj0pywrapfstarciterator pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextposition 0$^  pyxxdecrefpyxr$^  pyxt0  pyxpyintfromsizetpyxf0pywrapfst00arciteratorpositionpyxvself 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.arciterator.position pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return self.aiter.get.position$^  $^    cpdef void resetself              $^      $^      resetself$^ $^$^static pyobject pyxpw0pywrapfst00arciterator00resetpyobject pyxvself cythonunused pyobject unused proto$^static void pyxf0pywrapfst00arciteratorresetstruct pyxobj0pywrapfstarciterator pyxvself int pyxskipdispatch $^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextreset 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnsreset if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst00arciterator00reset $^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxdecrefpyxt0 pyxt0  0$^       else $^        pyxt0  pyxpyobjectcallnoargpyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      $^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx0000$^      resets the iterator to the initial position.$^      $^      self.aiter.get.reset              $^  $^    cpdef void seekself sizet a$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s aiter$^    pyxerr0 0000 pyxl0error$^  $^  pyxvselfaiter.getreset$^$^   pywrapfst.pyx0000$^      return self.aiter.get.position$^  $^    cpdef void resetself              $^      $^      resetself$^ $^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxwriteunraisablepywrapfst.arciterator.reset pyxclineno pyxlineno pyxfilename 0 0$^  pyxl0$^  pyxrefnannyfinishcontext$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst00arciterator00resetpyobject pyxvself cythonunused pyobject unused proto$^static char pyxdoc0pywrapfst00arciterator00reset  n    resetselfnn    resets the iterator to the initial position.n    $^static pyobject pyxpw0pywrapfst00arciterator00resetpyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextreset wrapper 0$^  pyxr  pyxpf0pywrapfst00arciterator00resetstruct pyxobj0pywrapfstarciterator pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00arciterator00resetstruct pyxobj0pywrapfstarciterator pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextreset 0$^  pyxxdecrefpyxr$^  pyxt0  pyxvoidtononepyxf0pywrapfst00arciteratorresetpyxvself 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.arciterator.reset pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      self.aiter.get.reset$^  $^    cpdef void seekself sizet a              $^      $^      seekself a$^ $^$^static pyobject pyxpw0pywrapfst00arciterator00seekpyobject pyxvself pyobject pyxarga proto$^static void pyxf0pywrapfst00arciteratorseekstruct pyxobj0pywrapfstarciterator pyxvself sizet pyxva int pyxskipdispatch $^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextseek 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnsseek if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst00arciterator00seek $^      pyxt0  pyxpyintfromsizetpyxva if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxgotrefpyxt0$^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^       else $^        if cythonfastpycall$^        if pyfunctioncheckpyxt0 $^          pyobject pyxtemp0  pyxt0 pyxt0$^          pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^          pyxxdecrefpyxt0 pyxt0  0$^          pyxgotrefpyxt0$^          pyxdecrefpyxt0 pyxt0  0$^         else$^        endif$^        if cythonfastpyccall$^        if pyxpyfastcfunctioncheckpyxt0 $^          pyobject pyxtemp0  pyxt0 pyxt0$^          pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^          pyxxdecrefpyxt0 pyxt0  0$^          pyxgotrefpyxt0$^          pyxdecrefpyxt0 pyxt0  0$^         else$^        endif$^        $^          pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^          pyxgotrefpyxt0$^          pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^          pyxgiverefpyxt0$^          pytuplesetitempyxt0 00 pyxt0$^          pyxt0  0$^          pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^          pyxgotrefpyxt0$^          pyxdecrefpyxt0 pyxt0  0$^        $^      $^      pyxdecrefpyxt0 pyxt0  0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx0000$^        a the position to seek to.$^      $^      self.aiter.get.seeka              $^  $^    cpdef void setflagsself uint00 flags uint00 mask$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s aiter$^    pyxerr0 0000 pyxl0error$^  $^  pyxvselfaiter.getseekpyxva$^$^   pywrapfst.pyx0000$^      self.aiter.get.reset$^  $^    cpdef void seekself sizet a              $^      $^      seekself a$^ $^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxwriteunraisablepywrapfst.arciterator.seek pyxclineno pyxlineno pyxfilename 0 0$^  pyxl0$^  pyxrefnannyfinishcontext$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst00arciterator00seekpyobject pyxvself pyobject pyxarga proto$^static char pyxdoc0pywrapfst00arciterator00seek  n    seekself ann    advance the iterator to a new position.nn    argsn      a the position to seek to.n    $^static pyobject pyxpw0pywrapfst00arciterator00seekpyobject pyxvself pyobject pyxarga $^  sizet pyxva$^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextseek wrapper 0$^  assertpyxarga $^    pyxva  pyxpyintassizetpyxarga if unlikelypyxva  sizet0  pyerroccurred pyxerr0 0000 pyxl0error$^  $^  goto pyxl0argumentunpackingdone$^  pyxl0error$^  pyxaddtracebackpywrapfst.arciterator.seek pyxclineno pyxlineno pyxfilename$^  pyxrefnannyfinishcontext$^  return null$^  pyxl0argumentunpackingdone$^  pyxr  pyxpf0pywrapfst00arciterator00seekstruct pyxobj0pywrapfstarciterator pyxvself sizetpyxva$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00arciterator00seekstruct pyxobj0pywrapfstarciterator pyxvself sizet pyxva $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextseek 0$^  pyxxdecrefpyxr$^  pyxt0  pyxvoidtononepyxf0pywrapfst00arciteratorseekpyxvself pyxva 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.arciterator.seek pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      self.aiter.get.seeka$^  $^    cpdef void setflagsself uint00 flags uint00 mask              $^      $^      setflagsself flags mask$^ $^$^static pyobject pyxpw0pywrapfst00arciterator00setflagspyobject pyxvself pyobject pyxargs pyobject pyxkwds proto$^static void pyxf0pywrapfst00arciteratorsetflagsstruct pyxobj0pywrapfstarciterator pyxvself pyxt00basictypesuint00 pyxvflags pyxt00basictypesuint00 pyxvmask int pyxskipdispatch $^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  int pyxt0$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextsetflags 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnssetflags if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst00arciterator00setflags $^      pyxt0  pyxpyintfromuint00tpyxvflags if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxgotrefpyxt0$^      pyxt0  pyxpyintfromuint00tpyxvmask if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxgotrefpyxt0$^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      pyxt0  0$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^          pyxt0  0$^        $^      $^      if cythonfastpycall$^      if pyfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxt0 pyxt0$^        pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp0pyxt0 0pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^        pyxdecrefpyxt0 pyxt0  0$^       else$^      endif$^      if cythonfastpyccall$^      if pyxpyfastcfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxt0 pyxt0$^        pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp0pyxt0 0pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^        pyxdecrefpyxt0 pyxt0  0$^       else$^      endif$^      $^        pyxt0  pytuplenew0pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxgotrefpyxt0$^        if pyxt0 $^          pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^        $^        pyxgiverefpyxt0$^        pytuplesetitempyxt0 0pyxt0 pyxt0$^        pyxgiverefpyxt0$^        pytuplesetitempyxt0 0pyxt0 pyxt0$^        pyxt0  0$^        pyxt0  0$^        pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^      $^      pyxdecrefpyxt0 pyxt0  0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx0000$^        mask a mask to be applied to the flags argument before setting them.$^      $^      self.aiter.get.setflagsflags mask              $^  $^    cpdef object valueself$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s aiter$^    pyxerr0 0000 pyxl0error$^  $^  pyxvselfaiter.getsetflagspyxvflags pyxvmask$^$^   pywrapfst.pyx0000$^      self.aiter.get.seeka$^  $^    cpdef void setflagsself uint00 flags uint00 mask              $^      $^      setflagsself flags mask$^ $^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxwriteunraisablepywrapfst.arciterator.setflags pyxclineno pyxlineno pyxfilename 0 0$^  pyxl0$^  pyxrefnannyfinishcontext$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst00arciterator00setflagspyobject pyxvself pyobject pyxargs pyobject pyxkwds proto$^static char pyxdoc0pywrapfst00arciterator00setflags  n    setflagsself flags masknn    sets the current iterator behavioral flags.nn    argsn      flags the properties to be set.n      mask a mask to be applied to the flags argument before setting them.n    $^static pyobject pyxpw0pywrapfst00arciterator00setflagspyobject pyxvself pyobject pyxargs pyobject pyxkwds $^  pyxt00basictypesuint00 pyxvflags$^  pyxt00basictypesuint00 pyxvmask$^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextsetflags wrapper 0$^  $^    static pyobject pyxpyargnames  pyxnsflagspyxnsmask0$^    pyobject values0  00$^    if unlikelypyxkwds $^      pyssizet kwargs$^      const pyssizet posargs  pytuplegetsizepyxargs$^      switch posargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 break$^        default goto pyxl0argtupleerror$^      $^      kwargs  pydictsizepyxkwds$^      switch posargs $^        case  0$^        if likelyvalues0  pyxpydictgetitemstrpyxkwds pyxnsflags  0 kwargs$^        else goto pyxl0argtupleerror$^        cythonfallthrough$^        case  0$^        if likelyvalues0  pyxpydictgetitemstrpyxkwds pyxnsmask  0 kwargs$^        else $^          pyxraiseargtupleinvalidsetflags 0 0 0 0 pyxerr0 0000 pyxl0error$^        $^      $^      if unlikelykwargs  0 $^        if unlikelypyxparseoptionalkeywordspyxkwds pyxpyargnames 0 values posargs setflags  0 pyxerr0 0000 pyxl0error$^      $^     else if pytuplegetsizepyxargs  0 $^      goto pyxl0argtupleerror$^     else $^      values0  pytuplegetitempyxargs 0$^      values0  pytuplegetitempyxargs 0$^    $^    pyxvflags  pyxpyintasuint00tvalues0 if unlikelypyxvflags  uint00t0  pyerroccurred pyxerr0 0000 pyxl0error$^    pyxvmask  pyxpyintasuint00tvalues0 if unlikelypyxvmask  uint00t0  pyerroccurred pyxerr0 0000 pyxl0error$^  $^  goto pyxl0argumentunpackingdone$^  pyxl0argtupleerror$^  pyxraiseargtupleinvalidsetflags 0 0 0 pytuplegetsizepyxargs pyxerr0 0000 pyxl0error$^  pyxl0error$^  pyxaddtracebackpywrapfst.arciterator.setflags pyxclineno pyxlineno pyxfilename$^  pyxrefnannyfinishcontext$^  return null$^  pyxl0argumentunpackingdone$^  pyxr  pyxpf0pywrapfst00arciterator00setflagsstruct pyxobj0pywrapfstarciterator pyxvself pyxvflags pyxvmask$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00arciterator00setflagsstruct pyxobj0pywrapfstarciterator pyxvself pyxt00basictypesuint00 pyxvflags pyxt00basictypesuint00 pyxvmask $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextsetflags 0$^  pyxxdecrefpyxr$^  pyxt0  pyxvoidtononepyxf0pywrapfst00arciteratorsetflagspyxvself pyxvflags pyxvmask 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.arciterator.setflags pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      self.aiter.get.setflagsflags mask$^  $^    cpdef object valueself              $^      $^      valueself$^ $^$^static pyobject pyxpw0pywrapfst00arciterator00valuepyobject pyxvself cythonunused pyobject unused proto$^static pyobject pyxf0pywrapfst00arciteratorvaluestruct pyxobj0pywrapfstarciterator pyxvself int pyxskipdispatch $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextvalue 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnsvalue if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst00arciterator00value $^      pyxxdecrefpyxr$^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxdecrefpyxt0 pyxt0  0$^       else $^        pyxt0  pyxpyobjectcallnoargpyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      $^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxr  pyxt0$^      pyxt0  0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx0000$^      returns the current arc.$^      $^      return initarcself.aiter.get.value              $^  $^  $^ $^  pyxxdecrefpyxr$^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s aiter$^    pyxerr0 0000 pyxl0error$^  $^  pyxt0  pyobject pyxf0pywrapfstinitarcpyxvselfaiter.getvalue if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      self.aiter.get.setflagsflags mask$^  $^    cpdef object valueself              $^      $^      valueself$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.arciterator.value pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst00arciterator00valuepyobject pyxvself cythonunused pyobject unused proto$^static char pyxdoc0pywrapfst00arciterator00value  n    valueselfnn    returns the current arc.n    $^static pyobject pyxpw0pywrapfst00arciterator00valuepyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextvalue wrapper 0$^  pyxr  pyxpf0pywrapfst00arciterator00valuestruct pyxobj0pywrapfstarciterator pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00arciterator00valuestruct pyxobj0pywrapfstarciterator pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextvalue 0$^  pyxxdecrefpyxr$^  pyxt0  pyxf0pywrapfst00arciteratorvaluepyxvself 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.arciterator.value pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ tree fragment0$^  def reducecythonself              $^      raise typeerrorself.aiterself.fst cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00arciterator00reducecythonpyobject pyxvself cythonunused pyobject unused proto$^static pyobject pyxpw0pywrapfst00arciterator00reducecythonpyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextreducecython wrapper 0$^  pyxr  pyxpf0pywrapfst00arciterator00reducecythonstruct pyxobj0pywrapfstarciterator pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00arciterator00reducecythoncythonunused struct pyxobj0pywrapfstarciterator pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextreducecython 0$^$^   tree fragment0$^  def reducecythonself$^      raise typeerrorself.aiterself.fst cannot be converted to a python object for pickling              $^  def setstatecythonself pyxstate$^      raise typeerrorself.aiterself.fst cannot be converted to a python object for pickling$^ $^  pyxt0  pyxpyobjectcallpyxbuiltintypeerror pyxtuple00 null if unlikelypyxt0 pyxerr0 0 pyxl0error$^  pyxgotrefpyxt0$^  pyxraisepyxt0 0 0 0$^  pyxdecrefpyxt0 pyxt0  0$^  pyxerr0 0 pyxl0error$^$^   tree fragment0$^  def reducecythonself              $^      raise typeerrorself.aiterself.fst cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.arciterator.reducecython pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ tree fragment0$^  def reducecythonself$^      raise typeerrorself.aiterself.fst cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate              $^      raise typeerrorself.aiterself.fst cannot be converted to a python object for pickling$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00arciterator00setstatecythonpyobject pyxvself pyobject pyxvpyxstate proto$^static pyobject pyxpw0pywrapfst00arciterator00setstatecythonpyobject pyxvself pyobject pyxvpyxstate $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextsetstatecython wrapper 0$^  pyxr  pyxpf0pywrapfst00arciterator00setstatecythonstruct pyxobj0pywrapfstarciterator pyxvself pyobject pyxvpyxstate$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00arciterator00setstatecythoncythonunused struct pyxobj0pywrapfstarciterator pyxvself cythonunused pyobject pyxvpyxstate $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextsetstatecython 0$^$^   tree fragment0$^      raise typeerrorself.aiterself.fst cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate$^      raise typeerrorself.aiterself.fst cannot be converted to a python object for pickling              $^ $^  pyxt0  pyxpyobjectcallpyxbuiltintypeerror pyxtuple00 null if unlikelypyxt0 pyxerr0 0 pyxl0error$^  pyxgotrefpyxt0$^  pyxraisepyxt0 0 0 0$^  pyxdecrefpyxt0 pyxt0  0$^  pyxerr0 0 pyxl0error$^$^   tree fragment0$^  def reducecythonself$^      raise typeerrorself.aiterself.fst cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate              $^      raise typeerrorself.aiterself.fst cannot be converted to a python object for pickling$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.arciterator.setstatecython pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^    $^  $^    def reprself              $^      return mutablearciterator at 0xx.formatidself$^  $^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00mutablearciterator0reprpyobject pyxvself proto$^static pyobject pyxpw0pywrapfst00mutablearciterator0reprpyobject pyxvself $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextrepr wrapper 0$^  pyxr  pyxpf0pywrapfst00mutablearciteratorreprstruct pyxobj0pywrapfstmutablearciterator pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00mutablearciteratorreprstruct pyxobj0pywrapfstmutablearciterator pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextrepr 0$^$^   pywrapfst.pyx0000$^  $^    def reprself$^      return mutablearciterator at 0xx.formatidself              $^  $^    def initself mutablefst ifst int00 state$^ $^  pyxxdecrefpyxr$^  pyxt0  pyxpyobjectgetattrstrpyxkpsmutablearciteratorat0xx pyxnsformat if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxt0  pyxpyobjectcalloneargpyxbuiltinid pyobject pyxvself if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxt0  null$^  if cythonunpackmethods  likelypymethodcheckpyxt0 $^    pyxt0  pymethodgetselfpyxt0$^    if likelypyxt0 $^      pyobject function  pymethodgetfunctionpyxt0$^      pyxincrefpyxt0$^      pyxincreffunction$^      pyxdecrefsetpyxt0 function$^    $^  $^  if pyxt0 $^    pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxdecrefpyxt0 pyxt0  0$^    pyxgotrefpyxt0$^   else $^    if cythonfastpycall$^    if pyfunctioncheckpyxt0 $^      pyobject pyxtemp0  pyxt0 pyxt0$^      pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxxdecrefpyxt0 pyxt0  0$^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^     else$^    endif$^    if cythonfastpyccall$^    if pyxpyfastcfunctioncheckpyxt0 $^      pyobject pyxtemp0  pyxt0 pyxt0$^      pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxxdecrefpyxt0 pyxt0  0$^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^     else$^    endif$^    $^      pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxgotrefpyxt0$^      pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^      pyxgiverefpyxt0$^      pytuplesetitempyxt0 00 pyxt0$^      pyxt0  0$^      pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^    $^  $^  pyxdecrefpyxt0 pyxt0  0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   pywrapfst.pyx0000$^    $^  $^    def reprself              $^      return mutablearciterator at 0xx.formatidself$^  $^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.mutablearciterator.repr pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return mutablearciterator at 0xx.formatidself$^  $^    def initself mutablefst ifst int00 state              $^      if not ifst.fst.get.validstateidstate$^        raise fstindexerrorstate index out of range$^ $^$^ python wrapper $^static int pyxpw0pywrapfst00mutablearciterator0initpyobject pyxvself pyobject pyxargs pyobject pyxkwds proto$^static int pyxpw0pywrapfst00mutablearciterator0initpyobject pyxvself pyobject pyxargs pyobject pyxkwds $^  struct pyxobj0pywrapfstmutablefst pyxvifst  0$^  pyxt00basictypesint00 pyxvstate$^  int pyxr$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextinit wrapper 0$^  $^    static pyobject pyxpyargnames  pyxnsifstpyxnsstate0$^    pyobject values0  00$^    if unlikelypyxkwds $^      pyssizet kwargs$^      const pyssizet posargs  pytuplegetsizepyxargs$^      switch posargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 break$^        default goto pyxl0argtupleerror$^      $^      kwargs  pydictsizepyxkwds$^      switch posargs $^        case  0$^        if likelyvalues0  pyxpydictgetitemstrpyxkwds pyxnsifst  0 kwargs$^        else goto pyxl0argtupleerror$^        cythonfallthrough$^        case  0$^        if likelyvalues0  pyxpydictgetitemstrpyxkwds pyxnsstate  0 kwargs$^        else $^          pyxraiseargtupleinvalidinit 0 0 0 0 pyxerr0 0000 pyxl0error$^        $^      $^      if unlikelykwargs  0 $^        if unlikelypyxparseoptionalkeywordspyxkwds pyxpyargnames 0 values posargs init  0 pyxerr0 0000 pyxl0error$^      $^     else if pytuplegetsizepyxargs  0 $^      goto pyxl0argtupleerror$^     else $^      values0  pytuplegetitempyxargs 0$^      values0  pytuplegetitempyxargs 0$^    $^    pyxvifst  struct pyxobj0pywrapfstmutablefst values0$^    pyxvstate  pyxpyintasint00tvalues0 if unlikelypyxvstate  int00t0  pyerroccurred pyxerr0 0000 pyxl0error$^  $^  goto pyxl0argumentunpackingdone$^  pyxl0argtupleerror$^  pyxraiseargtupleinvalidinit 0 0 0 pytuplegetsizepyxargs pyxerr0 0000 pyxl0error$^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablearciterator.init pyxclineno pyxlineno pyxfilename$^  pyxrefnannyfinishcontext$^  return 0$^  pyxl0argumentunpackingdone$^  if unlikelypyxargtypetestpyobject pyxvifst pyxptype0pywrapfstmutablefst 0 ifst 0 pyxerr0 0000 pyxl0error$^  pyxr  pyxpf0pywrapfst00mutablearciterator0initstruct pyxobj0pywrapfstmutablearciterator pyxvself pyxvifst pyxvstate$^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxr  0$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static int pyxpf0pywrapfst00mutablearciterator0initstruct pyxobj0pywrapfstmutablearciterator pyxvself struct pyxobj0pywrapfstmutablefst pyxvifst pyxt00basictypesint00 pyxvstate $^  int pyxr$^  pyxrefnannydeclarations$^  int pyxt0$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  stdsharedptrfstscriptmutablefstclass  pyxt0$^  pyxrefnannysetupcontextinit 0$^$^   pywrapfst.pyx0000$^  $^    def initself mutablefst ifst int00 state$^      if not ifst.fst.get.validstateidstate              $^        raise fstindexerrorstate index out of range$^       makes copy of the sharedptr potentially extending the fsts lifetime.$^ $^  if unlikelypyobject pyxvifst  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s fst$^    pyxerr0 0000 pyxl0error$^  $^  pyxt0  pyxvifstpyxbase.fst.getvalidstateidpyxvstate  0  0$^  if unlikelypyxt0 $^$^     pywrapfst.pyx0000$^    def initself mutablefst ifst int00 state$^      if not ifst.fst.get.validstateidstate$^        raise fstindexerrorstate index out of range              $^       makes copy of the sharedptr potentially extending the fsts lifetime.$^      self.mfst  ifst.mfst$^ $^    pyxt0  pyxgetmoduleglobalnamepyxnsfstindexerror if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  pyxpyobjectcallpyxt0 pyxtuple00 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxraisepyxt0 0 0 0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxerr0 0000 pyxl0error$^$^     pywrapfst.pyx0000$^  $^    def initself mutablefst ifst int00 state$^      if not ifst.fst.get.validstateidstate              $^        raise fstindexerrorstate index out of range$^       makes copy of the sharedptr potentially extending the fsts lifetime.$^ $^  $^$^   pywrapfst.pyx0000$^        raise fstindexerrorstate index out of range$^       makes copy of the sharedptr potentially extending the fsts lifetime.$^      self.mfst  ifst.mfst              $^      self.aiter.resetnew fst.mutablearciteratorclassifst.mfst.get state$^  $^ $^  if unlikelypyobject pyxvifst  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s mfst$^    pyxerr0 0000 pyxl0error$^  $^  pyxt0  pyxvifstmfst$^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s mfst$^    pyxerr0 0000 pyxl0error$^  $^  pyxvselfmfst  pyxt0$^$^   pywrapfst.pyx0000$^       makes copy of the sharedptr potentially extending the fsts lifetime.$^      self.mfst  ifst.mfst$^      self.aiter.resetnew fst.mutablearciteratorclassifst.mfst.get state              $^  $^    cpdef bool doneself$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s aiter$^    pyxerr0 0000 pyxl0error$^  $^  if unlikelypyobject pyxvifst  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s mfst$^    pyxerr0 0000 pyxl0error$^  $^  pyxvselfaiter.resetnew fstscriptmutablearciteratorclasspyxvifstmfst.get pyxvstate$^$^   pywrapfst.pyx0000$^      return mutablearciterator at 0xx.formatidself$^  $^    def initself mutablefst ifst int00 state              $^      if not ifst.fst.get.validstateidstate$^        raise fstindexerrorstate index out of range$^ $^$^   function exit code $^  pyxr  0$^  goto pyxl0$^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.mutablearciterator.init pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      self.aiter.resetnew fst.mutablearciteratorclassifst.mfst.get state$^  $^    cpdef bool doneself              $^      $^      doneself$^ $^$^static pyobject pyxpw0pywrapfst00mutablearciterator0donepyobject pyxvself cythonunused pyobject unused proto$^static bool pyxf0pywrapfst00mutablearciteratordonestruct pyxobj0pywrapfstmutablearciterator pyxvself int pyxskipdispatch $^  bool pyxr$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  bool pyxt0$^  pyxrefnannysetupcontextdone 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnsdone if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst00mutablearciterator0done $^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxdecrefpyxt0 pyxt0  0$^       else $^        pyxt0  pyxpyobjectcallnoargpyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      $^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxt0  pyxpyobjectistruepyxt0 if unlikelypyxt0  bool0  pyerroccurred pyxerr0 0000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxr  pyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx0000$^        true if the iterator is exhausted false otherwise.$^      $^      return self.aiter.get.done              $^  $^    cpdef uint00 flagsself$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s aiter$^    pyxerr0 0000 pyxl0error$^  $^  pyxr  pyxvselfaiter.getdone$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      self.aiter.resetnew fst.mutablearciteratorclassifst.mfst.get state$^  $^    cpdef bool doneself              $^      $^      doneself$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxwriteunraisablepywrapfst.mutablearciterator.done pyxclineno pyxlineno pyxfilename 0 0$^  pyxr  0$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst00mutablearciterator0donepyobject pyxvself cythonunused pyobject unused proto$^static char pyxdoc0pywrapfst00mutablearciterator0done  n    doneselfnn    indicates whether the iterator is exhausted or not.nn    returnsn      true if the iterator is exhausted false otherwise.n    $^static pyobject pyxpw0pywrapfst00mutablearciterator0donepyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextdone wrapper 0$^  pyxr  pyxpf0pywrapfst00mutablearciterator0donestruct pyxobj0pywrapfstmutablearciterator pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00mutablearciterator0donestruct pyxobj0pywrapfstmutablearciterator pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextdone 0$^  pyxxdecrefpyxr$^  pyxt0  pyxpyboolfromlongpyxf0pywrapfst00mutablearciteratordonepyxvself 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.mutablearciterator.done pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return self.aiter.get.done$^  $^    cpdef uint00 flagsself              $^      $^      flagsself$^ $^$^static pyobject pyxpw0pywrapfst00mutablearciterator0flagspyobject pyxvself cythonunused pyobject unused proto$^static pyxt00basictypesuint00 pyxf0pywrapfst00mutablearciteratorflagsstruct pyxobj0pywrapfstmutablearciterator pyxvself int pyxskipdispatch $^  pyxt00basictypesuint00 pyxr$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxt00basictypesuint00 pyxt0$^  pyxrefnannysetupcontextflags 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnsflags if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst00mutablearciterator0flags $^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxdecrefpyxt0 pyxt0  0$^       else $^        pyxt0  pyxpyobjectcallnoargpyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      $^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxt0  pyxpyintasuint00tpyxt0 if unlikelypyxt0  uint00t0  pyerroccurred pyxerr0 0000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxr  pyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx0000$^        the current iterator behavioral flags as an integer.$^      $^      return self.aiter.get.flags              $^  $^    cpdef void nextself$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s aiter$^    pyxerr0 0000 pyxl0error$^  $^  pyxr  pyxvselfaiter.getflags$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      return self.aiter.get.done$^  $^    cpdef uint00 flagsself              $^      $^      flagsself$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxwriteunraisablepywrapfst.mutablearciterator.flags pyxclineno pyxlineno pyxfilename 0 0$^  pyxr  0$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst00mutablearciterator0flagspyobject pyxvself cythonunused pyobject unused proto$^static char pyxdoc0pywrapfst00mutablearciterator0flags  n    flagsselfnn    returns the current iterator behavioral flags.nn    returnsn      the current iterator behavioral flags as an integer.n    $^static pyobject pyxpw0pywrapfst00mutablearciterator0flagspyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextflags wrapper 0$^  pyxr  pyxpf0pywrapfst00mutablearciterator0flagsstruct pyxobj0pywrapfstmutablearciterator pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00mutablearciterator0flagsstruct pyxobj0pywrapfstmutablearciterator pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextflags 0$^  pyxxdecrefpyxr$^  pyxt0  pyxpyintfromuint00tpyxf0pywrapfst00mutablearciteratorflagspyxvself 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.mutablearciterator.flags pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return self.aiter.get.flags$^  $^    cpdef void nextself              $^      $^      nextself$^ $^$^static pyobject pyxpw0pywrapfst00mutablearciterator0nextpyobject pyxvself cythonunused pyobject unused proto$^static void pyxf0pywrapfst00mutablearciteratornextstruct pyxobj0pywrapfstmutablearciterator pyxvself int pyxskipdispatch $^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextnext 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnsnext if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst00mutablearciterator0next $^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxdecrefpyxt0 pyxt0  0$^       else $^        pyxt0  pyxpyobjectcallnoargpyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      $^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx0000$^      advances the iterator.$^      $^      self.aiter.get.next              $^  $^    cpdef sizet positionself$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s aiter$^    pyxerr0 0000 pyxl0error$^  $^  pyxvselfaiter.getnext$^$^   pywrapfst.pyx0000$^      return self.aiter.get.flags$^  $^    cpdef void nextself              $^      $^      nextself$^ $^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxwriteunraisablepywrapfst.mutablearciterator.next pyxclineno pyxlineno pyxfilename 0 0$^  pyxl0$^  pyxrefnannyfinishcontext$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst00mutablearciterator0nextpyobject pyxvself cythonunused pyobject unused proto$^static char pyxdoc0pywrapfst00mutablearciterator0next  n    nextselfnn    advances the iterator.n    $^static pyobject pyxpw0pywrapfst00mutablearciterator0nextpyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextnext wrapper 0$^  pyxr  pyxpf0pywrapfst00mutablearciterator0nextstruct pyxobj0pywrapfstmutablearciterator pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00mutablearciterator0nextstruct pyxobj0pywrapfstmutablearciterator pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextnext 0$^  pyxxdecrefpyxr$^  pyxt0  pyxvoidtononepyxf0pywrapfst00mutablearciteratornextpyxvself 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.mutablearciterator.next pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      self.aiter.get.next$^  $^    cpdef sizet positionself              $^      $^      positionself$^ $^$^static pyobject pyxpw0pywrapfst00mutablearciterator00positionpyobject pyxvself cythonunused pyobject unused proto$^static sizet pyxf0pywrapfst00mutablearciteratorpositionstruct pyxobj0pywrapfstmutablearciterator pyxvself int pyxskipdispatch $^  sizet pyxr$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  sizet pyxt0$^  pyxrefnannysetupcontextposition 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnsposition if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst00mutablearciterator00position $^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxdecrefpyxt0 pyxt0  0$^       else $^        pyxt0  pyxpyobjectcallnoargpyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      $^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxt0  pyxpyintassizetpyxt0 if unlikelypyxt0  sizet0  pyerroccurred pyxerr0 0000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxr  pyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx0000$^        the iterators position expressed as an integer.$^      $^      return self.aiter.get.position              $^  $^    cpdef void resetself$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s aiter$^    pyxerr0 0000 pyxl0error$^  $^  pyxr  pyxvselfaiter.getposition$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      self.aiter.get.next$^  $^    cpdef sizet positionself              $^      $^      positionself$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxwriteunraisablepywrapfst.mutablearciterator.position pyxclineno pyxlineno pyxfilename 0 0$^  pyxr  0$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst00mutablearciterator00positionpyobject pyxvself cythonunused pyobject unused proto$^static char pyxdoc0pywrapfst00mutablearciterator00position  n    positionselfnn    returns the position of the iterator.nn    returnsn      the iterators position expressed as an integer.n    $^static pyobject pyxpw0pywrapfst00mutablearciterator00positionpyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextposition wrapper 0$^  pyxr  pyxpf0pywrapfst00mutablearciterator00positionstruct pyxobj0pywrapfstmutablearciterator pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00mutablearciterator00positionstruct pyxobj0pywrapfstmutablearciterator pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextposition 0$^  pyxxdecrefpyxr$^  pyxt0  pyxpyintfromsizetpyxf0pywrapfst00mutablearciteratorpositionpyxvself 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.mutablearciterator.position pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return self.aiter.get.position$^  $^    cpdef void resetself              $^      $^      resetself$^ $^$^static pyobject pyxpw0pywrapfst00mutablearciterator00resetpyobject pyxvself cythonunused pyobject unused proto$^static void pyxf0pywrapfst00mutablearciteratorresetstruct pyxobj0pywrapfstmutablearciterator pyxvself int pyxskipdispatch $^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextreset 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnsreset if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst00mutablearciterator00reset $^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxdecrefpyxt0 pyxt0  0$^       else $^        pyxt0  pyxpyobjectcallnoargpyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      $^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx0000$^      resets the iterator to the initial position.$^      $^      self.aiter.get.reset              $^  $^    cpdef void seekself sizet a$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s aiter$^    pyxerr0 0000 pyxl0error$^  $^  pyxvselfaiter.getreset$^$^   pywrapfst.pyx0000$^      return self.aiter.get.position$^  $^    cpdef void resetself              $^      $^      resetself$^ $^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxwriteunraisablepywrapfst.mutablearciterator.reset pyxclineno pyxlineno pyxfilename 0 0$^  pyxl0$^  pyxrefnannyfinishcontext$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst00mutablearciterator00resetpyobject pyxvself cythonunused pyobject unused proto$^static char pyxdoc0pywrapfst00mutablearciterator00reset  n    resetselfnn    resets the iterator to the initial position.n    $^static pyobject pyxpw0pywrapfst00mutablearciterator00resetpyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextreset wrapper 0$^  pyxr  pyxpf0pywrapfst00mutablearciterator00resetstruct pyxobj0pywrapfstmutablearciterator pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00mutablearciterator00resetstruct pyxobj0pywrapfstmutablearciterator pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextreset 0$^  pyxxdecrefpyxr$^  pyxt0  pyxvoidtononepyxf0pywrapfst00mutablearciteratorresetpyxvself 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.mutablearciterator.reset pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      self.aiter.get.reset$^  $^    cpdef void seekself sizet a              $^      $^      seekself a$^ $^$^static pyobject pyxpw0pywrapfst00mutablearciterator00seekpyobject pyxvself pyobject pyxarga proto$^static void pyxf0pywrapfst00mutablearciteratorseekstruct pyxobj0pywrapfstmutablearciterator pyxvself sizet pyxva int pyxskipdispatch $^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextseek 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnsseek if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst00mutablearciterator00seek $^      pyxt0  pyxpyintfromsizetpyxva if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxgotrefpyxt0$^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^       else $^        if cythonfastpycall$^        if pyfunctioncheckpyxt0 $^          pyobject pyxtemp0  pyxt0 pyxt0$^          pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^          pyxxdecrefpyxt0 pyxt0  0$^          pyxgotrefpyxt0$^          pyxdecrefpyxt0 pyxt0  0$^         else$^        endif$^        if cythonfastpyccall$^        if pyxpyfastcfunctioncheckpyxt0 $^          pyobject pyxtemp0  pyxt0 pyxt0$^          pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^          pyxxdecrefpyxt0 pyxt0  0$^          pyxgotrefpyxt0$^          pyxdecrefpyxt0 pyxt0  0$^         else$^        endif$^        $^          pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^          pyxgotrefpyxt0$^          pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^          pyxgiverefpyxt0$^          pytuplesetitempyxt0 00 pyxt0$^          pyxt0  0$^          pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^          pyxgotrefpyxt0$^          pyxdecrefpyxt0 pyxt0  0$^        $^      $^      pyxdecrefpyxt0 pyxt0  0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx0000$^        a the position to seek to.$^      $^      self.aiter.get.seeka              $^  $^    cpdef void setflagsself uint00 flags uint00 mask$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s aiter$^    pyxerr0 0000 pyxl0error$^  $^  pyxvselfaiter.getseekpyxva$^$^   pywrapfst.pyx0000$^      self.aiter.get.reset$^  $^    cpdef void seekself sizet a              $^      $^      seekself a$^ $^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxwriteunraisablepywrapfst.mutablearciterator.seek pyxclineno pyxlineno pyxfilename 0 0$^  pyxl0$^  pyxrefnannyfinishcontext$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst00mutablearciterator00seekpyobject pyxvself pyobject pyxarga proto$^static char pyxdoc0pywrapfst00mutablearciterator00seek  n    seekself ann    advance the iterator to a new position.nn    argsn      a the position to seek to.n    $^static pyobject pyxpw0pywrapfst00mutablearciterator00seekpyobject pyxvself pyobject pyxarga $^  sizet pyxva$^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextseek wrapper 0$^  assertpyxarga $^    pyxva  pyxpyintassizetpyxarga if unlikelypyxva  sizet0  pyerroccurred pyxerr0 0000 pyxl0error$^  $^  goto pyxl0argumentunpackingdone$^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablearciterator.seek pyxclineno pyxlineno pyxfilename$^  pyxrefnannyfinishcontext$^  return null$^  pyxl0argumentunpackingdone$^  pyxr  pyxpf0pywrapfst00mutablearciterator00seekstruct pyxobj0pywrapfstmutablearciterator pyxvself sizetpyxva$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00mutablearciterator00seekstruct pyxobj0pywrapfstmutablearciterator pyxvself sizet pyxva $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextseek 0$^  pyxxdecrefpyxr$^  pyxt0  pyxvoidtononepyxf0pywrapfst00mutablearciteratorseekpyxvself pyxva 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.mutablearciterator.seek pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      self.aiter.get.seeka$^  $^    cpdef void setflagsself uint00 flags uint00 mask              $^      $^      setflagsself flags mask$^ $^$^static pyobject pyxpw0pywrapfst00mutablearciterator00setflagspyobject pyxvself pyobject pyxargs pyobject pyxkwds proto$^static void pyxf0pywrapfst00mutablearciteratorsetflagsstruct pyxobj0pywrapfstmutablearciterator pyxvself pyxt00basictypesuint00 pyxvflags pyxt00basictypesuint00 pyxvmask int pyxskipdispatch $^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  int pyxt0$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextsetflags 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnssetflags if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst00mutablearciterator00setflags $^      pyxt0  pyxpyintfromuint00tpyxvflags if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxgotrefpyxt0$^      pyxt0  pyxpyintfromuint00tpyxvmask if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxgotrefpyxt0$^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      pyxt0  0$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^          pyxt0  0$^        $^      $^      if cythonfastpycall$^      if pyfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxt0 pyxt0$^        pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp0pyxt0 0pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^        pyxdecrefpyxt0 pyxt0  0$^       else$^      endif$^      if cythonfastpyccall$^      if pyxpyfastcfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxt0 pyxt0$^        pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp0pyxt0 0pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^        pyxdecrefpyxt0 pyxt0  0$^       else$^      endif$^      $^        pyxt0  pytuplenew0pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxgotrefpyxt0$^        if pyxt0 $^          pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^        $^        pyxgiverefpyxt0$^        pytuplesetitempyxt0 0pyxt0 pyxt0$^        pyxgiverefpyxt0$^        pytuplesetitempyxt0 0pyxt0 pyxt0$^        pyxt0  0$^        pyxt0  0$^        pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^      $^      pyxdecrefpyxt0 pyxt0  0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx0000$^        mask a mask to be applied to the flags argument before setting them.$^      $^      self.aiter.get.setflagsflags mask              $^  $^    cpdef void setvalueself arc arc$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s aiter$^    pyxerr0 0000 pyxl0error$^  $^  pyxvselfaiter.getsetflagspyxvflags pyxvmask$^$^   pywrapfst.pyx0000$^      self.aiter.get.seeka$^  $^    cpdef void setflagsself uint00 flags uint00 mask              $^      $^      setflagsself flags mask$^ $^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxwriteunraisablepywrapfst.mutablearciterator.setflags pyxclineno pyxlineno pyxfilename 0 0$^  pyxl0$^  pyxrefnannyfinishcontext$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst00mutablearciterator00setflagspyobject pyxvself pyobject pyxargs pyobject pyxkwds proto$^static char pyxdoc0pywrapfst00mutablearciterator00setflags  n    setflagsself flags masknn    sets the current iterator behavioral flags.nn    argsn      flags the properties to be set.n      mask a mask to be applied to the flags argument before setting them.n    $^static pyobject pyxpw0pywrapfst00mutablearciterator00setflagspyobject pyxvself pyobject pyxargs pyobject pyxkwds $^  pyxt00basictypesuint00 pyxvflags$^  pyxt00basictypesuint00 pyxvmask$^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextsetflags wrapper 0$^  $^    static pyobject pyxpyargnames  pyxnsflagspyxnsmask0$^    pyobject values0  00$^    if unlikelypyxkwds $^      pyssizet kwargs$^      const pyssizet posargs  pytuplegetsizepyxargs$^      switch posargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 break$^        default goto pyxl0argtupleerror$^      $^      kwargs  pydictsizepyxkwds$^      switch posargs $^        case  0$^        if likelyvalues0  pyxpydictgetitemstrpyxkwds pyxnsflags  0 kwargs$^        else goto pyxl0argtupleerror$^        cythonfallthrough$^        case  0$^        if likelyvalues0  pyxpydictgetitemstrpyxkwds pyxnsmask  0 kwargs$^        else $^          pyxraiseargtupleinvalidsetflags 0 0 0 0 pyxerr0 0000 pyxl0error$^        $^      $^      if unlikelykwargs  0 $^        if unlikelypyxparseoptionalkeywordspyxkwds pyxpyargnames 0 values posargs setflags  0 pyxerr0 0000 pyxl0error$^      $^     else if pytuplegetsizepyxargs  0 $^      goto pyxl0argtupleerror$^     else $^      values0  pytuplegetitempyxargs 0$^      values0  pytuplegetitempyxargs 0$^    $^    pyxvflags  pyxpyintasuint00tvalues0 if unlikelypyxvflags  uint00t0  pyerroccurred pyxerr0 0000 pyxl0error$^    pyxvmask  pyxpyintasuint00tvalues0 if unlikelypyxvmask  uint00t0  pyerroccurred pyxerr0 0000 pyxl0error$^  $^  goto pyxl0argumentunpackingdone$^  pyxl0argtupleerror$^  pyxraiseargtupleinvalidsetflags 0 0 0 pytuplegetsizepyxargs pyxerr0 0000 pyxl0error$^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablearciterator.setflags pyxclineno pyxlineno pyxfilename$^  pyxrefnannyfinishcontext$^  return null$^  pyxl0argumentunpackingdone$^  pyxr  pyxpf0pywrapfst00mutablearciterator00setflagsstruct pyxobj0pywrapfstmutablearciterator pyxvself pyxvflags pyxvmask$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00mutablearciterator00setflagsstruct pyxobj0pywrapfstmutablearciterator pyxvself pyxt00basictypesuint00 pyxvflags pyxt00basictypesuint00 pyxvmask $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextsetflags 0$^  pyxxdecrefpyxr$^  pyxt0  pyxvoidtononepyxf0pywrapfst00mutablearciteratorsetflagspyxvself pyxvflags pyxvmask 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.mutablearciterator.setflags pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      self.aiter.get.setflagsflags mask$^  $^    cpdef void setvalueself arc arc              $^      $^      setvalueself arc$^ $^$^static pyobject pyxpw0pywrapfst00mutablearciterator00setvaluepyobject pyxvself pyobject pyxvarc proto$^static void pyxf0pywrapfst00mutablearciteratorsetvaluestruct pyxobj0pywrapfstmutablearciterator pyxvself struct pyxobj0pywrapfstarc pyxvarc int pyxskipdispatch $^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextsetvalue 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnssetvalue if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst00mutablearciterator00setvalue $^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyobject pyxvarc if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxgotrefpyxt0$^       else $^        if cythonfastpycall$^        if pyfunctioncheckpyxt0 $^          pyobject pyxtemp0  pyxt0 pyobject pyxvarc$^          pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^          pyxxdecrefpyxt0 pyxt0  0$^          pyxgotrefpyxt0$^         else$^        endif$^        if cythonfastpyccall$^        if pyxpyfastcfunctioncheckpyxt0 $^          pyobject pyxtemp0  pyxt0 pyobject pyxvarc$^          pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^          pyxxdecrefpyxt0 pyxt0  0$^          pyxgotrefpyxt0$^         else$^        endif$^        $^          pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^          pyxgotrefpyxt0$^          pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^          pyxincrefpyobject pyxvarc$^          pyxgiverefpyobject pyxvarc$^          pytuplesetitempyxt0 00 pyobject pyxvarc$^          pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^          pyxgotrefpyxt0$^          pyxdecrefpyxt0 pyxt0  0$^        $^      $^      pyxdecrefpyxt0 pyxt0  0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx0000$^        arc the arc to replace the current arc with.$^      $^      self.aiter.get.setvaluederefarc.arc              $^  $^    cpdef object valueself$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s aiter$^    pyxerr0 0000 pyxl0error$^  $^  if unlikelypyobject pyxvarc  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s arc$^    pyxerr0 0000 pyxl0error$^  $^  pyxvselfaiter.getsetvaluepyxvarcarc$^$^   pywrapfst.pyx0000$^      self.aiter.get.setflagsflags mask$^  $^    cpdef void setvalueself arc arc              $^      $^      setvalueself arc$^ $^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxwriteunraisablepywrapfst.mutablearciterator.setvalue pyxclineno pyxlineno pyxfilename 0 0$^  pyxl0$^  pyxrefnannyfinishcontext$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst00mutablearciterator00setvaluepyobject pyxvself pyobject pyxvarc proto$^static char pyxdoc0pywrapfst00mutablearciterator00setvalue  n    setvalueself arcnn    replace the current arc with a new arc.nn    argsn      arc the arc to replace the current arc with.n    $^static pyobject pyxpw0pywrapfst00mutablearciterator00setvaluepyobject pyxvself pyobject pyxvarc $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextsetvalue wrapper 0$^  if unlikelypyxargtypetestpyobject pyxvarc pyxptype0pywrapfstarc 0 arc 0 pyxerr0 0000 pyxl0error$^  pyxr  pyxpf0pywrapfst00mutablearciterator00setvaluestruct pyxobj0pywrapfstmutablearciterator pyxvself struct pyxobj0pywrapfstarc pyxvarc$^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxr  null$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00mutablearciterator00setvaluestruct pyxobj0pywrapfstmutablearciterator pyxvself struct pyxobj0pywrapfstarc pyxvarc $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextsetvalue 0$^  pyxxdecrefpyxr$^  pyxt0  pyxvoidtononepyxf0pywrapfst00mutablearciteratorsetvaluepyxvself pyxvarc 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.mutablearciterator.setvalue pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      self.aiter.get.setvaluederefarc.arc$^  $^    cpdef object valueself              $^      $^      valueself$^ $^$^static pyobject pyxpw0pywrapfst00mutablearciterator00valuepyobject pyxvself cythonunused pyobject unused proto$^static pyobject pyxf0pywrapfst00mutablearciteratorvaluestruct pyxobj0pywrapfstmutablearciterator pyxvself int pyxskipdispatch $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextvalue 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnsvalue if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst00mutablearciterator00value $^      pyxxdecrefpyxr$^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxdecrefpyxt0 pyxt0  0$^       else $^        pyxt0  pyxpyobjectcallnoargpyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      $^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxr  pyxt0$^      pyxt0  0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx0000$^      returns the current arc.$^      $^      return initarcself.aiter.get.value              $^  $^  $^ $^  pyxxdecrefpyxr$^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s aiter$^    pyxerr0 0000 pyxl0error$^  $^  pyxt0  pyobject pyxf0pywrapfstinitarcpyxvselfaiter.getvalue if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      self.aiter.get.setvaluederefarc.arc$^  $^    cpdef object valueself              $^      $^      valueself$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.mutablearciterator.value pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst00mutablearciterator00valuepyobject pyxvself cythonunused pyobject unused proto$^static char pyxdoc0pywrapfst00mutablearciterator00value  n    valueselfnn    returns the current arc.n    $^static pyobject pyxpw0pywrapfst00mutablearciterator00valuepyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextvalue wrapper 0$^  pyxr  pyxpf0pywrapfst00mutablearciterator00valuestruct pyxobj0pywrapfstmutablearciterator pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00mutablearciterator00valuestruct pyxobj0pywrapfstmutablearciterator pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextvalue 0$^  pyxxdecrefpyxr$^  pyxt0  pyxf0pywrapfst00mutablearciteratorvaluepyxvself 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.mutablearciterator.value pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ tree fragment0$^  def reducecythonself              $^      raise typeerrorself.aiterself.mfst cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00mutablearciterator00reducecythonpyobject pyxvself cythonunused pyobject unused proto$^static pyobject pyxpw0pywrapfst00mutablearciterator00reducecythonpyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextreducecython wrapper 0$^  pyxr  pyxpf0pywrapfst00mutablearciterator00reducecythonstruct pyxobj0pywrapfstmutablearciterator pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00mutablearciterator00reducecythoncythonunused struct pyxobj0pywrapfstmutablearciterator pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextreducecython 0$^$^   tree fragment0$^  def reducecythonself$^      raise typeerrorself.aiterself.mfst cannot be converted to a python object for pickling              $^  def setstatecythonself pyxstate$^      raise typeerrorself.aiterself.mfst cannot be converted to a python object for pickling$^ $^  pyxt0  pyxpyobjectcallpyxbuiltintypeerror pyxtuple00 null if unlikelypyxt0 pyxerr0 0 pyxl0error$^  pyxgotrefpyxt0$^  pyxraisepyxt0 0 0 0$^  pyxdecrefpyxt0 pyxt0  0$^  pyxerr0 0 pyxl0error$^$^   tree fragment0$^  def reducecythonself              $^      raise typeerrorself.aiterself.mfst cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.mutablearciterator.reducecython pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ tree fragment0$^  def reducecythonself$^      raise typeerrorself.aiterself.mfst cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate              $^      raise typeerrorself.aiterself.mfst cannot be converted to a python object for pickling$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00mutablearciterator00setstatecythonpyobject pyxvself pyobject pyxvpyxstate proto$^static pyobject pyxpw0pywrapfst00mutablearciterator00setstatecythonpyobject pyxvself pyobject pyxvpyxstate $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextsetstatecython wrapper 0$^  pyxr  pyxpf0pywrapfst00mutablearciterator00setstatecythonstruct pyxobj0pywrapfstmutablearciterator pyxvself pyobject pyxvpyxstate$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00mutablearciterator00setstatecythoncythonunused struct pyxobj0pywrapfstmutablearciterator pyxvself cythonunused pyobject pyxvpyxstate $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextsetstatecython 0$^$^   tree fragment0$^      raise typeerrorself.aiterself.mfst cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate$^      raise typeerrorself.aiterself.mfst cannot be converted to a python object for pickling              $^ $^  pyxt0  pyxpyobjectcallpyxbuiltintypeerror pyxtuple00 null if unlikelypyxt0 pyxerr0 0 pyxl0error$^  pyxgotrefpyxt0$^  pyxraisepyxt0 0 0 0$^  pyxdecrefpyxt0 pyxt0  0$^  pyxerr0 0 pyxl0error$^$^   tree fragment0$^  def reducecythonself$^      raise typeerrorself.aiterself.mfst cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate              $^      raise typeerrorself.aiterself.mfst cannot be converted to a python object for pickling$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.mutablearciterator.setstatecython pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^    $^  $^    def reprself              $^      return stateiterator at 0xx.formatidself$^  $^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00stateiterator0reprpyobject pyxvself proto$^static pyobject pyxpw0pywrapfst00stateiterator0reprpyobject pyxvself $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextrepr wrapper 0$^  pyxr  pyxpf0pywrapfst00stateiteratorreprstruct pyxobj0pywrapfststateiterator pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00stateiteratorreprstruct pyxobj0pywrapfststateiterator pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextrepr 0$^$^   pywrapfst.pyx0000$^  $^    def reprself$^      return stateiterator at 0xx.formatidself              $^  $^    def initself fst ifst$^ $^  pyxxdecrefpyxr$^  pyxt0  pyxpyobjectgetattrstrpyxkpsstateiteratorat0xx pyxnsformat if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxt0  pyxpyobjectcalloneargpyxbuiltinid pyobject pyxvself if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxt0  null$^  if cythonunpackmethods  likelypymethodcheckpyxt0 $^    pyxt0  pymethodgetselfpyxt0$^    if likelypyxt0 $^      pyobject function  pymethodgetfunctionpyxt0$^      pyxincrefpyxt0$^      pyxincreffunction$^      pyxdecrefsetpyxt0 function$^    $^  $^  if pyxt0 $^    pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxdecrefpyxt0 pyxt0  0$^    pyxgotrefpyxt0$^   else $^    if cythonfastpycall$^    if pyfunctioncheckpyxt0 $^      pyobject pyxtemp0  pyxt0 pyxt0$^      pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxxdecrefpyxt0 pyxt0  0$^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^     else$^    endif$^    if cythonfastpyccall$^    if pyxpyfastcfunctioncheckpyxt0 $^      pyobject pyxtemp0  pyxt0 pyxt0$^      pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxxdecrefpyxt0 pyxt0  0$^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^     else$^    endif$^    $^      pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxgotrefpyxt0$^      pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^      pyxgiverefpyxt0$^      pytuplesetitempyxt0 00 pyxt0$^      pyxt0  0$^      pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^    $^  $^  pyxdecrefpyxt0 pyxt0  0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   pywrapfst.pyx0000$^    $^  $^    def reprself              $^      return stateiterator at 0xx.formatidself$^  $^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.stateiterator.repr pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return stateiterator at 0xx.formatidself$^  $^    def initself fst ifst              $^       makes copy of the sharedptr potentially extending the fsts lifetime.$^      self.fst  ifst.fst$^ $^$^ python wrapper $^static int pyxpw0pywrapfst00stateiterator0initpyobject pyxvself pyobject pyxargs pyobject pyxkwds proto$^static int pyxpw0pywrapfst00stateiterator0initpyobject pyxvself pyobject pyxargs pyobject pyxkwds $^  struct pyxobj0pywrapfstfst pyxvifst  0$^  int pyxr$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextinit wrapper 0$^  $^    static pyobject pyxpyargnames  pyxnsifst0$^    pyobject values0  0$^    if unlikelypyxkwds $^      pyssizet kwargs$^      const pyssizet posargs  pytuplegetsizepyxargs$^      switch posargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 break$^        default goto pyxl0argtupleerror$^      $^      kwargs  pydictsizepyxkwds$^      switch posargs $^        case  0$^        if likelyvalues0  pyxpydictgetitemstrpyxkwds pyxnsifst  0 kwargs$^        else goto pyxl0argtupleerror$^      $^      if unlikelykwargs  0 $^        if unlikelypyxparseoptionalkeywordspyxkwds pyxpyargnames 0 values posargs init  0 pyxerr0 0000 pyxl0error$^      $^     else if pytuplegetsizepyxargs  0 $^      goto pyxl0argtupleerror$^     else $^      values0  pytuplegetitempyxargs 0$^    $^    pyxvifst  struct pyxobj0pywrapfstfst values0$^  $^  goto pyxl0argumentunpackingdone$^  pyxl0argtupleerror$^  pyxraiseargtupleinvalidinit 0 0 0 pytuplegetsizepyxargs pyxerr0 0000 pyxl0error$^  pyxl0error$^  pyxaddtracebackpywrapfst.stateiterator.init pyxclineno pyxlineno pyxfilename$^  pyxrefnannyfinishcontext$^  return 0$^  pyxl0argumentunpackingdone$^  if unlikelypyxargtypetestpyobject pyxvifst pyxptype0pywrapfstfst 0 ifst 0 pyxerr0 0000 pyxl0error$^  pyxr  pyxpf0pywrapfst00stateiterator0initstruct pyxobj0pywrapfststateiterator pyxvself pyxvifst$^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxr  0$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static int pyxpf0pywrapfst00stateiterator0initstruct pyxobj0pywrapfststateiterator pyxvself struct pyxobj0pywrapfstfst pyxvifst $^  int pyxr$^  pyxrefnannydeclarations$^  stdsharedptrfstscriptfstclass  pyxt0$^  pyxrefnannysetupcontextinit 0$^$^   pywrapfst.pyx0000$^    def initself fst ifst$^       makes copy of the sharedptr potentially extending the fsts lifetime.$^      self.fst  ifst.fst              $^      self.siter.resetnew fst.stateiteratorclassderefself.fst$^  $^ $^  if unlikelypyobject pyxvifst  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s fst$^    pyxerr0 0000 pyxl0error$^  $^  pyxt0  pyxvifstfst$^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s fst$^    pyxerr0 0000 pyxl0error$^  $^  pyxvselffst  pyxt0$^$^   pywrapfst.pyx0000$^       makes copy of the sharedptr potentially extending the fsts lifetime.$^      self.fst  ifst.fst$^      self.siter.resetnew fst.stateiteratorclassderefself.fst              $^  $^     this just registers this class as a possible iterator.$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s siter$^    pyxerr0 0000 pyxl0error$^  $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s fst$^    pyxerr0 0000 pyxl0error$^  $^  pyxvselfsiter.resetnew fstscriptstateiteratorclasspyxvselffst$^$^   pywrapfst.pyx0000$^      return stateiterator at 0xx.formatidself$^  $^    def initself fst ifst              $^       makes copy of the sharedptr potentially extending the fsts lifetime.$^      self.fst  ifst.fst$^ $^$^   function exit code $^  pyxr  0$^  goto pyxl0$^  pyxl0error$^  pyxaddtracebackpywrapfst.stateiterator.init pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^  $^     this just registers this class as a possible iterator.$^    def iterself              $^      return self$^  $^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00stateiterator0iterpyobject pyxvself proto$^static pyobject pyxpw0pywrapfst00stateiterator0iterpyobject pyxvself $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextiter wrapper 0$^  pyxr  pyxpf0pywrapfst00stateiterator0iterstruct pyxobj0pywrapfststateiterator pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00stateiterator0iterstruct pyxobj0pywrapfststateiterator pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextiter 0$^$^   pywrapfst.pyx0000$^     this just registers this class as a possible iterator.$^    def iterself$^      return self              $^  $^     magic method used to get a pythonic api out of the c api.$^ $^  pyxxdecrefpyxr$^  pyxincrefpyobject pyxvself$^  pyxr  pyobject pyxvself$^  goto pyxl0$^$^   pywrapfst.pyx0000$^  $^     this just registers this class as a possible iterator.$^    def iterself              $^      return self$^  $^ $^$^   function exit code $^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^  $^     magic method used to get a pythonic api out of the c api.$^    def nextself              $^      if self.done$^        raise stopiteration$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00stateiterator0nextpyobject pyxvself proto$^static pyobject pyxpw0pywrapfst00stateiterator0nextpyobject pyxvself $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextnext wrapper 0$^  pyxr  pyxpf0pywrapfst00stateiterator0nextstruct pyxobj0pywrapfststateiterator pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00stateiterator0nextstruct pyxobj0pywrapfststateiterator pyxvself $^  pyxt00basictypesint00 pyxvresult$^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  int pyxt0$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextnext 0$^$^   pywrapfst.pyx0000$^     magic method used to get a pythonic api out of the c api.$^    def nextself$^      if self.done              $^        raise stopiteration$^      cdef int00 result  self.value$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s done$^    pyxerr0 0000 pyxl0error$^  $^  pyxt0  struct pyxvtabstruct0pywrapfststateiterator pyxvselfpyxvtabdonepyxvself 0  0$^  if unlikelypyxt0 $^$^     pywrapfst.pyx0000$^    def nextself$^      if self.done$^        raise stopiteration              $^      cdef int00 result  self.value$^      self.next$^ $^    pyxraisepyxbuiltinstopiteration 0 0 0$^    pyxerr0 0000 pyxl0error$^$^     pywrapfst.pyx0000$^     magic method used to get a pythonic api out of the c api.$^    def nextself$^      if self.done              $^        raise stopiteration$^      cdef int00 result  self.value$^ $^  $^$^   pywrapfst.pyx0000$^      if self.done$^        raise stopiteration$^      cdef int00 result  self.value              $^      self.next$^      return result$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s value$^    pyxerr0 0000 pyxl0error$^  $^  pyxvresult  struct pyxvtabstruct0pywrapfststateiterator pyxvselfpyxvtabvaluepyxvself 0$^$^   pywrapfst.pyx0000$^        raise stopiteration$^      cdef int00 result  self.value$^      self.next              $^      return result$^  $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s next$^    pyxerr0 0000 pyxl0error$^  $^  struct pyxvtabstruct0pywrapfststateiterator pyxvselfpyxvtabnextpyxvself 0$^$^   pywrapfst.pyx0000$^      cdef int00 result  self.value$^      self.next$^      return result              $^  $^    cpdef bool doneself$^ $^  pyxxdecrefpyxr$^  pyxt0  pyxpyintfromint00tpyxvresult if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   pywrapfst.pyx0000$^  $^     magic method used to get a pythonic api out of the c api.$^    def nextself              $^      if self.done$^        raise stopiteration$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.stateiterator.next pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return result$^  $^    cpdef bool doneself              $^      $^      doneself$^ $^$^static pyobject pyxpw0pywrapfst00stateiterator0donepyobject pyxvself cythonunused pyobject unused proto$^static bool pyxf0pywrapfst00stateiteratordonestruct pyxobj0pywrapfststateiterator pyxvself int pyxskipdispatch $^  bool pyxr$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  bool pyxt0$^  pyxrefnannysetupcontextdone 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnsdone if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst00stateiterator0done $^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxdecrefpyxt0 pyxt0  0$^       else $^        pyxt0  pyxpyobjectcallnoargpyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      $^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxt0  pyxpyobjectistruepyxt0 if unlikelypyxt0  bool0  pyerroccurred pyxerr0 0000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxr  pyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx0000$^        true if the iterator is exhausted false otherwise.$^      $^      return self.siter.get.done              $^  $^    cpdef void nextself$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s siter$^    pyxerr0 0000 pyxl0error$^  $^  pyxr  pyxvselfsiter.getdone$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      return result$^  $^    cpdef bool doneself              $^      $^      doneself$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxwriteunraisablepywrapfst.stateiterator.done pyxclineno pyxlineno pyxfilename 0 0$^  pyxr  0$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst00stateiterator0donepyobject pyxvself cythonunused pyobject unused proto$^static char pyxdoc0pywrapfst00stateiterator0done  n    doneselfnn    indicates whether the iterator is exhausted or not.nn    returnsn      true if the iterator is exhausted false otherwise.n    $^static pyobject pyxpw0pywrapfst00stateiterator0donepyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextdone wrapper 0$^  pyxr  pyxpf0pywrapfst00stateiterator0donestruct pyxobj0pywrapfststateiterator pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00stateiterator0donestruct pyxobj0pywrapfststateiterator pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextdone 0$^  pyxxdecrefpyxr$^  pyxt0  pyxpyboolfromlongpyxf0pywrapfst00stateiteratordonepyxvself 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.stateiterator.done pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return self.siter.get.done$^  $^    cpdef void nextself              $^      $^      nextself$^ $^$^static pyobject pyxpw0pywrapfst00stateiterator00nextpyobject pyxvself cythonunused pyobject unused proto$^static void pyxf0pywrapfst00stateiteratornextstruct pyxobj0pywrapfststateiterator pyxvself int pyxskipdispatch $^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextnext 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnsnext if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst00stateiterator00next $^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxdecrefpyxt0 pyxt0  0$^       else $^        pyxt0  pyxpyobjectcallnoargpyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      $^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx0000$^      advances the iterator.$^      $^      self.siter.get.next              $^  $^    cpdef void resetself$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s siter$^    pyxerr0 0000 pyxl0error$^  $^  pyxvselfsiter.getnext$^$^   pywrapfst.pyx0000$^      return self.siter.get.done$^  $^    cpdef void nextself              $^      $^      nextself$^ $^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxwriteunraisablepywrapfst.stateiterator.next pyxclineno pyxlineno pyxfilename 0 0$^  pyxl0$^  pyxrefnannyfinishcontext$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst00stateiterator00nextpyobject pyxvself cythonunused pyobject unused proto$^static char pyxdoc0pywrapfst00stateiterator00next  n    nextselfnn    advances the iterator.n    $^static pyobject pyxpw0pywrapfst00stateiterator00nextpyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextnext wrapper 0$^  pyxr  pyxpf0pywrapfst00stateiterator00nextstruct pyxobj0pywrapfststateiterator pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00stateiterator00nextstruct pyxobj0pywrapfststateiterator pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextnext 0$^  pyxxdecrefpyxr$^  pyxt0  pyxvoidtononepyxf0pywrapfst00stateiteratornextpyxvself 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.stateiterator.next pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      self.siter.get.next$^  $^    cpdef void resetself              $^      $^      resetself$^ $^$^static pyobject pyxpw0pywrapfst00stateiterator00resetpyobject pyxvself cythonunused pyobject unused proto$^static void pyxf0pywrapfst00stateiteratorresetstruct pyxobj0pywrapfststateiterator pyxvself int pyxskipdispatch $^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextreset 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnsreset if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst00stateiterator00reset $^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxdecrefpyxt0 pyxt0  0$^       else $^        pyxt0  pyxpyobjectcallnoargpyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      $^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx0000$^      resets the iterator to the initial position.$^      $^      self.siter.get.reset              $^  $^    cpdef int00 valueself$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s siter$^    pyxerr0 0000 pyxl0error$^  $^  pyxvselfsiter.getreset$^$^   pywrapfst.pyx0000$^      self.siter.get.next$^  $^    cpdef void resetself              $^      $^      resetself$^ $^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxwriteunraisablepywrapfst.stateiterator.reset pyxclineno pyxlineno pyxfilename 0 0$^  pyxl0$^  pyxrefnannyfinishcontext$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst00stateiterator00resetpyobject pyxvself cythonunused pyobject unused proto$^static char pyxdoc0pywrapfst00stateiterator00reset  n    resetselfnn    resets the iterator to the initial position.n    $^static pyobject pyxpw0pywrapfst00stateiterator00resetpyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextreset wrapper 0$^  pyxr  pyxpf0pywrapfst00stateiterator00resetstruct pyxobj0pywrapfststateiterator pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00stateiterator00resetstruct pyxobj0pywrapfststateiterator pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextreset 0$^  pyxxdecrefpyxr$^  pyxt0  pyxvoidtononepyxf0pywrapfst00stateiteratorresetpyxvself 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.stateiterator.reset pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      self.siter.get.reset$^  $^    cpdef int00 valueself              $^      $^      valueself$^ $^$^static pyobject pyxpw0pywrapfst00stateiterator00valuepyobject pyxvself cythonunused pyobject unused proto$^static pyxt00basictypesint00 pyxf0pywrapfst00stateiteratorvaluestruct pyxobj0pywrapfststateiterator pyxvself int pyxskipdispatch $^  pyxt00basictypesint00 pyxr$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxt00basictypesint00 pyxt0$^  pyxrefnannysetupcontextvalue 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnsvalue if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst00stateiterator00value $^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxdecrefpyxt0 pyxt0  0$^       else $^        pyxt0  pyxpyobjectcallnoargpyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      $^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxt0  pyxpyintasint00tpyxt0 if unlikelypyxt0  int00t0  pyerroccurred pyxerr0 0000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxr  pyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx0000$^      returns the current state index.$^      $^      return self.siter.get.value              $^  $^  $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s siter$^    pyxerr0 0000 pyxl0error$^  $^  pyxr  pyxvselfsiter.getvalue$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      self.siter.get.reset$^  $^    cpdef int00 valueself              $^      $^      valueself$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxwriteunraisablepywrapfst.stateiterator.value pyxclineno pyxlineno pyxfilename 0 0$^  pyxr  0$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst00stateiterator00valuepyobject pyxvself cythonunused pyobject unused proto$^static char pyxdoc0pywrapfst00stateiterator00value  n    valueselfnn    returns the current state index.n    $^static pyobject pyxpw0pywrapfst00stateiterator00valuepyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextvalue wrapper 0$^  pyxr  pyxpf0pywrapfst00stateiterator00valuestruct pyxobj0pywrapfststateiterator pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00stateiterator00valuestruct pyxobj0pywrapfststateiterator pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextvalue 0$^  pyxxdecrefpyxr$^  pyxt0  pyxpyintfromint00tpyxf0pywrapfst00stateiteratorvaluepyxvself 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.stateiterator.value pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ tree fragment0$^  def reducecythonself              $^      raise typeerrorself.fstself.siter cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00stateiterator00reducecythonpyobject pyxvself cythonunused pyobject unused proto$^static pyobject pyxpw0pywrapfst00stateiterator00reducecythonpyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextreducecython wrapper 0$^  pyxr  pyxpf0pywrapfst00stateiterator00reducecythonstruct pyxobj0pywrapfststateiterator pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00stateiterator00reducecythoncythonunused struct pyxobj0pywrapfststateiterator pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextreducecython 0$^$^   tree fragment0$^  def reducecythonself$^      raise typeerrorself.fstself.siter cannot be converted to a python object for pickling              $^  def setstatecythonself pyxstate$^      raise typeerrorself.fstself.siter cannot be converted to a python object for pickling$^ $^  pyxt0  pyxpyobjectcallpyxbuiltintypeerror pyxtuple00 null if unlikelypyxt0 pyxerr0 0 pyxl0error$^  pyxgotrefpyxt0$^  pyxraisepyxt0 0 0 0$^  pyxdecrefpyxt0 pyxt0  0$^  pyxerr0 0 pyxl0error$^$^   tree fragment0$^  def reducecythonself              $^      raise typeerrorself.fstself.siter cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.stateiterator.reducecython pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ tree fragment0$^  def reducecythonself$^      raise typeerrorself.fstself.siter cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate              $^      raise typeerrorself.fstself.siter cannot be converted to a python object for pickling$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00stateiterator00setstatecythonpyobject pyxvself pyobject pyxvpyxstate proto$^static pyobject pyxpw0pywrapfst00stateiterator00setstatecythonpyobject pyxvself pyobject pyxvpyxstate $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextsetstatecython wrapper 0$^  pyxr  pyxpf0pywrapfst00stateiterator00setstatecythonstruct pyxobj0pywrapfststateiterator pyxvself pyobject pyxvpyxstate$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00stateiterator00setstatecythoncythonunused struct pyxobj0pywrapfststateiterator pyxvself cythonunused pyobject pyxvpyxstate $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextsetstatecython 0$^$^   tree fragment0$^      raise typeerrorself.fstself.siter cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate$^      raise typeerrorself.fstself.siter cannot be converted to a python object for pickling              $^ $^  pyxt0  pyxpyobjectcallpyxbuiltintypeerror pyxtuple00 null if unlikelypyxt0 pyxerr0 0 pyxl0error$^  pyxgotrefpyxt0$^  pyxraisepyxt0 0 0 0$^  pyxdecrefpyxt0 pyxt0  0$^  pyxerr0 0 pyxl0error$^$^   tree fragment0$^  def reducecythonself$^      raise typeerrorself.fstself.siter cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate              $^      raise typeerrorself.fstself.siter cannot be converted to a python object for pickling$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.stateiterator.setstatecython pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^  $^  $^  cdef fst mapfst ifst              $^                 float deltafst.kdelta$^                 maptypebidentity$^ $^$^static struct pyxobj0pywrapfstfst pyxf0pywrapfstmapstruct pyxobj0pywrapfstfst pyxvifst struct pyxoptargs0pywrapfstmap pyxoptionalargs $^  float pyxvdelta  pyxk00$^  pyobject pyxvmaptype  pyobject pyxnbidentity$^  double pyxvpower  double0.$^$^   pywrapfst.pyx0000$^                 maptypebidentity$^                 double power0.$^                 weightnone              $^    cdef fst.maptype maptypeenum$^    if not fst.getmaptypetostringmaptype addrmaptypeenum$^ $^  pyobject pyxvweight  pyobject pynone$^  enum fstscriptmaptype pyxvmaptypeenum$^  fstscriptweightclass pyxvwc$^  struct pyxobj0pywrapfstfst pyxr  null$^  pyxrefnannydeclarations$^  stdstring pyxt0$^  int pyxt0$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  fstscriptweightclass pyxt0$^  fstscriptweightclass pyxt00$^  pyxrefnannysetupcontextmap 0$^  if pyxoptionalargs $^    if pyxoptionalargspyxn  0 $^      pyxvdelta  pyxoptionalargsdelta$^      if pyxoptionalargspyxn  0 $^        pyxvmaptype  pyxoptionalargsmaptype$^        if pyxoptionalargspyxn  0 $^          pyxvpower  pyxoptionalargspower$^          if pyxoptionalargspyxn  0 $^            pyxvweight  pyxoptionalargsweight$^          $^        $^      $^    $^  $^$^   pywrapfst.pyx0000$^                 weightnone$^    cdef fst.maptype maptypeenum$^    if not fst.getmaptypetostringmaptype addrmaptypeenum              $^      raise fstargerrorunknown map type r.formatmaptype$^    cdef fst.weightclass wc  getweightclassoroneifst.weighttype$^ $^  pyxt0  pyxf0pywrapfsttostringpyxvmaptype null if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^  pyxt0  fstscriptgetmaptypepyxt0 pyxvmaptypeenum  0  0$^  if unlikelypyxt0 $^$^     pywrapfst.pyx0000$^    cdef fst.maptype maptypeenum$^    if not fst.getmaptypetostringmaptype addrmaptypeenum$^      raise fstargerrorunknown map type r.formatmaptype              $^    cdef fst.weightclass wc  getweightclassoroneifst.weighttype$^        weight if maptypeenum  fst.timesmapper else$^ $^    pyxt0  pyxgetmoduleglobalnamepyxnsfstargerror if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  pyxpyobjectgetattrstrpyxkpsunknownmaptyper pyxnsformat if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  null$^    if cythonunpackmethods  likelypymethodcheckpyxt0 $^      pyxt0  pymethodgetselfpyxt0$^      if likelypyxt0 $^        pyobject function  pymethodgetfunctionpyxt0$^        pyxincrefpyxt0$^        pyxincreffunction$^        pyxdecrefsetpyxt0 function$^      $^    $^    if pyxt0 $^      pyxt0  pyxpyobjectcalloneargpyxt0 pyxvmaptype if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxgotrefpyxt0$^     else $^      if cythonfastpycall$^      if pyfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxvmaptype$^        pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^       else$^      endif$^      if cythonfastpyccall$^      if pyxpyfastcfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxvmaptype$^        pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^       else$^      endif$^      $^        pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxgotrefpyxt0$^        pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^        pyxincrefpyxvmaptype$^        pyxgiverefpyxvmaptype$^        pytuplesetitempyxt0 00 pyxvmaptype$^        pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^      $^    $^    pyxdecrefpyxt0 pyxt0  0$^    pyxt0  null$^    if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^      pyxt0  pymethodgetselfpyxt0$^      if likelypyxt0 $^        pyobject function  pymethodgetfunctionpyxt0$^        pyxincrefpyxt0$^        pyxincreffunction$^        pyxdecrefsetpyxt0 function$^      $^    $^    if pyxt0 $^      pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxgotrefpyxt0$^     else $^      if cythonfastpycall$^      if pyfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxt0$^        pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^       else$^      endif$^      if cythonfastpyccall$^      if pyxpyfastcfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxt0$^        pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^       else$^      endif$^      $^        pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxgotrefpyxt0$^        pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^        pyxgiverefpyxt0$^        pytuplesetitempyxt0 00 pyxt0$^        pyxt0  0$^        pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^      $^    $^    pyxdecrefpyxt0 pyxt0  0$^    pyxraisepyxt0 0 0 0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxerr0 0000 pyxl0error$^$^     pywrapfst.pyx0000$^                 weightnone$^    cdef fst.maptype maptypeenum$^    if not fst.getmaptypetostringmaptype addrmaptypeenum              $^      raise fstargerrorunknown map type r.formatmaptype$^    cdef fst.weightclass wc  getweightclassoroneifst.weighttype$^ $^  $^$^   pywrapfst.pyx0000$^      raise fstargerrorunknown map type r.formatmaptype$^    cdef fst.weightclass wc  getweightclassoroneifst.weighttype$^        weight if maptypeenum  fst.timesmapper else              $^        getweightclassorzeroifst.weighttype weight$^    return initxfstfst.mapderefifst.fst maptypeenum delta power wc$^ $^  if pyxvmaptypeenum  fstscripttimesmapper  0 $^$^     pywrapfst.pyx0000$^    if not fst.getmaptypetostringmaptype addrmaptypeenum$^      raise fstargerrorunknown map type r.formatmaptype$^    cdef fst.weightclass wc  getweightclassoroneifst.weighttype              $^        weight if maptypeenum  fst.timesmapper else$^        getweightclassorzeroifst.weighttype weight$^ $^    if unlikelypyobject pyxvifst  pynone $^      pyerrformatpyexcattributeerror nonetype object has no attribute .00s weighttype$^      pyxerr0 0000 pyxl0error$^    $^$^     pywrapfst.pyx0000$^      raise fstargerrorunknown map type r.formatmaptype$^    cdef fst.weightclass wc  getweightclassoroneifst.weighttype$^        weight if maptypeenum  fst.timesmapper else              $^        getweightclassorzeroifst.weighttype weight$^    return initxfstfst.mapderefifst.fst maptypeenum delta power wc$^ $^    pyxt00  pyxf0pywrapfstgetweightclassoronestruct pyxvtabstruct0pywrapfstfst pyxvifstpyxvtabweighttypepyxvifst 0 pyxvweight if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^    pyxt0  pyxt00$^   else $^$^     pywrapfst.pyx0000$^    cdef fst.weightclass wc  getweightclassoroneifst.weighttype$^        weight if maptypeenum  fst.timesmapper else$^        getweightclassorzeroifst.weighttype weight              $^    return initxfstfst.mapderefifst.fst maptypeenum delta power wc$^  $^ $^    if unlikelypyobject pyxvifst  pynone $^      pyerrformatpyexcattributeerror nonetype object has no attribute .00s weighttype$^      pyxerr0 0000 pyxl0error$^    $^    pyxt00  pyxf0pywrapfstgetweightclassorzerostruct pyxvtabstruct0pywrapfstfst pyxvifstpyxvtabweighttypepyxvifst 0 pyxvweight if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^    pyxt0  pyxt00$^  $^  pyxvwc  pyxt0$^$^   pywrapfst.pyx0000$^        weight if maptypeenum  fst.timesmapper else$^        getweightclassorzeroifst.weighttype weight$^    return initxfstfst.mapderefifst.fst maptypeenum delta power wc              $^  $^  $^ $^  pyxxdecrefpyobject pyxr$^  if unlikelypyobject pyxvifst  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s fst$^    pyxerr0 0000 pyxl0error$^  $^  pyxt0  pyobject pyxf0pywrapfstinitxfstfstscriptmappyxvifstfst pyxvmaptypeenum pyxvdelta pyxvpower pyxvwc if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  struct pyxobj0pywrapfstfst pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   pywrapfst.pyx0000$^  $^  $^  cdef fst mapfst ifst              $^                 float deltafst.kdelta$^                 maptypebidentity$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.map pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxl0$^  pyxxgiverefpyobject pyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^  $^  $^  cpdef fst arcmapfst ifst              $^                    float deltafst.kdelta$^                    maptypebidentity$^ $^$^static pyobject pyxpw0pywrapfst00arcmappyobject pyxself pyobject pyxargs pyobject pyxkwds proto$^static struct pyxobj0pywrapfstfst pyxf0pywrapfstarcmapstruct pyxobj0pywrapfstfst pyxvifst cythonunused int pyxskipdispatch struct pyxoptargs0pywrapfstarcmap pyxoptionalargs $^  float pyxvdelta  pyxk00$^  pyobject pyxvmaptype  pyobject pyxnbidentity$^  double pyxvpower  double0.$^$^   pywrapfst.pyx0000$^                    maptypebidentity$^                    double power0.$^                    weightnone              $^    $^    arcmapifst delta0.0000000000 maptypeidentity weightnone$^ $^  pyobject pyxvweight  pyobject pynone$^  struct pyxobj0pywrapfstfst pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  struct pyxoptargs0pywrapfstmap pyxt0$^  pyxrefnannysetupcontextarcmap 0$^  if pyxoptionalargs $^    if pyxoptionalargspyxn  0 $^      pyxvdelta  pyxoptionalargsdelta$^      if pyxoptionalargspyxn  0 $^        pyxvmaptype  pyxoptionalargsmaptype$^        if pyxoptionalargspyxn  0 $^          pyxvpower  pyxoptionalargspower$^          if pyxoptionalargspyxn  0 $^            pyxvweight  pyxoptionalargsweight$^          $^        $^      $^    $^  $^$^   pywrapfst.pyx0000$^    see also statemap.$^    $^    return mapifst delta maptype power weight              $^  $^  $^ $^  pyxxdecrefpyobject pyxr$^  pyxt0.pyxn  0$^  pyxt0.delta  pyxvdelta$^  pyxt0.maptype  pyxvmaptype$^  pyxt0.power  pyxvpower$^  pyxt0.weight  pyxvweight$^  pyxt0  pyobject pyxf0pywrapfstmappyxvifst pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  struct pyxobj0pywrapfstfst pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   pywrapfst.pyx0000$^  $^  $^  cpdef fst arcmapfst ifst              $^                    float deltafst.kdelta$^                    maptypebidentity$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.arcmap pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxl0$^  pyxxgiverefpyobject pyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst00arcmappyobject pyxself pyobject pyxargs pyobject pyxkwds proto$^static char pyxdoc0pywrapfst00arcmap  n  arcmapifst delta0.0000000000 maptypeidentity weightnonenn  constructively applies a transform to all arcs and final states.nn  this operation transforms each arc and final state in the input fst usingn  one of the followingnn     identity maps to self.n     inputepsilon replaces all input labels with epsilon.n     invert reciprocates all nonzero weights.n     floatpower raises all weights to a floatingpoint power.n     outputepsilon replaces all output labels with epsilon.n     quantize quantizes weights.n     plus adds a constant to all weights.n     power raises all weights to an integral power.n     rmweight replaces all nonzero weights with 0.n     superfinal redirects final states to a new superfinal state.n     times rightmultiplies a constant to all weights.n     tolog converts weights to the log semiring.n     tolog00 converts weights to the log00 semiring.n     tostandard converts weights to the tropical standard semiring.nn  argsn    ifst the input fst.n    delta comparisonquantization delta ignored unless maptype isn        quantize.n    maptype a string matching a known mapping operation see above.n    power a positive scalar or integer power ignored unless maptype isn        floatpower or power in which case it defaults to 0.n    weight a weight or weight string passed to the arcmapper ignored unlessn        maptype is plus in which case it defaults to semiring zero orn        times in which case it defaults to semiring one.nn  returnsn    an fst with arcs and final states remapped.nn  raisesn    fstargerror unknown map type.nn  see also statemap.n  $^static pyobject pyxpw0pywrapfst00arcmappyobject pyxself pyobject pyxargs pyobject pyxkwds $^  struct pyxobj0pywrapfstfst pyxvifst  0$^  float pyxvdelta$^  pyobject pyxvmaptype  0$^  double pyxvpower$^  pyobject pyxvweight  0$^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextarcmap wrapper 0$^  $^    static pyobject pyxpyargnames  pyxnsifstpyxnsdeltapyxnsmaptypepyxnspowerpyxnsweight0$^    pyobject values0  00000$^    values0  pyobject pyxnbidentity$^$^     pywrapfst.pyx0000$^                    maptypebidentity$^                    double power0.$^                    weightnone              $^    $^    arcmapifst delta0.0000000000 maptypeidentity weightnone$^ $^    values0  pyobject pynone$^    if unlikelypyxkwds $^      pyssizet kwargs$^      const pyssizet posargs  pytuplegetsizepyxargs$^      switch posargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 break$^        default goto pyxl0argtupleerror$^      $^      kwargs  pydictsizepyxkwds$^      switch posargs $^        case  0$^        if likelyvalues0  pyxpydictgetitemstrpyxkwds pyxnsifst  0 kwargs$^        else goto pyxl0argtupleerror$^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnsdelta$^          if value  values0  value kwargs $^        $^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnsmaptype$^          if value  values0  value kwargs $^        $^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnspower$^          if value  values0  value kwargs $^        $^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnsweight$^          if value  values0  value kwargs $^        $^      $^      if unlikelykwargs  0 $^        if unlikelypyxparseoptionalkeywordspyxkwds pyxpyargnames 0 values posargs arcmap  0 pyxerr0 0000 pyxl0error$^      $^     else $^      switch pytuplegetsizepyxargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        break$^        default goto pyxl0argtupleerror$^      $^    $^    pyxvifst  struct pyxobj0pywrapfstfst values0$^    if values0 $^      pyxvdelta  pyxpyfloatasfloatvalues0 if unlikelypyxvdelta  float0  pyerroccurred pyxerr0 0000 pyxl0error$^     else $^      pyxvdelta  pyxk00$^    $^    pyxvmaptype  values0$^    if values0 $^      pyxvpower  pyxpyfloatasdoublevalues0 if unlikelypyxvpower  double0  pyerroccurred pyxerr0 0000 pyxl0error$^     else $^      pyxvpower  double0.$^    $^    pyxvweight  values0$^  $^  goto pyxl0argumentunpackingdone$^  pyxl0argtupleerror$^  pyxraiseargtupleinvalidarcmap 0 0 0 pytuplegetsizepyxargs pyxerr0 0000 pyxl0error$^  pyxl0error$^  pyxaddtracebackpywrapfst.arcmap pyxclineno pyxlineno pyxfilename$^  pyxrefnannyfinishcontext$^  return null$^  pyxl0argumentunpackingdone$^  if unlikelypyxargtypetestpyobject pyxvifst pyxptype0pywrapfstfst 0 ifst 0 pyxerr0 0000 pyxl0error$^  pyxr  pyxpf0pywrapfst00arcmappyxself pyxvifst pyxvdelta pyxvmaptype pyxvpower pyxvweight$^$^   pywrapfst.pyx0000$^  $^  $^  cpdef fst arcmapfst ifst              $^                    float deltafst.kdelta$^                    maptypebidentity$^ $^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxr  null$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00arcmapcythonunused pyobject pyxself struct pyxobj0pywrapfstfst pyxvifst float pyxvdelta pyobject pyxvmaptype double pyxvpower pyobject pyxvweight $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  struct pyxoptargs0pywrapfstarcmap pyxt0$^  pyxrefnannysetupcontextarcmap 0$^  pyxxdecrefpyxr$^  pyxt0.pyxn  0$^  pyxt0.delta  pyxvdelta$^  pyxt0.maptype  pyxvmaptype$^  pyxt0.power  pyxvpower$^  pyxt0.weight  pyxvweight$^  pyxt0  pyobject pyxf0pywrapfstarcmappyxvifst 0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.arcmap pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^  $^  $^  cpdef mutablefst composefst ifst0              $^                            fst ifst0$^                            composefilterbauto$^ $^$^static pyobject pyxpw0pywrapfst00composepyobject pyxself pyobject pyxargs pyobject pyxkwds proto$^static struct pyxobj0pywrapfstmutablefst pyxf0pywrapfstcomposestruct pyxobj0pywrapfstfst pyxvifst0 struct pyxobj0pywrapfstfst pyxvifst0 cythonunused int pyxskipdispatch struct pyxoptargs0pywrapfstcompose pyxoptionalargs $^  pyobject pyxvcomposefilter  pyobject pyxnbauto$^$^   pywrapfst.pyx0000$^                            fst ifst0$^                            composefilterbauto$^                            bool connecttrue              $^    $^    composeifst0 ifst0 composefilterauto connecttrue$^ $^  bool pyxvconnect  bool0$^  stduniqueptrfstscriptvectorfstclass  pyxvtfst$^  stduniqueptrfstcomposeoptions  pyxvopts$^  struct pyxobj0pywrapfstmutablefst pyxr  null$^  pyxrefnannydeclarations$^  stdstring pyxt0$^  enum fstcomposefilter pyxt0$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextcompose 0$^  if pyxoptionalargs $^    if pyxoptionalargspyxn  0 $^      pyxvcomposefilter  pyxoptionalargscomposefilter$^      if pyxoptionalargspyxn  0 $^        pyxvconnect  pyxoptionalargsconnect$^      $^    $^  $^$^   pywrapfst.pyx0000$^    $^    cdef uniqueptrfst.vectorfstclass tfst$^    tfst.resetnew fst.vectorfstclassifst0.arctype              $^    cdef uniqueptrfst.composeoptions opts$^    opts.resetnew fst.composeoptionsconnect$^ $^  if unlikelypyobject pyxvifst0  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s arctype$^    pyxerr0 0000 pyxl0error$^  $^  pyxvtfst.resetnew fstscriptvectorfstclassstruct pyxvtabstruct0pywrapfstfst pyxvifst0pyxvtabarctypepyxvifst0 0$^$^   pywrapfst.pyx0000$^    cdef uniqueptrfst.composeoptions opts$^    opts.resetnew fst.composeoptionsconnect$^        getcomposefiltertostringcomposefilter              $^    fst.composederefifst0.fst derefifst0.fst tfst.get derefopts$^    return initmutablefsttfst.release$^ $^  pyxt0  pyxf0pywrapfsttostringpyxvcomposefilter null if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^  pyxt0  pyxf0pywrapfstgetcomposefilterpyxt0 if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^    tfst.resetnew fst.vectorfstclassifst0.arctype$^    cdef uniqueptrfst.composeoptions opts$^    opts.resetnew fst.composeoptionsconnect              $^        getcomposefiltertostringcomposefilter$^    fst.composederefifst0.fst derefifst0.fst tfst.get derefopts$^ $^  pyxvopts.resetnew fstcomposeoptionspyxvconnect pyxt0$^$^   pywrapfst.pyx0000$^    opts.resetnew fst.composeoptionsconnect$^        getcomposefiltertostringcomposefilter$^    fst.composederefifst0.fst derefifst0.fst tfst.get derefopts              $^    return initmutablefsttfst.release$^  $^ $^  if unlikelypyobject pyxvifst0  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s fst$^    pyxerr0 0000 pyxl0error$^  $^  if unlikelypyobject pyxvifst0  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s fst$^    pyxerr0 0000 pyxl0error$^  $^  fstscriptcomposepyxvifst0fst pyxvifst0fst pyxvtfst.get pyxvopts$^$^   pywrapfst.pyx0000$^        getcomposefiltertostringcomposefilter$^    fst.composederefifst0.fst derefifst0.fst tfst.get derefopts$^    return initmutablefsttfst.release              $^  $^  $^ $^  pyxxdecrefpyobject pyxr$^  pyxt0  pyobject pyxf0pywrapfstinitmutablefstpyxvtfst.release if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  struct pyxobj0pywrapfstmutablefst pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   pywrapfst.pyx0000$^  $^  $^  cpdef mutablefst composefst ifst0              $^                            fst ifst0$^                            composefilterbauto$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.compose pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxl0$^  pyxxgiverefpyobject pyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst00composepyobject pyxself pyobject pyxargs pyobject pyxkwds proto$^static char pyxdoc0pywrapfst00compose  n  composeifst0 ifst0 composefilterauto connecttruenn  constructively composes two fsts.nn  this operation computes the composition of two fsts. if a transduces stringn  x to y with weight a and b transduces y to z with weight b then theirn  composition transduces string x to z with weight a otimes b. the outputn  labels of the first transducer or the input labels of the second transducern  must be sorted or otherwise support appropriate matchers.nn  argsn    ifst0 the first input fst.n    ifst0 the second input fst.n    composefilter a string matching a known composition filter one ofn        altsequence auto match null sequence trivial.n    connect should output be trimmednn  returnsn    an fst.nn  see also arcsort.n  $^static pyobject pyxpw0pywrapfst00composepyobject pyxself pyobject pyxargs pyobject pyxkwds $^  struct pyxobj0pywrapfstfst pyxvifst0  0$^  struct pyxobj0pywrapfstfst pyxvifst0  0$^  pyobject pyxvcomposefilter  0$^  bool pyxvconnect$^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextcompose wrapper 0$^  $^    static pyobject pyxpyargnames  pyxnsifst0pyxnsifst0pyxnscomposefilterpyxnsconnect0$^    pyobject values0  0000$^    values0  pyobject pyxnbauto$^    if unlikelypyxkwds $^      pyssizet kwargs$^      const pyssizet posargs  pytuplegetsizepyxargs$^      switch posargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 break$^        default goto pyxl0argtupleerror$^      $^      kwargs  pydictsizepyxkwds$^      switch posargs $^        case  0$^        if likelyvalues0  pyxpydictgetitemstrpyxkwds pyxnsifst0  0 kwargs$^        else goto pyxl0argtupleerror$^        cythonfallthrough$^        case  0$^        if likelyvalues0  pyxpydictgetitemstrpyxkwds pyxnsifst0  0 kwargs$^        else $^          pyxraiseargtupleinvalidcompose 0 0 0 0 pyxerr0 0000 pyxl0error$^        $^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnscomposefilter$^          if value  values0  value kwargs $^        $^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnsconnect$^          if value  values0  value kwargs $^        $^      $^      if unlikelykwargs  0 $^        if unlikelypyxparseoptionalkeywordspyxkwds pyxpyargnames 0 values posargs compose  0 pyxerr0 0000 pyxl0error$^      $^     else $^      switch pytuplegetsizepyxargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        values0  pytuplegetitempyxargs 0$^        break$^        default goto pyxl0argtupleerror$^      $^    $^    pyxvifst0  struct pyxobj0pywrapfstfst values0$^    pyxvifst0  struct pyxobj0pywrapfstfst values0$^    pyxvcomposefilter  values0$^    if values0 $^      pyxvconnect  pyxpyobjectistruevalues0 if unlikelypyxvconnect  bool0  pyerroccurred pyxerr0 0000 pyxl0error$^     else $^$^       pywrapfst.pyx0000$^                            fst ifst0$^                            composefilterbauto$^                            bool connecttrue              $^    $^    composeifst0 ifst0 composefilterauto connecttrue$^ $^      pyxvconnect  bool0$^    $^  $^  goto pyxl0argumentunpackingdone$^  pyxl0argtupleerror$^  pyxraiseargtupleinvalidcompose 0 0 0 pytuplegetsizepyxargs pyxerr0 0000 pyxl0error$^  pyxl0error$^  pyxaddtracebackpywrapfst.compose pyxclineno pyxlineno pyxfilename$^  pyxrefnannyfinishcontext$^  return null$^  pyxl0argumentunpackingdone$^  if unlikelypyxargtypetestpyobject pyxvifst0 pyxptype0pywrapfstfst 0 ifst0 0 pyxerr0 0000 pyxl0error$^  if unlikelypyxargtypetestpyobject pyxvifst0 pyxptype0pywrapfstfst 0 ifst0 0 pyxerr0 0000 pyxl0error$^  pyxr  pyxpf0pywrapfst00composepyxself pyxvifst0 pyxvifst0 pyxvcomposefilter pyxvconnect$^$^   pywrapfst.pyx0000$^  $^  $^  cpdef mutablefst composefst ifst0              $^                            fst ifst0$^                            composefilterbauto$^ $^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxr  null$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00composecythonunused pyobject pyxself struct pyxobj0pywrapfstfst pyxvifst0 struct pyxobj0pywrapfstfst pyxvifst0 pyobject pyxvcomposefilter bool pyxvconnect $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  struct pyxoptargs0pywrapfstcompose pyxt0$^  pyxrefnannysetupcontextcompose 0$^  pyxxdecrefpyxr$^  pyxt0.pyxn  0$^  pyxt0.composefilter  pyxvcomposefilter$^  pyxt0.connect  pyxvconnect$^  pyxt0  pyobject pyxf0pywrapfstcomposepyxvifst0 pyxvifst0 0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.compose pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^  $^  $^  cpdef fst convertfst ifst fsttypenone              $^    $^    convertifst fsttypenone$^ $^$^static pyobject pyxpw0pywrapfst00convertpyobject pyxself pyobject pyxargs pyobject pyxkwds proto$^static struct pyxobj0pywrapfstfst pyxf0pywrapfstconvertstruct pyxobj0pywrapfstfst pyxvifst cythonunused int pyxskipdispatch struct pyxoptargs0pywrapfstconvert pyxoptionalargs $^  pyobject pyxvfsttype  pyobject pynone$^  stdstring pyxvfsttypestring$^  stduniqueptrfstscriptfstclass  pyxvtfst$^  struct pyxobj0pywrapfstfst pyxr  null$^  pyxrefnannydeclarations$^  stdstring pyxt0$^  int pyxt0$^  stdstring pyxt0$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextconvert 0$^  if pyxoptionalargs $^    if pyxoptionalargspyxn  0 $^      pyxvfsttype  pyxoptionalargsfsttype$^    $^  $^$^   pywrapfst.pyx0000$^      fstoperror conversion failed.$^    $^    cdef string fsttypestring  b if fsttype is none else tostringfsttype              $^    cdef uniqueptrfst.fstclass tfst$^    tfst.resetfst.convertderefifst.fst fsttypestring$^ $^  pyxt0  pyxvfsttype  pynone$^  if pyxt0  0 $^    pyxt0  pyxconvertstringfrompystdinstringpyxkpb00 if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^    pyxt0  pyxt0$^   else $^    pyxt0  pyxf0pywrapfsttostringpyxvfsttype null if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^    pyxt0  pyxconvertpybytesstringtopystdinstringpyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  pyxconvertstringfrompystdinstringpyxt0 if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^    pyxdecrefpyxt0 pyxt0  0$^    pyxt0  pyxt0$^  $^  pyxvfsttypestring  pyxt0$^$^   pywrapfst.pyx0000$^    cdef string fsttypestring  b if fsttype is none else tostringfsttype$^    cdef uniqueptrfst.fstclass tfst$^    tfst.resetfst.convertderefifst.fst fsttypestring              $^     scriptland convert returns a null pointer to signal failure.$^    if tfst.get  null$^ $^  if unlikelypyobject pyxvifst  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s fst$^    pyxerr0 0000 pyxl0error$^  $^  pyxvtfst.resetfstscriptconvertpyxvifstfst pyxvfsttypestring$^$^   pywrapfst.pyx0000$^    tfst.resetfst.convertderefifst.fst fsttypestring$^     scriptland convert returns a null pointer to signal failure.$^    if tfst.get  null              $^      raise fstoperrorconversion to r failed.formatfsttype$^    return initxfsttfst.release$^ $^  pyxt0  pyxvtfst.get  null  0$^  if unlikelypyxt0 $^$^     pywrapfst.pyx0000$^     scriptland convert returns a null pointer to signal failure.$^    if tfst.get  null$^      raise fstoperrorconversion to r failed.formatfsttype              $^    return initxfsttfst.release$^  $^ $^    pyxt0  pyxgetmoduleglobalnamepyxnsfstoperror if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  pyxpyobjectgetattrstrpyxkpsconversiontorfailed pyxnsformat if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  null$^    if cythonunpackmethods  likelypymethodcheckpyxt0 $^      pyxt0  pymethodgetselfpyxt0$^      if likelypyxt0 $^        pyobject function  pymethodgetfunctionpyxt0$^        pyxincrefpyxt0$^        pyxincreffunction$^        pyxdecrefsetpyxt0 function$^      $^    $^    if pyxt0 $^      pyxt0  pyxpyobjectcalloneargpyxt0 pyxvfsttype if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxgotrefpyxt0$^     else $^      if cythonfastpycall$^      if pyfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxvfsttype$^        pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^       else$^      endif$^      if cythonfastpyccall$^      if pyxpyfastcfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxvfsttype$^        pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^       else$^      endif$^      $^        pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxgotrefpyxt0$^        pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^        pyxincrefpyxvfsttype$^        pyxgiverefpyxvfsttype$^        pytuplesetitempyxt0 00 pyxvfsttype$^        pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^      $^    $^    pyxdecrefpyxt0 pyxt0  0$^    pyxt0  null$^    if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^      pyxt0  pymethodgetselfpyxt0$^      if likelypyxt0 $^        pyobject function  pymethodgetfunctionpyxt0$^        pyxincrefpyxt0$^        pyxincreffunction$^        pyxdecrefsetpyxt0 function$^      $^    $^    if pyxt0 $^      pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxgotrefpyxt0$^     else $^      if cythonfastpycall$^      if pyfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxt0$^        pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^       else$^      endif$^      if cythonfastpyccall$^      if pyxpyfastcfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxt0$^        pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^       else$^      endif$^      $^        pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxgotrefpyxt0$^        pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^        pyxgiverefpyxt0$^        pytuplesetitempyxt0 00 pyxt0$^        pyxt0  0$^        pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^      $^    $^    pyxdecrefpyxt0 pyxt0  0$^    pyxraisepyxt0 0 0 0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxerr0 0000 pyxl0error$^$^     pywrapfst.pyx0000$^    tfst.resetfst.convertderefifst.fst fsttypestring$^     scriptland convert returns a null pointer to signal failure.$^    if tfst.get  null              $^      raise fstoperrorconversion to r failed.formatfsttype$^    return initxfsttfst.release$^ $^  $^$^   pywrapfst.pyx0000$^    if tfst.get  null$^      raise fstoperrorconversion to r failed.formatfsttype$^    return initxfsttfst.release              $^  $^  $^ $^  pyxxdecrefpyobject pyxr$^  pyxt0  pyobject pyxf0pywrapfstinitxfstpyxvtfst.release if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  struct pyxobj0pywrapfstfst pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   pywrapfst.pyx0000$^  $^  $^  cpdef fst convertfst ifst fsttypenone              $^    $^    convertifst fsttypenone$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.convert pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxl0$^  pyxxgiverefpyobject pyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst00convertpyobject pyxself pyobject pyxargs pyobject pyxkwds proto$^static char pyxdoc0pywrapfst00convert  n  convertifst fsttypenonenn  constructively converts an fst to a new internal representation.nn  argsn    ifst the input fst.n    fsttype a string indicating the fst type to convert to or none ifn        no conversion is desired.nn  returnsn    the input fst converted to the desired fst type.nn  raisesn    fstoperror conversion failed.n  $^static pyobject pyxpw0pywrapfst00convertpyobject pyxself pyobject pyxargs pyobject pyxkwds $^  struct pyxobj0pywrapfstfst pyxvifst  0$^  pyobject pyxvfsttype  0$^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextconvert wrapper 0$^  $^    static pyobject pyxpyargnames  pyxnsifstpyxnsfsttype0$^    pyobject values0  00$^    values0  pyobject pynone$^    if unlikelypyxkwds $^      pyssizet kwargs$^      const pyssizet posargs  pytuplegetsizepyxargs$^      switch posargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 break$^        default goto pyxl0argtupleerror$^      $^      kwargs  pydictsizepyxkwds$^      switch posargs $^        case  0$^        if likelyvalues0  pyxpydictgetitemstrpyxkwds pyxnsifst  0 kwargs$^        else goto pyxl0argtupleerror$^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnsfsttype$^          if value  values0  value kwargs $^        $^      $^      if unlikelykwargs  0 $^        if unlikelypyxparseoptionalkeywordspyxkwds pyxpyargnames 0 values posargs convert  0 pyxerr0 0000 pyxl0error$^      $^     else $^      switch pytuplegetsizepyxargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        break$^        default goto pyxl0argtupleerror$^      $^    $^    pyxvifst  struct pyxobj0pywrapfstfst values0$^    pyxvfsttype  values0$^  $^  goto pyxl0argumentunpackingdone$^  pyxl0argtupleerror$^  pyxraiseargtupleinvalidconvert 0 0 0 pytuplegetsizepyxargs pyxerr0 0000 pyxl0error$^  pyxl0error$^  pyxaddtracebackpywrapfst.convert pyxclineno pyxlineno pyxfilename$^  pyxrefnannyfinishcontext$^  return null$^  pyxl0argumentunpackingdone$^  if unlikelypyxargtypetestpyobject pyxvifst pyxptype0pywrapfstfst 0 ifst 0 pyxerr0 0000 pyxl0error$^  pyxr  pyxpf0pywrapfst00convertpyxself pyxvifst pyxvfsttype$^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxr  null$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00convertcythonunused pyobject pyxself struct pyxobj0pywrapfstfst pyxvifst pyobject pyxvfsttype $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  struct pyxoptargs0pywrapfstconvert pyxt0$^  pyxrefnannysetupcontextconvert 0$^  pyxxdecrefpyxr$^  pyxt0.pyxn  0$^  pyxt0.fsttype  pyxvfsttype$^  pyxt0  pyobject pyxf0pywrapfstconvertpyxvifst 0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.convert pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^  $^  $^  cpdef mutablefst determinizefst ifst              $^                                float deltafst.kshortestdelta$^                                dettypebfunctional$^ $^$^static pyobject pyxpw0pywrapfst00determinizepyobject pyxself pyobject pyxargs pyobject pyxkwds proto$^static struct pyxobj0pywrapfstmutablefst pyxf0pywrapfstdeterminizestruct pyxobj0pywrapfstfst pyxvifst cythonunused int pyxskipdispatch struct pyxoptargs0pywrapfstdeterminize pyxoptionalargs $^  float pyxvdelta  pyxk00$^  pyobject pyxvdettype  pyobject pyxnbfunctional$^  pyxt00basictypesint00 pyxvnstate  pyxk00$^  pyxt00basictypesint00 pyxvsubsequentiallabel  pyxt00basictypesint000$^$^   pywrapfst.pyx0000$^                                int00 nstatefst.knostateid$^                                int00 subsequentiallabel0$^                                weightnone              $^                                bool incrementsubsequentiallabelfalse$^    $^ $^  pyobject pyxvweight  pyobject pynone$^$^   pywrapfst.pyx0000$^                                int00 subsequentiallabel0$^                                weightnone$^                                bool incrementsubsequentiallabelfalse              $^    $^    determinizeifst delta0e0 dettypefunctional$^ $^  bool pyxvincrementsubsequentiallabel  bool0$^  stduniqueptrfstscriptvectorfstclass  pyxvtfst$^  fstscriptweightclass pyxvwc$^  enum fstdeterminizetype pyxvdeterminizetypeenum$^  stduniqueptrfstscriptdeterminizeoptions  pyxvopts$^  struct pyxobj0pywrapfstmutablefst pyxr  null$^  pyxrefnannydeclarations$^  fstscriptweightclass pyxt0$^  stdstring pyxt0$^  int pyxt0$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextdeterminize 0$^  if pyxoptionalargs $^    if pyxoptionalargspyxn  0 $^      pyxvdelta  pyxoptionalargsdelta$^      if pyxoptionalargspyxn  0 $^        pyxvdettype  pyxoptionalargsdettype$^        if pyxoptionalargspyxn  0 $^          pyxvnstate  pyxoptionalargsnstate$^          if pyxoptionalargspyxn  0 $^            pyxvsubsequentiallabel  pyxoptionalargssubsequentiallabel$^            if pyxoptionalargspyxn  0 $^              pyxvweight  pyxoptionalargsweight$^              if pyxoptionalargspyxn  0 $^                pyxvincrementsubsequentiallabel  pyxoptionalargsincrementsubsequentiallabel$^              $^            $^          $^        $^      $^    $^  $^$^   pywrapfst.pyx0000$^    $^    cdef uniqueptrfst.vectorfstclass tfst$^    tfst.resetnew fst.vectorfstclassifst.arctype              $^     threshold is set to semiring zero no pruning if weight unspecified.$^    cdef fst.weightclass wc  getweightclassorzeroifst.weighttype$^ $^  if unlikelypyobject pyxvifst  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s arctype$^    pyxerr0 0000 pyxl0error$^  $^  pyxvtfst.resetnew fstscriptvectorfstclassstruct pyxvtabstruct0pywrapfstfst pyxvifstpyxvtabarctypepyxvifst 0$^$^   pywrapfst.pyx0000$^    tfst.resetnew fst.vectorfstclassifst.arctype$^     threshold is set to semiring zero no pruning if weight unspecified.$^    cdef fst.weightclass wc  getweightclassorzeroifst.weighttype              $^                                                       weight$^    cdef fst.determinizetype determinizetypeenum$^ $^  if unlikelypyobject pyxvifst  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s weighttype$^    pyxerr0 0000 pyxl0error$^  $^$^   pywrapfst.pyx0000$^     threshold is set to semiring zero no pruning if weight unspecified.$^    cdef fst.weightclass wc  getweightclassorzeroifst.weighttype$^                                                       weight              $^    cdef fst.determinizetype determinizetypeenum$^    if not fst.getdeterminizetypetostringdettype$^ $^  pyxt0  pyxf0pywrapfstgetweightclassorzerostruct pyxvtabstruct0pywrapfstfst pyxvifstpyxvtabweighttypepyxvifst 0 pyxvweight if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^  pyxvwc  pyxt0$^$^   pywrapfst.pyx0000$^                                                       weight$^    cdef fst.determinizetype determinizetypeenum$^    if not fst.getdeterminizetypetostringdettype              $^                                  addrdeterminizetypeenum$^      raise fstargerrorunknown determinization type r.formatdettype$^ $^  pyxt0  pyxf0pywrapfsttostringpyxvdettype null if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^    cdef fst.determinizetype determinizetypeenum$^    if not fst.getdeterminizetypetostringdettype$^                                  addrdeterminizetypeenum              $^      raise fstargerrorunknown determinization type r.formatdettype$^    cdef uniqueptrfst.determinizeoptions opts$^ $^  pyxt0  fstscriptgetdeterminizetypepyxt0 pyxvdeterminizetypeenum  0  0$^$^   pywrapfst.pyx0000$^                                                       weight$^    cdef fst.determinizetype determinizetypeenum$^    if not fst.getdeterminizetypetostringdettype              $^                                  addrdeterminizetypeenum$^      raise fstargerrorunknown determinization type r.formatdettype$^ $^  if unlikelypyxt0 $^$^     pywrapfst.pyx0000$^    if not fst.getdeterminizetypetostringdettype$^                                  addrdeterminizetypeenum$^      raise fstargerrorunknown determinization type r.formatdettype              $^    cdef uniqueptrfst.determinizeoptions opts$^    opts.resetnew fst.determinizeoptionsdelta wc nstate subsequentiallabel$^ $^    pyxt0  pyxgetmoduleglobalnamepyxnsfstargerror if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  pyxpyobjectgetattrstrpyxkpsunknowndeterminizationtyper pyxnsformat if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  null$^    if cythonunpackmethods  likelypymethodcheckpyxt0 $^      pyxt0  pymethodgetselfpyxt0$^      if likelypyxt0 $^        pyobject function  pymethodgetfunctionpyxt0$^        pyxincrefpyxt0$^        pyxincreffunction$^        pyxdecrefsetpyxt0 function$^      $^    $^    if pyxt0 $^      pyxt0  pyxpyobjectcalloneargpyxt0 pyxvdettype if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxgotrefpyxt0$^     else $^      if cythonfastpycall$^      if pyfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxvdettype$^        pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^       else$^      endif$^      if cythonfastpyccall$^      if pyxpyfastcfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxvdettype$^        pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^       else$^      endif$^      $^        pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxgotrefpyxt0$^        pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^        pyxincrefpyxvdettype$^        pyxgiverefpyxvdettype$^        pytuplesetitempyxt0 00 pyxvdettype$^        pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^      $^    $^    pyxdecrefpyxt0 pyxt0  0$^    pyxt0  null$^    if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^      pyxt0  pymethodgetselfpyxt0$^      if likelypyxt0 $^        pyobject function  pymethodgetfunctionpyxt0$^        pyxincrefpyxt0$^        pyxincreffunction$^        pyxdecrefsetpyxt0 function$^      $^    $^    if pyxt0 $^      pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxgotrefpyxt0$^     else $^      if cythonfastpycall$^      if pyfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxt0$^        pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^       else$^      endif$^      if cythonfastpyccall$^      if pyxpyfastcfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxt0$^        pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^       else$^      endif$^      $^        pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxgotrefpyxt0$^        pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^        pyxgiverefpyxt0$^        pytuplesetitempyxt0 00 pyxt0$^        pyxt0  0$^        pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^      $^    $^    pyxdecrefpyxt0 pyxt0  0$^    pyxraisepyxt0 0 0 0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxerr0 0000 pyxl0error$^$^     pywrapfst.pyx0000$^                                                       weight$^    cdef fst.determinizetype determinizetypeenum$^    if not fst.getdeterminizetypetostringdettype              $^                                  addrdeterminizetypeenum$^      raise fstargerrorunknown determinization type r.formatdettype$^ $^  $^$^   pywrapfst.pyx0000$^      raise fstargerrorunknown determinization type r.formatdettype$^    cdef uniqueptrfst.determinizeoptions opts$^    opts.resetnew fst.determinizeoptionsdelta wc nstate subsequentiallabel              $^                                          determinizetypeenum$^                                          incrementsubsequentiallabel$^ $^  pyxvopts.resetnew fstscriptdeterminizeoptionspyxvdelta pyxvwc pyxvnstate pyxvsubsequentiallabel pyxvdeterminizetypeenum pyxvincrementsubsequentiallabel$^$^   pywrapfst.pyx0000$^                                          determinizetypeenum$^                                          incrementsubsequentiallabel$^    fst.determinizederefifst.fst tfst.get derefopts              $^    return initmutablefsttfst.release$^  $^ $^  if unlikelypyobject pyxvifst  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s fst$^    pyxerr0 0000 pyxl0error$^  $^  fstscriptdeterminizepyxvifstfst pyxvtfst.get pyxvopts$^$^   pywrapfst.pyx0000$^                                          incrementsubsequentiallabel$^    fst.determinizederefifst.fst tfst.get derefopts$^    return initmutablefsttfst.release              $^  $^  $^ $^  pyxxdecrefpyobject pyxr$^  pyxt0  pyobject pyxf0pywrapfstinitmutablefstpyxvtfst.release if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  struct pyxobj0pywrapfstmutablefst pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   pywrapfst.pyx0000$^  $^  $^  cpdef mutablefst determinizefst ifst              $^                                float deltafst.kshortestdelta$^                                dettypebfunctional$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.determinize pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxl0$^  pyxxgiverefpyobject pyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst00determinizepyobject pyxself pyobject pyxargs pyobject pyxkwds proto$^static char pyxdoc0pywrapfst00determinize  n  determinizeifst delta0e0 dettypefunctionaln              nstatenostateid subsequentiallabel0 weightnonen              incrementalsubsequentiallabelfalsenn  constructively determinizes a weighted fst.nn  this operations creates an equivalent fst that has the property that non  state has two transitions with the same input label. for this algorithmn  epsilon transitions are treated as regular symbols cf. rmepsilon.nn  argsn    ifst the input fst.n    delta comparisonquantization delta.n    dettype type of determinization one of functional input transducer isn        functional nonfunctional input transducer is not functional andn        disambiguate input transducer is not functional but only keep the minn        of ambiguous outputs.n    nstate state number threshold.n    subsequentiallabel input label of arc corresponding to residual finaln        output when producing a subsequential transducer.n    weight a weight or weight string indicating the desired weight thresholdn        below which paths are pruned if omitted no paths are pruned.n    incrementsubsequentiallabel increment subsequential when creatingn        several arcs for the residual final output at a given state.nn  returnsn    an equivalent deterministic fst.nn  raisesn    fstargerror unknown determinization type.nn  see also disambiguate rmepsilon.n  $^static pyobject pyxpw0pywrapfst00determinizepyobject pyxself pyobject pyxargs pyobject pyxkwds $^  struct pyxobj0pywrapfstfst pyxvifst  0$^  float pyxvdelta$^  pyobject pyxvdettype  0$^  pyxt00basictypesint00 pyxvnstate$^  pyxt00basictypesint00 pyxvsubsequentiallabel$^  pyobject pyxvweight  0$^  bool pyxvincrementsubsequentiallabel$^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextdeterminize wrapper 0$^  $^    static pyobject pyxpyargnames  pyxnsifstpyxnsdeltapyxnsdettypepyxnsnstatepyxnssubsequentiallabelpyxnsweightpyxnsincrementsubsequentiallabel0$^    pyobject values0  0000000$^    values0  pyobject pyxnbfunctional$^$^     pywrapfst.pyx0000$^                                int00 nstatefst.knostateid$^                                int00 subsequentiallabel0$^                                weightnone              $^                                bool incrementsubsequentiallabelfalse$^    $^ $^    values0  pyobject pynone$^    if unlikelypyxkwds $^      pyssizet kwargs$^      const pyssizet posargs  pytuplegetsizepyxargs$^      switch posargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 break$^        default goto pyxl0argtupleerror$^      $^      kwargs  pydictsizepyxkwds$^      switch posargs $^        case  0$^        if likelyvalues0  pyxpydictgetitemstrpyxkwds pyxnsifst  0 kwargs$^        else goto pyxl0argtupleerror$^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnsdelta$^          if value  values0  value kwargs $^        $^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnsdettype$^          if value  values0  value kwargs $^        $^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnsnstate$^          if value  values0  value kwargs $^        $^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnssubsequentiallabel$^          if value  values0  value kwargs $^        $^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnsweight$^          if value  values0  value kwargs $^        $^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnsincrementsubsequentiallabel$^          if value  values0  value kwargs $^        $^      $^      if unlikelykwargs  0 $^        if unlikelypyxparseoptionalkeywordspyxkwds pyxpyargnames 0 values posargs determinize  0 pyxerr0 0000 pyxl0error$^      $^     else $^      switch pytuplegetsizepyxargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        break$^        default goto pyxl0argtupleerror$^      $^    $^    pyxvifst  struct pyxobj0pywrapfstfst values0$^    if values0 $^      pyxvdelta  pyxpyfloatasfloatvalues0 if unlikelypyxvdelta  float0  pyerroccurred pyxerr0 0000 pyxl0error$^     else $^      pyxvdelta  pyxk00$^    $^    pyxvdettype  values0$^    if values0 $^      pyxvnstate  pyxpyintasint00tvalues0 if unlikelypyxvnstate  int00t0  pyerroccurred pyxerr0 0000 pyxl0error$^     else $^      pyxvnstate  pyxk00$^    $^    if values0 $^      pyxvsubsequentiallabel  pyxpyintasint00tvalues0 if unlikelypyxvsubsequentiallabel  int00t0  pyerroccurred pyxerr0 0000 pyxl0error$^     else $^      pyxvsubsequentiallabel  pyxt00basictypesint000$^    $^    pyxvweight  values0$^    if values0 $^      pyxvincrementsubsequentiallabel  pyxpyobjectistruevalues0 if unlikelypyxvincrementsubsequentiallabel  bool0  pyerroccurred pyxerr0 0000 pyxl0error$^     else $^$^       pywrapfst.pyx0000$^                                int00 subsequentiallabel0$^                                weightnone$^                                bool incrementsubsequentiallabelfalse              $^    $^    determinizeifst delta0e0 dettypefunctional$^ $^      pyxvincrementsubsequentiallabel  bool0$^    $^  $^  goto pyxl0argumentunpackingdone$^  pyxl0argtupleerror$^  pyxraiseargtupleinvaliddeterminize 0 0 0 pytuplegetsizepyxargs pyxerr0 0000 pyxl0error$^  pyxl0error$^  pyxaddtracebackpywrapfst.determinize pyxclineno pyxlineno pyxfilename$^  pyxrefnannyfinishcontext$^  return null$^  pyxl0argumentunpackingdone$^  if unlikelypyxargtypetestpyobject pyxvifst pyxptype0pywrapfstfst 0 ifst 0 pyxerr0 0000 pyxl0error$^  pyxr  pyxpf0pywrapfst00determinizepyxself pyxvifst pyxvdelta pyxvdettype pyxvnstate pyxvsubsequentiallabel pyxvweight pyxvincrementsubsequentiallabel$^$^   pywrapfst.pyx0000$^  $^  $^  cpdef mutablefst determinizefst ifst              $^                                float deltafst.kshortestdelta$^                                dettypebfunctional$^ $^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxr  null$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00determinizecythonunused pyobject pyxself struct pyxobj0pywrapfstfst pyxvifst float pyxvdelta pyobject pyxvdettype pyxt00basictypesint00 pyxvnstate pyxt00basictypesint00 pyxvsubsequentiallabel pyobject pyxvweight bool pyxvincrementsubsequentiallabel $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  struct pyxoptargs0pywrapfstdeterminize pyxt0$^  pyxrefnannysetupcontextdeterminize 0$^  pyxxdecrefpyxr$^  pyxt0.pyxn  0$^  pyxt0.delta  pyxvdelta$^  pyxt0.dettype  pyxvdettype$^  pyxt0.nstate  pyxvnstate$^  pyxt0.subsequentiallabel  pyxvsubsequentiallabel$^  pyxt0.weight  pyxvweight$^  pyxt0.incrementsubsequentiallabel  pyxvincrementsubsequentiallabel$^  pyxt0  pyobject pyxf0pywrapfstdeterminizepyxvifst 0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.determinize pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^  $^  $^  cpdef mutablefst differencefst ifst0              $^                               fst ifst0$^                               composefilterbauto$^ $^$^static pyobject pyxpw0pywrapfst00differencepyobject pyxself pyobject pyxargs pyobject pyxkwds proto$^static struct pyxobj0pywrapfstmutablefst pyxf0pywrapfstdifferencestruct pyxobj0pywrapfstfst pyxvifst0 struct pyxobj0pywrapfstfst pyxvifst0 cythonunused int pyxskipdispatch struct pyxoptargs0pywrapfstdifference pyxoptionalargs $^  pyobject pyxvcomposefilter  pyobject pyxnbauto$^$^   pywrapfst.pyx0000$^                               fst ifst0$^                               composefilterbauto$^                               bool connecttrue              $^    $^    differenceifst0 ifst0 composefilterauto connecttrue$^ $^  bool pyxvconnect  bool0$^  stduniqueptrfstscriptvectorfstclass  pyxvtfst$^  stduniqueptrfstcomposeoptions  pyxvopts$^  struct pyxobj0pywrapfstmutablefst pyxr  null$^  pyxrefnannydeclarations$^  stdstring pyxt0$^  enum fstcomposefilter pyxt0$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextdifference 0$^  if pyxoptionalargs $^    if pyxoptionalargspyxn  0 $^      pyxvcomposefilter  pyxoptionalargscomposefilter$^      if pyxoptionalargspyxn  0 $^        pyxvconnect  pyxoptionalargsconnect$^      $^    $^  $^$^   pywrapfst.pyx0000$^    $^    cdef uniqueptrfst.vectorfstclass tfst$^    tfst.resetnew fst.vectorfstclassifst0.arctype              $^    cdef uniqueptrfst.composeoptions opts$^    opts.resetnew fst.composeoptionsconnect getcomposefilter$^ $^  if unlikelypyobject pyxvifst0  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s arctype$^    pyxerr0 0000 pyxl0error$^  $^  pyxvtfst.resetnew fstscriptvectorfstclassstruct pyxvtabstruct0pywrapfstfst pyxvifst0pyxvtabarctypepyxvifst0 0$^$^   pywrapfst.pyx0000$^    cdef uniqueptrfst.composeoptions opts$^    opts.resetnew fst.composeoptionsconnect getcomposefilter$^        tostringcomposefilter              $^    fst.differencederefifst0.fst derefifst0.fst tfst.get derefopts$^    return initmutablefsttfst.release$^ $^  pyxt0  pyxf0pywrapfsttostringpyxvcomposefilter null if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^    tfst.resetnew fst.vectorfstclassifst0.arctype$^    cdef uniqueptrfst.composeoptions opts$^    opts.resetnew fst.composeoptionsconnect getcomposefilter              $^        tostringcomposefilter$^    fst.differencederefifst0.fst derefifst0.fst tfst.get derefopts$^ $^  pyxt0  pyxf0pywrapfstgetcomposefilterpyxt0 if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^  pyxvopts.resetnew fstcomposeoptionspyxvconnect pyxt0$^$^   pywrapfst.pyx0000$^    opts.resetnew fst.composeoptionsconnect getcomposefilter$^        tostringcomposefilter$^    fst.differencederefifst0.fst derefifst0.fst tfst.get derefopts              $^    return initmutablefsttfst.release$^  $^ $^  if unlikelypyobject pyxvifst0  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s fst$^    pyxerr0 0000 pyxl0error$^  $^  if unlikelypyobject pyxvifst0  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s fst$^    pyxerr0 0000 pyxl0error$^  $^  fstscriptdifferencepyxvifst0fst pyxvifst0fst pyxvtfst.get pyxvopts$^$^   pywrapfst.pyx0000$^        tostringcomposefilter$^    fst.differencederefifst0.fst derefifst0.fst tfst.get derefopts$^    return initmutablefsttfst.release              $^  $^  $^ $^  pyxxdecrefpyobject pyxr$^  pyxt0  pyobject pyxf0pywrapfstinitmutablefstpyxvtfst.release if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  struct pyxobj0pywrapfstmutablefst pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   pywrapfst.pyx0000$^  $^  $^  cpdef mutablefst differencefst ifst0              $^                               fst ifst0$^                               composefilterbauto$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.difference pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxl0$^  pyxxgiverefpyobject pyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst00differencepyobject pyxself pyobject pyxargs pyobject pyxkwds proto$^static char pyxdoc0pywrapfst00difference  n  differenceifst0 ifst0 composefilterauto connecttruenn  constructively computes the difference of two fsts.nn  this operation computes the difference between two fsas. only strings that aren  in the first automaton but not in second are retained in the result. the firstn  argument must be an acceptor the second argument must be an unweightedn  epsilonfree deterministic acceptor. the output labels of the firstn  transducer or the input labels of the second transducer must be sorted orn  otherwise support appropriate matchers.nn  argsn    ifst0 the first input fst.n    ifst0 the second input fst.n    composefilter a string matching a known composition filter one ofn        altsequence auto match null sequence trivial.n    connect should the output fst be trimmednn  returnsn    an fst representing the difference of the fsts.n  $^static pyobject pyxpw0pywrapfst00differencepyobject pyxself pyobject pyxargs pyobject pyxkwds $^  struct pyxobj0pywrapfstfst pyxvifst0  0$^  struct pyxobj0pywrapfstfst pyxvifst0  0$^  pyobject pyxvcomposefilter  0$^  bool pyxvconnect$^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextdifference wrapper 0$^  $^    static pyobject pyxpyargnames  pyxnsifst0pyxnsifst0pyxnscomposefilterpyxnsconnect0$^    pyobject values0  0000$^    values0  pyobject pyxnbauto$^    if unlikelypyxkwds $^      pyssizet kwargs$^      const pyssizet posargs  pytuplegetsizepyxargs$^      switch posargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 break$^        default goto pyxl0argtupleerror$^      $^      kwargs  pydictsizepyxkwds$^      switch posargs $^        case  0$^        if likelyvalues0  pyxpydictgetitemstrpyxkwds pyxnsifst0  0 kwargs$^        else goto pyxl0argtupleerror$^        cythonfallthrough$^        case  0$^        if likelyvalues0  pyxpydictgetitemstrpyxkwds pyxnsifst0  0 kwargs$^        else $^          pyxraiseargtupleinvaliddifference 0 0 0 0 pyxerr0 0000 pyxl0error$^        $^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnscomposefilter$^          if value  values0  value kwargs $^        $^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnsconnect$^          if value  values0  value kwargs $^        $^      $^      if unlikelykwargs  0 $^        if unlikelypyxparseoptionalkeywordspyxkwds pyxpyargnames 0 values posargs difference  0 pyxerr0 0000 pyxl0error$^      $^     else $^      switch pytuplegetsizepyxargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        values0  pytuplegetitempyxargs 0$^        break$^        default goto pyxl0argtupleerror$^      $^    $^    pyxvifst0  struct pyxobj0pywrapfstfst values0$^    pyxvifst0  struct pyxobj0pywrapfstfst values0$^    pyxvcomposefilter  values0$^    if values0 $^      pyxvconnect  pyxpyobjectistruevalues0 if unlikelypyxvconnect  bool0  pyerroccurred pyxerr0 0000 pyxl0error$^     else $^$^       pywrapfst.pyx0000$^                               fst ifst0$^                               composefilterbauto$^                               bool connecttrue              $^    $^    differenceifst0 ifst0 composefilterauto connecttrue$^ $^      pyxvconnect  bool0$^    $^  $^  goto pyxl0argumentunpackingdone$^  pyxl0argtupleerror$^  pyxraiseargtupleinvaliddifference 0 0 0 pytuplegetsizepyxargs pyxerr0 0000 pyxl0error$^  pyxl0error$^  pyxaddtracebackpywrapfst.difference pyxclineno pyxlineno pyxfilename$^  pyxrefnannyfinishcontext$^  return null$^  pyxl0argumentunpackingdone$^  if unlikelypyxargtypetestpyobject pyxvifst0 pyxptype0pywrapfstfst 0 ifst0 0 pyxerr0 0000 pyxl0error$^  if unlikelypyxargtypetestpyobject pyxvifst0 pyxptype0pywrapfstfst 0 ifst0 0 pyxerr0 0000 pyxl0error$^  pyxr  pyxpf0pywrapfst00differencepyxself pyxvifst0 pyxvifst0 pyxvcomposefilter pyxvconnect$^$^   pywrapfst.pyx0000$^  $^  $^  cpdef mutablefst differencefst ifst0              $^                               fst ifst0$^                               composefilterbauto$^ $^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxr  null$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00differencecythonunused pyobject pyxself struct pyxobj0pywrapfstfst pyxvifst0 struct pyxobj0pywrapfstfst pyxvifst0 pyobject pyxvcomposefilter bool pyxvconnect $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  struct pyxoptargs0pywrapfstdifference pyxt0$^  pyxrefnannysetupcontextdifference 0$^  pyxxdecrefpyxr$^  pyxt0.pyxn  0$^  pyxt0.composefilter  pyxvcomposefilter$^  pyxt0.connect  pyxvconnect$^  pyxt0  pyobject pyxf0pywrapfstdifferencepyxvifst0 pyxvifst0 0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.difference pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^  $^  $^  cpdef mutablefst disambiguatefst ifst              $^                                 float deltafst.kdelta$^                                 int00 nstatefst.knostateid$^ $^$^static pyobject pyxpw0pywrapfst00disambiguatepyobject pyxself pyobject pyxargs pyobject pyxkwds proto$^static struct pyxobj0pywrapfstmutablefst pyxf0pywrapfstdisambiguatestruct pyxobj0pywrapfstfst pyxvifst cythonunused int pyxskipdispatch struct pyxoptargs0pywrapfstdisambiguate pyxoptionalargs $^  float pyxvdelta  pyxk00$^  pyxt00basictypesint00 pyxvnstate  pyxk00$^  pyxt00basictypesint00 pyxvsubsequentiallabel  pyxt00basictypesint000$^$^   pywrapfst.pyx0000$^                                 int00 nstatefst.knostateid$^                                 int00 subsequentiallabel0$^                                 weightnone              $^    $^    disambiguateifst delta0.0000000000 nstatenostateid$^ $^  pyobject pyxvweight  pyobject pynone$^  stduniqueptrfstscriptvectorfstclass  pyxvtfst$^  fstscriptweightclass pyxvwc$^  stduniqueptrfstscriptdisambiguateoptions  pyxvopts$^  struct pyxobj0pywrapfstmutablefst pyxr  null$^  pyxrefnannydeclarations$^  fstscriptweightclass pyxt0$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextdisambiguate 0$^  if pyxoptionalargs $^    if pyxoptionalargspyxn  0 $^      pyxvdelta  pyxoptionalargsdelta$^      if pyxoptionalargspyxn  0 $^        pyxvnstate  pyxoptionalargsnstate$^        if pyxoptionalargspyxn  0 $^          pyxvsubsequentiallabel  pyxoptionalargssubsequentiallabel$^          if pyxoptionalargspyxn  0 $^            pyxvweight  pyxoptionalargsweight$^          $^        $^      $^    $^  $^$^   pywrapfst.pyx0000$^    $^    cdef uniqueptrfst.vectorfstclass tfst$^    tfst.resetnew fst.vectorfstclassifst.arctype              $^     threshold is set to semiring zero no pruning if no weight is specified.$^    cdef fst.weightclass wc  getweightclassorzeroifst.weighttype$^ $^  if unlikelypyobject pyxvifst  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s arctype$^    pyxerr0 0000 pyxl0error$^  $^  pyxvtfst.resetnew fstscriptvectorfstclassstruct pyxvtabstruct0pywrapfstfst pyxvifstpyxvtabarctypepyxvifst 0$^$^   pywrapfst.pyx0000$^    tfst.resetnew fst.vectorfstclassifst.arctype$^     threshold is set to semiring zero no pruning if no weight is specified.$^    cdef fst.weightclass wc  getweightclassorzeroifst.weighttype              $^                                                       weight$^    cdef uniqueptrfst.disambiguateoptions opts$^ $^  if unlikelypyobject pyxvifst  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s weighttype$^    pyxerr0 0000 pyxl0error$^  $^$^   pywrapfst.pyx0000$^     threshold is set to semiring zero no pruning if no weight is specified.$^    cdef fst.weightclass wc  getweightclassorzeroifst.weighttype$^                                                       weight              $^    cdef uniqueptrfst.disambiguateoptions opts$^    opts.resetnew fst.disambiguateoptionsdelta wc nstate$^ $^  pyxt0  pyxf0pywrapfstgetweightclassorzerostruct pyxvtabstruct0pywrapfstfst pyxvifstpyxvtabweighttypepyxvifst 0 pyxvweight if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^  pyxvwc  pyxt0$^$^   pywrapfst.pyx0000$^                                                       weight$^    cdef uniqueptrfst.disambiguateoptions opts$^    opts.resetnew fst.disambiguateoptionsdelta wc nstate              $^                                           subsequentiallabel$^    fst.disambiguatederefifst.fst tfst.get derefopts$^ $^  pyxvopts.resetnew fstscriptdisambiguateoptionspyxvdelta pyxvwc pyxvnstate pyxvsubsequentiallabel$^$^   pywrapfst.pyx0000$^    opts.resetnew fst.disambiguateoptionsdelta wc nstate$^                                           subsequentiallabel$^    fst.disambiguatederefifst.fst tfst.get derefopts              $^    return initmutablefsttfst.release$^  $^ $^  if unlikelypyobject pyxvifst  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s fst$^    pyxerr0 0000 pyxl0error$^  $^  fstscriptdisambiguatepyxvifstfst pyxvtfst.get pyxvopts$^$^   pywrapfst.pyx0000$^                                           subsequentiallabel$^    fst.disambiguatederefifst.fst tfst.get derefopts$^    return initmutablefsttfst.release              $^  $^  $^ $^  pyxxdecrefpyobject pyxr$^  pyxt0  pyobject pyxf0pywrapfstinitmutablefstpyxvtfst.release if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  struct pyxobj0pywrapfstmutablefst pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   pywrapfst.pyx0000$^  $^  $^  cpdef mutablefst disambiguatefst ifst              $^                                 float deltafst.kdelta$^                                 int00 nstatefst.knostateid$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.disambiguate pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxl0$^  pyxxgiverefpyobject pyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst00disambiguatepyobject pyxself pyobject pyxargs pyobject pyxkwds proto$^static char pyxdoc0pywrapfst00disambiguate  n  disambiguateifst delta0.0000000000 nstatenostateidn               subsequentiallabel0 weightnonenn  constructively disambiguates a weighted transducer.nn  this operation disambiguates a weighted transducer. the result will be ann  equivalent fst that has the property that no two successful paths have then  same input labeling. for this algorithm epsilon transitions are treated asn  regular symbols cf. rmepsilon.nn  argsn    ifst the input fst.n    delta comparisonquantization delta.n    nstate state number threshold.n    subsequentiallabel input label of arc corresponding to residual finaln        output when producing a subsequential transducer.n    weight a weight or weight string indicating the desired weight thresholdn        below which paths are pruned if omitted no paths are pruned.nn  returnsn    an equivalent disambiguated fst.nn  see also determinize rmepsilon.n  $^static pyobject pyxpw0pywrapfst00disambiguatepyobject pyxself pyobject pyxargs pyobject pyxkwds $^  struct pyxobj0pywrapfstfst pyxvifst  0$^  float pyxvdelta$^  pyxt00basictypesint00 pyxvnstate$^  pyxt00basictypesint00 pyxvsubsequentiallabel$^  pyobject pyxvweight  0$^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextdisambiguate wrapper 0$^  $^    static pyobject pyxpyargnames  pyxnsifstpyxnsdeltapyxnsnstatepyxnssubsequentiallabelpyxnsweight0$^    pyobject values0  00000$^$^     pywrapfst.pyx0000$^                                 int00 nstatefst.knostateid$^                                 int00 subsequentiallabel0$^                                 weightnone              $^    $^    disambiguateifst delta0.0000000000 nstatenostateid$^ $^    values0  pyobject pynone$^    if unlikelypyxkwds $^      pyssizet kwargs$^      const pyssizet posargs  pytuplegetsizepyxargs$^      switch posargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 break$^        default goto pyxl0argtupleerror$^      $^      kwargs  pydictsizepyxkwds$^      switch posargs $^        case  0$^        if likelyvalues0  pyxpydictgetitemstrpyxkwds pyxnsifst  0 kwargs$^        else goto pyxl0argtupleerror$^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnsdelta$^          if value  values0  value kwargs $^        $^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnsnstate$^          if value  values0  value kwargs $^        $^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnssubsequentiallabel$^          if value  values0  value kwargs $^        $^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnsweight$^          if value  values0  value kwargs $^        $^      $^      if unlikelykwargs  0 $^        if unlikelypyxparseoptionalkeywordspyxkwds pyxpyargnames 0 values posargs disambiguate  0 pyxerr0 0000 pyxl0error$^      $^     else $^      switch pytuplegetsizepyxargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        break$^        default goto pyxl0argtupleerror$^      $^    $^    pyxvifst  struct pyxobj0pywrapfstfst values0$^    if values0 $^      pyxvdelta  pyxpyfloatasfloatvalues0 if unlikelypyxvdelta  float0  pyerroccurred pyxerr0 0000 pyxl0error$^     else $^      pyxvdelta  pyxk00$^    $^    if values0 $^      pyxvnstate  pyxpyintasint00tvalues0 if unlikelypyxvnstate  int00t0  pyerroccurred pyxerr0 0000 pyxl0error$^     else $^      pyxvnstate  pyxk00$^    $^    if values0 $^      pyxvsubsequentiallabel  pyxpyintasint00tvalues0 if unlikelypyxvsubsequentiallabel  int00t0  pyerroccurred pyxerr0 0000 pyxl0error$^     else $^      pyxvsubsequentiallabel  pyxt00basictypesint000$^    $^    pyxvweight  values0$^  $^  goto pyxl0argumentunpackingdone$^  pyxl0argtupleerror$^  pyxraiseargtupleinvaliddisambiguate 0 0 0 pytuplegetsizepyxargs pyxerr0 0000 pyxl0error$^  pyxl0error$^  pyxaddtracebackpywrapfst.disambiguate pyxclineno pyxlineno pyxfilename$^  pyxrefnannyfinishcontext$^  return null$^  pyxl0argumentunpackingdone$^  if unlikelypyxargtypetestpyobject pyxvifst pyxptype0pywrapfstfst 0 ifst 0 pyxerr0 0000 pyxl0error$^  pyxr  pyxpf0pywrapfst00disambiguatepyxself pyxvifst pyxvdelta pyxvnstate pyxvsubsequentiallabel pyxvweight$^$^   pywrapfst.pyx0000$^  $^  $^  cpdef mutablefst disambiguatefst ifst              $^                                 float deltafst.kdelta$^                                 int00 nstatefst.knostateid$^ $^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxr  null$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00disambiguatecythonunused pyobject pyxself struct pyxobj0pywrapfstfst pyxvifst float pyxvdelta pyxt00basictypesint00 pyxvnstate pyxt00basictypesint00 pyxvsubsequentiallabel pyobject pyxvweight $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  struct pyxoptargs0pywrapfstdisambiguate pyxt0$^  pyxrefnannysetupcontextdisambiguate 0$^  pyxxdecrefpyxr$^  pyxt0.pyxn  0$^  pyxt0.delta  pyxvdelta$^  pyxt0.nstate  pyxvnstate$^  pyxt0.subsequentiallabel  pyxvsubsequentiallabel$^  pyxt0.weight  pyxvweight$^  pyxt0  pyobject pyxf0pywrapfstdisambiguatepyxvifst 0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.disambiguate pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^  $^  $^  cpdef mutablefst epsnormalizefst ifst bool epsnormoutputfalse              $^    $^    epsnormalizeifst epsnormoutputfalse$^ $^$^static pyobject pyxpw0pywrapfst00epsnormalizepyobject pyxself pyobject pyxargs pyobject pyxkwds proto$^static struct pyxobj0pywrapfstmutablefst pyxf0pywrapfstepsnormalizestruct pyxobj0pywrapfstfst pyxvifst cythonunused int pyxskipdispatch struct pyxoptargs0pywrapfstepsnormalize pyxoptionalargs $^  bool pyxvepsnormoutput  bool0$^  stduniqueptrfstscriptvectorfstclass  pyxvtfst$^  struct pyxobj0pywrapfstmutablefst pyxr  null$^  pyxrefnannydeclarations$^  enum fstepsnormalizetype pyxt0$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextepsnormalize 0$^  if pyxoptionalargs $^    if pyxoptionalargspyxn  0 $^      pyxvepsnormoutput  pyxoptionalargsepsnormoutput$^    $^  $^$^   pywrapfst.pyx0000$^    $^    cdef uniqueptrfst.vectorfstclass tfst$^    tfst.resetnew fst.vectorfstclassifst.arctype              $^    fst.epsnormalizederefifst.fst tfst.get fst.epsnormoutput if$^                                                   epsnormoutput else$^ $^  if unlikelypyobject pyxvifst  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s arctype$^    pyxerr0 0000 pyxl0error$^  $^  pyxvtfst.resetnew fstscriptvectorfstclassstruct pyxvtabstruct0pywrapfstfst pyxvifstpyxvtabarctypepyxvifst 0$^$^   pywrapfst.pyx0000$^    cdef uniqueptrfst.vectorfstclass tfst$^    tfst.resetnew fst.vectorfstclassifst.arctype$^    fst.epsnormalizederefifst.fst tfst.get fst.epsnormoutput if              $^                                                   epsnormoutput else$^                                                   fst.epsnorminput$^ $^  if unlikelypyobject pyxvifst  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s fst$^    pyxerr0 0000 pyxl0error$^  $^$^   pywrapfst.pyx0000$^    tfst.resetnew fst.vectorfstclassifst.arctype$^    fst.epsnormalizederefifst.fst tfst.get fst.epsnormoutput if$^                                                   epsnormoutput else              $^                                                   fst.epsnorminput$^    return initmutablefsttfst.release$^ $^  if pyxvepsnormoutput  0 $^$^     pywrapfst.pyx0000$^    cdef uniqueptrfst.vectorfstclass tfst$^    tfst.resetnew fst.vectorfstclassifst.arctype$^    fst.epsnormalizederefifst.fst tfst.get fst.epsnormoutput if              $^                                                   epsnormoutput else$^                                                   fst.epsnorminput$^ $^    pyxt0  fstepsnormoutput$^   else $^$^     pywrapfst.pyx0000$^    fst.epsnormalizederefifst.fst tfst.get fst.epsnormoutput if$^                                                   epsnormoutput else$^                                                   fst.epsnorminput              $^    return initmutablefsttfst.release$^  $^ $^    pyxt0  fstepsnorminput$^  $^$^   pywrapfst.pyx0000$^    cdef uniqueptrfst.vectorfstclass tfst$^    tfst.resetnew fst.vectorfstclassifst.arctype$^    fst.epsnormalizederefifst.fst tfst.get fst.epsnormoutput if              $^                                                   epsnormoutput else$^                                                   fst.epsnorminput$^ $^  fstscriptepsnormalizepyxvifstfst pyxvtfst.get pyxt0$^$^   pywrapfst.pyx0000$^                                                   epsnormoutput else$^                                                   fst.epsnorminput$^    return initmutablefsttfst.release              $^  $^  $^ $^  pyxxdecrefpyobject pyxr$^  pyxt0  pyobject pyxf0pywrapfstinitmutablefstpyxvtfst.release if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  struct pyxobj0pywrapfstmutablefst pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   pywrapfst.pyx0000$^  $^  $^  cpdef mutablefst epsnormalizefst ifst bool epsnormoutputfalse              $^    $^    epsnormalizeifst epsnormoutputfalse$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.epsnormalize pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxl0$^  pyxxgiverefpyobject pyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst00epsnormalizepyobject pyxself pyobject pyxargs pyobject pyxkwds proto$^static char pyxdoc0pywrapfst00epsnormalize  n  epsnormalizeifst epsnormoutputfalsenn  constructively epsilonnormalizes an fst.nn  this operation creates an equivalent fst that is epsilonnormalized. ann  acceptor is epsilonnormalized if it it is epsilonremoved cf. rmepsilon.n  a transducer is input epsilonnormalized if in addition along any path alln  arcs with epsilon input labels follow all arcs with nonepsilon input labels.n  output epsilonnormalized is defined similarly. the input fst must ben  functional.nn  argsn    ifst the input fst.n    epsnormoutput should the fst be output epsilonnormalizednn  returnsn    an equivalent epsilonnormalized fst.nn  see also rmepsilon.n  $^static pyobject pyxpw0pywrapfst00epsnormalizepyobject pyxself pyobject pyxargs pyobject pyxkwds $^  struct pyxobj0pywrapfstfst pyxvifst  0$^  bool pyxvepsnormoutput$^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextepsnormalize wrapper 0$^  $^    static pyobject pyxpyargnames  pyxnsifstpyxnsepsnormoutput0$^    pyobject values0  00$^    if unlikelypyxkwds $^      pyssizet kwargs$^      const pyssizet posargs  pytuplegetsizepyxargs$^      switch posargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 break$^        default goto pyxl0argtupleerror$^      $^      kwargs  pydictsizepyxkwds$^      switch posargs $^        case  0$^        if likelyvalues0  pyxpydictgetitemstrpyxkwds pyxnsifst  0 kwargs$^        else goto pyxl0argtupleerror$^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnsepsnormoutput$^          if value  values0  value kwargs $^        $^      $^      if unlikelykwargs  0 $^        if unlikelypyxparseoptionalkeywordspyxkwds pyxpyargnames 0 values posargs epsnormalize  0 pyxerr0 0000 pyxl0error$^      $^     else $^      switch pytuplegetsizepyxargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        break$^        default goto pyxl0argtupleerror$^      $^    $^    pyxvifst  struct pyxobj0pywrapfstfst values0$^    if values0 $^      pyxvepsnormoutput  pyxpyobjectistruevalues0 if unlikelypyxvepsnormoutput  bool0  pyerroccurred pyxerr0 0000 pyxl0error$^     else $^      pyxvepsnormoutput  bool0$^    $^  $^  goto pyxl0argumentunpackingdone$^  pyxl0argtupleerror$^  pyxraiseargtupleinvalidepsnormalize 0 0 0 pytuplegetsizepyxargs pyxerr0 0000 pyxl0error$^  pyxl0error$^  pyxaddtracebackpywrapfst.epsnormalize pyxclineno pyxlineno pyxfilename$^  pyxrefnannyfinishcontext$^  return null$^  pyxl0argumentunpackingdone$^  if unlikelypyxargtypetestpyobject pyxvifst pyxptype0pywrapfstfst 0 ifst 0 pyxerr0 0000 pyxl0error$^  pyxr  pyxpf0pywrapfst00epsnormalizepyxself pyxvifst pyxvepsnormoutput$^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxr  null$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00epsnormalizecythonunused pyobject pyxself struct pyxobj0pywrapfstfst pyxvifst bool pyxvepsnormoutput $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  struct pyxoptargs0pywrapfstepsnormalize pyxt0$^  pyxrefnannysetupcontextepsnormalize 0$^  pyxxdecrefpyxr$^  pyxt0.pyxn  0$^  pyxt0.epsnormoutput  pyxvepsnormoutput$^  pyxt0  pyobject pyxf0pywrapfstepsnormalizepyxvifst 0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.epsnormalize pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^  $^  $^  cpdef bool equalfst ifst0 fst ifst0 float deltafst.kdelta              $^    $^    equalifst0 ifst0 delta0.0000000000$^ $^$^static pyobject pyxpw0pywrapfst00equalpyobject pyxself pyobject pyxargs pyobject pyxkwds proto$^static bool pyxf0pywrapfstequalstruct pyxobj0pywrapfstfst pyxvifst0 struct pyxobj0pywrapfstfst pyxvifst0 cythonunused int pyxskipdispatch struct pyxoptargs0pywrapfstequal pyxoptionalargs $^  float pyxvdelta  pyxk00$^  bool pyxr$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextequal 0$^  if pyxoptionalargs $^    if pyxoptionalargspyxn  0 $^      pyxvdelta  pyxoptionalargsdelta$^    $^  $^$^   pywrapfst.pyx0000$^    see also equivalent isomorphic randequivalent.$^    $^    return fst.equalderefifst0.fst derefifst0.fst delta              $^  $^  $^ $^  if unlikelypyobject pyxvifst0  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s fst$^    pyxerr0 0000 pyxl0error$^  $^  if unlikelypyobject pyxvifst0  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s fst$^    pyxerr0 0000 pyxl0error$^  $^  pyxr  fstscriptequalpyxvifst0fst pyxvifst0fst pyxvdelta$^  goto pyxl0$^$^   pywrapfst.pyx0000$^  $^  $^  cpdef bool equalfst ifst0 fst ifst0 float deltafst.kdelta              $^    $^    equalifst0 ifst0 delta0.0000000000$^ $^$^   function exit code $^  pyxl0error$^  pyxwriteunraisablepywrapfst.equal pyxclineno pyxlineno pyxfilename 0 0$^  pyxr  0$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst00equalpyobject pyxself pyobject pyxargs pyobject pyxkwds proto$^static char pyxdoc0pywrapfst00equal  n  equalifst0 ifst0 delta0.0000000000nn  are two fsts equalnn  this function tests whether two fsts have the same states with the samen  numbering and the same transitions with the same labels and weights in then  same order.nn  argsn    ifst0 the first input fst.n    ifst0 the second input fst.n    delta comparisonquantization delta.nn  returnsn    true if the fsts satisfy the above condition else false.nn  see also equivalent isomorphic randequivalent.n  $^static pyobject pyxpw0pywrapfst00equalpyobject pyxself pyobject pyxargs pyobject pyxkwds $^  struct pyxobj0pywrapfstfst pyxvifst0  0$^  struct pyxobj0pywrapfstfst pyxvifst0  0$^  float pyxvdelta$^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextequal wrapper 0$^  $^    static pyobject pyxpyargnames  pyxnsifst0pyxnsifst0pyxnsdelta0$^    pyobject values0  000$^    if unlikelypyxkwds $^      pyssizet kwargs$^      const pyssizet posargs  pytuplegetsizepyxargs$^      switch posargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 break$^        default goto pyxl0argtupleerror$^      $^      kwargs  pydictsizepyxkwds$^      switch posargs $^        case  0$^        if likelyvalues0  pyxpydictgetitemstrpyxkwds pyxnsifst0  0 kwargs$^        else goto pyxl0argtupleerror$^        cythonfallthrough$^        case  0$^        if likelyvalues0  pyxpydictgetitemstrpyxkwds pyxnsifst0  0 kwargs$^        else $^          pyxraiseargtupleinvalidequal 0 0 0 0 pyxerr0 0000 pyxl0error$^        $^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnsdelta$^          if value  values0  value kwargs $^        $^      $^      if unlikelykwargs  0 $^        if unlikelypyxparseoptionalkeywordspyxkwds pyxpyargnames 0 values posargs equal  0 pyxerr0 0000 pyxl0error$^      $^     else $^      switch pytuplegetsizepyxargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        values0  pytuplegetitempyxargs 0$^        break$^        default goto pyxl0argtupleerror$^      $^    $^    pyxvifst0  struct pyxobj0pywrapfstfst values0$^    pyxvifst0  struct pyxobj0pywrapfstfst values0$^    if values0 $^      pyxvdelta  pyxpyfloatasfloatvalues0 if unlikelypyxvdelta  float0  pyerroccurred pyxerr0 0000 pyxl0error$^     else $^      pyxvdelta  pyxk00$^    $^  $^  goto pyxl0argumentunpackingdone$^  pyxl0argtupleerror$^  pyxraiseargtupleinvalidequal 0 0 0 pytuplegetsizepyxargs pyxerr0 0000 pyxl0error$^  pyxl0error$^  pyxaddtracebackpywrapfst.equal pyxclineno pyxlineno pyxfilename$^  pyxrefnannyfinishcontext$^  return null$^  pyxl0argumentunpackingdone$^  if unlikelypyxargtypetestpyobject pyxvifst0 pyxptype0pywrapfstfst 0 ifst0 0 pyxerr0 0000 pyxl0error$^  if unlikelypyxargtypetestpyobject pyxvifst0 pyxptype0pywrapfstfst 0 ifst0 0 pyxerr0 0000 pyxl0error$^  pyxr  pyxpf0pywrapfst00equalpyxself pyxvifst0 pyxvifst0 pyxvdelta$^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxr  null$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00equalcythonunused pyobject pyxself struct pyxobj0pywrapfstfst pyxvifst0 struct pyxobj0pywrapfstfst pyxvifst0 float pyxvdelta $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  bool pyxt0$^  struct pyxoptargs0pywrapfstequal pyxt0$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextequal 0$^  pyxxdecrefpyxr$^  pyxt0.pyxn  0$^  pyxt0.delta  pyxvdelta$^  pyxt0  pyxf0pywrapfstequalpyxvifst0 pyxvifst0 0 pyxt0 $^  pyxt0  pyxpyboolfromlongpyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.equal pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^  $^  $^  cpdef bool equivalentfst ifst0 fst ifst0 float deltafst.kdelta except               $^    $^    equivalentifst0 ifst0 delta0.0000000000$^ $^$^static pyobject pyxpw0pywrapfst00equivalentpyobject pyxself pyobject pyxargs pyobject pyxkwds proto$^static bool pyxf0pywrapfstequivalentstruct pyxobj0pywrapfstfst pyxvifst0 struct pyxobj0pywrapfstfst pyxvifst0 cythonunused int pyxskipdispatch struct pyxoptargs0pywrapfstequivalent pyxoptionalargs $^  float pyxvdelta  pyxk00$^  bool pyxr$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextequivalent 0$^  if pyxoptionalargs $^    if pyxoptionalargspyxn  0 $^      pyxvdelta  pyxoptionalargsdelta$^    $^  $^$^   pywrapfst.pyx0000$^    see also equal isomorphic randequivalent.$^    $^    return fst.equivalentderefifst0.fst derefifst0.fst delta              $^  $^  $^ $^  if unlikelypyobject pyxvifst0  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s fst$^    pyxerr0 0000 pyxl0error$^  $^  if unlikelypyobject pyxvifst0  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s fst$^    pyxerr0 0000 pyxl0error$^  $^  pyxr  fstscriptequivalentpyxvifst0fst pyxvifst0fst pyxvdelta$^  goto pyxl0$^$^   pywrapfst.pyx0000$^  $^  $^  cpdef bool equivalentfst ifst0 fst ifst0 float deltafst.kdelta except               $^    $^    equivalentifst0 ifst0 delta0.0000000000$^ $^$^   function exit code $^  pyxl0error$^  pyxaddtracebackpywrapfst.equivalent pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst00equivalentpyobject pyxself pyobject pyxargs pyobject pyxkwds proto$^static char pyxdoc0pywrapfst00equivalent  n  equivalentifst0 ifst0 delta0.0000000000nn  are the two acceptors equivalentnn  this operation tests whether two epsilonfree deterministic weightedn  acceptors are equivalent that is if they accept the same strings with then  same weights.nn  argsn    ifst0 the first input fst.n    ifst0 the second input fst.n    delta comparisonquantization delta.nn  returnsn    true if the fsts satisfy the above condition else false.nn  see also equal isomorphic randequivalent.n  $^static pyobject pyxpw0pywrapfst00equivalentpyobject pyxself pyobject pyxargs pyobject pyxkwds $^  struct pyxobj0pywrapfstfst pyxvifst0  0$^  struct pyxobj0pywrapfstfst pyxvifst0  0$^  float pyxvdelta$^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextequivalent wrapper 0$^  $^    static pyobject pyxpyargnames  pyxnsifst0pyxnsifst0pyxnsdelta0$^    pyobject values0  000$^    if unlikelypyxkwds $^      pyssizet kwargs$^      const pyssizet posargs  pytuplegetsizepyxargs$^      switch posargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 break$^        default goto pyxl0argtupleerror$^      $^      kwargs  pydictsizepyxkwds$^      switch posargs $^        case  0$^        if likelyvalues0  pyxpydictgetitemstrpyxkwds pyxnsifst0  0 kwargs$^        else goto pyxl0argtupleerror$^        cythonfallthrough$^        case  0$^        if likelyvalues0  pyxpydictgetitemstrpyxkwds pyxnsifst0  0 kwargs$^        else $^          pyxraiseargtupleinvalidequivalent 0 0 0 0 pyxerr0 0000 pyxl0error$^        $^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnsdelta$^          if value  values0  value kwargs $^        $^      $^      if unlikelykwargs  0 $^        if unlikelypyxparseoptionalkeywordspyxkwds pyxpyargnames 0 values posargs equivalent  0 pyxerr0 0000 pyxl0error$^      $^     else $^      switch pytuplegetsizepyxargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        values0  pytuplegetitempyxargs 0$^        break$^        default goto pyxl0argtupleerror$^      $^    $^    pyxvifst0  struct pyxobj0pywrapfstfst values0$^    pyxvifst0  struct pyxobj0pywrapfstfst values0$^    if values0 $^      pyxvdelta  pyxpyfloatasfloatvalues0 if unlikelypyxvdelta  float0  pyerroccurred pyxerr0 0000 pyxl0error$^     else $^      pyxvdelta  pyxk00$^    $^  $^  goto pyxl0argumentunpackingdone$^  pyxl0argtupleerror$^  pyxraiseargtupleinvalidequivalent 0 0 0 pytuplegetsizepyxargs pyxerr0 0000 pyxl0error$^  pyxl0error$^  pyxaddtracebackpywrapfst.equivalent pyxclineno pyxlineno pyxfilename$^  pyxrefnannyfinishcontext$^  return null$^  pyxl0argumentunpackingdone$^  if unlikelypyxargtypetestpyobject pyxvifst0 pyxptype0pywrapfstfst 0 ifst0 0 pyxerr0 0000 pyxl0error$^  if unlikelypyxargtypetestpyobject pyxvifst0 pyxptype0pywrapfstfst 0 ifst0 0 pyxerr0 0000 pyxl0error$^  pyxr  pyxpf0pywrapfst00equivalentpyxself pyxvifst0 pyxvifst0 pyxvdelta$^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxr  null$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00equivalentcythonunused pyobject pyxself struct pyxobj0pywrapfstfst pyxvifst0 struct pyxobj0pywrapfstfst pyxvifst0 float pyxvdelta $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  bool pyxt0$^  struct pyxoptargs0pywrapfstequivalent pyxt0$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextequivalent 0$^  pyxxdecrefpyxr$^  pyxt0.pyxn  0$^  pyxt0.delta  pyxvdelta$^  pyxt0  pyxf0pywrapfstequivalentpyxvifst0 pyxvifst0 0 pyxt0 if unlikelypyxt0  bool0  pyerroccurred pyxerr0 0000 pyxl0error$^  pyxt0  pyxpyboolfromlongpyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.equivalent pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^  $^  $^  cpdef mutablefst intersectfst ifst0              $^                              fst ifst0$^                              composefilterbauto$^ $^$^static pyobject pyxpw0pywrapfst00intersectpyobject pyxself pyobject pyxargs pyobject pyxkwds proto$^static struct pyxobj0pywrapfstmutablefst pyxf0pywrapfstintersectstruct pyxobj0pywrapfstfst pyxvifst0 struct pyxobj0pywrapfstfst pyxvifst0 cythonunused int pyxskipdispatch struct pyxoptargs0pywrapfstintersect pyxoptionalargs $^  pyobject pyxvcomposefilter  pyobject pyxnbauto$^$^   pywrapfst.pyx0000$^                              fst ifst0$^                              composefilterbauto$^                              bool connecttrue              $^    $^    intersectifst0 ifst0 composefilterauto connecttrue$^ $^  bool pyxvconnect  bool0$^  stduniqueptrfstscriptvectorfstclass  pyxvtfst$^  stduniqueptrfstcomposeoptions  pyxvopts$^  struct pyxobj0pywrapfstmutablefst pyxr  null$^  pyxrefnannydeclarations$^  stdstring pyxt0$^  enum fstcomposefilter pyxt0$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextintersect 0$^  if pyxoptionalargs $^    if pyxoptionalargspyxn  0 $^      pyxvcomposefilter  pyxoptionalargscomposefilter$^      if pyxoptionalargspyxn  0 $^        pyxvconnect  pyxoptionalargsconnect$^      $^    $^  $^$^   pywrapfst.pyx0000$^    $^    cdef uniqueptrfst.vectorfstclass tfst$^    tfst.resetnew fst.vectorfstclassifst0.arctype              $^    cdef uniqueptrfst.composeoptions opts$^    opts.resetnew fst.composeoptionsconnect$^ $^  if unlikelypyobject pyxvifst0  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s arctype$^    pyxerr0 0000 pyxl0error$^  $^  pyxvtfst.resetnew fstscriptvectorfstclassstruct pyxvtabstruct0pywrapfstfst pyxvifst0pyxvtabarctypepyxvifst0 0$^$^   pywrapfst.pyx0000$^    cdef uniqueptrfst.composeoptions opts$^    opts.resetnew fst.composeoptionsconnect$^          getcomposefiltertostringcomposefilter              $^    fst.intersectderefifst0.fst derefifst0.fst tfst.get derefopts$^    return initmutablefsttfst.release$^ $^  pyxt0  pyxf0pywrapfsttostringpyxvcomposefilter null if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^  pyxt0  pyxf0pywrapfstgetcomposefilterpyxt0 if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^    tfst.resetnew fst.vectorfstclassifst0.arctype$^    cdef uniqueptrfst.composeoptions opts$^    opts.resetnew fst.composeoptionsconnect              $^          getcomposefiltertostringcomposefilter$^    fst.intersectderefifst0.fst derefifst0.fst tfst.get derefopts$^ $^  pyxvopts.resetnew fstcomposeoptionspyxvconnect pyxt0$^$^   pywrapfst.pyx0000$^    opts.resetnew fst.composeoptionsconnect$^          getcomposefiltertostringcomposefilter$^    fst.intersectderefifst0.fst derefifst0.fst tfst.get derefopts              $^    return initmutablefsttfst.release$^  $^ $^  if unlikelypyobject pyxvifst0  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s fst$^    pyxerr0 0000 pyxl0error$^  $^  if unlikelypyobject pyxvifst0  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s fst$^    pyxerr0 0000 pyxl0error$^  $^  fstscriptintersectpyxvifst0fst pyxvifst0fst pyxvtfst.get pyxvopts$^$^   pywrapfst.pyx0000$^          getcomposefiltertostringcomposefilter$^    fst.intersectderefifst0.fst derefifst0.fst tfst.get derefopts$^    return initmutablefsttfst.release              $^  $^  $^ $^  pyxxdecrefpyobject pyxr$^  pyxt0  pyobject pyxf0pywrapfstinitmutablefstpyxvtfst.release if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  struct pyxobj0pywrapfstmutablefst pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   pywrapfst.pyx0000$^  $^  $^  cpdef mutablefst intersectfst ifst0              $^                              fst ifst0$^                              composefilterbauto$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.intersect pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxl0$^  pyxxgiverefpyobject pyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst00intersectpyobject pyxself pyobject pyxargs pyobject pyxkwds proto$^static char pyxdoc0pywrapfst00intersect  n  intersectifst0 ifst0 composefilterauto connecttruenn  constructively intersects two fsts.nn  this operation computes the intersection hadamard product of two fsts.n  only strings that are in both automata are retained in the result. the twon  arguments must be acceptors. one of the arguments must be labelsorted orn  otherwise support appropriate matchers.nn  argsn    ifst0 the first input fst.n    ifst0 the second input fst.n    composefilter a string matching a known composition filter one ofn        altsequence auto match null sequence trivial.n    connect should output be trimmednn  returnsn    an intersected fst.n  $^static pyobject pyxpw0pywrapfst00intersectpyobject pyxself pyobject pyxargs pyobject pyxkwds $^  struct pyxobj0pywrapfstfst pyxvifst0  0$^  struct pyxobj0pywrapfstfst pyxvifst0  0$^  pyobject pyxvcomposefilter  0$^  bool pyxvconnect$^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextintersect wrapper 0$^  $^    static pyobject pyxpyargnames  pyxnsifst0pyxnsifst0pyxnscomposefilterpyxnsconnect0$^    pyobject values0  0000$^    values0  pyobject pyxnbauto$^    if unlikelypyxkwds $^      pyssizet kwargs$^      const pyssizet posargs  pytuplegetsizepyxargs$^      switch posargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 break$^        default goto pyxl0argtupleerror$^      $^      kwargs  pydictsizepyxkwds$^      switch posargs $^        case  0$^        if likelyvalues0  pyxpydictgetitemstrpyxkwds pyxnsifst0  0 kwargs$^        else goto pyxl0argtupleerror$^        cythonfallthrough$^        case  0$^        if likelyvalues0  pyxpydictgetitemstrpyxkwds pyxnsifst0  0 kwargs$^        else $^          pyxraiseargtupleinvalidintersect 0 0 0 0 pyxerr0 0000 pyxl0error$^        $^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnscomposefilter$^          if value  values0  value kwargs $^        $^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnsconnect$^          if value  values0  value kwargs $^        $^      $^      if unlikelykwargs  0 $^        if unlikelypyxparseoptionalkeywordspyxkwds pyxpyargnames 0 values posargs intersect  0 pyxerr0 0000 pyxl0error$^      $^     else $^      switch pytuplegetsizepyxargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        values0  pytuplegetitempyxargs 0$^        break$^        default goto pyxl0argtupleerror$^      $^    $^    pyxvifst0  struct pyxobj0pywrapfstfst values0$^    pyxvifst0  struct pyxobj0pywrapfstfst values0$^    pyxvcomposefilter  values0$^    if values0 $^      pyxvconnect  pyxpyobjectistruevalues0 if unlikelypyxvconnect  bool0  pyerroccurred pyxerr0 0000 pyxl0error$^     else $^$^       pywrapfst.pyx0000$^                              fst ifst0$^                              composefilterbauto$^                              bool connecttrue              $^    $^    intersectifst0 ifst0 composefilterauto connecttrue$^ $^      pyxvconnect  bool0$^    $^  $^  goto pyxl0argumentunpackingdone$^  pyxl0argtupleerror$^  pyxraiseargtupleinvalidintersect 0 0 0 pytuplegetsizepyxargs pyxerr0 0000 pyxl0error$^  pyxl0error$^  pyxaddtracebackpywrapfst.intersect pyxclineno pyxlineno pyxfilename$^  pyxrefnannyfinishcontext$^  return null$^  pyxl0argumentunpackingdone$^  if unlikelypyxargtypetestpyobject pyxvifst0 pyxptype0pywrapfstfst 0 ifst0 0 pyxerr0 0000 pyxl0error$^  if unlikelypyxargtypetestpyobject pyxvifst0 pyxptype0pywrapfstfst 0 ifst0 0 pyxerr0 0000 pyxl0error$^  pyxr  pyxpf0pywrapfst00intersectpyxself pyxvifst0 pyxvifst0 pyxvcomposefilter pyxvconnect$^$^   pywrapfst.pyx0000$^  $^  $^  cpdef mutablefst intersectfst ifst0              $^                              fst ifst0$^                              composefilterbauto$^ $^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxr  null$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00intersectcythonunused pyobject pyxself struct pyxobj0pywrapfstfst pyxvifst0 struct pyxobj0pywrapfstfst pyxvifst0 pyobject pyxvcomposefilter bool pyxvconnect $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  struct pyxoptargs0pywrapfstintersect pyxt0$^  pyxrefnannysetupcontextintersect 0$^  pyxxdecrefpyxr$^  pyxt0.pyxn  0$^  pyxt0.composefilter  pyxvcomposefilter$^  pyxt0.connect  pyxvconnect$^  pyxt0  pyobject pyxf0pywrapfstintersectpyxvifst0 pyxvifst0 0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.intersect pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^  $^  $^  cpdef bool isomorphicfst ifst0 fst ifst0 float deltafst.kdelta              $^    $^    isomorphicifst0 ifst0 delta0.0000000000$^ $^$^static pyobject pyxpw0pywrapfst00isomorphicpyobject pyxself pyobject pyxargs pyobject pyxkwds proto$^static bool pyxf0pywrapfstisomorphicstruct pyxobj0pywrapfstfst pyxvifst0 struct pyxobj0pywrapfstfst pyxvifst0 cythonunused int pyxskipdispatch struct pyxoptargs0pywrapfstisomorphic pyxoptionalargs $^  float pyxvdelta  pyxk00$^  bool pyxr$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextisomorphic 0$^  if pyxoptionalargs $^    if pyxoptionalargspyxn  0 $^      pyxvdelta  pyxoptionalargsdelta$^    $^  $^$^   pywrapfst.pyx0000$^    see also equal equivalent randequivalent.$^    $^    return fst.isomorphicderefifst0.fst derefifst0.fst delta              $^  $^  $^ $^  if unlikelypyobject pyxvifst0  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s fst$^    pyxerr0 0000 pyxl0error$^  $^  if unlikelypyobject pyxvifst0  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s fst$^    pyxerr0 0000 pyxl0error$^  $^  pyxr  fstscriptisomorphicpyxvifst0fst pyxvifst0fst pyxvdelta$^  goto pyxl0$^$^   pywrapfst.pyx0000$^  $^  $^  cpdef bool isomorphicfst ifst0 fst ifst0 float deltafst.kdelta              $^    $^    isomorphicifst0 ifst0 delta0.0000000000$^ $^$^   function exit code $^  pyxl0error$^  pyxwriteunraisablepywrapfst.isomorphic pyxclineno pyxlineno pyxfilename 0 0$^  pyxr  0$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst00isomorphicpyobject pyxself pyobject pyxargs pyobject pyxkwds proto$^static char pyxdoc0pywrapfst00isomorphic  n  isomorphicifst0 ifst0 delta0.0000000000nn  are the two acceptors isomorphicnn  this operation determines if two transducers with a certain requiredn  determinism have the same states irrespective of numbering and the samen  transitions with the same labels and weights irrespective of ordering. inn  other words fsts a b are isomorphic if and only if the states of a can ben  renumbered and the transitions leaving each state reordered so the two aren  equal according to the definition given in equal.nn  argsn    ifst0 the first input fst.n    ifst0 the second input fst.n    delta comparisonquantization delta.nn  returnsn    true if the two transducers satisfy the above condition else false.nn  see also equal equivalent randequivalent.n  $^static pyobject pyxpw0pywrapfst00isomorphicpyobject pyxself pyobject pyxargs pyobject pyxkwds $^  struct pyxobj0pywrapfstfst pyxvifst0  0$^  struct pyxobj0pywrapfstfst pyxvifst0  0$^  float pyxvdelta$^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextisomorphic wrapper 0$^  $^    static pyobject pyxpyargnames  pyxnsifst0pyxnsifst0pyxnsdelta0$^    pyobject values0  000$^    if unlikelypyxkwds $^      pyssizet kwargs$^      const pyssizet posargs  pytuplegetsizepyxargs$^      switch posargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 break$^        default goto pyxl0argtupleerror$^      $^      kwargs  pydictsizepyxkwds$^      switch posargs $^        case  0$^        if likelyvalues0  pyxpydictgetitemstrpyxkwds pyxnsifst0  0 kwargs$^        else goto pyxl0argtupleerror$^        cythonfallthrough$^        case  0$^        if likelyvalues0  pyxpydictgetitemstrpyxkwds pyxnsifst0  0 kwargs$^        else $^          pyxraiseargtupleinvalidisomorphic 0 0 0 0 pyxerr0 0000 pyxl0error$^        $^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnsdelta$^          if value  values0  value kwargs $^        $^      $^      if unlikelykwargs  0 $^        if unlikelypyxparseoptionalkeywordspyxkwds pyxpyargnames 0 values posargs isomorphic  0 pyxerr0 0000 pyxl0error$^      $^     else $^      switch pytuplegetsizepyxargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        values0  pytuplegetitempyxargs 0$^        break$^        default goto pyxl0argtupleerror$^      $^    $^    pyxvifst0  struct pyxobj0pywrapfstfst values0$^    pyxvifst0  struct pyxobj0pywrapfstfst values0$^    if values0 $^      pyxvdelta  pyxpyfloatasfloatvalues0 if unlikelypyxvdelta  float0  pyerroccurred pyxerr0 0000 pyxl0error$^     else $^      pyxvdelta  pyxk00$^    $^  $^  goto pyxl0argumentunpackingdone$^  pyxl0argtupleerror$^  pyxraiseargtupleinvalidisomorphic 0 0 0 pytuplegetsizepyxargs pyxerr0 0000 pyxl0error$^  pyxl0error$^  pyxaddtracebackpywrapfst.isomorphic pyxclineno pyxlineno pyxfilename$^  pyxrefnannyfinishcontext$^  return null$^  pyxl0argumentunpackingdone$^  if unlikelypyxargtypetestpyobject pyxvifst0 pyxptype0pywrapfstfst 0 ifst0 0 pyxerr0 0000 pyxl0error$^  if unlikelypyxargtypetestpyobject pyxvifst0 pyxptype0pywrapfstfst 0 ifst0 0 pyxerr0 0000 pyxl0error$^  pyxr  pyxpf0pywrapfst00isomorphicpyxself pyxvifst0 pyxvifst0 pyxvdelta$^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxr  null$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00isomorphiccythonunused pyobject pyxself struct pyxobj0pywrapfstfst pyxvifst0 struct pyxobj0pywrapfstfst pyxvifst0 float pyxvdelta $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  bool pyxt0$^  struct pyxoptargs0pywrapfstisomorphic pyxt0$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextisomorphic 0$^  pyxxdecrefpyxr$^  pyxt0.pyxn  0$^  pyxt0.delta  pyxvdelta$^  pyxt0  pyxf0pywrapfstisomorphicpyxvifst0 pyxvifst0 0 pyxt0 $^  pyxt0  pyxpyboolfromlongpyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.isomorphic pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^  $^  $^  cpdef mutablefst prunefst ifst              $^                          float deltafst.kdelta$^                          int00 nstatefst.knostateid$^ $^$^static pyobject pyxpw0pywrapfst00prunepyobject pyxself pyobject pyxargs pyobject pyxkwds proto$^static struct pyxobj0pywrapfstmutablefst pyxf0pywrapfstprunestruct pyxobj0pywrapfstfst pyxvifst cythonunused int pyxskipdispatch struct pyxoptargs0pywrapfstprune pyxoptionalargs $^  float pyxvdelta  pyxk00$^  pyxt00basictypesint00 pyxvnstate  pyxk00$^$^   pywrapfst.pyx0000$^                          float deltafst.kdelta$^                          int00 nstatefst.knostateid$^                          weightnone              $^    $^    pruneifst delta0.0000000000 nstatenostateid weightnone$^ $^  pyobject pyxvweight  pyobject pynone$^  stduniqueptrfstscriptvectorfstclass  pyxvtfst$^  fstscriptweightclass pyxvwc$^  struct pyxobj0pywrapfstmutablefst pyxr  null$^  pyxrefnannydeclarations$^  fstscriptweightclass pyxt0$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextprune 0$^  if pyxoptionalargs $^    if pyxoptionalargspyxn  0 $^      pyxvdelta  pyxoptionalargsdelta$^      if pyxoptionalargspyxn  0 $^        pyxvnstate  pyxoptionalargsnstate$^        if pyxoptionalargspyxn  0 $^          pyxvweight  pyxoptionalargsweight$^        $^      $^    $^  $^$^   pywrapfst.pyx0000$^    $^    cdef uniqueptrfst.vectorfstclass tfst$^    tfst.resetnew fst.vectorfstclassifst.arctype              $^    cdef fst.weightclass wc  getweightclassorzeroifst.weighttype weight$^    fst.prunederefifst.fst tfst.get wc nstate delta$^ $^  if unlikelypyobject pyxvifst  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s arctype$^    pyxerr0 0000 pyxl0error$^  $^  pyxvtfst.resetnew fstscriptvectorfstclassstruct pyxvtabstruct0pywrapfstfst pyxvifstpyxvtabarctypepyxvifst 0$^$^   pywrapfst.pyx0000$^    cdef uniqueptrfst.vectorfstclass tfst$^    tfst.resetnew fst.vectorfstclassifst.arctype$^    cdef fst.weightclass wc  getweightclassorzeroifst.weighttype weight              $^    fst.prunederefifst.fst tfst.get wc nstate delta$^    return initmutablefsttfst.release$^ $^  if unlikelypyobject pyxvifst  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s weighttype$^    pyxerr0 0000 pyxl0error$^  $^  pyxt0  pyxf0pywrapfstgetweightclassorzerostruct pyxvtabstruct0pywrapfstfst pyxvifstpyxvtabweighttypepyxvifst 0 pyxvweight if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^  pyxvwc  pyxt0$^$^   pywrapfst.pyx0000$^    tfst.resetnew fst.vectorfstclassifst.arctype$^    cdef fst.weightclass wc  getweightclassorzeroifst.weighttype weight$^    fst.prunederefifst.fst tfst.get wc nstate delta              $^    return initmutablefsttfst.release$^  $^ $^  if unlikelypyobject pyxvifst  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s fst$^    pyxerr0 0000 pyxl0error$^  $^  fstscriptprunepyxvifstfst pyxvtfst.get pyxvwc pyxvnstate pyxvdelta$^$^   pywrapfst.pyx0000$^    cdef fst.weightclass wc  getweightclassorzeroifst.weighttype weight$^    fst.prunederefifst.fst tfst.get wc nstate delta$^    return initmutablefsttfst.release              $^  $^  $^ $^  pyxxdecrefpyobject pyxr$^  pyxt0  pyobject pyxf0pywrapfstinitmutablefstpyxvtfst.release if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  struct pyxobj0pywrapfstmutablefst pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   pywrapfst.pyx0000$^  $^  $^  cpdef mutablefst prunefst ifst              $^                          float deltafst.kdelta$^                          int00 nstatefst.knostateid$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.prune pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxl0$^  pyxxgiverefpyobject pyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst00prunepyobject pyxself pyobject pyxargs pyobject pyxkwds proto$^static char pyxdoc0pywrapfst00prune  n  pruneifst delta0.0000000000 nstatenostateid weightnonenn  constructively removes paths with weights below a certain threshold.nn  this operation deletes states and arcs in the input fst that do not belongn  to a successful path whose weight is no more w.r.t the natural semiringn  order than the threshold t otimestimes the weight of the shortest path inn  the input fst. weights must be commutative and have the path property.nn  argsn    ifst the input fst.n    delta comparisonquantization delta.n    nstate state number threshold.n    weight a weight or weight string indicating the desired weight thresholdn        below which paths are pruned if omitted no paths are pruned.nn  returnsn    a pruned fst.nn  see also the destructive variant.n  $^static pyobject pyxpw0pywrapfst00prunepyobject pyxself pyobject pyxargs pyobject pyxkwds $^  struct pyxobj0pywrapfstfst pyxvifst  0$^  float pyxvdelta$^  pyxt00basictypesint00 pyxvnstate$^  pyobject pyxvweight  0$^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextprune wrapper 0$^  $^    static pyobject pyxpyargnames  pyxnsifstpyxnsdeltapyxnsnstatepyxnsweight0$^    pyobject values0  0000$^$^     pywrapfst.pyx0000$^                          float deltafst.kdelta$^                          int00 nstatefst.knostateid$^                          weightnone              $^    $^    pruneifst delta0.0000000000 nstatenostateid weightnone$^ $^    values0  pyobject pynone$^    if unlikelypyxkwds $^      pyssizet kwargs$^      const pyssizet posargs  pytuplegetsizepyxargs$^      switch posargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 break$^        default goto pyxl0argtupleerror$^      $^      kwargs  pydictsizepyxkwds$^      switch posargs $^        case  0$^        if likelyvalues0  pyxpydictgetitemstrpyxkwds pyxnsifst  0 kwargs$^        else goto pyxl0argtupleerror$^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnsdelta$^          if value  values0  value kwargs $^        $^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnsnstate$^          if value  values0  value kwargs $^        $^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnsweight$^          if value  values0  value kwargs $^        $^      $^      if unlikelykwargs  0 $^        if unlikelypyxparseoptionalkeywordspyxkwds pyxpyargnames 0 values posargs prune  0 pyxerr0 0000 pyxl0error$^      $^     else $^      switch pytuplegetsizepyxargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        break$^        default goto pyxl0argtupleerror$^      $^    $^    pyxvifst  struct pyxobj0pywrapfstfst values0$^    if values0 $^      pyxvdelta  pyxpyfloatasfloatvalues0 if unlikelypyxvdelta  float0  pyerroccurred pyxerr0 0000 pyxl0error$^     else $^      pyxvdelta  pyxk00$^    $^    if values0 $^      pyxvnstate  pyxpyintasint00tvalues0 if unlikelypyxvnstate  int00t0  pyerroccurred pyxerr0 0000 pyxl0error$^     else $^      pyxvnstate  pyxk00$^    $^    pyxvweight  values0$^  $^  goto pyxl0argumentunpackingdone$^  pyxl0argtupleerror$^  pyxraiseargtupleinvalidprune 0 0 0 pytuplegetsizepyxargs pyxerr0 0000 pyxl0error$^  pyxl0error$^  pyxaddtracebackpywrapfst.prune pyxclineno pyxlineno pyxfilename$^  pyxrefnannyfinishcontext$^  return null$^  pyxl0argumentunpackingdone$^  if unlikelypyxargtypetestpyobject pyxvifst pyxptype0pywrapfstfst 0 ifst 0 pyxerr0 0000 pyxl0error$^  pyxr  pyxpf0pywrapfst00prunepyxself pyxvifst pyxvdelta pyxvnstate pyxvweight$^$^   pywrapfst.pyx0000$^  $^  $^  cpdef mutablefst prunefst ifst              $^                          float deltafst.kdelta$^                          int00 nstatefst.knostateid$^ $^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxr  null$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00prunecythonunused pyobject pyxself struct pyxobj0pywrapfstfst pyxvifst float pyxvdelta pyxt00basictypesint00 pyxvnstate pyobject pyxvweight $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  struct pyxoptargs0pywrapfstprune pyxt0$^  pyxrefnannysetupcontextprune 0$^  pyxxdecrefpyxr$^  pyxt0.pyxn  0$^  pyxt0.delta  pyxvdelta$^  pyxt0.nstate  pyxvnstate$^  pyxt0.weight  pyxvweight$^  pyxt0  pyobject pyxf0pywrapfstprunepyxvifst 0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.prune pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^  $^  $^  cpdef mutablefst pushfst ifst              $^                         float deltafst.kdelta$^                         bool pushweightsfalse$^ $^$^static pyobject pyxpw0pywrapfst00pushpyobject pyxself pyobject pyxargs pyobject pyxkwds proto$^static struct pyxobj0pywrapfstmutablefst pyxf0pywrapfstpushstruct pyxobj0pywrapfstfst pyxvifst cythonunused int pyxskipdispatch struct pyxoptargs0pywrapfstpush pyxoptionalargs $^  float pyxvdelta  pyxk00$^$^   pywrapfst.pyx0000$^  cpdef mutablefst pushfst ifst$^                         float deltafst.kdelta$^                         bool pushweightsfalse              $^                         bool pushlabelsfalse$^                         bool removecommonaffixfalse$^ $^  bool pyxvpushweights  bool0$^$^   pywrapfst.pyx0000$^                         float deltafst.kdelta$^                         bool pushweightsfalse$^                         bool pushlabelsfalse              $^                         bool removecommonaffixfalse$^                         bool removetotalweightfalse$^ $^  bool pyxvpushlabels  bool0$^$^   pywrapfst.pyx0000$^                         bool pushweightsfalse$^                         bool pushlabelsfalse$^                         bool removecommonaffixfalse              $^                         bool removetotalweightfalse$^                         bool tofinalfalse$^ $^  bool pyxvremovecommonaffix  bool0$^$^   pywrapfst.pyx0000$^                         bool pushlabelsfalse$^                         bool removecommonaffixfalse$^                         bool removetotalweightfalse              $^                         bool tofinalfalse$^    $^ $^  bool pyxvremovetotalweight  bool0$^$^   pywrapfst.pyx0000$^                         bool removecommonaffixfalse$^                         bool removetotalweightfalse$^                         bool tofinalfalse              $^    $^    pushifst delta0.0000000000 pushweightsfalse pushlabelsfalse$^ $^  bool pyxvtofinal  bool0$^  stduniqueptrfstscriptvectorfstclass  pyxvtfst$^  pyxt00basictypesuint00 pyxvflags$^  struct pyxobj0pywrapfstmutablefst pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextpush 0$^  if pyxoptionalargs $^    if pyxoptionalargspyxn  0 $^      pyxvdelta  pyxoptionalargsdelta$^      if pyxoptionalargspyxn  0 $^        pyxvpushweights  pyxoptionalargspushweights$^        if pyxoptionalargspyxn  0 $^          pyxvpushlabels  pyxoptionalargspushlabels$^          if pyxoptionalargspyxn  0 $^            pyxvremovecommonaffix  pyxoptionalargsremovecommonaffix$^            if pyxoptionalargspyxn  0 $^              pyxvremovetotalweight  pyxoptionalargsremovetotalweight$^              if pyxoptionalargspyxn  0 $^                pyxvtofinal  pyxoptionalargstofinal$^              $^            $^          $^        $^      $^    $^  $^$^   pywrapfst.pyx0000$^     this is copied almost verbatim from nlpfstbinfstpush.cc.$^    cdef uniqueptrfst.vectorfstclass tfst$^    tfst.resetnew fst.vectorfstclassifst.arctype              $^    cdef uint00 flags  fst.getpushflagspushweights pushlabels$^                                         removecommonaffix removetotalweight$^ $^  if unlikelypyobject pyxvifst  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s arctype$^    pyxerr0 0000 pyxl0error$^  $^  pyxvtfst.resetnew fstscriptvectorfstclassstruct pyxvtabstruct0pywrapfstfst pyxvifstpyxvtabarctypepyxvifst 0$^$^   pywrapfst.pyx0000$^    cdef uniqueptrfst.vectorfstclass tfst$^    tfst.resetnew fst.vectorfstclassifst.arctype$^    cdef uint00 flags  fst.getpushflagspushweights pushlabels              $^                                         removecommonaffix removetotalweight$^    fst.pushderefifst.fst tfst.get flags fst.getreweighttypetofinal$^ $^  pyxvflags  fstscriptgetpushflagspyxvpushweights pyxvpushlabels pyxvremovecommonaffix pyxvremovetotalweight$^$^   pywrapfst.pyx0000$^    cdef uint00 flags  fst.getpushflagspushweights pushlabels$^                                         removecommonaffix removetotalweight$^    fst.pushderefifst.fst tfst.get flags fst.getreweighttypetofinal              $^             delta$^    return initmutablefsttfst.release$^ $^  if unlikelypyobject pyxvifst  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s fst$^    pyxerr0 0000 pyxl0error$^  $^$^   pywrapfst.pyx0000$^                                         removecommonaffix removetotalweight$^    fst.pushderefifst.fst tfst.get flags fst.getreweighttypetofinal$^             delta              $^    return initmutablefsttfst.release$^  $^ $^  fstscriptpushpyxvifstfst pyxvtfst.get pyxvflags fstscriptgetreweighttypepyxvtofinal pyxvdelta$^$^   pywrapfst.pyx0000$^    fst.pushderefifst.fst tfst.get flags fst.getreweighttypetofinal$^             delta$^    return initmutablefsttfst.release              $^  $^  $^ $^  pyxxdecrefpyobject pyxr$^  pyxt0  pyobject pyxf0pywrapfstinitmutablefstpyxvtfst.release if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  struct pyxobj0pywrapfstmutablefst pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   pywrapfst.pyx0000$^  $^  $^  cpdef mutablefst pushfst ifst              $^                         float deltafst.kdelta$^                         bool pushweightsfalse$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.push pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxl0$^  pyxxgiverefpyobject pyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst00pushpyobject pyxself pyobject pyxargs pyobject pyxkwds proto$^static char pyxdoc0pywrapfst00push  n  pushifst delta0.0000000000 pushweightsfalse pushlabelsfalsen       removecommonaffixfalse removetotalweightfalse tofinalfalsenn  constructively pushes weightslabels towards initial or final states.nn  this operation produces an equivalent transducer by pushing the weightsn  andor the labels towards the initial state or toward the final states.nn  when pushing weights towards the initial state the sum of the weight of then  outgoing transitions and final weight at any noninitial state is equal to 0n  in the resulting machine. when pushing weights towards the final states then  sum of the weight of the incoming transitions at any state is equal to 0.n  weights need to be left distributive when pushing towards the initial staten  and right distributive when pushing towards the final states.nn  pushing labels towards the initial state consists in minimizing at everyn  state the length of the longest common prefix of the output labels of then  outgoing paths. pushing labels towards the final states consists inn  minimizing at every state the length of the longest common suffix of then  output labels of the incoming paths.nn  argsn    ifst the input fst.n    delta comparisonquantization delta.n    pushweights should weights be pushedn    pushlabels should labels be pushedn    removecommonaffix if pushing labels should common prefixsuffix ben        removedn    removetotalweight if pushing weights should total weight be removedn    tofinal push towards final statesnn  returnsn    an equivalent pushed fst.nn  see also the destructive variant.n  $^static pyobject pyxpw0pywrapfst00pushpyobject pyxself pyobject pyxargs pyobject pyxkwds $^  struct pyxobj0pywrapfstfst pyxvifst  0$^  float pyxvdelta$^  bool pyxvpushweights$^  bool pyxvpushlabels$^  bool pyxvremovecommonaffix$^  bool pyxvremovetotalweight$^  bool pyxvtofinal$^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextpush wrapper 0$^  $^    static pyobject pyxpyargnames  pyxnsifstpyxnsdeltapyxnspushweightspyxnspushlabelspyxnsremovecommonaffixpyxnsremovetotalweightpyxnstofinal0$^    pyobject values0  0000000$^    if unlikelypyxkwds $^      pyssizet kwargs$^      const pyssizet posargs  pytuplegetsizepyxargs$^      switch posargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 break$^        default goto pyxl0argtupleerror$^      $^      kwargs  pydictsizepyxkwds$^      switch posargs $^        case  0$^        if likelyvalues0  pyxpydictgetitemstrpyxkwds pyxnsifst  0 kwargs$^        else goto pyxl0argtupleerror$^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnsdelta$^          if value  values0  value kwargs $^        $^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnspushweights$^          if value  values0  value kwargs $^        $^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnspushlabels$^          if value  values0  value kwargs $^        $^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnsremovecommonaffix$^          if value  values0  value kwargs $^        $^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnsremovetotalweight$^          if value  values0  value kwargs $^        $^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnstofinal$^          if value  values0  value kwargs $^        $^      $^      if unlikelykwargs  0 $^        if unlikelypyxparseoptionalkeywordspyxkwds pyxpyargnames 0 values posargs push  0 pyxerr0 0000 pyxl0error$^      $^     else $^      switch pytuplegetsizepyxargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        break$^        default goto pyxl0argtupleerror$^      $^    $^    pyxvifst  struct pyxobj0pywrapfstfst values0$^    if values0 $^      pyxvdelta  pyxpyfloatasfloatvalues0 if unlikelypyxvdelta  float0  pyerroccurred pyxerr0 0000 pyxl0error$^     else $^      pyxvdelta  pyxk00$^    $^    if values0 $^      pyxvpushweights  pyxpyobjectistruevalues0 if unlikelypyxvpushweights  bool0  pyerroccurred pyxerr0 0000 pyxl0error$^     else $^$^       pywrapfst.pyx0000$^  cpdef mutablefst pushfst ifst$^                         float deltafst.kdelta$^                         bool pushweightsfalse              $^                         bool pushlabelsfalse$^                         bool removecommonaffixfalse$^ $^      pyxvpushweights  bool0$^    $^    if values0 $^      pyxvpushlabels  pyxpyobjectistruevalues0 if unlikelypyxvpushlabels  bool0  pyerroccurred pyxerr0 0000 pyxl0error$^     else $^$^       pywrapfst.pyx0000$^                         float deltafst.kdelta$^                         bool pushweightsfalse$^                         bool pushlabelsfalse              $^                         bool removecommonaffixfalse$^                         bool removetotalweightfalse$^ $^      pyxvpushlabels  bool0$^    $^    if values0 $^      pyxvremovecommonaffix  pyxpyobjectistruevalues0 if unlikelypyxvremovecommonaffix  bool0  pyerroccurred pyxerr0 0000 pyxl0error$^     else $^$^       pywrapfst.pyx0000$^                         bool pushweightsfalse$^                         bool pushlabelsfalse$^                         bool removecommonaffixfalse              $^                         bool removetotalweightfalse$^                         bool tofinalfalse$^ $^      pyxvremovecommonaffix  bool0$^    $^    if values0 $^      pyxvremovetotalweight  pyxpyobjectistruevalues0 if unlikelypyxvremovetotalweight  bool0  pyerroccurred pyxerr0 0000 pyxl0error$^     else $^$^       pywrapfst.pyx0000$^                         bool pushlabelsfalse$^                         bool removecommonaffixfalse$^                         bool removetotalweightfalse              $^                         bool tofinalfalse$^    $^ $^      pyxvremovetotalweight  bool0$^    $^    if values0 $^      pyxvtofinal  pyxpyobjectistruevalues0 if unlikelypyxvtofinal  bool0  pyerroccurred pyxerr0 0000 pyxl0error$^     else $^$^       pywrapfst.pyx0000$^                         bool removecommonaffixfalse$^                         bool removetotalweightfalse$^                         bool tofinalfalse              $^    $^    pushifst delta0.0000000000 pushweightsfalse pushlabelsfalse$^ $^      pyxvtofinal  bool0$^    $^  $^  goto pyxl0argumentunpackingdone$^  pyxl0argtupleerror$^  pyxraiseargtupleinvalidpush 0 0 0 pytuplegetsizepyxargs pyxerr0 0000 pyxl0error$^  pyxl0error$^  pyxaddtracebackpywrapfst.push pyxclineno pyxlineno pyxfilename$^  pyxrefnannyfinishcontext$^  return null$^  pyxl0argumentunpackingdone$^  if unlikelypyxargtypetestpyobject pyxvifst pyxptype0pywrapfstfst 0 ifst 0 pyxerr0 0000 pyxl0error$^  pyxr  pyxpf0pywrapfst00pushpyxself pyxvifst pyxvdelta pyxvpushweights pyxvpushlabels pyxvremovecommonaffix pyxvremovetotalweight pyxvtofinal$^$^   pywrapfst.pyx0000$^  $^  $^  cpdef mutablefst pushfst ifst              $^                         float deltafst.kdelta$^                         bool pushweightsfalse$^ $^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxr  null$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00pushcythonunused pyobject pyxself struct pyxobj0pywrapfstfst pyxvifst float pyxvdelta bool pyxvpushweights bool pyxvpushlabels bool pyxvremovecommonaffix bool pyxvremovetotalweight bool pyxvtofinal $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  struct pyxoptargs0pywrapfstpush pyxt0$^  pyxrefnannysetupcontextpush 0$^  pyxxdecrefpyxr$^  pyxt0.pyxn  0$^  pyxt0.delta  pyxvdelta$^  pyxt0.pushweights  pyxvpushweights$^  pyxt0.pushlabels  pyxvpushlabels$^  pyxt0.removecommonaffix  pyxvremovecommonaffix$^  pyxt0.removetotalweight  pyxvremovetotalweight$^  pyxt0.tofinal  pyxvtofinal$^  pyxt0  pyobject pyxf0pywrapfstpushpyxvifst 0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.push pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^  $^  $^  cpdef bool randequivalentfst ifst0              $^                            fst ifst0$^                            int00 npath0$^ $^$^static pyobject pyxpw0pywrapfst00randequivalentpyobject pyxself pyobject pyxargs pyobject pyxkwds proto$^static bool pyxf0pywrapfstrandequivalentstruct pyxobj0pywrapfstfst pyxvifst0 struct pyxobj0pywrapfstfst pyxvifst0 cythonunused int pyxskipdispatch struct pyxoptargs0pywrapfstrandequivalent pyxoptionalargs $^  pyxt00basictypesint00 pyxvnpath  pyxt00basictypesint000$^  float pyxvdelta  pyxk00$^  timet pyxvseed  timet0$^  pyobject pyxvselect  pyobject pyxnbuniform$^  pyxt00basictypesint00 pyxvmaxlength  pyxk00$^  enum fstscriptrandarcselection pyxvras$^  stduniqueptrfstrandgenoptionsenum fstscriptrandarcselection   pyxvopts$^  bool pyxr$^  pyxrefnannydeclarations$^  stdstring pyxt0$^  enum fstscriptrandarcselection pyxt0$^  int pyxt0$^  pyxrefnannysetupcontextrandequivalent 0$^  if pyxoptionalargs $^    if pyxoptionalargspyxn  0 $^      pyxvnpath  pyxoptionalargsnpath$^      if pyxoptionalargspyxn  0 $^        pyxvdelta  pyxoptionalargsdelta$^        if pyxoptionalargspyxn  0 $^          pyxvseed  pyxoptionalargsseed$^          if pyxoptionalargspyxn  0 $^            pyxvselect  pyxoptionalargsselect$^            if pyxoptionalargspyxn  0 $^              pyxvmaxlength  pyxoptionalargsmaxlength$^            $^          $^        $^      $^    $^  $^$^   pywrapfst.pyx0000$^    see also equal equivalent isomorphic randgen.$^    $^    cdef fst.randarcselection ras  getrandarcselectiontostringselect              $^    cdef uniqueptrfst.randgenoptionsfst.randarcselection opts$^     the three trailing options will be ignored by randequivalent.$^ $^  pyxt0  pyxf0pywrapfsttostringpyxvselect null if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^  pyxt0  pyxf0pywrapfstgetrandarcselectionpyxt0 if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^  pyxvras  pyxt0$^$^   pywrapfst.pyx0000$^    cdef uniqueptrfst.randgenoptionsfst.randarcselection opts$^     the three trailing options will be ignored by randequivalent.$^    opts.resetnew fst.randgenoptionsfst.randarcselectionras maxlength              $^                                                            0 false false$^    if seed  0$^ $^  pyxvopts.resetnew fstrandgenoptionsenum fstscriptrandarcselection pyxvras pyxvmaxlength 0 0 0$^$^   pywrapfst.pyx0000$^    opts.resetnew fst.randgenoptionsfst.randarcselectionras maxlength$^                                                            0 false false$^    if seed  0              $^      seed  timenull  getpid$^    return fst.randequivalentderefifst0.fst derefifst0.fst npath delta$^ $^  pyxt0  pyxvseed  0  0$^  if pyxt0 $^$^     pywrapfst.pyx0000$^                                                            0 false false$^    if seed  0$^      seed  timenull  getpid              $^    return fst.randequivalentderefifst0.fst derefifst0.fst npath delta$^                             seed derefopts$^ $^    pyxvseed  timenull  getpid$^$^     pywrapfst.pyx0000$^    opts.resetnew fst.randgenoptionsfst.randarcselectionras maxlength$^                                                            0 false false$^    if seed  0              $^      seed  timenull  getpid$^    return fst.randequivalentderefifst0.fst derefifst0.fst npath delta$^ $^  $^$^   pywrapfst.pyx0000$^    if seed  0$^      seed  timenull  getpid$^    return fst.randequivalentderefifst0.fst derefifst0.fst npath delta              $^                             seed derefopts$^  $^ $^  if unlikelypyobject pyxvifst0  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s fst$^    pyxerr0 0000 pyxl0error$^  $^  if unlikelypyobject pyxvifst0  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s fst$^    pyxerr0 0000 pyxl0error$^  $^$^   pywrapfst.pyx0000$^      seed  timenull  getpid$^    return fst.randequivalentderefifst0.fst derefifst0.fst npath delta$^                             seed derefopts              $^  $^  $^ $^  pyxr  fstscriptrandequivalentpyxvifst0fst pyxvifst0fst pyxvnpath pyxvdelta pyxvseed pyxvopts$^  goto pyxl0$^$^   pywrapfst.pyx0000$^  $^  $^  cpdef bool randequivalentfst ifst0              $^                            fst ifst0$^                            int00 npath0$^ $^$^   function exit code $^  pyxl0error$^  pyxaddtracebackpywrapfst.randequivalent pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst00randequivalentpyobject pyxself pyobject pyxargs pyobject pyxkwds proto$^static char pyxdoc0pywrapfst00randequivalent  n  randequivalentifst0 ifst0 npath0 delta0.0000000000 seed0n                 selectuniform maxlength0000000000nn  are two acceptors stochastically equivalentnn  this operation tests whether two fsts are equivalent by randomly generatingn  paths alternatively in each of the two fsts. for each randomly generated pathn  the algorithm computes for each of the two fsts the sum of the weights of alln  the successful paths sharing the same input and output labels as the randomlyn  generated path and checks that these two values are within delta.nn  argsn    ifst0 the first input fst.n    ifst0 the second input fst.n    npath the number of random paths to generate.n    delta comparisonquantization delta.n    seed an optional seed value for random path generation if zero then        current time and process id is used.n    select a string matching a known random arc selection type one ofn        uniform logprob fastlogprob.n    maxlength the maximum length of each random path.nn  returnsn    true if the two transducers satisfy the above condition else false.nn  see also equal equivalent isomorphic randgen.n  $^static pyobject pyxpw0pywrapfst00randequivalentpyobject pyxself pyobject pyxargs pyobject pyxkwds $^  struct pyxobj0pywrapfstfst pyxvifst0  0$^  struct pyxobj0pywrapfstfst pyxvifst0  0$^  pyxt00basictypesint00 pyxvnpath$^  float pyxvdelta$^  timet pyxvseed$^  pyobject pyxvselect  0$^  pyxt00basictypesint00 pyxvmaxlength$^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextrandequivalent wrapper 0$^  $^    static pyobject pyxpyargnames  pyxnsifst0pyxnsifst0pyxnsnpathpyxnsdeltapyxnsseedpyxnsselectpyxnsmaxlength0$^    pyobject values0  0000000$^    values0  pyobject pyxnbuniform$^    if unlikelypyxkwds $^      pyssizet kwargs$^      const pyssizet posargs  pytuplegetsizepyxargs$^      switch posargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 break$^        default goto pyxl0argtupleerror$^      $^      kwargs  pydictsizepyxkwds$^      switch posargs $^        case  0$^        if likelyvalues0  pyxpydictgetitemstrpyxkwds pyxnsifst0  0 kwargs$^        else goto pyxl0argtupleerror$^        cythonfallthrough$^        case  0$^        if likelyvalues0  pyxpydictgetitemstrpyxkwds pyxnsifst0  0 kwargs$^        else $^          pyxraiseargtupleinvalidrandequivalent 0 0 0 0 pyxerr0 0000 pyxl0error$^        $^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnsnpath$^          if value  values0  value kwargs $^        $^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnsdelta$^          if value  values0  value kwargs $^        $^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnsseed$^          if value  values0  value kwargs $^        $^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnsselect$^          if value  values0  value kwargs $^        $^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnsmaxlength$^          if value  values0  value kwargs $^        $^      $^      if unlikelykwargs  0 $^        if unlikelypyxparseoptionalkeywordspyxkwds pyxpyargnames 0 values posargs randequivalent  0 pyxerr0 0000 pyxl0error$^      $^     else $^      switch pytuplegetsizepyxargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        values0  pytuplegetitempyxargs 0$^        break$^        default goto pyxl0argtupleerror$^      $^    $^    pyxvifst0  struct pyxobj0pywrapfstfst values0$^    pyxvifst0  struct pyxobj0pywrapfstfst values0$^    if values0 $^      pyxvnpath  pyxpyintasint00tvalues0 if unlikelypyxvnpath  int00t0  pyerroccurred pyxerr0 0000 pyxl0error$^     else $^      pyxvnpath  pyxt00basictypesint000$^    $^    if values0 $^      pyxvdelta  pyxpyfloatasfloatvalues0 if unlikelypyxvdelta  float0  pyerroccurred pyxerr0 0000 pyxl0error$^     else $^      pyxvdelta  pyxk00$^    $^    if values0 $^      pyxvseed  pyxpyintastimetvalues0 if unlikelypyxvseed  timet0  pyerroccurred pyxerr0 0000 pyxl0error$^     else $^      pyxvseed  timet0$^    $^    pyxvselect  values0$^    if values0 $^      pyxvmaxlength  pyxpyintasint00tvalues0 if unlikelypyxvmaxlength  int00t0  pyerroccurred pyxerr0 0000 pyxl0error$^     else $^      pyxvmaxlength  pyxk00$^    $^  $^  goto pyxl0argumentunpackingdone$^  pyxl0argtupleerror$^  pyxraiseargtupleinvalidrandequivalent 0 0 0 pytuplegetsizepyxargs pyxerr0 0000 pyxl0error$^  pyxl0error$^  pyxaddtracebackpywrapfst.randequivalent pyxclineno pyxlineno pyxfilename$^  pyxrefnannyfinishcontext$^  return null$^  pyxl0argumentunpackingdone$^  if unlikelypyxargtypetestpyobject pyxvifst0 pyxptype0pywrapfstfst 0 ifst0 0 pyxerr0 0000 pyxl0error$^  if unlikelypyxargtypetestpyobject pyxvifst0 pyxptype0pywrapfstfst 0 ifst0 0 pyxerr0 0000 pyxl0error$^  pyxr  pyxpf0pywrapfst00randequivalentpyxself pyxvifst0 pyxvifst0 pyxvnpath pyxvdelta pyxvseed pyxvselect pyxvmaxlength$^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxr  null$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00randequivalentcythonunused pyobject pyxself struct pyxobj0pywrapfstfst pyxvifst0 struct pyxobj0pywrapfstfst pyxvifst0 pyxt00basictypesint00 pyxvnpath float pyxvdelta timet pyxvseed pyobject pyxvselect pyxt00basictypesint00 pyxvmaxlength $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  bool pyxt0$^  struct pyxoptargs0pywrapfstrandequivalent pyxt0$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextrandequivalent 0$^  pyxxdecrefpyxr$^  pyxt0.pyxn  0$^  pyxt0.npath  pyxvnpath$^  pyxt0.delta  pyxvdelta$^  pyxt0.seed  pyxvseed$^  pyxt0.select  pyxvselect$^  pyxt0.maxlength  pyxvmaxlength$^  pyxt0  pyxf0pywrapfstrandequivalentpyxvifst0 pyxvifst0 0 pyxt0 if unlikelypyxt0  bool0  pyerroccurred pyxerr0 0000 pyxl0error$^  pyxt0  pyxpyboolfromlongpyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.randequivalent pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^  $^  $^  cpdef mutablefst randgenfst ifst              $^                            int00 npath0$^                            timet seed0$^ $^$^static pyobject pyxpw0pywrapfst00randgenpyobject pyxself pyobject pyxargs pyobject pyxkwds proto$^static struct pyxobj0pywrapfstmutablefst pyxf0pywrapfstrandgenstruct pyxobj0pywrapfstfst pyxvifst cythonunused int pyxskipdispatch struct pyxoptargs0pywrapfstrandgen pyxoptionalargs $^  pyxt00basictypesint00 pyxvnpath  pyxt00basictypesint000$^  timet pyxvseed  timet0$^  pyobject pyxvselect  pyobject pyxnbuniform$^  pyxt00basictypesint00 pyxvmaxlength  pyxk00$^$^   pywrapfst.pyx0000$^                            selectbuniform$^                            int00 maxlengthint00max$^                            bool weightedfalse              $^                            bool removetotalweightfalse$^    $^ $^  bool pyxvweighted  bool0$^$^   pywrapfst.pyx0000$^                            int00 maxlengthint00max$^                            bool weightedfalse$^                            bool removetotalweightfalse              $^    $^    randgenifst npath0 seed0 selectuniform maxlength0000000000$^ $^  bool pyxvremovetotalweight  bool0$^  enum fstscriptrandarcselection pyxvras$^  stduniqueptrfstrandgenoptionsenum fstscriptrandarcselection   pyxvopts$^  stduniqueptrfstscriptvectorfstclass  pyxvtfst$^  struct pyxobj0pywrapfstmutablefst pyxr  null$^  pyxrefnannydeclarations$^  stdstring pyxt0$^  enum fstscriptrandarcselection pyxt0$^  int pyxt0$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextrandgen 0$^  if pyxoptionalargs $^    if pyxoptionalargspyxn  0 $^      pyxvnpath  pyxoptionalargsnpath$^      if pyxoptionalargspyxn  0 $^        pyxvseed  pyxoptionalargsseed$^        if pyxoptionalargspyxn  0 $^          pyxvselect  pyxoptionalargsselect$^          if pyxoptionalargspyxn  0 $^            pyxvmaxlength  pyxoptionalargsmaxlength$^            if pyxoptionalargspyxn  0 $^              pyxvweighted  pyxoptionalargsweighted$^              if pyxoptionalargspyxn  0 $^                pyxvremovetotalweight  pyxoptionalargsremovetotalweight$^              $^            $^          $^        $^      $^    $^  $^$^   pywrapfst.pyx0000$^    see also randequivalent.$^    $^    cdef fst.randarcselection ras  getrandarcselectiontostringselect              $^    cdef uniqueptrfst.randgenoptionsfst.randarcselection opts$^    opts.resetnew fst.randgenoptionsfst.randarcselectionras maxlength$^ $^  pyxt0  pyxf0pywrapfsttostringpyxvselect null if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^  pyxt0  pyxf0pywrapfstgetrandarcselectionpyxt0 if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^  pyxvras  pyxt0$^$^   pywrapfst.pyx0000$^    cdef fst.randarcselection ras  getrandarcselectiontostringselect$^    cdef uniqueptrfst.randgenoptionsfst.randarcselection opts$^    opts.resetnew fst.randgenoptionsfst.randarcselectionras maxlength              $^                                                            npath weighted$^                                                            removetotalweight$^ $^  pyxvopts.resetnew fstrandgenoptionsenum fstscriptrandarcselection pyxvras pyxvmaxlength pyxvnpath pyxvweighted pyxvremovetotalweight$^$^   pywrapfst.pyx0000$^                                                            removetotalweight$^    cdef uniqueptrfst.vectorfstclass tfst$^    tfst.resetnew fst.vectorfstclassifst.arctype              $^    if seed  0$^      seed  timenull  getpid$^ $^  if unlikelypyobject pyxvifst  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s arctype$^    pyxerr0 0000 pyxl0error$^  $^  pyxvtfst.resetnew fstscriptvectorfstclassstruct pyxvtabstruct0pywrapfstfst pyxvifstpyxvtabarctypepyxvifst 0$^$^   pywrapfst.pyx0000$^    cdef uniqueptrfst.vectorfstclass tfst$^    tfst.resetnew fst.vectorfstclassifst.arctype$^    if seed  0              $^      seed  timenull  getpid$^    fst.randgenderefifst.fst tfst.get seed derefopts$^ $^  pyxt0  pyxvseed  0  0$^  if pyxt0 $^$^     pywrapfst.pyx0000$^    tfst.resetnew fst.vectorfstclassifst.arctype$^    if seed  0$^      seed  timenull  getpid              $^    fst.randgenderefifst.fst tfst.get seed derefopts$^    return initmutablefsttfst.release$^ $^    pyxvseed  timenull  getpid$^$^     pywrapfst.pyx0000$^    cdef uniqueptrfst.vectorfstclass tfst$^    tfst.resetnew fst.vectorfstclassifst.arctype$^    if seed  0              $^      seed  timenull  getpid$^    fst.randgenderefifst.fst tfst.get seed derefopts$^ $^  $^$^   pywrapfst.pyx0000$^    if seed  0$^      seed  timenull  getpid$^    fst.randgenderefifst.fst tfst.get seed derefopts              $^    return initmutablefsttfst.release$^  $^ $^  if unlikelypyobject pyxvifst  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s fst$^    pyxerr0 0000 pyxl0error$^  $^  fstscriptrandgenpyxvifstfst pyxvtfst.get pyxvseed pyxvopts$^$^   pywrapfst.pyx0000$^      seed  timenull  getpid$^    fst.randgenderefifst.fst tfst.get seed derefopts$^    return initmutablefsttfst.release              $^  $^  $^ $^  pyxxdecrefpyobject pyxr$^  pyxt0  pyobject pyxf0pywrapfstinitmutablefstpyxvtfst.release if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  struct pyxobj0pywrapfstmutablefst pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   pywrapfst.pyx0000$^  $^  $^  cpdef mutablefst randgenfst ifst              $^                            int00 npath0$^                            timet seed0$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.randgen pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxl0$^  pyxxgiverefpyobject pyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst00randgenpyobject pyxself pyobject pyxargs pyobject pyxkwds proto$^static char pyxdoc0pywrapfst00randgen  n  randgenifst npath0 seed0 selectuniform maxlength0000000000n          weightfalse removetotalweightfalsenn  randomly generate successful paths in an fst.nn  this operation randomly generates a set of successful paths in the input fst.n  this relies on a mechanism for selecting arcs specified using the selectn  argument. the default selector uniform randomly selects a transitionn  using a uniform distribution. the logprob selector randomly selects an  transition w.r.t. the weights treated as negative log probabilities aftern  normalizing for the total weight leaving the state. in all cases finality isn  treated as a transition to a superfinal state.nn  argsn    ifst the input fst.n    npath the number of random paths to generate.n    seed an optional seed value for random path generation if zero then        current time and process id is used.n    select a string matching a known random arc selection type one ofn        uniform logprob fastlogprob.n    maxlength the maximum length of each random path.n    weighted should the output be weighted by path countn    removetotalweight should the total weight be removed ignored whenn        weighted is falsenn  returnsn    an fst containing one or more random paths.nn  see also randequivalent.n  $^static pyobject pyxpw0pywrapfst00randgenpyobject pyxself pyobject pyxargs pyobject pyxkwds $^  struct pyxobj0pywrapfstfst pyxvifst  0$^  pyxt00basictypesint00 pyxvnpath$^  timet pyxvseed$^  pyobject pyxvselect  0$^  pyxt00basictypesint00 pyxvmaxlength$^  bool pyxvweighted$^  bool pyxvremovetotalweight$^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextrandgen wrapper 0$^  $^    static pyobject pyxpyargnames  pyxnsifstpyxnsnpathpyxnsseedpyxnsselectpyxnsmaxlengthpyxnsweightedpyxnsremovetotalweight0$^    pyobject values0  0000000$^    values0  pyobject pyxnbuniform$^    if unlikelypyxkwds $^      pyssizet kwargs$^      const pyssizet posargs  pytuplegetsizepyxargs$^      switch posargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 break$^        default goto pyxl0argtupleerror$^      $^      kwargs  pydictsizepyxkwds$^      switch posargs $^        case  0$^        if likelyvalues0  pyxpydictgetitemstrpyxkwds pyxnsifst  0 kwargs$^        else goto pyxl0argtupleerror$^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnsnpath$^          if value  values0  value kwargs $^        $^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnsseed$^          if value  values0  value kwargs $^        $^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnsselect$^          if value  values0  value kwargs $^        $^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnsmaxlength$^          if value  values0  value kwargs $^        $^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnsweighted$^          if value  values0  value kwargs $^        $^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnsremovetotalweight$^          if value  values0  value kwargs $^        $^      $^      if unlikelykwargs  0 $^        if unlikelypyxparseoptionalkeywordspyxkwds pyxpyargnames 0 values posargs randgen  0 pyxerr0 0000 pyxl0error$^      $^     else $^      switch pytuplegetsizepyxargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        break$^        default goto pyxl0argtupleerror$^      $^    $^    pyxvifst  struct pyxobj0pywrapfstfst values0$^    if values0 $^      pyxvnpath  pyxpyintasint00tvalues0 if unlikelypyxvnpath  int00t0  pyerroccurred pyxerr0 0000 pyxl0error$^     else $^      pyxvnpath  pyxt00basictypesint000$^    $^    if values0 $^      pyxvseed  pyxpyintastimetvalues0 if unlikelypyxvseed  timet0  pyerroccurred pyxerr0 0000 pyxl0error$^     else $^      pyxvseed  timet0$^    $^    pyxvselect  values0$^    if values0 $^      pyxvmaxlength  pyxpyintasint00tvalues0 if unlikelypyxvmaxlength  int00t0  pyerroccurred pyxerr0 0000 pyxl0error$^     else $^      pyxvmaxlength  pyxk00$^    $^    if values0 $^      pyxvweighted  pyxpyobjectistruevalues0 if unlikelypyxvweighted  bool0  pyerroccurred pyxerr0 0000 pyxl0error$^     else $^$^       pywrapfst.pyx0000$^                            selectbuniform$^                            int00 maxlengthint00max$^                            bool weightedfalse              $^                            bool removetotalweightfalse$^    $^ $^      pyxvweighted  bool0$^    $^    if values0 $^      pyxvremovetotalweight  pyxpyobjectistruevalues0 if unlikelypyxvremovetotalweight  bool0  pyerroccurred pyxerr0 0000 pyxl0error$^     else $^$^       pywrapfst.pyx0000$^                            int00 maxlengthint00max$^                            bool weightedfalse$^                            bool removetotalweightfalse              $^    $^    randgenifst npath0 seed0 selectuniform maxlength0000000000$^ $^      pyxvremovetotalweight  bool0$^    $^  $^  goto pyxl0argumentunpackingdone$^  pyxl0argtupleerror$^  pyxraiseargtupleinvalidrandgen 0 0 0 pytuplegetsizepyxargs pyxerr0 0000 pyxl0error$^  pyxl0error$^  pyxaddtracebackpywrapfst.randgen pyxclineno pyxlineno pyxfilename$^  pyxrefnannyfinishcontext$^  return null$^  pyxl0argumentunpackingdone$^  if unlikelypyxargtypetestpyobject pyxvifst pyxptype0pywrapfstfst 0 ifst 0 pyxerr0 0000 pyxl0error$^  pyxr  pyxpf0pywrapfst00randgenpyxself pyxvifst pyxvnpath pyxvseed pyxvselect pyxvmaxlength pyxvweighted pyxvremovetotalweight$^$^   pywrapfst.pyx0000$^  $^  $^  cpdef mutablefst randgenfst ifst              $^                            int00 npath0$^                            timet seed0$^ $^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxr  null$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00randgencythonunused pyobject pyxself struct pyxobj0pywrapfstfst pyxvifst pyxt00basictypesint00 pyxvnpath timet pyxvseed pyobject pyxvselect pyxt00basictypesint00 pyxvmaxlength bool pyxvweighted bool pyxvremovetotalweight $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  struct pyxoptargs0pywrapfstrandgen pyxt0$^  pyxrefnannysetupcontextrandgen 0$^  pyxxdecrefpyxr$^  pyxt0.pyxn  0$^  pyxt0.npath  pyxvnpath$^  pyxt0.seed  pyxvseed$^  pyxt0.select  pyxvselect$^  pyxt0.maxlength  pyxvmaxlength$^  pyxt0.removetotalweight  pyxvweighted$^  pyxt0.weighted  pyxvremovetotalweight$^  pyxt0  pyobject pyxf0pywrapfstrandgenpyxvifst 0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.randgen pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^  $^  $^  cpdef mutablefst replacepairs              $^                            callarclabelingbinput$^                            returnarclabelingbneither$^ $^$^static pyobject pyxpw0pywrapfst00replacepyobject pyxself pyobject pyxargs pyobject pyxkwds proto$^static struct pyxobj0pywrapfstmutablefst pyxf0pywrapfstreplacepyobject pyxvpairs cythonunused int pyxskipdispatch struct pyxoptargs0pywrapfstreplace pyxoptionalargs $^  pyobject pyxvcallarclabeling  pyobject pyxnbinput$^  pyobject pyxvreturnarclabeling  pyobject pyxnbneither$^$^   pywrapfst.pyx0000$^                            callarclabelingbinput$^                            returnarclabelingbneither$^                            bool epsilononreplacefalse              $^                            int00 returnlabel0$^    $^ $^  bool pyxvepsilononreplace  bool0$^  pyxt00basictypesint00 pyxvreturnlabel  pyxt00basictypesint000$^  stdvectorpyxt0fstlabelfstclasspair  pyxvpairs$^  pyxt00basictypesint00 pyxvrootlabel$^  pyxt00basictypesint00 pyxvlabel$^  struct pyxobj0pywrapfstfst pyxvifst  0$^  pyobject pyxvit  null$^  stduniqueptrfstscriptvectorfstclass  pyxvtfst$^  enum fstreplacelabeltype pyxvcal$^  enum fstreplacelabeltype pyxvral$^  stduniqueptrfstscriptreplaceoptions  pyxvopts$^  struct pyxobj0pywrapfstmutablefst pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0pyobject $^  pyxt00basictypesint00 pyxt0$^  pyxt0fstlabelfstclasspair pyxt0$^  pyssizet pyxt0$^  pyobject pyxt0pyobject $^  pyobject pyxt00  null$^  stdstring pyxt00$^  enum fstreplacelabeltype pyxt00$^  pyxrefnannysetupcontextreplace 0$^  if pyxoptionalargs $^    if pyxoptionalargspyxn  0 $^      pyxvcallarclabeling  pyxoptionalargscallarclabeling$^      if pyxoptionalargspyxn  0 $^        pyxvreturnarclabeling  pyxoptionalargsreturnarclabeling$^        if pyxoptionalargspyxn  0 $^          pyxvepsilononreplace  pyxoptionalargsepsilononreplace$^          if pyxoptionalargspyxn  0 $^            pyxvreturnlabel  pyxoptionalargsreturnlabel$^          $^        $^      $^    $^  $^$^   pywrapfst.pyx0000$^    cdef int00 label$^    cdef fst ifst$^    it  iterpairs              $^    rootlabel ifst  nextit$^    pairs.pushbackfst.labelfstclasspairrootlabel ifst.fst.get$^ $^  pyxt0  pyobjectgetiterpyxvpairs if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxvit  pyxt0$^  pyxt0  0$^$^   pywrapfst.pyx0000$^    cdef fst ifst$^    it  iterpairs$^    rootlabel ifst  nextit              $^    pairs.pushbackfst.labelfstclasspairrootlabel ifst.fst.get$^    cdef uniqueptrfst.vectorfstclass tfst$^ $^  pyxt0  pyxpyiternextpyxvit if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  if likelypytuplecheckexactpyxt0  pylistcheckexactpyxt0 $^    pyobject sequence  pyxt0$^    pyssizet size  pyxpysequencesizesequence$^    if unlikelysize  0 $^      if size  0 pyxraisetoomanyvalueserror0$^      else if size  0 pyxraiseneedmorevalueserrorsize$^      pyxerr0 0000 pyxl0error$^    $^    if cythonassumesafemacros  cythonavoidborrowedrefs$^    if likelypytuplecheckexactsequence $^      pyxt0  pytuplegetitemsequence 0 $^      pyxt0  pytuplegetitemsequence 0 $^     else $^      pyxt0  pylistgetitemsequence 0 $^      pyxt0  pylistgetitemsequence 0 $^    $^    pyxincrefpyxt0$^    pyxincrefpyxt0$^    else$^    pyxt0  pysequenceitemsequence 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  pysequenceitemsequence 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    endif$^    pyxdecrefpyxt0 pyxt0  0$^   else $^    pyssizet index  0$^    pyxt0  pyobjectgetiterpyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxt0  pytypepyxt0tpiternext$^    index  0 pyxt0  pyxt0pyxt0 if unlikelypyxt0 goto pyxl0unpackingfailed$^    pyxgotrefpyxt0$^    index  0 pyxt0  pyxt0pyxt0 if unlikelypyxt0 goto pyxl0unpackingfailed$^    pyxgotrefpyxt0$^    if pyxiternextunpackendcheckpyxt0pyxt0 0  0 pyxerr0 0000 pyxl0error$^    pyxt0  null$^    pyxdecrefpyxt0 pyxt0  0$^    goto pyxl0unpackingdone$^    pyxl0unpackingfailed$^    pyxdecrefpyxt0 pyxt0  0$^    pyxt0  null$^    if pyxiterfinish  0 pyxraiseneedmorevalueserrorindex$^    pyxerr0 0000 pyxl0error$^    pyxl0unpackingdone$^  $^  pyxt0  pyxpyintasint00tpyxt0 if unlikelypyxt0  int00t0  pyerroccurred pyxerr0 0000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^  if likelypyxt0  pynone  likelypyxtypetestpyxt0 pyxptype0pywrapfstfst pyxerr0 0000 pyxl0error$^  pyxvrootlabel  pyxt0$^  pyxvifst  struct pyxobj0pywrapfstfst pyxt0$^  pyxt0  0$^$^   pywrapfst.pyx0000$^    it  iterpairs$^    rootlabel ifst  nextit$^    pairs.pushbackfst.labelfstclasspairrootlabel ifst.fst.get              $^    cdef uniqueptrfst.vectorfstclass tfst$^    tfst.resetnew fst.vectorfstclassifst.arctype$^ $^  if unlikelypyobject pyxvifst  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s fst$^    pyxerr0 0000 pyxl0error$^  $^  try $^    pyxt0  pyxt0fstlabelfstclasspairpyxvrootlabel pyxvifstfst.get$^   catch... $^    pyxcppexn0pyerr$^    pyxerr0 0000 pyxl0error$^  $^  try $^    pyxvpairs.pushbackpyxt0$^   catch... $^    pyxcppexn0pyerr$^    pyxerr0 0000 pyxl0error$^  $^$^   pywrapfst.pyx0000$^    pairs.pushbackfst.labelfstclasspairrootlabel ifst.fst.get$^    cdef uniqueptrfst.vectorfstclass tfst$^    tfst.resetnew fst.vectorfstclassifst.arctype              $^    for label ifst in it$^      pairs.pushbackfst.labelfstclasspairlabel ifst.fst.get$^ $^  if unlikelypyobject pyxvifst  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s arctype$^    pyxerr0 0000 pyxl0error$^  $^  pyxvtfst.resetnew fstscriptvectorfstclassstruct pyxvtabstruct0pywrapfstfst pyxvifstpyxvtabarctypepyxvifst 0$^$^   pywrapfst.pyx0000$^    cdef uniqueptrfst.vectorfstclass tfst$^    tfst.resetnew fst.vectorfstclassifst.arctype$^    for label ifst in it              $^      pairs.pushbackfst.labelfstclasspairlabel ifst.fst.get$^    cdef fst.replacelabeltype cal  getreplacelabeltype$^ $^  if likelypylistcheckexactpyxvit  pytuplecheckexactpyxvit $^    pyxt0  pyxvit pyxincrefpyxt0 pyxt0  0$^    pyxt0  null$^   else $^    pyxt0  0 pyxt0  pyobjectgetiterpyxvit if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  pytypepyxt0tpiternext if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  $^  for  $^    if likelypyxt0 $^      if likelypylistcheckexactpyxt0 $^        if pyxt0  pylistgetsizepyxt0 break$^        if cythonassumesafemacros  cythonavoidborrowedrefs$^        pyxt0  pylistgetitempyxt0 pyxt0 pyxincrefpyxt0 pyxt0 if unlikely0  0 pyxerr0 0000 pyxl0error$^        else$^        pyxt0  pysequenceitempyxt0 pyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxgotrefpyxt0$^        endif$^       else $^        if pyxt0  pytuplegetsizepyxt0 break$^        if cythonassumesafemacros  cythonavoidborrowedrefs$^        pyxt0  pytuplegetitempyxt0 pyxt0 pyxincrefpyxt0 pyxt0 if unlikely0  0 pyxerr0 0000 pyxl0error$^        else$^        pyxt0  pysequenceitempyxt0 pyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxgotrefpyxt0$^        endif$^      $^     else $^      pyxt0  pyxt0pyxt0$^      if unlikelypyxt0 $^        pyobject exctype  pyerroccurred$^        if exctype $^          if likelypyxpyerrgivenexceptionmatchesexctype pyexcstopiteration pyerrclear$^          else pyxerr0 0000 pyxl0error$^        $^        break$^      $^      pyxgotrefpyxt0$^    $^    if likelypytuplecheckexactpyxt0  pylistcheckexactpyxt0 $^      pyobject sequence  pyxt0$^      pyssizet size  pyxpysequencesizesequence$^      if unlikelysize  0 $^        if size  0 pyxraisetoomanyvalueserror0$^        else if size  0 pyxraiseneedmorevalueserrorsize$^        pyxerr0 0000 pyxl0error$^      $^      if cythonassumesafemacros  cythonavoidborrowedrefs$^      if likelypytuplecheckexactsequence $^        pyxt0  pytuplegetitemsequence 0 $^        pyxt0  pytuplegetitemsequence 0 $^       else $^        pyxt0  pylistgetitemsequence 0 $^        pyxt0  pylistgetitemsequence 0 $^      $^      pyxincrefpyxt0$^      pyxincrefpyxt0$^      else$^      pyxt0  pysequenceitemsequence 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxgotrefpyxt0$^      pyxt0  pysequenceitemsequence 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxgotrefpyxt0$^      endif$^      pyxdecrefpyxt0 pyxt0  0$^     else $^      pyssizet index  0$^      pyxt00  pyobjectgetiterpyxt0 if unlikelypyxt00 pyxerr0 0000 pyxl0error$^      pyxgotrefpyxt00$^      pyxdecrefpyxt0 pyxt0  0$^      pyxt0  pytypepyxt00tpiternext$^      index  0 pyxt0  pyxt0pyxt00 if unlikelypyxt0 goto pyxl0unpackingfailed$^      pyxgotrefpyxt0$^      index  0 pyxt0  pyxt0pyxt00 if unlikelypyxt0 goto pyxl0unpackingfailed$^      pyxgotrefpyxt0$^      if pyxiternextunpackendcheckpyxt0pyxt00 0  0 pyxerr0 0000 pyxl0error$^      pyxt0  null$^      pyxdecrefpyxt00 pyxt00  0$^      goto pyxl0unpackingdone$^      pyxl0unpackingfailed$^      pyxdecrefpyxt00 pyxt00  0$^      pyxt0  null$^      if pyxiterfinish  0 pyxraiseneedmorevalueserrorindex$^      pyxerr0 0000 pyxl0error$^      pyxl0unpackingdone$^    $^    pyxt0  pyxpyintasint00tpyxt0 if unlikelypyxt0  int00t0  pyerroccurred pyxerr0 0000 pyxl0error$^    pyxdecrefpyxt0 pyxt0  0$^    if likelypyxt0  pynone  likelypyxtypetestpyxt0 pyxptype0pywrapfstfst pyxerr0 0000 pyxl0error$^    pyxvlabel  pyxt0$^    pyxdecrefsetpyxvifst struct pyxobj0pywrapfstfst pyxt0$^    pyxt0  0$^$^     pywrapfst.pyx0000$^    tfst.resetnew fst.vectorfstclassifst.arctype$^    for label ifst in it$^      pairs.pushbackfst.labelfstclasspairlabel ifst.fst.get              $^    cdef fst.replacelabeltype cal  getreplacelabeltype$^        tostringcallarclabeling epsilononreplace$^ $^    if unlikelypyobject pyxvifst  pynone $^      pyerrformatpyexcattributeerror nonetype object has no attribute .00s fst$^      pyxerr0 0000 pyxl0error$^    $^    try $^      pyxt0  pyxt0fstlabelfstclasspairpyxvlabel pyxvifstfst.get$^     catch... $^      pyxcppexn0pyerr$^      pyxerr0 0000 pyxl0error$^    $^    try $^      pyxvpairs.pushbackpyxt0$^     catch... $^      pyxcppexn0pyerr$^      pyxerr0 0000 pyxl0error$^    $^$^     pywrapfst.pyx0000$^    cdef uniqueptrfst.vectorfstclass tfst$^    tfst.resetnew fst.vectorfstclassifst.arctype$^    for label ifst in it              $^      pairs.pushbackfst.labelfstclasspairlabel ifst.fst.get$^    cdef fst.replacelabeltype cal  getreplacelabeltype$^ $^  $^  pyxdecrefpyxt0 pyxt0  0$^$^   pywrapfst.pyx0000$^      pairs.pushbackfst.labelfstclasspairlabel ifst.fst.get$^    cdef fst.replacelabeltype cal  getreplacelabeltype$^        tostringcallarclabeling epsilononreplace              $^    cdef fst.replacelabeltype ral  getreplacelabeltype$^        tostringreturnarclabeling epsilononreplace$^ $^  pyxt00  pyxf0pywrapfsttostringpyxvcallarclabeling null if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^    for label ifst in it$^      pairs.pushbackfst.labelfstclasspairlabel ifst.fst.get$^    cdef fst.replacelabeltype cal  getreplacelabeltype              $^        tostringcallarclabeling epsilononreplace$^    cdef fst.replacelabeltype ral  getreplacelabeltype$^ $^  pyxt00  pyxf0pywrapfstgetreplacelabeltypepyxt00 pyxvepsilononreplace if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^  pyxvcal  pyxt00$^$^   pywrapfst.pyx0000$^        tostringcallarclabeling epsilononreplace$^    cdef fst.replacelabeltype ral  getreplacelabeltype$^        tostringreturnarclabeling epsilononreplace              $^    cdef uniqueptrfst.replaceoptions opts$^    opts.resetnew fst.replaceoptionsrootlabel cal ral returnlabel$^ $^  pyxt00  pyxf0pywrapfsttostringpyxvreturnarclabeling null if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^    cdef fst.replacelabeltype cal  getreplacelabeltype$^        tostringcallarclabeling epsilononreplace$^    cdef fst.replacelabeltype ral  getreplacelabeltype              $^        tostringreturnarclabeling epsilononreplace$^    cdef uniqueptrfst.replaceoptions opts$^ $^  pyxt00  pyxf0pywrapfstgetreplacelabeltypepyxt00 pyxvepsilononreplace if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^  pyxvral  pyxt00$^$^   pywrapfst.pyx0000$^        tostringreturnarclabeling epsilononreplace$^    cdef uniqueptrfst.replaceoptions opts$^    opts.resetnew fst.replaceoptionsrootlabel cal ral returnlabel              $^    fst.replacepairs tfst.get derefopts$^    return initmutablefsttfst.release$^ $^  pyxvopts.resetnew fstscriptreplaceoptionspyxvrootlabel pyxvcal pyxvral pyxvreturnlabel$^$^   pywrapfst.pyx0000$^    cdef uniqueptrfst.replaceoptions opts$^    opts.resetnew fst.replaceoptionsrootlabel cal ral returnlabel$^    fst.replacepairs tfst.get derefopts              $^    return initmutablefsttfst.release$^  $^ $^  fstscriptreplacepyxvpairs pyxvtfst.get pyxvopts$^$^   pywrapfst.pyx0000$^    opts.resetnew fst.replaceoptionsrootlabel cal ral returnlabel$^    fst.replacepairs tfst.get derefopts$^    return initmutablefsttfst.release              $^  $^  $^ $^  pyxxdecrefpyobject pyxr$^  pyxt0  pyobject pyxf0pywrapfstinitmutablefstpyxvtfst.release if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  struct pyxobj0pywrapfstmutablefst pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   pywrapfst.pyx0000$^  $^  $^  cpdef mutablefst replacepairs              $^                            callarclabelingbinput$^                            returnarclabelingbneither$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt00$^  pyxaddtracebackpywrapfst.replace pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxl0$^  pyxxdecrefpyobject pyxvifst$^  pyxxdecrefpyxvit$^  pyxxgiverefpyobject pyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst00replacepyobject pyxself pyobject pyxargs pyobject pyxkwds proto$^static char pyxdoc0pywrapfst00replace  n  replacepairs callarclabelinginput returnarclabelingneithern          epsilononreplacefalse returnlabel0nn  recursively replaces arcs in the fst with other fsts.nn  this operation performs the dynamic replacement of arcs in one fst withn  another fst allowing the definition of fsts analogous to rtns. it takes asn  input a set of pairs of a set of pairs formed by a nonterminal label andn  its corresponding fst and a label identifying the root fst in that set.n  the resulting fst is obtained by taking the root fst and recursively replacingn  each arc having a nonterminal as output label by its corresponding fst. moren  precisely an arc from state s to state d with nonterminal output label n inn  this fst is replaced by redirecting this call arc to the initial state of an  copy f of the fst for n and adding return arcs from each final state of fn  to d. optional arguments control how the call and return arcs are labeled byn  default the only nonepsilon label is placed on the call arc.nn  argsnn    pairs an iterable of nonterminal label fst pairs where the former is ann        unsigned integer and the latter is an fst instance.n    callarclabeling a string indicating which call arc labels should ben        nonepsilon. one of input default output both neither.n        this value is set to neither if epsilononreplace is true.n    returnarclabeling a string indicating which return arc labels should ben        nonepsilon. one of input output both neither default.n        this value is set to neither if epsilononreplace is true.n    epsilononreplace should call and return arcs be epsilon arcs if truen        this effectively overrides callarclabeling and returnarclabelingn        setting both to neither.n    returnlabel the integer label for return arcs.nn  returnsn    an fst resulting from expanding the input rtn.n  $^static pyobject pyxpw0pywrapfst00replacepyobject pyxself pyobject pyxargs pyobject pyxkwds $^  pyobject pyxvpairs  0$^  pyobject pyxvcallarclabeling  0$^  pyobject pyxvreturnarclabeling  0$^  bool pyxvepsilononreplace$^  pyxt00basictypesint00 pyxvreturnlabel$^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextreplace wrapper 0$^  $^    static pyobject pyxpyargnames  pyxnspairspyxnscallarclabelingpyxnsreturnarclabelingpyxnsepsilononreplacepyxnsreturnlabel0$^    pyobject values0  00000$^    values0  pyobject pyxnbinput$^    values0  pyobject pyxnbneither$^    if unlikelypyxkwds $^      pyssizet kwargs$^      const pyssizet posargs  pytuplegetsizepyxargs$^      switch posargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 break$^        default goto pyxl0argtupleerror$^      $^      kwargs  pydictsizepyxkwds$^      switch posargs $^        case  0$^        if likelyvalues0  pyxpydictgetitemstrpyxkwds pyxnspairs  0 kwargs$^        else goto pyxl0argtupleerror$^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnscallarclabeling$^          if value  values0  value kwargs $^        $^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnsreturnarclabeling$^          if value  values0  value kwargs $^        $^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnsepsilononreplace$^          if value  values0  value kwargs $^        $^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnsreturnlabel$^          if value  values0  value kwargs $^        $^      $^      if unlikelykwargs  0 $^        if unlikelypyxparseoptionalkeywordspyxkwds pyxpyargnames 0 values posargs replace  0 pyxerr0 0000 pyxl0error$^      $^     else $^      switch pytuplegetsizepyxargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        break$^        default goto pyxl0argtupleerror$^      $^    $^    pyxvpairs  values0$^    pyxvcallarclabeling  values0$^    pyxvreturnarclabeling  values0$^    if values0 $^      pyxvepsilononreplace  pyxpyobjectistruevalues0 if unlikelypyxvepsilononreplace  bool0  pyerroccurred pyxerr0 0000 pyxl0error$^     else $^$^       pywrapfst.pyx0000$^                            callarclabelingbinput$^                            returnarclabelingbneither$^                            bool epsilononreplacefalse              $^                            int00 returnlabel0$^    $^ $^      pyxvepsilononreplace  bool0$^    $^    if values0 $^      pyxvreturnlabel  pyxpyintasint00tvalues0 if unlikelypyxvreturnlabel  int00t0  pyerroccurred pyxerr0 0000 pyxl0error$^     else $^      pyxvreturnlabel  pyxt00basictypesint000$^    $^  $^  goto pyxl0argumentunpackingdone$^  pyxl0argtupleerror$^  pyxraiseargtupleinvalidreplace 0 0 0 pytuplegetsizepyxargs pyxerr0 0000 pyxl0error$^  pyxl0error$^  pyxaddtracebackpywrapfst.replace pyxclineno pyxlineno pyxfilename$^  pyxrefnannyfinishcontext$^  return null$^  pyxl0argumentunpackingdone$^  pyxr  pyxpf0pywrapfst00replacepyxself pyxvpairs pyxvcallarclabeling pyxvreturnarclabeling pyxvepsilononreplace pyxvreturnlabel$^$^   pywrapfst.pyx0000$^  $^  $^  cpdef mutablefst replacepairs              $^                            callarclabelingbinput$^                            returnarclabelingbneither$^ $^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00replacecythonunused pyobject pyxself pyobject pyxvpairs pyobject pyxvcallarclabeling pyobject pyxvreturnarclabeling bool pyxvepsilononreplace pyxt00basictypesint00 pyxvreturnlabel $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  struct pyxoptargs0pywrapfstreplace pyxt0$^  pyxrefnannysetupcontextreplace 0$^  pyxxdecrefpyxr$^  pyxt0.pyxn  0$^  pyxt0.callarclabeling  pyxvcallarclabeling$^  pyxt0.returnarclabeling  pyxvreturnarclabeling$^  pyxt0.epsilononreplace  pyxvepsilononreplace$^  pyxt0.returnlabel  pyxvreturnlabel$^  pyxt0  pyobject pyxf0pywrapfstreplacepyxvpairs 0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.replace pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^  $^  $^  cpdef mutablefst reversefst ifst bool requiresuperinitialtrue              $^    $^    reverseifst requiresuperinitialtrue$^ $^$^static pyobject pyxpw0pywrapfst00reversepyobject pyxself pyobject pyxargs pyobject pyxkwds proto$^static struct pyxobj0pywrapfstmutablefst pyxf0pywrapfstreversestruct pyxobj0pywrapfstfst pyxvifst cythonunused int pyxskipdispatch struct pyxoptargs0pywrapfstreverse pyxoptionalargs $^  bool pyxvrequiresuperinitial  bool0$^  stduniqueptrfstscriptvectorfstclass  pyxvtfst$^  struct pyxobj0pywrapfstmutablefst pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextreverse 0$^  if pyxoptionalargs $^    if pyxoptionalargspyxn  0 $^      pyxvrequiresuperinitial  pyxoptionalargsrequiresuperinitial$^    $^  $^$^   pywrapfst.pyx0000$^    $^    cdef uniqueptrfst.vectorfstclass tfst$^    tfst.resetnew fst.vectorfstclassifst.arctype              $^    fst.reversederefifst.fst tfst.get requiresuperinitial$^    return initmutablefsttfst.release$^ $^  if unlikelypyobject pyxvifst  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s arctype$^    pyxerr0 0000 pyxl0error$^  $^  pyxvtfst.resetnew fstscriptvectorfstclassstruct pyxvtabstruct0pywrapfstfst pyxvifstpyxvtabarctypepyxvifst 0$^$^   pywrapfst.pyx0000$^    cdef uniqueptrfst.vectorfstclass tfst$^    tfst.resetnew fst.vectorfstclassifst.arctype$^    fst.reversederefifst.fst tfst.get requiresuperinitial              $^    return initmutablefsttfst.release$^  $^ $^  if unlikelypyobject pyxvifst  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s fst$^    pyxerr0 0000 pyxl0error$^  $^  fstscriptreversepyxvifstfst pyxvtfst.get pyxvrequiresuperinitial$^$^   pywrapfst.pyx0000$^    tfst.resetnew fst.vectorfstclassifst.arctype$^    fst.reversederefifst.fst tfst.get requiresuperinitial$^    return initmutablefsttfst.release              $^  $^  $^ $^  pyxxdecrefpyobject pyxr$^  pyxt0  pyobject pyxf0pywrapfstinitmutablefstpyxvtfst.release if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  struct pyxobj0pywrapfstmutablefst pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   pywrapfst.pyx0000$^  $^  $^  cpdef mutablefst reversefst ifst bool requiresuperinitialtrue              $^    $^    reverseifst requiresuperinitialtrue$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.reverse pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxl0$^  pyxxgiverefpyobject pyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst00reversepyobject pyxself pyobject pyxargs pyobject pyxkwds proto$^static char pyxdoc0pywrapfst00reverse  n  reverseifst requiresuperinitialtruenn  constructively reverses an fsts transduction.nn  this operation reverses an fst. if a transduces string x to y with weight an  then the reverse of a transduces the reverse of x to the reverse of y withn  weight a.reverse. typically a  a.reverse and arc  revarc e.g.n  tropicalweight and logweight. in general e.g. when the weights only form an  left or right semiring the output arc type must match the input arc type.nn  argsn    ifst the input fst.n    requiresuperinitial should a superinitial state be creatednn  returnsn    a reversed fst.n  $^static pyobject pyxpw0pywrapfst00reversepyobject pyxself pyobject pyxargs pyobject pyxkwds $^  struct pyxobj0pywrapfstfst pyxvifst  0$^  bool pyxvrequiresuperinitial$^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextreverse wrapper 0$^  $^    static pyobject pyxpyargnames  pyxnsifstpyxnsrequiresuperinitial0$^    pyobject values0  00$^    if unlikelypyxkwds $^      pyssizet kwargs$^      const pyssizet posargs  pytuplegetsizepyxargs$^      switch posargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 break$^        default goto pyxl0argtupleerror$^      $^      kwargs  pydictsizepyxkwds$^      switch posargs $^        case  0$^        if likelyvalues0  pyxpydictgetitemstrpyxkwds pyxnsifst  0 kwargs$^        else goto pyxl0argtupleerror$^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnsrequiresuperinitial$^          if value  values0  value kwargs $^        $^      $^      if unlikelykwargs  0 $^        if unlikelypyxparseoptionalkeywordspyxkwds pyxpyargnames 0 values posargs reverse  0 pyxerr0 0000 pyxl0error$^      $^     else $^      switch pytuplegetsizepyxargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        break$^        default goto pyxl0argtupleerror$^      $^    $^    pyxvifst  struct pyxobj0pywrapfstfst values0$^    if values0 $^      pyxvrequiresuperinitial  pyxpyobjectistruevalues0 if unlikelypyxvrequiresuperinitial  bool0  pyerroccurred pyxerr0 0000 pyxl0error$^     else $^      pyxvrequiresuperinitial  bool0$^    $^  $^  goto pyxl0argumentunpackingdone$^  pyxl0argtupleerror$^  pyxraiseargtupleinvalidreverse 0 0 0 pytuplegetsizepyxargs pyxerr0 0000 pyxl0error$^  pyxl0error$^  pyxaddtracebackpywrapfst.reverse pyxclineno pyxlineno pyxfilename$^  pyxrefnannyfinishcontext$^  return null$^  pyxl0argumentunpackingdone$^  if unlikelypyxargtypetestpyobject pyxvifst pyxptype0pywrapfstfst 0 ifst 0 pyxerr0 0000 pyxl0error$^  pyxr  pyxpf0pywrapfst00reversepyxself pyxvifst pyxvrequiresuperinitial$^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxr  null$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00reversecythonunused pyobject pyxself struct pyxobj0pywrapfstfst pyxvifst bool pyxvrequiresuperinitial $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  struct pyxoptargs0pywrapfstreverse pyxt0$^  pyxrefnannysetupcontextreverse 0$^  pyxxdecrefpyxr$^  pyxt0.pyxn  0$^  pyxt0.requiresuperinitial  pyxvrequiresuperinitial$^  pyxt0  pyobject pyxf0pywrapfstreversepyxvifst 0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.reverse pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^  $^  $^  cdef vectorfst.weightclass shortestdistancefst ifst              $^                                                  float deltafst.kshortestdelta$^                                                  int00 nstatefst.knostateid$^ $^$^static stdvectorfstscriptweightclass  pyxf0pywrapfstshortestdistancestruct pyxobj0pywrapfstfst pyxvifst struct pyxoptargs0pywrapfstshortestdistance pyxoptionalargs $^  float pyxvdelta  pyxk00$^  pyxt00basictypesint00 pyxvnstate  pyxk00$^  pyobject pyxvqueuetype  pyobject pyxnbauto$^$^   pywrapfst.pyx0000$^                                                  int00 nstatefst.knostateid$^                                                  queuetypebauto$^                                                  bool reversefalse except               $^    cdef uniqueptrvectorfst.weightclass distance$^    distance.resetnew vectorfst.weightclass$^ $^  bool pyxvreverse  bool0$^  stduniqueptrstdvectorfstscriptweightclass   pyxvdistance$^  stduniqueptrfstscriptshortestdistanceoptions  pyxvopts$^  stdvectorfstscriptweightclass  pyxr$^  pyxrefnannydeclarations$^  stdvectorfstscriptweightclass  pyxt0$^  int pyxt0$^  stdstring pyxt0$^  enum fstqueuetype pyxt0$^  pyxrefnannysetupcontextshortestdistance 0$^  if pyxoptionalargs $^    if pyxoptionalargspyxn  0 $^      pyxvdelta  pyxoptionalargsdelta$^      if pyxoptionalargspyxn  0 $^        pyxvnstate  pyxoptionalargsnstate$^        if pyxoptionalargspyxn  0 $^          pyxvqueuetype  pyxoptionalargsqueuetype$^          if pyxoptionalargspyxn  0 $^            pyxvreverse  pyxoptionalargsreverse$^          $^        $^      $^    $^  $^$^   pywrapfst.pyx0000$^                                                  bool reversefalse except $^    cdef uniqueptrvectorfst.weightclass distance$^    distance.resetnew vectorfst.weightclass              $^     for scoping reasons these have to be declared here even though they may$^     not be used in all cases.$^ $^  try $^    pyxt0  new stdvectorfstscriptweightclass $^   catch... $^    pyxcppexn0pyerr$^    pyxerr0 0000 pyxl0error$^  $^  pyxvdistance.resetpyxt0$^$^   pywrapfst.pyx0000$^     not be used in all cases.$^    cdef uniqueptrfst.shortestdistanceoptions opts$^    if reverse              $^       only the simpler signature supports shortest distance to final states$^       nstate and queuetype arguments are ignored.$^ $^  pyxt0  pyxvreverse  0$^  if pyxt0 $^$^     pywrapfst.pyx0000$^       only the simpler signature supports shortest distance to final states$^       nstate and queuetype arguments are ignored.$^      fst.shortestdistancederefifst.fst distance.get true delta              $^    else$^      opts.resetnew fst.shortestdistanceoptions$^ $^    if unlikelypyobject pyxvifst  pynone $^      pyerrformatpyexcattributeerror nonetype object has no attribute .00s fst$^      pyxerr0 0000 pyxl0error$^    $^    fstscriptshortestdistancepyxvifstfst pyxvdistance.get 0 pyxvdelta$^$^     pywrapfst.pyx0000$^     not be used in all cases.$^    cdef uniqueptrfst.shortestdistanceoptions opts$^    if reverse              $^       only the simpler signature supports shortest distance to final states$^       nstate and queuetype arguments are ignored.$^ $^    goto pyxl0$^  $^$^   pywrapfst.pyx0000$^      fst.shortestdistancederefifst.fst distance.get true delta$^    else$^      opts.resetnew fst.shortestdistanceoptions              $^          getqueuetypetostringqueuetype fst.anyarcfilter nstate$^          delta$^ $^  else $^$^     pywrapfst.pyx0000$^    else$^      opts.resetnew fst.shortestdistanceoptions$^          getqueuetypetostringqueuetype fst.anyarcfilter nstate              $^          delta$^      fst.shortestdistancederefifst.fst distance.get derefopts$^ $^    pyxt0  pyxf0pywrapfsttostringpyxvqueuetype null if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^    pyxt0  pyxf0pywrapfstgetqueuetypepyxt0 if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^     pywrapfst.pyx0000$^      fst.shortestdistancederefifst.fst distance.get true delta$^    else$^      opts.resetnew fst.shortestdistanceoptions              $^          getqueuetypetostringqueuetype fst.anyarcfilter nstate$^          delta$^ $^    pyxvopts.resetnew fstscriptshortestdistanceoptionspyxt0 fstscriptanyarcfilter pyxvnstate pyxvdelta$^$^     pywrapfst.pyx0000$^          getqueuetypetostringqueuetype fst.anyarcfilter nstate$^          delta$^      fst.shortestdistancederefifst.fst distance.get derefopts              $^    return distance.release$^  $^ $^    if unlikelypyobject pyxvifst  pynone $^      pyerrformatpyexcattributeerror nonetype object has no attribute .00s fst$^      pyxerr0 0000 pyxl0error$^    $^    fstscriptshortestdistancepyxvifstfst pyxvdistance.get pyxvopts$^  $^  pyxl0$^$^   pywrapfst.pyx0000$^          delta$^      fst.shortestdistancederefifst.fst distance.get derefopts$^    return distance.release              $^  $^  $^ $^  pyxr  pyxvdistance.release$^  goto pyxl0$^$^   pywrapfst.pyx0000$^  $^  $^  cdef vectorfst.weightclass shortestdistancefst ifst              $^                                                  float deltafst.kshortestdelta$^                                                  int00 nstatefst.knostateid$^ $^$^   function exit code $^  pyxl0error$^  pyxaddtracebackpywrapfst.shortestdistance pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^  $^  $^  def shortestdistancefst ifst              $^                       float deltafst.kshortestdelta$^                       int00 nstatefst.knostateid$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00shortestdistancepyobject pyxself pyobject pyxargs pyobject pyxkwds proto$^static char pyxdoc0pywrapfst00shortestdistance  n  shortestdistanceifst delta0e0 nstatenostateidn                   queuetypeauto reversefalsenn  compute the shortest distance from the initial or final state.nn  this operation computes the shortest distance from the initial state whenn  reverse is false or from every state to the final state when reverse isn  true. the shortest distance from p to q is the otimessum of the weights ofn  all the paths between p and q. the weights must be right if reverse isn  false or left if reverse is true distributive and kclosed i.e. 0n  otimes x otimes x0 otimes ... otimes xk  0  0 otimes x otimes x0n  otimes ... otimes xk e.g. tropicalweight.nn  argsn    ifst the input fst.n    delta comparisonquantization delta.n    nstate state number threshold ignored if reverse is true.n    queuetype a string matching a known queue type one of auto fifon        lifo shortest state top ignored if reverse is true.n    reverse should the reverse distance from each state to the final staten        be computednn  returnsn    a list of weight objects representing the shortest distance for each state.n  $^static pymethoddef pyxmdef0pywrapfst00shortestdistance  shortestdistance pycfunctionpyxpw0pywrapfst00shortestdistance methvarargsmethkeywords pyxdoc0pywrapfst00shortestdistance$^static pyobject pyxpw0pywrapfst00shortestdistancepyobject pyxself pyobject pyxargs pyobject pyxkwds $^  struct pyxobj0pywrapfstfst pyxvifst  0$^  float pyxvdelta$^  pyxt00basictypesint00 pyxvnstate$^  pyobject pyxvqueuetype  0$^  bool pyxvreverse$^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextshortestdistance wrapper 0$^  $^    static pyobject pyxpyargnames  pyxnsifstpyxnsdeltapyxnsnstatepyxnsqueuetypepyxnsreverse0$^    pyobject values0  00000$^    values0  pyobject pyxnbauto$^    if unlikelypyxkwds $^      pyssizet kwargs$^      const pyssizet posargs  pytuplegetsizepyxargs$^      switch posargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 break$^        default goto pyxl0argtupleerror$^      $^      kwargs  pydictsizepyxkwds$^      switch posargs $^        case  0$^        if likelyvalues0  pyxpydictgetitemstrpyxkwds pyxnsifst  0 kwargs$^        else goto pyxl0argtupleerror$^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnsdelta$^          if value  values0  value kwargs $^        $^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnsnstate$^          if value  values0  value kwargs $^        $^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnsqueuetype$^          if value  values0  value kwargs $^        $^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnsreverse$^          if value  values0  value kwargs $^        $^      $^      if unlikelykwargs  0 $^        if unlikelypyxparseoptionalkeywordspyxkwds pyxpyargnames 0 values posargs shortestdistance  0 pyxerr0 0000 pyxl0error$^      $^     else $^      switch pytuplegetsizepyxargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        break$^        default goto pyxl0argtupleerror$^      $^    $^    pyxvifst  struct pyxobj0pywrapfstfst values0$^    if values0 $^      pyxvdelta  pyxpyfloatasfloatvalues0 if unlikelypyxvdelta  float0  pyerroccurred pyxerr0 0000 pyxl0error$^     else $^      pyxvdelta  pyxk00$^    $^    if values0 $^      pyxvnstate  pyxpyintasint00tvalues0 if unlikelypyxvnstate  int00t0  pyerroccurred pyxerr0 0000 pyxl0error$^     else $^      pyxvnstate  pyxk00$^    $^    pyxvqueuetype  values0$^    if values0 $^      pyxvreverse  pyxpyobjectistruevalues0 if unlikelypyxvreverse  bool0  pyerroccurred pyxerr0 0000 pyxl0error$^     else $^$^       pywrapfst.pyx0000$^                       int00 nstatefst.knostateid$^                       queuetypebauto$^                       bool reversefalse              $^    $^    shortestdistanceifst delta0e0 nstatenostateid$^ $^      pyxvreverse  bool0$^    $^  $^  goto pyxl0argumentunpackingdone$^  pyxl0argtupleerror$^  pyxraiseargtupleinvalidshortestdistance 0 0 0 pytuplegetsizepyxargs pyxerr0 0000 pyxl0error$^  pyxl0error$^  pyxaddtracebackpywrapfst.shortestdistance pyxclineno pyxlineno pyxfilename$^  pyxrefnannyfinishcontext$^  return null$^  pyxl0argumentunpackingdone$^  if unlikelypyxargtypetestpyobject pyxvifst pyxptype0pywrapfstfst 0 ifst 0 pyxerr0 0000 pyxl0error$^  pyxr  pyxpf0pywrapfst00shortestdistancepyxself pyxvifst pyxvdelta pyxvnstate pyxvqueuetype pyxvreverse$^$^   pywrapfst.pyx0000$^  $^  $^  def shortestdistancefst ifst              $^                       float deltafst.kshortestdelta$^                       int00 nstatefst.knostateid$^ $^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxr  null$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00shortestdistancecythonunused pyobject pyxself struct pyxobj0pywrapfstfst pyxvifst float pyxvdelta pyxt00basictypesint00 pyxvnstate pyobject pyxvqueuetype bool pyxvreverse $^  stduniqueptrstdvectorfstscriptweightclass   pyxvdistance$^  stdstring pyxvweighttype$^  fstscriptweightclass pyxvweight$^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  stdvectorfstscriptweightclass  pyxt0$^  struct pyxoptargs0pywrapfstshortestdistance pyxt0$^  pyobject pyxt0  null$^  stdvectorfstscriptweightclass iterator pyxt0$^  fstscriptweightclass pyxt0$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextshortestdistance 0$^$^   pywrapfst.pyx0000$^    $^    cdef uniqueptrvectorfst.weightclass distance$^    distance.resetshortestdistanceifst delta nstate queuetype reverse              $^    cdef string weighttype  ifst.weighttype$^    return weightweighttype weight.tostring for weight in derefdistance$^ $^  pyxt0.pyxn  0$^  pyxt0.delta  pyxvdelta$^  pyxt0.nstate  pyxvnstate$^  pyxt0.queuetype  pyxvqueuetype$^  pyxt0.reverse  pyxvreverse$^  pyxt0  pyxf0pywrapfstshortestdistancepyxvifst pyxt0 if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^  pyxvdistance.resetpyxt0$^$^   pywrapfst.pyx0000$^    cdef uniqueptrvectorfst.weightclass distance$^    distance.resetshortestdistanceifst delta nstate queuetype reverse$^    cdef string weighttype  ifst.weighttype              $^    return weightweighttype weight.tostring for weight in derefdistance$^  $^ $^  if unlikelypyobject pyxvifst  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s weighttype$^    pyxerr0 0000 pyxl0error$^  $^  pyxvweighttype  struct pyxvtabstruct0pywrapfstfst pyxvifstpyxvtabweighttypepyxvifst 0$^$^   pywrapfst.pyx0000$^    distance.resetshortestdistanceifst delta nstate queuetype reverse$^    cdef string weighttype  ifst.weighttype$^    return weightweighttype weight.tostring for weight in derefdistance              $^  $^  $^ $^  pyxxdecrefpyxr$^  pyxt0  pylistnew0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxt0  pyxvdistance$^  pyxt0  pyxt0begin$^  for  $^    if pyxt0  pyxt0end break$^    pyxt0  pyxt0$^    pyxt0$^    pyxvweight  pyxt0$^    pyxt0  pyxconvertpybytesstringtopystdinstringpyxvweighttype if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  pyxconvertpybytesstringtopystdinstringpyxvweight.tostring if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  pytuplenew0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxgiverefpyxt0$^    pytuplesetitempyxt0 0 pyxt0$^    pyxgiverefpyxt0$^    pytuplesetitempyxt0 0 pyxt0$^    pyxt0  0$^    pyxt0  0$^    pyxt0  pyxpyobjectcallpyobject pyxptype0pywrapfstweight pyxt0 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxdecrefpyxt0 pyxt0  0$^    if unlikelypyxlistcompappendpyxt0 pyobjectpyxt0 pyxerr0 0000 pyxl0error$^    pyxdecrefpyxt0 pyxt0  0$^  $^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   pywrapfst.pyx0000$^  $^  $^  def shortestdistancefst ifst              $^                       float deltafst.kshortestdelta$^                       int00 nstatefst.knostateid$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.shortestdistance pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^  $^  $^  cpdef mutablefst shortestpathfst ifst              $^                                 float deltafst.kshortestdelta$^                                 int00 nshortest0$^ $^$^static pyobject pyxpw0pywrapfst00shortestpathpyobject pyxself pyobject pyxargs pyobject pyxkwds proto$^static struct pyxobj0pywrapfstmutablefst pyxf0pywrapfstshortestpathstruct pyxobj0pywrapfstfst pyxvifst cythonunused int pyxskipdispatch struct pyxoptargs0pywrapfstshortestpath pyxoptionalargs $^  float pyxvdelta  pyxk00$^  pyxt00basictypesint00 pyxvnshortest  pyxt00basictypesint000$^  pyxt00basictypesint00 pyxvnstate  pyxk00$^  pyobject pyxvqueuetype  pyobject pyxnbauto$^$^   pywrapfst.pyx0000$^                                 int00 nstatefst.knostateid$^                                 queuetypebauto$^                                 bool uniquefalse              $^                                 weightnone$^    $^ $^  bool pyxvunique  bool0$^$^   pywrapfst.pyx0000$^                                 queuetypebauto$^                                 bool uniquefalse$^                                 weightnone              $^    $^    shortestpathifst delta0e0 nshortest0 nstatenostateid$^ $^  pyobject pyxvweight  pyobject pynone$^  stduniqueptrfstscriptvectorfstclass  pyxvtfst$^  fstscriptweightclass pyxvwc$^  stduniqueptrfstscriptshortestpathoptions  pyxvopts$^  struct pyxobj0pywrapfstmutablefst pyxr  null$^  pyxrefnannydeclarations$^  fstscriptweightclass pyxt0$^  stdstring pyxt0$^  enum fstqueuetype pyxt0$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextshortestpath 0$^  if pyxoptionalargs $^    if pyxoptionalargspyxn  0 $^      pyxvdelta  pyxoptionalargsdelta$^      if pyxoptionalargspyxn  0 $^        pyxvnshortest  pyxoptionalargsnshortest$^        if pyxoptionalargspyxn  0 $^          pyxvnstate  pyxoptionalargsnstate$^          if pyxoptionalargspyxn  0 $^            pyxvqueuetype  pyxoptionalargsqueuetype$^            if pyxoptionalargspyxn  0 $^              pyxvunique  pyxoptionalargsunique$^              if pyxoptionalargspyxn  0 $^                pyxvweight  pyxoptionalargsweight$^              $^            $^          $^        $^      $^    $^  $^$^   pywrapfst.pyx0000$^    $^    cdef uniqueptrfst.vectorfstclass tfst$^    tfst.resetnew fst.vectorfstclassifst.arctype              $^     threshold is set to semiring zero no pruning if no weight is specified.$^    cdef fst.weightclass wc  getweightclassorzeroifst.weighttype weight$^ $^  if unlikelypyobject pyxvifst  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s arctype$^    pyxerr0 0000 pyxl0error$^  $^  pyxvtfst.resetnew fstscriptvectorfstclassstruct pyxvtabstruct0pywrapfstfst pyxvifstpyxvtabarctypepyxvifst 0$^$^   pywrapfst.pyx0000$^    tfst.resetnew fst.vectorfstclassifst.arctype$^     threshold is set to semiring zero no pruning if no weight is specified.$^    cdef fst.weightclass wc  getweightclassorzeroifst.weighttype weight              $^    cdef uniqueptrfst.shortestpathoptions opts$^    opts.resetnew fst.shortestpathoptionsgetqueuetypetostringqueuetype$^ $^  if unlikelypyobject pyxvifst  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s weighttype$^    pyxerr0 0000 pyxl0error$^  $^  pyxt0  pyxf0pywrapfstgetweightclassorzerostruct pyxvtabstruct0pywrapfstfst pyxvifstpyxvtabweighttypepyxvifst 0 pyxvweight if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^  pyxvwc  pyxt0$^$^   pywrapfst.pyx0000$^    cdef fst.weightclass wc  getweightclassorzeroifst.weighttype weight$^    cdef uniqueptrfst.shortestpathoptions opts$^    opts.resetnew fst.shortestpathoptionsgetqueuetypetostringqueuetype              $^                                           nshortest unique delta wc nstate$^    fst.shortestpathderefifst.fst tfst.get derefopts$^ $^  pyxt0  pyxf0pywrapfsttostringpyxvqueuetype null if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^  pyxt0  pyxf0pywrapfstgetqueuetypepyxt0 if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^    cdef uniqueptrfst.shortestpathoptions opts$^    opts.resetnew fst.shortestpathoptionsgetqueuetypetostringqueuetype$^                                           nshortest unique delta wc nstate              $^    fst.shortestpathderefifst.fst tfst.get derefopts$^    return initmutablefsttfst.release$^ $^  pyxvopts.resetnew fstscriptshortestpathoptionspyxt0 pyxvnshortest pyxvunique pyxvdelta pyxvwc pyxvnstate$^$^   pywrapfst.pyx0000$^    opts.resetnew fst.shortestpathoptionsgetqueuetypetostringqueuetype$^                                           nshortest unique delta wc nstate$^    fst.shortestpathderefifst.fst tfst.get derefopts              $^    return initmutablefsttfst.release$^  $^ $^  if unlikelypyobject pyxvifst  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s fst$^    pyxerr0 0000 pyxl0error$^  $^  fstscriptshortestpathpyxvifstfst pyxvtfst.get pyxvopts$^$^   pywrapfst.pyx0000$^                                           nshortest unique delta wc nstate$^    fst.shortestpathderefifst.fst tfst.get derefopts$^    return initmutablefsttfst.release              $^  $^  $^ $^  pyxxdecrefpyobject pyxr$^  pyxt0  pyobject pyxf0pywrapfstinitmutablefstpyxvtfst.release if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  struct pyxobj0pywrapfstmutablefst pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   pywrapfst.pyx0000$^  $^  $^  cpdef mutablefst shortestpathfst ifst              $^                                 float deltafst.kshortestdelta$^                                 int00 nshortest0$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.shortestpath pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxl0$^  pyxxgiverefpyobject pyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst00shortestpathpyobject pyxself pyobject pyxargs pyobject pyxkwds proto$^static char pyxdoc0pywrapfst00shortestpath  n  shortestpathifst delta0e0 nshortest0 nstatenostateidn               queuetypeauto uniquefalse weightnonenn  construct an fst containing the shortest paths in the input fst.nn  this operation produces an fst containing the nshortest paths in the inputn  fst. the nshortest paths are the nlowest weight paths w.r.t. the naturaln  semiring order. the single path that can be read from the ith of at most nn  transitions leaving the initial state of the resulting fst is the ithn  shortest path. the weights need to be right distributive and have the pathn  property. they also need to be left distributive as well for nshortest withn  n  0 e.g. tropicalweight.nn  argsn    ifst the input fst.n    delta comparisonquantization delta.n    nshortest the number of paths to return.n    nstate state number threshold.n    queuetype a string matching a known queue type one of auto fifon        lifo shortest state top.n    unique should the resulting fst only contain distinct paths requiresn        the input fst to be an acceptor epsilons are treated as if they aren        regular symbols.n    weight a weight or weight string indicating the desired weight thresholdn        below which paths are pruned if omitted no paths are pruned.nn  returnsn    an fst containing the nshortest paths.n  $^static pyobject pyxpw0pywrapfst00shortestpathpyobject pyxself pyobject pyxargs pyobject pyxkwds $^  struct pyxobj0pywrapfstfst pyxvifst  0$^  float pyxvdelta$^  pyxt00basictypesint00 pyxvnshortest$^  pyxt00basictypesint00 pyxvnstate$^  pyobject pyxvqueuetype  0$^  bool pyxvunique$^  pyobject pyxvweight  0$^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextshortestpath wrapper 0$^  $^    static pyobject pyxpyargnames  pyxnsifstpyxnsdeltapyxnsnshortestpyxnsnstatepyxnsqueuetypepyxnsuniquepyxnsweight0$^    pyobject values0  0000000$^    values0  pyobject pyxnbauto$^$^     pywrapfst.pyx0000$^                                 queuetypebauto$^                                 bool uniquefalse$^                                 weightnone              $^    $^    shortestpathifst delta0e0 nshortest0 nstatenostateid$^ $^    values0  pyobject pynone$^    if unlikelypyxkwds $^      pyssizet kwargs$^      const pyssizet posargs  pytuplegetsizepyxargs$^      switch posargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 break$^        default goto pyxl0argtupleerror$^      $^      kwargs  pydictsizepyxkwds$^      switch posargs $^        case  0$^        if likelyvalues0  pyxpydictgetitemstrpyxkwds pyxnsifst  0 kwargs$^        else goto pyxl0argtupleerror$^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnsdelta$^          if value  values0  value kwargs $^        $^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnsnshortest$^          if value  values0  value kwargs $^        $^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnsnstate$^          if value  values0  value kwargs $^        $^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnsqueuetype$^          if value  values0  value kwargs $^        $^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnsunique$^          if value  values0  value kwargs $^        $^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnsweight$^          if value  values0  value kwargs $^        $^      $^      if unlikelykwargs  0 $^        if unlikelypyxparseoptionalkeywordspyxkwds pyxpyargnames 0 values posargs shortestpath  0 pyxerr0 0000 pyxl0error$^      $^     else $^      switch pytuplegetsizepyxargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        break$^        default goto pyxl0argtupleerror$^      $^    $^    pyxvifst  struct pyxobj0pywrapfstfst values0$^    if values0 $^      pyxvdelta  pyxpyfloatasfloatvalues0 if unlikelypyxvdelta  float0  pyerroccurred pyxerr0 0000 pyxl0error$^     else $^      pyxvdelta  pyxk00$^    $^    if values0 $^      pyxvnshortest  pyxpyintasint00tvalues0 if unlikelypyxvnshortest  int00t0  pyerroccurred pyxerr0 0000 pyxl0error$^     else $^      pyxvnshortest  pyxt00basictypesint000$^    $^    if values0 $^      pyxvnstate  pyxpyintasint00tvalues0 if unlikelypyxvnstate  int00t0  pyerroccurred pyxerr0 0000 pyxl0error$^     else $^      pyxvnstate  pyxk00$^    $^    pyxvqueuetype  values0$^    if values0 $^      pyxvunique  pyxpyobjectistruevalues0 if unlikelypyxvunique  bool0  pyerroccurred pyxerr0 0000 pyxl0error$^     else $^$^       pywrapfst.pyx0000$^                                 int00 nstatefst.knostateid$^                                 queuetypebauto$^                                 bool uniquefalse              $^                                 weightnone$^    $^ $^      pyxvunique  bool0$^    $^    pyxvweight  values0$^  $^  goto pyxl0argumentunpackingdone$^  pyxl0argtupleerror$^  pyxraiseargtupleinvalidshortestpath 0 0 0 pytuplegetsizepyxargs pyxerr0 0000 pyxl0error$^  pyxl0error$^  pyxaddtracebackpywrapfst.shortestpath pyxclineno pyxlineno pyxfilename$^  pyxrefnannyfinishcontext$^  return null$^  pyxl0argumentunpackingdone$^  if unlikelypyxargtypetestpyobject pyxvifst pyxptype0pywrapfstfst 0 ifst 0 pyxerr0 0000 pyxl0error$^  pyxr  pyxpf0pywrapfst00shortestpathpyxself pyxvifst pyxvdelta pyxvnshortest pyxvnstate pyxvqueuetype pyxvunique pyxvweight$^$^   pywrapfst.pyx0000$^  $^  $^  cpdef mutablefst shortestpathfst ifst              $^                                 float deltafst.kshortestdelta$^                                 int00 nshortest0$^ $^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxr  null$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00shortestpathcythonunused pyobject pyxself struct pyxobj0pywrapfstfst pyxvifst float pyxvdelta pyxt00basictypesint00 pyxvnshortest pyxt00basictypesint00 pyxvnstate pyobject pyxvqueuetype bool pyxvunique pyobject pyxvweight $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  struct pyxoptargs0pywrapfstshortestpath pyxt0$^  pyxrefnannysetupcontextshortestpath 0$^  pyxxdecrefpyxr$^  pyxt0.pyxn  0$^  pyxt0.delta  pyxvdelta$^  pyxt0.nshortest  pyxvnshortest$^  pyxt0.nstate  pyxvnstate$^  pyxt0.queuetype  pyxvqueuetype$^  pyxt0.unique  pyxvunique$^  pyxt0.weight  pyxvweight$^  pyxt0  pyobject pyxf0pywrapfstshortestpathpyxvifst 0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.shortestpath pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^  $^  $^  cpdef fst statemapfst ifst maptype              $^    $^    statemapifst maptype$^ $^$^static pyobject pyxpw0pywrapfst00statemappyobject pyxself pyobject pyxargs pyobject pyxkwds proto$^static struct pyxobj0pywrapfstfst pyxf0pywrapfststatemapstruct pyxobj0pywrapfstfst pyxvifst pyobject pyxvmaptype cythonunused int pyxskipdispatch $^  struct pyxobj0pywrapfstfst pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  struct pyxoptargs0pywrapfstmap pyxt0$^  pyxrefnannysetupcontextstatemap 0$^$^   pywrapfst.pyx0000$^    see also arcmap.$^    $^    return mapifst fst.kdelta maptype 0. none              $^  $^  $^ $^  pyxxdecrefpyobject pyxr$^  pyxt0.pyxn  0$^  pyxt0.delta  fstkdelta$^  pyxt0.maptype  pyxvmaptype$^  pyxt0.power  0.$^  pyxt0.weight  pynone$^  pyxt0  pyobject pyxf0pywrapfstmappyxvifst pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  struct pyxobj0pywrapfstfst pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   pywrapfst.pyx0000$^  $^  $^  cpdef fst statemapfst ifst maptype              $^    $^    statemapifst maptype$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.statemap pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxl0$^  pyxxgiverefpyobject pyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst00statemappyobject pyxself pyobject pyxargs pyobject pyxkwds proto$^static char pyxdoc0pywrapfst00statemap  n  statemapifst maptypenn  constructively applies a transform to all states.nn  this operation transforms each state according to the requested map type.n  note that currently only one statemapping operation is supported.nn  argsn    ifst the input fst.n    maptype a string matching a known mapping operation one of arcsumn        sum weights of identicallylabeled multiarcs arcunique deletesn        nonunique identicallylabeled multiarcs.nn  returnsn    an fst with states remapped.nn  raisesn    fstargerror unknown map type.nn  see also arcmap.n  $^static pyobject pyxpw0pywrapfst00statemappyobject pyxself pyobject pyxargs pyobject pyxkwds $^  struct pyxobj0pywrapfstfst pyxvifst  0$^  pyobject pyxvmaptype  0$^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextstatemap wrapper 0$^  $^    static pyobject pyxpyargnames  pyxnsifstpyxnsmaptype0$^    pyobject values0  00$^    if unlikelypyxkwds $^      pyssizet kwargs$^      const pyssizet posargs  pytuplegetsizepyxargs$^      switch posargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 break$^        default goto pyxl0argtupleerror$^      $^      kwargs  pydictsizepyxkwds$^      switch posargs $^        case  0$^        if likelyvalues0  pyxpydictgetitemstrpyxkwds pyxnsifst  0 kwargs$^        else goto pyxl0argtupleerror$^        cythonfallthrough$^        case  0$^        if likelyvalues0  pyxpydictgetitemstrpyxkwds pyxnsmaptype  0 kwargs$^        else $^          pyxraiseargtupleinvalidstatemap 0 0 0 0 pyxerr0 0000 pyxl0error$^        $^      $^      if unlikelykwargs  0 $^        if unlikelypyxparseoptionalkeywordspyxkwds pyxpyargnames 0 values posargs statemap  0 pyxerr0 0000 pyxl0error$^      $^     else if pytuplegetsizepyxargs  0 $^      goto pyxl0argtupleerror$^     else $^      values0  pytuplegetitempyxargs 0$^      values0  pytuplegetitempyxargs 0$^    $^    pyxvifst  struct pyxobj0pywrapfstfst values0$^    pyxvmaptype  values0$^  $^  goto pyxl0argumentunpackingdone$^  pyxl0argtupleerror$^  pyxraiseargtupleinvalidstatemap 0 0 0 pytuplegetsizepyxargs pyxerr0 0000 pyxl0error$^  pyxl0error$^  pyxaddtracebackpywrapfst.statemap pyxclineno pyxlineno pyxfilename$^  pyxrefnannyfinishcontext$^  return null$^  pyxl0argumentunpackingdone$^  if unlikelypyxargtypetestpyobject pyxvifst pyxptype0pywrapfstfst 0 ifst 0 pyxerr0 0000 pyxl0error$^  pyxr  pyxpf0pywrapfst00statemappyxself pyxvifst pyxvmaptype$^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxr  null$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00statemapcythonunused pyobject pyxself struct pyxobj0pywrapfstfst pyxvifst pyobject pyxvmaptype $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextstatemap 0$^  pyxxdecrefpyxr$^  pyxt0  pyobject pyxf0pywrapfststatemappyxvifst pyxvmaptype 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.statemap pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^  $^  $^  cpdef mutablefst synchronizefst ifst              $^    $^    synchronizeifst$^ $^$^static pyobject pyxpw0pywrapfst00synchronizepyobject pyxself pyobject pyxvifst proto$^static struct pyxobj0pywrapfstmutablefst pyxf0pywrapfstsynchronizestruct pyxobj0pywrapfstfst pyxvifst cythonunused int pyxskipdispatch $^  stduniqueptrfstscriptvectorfstclass  pyxvtfst$^  struct pyxobj0pywrapfstmutablefst pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextsynchronize 0$^$^   pywrapfst.pyx0000$^    $^    cdef uniqueptrfst.vectorfstclass tfst$^    tfst.resetnew fst.vectorfstclassifst.arctype              $^    fst.synchronizederefifst.fst tfst.get$^    return initmutablefsttfst.release$^ $^  if unlikelypyobject pyxvifst  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s arctype$^    pyxerr0 0000 pyxl0error$^  $^  pyxvtfst.resetnew fstscriptvectorfstclassstruct pyxvtabstruct0pywrapfstfst pyxvifstpyxvtabarctypepyxvifst 0$^$^   pywrapfst.pyx0000$^    cdef uniqueptrfst.vectorfstclass tfst$^    tfst.resetnew fst.vectorfstclassifst.arctype$^    fst.synchronizederefifst.fst tfst.get              $^    return initmutablefsttfst.release$^  $^ $^  if unlikelypyobject pyxvifst  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s fst$^    pyxerr0 0000 pyxl0error$^  $^  fstscriptsynchronizepyxvifstfst pyxvtfst.get$^$^   pywrapfst.pyx0000$^    tfst.resetnew fst.vectorfstclassifst.arctype$^    fst.synchronizederefifst.fst tfst.get$^    return initmutablefsttfst.release              $^  $^  $^ $^  pyxxdecrefpyobject pyxr$^  pyxt0  pyobject pyxf0pywrapfstinitmutablefstpyxvtfst.release if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  struct pyxobj0pywrapfstmutablefst pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   pywrapfst.pyx0000$^  $^  $^  cpdef mutablefst synchronizefst ifst              $^    $^    synchronizeifst$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.synchronize pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxl0$^  pyxxgiverefpyobject pyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst00synchronizepyobject pyxself pyobject pyxvifst proto$^static char pyxdoc0pywrapfst00synchronize  n  synchronizeifstnn  constructively synchronizes an fst.nn  this operation synchronizes a transducer. the result will be an equivalentn  fst that has the property that during the traversal of a path the delay isn  either zero or strictly increasing where the delay is the difference betweenn  the number of nonepsilon output labels and input labels along the path. forn  the algorithm to terminate the input transducer must have bounded delayn  i.e. the delay of every cycle must be zero.nn  argsn    ifst the input fst.nn  returnsn    an equivalent synchronized fst.n  $^static pyobject pyxpw0pywrapfst00synchronizepyobject pyxself pyobject pyxvifst $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextsynchronize wrapper 0$^  if unlikelypyxargtypetestpyobject pyxvifst pyxptype0pywrapfstfst 0 ifst 0 pyxerr0 0000 pyxl0error$^  pyxr  pyxpf0pywrapfst00synchronizepyxself struct pyxobj0pywrapfstfst pyxvifst$^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxr  null$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00synchronizecythonunused pyobject pyxself struct pyxobj0pywrapfstfst pyxvifst $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextsynchronize 0$^  pyxxdecrefpyxr$^  pyxt0  pyobject pyxf0pywrapfstsynchronizepyxvifst 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.synchronize pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^    $^  $^    def cinitself              $^                  string fsttypebvector$^                  string arctypebstandard$^ $^$^ python wrapper $^static int pyxpw0pywrapfst0compiler0cinitpyobject pyxvself pyobject pyxargs pyobject pyxkwds proto$^static int pyxpw0pywrapfst0compiler0cinitpyobject pyxvself pyobject pyxargs pyobject pyxkwds $^  stdstring pyxvfsttype$^  stdstring pyxvarctype$^  struct pyxobj0pywrapfstsymboltable pyxvisymbols  0$^  struct pyxobj0pywrapfstsymboltable pyxvosymbols  0$^  struct pyxobj0pywrapfstsymboltable pyxvssymbols  0$^  bool pyxvacceptor$^  bool pyxvkeepisymbols$^  bool pyxvkeeposymbols$^  bool pyxvkeepstatenumbering$^  bool pyxvallownegativelabels$^  int pyxr$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextcinit wrapper 0$^  $^    static pyobject pyxpyargnames  pyxnsfsttypepyxnsarctypepyxnsisymbolspyxnsosymbolspyxnsssymbolspyxnsacceptorpyxnskeepisymbolspyxnskeeposymbolspyxnskeepstatenumberingpyxnsallownegativelabels0$^    pyobject values00  0000000000$^$^     pywrapfst.pyx0000$^                  string fsttypebvector$^                  string arctypebstandard$^                  symboltable isymbolsnone              $^                  symboltable osymbolsnone$^                  symboltable ssymbolsnone$^ $^    values0  pyobject struct pyxobj0pywrapfstsymboltable pynone$^$^     pywrapfst.pyx0000$^                  string arctypebstandard$^                  symboltable isymbolsnone$^                  symboltable osymbolsnone              $^                  symboltable ssymbolsnone$^                  bool acceptorfalse$^ $^    values0  pyobject struct pyxobj0pywrapfstsymboltable pynone$^$^     pywrapfst.pyx0000$^                  symboltable isymbolsnone$^                  symboltable osymbolsnone$^                  symboltable ssymbolsnone              $^                  bool acceptorfalse$^                  bool keepisymbolsfalse$^ $^    values0  pyobject struct pyxobj0pywrapfstsymboltable pynone$^    if unlikelypyxkwds $^      pyssizet kwargs$^      const pyssizet posargs  pytuplegetsizepyxargs$^      switch posargs $^        case 00 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 break$^        default goto pyxl0argtupleerror$^      $^      kwargs  pydictsizepyxkwds$^      switch posargs $^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnsfsttype$^          if value  values0  value kwargs $^        $^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnsarctype$^          if value  values0  value kwargs $^        $^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnsisymbols$^          if value  values0  value kwargs $^        $^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnsosymbols$^          if value  values0  value kwargs $^        $^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnsssymbols$^          if value  values0  value kwargs $^        $^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnsacceptor$^          if value  values0  value kwargs $^        $^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnskeepisymbols$^          if value  values0  value kwargs $^        $^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnskeeposymbols$^          if value  values0  value kwargs $^        $^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnskeepstatenumbering$^          if value  values0  value kwargs $^        $^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnsallownegativelabels$^          if value  values0  value kwargs $^        $^      $^      if unlikelykwargs  0 $^        if unlikelypyxparseoptionalkeywordspyxkwds pyxpyargnames 0 values posargs cinit  0 pyxerr0 0000 pyxl0error$^      $^     else $^      switch pytuplegetsizepyxargs $^        case 00 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 break$^        default goto pyxl0argtupleerror$^      $^    $^    if values0 $^      pyxvfsttype  pyxconvertstringfrompystdinstringvalues0 if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^     else $^      pyxvfsttype  pyxk00$^    $^    if values0 $^      pyxvarctype  pyxconvertstringfrompystdinstringvalues0 if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^     else $^      pyxvarctype  pyxk00$^    $^    pyxvisymbols  struct pyxobj0pywrapfstsymboltable values0$^    pyxvosymbols  struct pyxobj0pywrapfstsymboltable values0$^    pyxvssymbols  struct pyxobj0pywrapfstsymboltable values0$^    if values0 $^      pyxvacceptor  pyxpyobjectistruevalues0 if unlikelypyxvacceptor  bool0  pyerroccurred pyxerr0 0000 pyxl0error$^     else $^$^       pywrapfst.pyx0000$^                  symboltable osymbolsnone$^                  symboltable ssymbolsnone$^                  bool acceptorfalse              $^                  bool keepisymbolsfalse$^                  bool keeposymbolsfalse$^ $^      pyxvacceptor  bool0$^    $^    if values0 $^      pyxvkeepisymbols  pyxpyobjectistruevalues0 if unlikelypyxvkeepisymbols  bool0  pyerroccurred pyxerr0 0000 pyxl0error$^     else $^$^       pywrapfst.pyx0000$^                  symboltable ssymbolsnone$^                  bool acceptorfalse$^                  bool keepisymbolsfalse              $^                  bool keeposymbolsfalse$^                  bool keepstatenumberingfalse$^ $^      pyxvkeepisymbols  bool0$^    $^    if values0 $^      pyxvkeeposymbols  pyxpyobjectistruevalues0 if unlikelypyxvkeeposymbols  bool0  pyerroccurred pyxerr0 0000 pyxl0error$^     else $^$^       pywrapfst.pyx0000$^                  bool acceptorfalse$^                  bool keepisymbolsfalse$^                  bool keeposymbolsfalse              $^                  bool keepstatenumberingfalse$^                  bool allownegativelabelsfalse$^ $^      pyxvkeeposymbols  bool0$^    $^    if values0 $^      pyxvkeepstatenumbering  pyxpyobjectistruevalues0 if unlikelypyxvkeepstatenumbering  bool0  pyerroccurred pyxerr0 0000 pyxl0error$^     else $^$^       pywrapfst.pyx0000$^                  bool keepisymbolsfalse$^                  bool keeposymbolsfalse$^                  bool keepstatenumberingfalse              $^                  bool allownegativelabelsfalse$^      self.sstrm.resetnew stringstream$^ $^      pyxvkeepstatenumbering  bool0$^    $^    if values0 $^      pyxvallownegativelabels  pyxpyobjectistruevalues0 if unlikelypyxvallownegativelabels  bool0  pyerroccurred pyxerr0 0000 pyxl0error$^     else $^$^       pywrapfst.pyx0000$^                  bool keeposymbolsfalse$^                  bool keepstatenumberingfalse$^                  bool allownegativelabelsfalse              $^      self.sstrm.resetnew stringstream$^      self.fsttype  tostringfsttype$^ $^      pyxvallownegativelabels  bool0$^    $^  $^  goto pyxl0argumentunpackingdone$^  pyxl0argtupleerror$^  pyxraiseargtupleinvalidcinit 0 0 00 pytuplegetsizepyxargs pyxerr0 0000 pyxl0error$^  pyxl0error$^  pyxaddtracebackpywrapfst.compiler.cinit pyxclineno pyxlineno pyxfilename$^  pyxrefnannyfinishcontext$^  return 0$^  pyxl0argumentunpackingdone$^  if unlikelypyxargtypetestpyobject pyxvisymbols pyxptype0pywrapfstsymboltable 0 isymbols 0 pyxerr0 0000 pyxl0error$^  if unlikelypyxargtypetestpyobject pyxvosymbols pyxptype0pywrapfstsymboltable 0 osymbols 0 pyxerr0 0000 pyxl0error$^  if unlikelypyxargtypetestpyobject pyxvssymbols pyxptype0pywrapfstsymboltable 0 ssymbols 0 pyxerr0 0000 pyxl0error$^  pyxr  pyxpf0pywrapfst0compilercinitstruct pyxobj0pywrapfstcompiler pyxvself pyxvfsttype pyxvarctype pyxvisymbols pyxvosymbols pyxvssymbols pyxvacceptor pyxvkeepisymbols pyxvkeeposymbols pyxvkeepstatenumbering pyxvallownegativelabels$^$^   pywrapfst.pyx0000$^    $^  $^    def cinitself              $^                  string fsttypebvector$^                  string arctypebstandard$^ $^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxr  0$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static int pyxpf0pywrapfst0compilercinitstruct pyxobj0pywrapfstcompiler pyxvself stdstring pyxvfsttype stdstring pyxvarctype struct pyxobj0pywrapfstsymboltable pyxvisymbols struct pyxobj0pywrapfstsymboltable pyxvosymbols struct pyxobj0pywrapfstsymboltable pyxvssymbols bool pyxvacceptor bool pyxvkeepisymbols bool pyxvkeeposymbols bool pyxvkeepstatenumbering bool pyxvallownegativelabels $^  int pyxr$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  stdstring pyxt0$^  int pyxt0$^  int pyxt0$^  fstsymboltable pyxt0$^  pyxrefnannysetupcontextcinit 0$^$^   pywrapfst.pyx0000$^                  bool keepstatenumberingfalse$^                  bool allownegativelabelsfalse$^      self.sstrm.resetnew stringstream              $^      self.fsttype  tostringfsttype$^      self.arctype  tostringarctype$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s sstrm$^    pyxerr0 0000 pyxl0error$^  $^  pyxvselfsstrm.resetnew stdstringstream$^$^   pywrapfst.pyx0000$^                  bool allownegativelabelsfalse$^      self.sstrm.resetnew stringstream$^      self.fsttype  tostringfsttype              $^      self.arctype  tostringarctype$^      self.isymbols  null$^ $^  pyxt0  pyxconvertpybytesstringtopystdinstringpyxvfsttype if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxt0  pyxf0pywrapfsttostringpyxt0 null if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s fsttype$^    pyxerr0 0000 pyxl0error$^  $^  pyxvselffsttype  pyxt0$^$^   pywrapfst.pyx0000$^      self.sstrm.resetnew stringstream$^      self.fsttype  tostringfsttype$^      self.arctype  tostringarctype              $^      self.isymbols  null$^      if isymbols is not none$^ $^  pyxt0  pyxconvertpybytesstringtopystdinstringpyxvarctype if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxt0  pyxf0pywrapfsttostringpyxt0 null if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s arctype$^    pyxerr0 0000 pyxl0error$^  $^  pyxvselfarctype  pyxt0$^$^   pywrapfst.pyx0000$^      self.fsttype  tostringfsttype$^      self.arctype  tostringarctype$^      self.isymbols  null              $^      if isymbols is not none$^        self.isymbols  isymbols.table$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s isymbols$^    pyxerr0 0000 pyxl0error$^  $^  pyxvselfisymbols  null$^$^   pywrapfst.pyx0000$^      self.arctype  tostringarctype$^      self.isymbols  null$^      if isymbols is not none              $^        self.isymbols  isymbols.table$^      self.osymbols  null$^ $^  pyxt0  pyobject pyxvisymbols  pynone$^  pyxt0  pyxt0  0$^  if pyxt0 $^$^     pywrapfst.pyx0000$^      self.isymbols  null$^      if isymbols is not none$^        self.isymbols  isymbols.table              $^      self.osymbols  null$^      if osymbols is not none$^ $^    if unlikelypyobject pyxvisymbols  pynone $^      pyerrformatpyexcattributeerror nonetype object has no attribute .00s table$^      pyxerr0 0000 pyxl0error$^    $^    pyxt0  pyxvisymbolspyxbase.pyxbase.table$^    if unlikelypyobject pyxvself  pynone $^      pyerrformatpyexcattributeerror nonetype object has no attribute .00s isymbols$^      pyxerr0 0000 pyxl0error$^    $^    pyxvselfisymbols  pyxt0$^$^     pywrapfst.pyx0000$^      self.arctype  tostringarctype$^      self.isymbols  null$^      if isymbols is not none              $^        self.isymbols  isymbols.table$^      self.osymbols  null$^ $^  $^$^   pywrapfst.pyx0000$^      if isymbols is not none$^        self.isymbols  isymbols.table$^      self.osymbols  null              $^      if osymbols is not none$^        self.osymbols  osymbols.table$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s osymbols$^    pyxerr0 0000 pyxl0error$^  $^  pyxvselfosymbols  null$^$^   pywrapfst.pyx0000$^        self.isymbols  isymbols.table$^      self.osymbols  null$^      if osymbols is not none              $^        self.osymbols  osymbols.table$^      self.ssymbols  null$^ $^  pyxt0  pyobject pyxvosymbols  pynone$^  pyxt0  pyxt0  0$^  if pyxt0 $^$^     pywrapfst.pyx0000$^      self.osymbols  null$^      if osymbols is not none$^        self.osymbols  osymbols.table              $^      self.ssymbols  null$^      if ssymbols is not none$^ $^    if unlikelypyobject pyxvosymbols  pynone $^      pyerrformatpyexcattributeerror nonetype object has no attribute .00s table$^      pyxerr0 0000 pyxl0error$^    $^    pyxt0  pyxvosymbolspyxbase.pyxbase.table$^    if unlikelypyobject pyxvself  pynone $^      pyerrformatpyexcattributeerror nonetype object has no attribute .00s osymbols$^      pyxerr0 0000 pyxl0error$^    $^    pyxvselfosymbols  pyxt0$^$^     pywrapfst.pyx0000$^        self.isymbols  isymbols.table$^      self.osymbols  null$^      if osymbols is not none              $^        self.osymbols  osymbols.table$^      self.ssymbols  null$^ $^  $^$^   pywrapfst.pyx0000$^      if osymbols is not none$^        self.osymbols  osymbols.table$^      self.ssymbols  null              $^      if ssymbols is not none$^        self.ssymbols  ssymbols.table$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s ssymbols$^    pyxerr0 0000 pyxl0error$^  $^  pyxvselfssymbols  null$^$^   pywrapfst.pyx0000$^        self.osymbols  osymbols.table$^      self.ssymbols  null$^      if ssymbols is not none              $^        self.ssymbols  ssymbols.table$^      self.acceptor  acceptor$^ $^  pyxt0  pyobject pyxvssymbols  pynone$^  pyxt0  pyxt0  0$^  if pyxt0 $^$^     pywrapfst.pyx0000$^      self.ssymbols  null$^      if ssymbols is not none$^        self.ssymbols  ssymbols.table              $^      self.acceptor  acceptor$^      self.keepisymbols  keepisymbols$^ $^    if unlikelypyobject pyxvssymbols  pynone $^      pyerrformatpyexcattributeerror nonetype object has no attribute .00s table$^      pyxerr0 0000 pyxl0error$^    $^    pyxt0  pyxvssymbolspyxbase.pyxbase.table$^    if unlikelypyobject pyxvself  pynone $^      pyerrformatpyexcattributeerror nonetype object has no attribute .00s ssymbols$^      pyxerr0 0000 pyxl0error$^    $^    pyxvselfssymbols  pyxt0$^$^     pywrapfst.pyx0000$^        self.osymbols  osymbols.table$^      self.ssymbols  null$^      if ssymbols is not none              $^        self.ssymbols  ssymbols.table$^      self.acceptor  acceptor$^ $^  $^$^   pywrapfst.pyx0000$^      if ssymbols is not none$^        self.ssymbols  ssymbols.table$^      self.acceptor  acceptor              $^      self.keepisymbols  keepisymbols$^      self.keeposymbols  keeposymbols$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s acceptor$^    pyxerr0 0000 pyxl0error$^  $^  pyxvselfacceptor  pyxvacceptor$^$^   pywrapfst.pyx0000$^        self.ssymbols  ssymbols.table$^      self.acceptor  acceptor$^      self.keepisymbols  keepisymbols              $^      self.keeposymbols  keeposymbols$^      self.keepstatenumbering  keepstatenumbering$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s keepisymbols$^    pyxerr0 0000 pyxl0error$^  $^  pyxvselfkeepisymbols  pyxvkeepisymbols$^$^   pywrapfst.pyx0000$^      self.acceptor  acceptor$^      self.keepisymbols  keepisymbols$^      self.keeposymbols  keeposymbols              $^      self.keepstatenumbering  keepstatenumbering$^      self.allownegativelabels  allownegativelabels$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s keeposymbols$^    pyxerr0 0000 pyxl0error$^  $^  pyxvselfkeeposymbols  pyxvkeeposymbols$^$^   pywrapfst.pyx0000$^      self.keepisymbols  keepisymbols$^      self.keeposymbols  keeposymbols$^      self.keepstatenumbering  keepstatenumbering              $^      self.allownegativelabels  allownegativelabels$^  $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s keepstatenumbering$^    pyxerr0 0000 pyxl0error$^  $^  pyxvselfkeepstatenumbering  pyxvkeepstatenumbering$^$^   pywrapfst.pyx0000$^      self.keeposymbols  keeposymbols$^      self.keepstatenumbering  keepstatenumbering$^      self.allownegativelabels  allownegativelabels              $^  $^    cpdef fst compileself$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s allownegativelabels$^    pyxerr0 0000 pyxl0error$^  $^  pyxvselfallownegativelabels  pyxvallownegativelabels$^$^   pywrapfst.pyx0000$^    $^  $^    def cinitself              $^                  string fsttypebvector$^                  string arctypebstandard$^ $^$^   function exit code $^  pyxr  0$^  goto pyxl0$^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.compiler.cinit pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      self.allownegativelabels  allownegativelabels$^  $^    cpdef fst compileself              $^      $^      compile$^ $^$^static pyobject pyxpw0pywrapfst0compiler0compilepyobject pyxvself cythonunused pyobject unused proto$^static struct pyxobj0pywrapfstfst pyxf0pywrapfst0compilercompilestruct pyxobj0pywrapfstcompiler pyxvself int pyxskipdispatch $^  stduniqueptrfstscriptfstclass  pyxvtfst$^  struct pyxobj0pywrapfstfst pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  int pyxt0$^  pyxrefnannysetupcontextcompile 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnscompile if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst0compiler0compile $^      pyxxdecrefpyobject pyxr$^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxdecrefpyxt0 pyxt0  0$^       else $^        pyxt0  pyxpyobjectcallnoargpyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      $^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      if likelypyxt0  pynone  likelypyxtypetestpyxt0 pyxptype0pywrapfstfst pyxerr0 0000 pyxl0error$^      pyxr  struct pyxobj0pywrapfstfst pyxt0$^      pyxt0  0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx0000$^      $^      cdef uniqueptrfst.fstclass tfst$^      tfst.resetfst.compilefstinternalderefself.sstrm              $^          bpywrapfst self.fsttype self.arctype self.isymbols$^          self.osymbols self.ssymbols self.acceptor self.keepisymbols$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s sstrm$^    pyxerr0 0000 pyxl0error$^  $^$^   pywrapfst.pyx0000$^      cdef uniqueptrfst.fstclass tfst$^      tfst.resetfst.compilefstinternalderefself.sstrm$^          bpywrapfst self.fsttype self.arctype self.isymbols              $^          self.osymbols self.ssymbols self.acceptor self.keepisymbols$^          self.keeposymbols self.keepstatenumbering$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s fsttype$^    pyxerr0 0000 pyxl0error$^  $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s arctype$^    pyxerr0 0000 pyxl0error$^  $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s isymbols$^    pyxerr0 0000 pyxl0error$^  $^$^   pywrapfst.pyx0000$^      tfst.resetfst.compilefstinternalderefself.sstrm$^          bpywrapfst self.fsttype self.arctype self.isymbols$^          self.osymbols self.ssymbols self.acceptor self.keepisymbols              $^          self.keeposymbols self.keepstatenumbering$^          self.allownegativelabels$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s osymbols$^    pyxerr0 0000 pyxl0error$^  $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s ssymbols$^    pyxerr0 0000 pyxl0error$^  $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s acceptor$^    pyxerr0 0000 pyxl0error$^  $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s keepisymbols$^    pyxerr0 0000 pyxl0error$^  $^$^   pywrapfst.pyx0000$^          bpywrapfst self.fsttype self.arctype self.isymbols$^          self.osymbols self.ssymbols self.acceptor self.keepisymbols$^          self.keeposymbols self.keepstatenumbering              $^          self.allownegativelabels$^      self.sstrm.resetnew stringstream$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s keeposymbols$^    pyxerr0 0000 pyxl0error$^  $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s keepstatenumbering$^    pyxerr0 0000 pyxl0error$^  $^$^   pywrapfst.pyx0000$^          self.osymbols self.ssymbols self.acceptor self.keepisymbols$^          self.keeposymbols self.keepstatenumbering$^          self.allownegativelabels              $^      self.sstrm.resetnew stringstream$^      if tfst.get  null$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s allownegativelabels$^    pyxerr0 0000 pyxl0error$^  $^$^   pywrapfst.pyx0000$^      $^      cdef uniqueptrfst.fstclass tfst$^      tfst.resetfst.compilefstinternalderefself.sstrm              $^          bpywrapfst self.fsttype self.arctype self.isymbols$^          self.osymbols self.ssymbols self.acceptor self.keepisymbols$^ $^  pyxvtfst.resetfstscriptcompilefstinternalpyxvselfsstrm pyxkpywrapfst pyxvselffsttype pyxvselfarctype pyxvselfisymbols pyxvselfosymbols pyxvselfssymbols pyxvselfacceptor pyxvselfkeepisymbols pyxvselfkeeposymbols pyxvselfkeepstatenumbering pyxvselfallownegativelabels$^$^   pywrapfst.pyx0000$^          self.keeposymbols self.keepstatenumbering$^          self.allownegativelabels$^      self.sstrm.resetnew stringstream              $^      if tfst.get  null$^        raise fstoperrorcompilation failed$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s sstrm$^    pyxerr0 0000 pyxl0error$^  $^  pyxvselfsstrm.resetnew stdstringstream$^$^   pywrapfst.pyx0000$^          self.allownegativelabels$^      self.sstrm.resetnew stringstream$^      if tfst.get  null              $^        raise fstoperrorcompilation failed$^      return initxfsttfst.release$^ $^  pyxt0  pyxvtfst.get  null  0$^  if unlikelypyxt0 $^$^     pywrapfst.pyx0000$^      self.sstrm.resetnew stringstream$^      if tfst.get  null$^        raise fstoperrorcompilation failed              $^      return initxfsttfst.release$^  $^ $^    pyxt0  pyxgetmoduleglobalnamepyxnsfstoperror if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  pyxpyobjectcallpyxt0 pyxtuple00 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxraisepyxt0 0 0 0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxerr0 0000 pyxl0error$^$^     pywrapfst.pyx0000$^          self.allownegativelabels$^      self.sstrm.resetnew stringstream$^      if tfst.get  null              $^        raise fstoperrorcompilation failed$^      return initxfsttfst.release$^ $^  $^$^   pywrapfst.pyx0000$^      if tfst.get  null$^        raise fstoperrorcompilation failed$^      return initxfsttfst.release              $^  $^    cpdef void writeself expression$^ $^  pyxxdecrefpyobject pyxr$^  pyxt0  pyobject pyxf0pywrapfstinitxfstpyxvtfst.release if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  struct pyxobj0pywrapfstfst pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      self.allownegativelabels  allownegativelabels$^  $^    cpdef fst compileself              $^      $^      compile$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.compiler.compile pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxl0$^  pyxxgiverefpyobject pyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst0compiler0compilepyobject pyxvself cythonunused pyobject unused proto$^static char pyxdoc0pywrapfst0compiler0compile  n    compilenn    compiles the fst in the compiler string buffer.nn    this method compiles the fst and returns the resulting machine.nn    returnsn      the fst described by the compiler string buffer.nn    raisesn      fstoperror compilation failed.n    $^static pyobject pyxpw0pywrapfst0compiler0compilepyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextcompile wrapper 0$^  pyxr  pyxpf0pywrapfst0compiler0compilestruct pyxobj0pywrapfstcompiler pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst0compiler0compilestruct pyxobj0pywrapfstcompiler pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextcompile 0$^  pyxxdecrefpyxr$^  pyxt0  pyobject pyxf0pywrapfst0compilercompilepyxvself 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.compiler.compile pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return initxfsttfst.release$^  $^    cpdef void writeself expression              $^      $^      writeexpression$^ $^$^static pyobject pyxpw0pywrapfst0compiler0writepyobject pyxvself pyobject pyxvexpression proto$^static void pyxf0pywrapfst0compilerwritestruct pyxobj0pywrapfstcompiler pyxvself pyobject pyxvexpression int pyxskipdispatch $^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  stdstring pyxt0$^  pyxrefnannysetupcontextwrite 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnswrite if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst0compiler0write $^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxvexpression if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxgotrefpyxt0$^       else $^        if cythonfastpycall$^        if pyfunctioncheckpyxt0 $^          pyobject pyxtemp0  pyxt0 pyxvexpression$^          pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^          pyxxdecrefpyxt0 pyxt0  0$^          pyxgotrefpyxt0$^         else$^        endif$^        if cythonfastpyccall$^        if pyxpyfastcfunctioncheckpyxt0 $^          pyobject pyxtemp0  pyxt0 pyxvexpression$^          pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^          pyxxdecrefpyxt0 pyxt0  0$^          pyxgotrefpyxt0$^         else$^        endif$^        $^          pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^          pyxgotrefpyxt0$^          pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^          pyxincrefpyxvexpression$^          pyxgiverefpyxvexpression$^          pytuplesetitempyxt0 00 pyxvexpression$^          pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^          pyxgotrefpyxt0$^          pyxdecrefpyxt0 pyxt0  0$^        $^      $^      pyxdecrefpyxt0 pyxt0  0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx0000$^        expression a string expression to add to compiler string buffer.$^      $^      derefself.sstrm  tostringexpression              $^  $^  $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s sstrm$^    pyxerr0 0000 pyxl0error$^  $^  pyxt0  pyxf0pywrapfsttostringpyxvexpression null if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^  voidpyxvselfsstrm  pyxt0$^$^   pywrapfst.pyx0000$^      return initxfsttfst.release$^  $^    cpdef void writeself expression              $^      $^      writeexpression$^ $^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxwriteunraisablepywrapfst.compiler.write pyxclineno pyxlineno pyxfilename 0 0$^  pyxl0$^  pyxrefnannyfinishcontext$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst0compiler0writepyobject pyxvself pyobject pyxvexpression proto$^static char pyxdoc0pywrapfst0compiler0write  n    writeexpressionnn    writes a string into the compiler string buffer.nn    this method adds a line to the compiler string buffer. it is normallyn    invoked using the right shift operator like sonn        compiler  fst.compilern        print  compiler 0 0 00 00n        print  compiler 0nn    argsn      expression a string expression to add to compiler string buffer.n    $^static pyobject pyxpw0pywrapfst0compiler0writepyobject pyxvself pyobject pyxvexpression $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextwrite wrapper 0$^  pyxr  pyxpf0pywrapfst0compiler0writestruct pyxobj0pywrapfstcompiler pyxvself pyobject pyxvexpression$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst0compiler0writestruct pyxobj0pywrapfstcompiler pyxvself pyobject pyxvexpression $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextwrite 0$^  pyxxdecrefpyxr$^  pyxt0  pyxvoidtononepyxf0pywrapfst0compilerwritepyxvself pyxvexpression 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.compiler.write pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ tree fragment0$^  def reducecythonself              $^      raise typeerrorno default reduce due to nontrivial cinit$^  def setstatecythonself pyxstate$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst0compiler0reducecythonpyobject pyxvself cythonunused pyobject unused proto$^static pyobject pyxpw0pywrapfst0compiler0reducecythonpyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextreducecython wrapper 0$^  pyxr  pyxpf0pywrapfst0compiler0reducecythonstruct pyxobj0pywrapfstcompiler pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst0compiler0reducecythoncythonunused struct pyxobj0pywrapfstcompiler pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextreducecython 0$^$^   tree fragment0$^  def reducecythonself$^      raise typeerrorno default reduce due to nontrivial cinit              $^  def setstatecythonself pyxstate$^      raise typeerrorno default reduce due to nontrivial cinit$^ $^  pyxt0  pyxpyobjectcallpyxbuiltintypeerror pyxtuple00 null if unlikelypyxt0 pyxerr0 0 pyxl0error$^  pyxgotrefpyxt0$^  pyxraisepyxt0 0 0 0$^  pyxdecrefpyxt0 pyxt0  0$^  pyxerr0 0 pyxl0error$^$^   tree fragment0$^  def reducecythonself              $^      raise typeerrorno default reduce due to nontrivial cinit$^  def setstatecythonself pyxstate$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.compiler.reducecython pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ tree fragment0$^  def reducecythonself$^      raise typeerrorno default reduce due to nontrivial cinit$^  def setstatecythonself pyxstate              $^      raise typeerrorno default reduce due to nontrivial cinit$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst0compiler0setstatecythonpyobject pyxvself pyobject pyxvpyxstate proto$^static pyobject pyxpw0pywrapfst0compiler0setstatecythonpyobject pyxvself pyobject pyxvpyxstate $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextsetstatecython wrapper 0$^  pyxr  pyxpf0pywrapfst0compiler0setstatecythonstruct pyxobj0pywrapfstcompiler pyxvself pyobject pyxvpyxstate$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst0compiler0setstatecythoncythonunused struct pyxobj0pywrapfstcompiler pyxvself cythonunused pyobject pyxvpyxstate $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextsetstatecython 0$^$^   tree fragment0$^      raise typeerrorno default reduce due to nontrivial cinit$^  def setstatecythonself pyxstate$^      raise typeerrorno default reduce due to nontrivial cinit              $^ $^  pyxt0  pyxpyobjectcallpyxbuiltintypeerror pyxtuple00 null if unlikelypyxt0 pyxerr0 0 pyxl0error$^  pyxgotrefpyxt0$^  pyxraisepyxt0 0 0 0$^  pyxdecrefpyxt0 pyxt0  0$^  pyxerr0 0 pyxl0error$^$^   tree fragment0$^  def reducecythonself$^      raise typeerrorno default reduce due to nontrivial cinit$^  def setstatecythonself pyxstate              $^      raise typeerrorno default reduce due to nontrivial cinit$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.compiler.setstatecython pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^    $^  $^    def initself              $^      raise fstdeletedconstructorerror$^          cannot construct .formatself.class.name$^ $^$^ python wrapper $^static int pyxpw0pywrapfst0farreader0initpyobject pyxvself pyobject pyxargs pyobject pyxkwds proto$^static int pyxpw0pywrapfst0farreader0initpyobject pyxvself pyobject pyxargs pyobject pyxkwds $^  int pyxr$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextinit wrapper 0$^  if unlikelypytuplegetsizepyxargs  0 $^    pyxraiseargtupleinvalidinit 0 0 0 pytuplegetsizepyxargs return 0$^  if unlikelypyxkwds  unlikelypydictsizepyxkwds  0  unlikelypyxcheckkeywordstringspyxkwds init 0 return 0$^  pyxr  pyxpf0pywrapfst0farreaderinitstruct pyxobj0pywrapfstfarreader pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static int pyxpf0pywrapfst0farreaderinitstruct pyxobj0pywrapfstfarreader pyxvself $^  int pyxr$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextinit 0$^$^   pywrapfst.pyx0000$^  $^    def initself$^      raise fstdeletedconstructorerror              $^          cannot construct .formatself.class.name$^  $^ $^  pyxt0  pyxgetmoduleglobalnamepyxnsfstdeletedconstructorerror if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^$^   pywrapfst.pyx0000$^    def initself$^      raise fstdeletedconstructorerror$^          cannot construct .formatself.class.name              $^  $^    def reprself$^ $^  pyxt0  pyxpyobjectgetattrstrpyxkpscannotconstruct pyxnsformat if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnsclass if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxt0  pyxpyobjectgetattrstrpyxt0 pyxnsname if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxdecrefpyxt0 pyxt0  0$^  pyxt0  null$^  if cythonunpackmethods  likelypymethodcheckpyxt0 $^    pyxt0  pymethodgetselfpyxt0$^    if likelypyxt0 $^      pyobject function  pymethodgetfunctionpyxt0$^      pyxincrefpyxt0$^      pyxincreffunction$^      pyxdecrefsetpyxt0 function$^    $^  $^  if pyxt0 $^    pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxdecrefpyxt0 pyxt0  0$^    pyxgotrefpyxt0$^   else $^    if cythonfastpycall$^    if pyfunctioncheckpyxt0 $^      pyobject pyxtemp0  pyxt0 pyxt0$^      pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxxdecrefpyxt0 pyxt0  0$^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^     else$^    endif$^    if cythonfastpyccall$^    if pyxpyfastcfunctioncheckpyxt0 $^      pyobject pyxtemp0  pyxt0 pyxt0$^      pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxxdecrefpyxt0 pyxt0  0$^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^     else$^    endif$^    $^      pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxgotrefpyxt0$^      pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^      pyxgiverefpyxt0$^      pytuplesetitempyxt0 00 pyxt0$^      pyxt0  0$^      pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^    $^  $^  pyxdecrefpyxt0 pyxt0  0$^  pyxt0  null$^  if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^    pyxt0  pymethodgetselfpyxt0$^    if likelypyxt0 $^      pyobject function  pymethodgetfunctionpyxt0$^      pyxincrefpyxt0$^      pyxincreffunction$^      pyxdecrefsetpyxt0 function$^    $^  $^  if pyxt0 $^    pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxdecrefpyxt0 pyxt0  0$^    pyxgotrefpyxt0$^   else $^    if cythonfastpycall$^    if pyfunctioncheckpyxt0 $^      pyobject pyxtemp0  pyxt0 pyxt0$^      pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxxdecrefpyxt0 pyxt0  0$^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^     else$^    endif$^    if cythonfastpyccall$^    if pyxpyfastcfunctioncheckpyxt0 $^      pyobject pyxtemp0  pyxt0 pyxt0$^      pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxxdecrefpyxt0 pyxt0  0$^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^     else$^    endif$^    $^      pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxgotrefpyxt0$^      pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^      pyxgiverefpyxt0$^      pytuplesetitempyxt0 00 pyxt0$^      pyxt0  0$^      pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^    $^  $^  pyxdecrefpyxt0 pyxt0  0$^  pyxraisepyxt0 0 0 0$^  pyxdecrefpyxt0 pyxt0  0$^  pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^    $^  $^    def initself              $^      raise fstdeletedconstructorerror$^          cannot construct .formatself.class.name$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.farreader.init pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^          cannot construct .formatself.class.name$^  $^    def reprself              $^      return  farreader at 0xx.formatself.fartype idself$^  $^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst0farreader0reprpyobject pyxvself proto$^static pyobject pyxpw0pywrapfst0farreader0reprpyobject pyxvself $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextrepr wrapper 0$^  pyxr  pyxpf0pywrapfst0farreader0reprstruct pyxobj0pywrapfstfarreader pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst0farreader0reprstruct pyxobj0pywrapfstfarreader pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  int pyxt0$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextrepr 0$^$^   pywrapfst.pyx0000$^  $^    def reprself$^      return  farreader at 0xx.formatself.fartype idself              $^  $^    classmethod$^ $^  pyxxdecrefpyxr$^  pyxt0  pyxpyobjectgetattrstrpyxkpsfarreaderat0xx pyxnsformat if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s fartype$^    pyxerr0 0000 pyxl0error$^  $^  pyxt0  pyxconvertpybytesstringtopystdinstringstruct pyxvtabstruct0pywrapfstfarreader pyxvselfpyxvtabfartypepyxvself 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxt0  pyxpyobjectcalloneargpyxbuiltinid pyobject pyxvself if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxt0  null$^  pyxt0  0$^  if cythonunpackmethods  likelypymethodcheckpyxt0 $^    pyxt0  pymethodgetselfpyxt0$^    if likelypyxt0 $^      pyobject function  pymethodgetfunctionpyxt0$^      pyxincrefpyxt0$^      pyxincreffunction$^      pyxdecrefsetpyxt0 function$^      pyxt0  0$^    $^  $^  if cythonfastpycall$^  if pyfunctioncheckpyxt0 $^    pyobject pyxtemp0  pyxt0 pyxt0 pyxt0$^    pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp0pyxt0 0pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxxdecrefpyxt0 pyxt0  0$^    pyxgotrefpyxt0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxdecrefpyxt0 pyxt0  0$^   else$^  endif$^  if cythonfastpyccall$^  if pyxpyfastcfunctioncheckpyxt0 $^    pyobject pyxtemp0  pyxt0 pyxt0 pyxt0$^    pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp0pyxt0 0pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxxdecrefpyxt0 pyxt0  0$^    pyxgotrefpyxt0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxdecrefpyxt0 pyxt0  0$^   else$^  endif$^  $^    pyxt0  pytuplenew0pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    if pyxt0 $^      pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^    $^    pyxgiverefpyxt0$^    pytuplesetitempyxt0 0pyxt0 pyxt0$^    pyxgiverefpyxt0$^    pytuplesetitempyxt0 0pyxt0 pyxt0$^    pyxt0  0$^    pyxt0  0$^    pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxdecrefpyxt0 pyxt0  0$^  $^  pyxdecrefpyxt0 pyxt0  0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   pywrapfst.pyx0000$^          cannot construct .formatself.class.name$^  $^    def reprself              $^      return  farreader at 0xx.formatself.fartype idself$^  $^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.farreader.repr pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^  $^    classmethod$^    def opencls filenames              $^      $^      farreader.openfilenames$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst0farreader0openpyobject pyxvcls pyobject pyxargs pyobject pyxkwds proto$^static char pyxdoc0pywrapfst0farreader0open  n    farreader.openfilenamesnn    creates a farreader object.nn    this class method creates a farreader given the string location of one orn    more far files on disk.nn    argsn      filenames the string location of one or more input far files.nn    returnsn      a new farreader instance.nn    raisesn      fstioerror read failed.n    $^static pyobject pyxpw0pywrapfst0farreader0openpyobject pyxvcls pyobject pyxargs pyobject pyxkwds $^  pyobject pyxvfilenames  0$^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextopen wrapper 0$^  if unlikelypyxkwds  unlikelypydictsizepyxkwds  0  unlikelypyxcheckkeywordstringspyxkwds open 0 return null$^  pyxincrefpyxargs$^  pyxvfilenames  pyxargs$^  pyxr  pyxpf0pywrapfst0farreader0openpytypeobjectpyxvcls pyxvfilenames$^$^   function exit code $^  pyxxdecrefpyxvfilenames$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst0farreader0opencythonunused pytypeobject pyxvcls pyobject pyxvfilenames $^  stduniqueptrfstscriptfarreaderclass  pyxvtfar$^  struct pyxobj0pywrapfstfarreader pyxvresult  0$^  pyobject pyxvfilename  null$^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyssizet pyxt0$^  pyobject pyxt0  null$^  stdstring pyxt0$^  stdvectorstdstring  pyxt0$^  int pyxt0$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt00  null$^  pyxrefnannysetupcontextopen 0$^  pyxincrefpyxvfilenames$^$^   pywrapfst.pyx0000$^        fstioerror read failed.$^      $^      filenames  tostringfilename for filename in filenames              $^      cdef uniqueptrfst.farreaderclass tfar$^      tfar.resetfst.farreaderclass.openfilenames$^ $^  pyxt0  pylistnew0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxt0  pyxvfilenames pyxincrefpyxt0 pyxt0  0$^  for  $^    if pyxt0  pytuplegetsizepyxt0 break$^    if cythonassumesafemacros  cythonavoidborrowedrefs$^    pyxt0  pytuplegetitempyxt0 pyxt0 pyxincrefpyxt0 pyxt0 if unlikely0  0 pyxerr0 0000 pyxl0error$^    else$^    pyxt0  pysequenceitempyxt0 pyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    endif$^    pyxxdecrefsetpyxvfilename pyxt0$^    pyxt0  0$^    pyxt0  pyxf0pywrapfsttostringpyxvfilename null if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^    pyxt0  pyxconvertpybytesstringtopystdinstringpyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    if unlikelypyxlistcompappendpyxt0 pyobjectpyxt0 pyxerr0 0000 pyxl0error$^    pyxdecrefpyxt0 pyxt0  0$^  $^  pyxdecrefpyxt0 pyxt0  0$^  pyxdecrefsetpyxvfilenames pyxt0$^  pyxt0  0$^$^   pywrapfst.pyx0000$^      filenames  tostringfilename for filename in filenames$^      cdef uniqueptrfst.farreaderclass tfar$^      tfar.resetfst.farreaderclass.openfilenames              $^      if tfar.get  null$^        raise fstioerrorread failed r.formatfilenames$^ $^  pyxt0  pyxconvertvectorfrompystd0a0astringpyxvfilenames if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^  pyxvtfar.resetfstscriptfarreaderclassopenpyxt0$^$^   pywrapfst.pyx0000$^      cdef uniqueptrfst.farreaderclass tfar$^      tfar.resetfst.farreaderclass.openfilenames$^      if tfar.get  null              $^        raise fstioerrorread failed r.formatfilenames$^      cdef farreader result  farreader.newfarreader$^ $^  pyxt0  pyxvtfar.get  null  0$^  if unlikelypyxt0 $^$^     pywrapfst.pyx0000$^      tfar.resetfst.farreaderclass.openfilenames$^      if tfar.get  null$^        raise fstioerrorread failed r.formatfilenames              $^      cdef farreader result  farreader.newfarreader$^      result.reader.resettfar.release$^ $^    pyxt0  pyxgetmoduleglobalnamepyxnsfstioerror if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  pyxpyobjectgetattrstrpyxkpsreadfailedr pyxnsformat if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  null$^    if cythonunpackmethods  likelypymethodcheckpyxt0 $^      pyxt0  pymethodgetselfpyxt0$^      if likelypyxt0 $^        pyobject function  pymethodgetfunctionpyxt0$^        pyxincrefpyxt0$^        pyxincreffunction$^        pyxdecrefsetpyxt0 function$^      $^    $^    if pyxt0 $^      pyxt0  pyxpyobjectcalloneargpyxt0 pyxvfilenames if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxgotrefpyxt0$^     else $^      if cythonfastpycall$^      if pyfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxvfilenames$^        pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^       else$^      endif$^      if cythonfastpyccall$^      if pyxpyfastcfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxvfilenames$^        pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^       else$^      endif$^      $^        pyxt00  pytuplenew00 if unlikelypyxt00 pyxerr0 0000 pyxl0error$^        pyxgotrefpyxt00$^        pyxgiverefpyxt0 pytuplesetitempyxt00 0 pyxt0 pyxt0  null$^        pyxincrefpyxvfilenames$^        pyxgiverefpyxvfilenames$^        pytuplesetitempyxt00 00 pyxvfilenames$^        pyxt0  pyxpyobjectcallpyxt0 pyxt00 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxgotrefpyxt0$^        pyxdecrefpyxt00 pyxt00  0$^      $^    $^    pyxdecrefpyxt0 pyxt0  0$^    pyxt0  null$^    if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^      pyxt0  pymethodgetselfpyxt0$^      if likelypyxt0 $^        pyobject function  pymethodgetfunctionpyxt0$^        pyxincrefpyxt0$^        pyxincreffunction$^        pyxdecrefsetpyxt0 function$^      $^    $^    if pyxt0 $^      pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxgotrefpyxt0$^     else $^      if cythonfastpycall$^      if pyfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxt0$^        pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^       else$^      endif$^      if cythonfastpyccall$^      if pyxpyfastcfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxt0$^        pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^       else$^      endif$^      $^        pyxt00  pytuplenew00 if unlikelypyxt00 pyxerr0 0000 pyxl0error$^        pyxgotrefpyxt00$^        pyxgiverefpyxt0 pytuplesetitempyxt00 0 pyxt0 pyxt0  null$^        pyxgiverefpyxt0$^        pytuplesetitempyxt00 00 pyxt0$^        pyxt0  0$^        pyxt0  pyxpyobjectcallpyxt0 pyxt00 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxgotrefpyxt0$^        pyxdecrefpyxt00 pyxt00  0$^      $^    $^    pyxdecrefpyxt0 pyxt0  0$^    pyxraisepyxt0 0 0 0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxerr0 0000 pyxl0error$^$^     pywrapfst.pyx0000$^      cdef uniqueptrfst.farreaderclass tfar$^      tfar.resetfst.farreaderclass.openfilenames$^      if tfar.get  null              $^        raise fstioerrorread failed r.formatfilenames$^      cdef farreader result  farreader.newfarreader$^ $^  $^$^   pywrapfst.pyx0000$^      if tfar.get  null$^        raise fstioerrorread failed r.formatfilenames$^      cdef farreader result  farreader.newfarreader              $^      result.reader.resettfar.release$^      return result$^ $^  pyxt0  pyobject pyxtpnew0pywrapfstfarreaderpytypeobject pyxptype0pywrapfstfarreader pyxemptytuple null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyobject pyxt0$^  pyxvresult  struct pyxobj0pywrapfstfarreader pyxt0$^  pyxt0  0$^$^   pywrapfst.pyx0000$^        raise fstioerrorread failed r.formatfilenames$^      cdef farreader result  farreader.newfarreader$^      result.reader.resettfar.release              $^      return result$^  $^ $^  if unlikelypyobject pyxvresult  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s reader$^    pyxerr0 0000 pyxl0error$^  $^  pyxvresultreader.resetpyxvtfar.release$^$^   pywrapfst.pyx0000$^      cdef farreader result  farreader.newfarreader$^      result.reader.resettfar.release$^      return result              $^  $^    cpdef string arctypeself$^ $^  pyxxdecrefpyxr$^  pyxincrefpyobject pyxvresult$^  pyxr  pyobject pyxvresult$^  goto pyxl0$^$^   pywrapfst.pyx0000$^  $^    classmethod$^    def opencls filenames              $^      $^      farreader.openfilenames$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt00$^  pyxaddtracebackpywrapfst.farreader.open pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxdecrefpyxvfilenames$^  pyxxdecrefpyobject pyxvresult$^  pyxxdecrefpyxvfilename$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return result$^  $^    cpdef string arctypeself              $^      $^      arctypeself$^ $^$^static pyobject pyxpw0pywrapfst0farreader0arctypepyobject pyxvself cythonunused pyobject unused proto$^static stdstring pyxf0pywrapfst0farreaderarctypestruct pyxobj0pywrapfstfarreader pyxvself int pyxskipdispatch $^  stdstring pyxr$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  stdstring pyxt0$^  pyxrefnannysetupcontextarctype 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnsarctype if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst0farreader0arctype $^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxdecrefpyxt0 pyxt0  0$^       else $^        pyxt0  pyxpyobjectcallnoargpyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      $^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxt0  pyxconvertstringfrompystdinstringpyxt0 if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxr  pyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx0000$^      returns a string indicating the arc type.$^      $^      return self.reader.get.arctype              $^  $^    cpdef bool doneself$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s reader$^    pyxerr0 0000 pyxl0error$^  $^  pyxr  pyxvselfreader.getarctype$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      return result$^  $^    cpdef string arctypeself              $^      $^      arctypeself$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxwriteunraisablepywrapfst.farreader.arctype pyxclineno pyxlineno pyxfilename 0 0$^  pyxpretendtoinitializepyxr$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst0farreader0arctypepyobject pyxvself cythonunused pyobject unused proto$^static char pyxdoc0pywrapfst0farreader0arctype  n    arctypeselfnn    returns a string indicating the arc type.n    $^static pyobject pyxpw0pywrapfst0farreader0arctypepyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextarctype wrapper 0$^  pyxr  pyxpf0pywrapfst0farreader0arctypestruct pyxobj0pywrapfstfarreader pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst0farreader0arctypestruct pyxobj0pywrapfstfarreader pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextarctype 0$^  pyxxdecrefpyxr$^  pyxt0  pyxconvertpybytesstringtopystdinstringpyxf0pywrapfst0farreaderarctypepyxvself 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.farreader.arctype pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return self.reader.get.arctype$^  $^    cpdef bool doneself              $^      $^      doneself$^ $^$^static pyobject pyxpw0pywrapfst0farreader0donepyobject pyxvself cythonunused pyobject unused proto$^static bool pyxf0pywrapfst0farreaderdonestruct pyxobj0pywrapfstfarreader pyxvself int pyxskipdispatch $^  bool pyxr$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  bool pyxt0$^  pyxrefnannysetupcontextdone 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnsdone if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst0farreader0done $^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxdecrefpyxt0 pyxt0  0$^       else $^        pyxt0  pyxpyobjectcallnoargpyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      $^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxt0  pyxpyobjectistruepyxt0 if unlikelypyxt0  bool0  pyerroccurred pyxerr0 0000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxr  pyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx0000$^        true if the iterator is exhausted false otherwise.$^      $^      return self.reader.get.done              $^  $^    cpdef bool errorself$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s reader$^    pyxerr0 0000 pyxl0error$^  $^  pyxr  pyxvselfreader.getdone$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      return self.reader.get.arctype$^  $^    cpdef bool doneself              $^      $^      doneself$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxwriteunraisablepywrapfst.farreader.done pyxclineno pyxlineno pyxfilename 0 0$^  pyxr  0$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst0farreader0donepyobject pyxvself cythonunused pyobject unused proto$^static char pyxdoc0pywrapfst0farreader0done  n    doneselfnn    indicates whether the iterator is exhausted or not.nn    returnsn      true if the iterator is exhausted false otherwise.n    $^static pyobject pyxpw0pywrapfst0farreader0donepyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextdone wrapper 0$^  pyxr  pyxpf0pywrapfst0farreader0donestruct pyxobj0pywrapfstfarreader pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst0farreader0donestruct pyxobj0pywrapfstfarreader pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextdone 0$^  pyxxdecrefpyxr$^  pyxt0  pyxpyboolfromlongpyxf0pywrapfst0farreaderdonepyxvself 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.farreader.done pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return self.reader.get.done$^  $^    cpdef bool errorself              $^      $^      errorself$^ $^$^static pyobject pyxpw0pywrapfst0farreader00errorpyobject pyxvself cythonunused pyobject unused proto$^static bool pyxf0pywrapfst0farreadererrorstruct pyxobj0pywrapfstfarreader pyxvself int pyxskipdispatch $^  bool pyxr$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  bool pyxt0$^  pyxrefnannysetupcontexterror 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnserror if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst0farreader00error $^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxdecrefpyxt0 pyxt0  0$^       else $^        pyxt0  pyxpyobjectcallnoargpyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      $^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxt0  pyxpyobjectistruepyxt0 if unlikelypyxt0  bool0  pyerroccurred pyxerr0 0000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxr  pyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx0000$^        true if the farreader is in an errorful state false otherwise.$^      $^      return self.reader.get.error              $^  $^    cpdef string fartypeself$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s reader$^    pyxerr0 0000 pyxl0error$^  $^  pyxr  pyxvselfreader.geterror$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      return self.reader.get.done$^  $^    cpdef bool errorself              $^      $^      errorself$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxwriteunraisablepywrapfst.farreader.error pyxclineno pyxlineno pyxfilename 0 0$^  pyxr  0$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst0farreader00errorpyobject pyxvself cythonunused pyobject unused proto$^static char pyxdoc0pywrapfst0farreader00error  n    errorselfnn    indicates whether the farreader has encountered an error.nn    returnsn      true if the farreader is in an errorful state false otherwise.n    $^static pyobject pyxpw0pywrapfst0farreader00errorpyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontexterror wrapper 0$^  pyxr  pyxpf0pywrapfst0farreader00errorstruct pyxobj0pywrapfstfarreader pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst0farreader00errorstruct pyxobj0pywrapfstfarreader pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontexterror 0$^  pyxxdecrefpyxr$^  pyxt0  pyxpyboolfromlongpyxf0pywrapfst0farreadererrorpyxvself 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.farreader.error pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return self.reader.get.error$^  $^    cpdef string fartypeself              $^      return fst.getfartypestringself.reader.get.type$^  $^ $^$^static pyobject pyxpw0pywrapfst0farreader00fartypepyobject pyxvself cythonunused pyobject unused proto$^static stdstring pyxf0pywrapfst0farreaderfartypestruct pyxobj0pywrapfstfarreader pyxvself int pyxskipdispatch $^  stdstring pyxr$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  stdstring pyxt0$^  pyxrefnannysetupcontextfartype 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnsfartype if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst0farreader00fartype $^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxdecrefpyxt0 pyxt0  0$^       else $^        pyxt0  pyxpyobjectcallnoargpyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      $^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxt0  pyxconvertstringfrompystdinstringpyxt0 if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxr  pyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx0000$^  $^    cpdef string fartypeself$^      return fst.getfartypestringself.reader.get.type              $^  $^    cpdef bool findself key except $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s reader$^    pyxerr0 0000 pyxl0error$^  $^  pyxr  fstgetfartypestringpyxvselfreader.gettype$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      return self.reader.get.error$^  $^    cpdef string fartypeself              $^      return fst.getfartypestringself.reader.get.type$^  $^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxwriteunraisablepywrapfst.farreader.fartype pyxclineno pyxlineno pyxfilename 0 0$^  pyxpretendtoinitializepyxr$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst0farreader00fartypepyobject pyxvself cythonunused pyobject unused proto$^static pyobject pyxpw0pywrapfst0farreader00fartypepyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextfartype wrapper 0$^  pyxr  pyxpf0pywrapfst0farreader00fartypestruct pyxobj0pywrapfstfarreader pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst0farreader00fartypestruct pyxobj0pywrapfstfarreader pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextfartype 0$^  pyxxdecrefpyxr$^  pyxt0  pyxconvertpybytesstringtopystdinstringpyxf0pywrapfst0farreaderfartypepyxvself 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.farreader.fartype pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return fst.getfartypestringself.reader.get.type$^  $^    cpdef bool findself key except               $^      $^      findself key$^ $^$^static pyobject pyxpw0pywrapfst0farreader00findpyobject pyxvself pyobject pyxvkey proto$^static bool pyxf0pywrapfst0farreaderfindstruct pyxobj0pywrapfstfarreader pyxvself pyobject pyxvkey int pyxskipdispatch $^  bool pyxr$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  bool pyxt0$^  stdstring pyxt0$^  pyxrefnannysetupcontextfind 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnsfind if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst0farreader00find $^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxvkey if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxgotrefpyxt0$^       else $^        if cythonfastpycall$^        if pyfunctioncheckpyxt0 $^          pyobject pyxtemp0  pyxt0 pyxvkey$^          pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^          pyxxdecrefpyxt0 pyxt0  0$^          pyxgotrefpyxt0$^         else$^        endif$^        if cythonfastpyccall$^        if pyxpyfastcfunctioncheckpyxt0 $^          pyobject pyxtemp0  pyxt0 pyxvkey$^          pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^          pyxxdecrefpyxt0 pyxt0  0$^          pyxgotrefpyxt0$^         else$^        endif$^        $^          pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^          pyxgotrefpyxt0$^          pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^          pyxincrefpyxvkey$^          pyxgiverefpyxvkey$^          pytuplesetitempyxt0 00 pyxvkey$^          pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^          pyxgotrefpyxt0$^          pyxdecrefpyxt0 pyxt0  0$^        $^      $^      pyxdecrefpyxt0 pyxt0  0$^      pyxt0  pyxpyobjectistruepyxt0 if unlikelypyxt0  bool0  pyerroccurred pyxerr0 0000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxr  pyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx0000$^        true if the key was found false otherwise.$^      $^      return self.reader.get.findtostringkey              $^  $^    cpdef fst getfstself$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s reader$^    pyxerr0 0000 pyxl0error$^  $^  pyxt0  pyxf0pywrapfsttostringpyxvkey null if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^  pyxr  pyxvselfreader.getfindpyxt0$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      return fst.getfartypestringself.reader.get.type$^  $^    cpdef bool findself key except               $^      $^      findself key$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.farreader.find pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst0farreader00findpyobject pyxvself pyobject pyxvkey proto$^static char pyxdoc0pywrapfst0farreader00find  n    findself keynn    sets the current position to the first entry greater than or equal to then    key a string and indicates whether or not a match was found.nn    argsn      key a string key.nn    returnsn      true if the key was found false otherwise.n    $^static pyobject pyxpw0pywrapfst0farreader00findpyobject pyxvself pyobject pyxvkey $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextfind wrapper 0$^  pyxr  pyxpf0pywrapfst0farreader00findstruct pyxobj0pywrapfstfarreader pyxvself pyobject pyxvkey$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst0farreader00findstruct pyxobj0pywrapfstfarreader pyxvself pyobject pyxvkey $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  bool pyxt0$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextfind 0$^  pyxxdecrefpyxr$^  pyxt0  pyxf0pywrapfst0farreaderfindpyxvself pyxvkey 0 if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^  pyxt0  pyxpyboolfromlongpyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.farreader.find pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return self.reader.get.findtostringkey$^  $^    cpdef fst getfstself              $^      $^      getfstself$^ $^$^static pyobject pyxpw0pywrapfst0farreader00getfstpyobject pyxvself cythonunused pyobject unused proto$^static struct pyxobj0pywrapfstfst pyxf0pywrapfst0farreadergetfststruct pyxobj0pywrapfstfarreader pyxvself int pyxskipdispatch $^  struct pyxobj0pywrapfstfst pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextgetfst 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnsgetfst if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst0farreader00getfst $^      pyxxdecrefpyobject pyxr$^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxdecrefpyxt0 pyxt0  0$^       else $^        pyxt0  pyxpyobjectcallnoargpyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      $^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      if likelypyxt0  pynone  likelypyxtypetestpyxt0 pyxptype0pywrapfstfst pyxerr0 0000 pyxl0error$^      pyxr  struct pyxobj0pywrapfstfst pyxt0$^      pyxt0  0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx0000$^        a copy of the fst at the current position.$^      $^      return initxfstnew fst.fstclass              $^          derefself.reader.get.getfstclass$^  $^ $^  pyxxdecrefpyobject pyxr$^$^   pywrapfst.pyx0000$^      $^      return initxfstnew fst.fstclass$^          derefself.reader.get.getfstclass              $^  $^    cpdef string getkeyself$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s reader$^    pyxerr0 0000 pyxl0error$^  $^$^   pywrapfst.pyx0000$^        a copy of the fst at the current position.$^      $^      return initxfstnew fst.fstclass              $^          derefself.reader.get.getfstclass$^  $^ $^  pyxt0  pyobject pyxf0pywrapfstinitxfstnew fstscriptfstclasspyxvselfreader.getgetfstclass if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  struct pyxobj0pywrapfstfst pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      return self.reader.get.findtostringkey$^  $^    cpdef fst getfstself              $^      $^      getfstself$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.farreader.getfst pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxl0$^  pyxxgiverefpyobject pyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst0farreader00getfstpyobject pyxvself cythonunused pyobject unused proto$^static char pyxdoc0pywrapfst0farreader00getfst  n    getfstselfnn    returns the fst at the current position.nn    returnsn      a copy of the fst at the current position.n    $^static pyobject pyxpw0pywrapfst0farreader00getfstpyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextgetfst wrapper 0$^  pyxr  pyxpf0pywrapfst0farreader00getfststruct pyxobj0pywrapfstfarreader pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst0farreader00getfststruct pyxobj0pywrapfstfarreader pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextgetfst 0$^  pyxxdecrefpyxr$^  pyxt0  pyobject pyxf0pywrapfst0farreadergetfstpyxvself 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.farreader.getfst pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^          derefself.reader.get.getfstclass$^  $^    cpdef string getkeyself              $^      $^      getkeyself$^ $^$^static pyobject pyxpw0pywrapfst0farreader00getkeypyobject pyxvself cythonunused pyobject unused proto$^static stdstring pyxf0pywrapfst0farreadergetkeystruct pyxobj0pywrapfstfarreader pyxvself int pyxskipdispatch $^  stdstring pyxr$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  stdstring pyxt0$^  pyxrefnannysetupcontextgetkey 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnsgetkey if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst0farreader00getkey $^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxdecrefpyxt0 pyxt0  0$^       else $^        pyxt0  pyxpyobjectcallnoargpyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      $^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxt0  pyxconvertstringfrompystdinstringpyxt0 if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxr  pyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx0000$^        the string key at the current position.$^      $^      return self.reader.get.getkey              $^  $^    cpdef void nextself$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s reader$^    pyxerr0 0000 pyxl0error$^  $^  pyxr  pyxvselfreader.getgetkey$^  goto pyxl0$^$^   pywrapfst.pyx0000$^          derefself.reader.get.getfstclass$^  $^    cpdef string getkeyself              $^      $^      getkeyself$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxwriteunraisablepywrapfst.farreader.getkey pyxclineno pyxlineno pyxfilename 0 0$^  pyxpretendtoinitializepyxr$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst0farreader00getkeypyobject pyxvself cythonunused pyobject unused proto$^static char pyxdoc0pywrapfst0farreader00getkey  n    getkeyselfnn    returns the string key at the current position.nn    returnsn      the string key at the current position.n    $^static pyobject pyxpw0pywrapfst0farreader00getkeypyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextgetkey wrapper 0$^  pyxr  pyxpf0pywrapfst0farreader00getkeystruct pyxobj0pywrapfstfarreader pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst0farreader00getkeystruct pyxobj0pywrapfstfarreader pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextgetkey 0$^  pyxxdecrefpyxr$^  pyxt0  pyxconvertpybytesstringtopystdinstringpyxf0pywrapfst0farreadergetkeypyxvself 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.farreader.getkey pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return self.reader.get.getkey$^  $^    cpdef void nextself              $^      $^      nextself$^ $^$^static pyobject pyxpw0pywrapfst0farreader00nextpyobject pyxvself cythonunused pyobject unused proto$^static void pyxf0pywrapfst0farreadernextstruct pyxobj0pywrapfstfarreader pyxvself int pyxskipdispatch $^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextnext 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnsnext if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst0farreader00next $^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxdecrefpyxt0 pyxt0  0$^       else $^        pyxt0  pyxpyobjectcallnoargpyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      $^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx0000$^      advances the iterator.$^      $^      self.reader.get.next              $^  $^    cpdef void resetself$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s reader$^    pyxerr0 0000 pyxl0error$^  $^  pyxvselfreader.getnext$^$^   pywrapfst.pyx0000$^      return self.reader.get.getkey$^  $^    cpdef void nextself              $^      $^      nextself$^ $^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxwriteunraisablepywrapfst.farreader.next pyxclineno pyxlineno pyxfilename 0 0$^  pyxl0$^  pyxrefnannyfinishcontext$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst0farreader00nextpyobject pyxvself cythonunused pyobject unused proto$^static char pyxdoc0pywrapfst0farreader00next  n    nextselfnn    advances the iterator.n    $^static pyobject pyxpw0pywrapfst0farreader00nextpyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextnext wrapper 0$^  pyxr  pyxpf0pywrapfst0farreader00nextstruct pyxobj0pywrapfstfarreader pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst0farreader00nextstruct pyxobj0pywrapfstfarreader pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextnext 0$^  pyxxdecrefpyxr$^  pyxt0  pyxvoidtononepyxf0pywrapfst0farreadernextpyxvself 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.farreader.next pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      self.reader.get.next$^  $^    cpdef void resetself              $^      $^      resetself$^ $^$^static pyobject pyxpw0pywrapfst0farreader00resetpyobject pyxvself cythonunused pyobject unused proto$^static void pyxf0pywrapfst0farreaderresetstruct pyxobj0pywrapfstfarreader pyxvself int pyxskipdispatch $^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextreset 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnsreset if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst0farreader00reset $^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxdecrefpyxt0 pyxt0  0$^       else $^        pyxt0  pyxpyobjectcallnoargpyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      $^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx0000$^      resets the iterator to the initial position.$^      $^      self.reader.get.reset              $^  $^    def getitemself key$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s reader$^    pyxerr0 0000 pyxl0error$^  $^  pyxvselfreader.getreset$^$^   pywrapfst.pyx0000$^      self.reader.get.next$^  $^    cpdef void resetself              $^      $^      resetself$^ $^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxwriteunraisablepywrapfst.farreader.reset pyxclineno pyxlineno pyxfilename 0 0$^  pyxl0$^  pyxrefnannyfinishcontext$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst0farreader00resetpyobject pyxvself cythonunused pyobject unused proto$^static char pyxdoc0pywrapfst0farreader00reset  n    resetselfnn    resets the iterator to the initial position.n    $^static pyobject pyxpw0pywrapfst0farreader00resetpyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextreset wrapper 0$^  pyxr  pyxpf0pywrapfst0farreader00resetstruct pyxobj0pywrapfstfarreader pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst0farreader00resetstruct pyxobj0pywrapfstfarreader pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextreset 0$^  pyxxdecrefpyxr$^  pyxt0  pyxvoidtononepyxf0pywrapfst0farreaderresetpyxvself 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.farreader.reset pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      self.reader.get.reset$^  $^    def getitemself key              $^      cdef string ckey  tostringkey$^      if self.getkey  ckey or self.reader.get.findckey$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst0farreader00getitempyobject pyxvself pyobject pyxvkey proto$^static pyobject pyxpw0pywrapfst0farreader00getitempyobject pyxvself pyobject pyxvkey $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextgetitem wrapper 0$^  pyxr  pyxpf0pywrapfst0farreader00getitemstruct pyxobj0pywrapfstfarreader pyxvself pyobject pyxvkey$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst0farreader00getitemstruct pyxobj0pywrapfstfarreader pyxvself pyobject pyxvkey $^  stdstring pyxvckey$^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  stdstring pyxt0$^  int pyxt0$^  int pyxt0$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextgetitem 0$^$^   pywrapfst.pyx0000$^  $^    def getitemself key$^      cdef string ckey  tostringkey              $^      if self.getkey  ckey or self.reader.get.findckey$^        return self.getfst$^ $^  pyxt0  pyxf0pywrapfsttostringpyxvkey null if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^  pyxvckey  pyxt0$^$^   pywrapfst.pyx0000$^    def getitemself key$^      cdef string ckey  tostringkey$^      if self.getkey  ckey or self.reader.get.findckey              $^        return self.getfst$^      else$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s getkey$^    pyxerr0 0000 pyxl0error$^  $^  pyxt0  struct pyxvtabstruct0pywrapfstfarreader pyxvselfpyxvtabgetkeypyxvself 0  pyxvckey  0$^  if pyxt0 $^   else $^    pyxt0  pyxt0$^    goto pyxl0boolbinopdone$^  $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s reader$^    pyxerr0 0000 pyxl0error$^  $^  pyxt0  pyxvselfreader.getfindpyxvckey  0$^  pyxt0  pyxt0$^  pyxl0boolbinopdone$^  if likelypyxt0 $^$^     pywrapfst.pyx0000$^      cdef string ckey  tostringkey$^      if self.getkey  ckey or self.reader.get.findckey$^        return self.getfst              $^      else$^        raise keyerrorkey$^ $^    pyxxdecrefpyxr$^    if unlikelypyobject pyxvself  pynone $^      pyerrformatpyexcattributeerror nonetype object has no attribute .00s getfst$^      pyxerr0 0000 pyxl0error$^    $^    pyxt0  pyobject struct pyxvtabstruct0pywrapfstfarreader pyxvselfpyxvtabgetfstpyxvself 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxr  pyxt0$^    pyxt0  0$^    goto pyxl0$^$^     pywrapfst.pyx0000$^    def getitemself key$^      cdef string ckey  tostringkey$^      if self.getkey  ckey or self.reader.get.findckey              $^        return self.getfst$^      else$^ $^  $^$^   pywrapfst.pyx0000$^        return self.getfst$^      else$^        raise keyerrorkey              $^  $^  $^ $^  else $^    pyxt0  pyxpyobjectcalloneargpyxbuiltinkeyerror pyxvkey if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxraisepyxt0 0 0 0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxerr0 0000 pyxl0error$^  $^$^   pywrapfst.pyx0000$^      self.reader.get.reset$^  $^    def getitemself key              $^      cdef string ckey  tostringkey$^      if self.getkey  ckey or self.reader.get.findckey$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.farreader.getitem pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ tree fragment0$^  def reducecythonself              $^      raise typeerrorself.reader cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst0farreader00reducecythonpyobject pyxvself cythonunused pyobject unused proto$^static pyobject pyxpw0pywrapfst0farreader00reducecythonpyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextreducecython wrapper 0$^  pyxr  pyxpf0pywrapfst0farreader00reducecythonstruct pyxobj0pywrapfstfarreader pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst0farreader00reducecythoncythonunused struct pyxobj0pywrapfstfarreader pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextreducecython 0$^$^   tree fragment0$^  def reducecythonself$^      raise typeerrorself.reader cannot be converted to a python object for pickling              $^  def setstatecythonself pyxstate$^      raise typeerrorself.reader cannot be converted to a python object for pickling$^ $^  pyxt0  pyxpyobjectcallpyxbuiltintypeerror pyxtuple00 null if unlikelypyxt0 pyxerr0 0 pyxl0error$^  pyxgotrefpyxt0$^  pyxraisepyxt0 0 0 0$^  pyxdecrefpyxt0 pyxt0  0$^  pyxerr0 0 pyxl0error$^$^   tree fragment0$^  def reducecythonself              $^      raise typeerrorself.reader cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.farreader.reducecython pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ tree fragment0$^  def reducecythonself$^      raise typeerrorself.reader cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate              $^      raise typeerrorself.reader cannot be converted to a python object for pickling$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst0farreader00setstatecythonpyobject pyxvself pyobject pyxvpyxstate proto$^static pyobject pyxpw0pywrapfst0farreader00setstatecythonpyobject pyxvself pyobject pyxvpyxstate $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextsetstatecython wrapper 0$^  pyxr  pyxpf0pywrapfst0farreader00setstatecythonstruct pyxobj0pywrapfstfarreader pyxvself pyobject pyxvpyxstate$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst0farreader00setstatecythoncythonunused struct pyxobj0pywrapfstfarreader pyxvself cythonunused pyobject pyxvpyxstate $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextsetstatecython 0$^$^   tree fragment0$^      raise typeerrorself.reader cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate$^      raise typeerrorself.reader cannot be converted to a python object for pickling              $^ $^  pyxt0  pyxpyobjectcallpyxbuiltintypeerror pyxtuple00 null if unlikelypyxt0 pyxerr0 0 pyxl0error$^  pyxgotrefpyxt0$^  pyxraisepyxt0 0 0 0$^  pyxdecrefpyxt0 pyxt0  0$^  pyxerr0 0 pyxl0error$^$^   tree fragment0$^  def reducecythonself$^      raise typeerrorself.reader cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate              $^      raise typeerrorself.reader cannot be converted to a python object for pickling$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.farreader.setstatecython pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^    $^  $^    def initself              $^      raise fstdeletedconstructorerror$^          cannot construct .formatself.class.name$^ $^$^ python wrapper $^static int pyxpw0pywrapfst0farwriter0initpyobject pyxvself pyobject pyxargs pyobject pyxkwds proto$^static int pyxpw0pywrapfst0farwriter0initpyobject pyxvself pyobject pyxargs pyobject pyxkwds $^  int pyxr$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextinit wrapper 0$^  if unlikelypytuplegetsizepyxargs  0 $^    pyxraiseargtupleinvalidinit 0 0 0 pytuplegetsizepyxargs return 0$^  if unlikelypyxkwds  unlikelypydictsizepyxkwds  0  unlikelypyxcheckkeywordstringspyxkwds init 0 return 0$^  pyxr  pyxpf0pywrapfst0farwriterinitstruct pyxobj0pywrapfstfarwriter pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static int pyxpf0pywrapfst0farwriterinitstruct pyxobj0pywrapfstfarwriter pyxvself $^  int pyxr$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextinit 0$^$^   pywrapfst.pyx0000$^  $^    def initself$^      raise fstdeletedconstructorerror              $^          cannot construct .formatself.class.name$^  $^ $^  pyxt0  pyxgetmoduleglobalnamepyxnsfstdeletedconstructorerror if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^$^   pywrapfst.pyx0000$^    def initself$^      raise fstdeletedconstructorerror$^          cannot construct .formatself.class.name              $^  $^    def reprself$^ $^  pyxt0  pyxpyobjectgetattrstrpyxkpscannotconstruct pyxnsformat if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnsclass if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxt0  pyxpyobjectgetattrstrpyxt0 pyxnsname if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxdecrefpyxt0 pyxt0  0$^  pyxt0  null$^  if cythonunpackmethods  likelypymethodcheckpyxt0 $^    pyxt0  pymethodgetselfpyxt0$^    if likelypyxt0 $^      pyobject function  pymethodgetfunctionpyxt0$^      pyxincrefpyxt0$^      pyxincreffunction$^      pyxdecrefsetpyxt0 function$^    $^  $^  if pyxt0 $^    pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxdecrefpyxt0 pyxt0  0$^    pyxgotrefpyxt0$^   else $^    if cythonfastpycall$^    if pyfunctioncheckpyxt0 $^      pyobject pyxtemp0  pyxt0 pyxt0$^      pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxxdecrefpyxt0 pyxt0  0$^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^     else$^    endif$^    if cythonfastpyccall$^    if pyxpyfastcfunctioncheckpyxt0 $^      pyobject pyxtemp0  pyxt0 pyxt0$^      pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxxdecrefpyxt0 pyxt0  0$^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^     else$^    endif$^    $^      pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxgotrefpyxt0$^      pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^      pyxgiverefpyxt0$^      pytuplesetitempyxt0 00 pyxt0$^      pyxt0  0$^      pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^    $^  $^  pyxdecrefpyxt0 pyxt0  0$^  pyxt0  null$^  if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^    pyxt0  pymethodgetselfpyxt0$^    if likelypyxt0 $^      pyobject function  pymethodgetfunctionpyxt0$^      pyxincrefpyxt0$^      pyxincreffunction$^      pyxdecrefsetpyxt0 function$^    $^  $^  if pyxt0 $^    pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxdecrefpyxt0 pyxt0  0$^    pyxgotrefpyxt0$^   else $^    if cythonfastpycall$^    if pyfunctioncheckpyxt0 $^      pyobject pyxtemp0  pyxt0 pyxt0$^      pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxxdecrefpyxt0 pyxt0  0$^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^     else$^    endif$^    if cythonfastpyccall$^    if pyxpyfastcfunctioncheckpyxt0 $^      pyobject pyxtemp0  pyxt0 pyxt0$^      pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxxdecrefpyxt0 pyxt0  0$^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^     else$^    endif$^    $^      pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxgotrefpyxt0$^      pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^      pyxgiverefpyxt0$^      pytuplesetitempyxt0 00 pyxt0$^      pyxt0  0$^      pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^    $^  $^  pyxdecrefpyxt0 pyxt0  0$^  pyxraisepyxt0 0 0 0$^  pyxdecrefpyxt0 pyxt0  0$^  pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^    $^  $^    def initself              $^      raise fstdeletedconstructorerror$^          cannot construct .formatself.class.name$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.farwriter.init pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^          cannot construct .formatself.class.name$^  $^    def reprself              $^      return  farwriter at 0xx.formatself.fartype idself$^  $^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst0farwriter0reprpyobject pyxvself proto$^static pyobject pyxpw0pywrapfst0farwriter0reprpyobject pyxvself $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextrepr wrapper 0$^  pyxr  pyxpf0pywrapfst0farwriter0reprstruct pyxobj0pywrapfstfarwriter pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst0farwriter0reprstruct pyxobj0pywrapfstfarwriter pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  int pyxt0$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextrepr 0$^$^   pywrapfst.pyx0000$^  $^    def reprself$^      return  farwriter at 0xx.formatself.fartype idself              $^  $^    classmethod$^ $^  pyxxdecrefpyxr$^  pyxt0  pyxpyobjectgetattrstrpyxkpsfarwriterat0xx pyxnsformat if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s fartype$^    pyxerr0 0000 pyxl0error$^  $^  pyxt0  pyxconvertpybytesstringtopystdinstringstruct pyxvtabstruct0pywrapfstfarwriter pyxvselfpyxvtabfartypepyxvself 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxt0  pyxpyobjectcalloneargpyxbuiltinid pyobject pyxvself if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxt0  null$^  pyxt0  0$^  if cythonunpackmethods  likelypymethodcheckpyxt0 $^    pyxt0  pymethodgetselfpyxt0$^    if likelypyxt0 $^      pyobject function  pymethodgetfunctionpyxt0$^      pyxincrefpyxt0$^      pyxincreffunction$^      pyxdecrefsetpyxt0 function$^      pyxt0  0$^    $^  $^  if cythonfastpycall$^  if pyfunctioncheckpyxt0 $^    pyobject pyxtemp0  pyxt0 pyxt0 pyxt0$^    pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp0pyxt0 0pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxxdecrefpyxt0 pyxt0  0$^    pyxgotrefpyxt0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxdecrefpyxt0 pyxt0  0$^   else$^  endif$^  if cythonfastpyccall$^  if pyxpyfastcfunctioncheckpyxt0 $^    pyobject pyxtemp0  pyxt0 pyxt0 pyxt0$^    pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp0pyxt0 0pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxxdecrefpyxt0 pyxt0  0$^    pyxgotrefpyxt0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxdecrefpyxt0 pyxt0  0$^   else$^  endif$^  $^    pyxt0  pytuplenew0pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    if pyxt0 $^      pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^    $^    pyxgiverefpyxt0$^    pytuplesetitempyxt0 0pyxt0 pyxt0$^    pyxgiverefpyxt0$^    pytuplesetitempyxt0 0pyxt0 pyxt0$^    pyxt0  0$^    pyxt0  0$^    pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxdecrefpyxt0 pyxt0  0$^  $^  pyxdecrefpyxt0 pyxt0  0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   pywrapfst.pyx0000$^          cannot construct .formatself.class.name$^  $^    def reprself              $^      return  farwriter at 0xx.formatself.fartype idself$^  $^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.farwriter.repr pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^  $^    classmethod$^    def createcls filename arctypebstandard fartypebdefault              $^      $^      farwriter.$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst0farwriter0createpyobject pyxvcls pyobject pyxargs pyobject pyxkwds proto$^static char pyxdoc0pywrapfst0farwriter0create  n    farwriter.nn    creates a farwriter object.nn    this class method creates a farwriter given the desired output locationn    arc type and far type.nn    argsn      filename the string location for the output far files.n      arctype a string indicating the arc type.n      fartype a string indicating the far type one of fst stlistn          sttable sstable default.nn    returnsn      a new farwriter instance.nn    raisesn      fstioerror read failed.n    $^static pyobject pyxpw0pywrapfst0farwriter0createpyobject pyxvcls pyobject pyxargs pyobject pyxkwds $^  pyobject pyxvfilename  0$^  pyobject pyxvarctype  0$^  pyobject pyxvfartype  0$^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextcreate wrapper 0$^  $^    static pyobject pyxpyargnames  pyxnsfilenamepyxnsarctypepyxnsfartype0$^    pyobject values0  000$^    values0  pyobject pyxnbstandard$^    values0  pyobject pyxnbdefault$^    if unlikelypyxkwds $^      pyssizet kwargs$^      const pyssizet posargs  pytuplegetsizepyxargs$^      switch posargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 break$^        default goto pyxl0argtupleerror$^      $^      kwargs  pydictsizepyxkwds$^      switch posargs $^        case  0$^        if likelyvalues0  pyxpydictgetitemstrpyxkwds pyxnsfilename  0 kwargs$^        else goto pyxl0argtupleerror$^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnsarctype$^          if value  values0  value kwargs $^        $^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pyxpydictgetitemstrpyxkwds pyxnsfartype$^          if value  values0  value kwargs $^        $^      $^      if unlikelykwargs  0 $^        if unlikelypyxparseoptionalkeywordspyxkwds pyxpyargnames 0 values posargs create  0 pyxerr0 0000 pyxl0error$^      $^     else $^      switch pytuplegetsizepyxargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        break$^        default goto pyxl0argtupleerror$^      $^    $^    pyxvfilename  values0$^    pyxvarctype  values0$^    pyxvfartype  values0$^  $^  goto pyxl0argumentunpackingdone$^  pyxl0argtupleerror$^  pyxraiseargtupleinvalidcreate 0 0 0 pytuplegetsizepyxargs pyxerr0 0000 pyxl0error$^  pyxl0error$^  pyxaddtracebackpywrapfst.farwriter.create pyxclineno pyxlineno pyxfilename$^  pyxrefnannyfinishcontext$^  return null$^  pyxl0argumentunpackingdone$^  pyxr  pyxpf0pywrapfst0farwriter0createpytypeobjectpyxvcls pyxvfilename pyxvarctype pyxvfartype$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst0farwriter0createcythonunused pytypeobject pyxvcls pyobject pyxvfilename pyobject pyxvarctype pyobject pyxvfartype $^  enum fstfartype pyxvft$^  fstscriptfarwriterclass pyxvtfar$^  struct pyxobj0pywrapfstfarwriter pyxvresult  0$^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  stdstring pyxt0$^  stdstring pyxt0$^  int pyxt0$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextcreate 0$^$^   pywrapfst.pyx0000$^        fstioerror read failed.$^      $^      cdef fst.fartype ft  fst.getfartypetostringfartype              $^      cdef fst.farwriterclass tfar  fst.farwriterclass.create$^          tostringfilename tostringarctype ft$^ $^  pyxt0  pyxf0pywrapfsttostringpyxvfartype null if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^  pyxvft  fstscriptgetfartypepyxt0$^$^   pywrapfst.pyx0000$^      cdef fst.fartype ft  fst.getfartypetostringfartype$^      cdef fst.farwriterclass tfar  fst.farwriterclass.create$^          tostringfilename tostringarctype ft              $^      if tfar  null$^        raise fstioerroropen failed r.formatfilename$^ $^  pyxt0  pyxf0pywrapfsttostringpyxvfilename null if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^  pyxt0  pyxf0pywrapfsttostringpyxvarctype null if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^      $^      cdef fst.fartype ft  fst.getfartypetostringfartype$^      cdef fst.farwriterclass tfar  fst.farwriterclass.create              $^          tostringfilename tostringarctype ft$^      if tfar  null$^ $^  pyxvtfar  fstscriptfarwriterclasscreatepyxt0 pyxt0 pyxvft$^$^   pywrapfst.pyx0000$^      cdef fst.farwriterclass tfar  fst.farwriterclass.create$^          tostringfilename tostringarctype ft$^      if tfar  null              $^        raise fstioerroropen failed r.formatfilename$^      cdef farwriter result  farwriter.newfarwriter$^ $^  pyxt0  pyxvtfar  null  0$^  if unlikelypyxt0 $^$^     pywrapfst.pyx0000$^          tostringfilename tostringarctype ft$^      if tfar  null$^        raise fstioerroropen failed r.formatfilename              $^      cdef farwriter result  farwriter.newfarwriter$^      result.writer.resettfar$^ $^    pyxt0  pyxgetmoduleglobalnamepyxnsfstioerror if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  pyxpyobjectgetattrstrpyxkpsopenfailedr pyxnsformat if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  null$^    if cythonunpackmethods  likelypymethodcheckpyxt0 $^      pyxt0  pymethodgetselfpyxt0$^      if likelypyxt0 $^        pyobject function  pymethodgetfunctionpyxt0$^        pyxincrefpyxt0$^        pyxincreffunction$^        pyxdecrefsetpyxt0 function$^      $^    $^    if pyxt0 $^      pyxt0  pyxpyobjectcalloneargpyxt0 pyxvfilename if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxgotrefpyxt0$^     else $^      if cythonfastpycall$^      if pyfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxvfilename$^        pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^       else$^      endif$^      if cythonfastpyccall$^      if pyxpyfastcfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxvfilename$^        pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^       else$^      endif$^      $^        pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxgotrefpyxt0$^        pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^        pyxincrefpyxvfilename$^        pyxgiverefpyxvfilename$^        pytuplesetitempyxt0 00 pyxvfilename$^        pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^      $^    $^    pyxdecrefpyxt0 pyxt0  0$^    pyxt0  null$^    if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^      pyxt0  pymethodgetselfpyxt0$^      if likelypyxt0 $^        pyobject function  pymethodgetfunctionpyxt0$^        pyxincrefpyxt0$^        pyxincreffunction$^        pyxdecrefsetpyxt0 function$^      $^    $^    if pyxt0 $^      pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxgotrefpyxt0$^     else $^      if cythonfastpycall$^      if pyfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxt0$^        pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^       else$^      endif$^      if cythonfastpyccall$^      if pyxpyfastcfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxt0$^        pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^       else$^      endif$^      $^        pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxgotrefpyxt0$^        pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^        pyxgiverefpyxt0$^        pytuplesetitempyxt0 00 pyxt0$^        pyxt0  0$^        pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^      $^    $^    pyxdecrefpyxt0 pyxt0  0$^    pyxraisepyxt0 0 0 0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxerr0 0000 pyxl0error$^$^     pywrapfst.pyx0000$^      cdef fst.farwriterclass tfar  fst.farwriterclass.create$^          tostringfilename tostringarctype ft$^      if tfar  null              $^        raise fstioerroropen failed r.formatfilename$^      cdef farwriter result  farwriter.newfarwriter$^ $^  $^$^   pywrapfst.pyx0000$^      if tfar  null$^        raise fstioerroropen failed r.formatfilename$^      cdef farwriter result  farwriter.newfarwriter              $^      result.writer.resettfar$^      return result$^ $^  pyxt0  pyobject pyxtpnew0pywrapfstfarwriterpytypeobject pyxptype0pywrapfstfarwriter pyxemptytuple null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyobject pyxt0$^  pyxvresult  struct pyxobj0pywrapfstfarwriter pyxt0$^  pyxt0  0$^$^   pywrapfst.pyx0000$^        raise fstioerroropen failed r.formatfilename$^      cdef farwriter result  farwriter.newfarwriter$^      result.writer.resettfar              $^      return result$^  $^ $^  if unlikelypyobject pyxvresult  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s writer$^    pyxerr0 0000 pyxl0error$^  $^  pyxvresultwriter.resetpyxvtfar$^$^   pywrapfst.pyx0000$^      cdef farwriter result  farwriter.newfarwriter$^      result.writer.resettfar$^      return result              $^  $^     nb invoking this method may be dangerous calling any other method on the$^ $^  pyxxdecrefpyxr$^  pyxincrefpyobject pyxvresult$^  pyxr  pyobject pyxvresult$^  goto pyxl0$^$^   pywrapfst.pyx0000$^  $^    classmethod$^    def createcls filename arctypebstandard fartypebdefault              $^      $^      farwriter.$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.farwriter.create pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxdecrefpyobject pyxvresult$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^     nb invoking this method may be dangerous calling any other method on the$^     instance after this is invoked may result in a null dereference.$^    cdef void closeself              $^      self.writer.reset$^  $^ $^$^static void pyxf0pywrapfst0farwriterclosestruct pyxobj0pywrapfstfarwriter pyxvself $^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextclose 0$^$^   pywrapfst.pyx0000$^     instance after this is invoked may result in a null dereference.$^    cdef void closeself$^      self.writer.reset              $^  $^    cpdef void addself key fst ifst except $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s writer$^    pyxerr0 0000 pyxl0error$^  $^  pyxvselfwriter.reset$^$^   pywrapfst.pyx0000$^     nb invoking this method may be dangerous calling any other method on the$^     instance after this is invoked may result in a null dereference.$^    cdef void closeself              $^      self.writer.reset$^  $^ $^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxwriteunraisablepywrapfst.farwriter.close pyxclineno pyxlineno pyxfilename 0 0$^  pyxl0$^  pyxrefnannyfinishcontext$^$^$^ pywrapfst.pyx0000$^      self.writer.reset$^  $^    cpdef void addself key fst ifst except               $^      $^      addself key ifst$^ $^$^static pyobject pyxpw0pywrapfst0farwriter0addpyobject pyxvself pyobject pyxargs pyobject pyxkwds proto$^static void pyxf0pywrapfst0farwriteraddstruct pyxobj0pywrapfstfarwriter pyxvself pyobject pyxvkey struct pyxobj0pywrapfstfst pyxvifst int pyxskipdispatch $^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  int pyxt0$^  pyobject pyxt0  null$^  stdstring pyxt0$^  int pyxt0$^  pyxrefnannysetupcontextadd 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnsadd if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst0farwriter0add $^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      pyxt0  0$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^          pyxt0  0$^        $^      $^      if cythonfastpycall$^      if pyfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxvkey pyobject pyxvifst$^        pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp0pyxt0 0pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^       else$^      endif$^      if cythonfastpyccall$^      if pyxpyfastcfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxvkey pyobject pyxvifst$^        pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp0pyxt0 0pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^       else$^      endif$^      $^        pyxt0  pytuplenew0pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxgotrefpyxt0$^        if pyxt0 $^          pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^        $^        pyxincrefpyxvkey$^        pyxgiverefpyxvkey$^        pytuplesetitempyxt0 0pyxt0 pyxvkey$^        pyxincrefpyobject pyxvifst$^        pyxgiverefpyobject pyxvifst$^        pytuplesetitempyxt0 0pyxt0 pyobject pyxvifst$^        pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^      $^      pyxdecrefpyxt0 pyxt0  0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx0000$^       failure here results from passing an fst with a different arc type than$^       used by the far was initialized to use.$^      if not self.writer.get.addtostringkey derefifst.fst              $^        raise fstoperrorincompatible or invalid arc type$^       an error here usually indicates a key out of order.$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s writer$^    pyxerr0 0000 pyxl0error$^  $^  pyxt0  pyxf0pywrapfsttostringpyxvkey null if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^  if unlikelypyobject pyxvifst  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s fst$^    pyxerr0 0000 pyxl0error$^  $^  pyxt0  pyxvselfwriter.getaddpyxt0 pyxvifstfst  0  0$^  if unlikelypyxt0 $^$^     pywrapfst.pyx0000$^       used by the far was initialized to use.$^      if not self.writer.get.addtostringkey derefifst.fst$^        raise fstoperrorincompatible or invalid arc type              $^       an error here usually indicates a key out of order.$^      if self.writer.get.error$^ $^    pyxt0  pyxgetmoduleglobalnamepyxnsfstoperror if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  pyxpyobjectcallpyxt0 pyxtuple00 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxraisepyxt0 0 0 0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxerr0 0000 pyxl0error$^$^     pywrapfst.pyx0000$^       failure here results from passing an fst with a different arc type than$^       used by the far was initialized to use.$^      if not self.writer.get.addtostringkey derefifst.fst              $^        raise fstoperrorincompatible or invalid arc type$^       an error here usually indicates a key out of order.$^ $^  $^$^   pywrapfst.pyx0000$^        raise fstoperrorincompatible or invalid arc type$^       an error here usually indicates a key out of order.$^      if self.writer.get.error              $^        raise fstargerrorkey out of order$^  $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s writer$^    pyxerr0 0000 pyxl0error$^  $^  pyxt0  pyxvselfwriter.geterror  0$^  if unlikelypyxt0 $^$^     pywrapfst.pyx0000$^       an error here usually indicates a key out of order.$^      if self.writer.get.error$^        raise fstargerrorkey out of order              $^  $^    cpdef string arctypeself$^ $^    pyxt0  pyxgetmoduleglobalnamepyxnsfstargerror if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  pyxpyobjectcallpyxt0 pyxtuple00 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxraisepyxt0 0 0 0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxerr0 0000 pyxl0error$^$^     pywrapfst.pyx0000$^        raise fstoperrorincompatible or invalid arc type$^       an error here usually indicates a key out of order.$^      if self.writer.get.error              $^        raise fstargerrorkey out of order$^  $^ $^  $^$^   pywrapfst.pyx0000$^      self.writer.reset$^  $^    cpdef void addself key fst ifst except               $^      $^      addself key ifst$^ $^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.farwriter.add pyxclineno pyxlineno pyxfilename$^  pyxl0$^  pyxrefnannyfinishcontext$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst0farwriter0addpyobject pyxvself pyobject pyxargs pyobject pyxkwds proto$^static char pyxdoc0pywrapfst0farwriter0add  n    addself key ifstnn    adds an fst to the far.nn    this method adds an fst to the far which can be retrieved with then    specified string key.nn    argsn      key the string used to key the input fst.n      ifst the fst to write to the far.nn    raisesn      fstargerror key out of order.n      fstoperror incompatible or invalid arc type.n    $^static pyobject pyxpw0pywrapfst0farwriter0addpyobject pyxvself pyobject pyxargs pyobject pyxkwds $^  pyobject pyxvkey  0$^  struct pyxobj0pywrapfstfst pyxvifst  0$^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextadd wrapper 0$^  $^    static pyobject pyxpyargnames  pyxnskeypyxnsifst0$^    pyobject values0  00$^    if unlikelypyxkwds $^      pyssizet kwargs$^      const pyssizet posargs  pytuplegetsizepyxargs$^      switch posargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 break$^        default goto pyxl0argtupleerror$^      $^      kwargs  pydictsizepyxkwds$^      switch posargs $^        case  0$^        if likelyvalues0  pyxpydictgetitemstrpyxkwds pyxnskey  0 kwargs$^        else goto pyxl0argtupleerror$^        cythonfallthrough$^        case  0$^        if likelyvalues0  pyxpydictgetitemstrpyxkwds pyxnsifst  0 kwargs$^        else $^          pyxraiseargtupleinvalidadd 0 0 0 0 pyxerr0 0000 pyxl0error$^        $^      $^      if unlikelykwargs  0 $^        if unlikelypyxparseoptionalkeywordspyxkwds pyxpyargnames 0 values posargs add  0 pyxerr0 0000 pyxl0error$^      $^     else if pytuplegetsizepyxargs  0 $^      goto pyxl0argtupleerror$^     else $^      values0  pytuplegetitempyxargs 0$^      values0  pytuplegetitempyxargs 0$^    $^    pyxvkey  values0$^    pyxvifst  struct pyxobj0pywrapfstfst values0$^  $^  goto pyxl0argumentunpackingdone$^  pyxl0argtupleerror$^  pyxraiseargtupleinvalidadd 0 0 0 pytuplegetsizepyxargs pyxerr0 0000 pyxl0error$^  pyxl0error$^  pyxaddtracebackpywrapfst.farwriter.add pyxclineno pyxlineno pyxfilename$^  pyxrefnannyfinishcontext$^  return null$^  pyxl0argumentunpackingdone$^  if unlikelypyxargtypetestpyobject pyxvifst pyxptype0pywrapfstfst 0 ifst 0 pyxerr0 0000 pyxl0error$^  pyxr  pyxpf0pywrapfst0farwriter0addstruct pyxobj0pywrapfstfarwriter pyxvself pyxvkey pyxvifst$^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxr  null$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst0farwriter0addstruct pyxobj0pywrapfstfarwriter pyxvself pyobject pyxvkey struct pyxobj0pywrapfstfst pyxvifst $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextadd 0$^  pyxxdecrefpyxr$^  pyxf0pywrapfst0farwriteraddpyxvself pyxvkey pyxvifst 0 if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^  pyxt0  pyxvoidtononenull if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.farwriter.add pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^        raise fstargerrorkey out of order$^  $^    cpdef string arctypeself              $^      $^      arctypeself$^ $^$^static pyobject pyxpw0pywrapfst0farwriter0arctypepyobject pyxvself cythonunused pyobject unused proto$^static stdstring pyxf0pywrapfst0farwriterarctypestruct pyxobj0pywrapfstfarwriter pyxvself int pyxskipdispatch $^  stdstring pyxr$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  stdstring pyxt0$^  pyxrefnannysetupcontextarctype 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnsarctype if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst0farwriter0arctype $^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxdecrefpyxt0 pyxt0  0$^       else $^        pyxt0  pyxpyobjectcallnoargpyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      $^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxt0  pyxconvertstringfrompystdinstringpyxt0 if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxr  pyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx0000$^      returns a string indicating the arc type.$^      $^      return self.writer.get.arctype              $^  $^    cpdef bool errorself$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s writer$^    pyxerr0 0000 pyxl0error$^  $^  pyxr  pyxvselfwriter.getarctype$^  goto pyxl0$^$^   pywrapfst.pyx0000$^        raise fstargerrorkey out of order$^  $^    cpdef string arctypeself              $^      $^      arctypeself$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxwriteunraisablepywrapfst.farwriter.arctype pyxclineno pyxlineno pyxfilename 0 0$^  pyxpretendtoinitializepyxr$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst0farwriter0arctypepyobject pyxvself cythonunused pyobject unused proto$^static char pyxdoc0pywrapfst0farwriter0arctype  n    arctypeselfnn    returns a string indicating the arc type.n    $^static pyobject pyxpw0pywrapfst0farwriter0arctypepyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextarctype wrapper 0$^  pyxr  pyxpf0pywrapfst0farwriter0arctypestruct pyxobj0pywrapfstfarwriter pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst0farwriter0arctypestruct pyxobj0pywrapfstfarwriter pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextarctype 0$^  pyxxdecrefpyxr$^  pyxt0  pyxconvertpybytesstringtopystdinstringpyxf0pywrapfst0farwriterarctypepyxvself 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.farwriter.arctype pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return self.writer.get.arctype$^  $^    cpdef bool errorself              $^      $^      errorself$^ $^$^static pyobject pyxpw0pywrapfst0farwriter00errorpyobject pyxvself cythonunused pyobject unused proto$^static bool pyxf0pywrapfst0farwritererrorstruct pyxobj0pywrapfstfarwriter pyxvself int pyxskipdispatch $^  bool pyxr$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  bool pyxt0$^  pyxrefnannysetupcontexterror 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnserror if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst0farwriter00error $^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxdecrefpyxt0 pyxt0  0$^       else $^        pyxt0  pyxpyobjectcallnoargpyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      $^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxt0  pyxpyobjectistruepyxt0 if unlikelypyxt0  bool0  pyerroccurred pyxerr0 0000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxr  pyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx0000$^        true if the farwriter is in an errorful state false otherwise.$^      $^      return self.writer.get.error              $^  $^    cpdef string fartypeself$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s writer$^    pyxerr0 0000 pyxl0error$^  $^  pyxr  pyxvselfwriter.geterror$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      return self.writer.get.arctype$^  $^    cpdef bool errorself              $^      $^      errorself$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxwriteunraisablepywrapfst.farwriter.error pyxclineno pyxlineno pyxfilename 0 0$^  pyxr  0$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst0farwriter00errorpyobject pyxvself cythonunused pyobject unused proto$^static char pyxdoc0pywrapfst0farwriter00error  n    errorselfnn    indicates whether the farwriter has encountered an error.nn    returnsn      true if the farwriter is in an errorful state false otherwise.n    $^static pyobject pyxpw0pywrapfst0farwriter00errorpyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontexterror wrapper 0$^  pyxr  pyxpf0pywrapfst0farwriter00errorstruct pyxobj0pywrapfstfarwriter pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst0farwriter00errorstruct pyxobj0pywrapfstfarwriter pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontexterror 0$^  pyxxdecrefpyxr$^  pyxt0  pyxpyboolfromlongpyxf0pywrapfst0farwritererrorpyxvself 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.farwriter.error pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return self.writer.get.error$^  $^    cpdef string fartypeself              $^      $^      fartypeself$^ $^$^static pyobject pyxpw0pywrapfst0farwriter00fartypepyobject pyxvself cythonunused pyobject unused proto$^static stdstring pyxf0pywrapfst0farwriterfartypestruct pyxobj0pywrapfstfarwriter pyxvself int pyxskipdispatch $^  stdstring pyxr$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  stdstring pyxt0$^  pyxrefnannysetupcontextfartype 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnsfartype if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst0farwriter00fartype $^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxdecrefpyxt0 pyxt0  0$^       else $^        pyxt0  pyxpyobjectcallnoargpyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      $^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxt0  pyxconvertstringfrompystdinstringpyxt0 if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxr  pyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx0000$^      returns a string indicating the far type.$^      $^      return fst.getfartypestringself.writer.get.type              $^  $^     dictionarylike assignment.$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s writer$^    pyxerr0 0000 pyxl0error$^  $^  pyxr  fstgetfartypestringpyxvselfwriter.gettype$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      return self.writer.get.error$^  $^    cpdef string fartypeself              $^      $^      fartypeself$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxwriteunraisablepywrapfst.farwriter.fartype pyxclineno pyxlineno pyxfilename 0 0$^  pyxpretendtoinitializepyxr$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst0farwriter00fartypepyobject pyxvself cythonunused pyobject unused proto$^static char pyxdoc0pywrapfst0farwriter00fartype  n    fartypeselfnn    returns a string indicating the far type.n    $^static pyobject pyxpw0pywrapfst0farwriter00fartypepyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextfartype wrapper 0$^  pyxr  pyxpf0pywrapfst0farwriter00fartypestruct pyxobj0pywrapfstfarwriter pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst0farwriter00fartypestruct pyxobj0pywrapfstfarwriter pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextfartype 0$^  pyxxdecrefpyxr$^  pyxt0  pyxconvertpybytesstringtopystdinstringpyxf0pywrapfst0farwriterfartypepyxvself 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.farwriter.fartype pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^  $^     dictionarylike assignment.$^    def setitemself key fst fst              $^      self.addkey fst$^  $^ $^$^ python wrapper $^static int pyxpw0pywrapfst0farwriter00setitempyobject pyxvself pyobject pyxvkey pyobject pyxvfst proto$^static int pyxpw0pywrapfst0farwriter00setitempyobject pyxvself pyobject pyxvkey pyobject pyxvfst $^  int pyxr$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextsetitem wrapper 0$^  if unlikelypyxargtypetestpyobject pyxvfst pyxptype0pywrapfstfst 0 fst 0 pyxerr0 0000 pyxl0error$^  pyxr  pyxpf0pywrapfst0farwriter00setitemstruct pyxobj0pywrapfstfarwriter pyxvself pyobject pyxvkey struct pyxobj0pywrapfstfst pyxvfst$^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxr  0$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static int pyxpf0pywrapfst0farwriter00setitemstruct pyxobj0pywrapfstfarwriter pyxvself pyobject pyxvkey struct pyxobj0pywrapfstfst pyxvfst $^  int pyxr$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextsetitem 0$^$^   pywrapfst.pyx0000$^     dictionarylike assignment.$^    def setitemself key fst fst$^      self.addkey fst              $^  $^  $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s add$^    pyxerr0 0000 pyxl0error$^  $^  struct pyxvtabstruct0pywrapfstfarwriter pyxvselfpyxvtabaddpyxvself pyxvkey pyxvfst 0 if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^  $^     dictionarylike assignment.$^    def setitemself key fst fst              $^      self.addkey fst$^  $^ $^$^   function exit code $^  pyxr  0$^  goto pyxl0$^  pyxl0error$^  pyxaddtracebackpywrapfst.farwriter.setitem pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ tree fragment0$^  def reducecythonself              $^      raise typeerrorself.writer cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst0farwriter00reducecythonpyobject pyxvself cythonunused pyobject unused proto$^static pyobject pyxpw0pywrapfst0farwriter00reducecythonpyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextreducecython wrapper 0$^  pyxr  pyxpf0pywrapfst0farwriter00reducecythonstruct pyxobj0pywrapfstfarwriter pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst0farwriter00reducecythoncythonunused struct pyxobj0pywrapfstfarwriter pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextreducecython 0$^$^   tree fragment0$^  def reducecythonself$^      raise typeerrorself.writer cannot be converted to a python object for pickling              $^  def setstatecythonself pyxstate$^      raise typeerrorself.writer cannot be converted to a python object for pickling$^ $^  pyxt0  pyxpyobjectcallpyxbuiltintypeerror pyxtuple00 null if unlikelypyxt0 pyxerr0 0 pyxl0error$^  pyxgotrefpyxt0$^  pyxraisepyxt0 0 0 0$^  pyxdecrefpyxt0 pyxt0  0$^  pyxerr0 0 pyxl0error$^$^   tree fragment0$^  def reducecythonself              $^      raise typeerrorself.writer cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.farwriter.reducecython pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ tree fragment0$^  def reducecythonself$^      raise typeerrorself.writer cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate              $^      raise typeerrorself.writer cannot be converted to a python object for pickling$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst0farwriter00setstatecythonpyobject pyxvself pyobject pyxvpyxstate proto$^static pyobject pyxpw0pywrapfst0farwriter00setstatecythonpyobject pyxvself pyobject pyxvpyxstate $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextsetstatecython wrapper 0$^  pyxr  pyxpf0pywrapfst0farwriter00setstatecythonstruct pyxobj0pywrapfstfarwriter pyxvself pyobject pyxvpyxstate$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst0farwriter00setstatecythoncythonunused struct pyxobj0pywrapfstfarwriter pyxvself cythonunused pyobject pyxvpyxstate $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextsetstatecython 0$^$^   tree fragment0$^      raise typeerrorself.writer cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate$^      raise typeerrorself.writer cannot be converted to a python object for pickling              $^ $^  pyxt0  pyxpyobjectcallpyxbuiltintypeerror pyxtuple00 null if unlikelypyxt0 pyxerr0 0 pyxl0error$^  pyxgotrefpyxt0$^  pyxraisepyxt0 0 0 0$^  pyxdecrefpyxt0 pyxt0  0$^  pyxerr0 0 pyxl0error$^$^   tree fragment0$^  def reducecythonself$^      raise typeerrorself.writer cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate              $^      raise typeerrorself.writer cannot be converted to a python object for pickling$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.farwriter.setstatecython pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^  $^  atexit.register$^  def resetfsterrorfatal              $^    fst.flagsfsterrorfatal  fsterrorfatalold$^  $^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00resetfsterrorfatalpyobject pyxself cythonunused pyobject unused proto$^static pymethoddef pyxmdef0pywrapfst00resetfsterrorfatal  resetfsterrorfatal pycfunctionpyxpw0pywrapfst00resetfsterrorfatal methnoargs 0$^static pyobject pyxpw0pywrapfst00resetfsterrorfatalpyobject pyxself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextresetfsterrorfatal wrapper 0$^  pyxr  pyxpf0pywrapfst00resetfsterrorfatalpyxself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00resetfsterrorfatalcythonunused pyobject pyxself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  bool pyxt0$^  pyxrefnannysetupcontextresetfsterrorfatal 0$^$^   pywrapfst.pyx0000$^  atexit.register$^  def resetfsterrorfatal$^    fst.flagsfsterrorfatal  fsterrorfatalold              $^  $^ $^  pyxt0  pyxgetmoduleglobalnamepyxnsfsterrorfatalold if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxt0  pyxpyobjectistruepyxt0 if unlikelypyxt0  bool0  pyerroccurred pyxerr0 0000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^  flagsfsterrorfatal  pyxt0$^$^   pywrapfst.pyx0000$^  $^  atexit.register$^  def resetfsterrorfatal              $^    fst.flagsfsterrorfatal  fsterrorfatalold$^  $^ $^$^   function exit code $^  pyxr  pynone pyxincrefpynone$^  goto pyxl0$^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.resetfsterrorfatal pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ string.frompy00$^  $^  cnamepyxconvertstringfrompystdinstring$^  cdef string pyxconvertstringfrompystdinstringobject o except               $^      cdef pyssizet length$^      cdef const char data  pyxpyobjectasstringandsizeo length$^ $^$^static stdstring pyxconvertstringfrompystdinstringpyobject pyxvo $^  pyssizet pyxvlength$^  char const pyxvdata$^  stdstring pyxr$^  pyxrefnannydeclarations$^  char const pyxt0$^  pyxrefnannysetupcontextpyxconvertstringfrompystdinstring 0$^$^   string.frompy00$^  cdef string pyxconvertstringfrompystdinstringobject o except $^      cdef pyssizet length$^      cdef const char data  pyxpyobjectasstringandsizeo length              $^      return stringdata length$^  $^ $^  pyxt0  pyxpyobjectasstringandsizepyxvo pyxvlength if unlikelypyxt0  char const null pyxerr0 00 pyxl0error$^  pyxvdata  pyxt0$^$^   string.frompy00$^      cdef pyssizet length$^      cdef const char data  pyxpyobjectasstringandsizeo length$^      return stringdata length              $^  $^  $^ $^  pyxr  stdstringpyxvdata pyxvlength$^  goto pyxl0$^$^   string.frompy00$^  $^  cnamepyxconvertstringfrompystdinstring$^  cdef string pyxconvertstringfrompystdinstringobject o except               $^      cdef pyssizet length$^      cdef const char data  pyxpyobjectasstringandsizeo length$^ $^$^   function exit code $^  pyxl0error$^  pyxaddtracebackstring.frompy.pyxconvertstringfrompystdinstring pyxclineno pyxlineno pyxfilename$^  pyxpretendtoinitializepyxr$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ string.topy00$^  $^  cnamepyxconvertpyobjectstringtopystdinstring$^  cdef inline object pyxconvertpyobjectstringtopystdinstringconst string s              $^      return pyxpyobjectfromstringandsizes.data s.size$^  cdef extern from $^ $^$^static cythoninline pyobject pyxconvertpyobjectstringtopystdinstringstdstring const pyxvs $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextpyxconvertpyobjectstringtopystdinstring 0$^$^   string.topy00$^  cnamepyxconvertpyobjectstringtopystdinstring$^  cdef inline object pyxconvertpyobjectstringtopystdinstringconst string s$^      return pyxpyobjectfromstringandsizes.data s.size              $^  cdef extern from $^      cdef object pyxpyunicodefromstringandsizeconst char sizet$^ $^  pyxxdecrefpyxr$^  pyxt0  pyxpyobjectfromstringandsizepyxvs.data pyxvs.size if unlikelypyxt0 pyxerr0 00 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   string.topy00$^  $^  cnamepyxconvertpyobjectstringtopystdinstring$^  cdef inline object pyxconvertpyobjectstringtopystdinstringconst string s              $^      return pyxpyobjectfromstringandsizes.data s.size$^  cdef extern from $^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackstring.topy.pyxconvertpyobjectstringtopystdinstring pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ string.topy00$^  $^  cnamepyxconvertpyunicodestringtopystdinstring$^  cdef inline object pyxconvertpyunicodestringtopystdinstringconst string s              $^      return pyxpyunicodefromstringandsizes.data s.size$^  cdef extern from $^ $^$^static cythoninline pyobject pyxconvertpyunicodestringtopystdinstringstdstring const pyxvs $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextpyxconvertpyunicodestringtopystdinstring 0$^$^   string.topy00$^  cnamepyxconvertpyunicodestringtopystdinstring$^  cdef inline object pyxconvertpyunicodestringtopystdinstringconst string s$^      return pyxpyunicodefromstringandsizes.data s.size              $^  cdef extern from $^      cdef object pyxpystrfromstringandsizeconst char sizet$^ $^  pyxxdecrefpyxr$^  pyxt0  pyxpyunicodefromstringandsizepyxvs.data pyxvs.size if unlikelypyxt0 pyxerr0 00 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   string.topy00$^  $^  cnamepyxconvertpyunicodestringtopystdinstring$^  cdef inline object pyxconvertpyunicodestringtopystdinstringconst string s              $^      return pyxpyunicodefromstringandsizes.data s.size$^  cdef extern from $^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackstring.topy.pyxconvertpyunicodestringtopystdinstring pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ string.topy00$^  $^  cnamepyxconvertpystrstringtopystdinstring$^  cdef inline object pyxconvertpystrstringtopystdinstringconst string s              $^      return pyxpystrfromstringandsizes.data s.size$^  cdef extern from $^ $^$^static cythoninline pyobject pyxconvertpystrstringtopystdinstringstdstring const pyxvs $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextpyxconvertpystrstringtopystdinstring 0$^$^   string.topy00$^  cnamepyxconvertpystrstringtopystdinstring$^  cdef inline object pyxconvertpystrstringtopystdinstringconst string s$^      return pyxpystrfromstringandsizes.data s.size              $^  cdef extern from $^      cdef object pyxpybytesfromstringandsizeconst char sizet$^ $^  pyxxdecrefpyxr$^  pyxt0  pyxpystrfromstringandsizepyxvs.data pyxvs.size if unlikelypyxt0 pyxerr0 00 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   string.topy00$^  $^  cnamepyxconvertpystrstringtopystdinstring$^  cdef inline object pyxconvertpystrstringtopystdinstringconst string s              $^      return pyxpystrfromstringandsizes.data s.size$^  cdef extern from $^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackstring.topy.pyxconvertpystrstringtopystdinstring pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ string.topy00$^  $^  cnamepyxconvertpybytesstringtopystdinstring$^  cdef inline object pyxconvertpybytesstringtopystdinstringconst string s              $^      return pyxpybytesfromstringandsizes.data s.size$^  cdef extern from $^ $^$^static cythoninline pyobject pyxconvertpybytesstringtopystdinstringstdstring const pyxvs $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextpyxconvertpybytesstringtopystdinstring 0$^$^   string.topy00$^  cnamepyxconvertpybytesstringtopystdinstring$^  cdef inline object pyxconvertpybytesstringtopystdinstringconst string s$^      return pyxpybytesfromstringandsizes.data s.size              $^  cdef extern from $^      cdef object pyxpybytearrayfromstringandsizeconst char sizet$^ $^  pyxxdecrefpyxr$^  pyxt0  pyxpybytesfromstringandsizepyxvs.data pyxvs.size if unlikelypyxt0 pyxerr0 00 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   string.topy00$^  $^  cnamepyxconvertpybytesstringtopystdinstring$^  cdef inline object pyxconvertpybytesstringtopystdinstringconst string s              $^      return pyxpybytesfromstringandsizes.data s.size$^  cdef extern from $^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackstring.topy.pyxconvertpybytesstringtopystdinstring pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ string.topy00$^  $^  cnamepyxconvertpybytearraystringtopystdinstring$^  cdef inline object pyxconvertpybytearraystringtopystdinstringconst string s              $^      return pyxpybytearrayfromstringandsizes.data s.size$^  $^ $^$^static cythoninline pyobject pyxconvertpybytearraystringtopystdinstringstdstring const pyxvs $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextpyxconvertpybytearraystringtopystdinstring 0$^$^   string.topy00$^  cnamepyxconvertpybytearraystringtopystdinstring$^  cdef inline object pyxconvertpybytearraystringtopystdinstringconst string s$^      return pyxpybytearrayfromstringandsizes.data s.size              $^  $^ $^  pyxxdecrefpyxr$^  pyxt0  pyxpybytearrayfromstringandsizepyxvs.data pyxvs.size if unlikelypyxt0 pyxerr0 00 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   string.topy00$^  $^  cnamepyxconvertpybytearraystringtopystdinstring$^  cdef inline object pyxconvertpybytearraystringtopystdinstringconst string s              $^      return pyxpybytearrayfromstringandsizes.data s.size$^  $^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackstring.topy.pyxconvertpybytearraystringtopystdinstring pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ vector.frompy00$^  $^  cnamepyxconvertvectorfrompypyxt00basictypesint00$^  cdef vectorx pyxconvertvectorfrompypyxt00basictypesint00object o except               $^      cdef vectorx v$^      for item in o$^ $^$^static stdvectorpyxt00basictypesint00  pyxconvertvectorfrompypyxt00basictypesint00pyobject pyxvo $^  stdvectorpyxt00basictypesint00  pyxvv$^  pyobject pyxvitem  null$^  stdvectorpyxt00basictypesint00  pyxr$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyssizet pyxt0$^  pyobject pyxt0pyobject $^  pyobject pyxt0  null$^  pyxt00basictypesint00 pyxt0$^  pyxrefnannysetupcontextpyxconvertvectorfrompypyxt00basictypesint00 0$^$^   vector.frompy00$^  cdef vectorx pyxconvertvectorfrompypyxt00basictypesint00object o except $^      cdef vectorx v$^      for item in o              $^          v.pushbackxitem$^      return v$^ $^  if likelypylistcheckexactpyxvo  pytuplecheckexactpyxvo $^    pyxt0  pyxvo pyxincrefpyxt0 pyxt0  0$^    pyxt0  null$^   else $^    pyxt0  0 pyxt0  pyobjectgetiterpyxvo if unlikelypyxt0 pyxerr0 00 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  pytypepyxt0tpiternext if unlikelypyxt0 pyxerr0 00 pyxl0error$^  $^  for  $^    if likelypyxt0 $^      if likelypylistcheckexactpyxt0 $^        if pyxt0  pylistgetsizepyxt0 break$^        if cythonassumesafemacros  cythonavoidborrowedrefs$^        pyxt0  pylistgetitempyxt0 pyxt0 pyxincrefpyxt0 pyxt0 if unlikely0  0 pyxerr0 00 pyxl0error$^        else$^        pyxt0  pysequenceitempyxt0 pyxt0 pyxt0 if unlikelypyxt0 pyxerr0 00 pyxl0error$^        pyxgotrefpyxt0$^        endif$^       else $^        if pyxt0  pytuplegetsizepyxt0 break$^        if cythonassumesafemacros  cythonavoidborrowedrefs$^        pyxt0  pytuplegetitempyxt0 pyxt0 pyxincrefpyxt0 pyxt0 if unlikely0  0 pyxerr0 00 pyxl0error$^        else$^        pyxt0  pysequenceitempyxt0 pyxt0 pyxt0 if unlikelypyxt0 pyxerr0 00 pyxl0error$^        pyxgotrefpyxt0$^        endif$^      $^     else $^      pyxt0  pyxt0pyxt0$^      if unlikelypyxt0 $^        pyobject exctype  pyerroccurred$^        if exctype $^          if likelypyxpyerrgivenexceptionmatchesexctype pyexcstopiteration pyerrclear$^          else pyxerr0 00 pyxl0error$^        $^        break$^      $^      pyxgotrefpyxt0$^    $^    pyxxdecrefsetpyxvitem pyxt0$^    pyxt0  0$^$^     vector.frompy00$^      cdef vectorx v$^      for item in o$^          v.pushbackxitem              $^      return v$^  $^ $^    pyxt0  pyxpyintasint00tpyxvitem if unlikelypyxt0  int00t0  pyerroccurred pyxerr0 00 pyxl0error$^    pyxvv.pushbackpyxt00basictypesint00pyxt0$^$^     vector.frompy00$^  cdef vectorx pyxconvertvectorfrompypyxt00basictypesint00object o except $^      cdef vectorx v$^      for item in o              $^          v.pushbackxitem$^      return v$^ $^  $^  pyxdecrefpyxt0 pyxt0  0$^$^   vector.frompy00$^      for item in o$^          v.pushbackxitem$^      return v              $^  $^  $^ $^  pyxr  pyxvv$^  goto pyxl0$^$^   vector.frompy00$^  $^  cnamepyxconvertvectorfrompypyxt00basictypesint00$^  cdef vectorx pyxconvertvectorfrompypyxt00basictypesint00object o except               $^      cdef vectorx v$^      for item in o$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackvector.frompy.pyxconvertvectorfrompypyxt00basictypesint00 pyxclineno pyxlineno pyxfilename$^  pyxpretendtoinitializepyxr$^  pyxl0$^  pyxxdecrefpyxvitem$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static stdvectorstdstring  pyxconvertvectorfrompystd0a0astringpyobject pyxvo $^  stdvectorstdstring  pyxvv$^  pyobject pyxvitem  null$^  stdvectorstdstring  pyxr$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyssizet pyxt0$^  pyobject pyxt0pyobject $^  pyobject pyxt0  null$^  stdstring pyxt0$^  pyxrefnannysetupcontextpyxconvertvectorfrompystd0a0astring 0$^$^   vector.frompy00$^  cdef vectorx pyxconvertvectorfrompystd0a0astringobject o except $^      cdef vectorx v$^      for item in o              $^          v.pushbackxitem$^      return v$^ $^  if likelypylistcheckexactpyxvo  pytuplecheckexactpyxvo $^    pyxt0  pyxvo pyxincrefpyxt0 pyxt0  0$^    pyxt0  null$^   else $^    pyxt0  0 pyxt0  pyobjectgetiterpyxvo if unlikelypyxt0 pyxerr0 00 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  pytypepyxt0tpiternext if unlikelypyxt0 pyxerr0 00 pyxl0error$^  $^  for  $^    if likelypyxt0 $^      if likelypylistcheckexactpyxt0 $^        if pyxt0  pylistgetsizepyxt0 break$^        if cythonassumesafemacros  cythonavoidborrowedrefs$^        pyxt0  pylistgetitempyxt0 pyxt0 pyxincrefpyxt0 pyxt0 if unlikely0  0 pyxerr0 00 pyxl0error$^        else$^        pyxt0  pysequenceitempyxt0 pyxt0 pyxt0 if unlikelypyxt0 pyxerr0 00 pyxl0error$^        pyxgotrefpyxt0$^        endif$^       else $^        if pyxt0  pytuplegetsizepyxt0 break$^        if cythonassumesafemacros  cythonavoidborrowedrefs$^        pyxt0  pytuplegetitempyxt0 pyxt0 pyxincrefpyxt0 pyxt0 if unlikely0  0 pyxerr0 00 pyxl0error$^        else$^        pyxt0  pysequenceitempyxt0 pyxt0 pyxt0 if unlikelypyxt0 pyxerr0 00 pyxl0error$^        pyxgotrefpyxt0$^        endif$^      $^     else $^      pyxt0  pyxt0pyxt0$^      if unlikelypyxt0 $^        pyobject exctype  pyerroccurred$^        if exctype $^          if likelypyxpyerrgivenexceptionmatchesexctype pyexcstopiteration pyerrclear$^          else pyxerr0 00 pyxl0error$^        $^        break$^      $^      pyxgotrefpyxt0$^    $^    pyxxdecrefsetpyxvitem pyxt0$^    pyxt0  0$^$^     vector.frompy00$^      cdef vectorx v$^      for item in o$^          v.pushbackxitem              $^      return v$^  $^ $^    pyxt0  pyxconvertstringfrompystdinstringpyxvitem if unlikelypyerroccurred pyxerr0 00 pyxl0error$^    pyxvv.pushbackstdstringpyxt0$^$^     vector.frompy00$^  cdef vectorx pyxconvertvectorfrompystd0a0astringobject o except $^      cdef vectorx v$^      for item in o              $^          v.pushbackxitem$^      return v$^ $^  $^  pyxdecrefpyxt0 pyxt0  0$^$^   vector.frompy00$^      for item in o$^          v.pushbackxitem$^      return v              $^  $^  $^ $^  pyxr  pyxvv$^  goto pyxl0$^$^   vector.frompy00$^  $^  cnamepyxconvertvectorfrompystd0a0astring$^  cdef vectorx pyxconvertvectorfrompystd0a0astringobject o except               $^      cdef vectorx v$^      for item in o$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackvector.frompy.pyxconvertvectorfrompystd0a0astring pyxclineno pyxlineno pyxfilename$^  pyxpretendtoinitializepyxr$^  pyxl0$^  pyxxdecrefpyxvitem$^  pyxrefnannyfinishcontext$^  return pyxr$^$^static struct pyxvtabstruct0pywrapfstweight pyxvtable0pywrapfstweight$^$^static pyobject pyxtpnew0pywrapfstweightpytypeobject t cythonunused pyobject a cythonunused pyobject k $^  struct pyxobj0pywrapfstweight p$^  pyobject o$^  if likelyttpflags  pytpflagsisabstract  0 $^    o  ttpalloct 0$^   else $^    o  pyobject  pybaseobjecttype.tpnewt pyxemptytuple 0$^  $^  if unlikelyo return 0$^  p  struct pyxobj0pywrapfstweight o$^  ppyxvtab  pyxvtabptr0pywrapfstweight$^  newvoidpweight stduniqueptrfstscriptweightclass $^  return o$^$^$^static void pyxtpdealloc0pywrapfstweightpyobject o $^  struct pyxobj0pywrapfstweight p  struct pyxobj0pywrapfstweight o$^  if cythonusetpfinalize$^  if unlikelypytypehasfeaturepytypeo pytpflagshavefinalize  pytypeotpfinalize  pytypeisgcpytypeo  pygcfinalizedo $^    if pyobjectcallfinalizerfromdealloco return$^  $^  endif$^  pyxcalldestructorpweight$^  pytypeotpfreeo$^$^$^static pyobject pyxtprichcompare0pywrapfstweightpyobject o0 pyobject o0 int op $^  switch op $^    case pyeq $^      return pyxpw0pywrapfst0weight00eqo0 o0$^    $^    case pyne $^      return pyxpw0pywrapfst0weight00neo0 o0$^    $^    default $^      return pyxnewrefpynotimplemented$^    $^  $^$^$^static pymethoddef pyxmethods0pywrapfstweight  $^  copy pycfunctionpyxpw0pywrapfst0weight0copy methnoargs pyxdoc0pywrapfst0weight0copy$^  zero pycfunctionpyxpw0pywrapfst0weight00zero metho pyxdoc0pywrapfst0weight00zero$^  one pycfunctionpyxpw0pywrapfst0weight00one metho pyxdoc0pywrapfst0weight00one$^  noweight pycfunctionpyxpw0pywrapfst0weight00noweight metho pyxdoc0pywrapfst0weight00noweight$^  tostring pycfunctionpyxpw0pywrapfst0weight00tostring methnoargs 0$^  type pycfunctionpyxpw0pywrapfst0weight00type methnoargs pyxdoc0pywrapfst0weight00type$^  reducecython pycfunctionpyxpw0pywrapfst0weight00reducecython methnoargs 0$^  setstatecython pycfunctionpyxpw0pywrapfst0weight00setstatecython metho 0$^  0 0 0 0$^$^$^static pynumbermethods pyxtpasnumberweight  $^  0 nbadd$^  0 nbsubtract$^  0 nbmultiply$^  if pymajorversion  0  cythoncompilinginpypy  pyversionhex  0x00000000$^  0 nbdivide$^  endif$^  0 nbremainder$^  0 nbdivmod$^  0 nbpower$^  0 nbnegative$^  0 nbpositive$^  0 nbabsolute$^  0 nbnonzero$^  0 nbinvert$^  0 nblshift$^  0 nbrshift$^  0 nband$^  0 nbxor$^  0 nbor$^  if pymajorversion  0  cythoncompilinginpypy  pyversionhex  0x00000000$^  0 nbcoerce$^  endif$^  0 nbint$^  if pymajorversion  0$^  0 nblong$^  else$^  0 reserved$^  endif$^  pyxpw0pywrapfst0weight0float nbfloat$^  if pymajorversion  0  cythoncompilinginpypy  pyversionhex  0x00000000$^  0 nboct$^  endif$^  if pymajorversion  0  cythoncompilinginpypy  pyversionhex  0x00000000$^  0 nbhex$^  endif$^  0 nbinplaceadd$^  0 nbinplacesubtract$^  0 nbinplacemultiply$^  if pymajorversion  0  cythoncompilinginpypy  pyversionhex  0x00000000$^  0 nbinplacedivide$^  endif$^  0 nbinplaceremainder$^  0 nbinplacepower$^  0 nbinplacelshift$^  0 nbinplacershift$^  0 nbinplaceand$^  0 nbinplacexor$^  0 nbinplaceor$^  0 nbfloordivide$^  0 nbtruedivide$^  0 nbinplacefloordivide$^  0 nbinplacetruedivide$^  0 nbindex$^  if pyversionhex  0x00000000$^  0 nbmatrixmultiply$^  endif$^  if pyversionhex  0x00000000$^  0 nbinplacematrixmultiply$^  endif$^$^$^static pytypeobject pyxtype0pywrapfstweight  $^  pyvarobjectheadinit0 0$^  pywrapfst.weight tpname$^  sizeofstruct pyxobj0pywrapfstweight tpbasicsize$^  0 tpitemsize$^  pyxtpdealloc0pywrapfstweight tpdealloc$^  0 tpprint$^  0 tpgetattr$^  0 tpsetattr$^  if pymajorversion  0$^  0 tpcompare$^  endif$^  if pymajorversion  0$^  0 tpasasync$^  endif$^  pyxpw0pywrapfst0weight0repr tprepr$^  pyxtpasnumberweight tpasnumber$^  0 tpassequence$^  0 tpasmapping$^  0 tphash$^  0 tpcall$^  pyxpw0pywrapfst0weight0str tpstr$^  0 tpgetattro$^  0 tpsetattro$^  0 tpasbuffer$^  pytpflagsdefaultpytpflagshaveversiontagpytpflagschecktypespytpflagshavenewbufferpytpflagsbasetype tpflags$^  n  weightweighttype weightstringnn  fst weight class.nn  this class represents an fst weight. when passed as an argument to an fstn  operation it should have the weight type of the input fsts to saidn  operation.nn  argsn    weighttype a string indicating the weight type.n    weightstring a string indicating the underlying weight.nn  raisesn    fstargerror weight type not found.n    fstbadweighterror invalid weight.n   tpdoc$^  0 tptraverse$^  0 tpclear$^  pyxtprichcompare0pywrapfstweight tprichcompare$^  0 tpweaklistoffset$^  0 tpiter$^  0 tpiternext$^  pyxmethods0pywrapfstweight tpmethods$^  0 tpmembers$^  0 tpgetset$^  0 tpbase$^  0 tpdict$^  0 tpdescrget$^  0 tpdescrset$^  0 tpdictoffset$^  pyxpw0pywrapfst0weight0init tpinit$^  0 tpalloc$^  pyxtpnew0pywrapfstweight tpnew$^  0 tpfree$^  0 tpisgc$^  0 tpbases$^  0 tpmro$^  0 tpcache$^  0 tpsubclasses$^  0 tpweaklist$^  0 tpdel$^  0 tpversiontag$^  if pyversionhex  0x000000a0$^  0 tpfinalize$^  endif$^$^static struct pyxvtabstruct0pywrapfstsymboltable pyxvtable0pywrapfstsymboltable$^$^static pyobject pyxtpnew0pywrapfstsymboltablepytypeobject t cythonunused pyobject a cythonunused pyobject k $^  struct pyxobj0pywrapfstsymboltable p$^  pyobject o$^  if likelyttpflags  pytpflagsisabstract  0 $^    o  ttpalloct 0$^   else $^    o  pyobject  pybaseobjecttype.tpnewt pyxemptytuple 0$^  $^  if unlikelyo return 0$^  p  struct pyxobj0pywrapfstsymboltable o$^  ppyxvtab  pyxvtabptr0pywrapfstsymboltable$^  return o$^$^$^static void pyxtpdealloc0pywrapfstsymboltablepyobject o $^  if cythonusetpfinalize$^  if unlikelypytypehasfeaturepytypeo pytpflagshavefinalize  pytypeotpfinalize  pytypeisgcpytypeo  pygcfinalizedo $^    if pyobjectcallfinalizerfromdealloco return$^  $^  endif$^  pytypeotpfreeo$^$^$^static pymethoddef pyxmethods0pywrapfstsymboltable  $^  availablekey pycfunctionpyxpw0pywrapfst00symboltable0availablekey methnoargs pyxdoc0pywrapfst00symboltable0availablekey$^  checksum pycfunctionpyxpw0pywrapfst00symboltable0checksum methnoargs pyxdoc0pywrapfst00symboltable0checksum$^  copy pycfunctionpyxpw0pywrapfst00symboltable0copy methnoargs pyxdoc0pywrapfst00symboltable0copy$^  find pycfunctionpyxpw0pywrapfst00symboltable00find metho pyxdoc0pywrapfst00symboltable00find$^  getnthkey pycfunctionpyxpw0pywrapfst00symboltable00getnthkey metho pyxdoc0pywrapfst00symboltable00getnthkey$^  labeledchecksum pycfunctionpyxpw0pywrapfst00symboltable00labeledchecksum methnoargs pyxdoc0pywrapfst00symboltable00labeledchecksum$^  member pycfunctionpyxpw0pywrapfst00symboltable00member metho pyxdoc0pywrapfst00symboltable00member$^  name pycfunctionpyxpw0pywrapfst00symboltable00name methnoargs pyxdoc0pywrapfst00symboltable00name$^  numsymbols pycfunctionpyxpw0pywrapfst00symboltable00numsymbols methnoargs pyxdoc0pywrapfst00symboltable00numsymbols$^  write pycfunctionpyxpw0pywrapfst00symboltable00write metho pyxdoc0pywrapfst00symboltable00write$^  writetext pycfunctionpyxpw0pywrapfst00symboltable00writetext metho pyxdoc0pywrapfst00symboltable00writetext$^  reducecython pycfunctionpyxpw0pywrapfst00symboltable00reducecython methnoargs 0$^  setstatecython pycfunctionpyxpw0pywrapfst00symboltable00setstatecython metho 0$^  0 0 0 0$^$^$^static pysequencemethods pyxtpassequencesymboltable  $^  0 sqlength$^  0 sqconcat$^  0 sqrepeat$^  0 sqitem$^  0 sqslice$^  0 sqassitem$^  0 sqassslice$^  pyxpw0pywrapfst00symboltable00contains sqcontains$^  0 sqinplaceconcat$^  0 sqinplacerepeat$^$^$^static pytypeobject pyxtype0pywrapfstsymboltable  $^  pyvarobjectheadinit0 0$^  pywrapfst.symboltable tpname$^  sizeofstruct pyxobj0pywrapfstsymboltable tpbasicsize$^  0 tpitemsize$^  pyxtpdealloc0pywrapfstsymboltable tpdealloc$^  0 tpprint$^  0 tpgetattr$^  0 tpsetattr$^  if pymajorversion  0$^  0 tpcompare$^  endif$^  if pymajorversion  0$^  0 tpasasync$^  endif$^  0 tprepr$^  0 tpasnumber$^  pyxtpassequencesymboltable tpassequence$^  0 tpasmapping$^  0 tphash$^  0 tpcall$^  0 tpstr$^  0 tpgetattro$^  0 tpsetattro$^  0 tpasbuffer$^  pytpflagsdefaultpytpflagshaveversiontagpytpflagschecktypespytpflagshavenewbufferpytpflagsbasetype tpflags$^  n  no constructor.nn  base class for the symbol table hierarchy.nn  this class is the base class for symboltable. it has a deleted constructorn  and implementations for the const methods of the wrapped symboltable.n   tpdoc$^  0 tptraverse$^  0 tpclear$^  0 tprichcompare$^  0 tpweaklistoffset$^  pyxpw0pywrapfst00symboltable0iter tpiter$^  0 tpiternext$^  pyxmethods0pywrapfstsymboltable tpmethods$^  0 tpmembers$^  0 tpgetset$^  0 tpbase$^  0 tpdict$^  0 tpdescrget$^  0 tpdescrset$^  0 tpdictoffset$^  pyxpw0pywrapfst00symboltable0init tpinit$^  0 tpalloc$^  pyxtpnew0pywrapfstsymboltable tpnew$^  0 tpfree$^  0 tpisgc$^  0 tpbases$^  0 tpmro$^  0 tpcache$^  0 tpsubclasses$^  0 tpweaklist$^  0 tpdel$^  0 tpversiontag$^  if pyversionhex  0x000000a0$^  0 tpfinalize$^  endif$^$^static struct pyxvtabstruct0pywrapfstencodemappersymboltable pyxvtable0pywrapfstencodemappersymboltable$^$^static pyobject pyxtpnew0pywrapfstencodemappersymboltablepytypeobject t pyobject a pyobject k $^  struct pyxobj0pywrapfstencodemappersymboltable p$^  pyobject o  pyxtpnew0pywrapfstsymboltablet a k$^  if unlikelyo return 0$^  p  struct pyxobj0pywrapfstencodemappersymboltable o$^  ppyxbase.pyxvtab  struct pyxvtabstruct0pywrapfstsymboltablepyxvtabptr0pywrapfstencodemappersymboltable$^  newvoidpencoder stdsharedptrfstscriptencodemapperclass $^  return o$^$^$^static void pyxtpdealloc0pywrapfstencodemappersymboltablepyobject o $^  struct pyxobj0pywrapfstencodemappersymboltable p  struct pyxobj0pywrapfstencodemappersymboltable o$^  if cythonusetpfinalize$^  if unlikelypytypehasfeaturepytypeo pytpflagshavefinalize  pytypeotpfinalize  pytypeisgcpytypeo  pygcfinalizedo $^    if pyobjectcallfinalizerfromdealloco return$^  $^  endif$^  pyxcalldestructorpencoder$^  pyxtpdealloc0pywrapfstsymboltableo$^$^$^static pymethoddef pyxmethods0pywrapfstencodemappersymboltable  $^  reducecython pycfunctionpyxpw0pywrapfst00encodemappersymboltable0reducecython methnoargs 0$^  setstatecython pycfunctionpyxpw0pywrapfst00encodemappersymboltable0setstatecython metho 0$^  0 0 0 0$^$^$^static pytypeobject pyxtype0pywrapfstencodemappersymboltable  $^  pyvarobjectheadinit0 0$^  pywrapfst.encodemappersymboltable tpname$^  sizeofstruct pyxobj0pywrapfstencodemappersymboltable tpbasicsize$^  0 tpitemsize$^  pyxtpdealloc0pywrapfstencodemappersymboltable tpdealloc$^  0 tpprint$^  0 tpgetattr$^  0 tpsetattr$^  if pymajorversion  0$^  0 tpcompare$^  endif$^  if pymajorversion  0$^  0 tpasasync$^  endif$^  pyxpw0pywrapfst00encodemappersymboltable0repr tprepr$^  0 tpasnumber$^  0 tpassequence$^  0 tpasmapping$^  0 tphash$^  0 tpcall$^  0 tpstr$^  0 tpgetattro$^  0 tpsetattro$^  0 tpasbuffer$^  pytpflagsdefaultpytpflagshaveversiontagpytpflagschecktypespytpflagshavenewbufferpytpflagsbasetype tpflags$^  n  no constructor.nn  immutable symboltable class for tables stored in an encodemapper.nn  this class wraps a library const symboltable and exposes const methods of then  wrapped object. it is only to be returned by method never constructedn  directly.n   tpdoc$^  0 tptraverse$^  0 tpclear$^  0 tprichcompare$^  0 tpweaklistoffset$^  if cythoncompilinginpypy$^  pyxpw0pywrapfst00symboltable0iter tpiter$^  else$^  0 tpiter$^  endif$^  0 tpiternext$^  pyxmethods0pywrapfstencodemappersymboltable tpmethods$^  0 tpmembers$^  0 tpgetset$^  0 tpbase$^  0 tpdict$^  0 tpdescrget$^  0 tpdescrset$^  0 tpdictoffset$^  if cythoncompilinginpypy$^  pyxpw0pywrapfst00symboltable0init tpinit$^  else$^  0 tpinit$^  endif$^  0 tpalloc$^  pyxtpnew0pywrapfstencodemappersymboltable tpnew$^  0 tpfree$^  0 tpisgc$^  0 tpbases$^  0 tpmro$^  0 tpcache$^  0 tpsubclasses$^  0 tpweaklist$^  0 tpdel$^  0 tpversiontag$^  if pyversionhex  0x000000a0$^  0 tpfinalize$^  endif$^$^static struct pyxvtabstruct0pywrapfstfstsymboltable pyxvtable0pywrapfstfstsymboltable$^$^static pyobject pyxtpnew0pywrapfstfstsymboltablepytypeobject t pyobject a pyobject k $^  struct pyxobj0pywrapfstfstsymboltable p$^  pyobject o  pyxtpnew0pywrapfstsymboltablet a k$^  if unlikelyo return 0$^  p  struct pyxobj0pywrapfstfstsymboltable o$^  ppyxbase.pyxvtab  struct pyxvtabstruct0pywrapfstsymboltablepyxvtabptr0pywrapfstfstsymboltable$^  newvoidpfst stdsharedptrfstscriptfstclass $^  return o$^$^$^static void pyxtpdealloc0pywrapfstfstsymboltablepyobject o $^  struct pyxobj0pywrapfstfstsymboltable p  struct pyxobj0pywrapfstfstsymboltable o$^  if cythonusetpfinalize$^  if unlikelypytypehasfeaturepytypeo pytpflagshavefinalize  pytypeotpfinalize  pytypeisgcpytypeo  pygcfinalizedo $^    if pyobjectcallfinalizerfromdealloco return$^  $^  endif$^  pyxcalldestructorpfst$^  pyxtpdealloc0pywrapfstsymboltableo$^$^$^static pymethoddef pyxmethods0pywrapfstfstsymboltable  $^  reducecython pycfunctionpyxpw0pywrapfst00fstsymboltable0reducecython methnoargs 0$^  setstatecython pycfunctionpyxpw0pywrapfst00fstsymboltable0setstatecython metho 0$^  0 0 0 0$^$^$^static pytypeobject pyxtype0pywrapfstfstsymboltable  $^  pyvarobjectheadinit0 0$^  pywrapfst.fstsymboltable tpname$^  sizeofstruct pyxobj0pywrapfstfstsymboltable tpbasicsize$^  0 tpitemsize$^  pyxtpdealloc0pywrapfstfstsymboltable tpdealloc$^  0 tpprint$^  0 tpgetattr$^  0 tpsetattr$^  if pymajorversion  0$^  0 tpcompare$^  endif$^  if pymajorversion  0$^  0 tpasasync$^  endif$^  pyxpw0pywrapfst00fstsymboltable0repr tprepr$^  0 tpasnumber$^  0 tpassequence$^  0 tpasmapping$^  0 tphash$^  0 tpcall$^  0 tpstr$^  0 tpgetattro$^  0 tpsetattro$^  0 tpasbuffer$^  pytpflagsdefaultpytpflagshaveversiontagpytpflagschecktypespytpflagshavenewbufferpytpflagsbasetype tpflags$^  n  no constructor.nn  mutable symboltable class for tables stored in a mutable fst.nn  this class wraps a library symboltable and exposes methods of the wrappedn  object. it is only to be returned by method never constructed directly.n   tpdoc$^  0 tptraverse$^  0 tpclear$^  0 tprichcompare$^  0 tpweaklistoffset$^  if cythoncompilinginpypy$^  pyxpw0pywrapfst00symboltable0iter tpiter$^  else$^  0 tpiter$^  endif$^  0 tpiternext$^  pyxmethods0pywrapfstfstsymboltable tpmethods$^  0 tpmembers$^  0 tpgetset$^  0 tpbase$^  0 tpdict$^  0 tpdescrget$^  0 tpdescrset$^  0 tpdictoffset$^  if cythoncompilinginpypy$^  pyxpw0pywrapfst00symboltable0init tpinit$^  else$^  0 tpinit$^  endif$^  0 tpalloc$^  pyxtpnew0pywrapfstfstsymboltable tpnew$^  0 tpfree$^  0 tpisgc$^  0 tpbases$^  0 tpmro$^  0 tpcache$^  0 tpsubclasses$^  0 tpweaklist$^  0 tpdel$^  0 tpversiontag$^  if pyversionhex  0x000000a0$^  0 tpfinalize$^  endif$^$^static struct pyxvtabstruct0pywrapfstmutablesymboltable pyxvtable0pywrapfstmutablesymboltable$^$^static pyobject pyxtpnew0pywrapfstmutablesymboltablepytypeobject t pyobject a pyobject k $^  struct pyxobj0pywrapfstmutablesymboltable p$^  pyobject o  pyxtpnew0pywrapfstsymboltablet a k$^  if unlikelyo return 0$^  p  struct pyxobj0pywrapfstmutablesymboltable o$^  ppyxbase.pyxvtab  struct pyxvtabstruct0pywrapfstsymboltablepyxvtabptr0pywrapfstmutablesymboltable$^  return o$^$^$^static pymethoddef pyxmethods0pywrapfstmutablesymboltable  $^  addsymbol pycfunctionpyxpw0pywrapfst00mutablesymboltable0addsymbol methvarargsmethkeywords pyxdoc0pywrapfst00mutablesymboltableaddsymbol$^  addtable pycfunctionpyxpw0pywrapfst00mutablesymboltable0addtable metho pyxdoc0pywrapfst00mutablesymboltable0addtable$^  setname pycfunctionpyxpw0pywrapfst00mutablesymboltable0setname metho 0$^  reducecython pycfunctionpyxpw0pywrapfst00mutablesymboltable0reducecython methnoargs 0$^  setstatecython pycfunctionpyxpw0pywrapfst00mutablesymboltable0setstatecython metho 0$^  0 0 0 0$^$^$^static pytypeobject pyxtype0pywrapfstmutablesymboltable  $^  pyvarobjectheadinit0 0$^  pywrapfst.mutablesymboltable tpname$^  sizeofstruct pyxobj0pywrapfstmutablesymboltable tpbasicsize$^  0 tpitemsize$^  pyxtpdealloc0pywrapfstsymboltable tpdealloc$^  0 tpprint$^  0 tpgetattr$^  0 tpsetattr$^  if pymajorversion  0$^  0 tpcompare$^  endif$^  if pymajorversion  0$^  0 tpasasync$^  endif$^  0 tprepr$^  0 tpasnumber$^  0 tpassequence$^  0 tpasmapping$^  0 tphash$^  0 tpcall$^  0 tpstr$^  0 tpgetattro$^  0 tpsetattro$^  0 tpasbuffer$^  pytpflagsdefaultpytpflagshaveversiontagpytpflagschecktypespytpflagshavenewbufferpytpflagsbasetype tpflags$^  n  no constructor.nn  base class for mutable symbol tables.nn  this class is the base class for a mutable symboltable. it has a deletedn  constructor and implementations of all methods of the wrapped symboltable.n   tpdoc$^  0 tptraverse$^  0 tpclear$^  0 tprichcompare$^  0 tpweaklistoffset$^  if cythoncompilinginpypy$^  pyxpw0pywrapfst00symboltable0iter tpiter$^  else$^  0 tpiter$^  endif$^  0 tpiternext$^  pyxmethods0pywrapfstmutablesymboltable tpmethods$^  0 tpmembers$^  0 tpgetset$^  0 tpbase$^  0 tpdict$^  0 tpdescrget$^  0 tpdescrset$^  0 tpdictoffset$^  if cythoncompilinginpypy$^  pyxpw0pywrapfst00symboltable0init tpinit$^  else$^  0 tpinit$^  endif$^  0 tpalloc$^  pyxtpnew0pywrapfstmutablesymboltable tpnew$^  0 tpfree$^  0 tpisgc$^  0 tpbases$^  0 tpmro$^  0 tpcache$^  0 tpsubclasses$^  0 tpweaklist$^  0 tpdel$^  0 tpversiontag$^  if pyversionhex  0x000000a0$^  0 tpfinalize$^  endif$^$^static struct pyxvtabstruct0pywrapfstmutablefstsymboltable pyxvtable0pywrapfstmutablefstsymboltable$^$^static pyobject pyxtpnew0pywrapfstmutablefstsymboltablepytypeobject t pyobject a pyobject k $^  struct pyxobj0pywrapfstmutablefstsymboltable p$^  pyobject o  pyxtpnew0pywrapfstmutablesymboltablet a k$^  if unlikelyo return 0$^  p  struct pyxobj0pywrapfstmutablefstsymboltable o$^  ppyxbase.pyxbase.pyxvtab  struct pyxvtabstruct0pywrapfstsymboltablepyxvtabptr0pywrapfstmutablefstsymboltable$^  newvoidpmfst stdsharedptrfstscriptmutablefstclass $^  return o$^$^$^static void pyxtpdealloc0pywrapfstmutablefstsymboltablepyobject o $^  struct pyxobj0pywrapfstmutablefstsymboltable p  struct pyxobj0pywrapfstmutablefstsymboltable o$^  if cythonusetpfinalize$^  if unlikelypytypehasfeaturepytypeo pytpflagshavefinalize  pytypeotpfinalize  pytypeisgcpytypeo  pygcfinalizedo $^    if pyobjectcallfinalizerfromdealloco return$^  $^  endif$^  pyxcalldestructorpmfst$^  pyxtpdealloc0pywrapfstsymboltableo$^$^$^static pymethoddef pyxmethods0pywrapfstmutablefstsymboltable  $^  reducecython pycfunctionpyxpw0pywrapfst00mutablefstsymboltable0reducecython methnoargs 0$^  setstatecython pycfunctionpyxpw0pywrapfst00mutablefstsymboltable0setstatecython metho 0$^  0 0 0 0$^$^$^static pytypeobject pyxtype0pywrapfstmutablefstsymboltable  $^  pyvarobjectheadinit0 0$^  pywrapfst.mutablefstsymboltable tpname$^  sizeofstruct pyxobj0pywrapfstmutablefstsymboltable tpbasicsize$^  0 tpitemsize$^  pyxtpdealloc0pywrapfstmutablefstsymboltable tpdealloc$^  0 tpprint$^  0 tpgetattr$^  0 tpsetattr$^  if pymajorversion  0$^  0 tpcompare$^  endif$^  if pymajorversion  0$^  0 tpasasync$^  endif$^  pyxpw0pywrapfst00mutablefstsymboltable0repr tprepr$^  0 tpasnumber$^  0 tpassequence$^  0 tpasmapping$^  0 tphash$^  0 tpcall$^  0 tpstr$^  0 tpgetattro$^  0 tpsetattro$^  0 tpasbuffer$^  pytpflagsdefaultpytpflagshaveversiontagpytpflagschecktypespytpflagshavenewbufferpytpflagsbasetype tpflags$^  n  no constructor.nn  mutable symboltable assigned to an fst.n   tpdoc$^  0 tptraverse$^  0 tpclear$^  0 tprichcompare$^  0 tpweaklistoffset$^  if cythoncompilinginpypy$^  pyxpw0pywrapfst00symboltable0iter tpiter$^  else$^  0 tpiter$^  endif$^  0 tpiternext$^  pyxmethods0pywrapfstmutablefstsymboltable tpmethods$^  0 tpmembers$^  0 tpgetset$^  0 tpbase$^  0 tpdict$^  0 tpdescrget$^  0 tpdescrset$^  0 tpdictoffset$^  if cythoncompilinginpypy$^  pyxpw0pywrapfst00symboltable0init tpinit$^  else$^  0 tpinit$^  endif$^  0 tpalloc$^  pyxtpnew0pywrapfstmutablefstsymboltable tpnew$^  0 tpfree$^  0 tpisgc$^  0 tpbases$^  0 tpmro$^  0 tpcache$^  0 tpsubclasses$^  0 tpweaklist$^  0 tpdel$^  0 tpversiontag$^  if pyversionhex  0x000000a0$^  0 tpfinalize$^  endif$^$^static struct pyxvtabstruct0pywrapfstsymboltable pyxvtable0pywrapfstsymboltable$^$^static pyobject pyxtpnew0pywrapfstsymboltablepytypeobject t pyobject a pyobject k $^  struct pyxobj0pywrapfstsymboltable p$^  pyobject o  pyxtpnew0pywrapfstmutablesymboltablet a k$^  if unlikelyo return 0$^  p  struct pyxobj0pywrapfstsymboltable o$^  ppyxbase.pyxbase.pyxvtab  struct pyxvtabstruct0pywrapfstsymboltablepyxvtabptr0pywrapfstsymboltable$^  newvoidpsmarttable stduniqueptrfstsymboltable $^  return o$^$^$^static void pyxtpdealloc0pywrapfstsymboltablepyobject o $^  struct pyxobj0pywrapfstsymboltable p  struct pyxobj0pywrapfstsymboltable o$^  if cythonusetpfinalize$^  if unlikelypytypehasfeaturepytypeo pytpflagshavefinalize  pytypeotpfinalize  pytypeisgcpytypeo  pygcfinalizedo $^    if pyobjectcallfinalizerfromdealloco return$^  $^  endif$^  pyxcalldestructorpsmarttable$^  pyxtpdealloc0pywrapfstsymboltableo$^$^$^static pymethoddef pyxmethods0pywrapfstsymboltable  $^  read pycfunctionpyxpw0pywrapfst00symboltable0read metho pyxdoc0pywrapfst00symboltable0read$^  readtext pycfunctionpyxpw0pywrapfst00symboltable0readtext methvarargsmethkeywords pyxdoc0pywrapfst00symboltable0readtext$^  readfst pycfunctionpyxpw0pywrapfst00symboltable0readfst methvarargsmethkeywords pyxdoc0pywrapfst00symboltable0readfst$^  reducecython pycfunctionpyxpw0pywrapfst00symboltable00reducecython methnoargs 0$^  setstatecython pycfunctionpyxpw0pywrapfst00symboltable00setstatecython metho 0$^  0 0 0 0$^$^$^static pytypeobject pyxtype0pywrapfstsymboltable  $^  pyvarobjectheadinit0 0$^  pywrapfst.symboltable tpname$^  sizeofstruct pyxobj0pywrapfstsymboltable tpbasicsize$^  0 tpitemsize$^  pyxtpdealloc0pywrapfstsymboltable tpdealloc$^  0 tpprint$^  0 tpgetattr$^  0 tpsetattr$^  if pymajorversion  0$^  0 tpcompare$^  endif$^  if pymajorversion  0$^  0 tpasasync$^  endif$^  pyxpw0pywrapfst00symboltable0repr tprepr$^  0 tpasnumber$^  0 tpassequence$^  0 tpasmapping$^  0 tphash$^  0 tpcall$^  0 tpstr$^  0 tpgetattro$^  0 tpsetattro$^  0 tpasbuffer$^  pytpflagsdefaultpytpflagshaveversiontagpytpflagschecktypespytpflagshavenewbufferpytpflagsbasetype tpflags$^  n  symboltablenameunspecifiednn  mutable symboltable class.nn  this class wraps the library symboltable and exposes both const i.e.n  access and nonconst i.e. mutation methods of wrapped object.nn  unlike other classes in the hierarchy it has a working constructor and can ben  used to programmatically construct a symboltable in memory.nn  argsn    name an optional string indicating the tables name.n   tpdoc$^  0 tptraverse$^  0 tpclear$^  0 tprichcompare$^  0 tpweaklistoffset$^  if cythoncompilinginpypy$^  pyxpw0pywrapfst00symboltable0iter tpiter$^  else$^  0 tpiter$^  endif$^  0 tpiternext$^  pyxmethods0pywrapfstsymboltable tpmethods$^  0 tpmembers$^  0 tpgetset$^  0 tpbase$^  0 tpdict$^  0 tpdescrget$^  0 tpdescrset$^  0 tpdictoffset$^  pyxpw0pywrapfst00symboltable0init tpinit$^  0 tpalloc$^  pyxtpnew0pywrapfstsymboltable tpnew$^  0 tpfree$^  0 tpisgc$^  0 tpbases$^  0 tpmro$^  0 tpcache$^  0 tpsubclasses$^  0 tpweaklist$^  0 tpdel$^  0 tpversiontag$^  if pyversionhex  0x000000a0$^  0 tpfinalize$^  endif$^$^static struct pyxvtabstruct0pywrapfstsymboltableiterator pyxvtable0pywrapfstsymboltableiterator$^$^static pyobject pyxtpnew0pywrapfstsymboltableiteratorpytypeobject t cythonunused pyobject a cythonunused pyobject k $^  struct pyxobj0pywrapfstsymboltableiterator p$^  pyobject o$^  if likelyttpflags  pytpflagsisabstract  0 $^    o  ttpalloct 0$^   else $^    o  pyobject  pybaseobjecttype.tpnewt pyxemptytuple 0$^  $^  if unlikelyo return 0$^  p  struct pyxobj0pywrapfstsymboltableiterator o$^  ppyxvtab  pyxvtabptr0pywrapfstsymboltableiterator$^  newvoidptable stdsharedptrfstsymboltable $^  newvoidpsiter stduniqueptrfstsymboltableiterator $^  return o$^$^$^static void pyxtpdealloc0pywrapfstsymboltableiteratorpyobject o $^  struct pyxobj0pywrapfstsymboltableiterator p  struct pyxobj0pywrapfstsymboltableiterator o$^  if cythonusetpfinalize$^  if unlikelypytypehasfeaturepytypeo pytpflagshavefinalize  pytypeotpfinalize  pytypeisgcpytypeo  pygcfinalizedo $^    if pyobjectcallfinalizerfromdealloco return$^  $^  endif$^  pyxcalldestructorptable$^  pyxcalldestructorpsiter$^  pytypeotpfreeo$^$^$^static pymethoddef pyxmethods0pywrapfstsymboltableiterator  $^  next pycfunctionpyxpw0pywrapfst00symboltableiterator0next methnoargsmethcoexist 0$^  done pycfunctionpyxpw0pywrapfst00symboltableiterator0done methnoargs pyxdoc0pywrapfst00symboltableiterator0done$^  next pycfunctionpyxpw0pywrapfst00symboltableiterator00next methnoargs pyxdoc0pywrapfst00symboltableiterator00next$^  reset pycfunctionpyxpw0pywrapfst00symboltableiterator00reset methnoargs pyxdoc0pywrapfst00symboltableiterator00reset$^  symbol pycfunctionpyxpw0pywrapfst00symboltableiterator00symbol methnoargs pyxdoc0pywrapfst00symboltableiterator00symbol$^  value pycfunctionpyxpw0pywrapfst00symboltableiterator00value methnoargs pyxdoc0pywrapfst00symboltableiterator00value$^  reducecython pycfunctionpyxpw0pywrapfst00symboltableiterator00reducecython methnoargs 0$^  setstatecython pycfunctionpyxpw0pywrapfst00symboltableiterator00setstatecython metho 0$^  0 0 0 0$^$^$^static pytypeobject pyxtype0pywrapfstsymboltableiterator  $^  pyvarobjectheadinit0 0$^  pywrapfst.symboltableiterator tpname$^  sizeofstruct pyxobj0pywrapfstsymboltableiterator tpbasicsize$^  0 tpitemsize$^  pyxtpdealloc0pywrapfstsymboltableiterator tpdealloc$^  0 tpprint$^  0 tpgetattr$^  0 tpsetattr$^  if pymajorversion  0$^  0 tpcompare$^  endif$^  if pymajorversion  0$^  0 tpasasync$^  endif$^  pyxpw0pywrapfst00symboltableiterator0repr tprepr$^  0 tpasnumber$^  0 tpassequence$^  0 tpasmapping$^  0 tphash$^  0 tpcall$^  0 tpstr$^  0 tpgetattro$^  0 tpsetattro$^  0 tpasbuffer$^  pytpflagsdefaultpytpflagshaveversiontagpytpflagschecktypespytpflagshavenewbufferpytpflagsbasetype tpflags$^  n  symboltableiteratorsymsnn  this class is used for iterating over a symbol table.n   tpdoc$^  0 tptraverse$^  0 tpclear$^  0 tprichcompare$^  0 tpweaklistoffset$^  pyxpw0pywrapfst00symboltableiterator0iter tpiter$^  pyxpw0pywrapfst00symboltableiterator0next tpiternext$^  pyxmethods0pywrapfstsymboltableiterator tpmethods$^  0 tpmembers$^  0 tpgetset$^  0 tpbase$^  0 tpdict$^  0 tpdescrget$^  0 tpdescrset$^  0 tpdictoffset$^  pyxpw0pywrapfst00symboltableiterator0init tpinit$^  0 tpalloc$^  pyxtpnew0pywrapfstsymboltableiterator tpnew$^  0 tpfree$^  0 tpisgc$^  0 tpbases$^  0 tpmro$^  0 tpcache$^  0 tpsubclasses$^  0 tpweaklist$^  0 tpdel$^  0 tpversiontag$^  if pyversionhex  0x000000a0$^  0 tpfinalize$^  endif$^$^static struct pyxvtabstruct0pywrapfstencodemapper pyxvtable0pywrapfstencodemapper$^$^static pyobject pyxtpnew0pywrapfstencodemapperpytypeobject t cythonunused pyobject a cythonunused pyobject k $^  struct pyxobj0pywrapfstencodemapper p$^  pyobject o$^  if likelyttpflags  pytpflagsisabstract  0 $^    o  ttpalloct 0$^   else $^    o  pyobject  pybaseobjecttype.tpnewt pyxemptytuple 0$^  $^  if unlikelyo return 0$^  p  struct pyxobj0pywrapfstencodemapper o$^  ppyxvtab  pyxvtabptr0pywrapfstencodemapper$^  newvoidpencoder stdsharedptrfstscriptencodemapperclass $^  return o$^$^$^static void pyxtpdealloc0pywrapfstencodemapperpyobject o $^  struct pyxobj0pywrapfstencodemapper p  struct pyxobj0pywrapfstencodemapper o$^  if cythonusetpfinalize$^  if unlikelypytypehasfeaturepytypeo pytpflagshavefinalize  pytypeotpfinalize  pytypeisgcpytypeo  pygcfinalizedo $^    if pyobjectcallfinalizerfromdealloco return$^  $^  endif$^  pyxcalldestructorpencoder$^  pytypeotpfreeo$^$^$^static pymethoddef pyxmethods0pywrapfstencodemapper  $^  arctype pycfunctionpyxpw0pywrapfst00encodemapper0arctype methnoargs pyxdoc0pywrapfst00encodemapper0arctype$^  flags pycfunctionpyxpw0pywrapfst00encodemapper0flags methnoargs pyxdoc0pywrapfst00encodemapper0flags$^  inputsymbols pycfunctionpyxpw0pywrapfst00encodemapper00inputsymbols methnoargs pyxdoc0pywrapfst00encodemapper00inputsymbols$^  outputsymbols pycfunctionpyxpw0pywrapfst00encodemapper00outputsymbols methnoargs pyxdoc0pywrapfst00encodemapper00outputsymbols$^  properties pycfunctionpyxpw0pywrapfst00encodemapper00properties metho pyxdoc0pywrapfst00encodemapper00properties$^  setinputsymbols pycfunctionpyxpw0pywrapfst00encodemapper00setinputsymbols metho pyxdoc0pywrapfst00encodemapper00setinputsymbols$^  setoutputsymbols pycfunctionpyxpw0pywrapfst00encodemapper00setoutputsymbols metho pyxdoc0pywrapfst00encodemapper00setoutputsymbols$^  weighttype pycfunctionpyxpw0pywrapfst00encodemapper00weighttype methnoargs pyxdoc0pywrapfst00encodemapper00weighttype$^  reducecython pycfunctionpyxpw0pywrapfst00encodemapper00reducecython methnoargs 0$^  setstatecython pycfunctionpyxpw0pywrapfst00encodemapper00setstatecython metho 0$^  0 0 0 0$^$^$^static pytypeobject pyxtype0pywrapfstencodemapper  $^  pyvarobjectheadinit0 0$^  pywrapfst.encodemapper tpname$^  sizeofstruct pyxobj0pywrapfstencodemapper tpbasicsize$^  0 tpitemsize$^  pyxtpdealloc0pywrapfstencodemapper tpdealloc$^  0 tpprint$^  0 tpgetattr$^  0 tpsetattr$^  if pymajorversion  0$^  0 tpcompare$^  endif$^  if pymajorversion  0$^  0 tpasasync$^  endif$^  pyxpw0pywrapfst00encodemapper0repr tprepr$^  0 tpasnumber$^  0 tpassequence$^  0 tpasmapping$^  0 tphash$^  pyxpw0pywrapfst00encodemapper0call tpcall$^  0 tpstr$^  0 tpgetattro$^  0 tpsetattro$^  0 tpasbuffer$^  pytpflagsdefaultpytpflagshaveversiontagpytpflagschecktypespytpflagshavenewbufferpytpflagsbasetype tpflags$^  n  encodemapperarctypestandard encodelabelsfalse encodeweightsfalsenn  arc encoder class wrapping encodemapperclass.nn  this class provides an object which can be used to encode or decode fst arcs.n  this is most useful to convert an fst to an unweighted acceptor on whichn  some fst operations are more efficient and then decoding the fst afterwards.nn  to use an instance of this class to encode or decode a mutable fst pass itn  as the first argument to the fst instance methods encode and decode.nn  for implementational reasons it is not currently possible to use an encodern  on disk to construct this class.nn  argsn    arctype a string indicating the arc type.n    encodelabels should labels be encodedn    encodeweights should weights be encodedn   tpdoc$^  0 tptraverse$^  0 tpclear$^  0 tprichcompare$^  0 tpweaklistoffset$^  0 tpiter$^  0 tpiternext$^  pyxmethods0pywrapfstencodemapper tpmethods$^  0 tpmembers$^  0 tpgetset$^  0 tpbase$^  0 tpdict$^  0 tpdescrget$^  0 tpdescrset$^  0 tpdictoffset$^  pyxpw0pywrapfst00encodemapper0init tpinit$^  0 tpalloc$^  pyxtpnew0pywrapfstencodemapper tpnew$^  0 tpfree$^  0 tpisgc$^  0 tpbases$^  0 tpmro$^  0 tpcache$^  0 tpsubclasses$^  0 tpweaklist$^  0 tpdel$^  0 tpversiontag$^  if pyversionhex  0x000000a0$^  0 tpfinalize$^  endif$^$^static struct pyxvtabstruct0pywrapfstfst pyxvtable0pywrapfstfst$^$^static pyobject pyxtpnew0pywrapfstfstpytypeobject t cythonunused pyobject a cythonunused pyobject k $^  struct pyxobj0pywrapfstfst p$^  pyobject o$^  if likelyttpflags  pytpflagsisabstract  0 $^    o  ttpalloct 0$^   else $^    o  pyobject  pybaseobjecttype.tpnewt pyxemptytuple 0$^  $^  if unlikelyo return 0$^  p  struct pyxobj0pywrapfstfst o$^  ppyxvtab  pyxvtabptr0pywrapfstfst$^  newvoidpfst stdsharedptrfstscriptfstclass $^  return o$^$^$^static void pyxtpdealloc0pywrapfstfstpyobject o $^  struct pyxobj0pywrapfstfst p  struct pyxobj0pywrapfstfst o$^  if cythonusetpfinalize$^  if unlikelypytypehasfeaturepytypeo pytpflagshavefinalize  pytypeotpfinalize  pytypeisgcpytypeo  pygcfinalizedo $^    if pyobjectcallfinalizerfromdealloco return$^  $^  endif$^  pyxcalldestructorpfst$^  pytypeotpfreeo$^$^$^static pymethoddef pyxmethods0pywrapfstfst  $^  reprsvg pycfunctionpyxpw0pywrapfst0fst0reprsvg methnoargs pyxdoc0pywrapfst0fstreprsvg$^  reduce pycfunctionpyxpw0pywrapfst0fst0reduce methnoargs 0$^  arctype pycfunctionpyxpw0pywrapfst0fst00arctype methnoargs pyxdoc0pywrapfst0fst00arctype$^  arcs pycfunctionpyxpw0pywrapfst0fst00arcs metho pyxdoc0pywrapfst0fst00arcs$^  copy pycfunctionpyxpw0pywrapfst0fst00copy methnoargs pyxdoc0pywrapfst0fst00copy$^  draw pycfunctionpyxpw0pywrapfst0fst00draw methvarargsmethkeywords pyxdoc0pywrapfst0fst00draw$^  final pycfunctionpyxpw0pywrapfst0fst00final metho pyxdoc0pywrapfst0fst00final$^  fsttype pycfunctionpyxpw0pywrapfst0fst00fsttype methnoargs pyxdoc0pywrapfst0fst00fsttype$^  inputsymbols pycfunctionpyxpw0pywrapfst0fst00inputsymbols methnoargs pyxdoc0pywrapfst0fst00inputsymbols$^  numarcs pycfunctionpyxpw0pywrapfst0fst00numarcs metho pyxdoc0pywrapfst0fst00numarcs$^  numinputepsilons pycfunctionpyxpw0pywrapfst0fst00numinputepsilons metho pyxdoc0pywrapfst0fst00numinputepsilons$^  numoutputepsilons pycfunctionpyxpw0pywrapfst0fst00numoutputepsilons metho pyxdoc0pywrapfst0fst00numoutputepsilons$^  outputsymbols pycfunctionpyxpw0pywrapfst0fst00outputsymbols methnoargs pyxdoc0pywrapfst0fst00outputsymbols$^  properties pycfunctionpyxpw0pywrapfst0fst00properties methvarargsmethkeywords pyxdoc0pywrapfst0fst00properties$^  start pycfunctionpyxpw0pywrapfst0fst00start methnoargs pyxdoc0pywrapfst0fst00start$^  states pycfunctionpyxpw0pywrapfst0fst00states methnoargs pyxdoc0pywrapfst0fst00states$^  text pycfunctionpyxpw0pywrapfst0fst00text methvarargsmethkeywords pyxdoc0pywrapfst0fst00text$^  verify pycfunctionpyxpw0pywrapfst0fst00verify methnoargs pyxdoc0pywrapfst0fst00verify$^  weighttype pycfunctionpyxpw0pywrapfst0fst00weighttype methnoargs pyxdoc0pywrapfst0fst00weighttype$^  write pycfunctionpyxpw0pywrapfst0fst00write metho pyxdoc0pywrapfst0fst00write$^  writetostring pycfunctionpyxpw0pywrapfst0fst00writetostring methnoargs pyxdoc0pywrapfst0fst00writetostring$^  0 0 0 0$^$^$^static pytypeobject pyxtype0pywrapfstfst  $^  pyvarobjectheadinit0 0$^  pywrapfst.fst tpname$^  sizeofstruct pyxobj0pywrapfstfst tpbasicsize$^  0 tpitemsize$^  pyxtpdealloc0pywrapfstfst tpdealloc$^  0 tpprint$^  0 tpgetattr$^  0 tpsetattr$^  if pymajorversion  0$^  0 tpcompare$^  endif$^  if pymajorversion  0$^  0 tpasasync$^  endif$^  pyxpw0pywrapfst0fst0repr tprepr$^  0 tpasnumber$^  0 tpassequence$^  0 tpasmapping$^  0 tphash$^  0 tpcall$^  pyxpw0pywrapfst0fst0str tpstr$^  0 tpgetattro$^  0 tpsetattro$^  0 tpasbuffer$^  pytpflagsdefaultpytpflagshaveversiontagpytpflagschecktypespytpflagshavenewbufferpytpflagsbasetype tpflags$^  n  no constructor.nn  immutable fst class wrapping fstclass.nn  this class is the basic userfacing fst object. it does not itself support anyn  mutation operations.n   tpdoc$^  0 tptraverse$^  0 tpclear$^  0 tprichcompare$^  0 tpweaklistoffset$^  0 tpiter$^  0 tpiternext$^  pyxmethods0pywrapfstfst tpmethods$^  0 tpmembers$^  0 tpgetset$^  0 tpbase$^  0 tpdict$^  0 tpdescrget$^  0 tpdescrset$^  0 tpdictoffset$^  pyxpw0pywrapfst0fst0init tpinit$^  0 tpalloc$^  pyxtpnew0pywrapfstfst tpnew$^  0 tpfree$^  0 tpisgc$^  0 tpbases$^  0 tpmro$^  0 tpcache$^  0 tpsubclasses$^  0 tpweaklist$^  0 tpdel$^  0 tpversiontag$^  if pyversionhex  0x000000a0$^  0 tpfinalize$^  endif$^$^static struct pyxvtabstruct0pywrapfstmutablefst pyxvtable0pywrapfstmutablefst$^$^static pyobject pyxtpnew0pywrapfstmutablefstpytypeobject t pyobject a pyobject k $^  struct pyxobj0pywrapfstmutablefst p$^  pyobject o  pyxtpnew0pywrapfstfstt a k$^  if unlikelyo return 0$^  p  struct pyxobj0pywrapfstmutablefst o$^  ppyxbase.pyxvtab  struct pyxvtabstruct0pywrapfstfstpyxvtabptr0pywrapfstmutablefst$^  newvoidpmfst stdsharedptrfstscriptmutablefstclass $^  return o$^$^$^static void pyxtpdealloc0pywrapfstmutablefstpyobject o $^  struct pyxobj0pywrapfstmutablefst p  struct pyxobj0pywrapfstmutablefst o$^  if cythonusetpfinalize$^  if unlikelypytypehasfeaturepytypeo pytpflagshavefinalize  pytypeotpfinalize  pytypeisgcpytypeo  pygcfinalizedo $^    if pyobjectcallfinalizerfromdealloco return$^  $^  endif$^  pyxcalldestructorpmfst$^  pyxtpdealloc0pywrapfstfsto$^$^$^static pymethoddef pyxmethods0pywrapfstmutablefst  $^  addarc pycfunctionpyxpw0pywrapfst00mutablefst0addarc methvarargsmethkeywords pyxdoc0pywrapfst00mutablefstaddarc$^  addstate pycfunctionpyxpw0pywrapfst00mutablefst0addstate methnoargs pyxdoc0pywrapfst00mutablefst0addstate$^  arcsort pycfunctionpyxpw0pywrapfst00mutablefst0arcsort methvarargsmethkeywords pyxdoc0pywrapfst00mutablefst0arcsort$^  closure pycfunctionpyxpw0pywrapfst00mutablefst0closure methvarargsmethkeywords pyxdoc0pywrapfst00mutablefst0closure$^  concat pycfunctionpyxpw0pywrapfst00mutablefst0concat metho pyxdoc0pywrapfst00mutablefst0concat$^  connect pycfunctionpyxpw0pywrapfst00mutablefst00connect methnoargs pyxdoc0pywrapfst00mutablefst00connect$^  decode pycfunctionpyxpw0pywrapfst00mutablefst00decode metho pyxdoc0pywrapfst00mutablefst00decode$^  deletearcs pycfunctionpyxpw0pywrapfst00mutablefst00deletearcs methvarargsmethkeywords pyxdoc0pywrapfst00mutablefst00deletearcs$^  deletestates pycfunctionpyxpw0pywrapfst00mutablefst00deletestates methvarargsmethkeywords pyxdoc0pywrapfst00mutablefst00deletestates$^  encode pycfunctionpyxpw0pywrapfst00mutablefst00encode metho pyxdoc0pywrapfst00mutablefst00encode$^  invert pycfunctionpyxpw0pywrapfst00mutablefst00invert methnoargs pyxdoc0pywrapfst00mutablefst00invert$^  minimize pycfunctionpyxpw0pywrapfst00mutablefst00minimize methvarargsmethkeywords pyxdoc0pywrapfst00mutablefst00minimize$^  mutablearcs pycfunctionpyxpw0pywrapfst00mutablefst00mutablearcs metho pyxdoc0pywrapfst00mutablefst00mutablearcs$^  mutableinputsymbols pycfunctionpyxpw0pywrapfst00mutablefst00mutableinputsymbols methnoargs pyxdoc0pywrapfst00mutablefst00mutableinputsymbols$^  mutableoutputsymbols pycfunctionpyxpw0pywrapfst00mutablefst00mutableoutputsymbols methnoargs pyxdoc0pywrapfst00mutablefst00mutableoutputsymbols$^  numstates pycfunctionpyxpw0pywrapfst00mutablefst00numstates methnoargs pyxdoc0pywrapfst00mutablefst00numstates$^  project pycfunctionpyxpw0pywrapfst00mutablefst00project methvarargsmethkeywords pyxdoc0pywrapfst00mutablefst00project$^  prune pycfunctionpyxpw0pywrapfst00mutablefst00prune methvarargsmethkeywords pyxdoc0pywrapfst00mutablefst00prune$^  push pycfunctionpyxpw0pywrapfst00mutablefst00push methvarargsmethkeywords pyxdoc0pywrapfst00mutablefst00push$^  relabelpairs pycfunctionpyxpw0pywrapfst00mutablefst00relabelpairs methvarargsmethkeywords pyxdoc0pywrapfst00mutablefst00relabelpairs$^  relabeltables pycfunctionpyxpw0pywrapfst00mutablefst00relabeltables methvarargsmethkeywords pyxdoc0pywrapfst00mutablefst00relabeltables$^  reservearcs pycfunctionpyxpw0pywrapfst00mutablefst00reservearcs methvarargsmethkeywords pyxdoc0pywrapfst00mutablefst00reservearcs$^  reservestates pycfunctionpyxpw0pywrapfst00mutablefst00reservestates metho pyxdoc0pywrapfst00mutablefst00reservestates$^  reweight pycfunctionpyxpw0pywrapfst00mutablefst00reweight methvarargsmethkeywords pyxdoc0pywrapfst00mutablefst00reweight$^  rmepsilon pycfunctionpyxpw0pywrapfst00mutablefst00rmepsilon methvarargsmethkeywords pyxdoc0pywrapfst00mutablefst00rmepsilon$^  setfinal pycfunctionpyxpw0pywrapfst00mutablefst00setfinal methvarargsmethkeywords pyxdoc0pywrapfst00mutablefst00setfinal$^  setinputsymbols pycfunctionpyxpw0pywrapfst00mutablefst00setinputsymbols metho pyxdoc0pywrapfst00mutablefst00setinputsymbols$^  setoutputsymbols pycfunctionpyxpw0pywrapfst00mutablefst00setoutputsymbols metho pyxdoc0pywrapfst00mutablefst00setoutputsymbols$^  setproperties pycfunctionpyxpw0pywrapfst00mutablefst00setproperties methvarargsmethkeywords pyxdoc0pywrapfst00mutablefst00setproperties$^  setstart pycfunctionpyxpw0pywrapfst00mutablefst00setstart metho pyxdoc0pywrapfst00mutablefst00setstart$^  topsort pycfunctionpyxpw0pywrapfst00mutablefst00topsort methnoargs pyxdoc0pywrapfst00mutablefst00topsort$^  union pycfunctionpyxpw0pywrapfst00mutablefst00union metho pyxdoc0pywrapfst00mutablefst00union$^  0 0 0 0$^$^$^static pytypeobject pyxtype0pywrapfstmutablefst  $^  pyvarobjectheadinit0 0$^  pywrapfst.mutablefst tpname$^  sizeofstruct pyxobj0pywrapfstmutablefst tpbasicsize$^  0 tpitemsize$^  pyxtpdealloc0pywrapfstmutablefst tpdealloc$^  0 tpprint$^  0 tpgetattr$^  0 tpsetattr$^  if pymajorversion  0$^  0 tpcompare$^  endif$^  if pymajorversion  0$^  0 tpasasync$^  endif$^  if cythoncompilinginpypy$^  pyxpw0pywrapfst0fst0repr tprepr$^  else$^  0 tprepr$^  endif$^  0 tpasnumber$^  0 tpassequence$^  0 tpasmapping$^  0 tphash$^  0 tpcall$^  if cythoncompilinginpypy$^  pyxpw0pywrapfst0fst0str tpstr$^  else$^  0 tpstr$^  endif$^  0 tpgetattro$^  0 tpsetattro$^  0 tpasbuffer$^  pytpflagsdefaultpytpflagshaveversiontagpytpflagschecktypespytpflagshavenewbufferpytpflagsbasetype tpflags$^  n  no constructor.nn  mutable fst class wrapping mutablefstclass.nn  this class extends fst by adding mutation operations.n   tpdoc$^  0 tptraverse$^  0 tpclear$^  0 tprichcompare$^  0 tpweaklistoffset$^  0 tpiter$^  0 tpiternext$^  pyxmethods0pywrapfstmutablefst tpmethods$^  0 tpmembers$^  0 tpgetset$^  0 tpbase$^  0 tpdict$^  0 tpdescrget$^  0 tpdescrset$^  0 tpdictoffset$^  if cythoncompilinginpypy$^  pyxpw0pywrapfst0fst0init tpinit$^  else$^  0 tpinit$^  endif$^  0 tpalloc$^  pyxtpnew0pywrapfstmutablefst tpnew$^  0 tpfree$^  0 tpisgc$^  0 tpbases$^  0 tpmro$^  0 tpcache$^  0 tpsubclasses$^  0 tpweaklist$^  0 tpdel$^  0 tpversiontag$^  if pyversionhex  0x000000a0$^  0 tpfinalize$^  endif$^$^static struct pyxvtabstruct0pywrapfstarc pyxvtable0pywrapfstarc$^$^static pyobject pyxtpnew0pywrapfstarcpytypeobject t cythonunused pyobject a cythonunused pyobject k $^  struct pyxobj0pywrapfstarc p$^  pyobject o$^  if likelyttpflags  pytpflagsisabstract  0 $^    o  ttpalloct 0$^   else $^    o  pyobject  pybaseobjecttype.tpnewt pyxemptytuple 0$^  $^  if unlikelyo return 0$^  p  struct pyxobj0pywrapfstarc o$^  ppyxvtab  pyxvtabptr0pywrapfstarc$^  newvoidparc stduniqueptrfstscriptarcclass $^  return o$^$^$^static void pyxtpdealloc0pywrapfstarcpyobject o $^  struct pyxobj0pywrapfstarc p  struct pyxobj0pywrapfstarc o$^  if cythonusetpfinalize$^  if unlikelypytypehasfeaturepytypeo pytpflagshavefinalize  pytypeotpfinalize  pytypeisgcpytypeo  pygcfinalizedo $^    if pyobjectcallfinalizerfromdealloco return$^  $^  endif$^  pyxcalldestructorparc$^  pytypeotpfreeo$^$^$^static pyobject pyxgetprop0pywrapfst0arcilabelpyobject o cythonunused void x $^  return pyxpw0pywrapfst0arc0ilabel0geto$^$^$^static int pyxsetprop0pywrapfst0arcilabelpyobject o pyobject v cythonunused void x $^  if v $^    return pyxpw0pywrapfst0arc0ilabel0seto v$^  $^  else $^    pyerrsetstringpyexcnotimplementederror del$^    return 0$^  $^$^$^static pyobject pyxgetprop0pywrapfst0arcolabelpyobject o cythonunused void x $^  return pyxpw0pywrapfst0arc0olabel0geto$^$^$^static int pyxsetprop0pywrapfst0arcolabelpyobject o pyobject v cythonunused void x $^  if v $^    return pyxpw0pywrapfst0arc0olabel0seto v$^  $^  else $^    pyerrsetstringpyexcnotimplementederror del$^    return 0$^  $^$^$^static pyobject pyxgetprop0pywrapfst0arcweightpyobject o cythonunused void x $^  return pyxpw0pywrapfst0arc0weight0geto$^$^$^static int pyxsetprop0pywrapfst0arcweightpyobject o pyobject v cythonunused void x $^  if v $^    return pyxpw0pywrapfst0arc0weight0seto v$^  $^  else $^    pyerrsetstringpyexcnotimplementederror del$^    return 0$^  $^$^$^static pyobject pyxgetprop0pywrapfst0arcnextstatepyobject o cythonunused void x $^  return pyxpw0pywrapfst0arc0nextstate0geto$^$^$^static int pyxsetprop0pywrapfst0arcnextstatepyobject o pyobject v cythonunused void x $^  if v $^    return pyxpw0pywrapfst0arc0nextstate0seto v$^  $^  else $^    pyerrsetstringpyexcnotimplementederror del$^    return 0$^  $^$^$^static pymethoddef pyxmethods0pywrapfstarc  $^  copy pycfunctionpyxpw0pywrapfst0arc0copy methnoargs 0$^  reducecython pycfunctionpyxpw0pywrapfst0arc0reducecython methnoargs 0$^  setstatecython pycfunctionpyxpw0pywrapfst0arc0setstatecython metho 0$^  0 0 0 0$^$^$^static struct pygetsetdef pyxgetsets0pywrapfstarc  $^  char ilabel pyxgetprop0pywrapfst0arcilabel pyxsetprop0pywrapfst0arcilabel char 0 0$^  char olabel pyxgetprop0pywrapfst0arcolabel pyxsetprop0pywrapfst0arcolabel char 0 0$^  char weight pyxgetprop0pywrapfst0arcweight pyxsetprop0pywrapfst0arcweight char 0 0$^  char nextstate pyxgetprop0pywrapfst0arcnextstate pyxsetprop0pywrapfst0arcnextstate char 0 0$^  0 0 0 0 0$^$^$^static pytypeobject pyxtype0pywrapfstarc  $^  pyvarobjectheadinit0 0$^  pywrapfst.arc tpname$^  sizeofstruct pyxobj0pywrapfstarc tpbasicsize$^  0 tpitemsize$^  pyxtpdealloc0pywrapfstarc tpdealloc$^  0 tpprint$^  0 tpgetattr$^  0 tpsetattr$^  if pymajorversion  0$^  0 tpcompare$^  endif$^  if pymajorversion  0$^  0 tpasasync$^  endif$^  pyxpw0pywrapfst0arc0repr tprepr$^  0 tpasnumber$^  0 tpassequence$^  0 tpasmapping$^  0 tphash$^  0 tpcall$^  0 tpstr$^  0 tpgetattro$^  0 tpsetattro$^  0 tpasbuffer$^  pytpflagsdefaultpytpflagshaveversiontagpytpflagschecktypespytpflagshavenewbufferpytpflagsbasetype tpflags$^  n  arcilabel olabel weight nextstatenn  this class represents an arc while remaining agnostic about the underlying arcn  type.  attributes of the arc can be accessed or mutated and the arc can ben  copied.nn  attributesn    ilabel the input label.n    olabel the output label.n    weight the arc weight.n    nextstate the destination state for the arc.n   tpdoc$^  0 tptraverse$^  0 tpclear$^  0 tprichcompare$^  0 tpweaklistoffset$^  0 tpiter$^  0 tpiternext$^  pyxmethods0pywrapfstarc tpmethods$^  0 tpmembers$^  pyxgetsets0pywrapfstarc tpgetset$^  0 tpbase$^  0 tpdict$^  0 tpdescrget$^  0 tpdescrset$^  0 tpdictoffset$^  pyxpw0pywrapfst0arc0init tpinit$^  0 tpalloc$^  pyxtpnew0pywrapfstarc tpnew$^  0 tpfree$^  0 tpisgc$^  0 tpbases$^  0 tpmro$^  0 tpcache$^  0 tpsubclasses$^  0 tpweaklist$^  0 tpdel$^  0 tpversiontag$^  if pyversionhex  0x000000a0$^  0 tpfinalize$^  endif$^$^static struct pyxvtabstruct0pywrapfstarciterator pyxvtable0pywrapfstarciterator$^$^static pyobject pyxtpnew0pywrapfstarciteratorpytypeobject t cythonunused pyobject a cythonunused pyobject k $^  struct pyxobj0pywrapfstarciterator p$^  pyobject o$^  if likelyttpflags  pytpflagsisabstract  0 $^    o  ttpalloct 0$^   else $^    o  pyobject  pybaseobjecttype.tpnewt pyxemptytuple 0$^  $^  if unlikelyo return 0$^  p  struct pyxobj0pywrapfstarciterator o$^  ppyxvtab  pyxvtabptr0pywrapfstarciterator$^  newvoidpfst stdsharedptrfstscriptfstclass $^  newvoidpaiter stduniqueptrfstscriptarciteratorclass $^  return o$^$^$^static void pyxtpdealloc0pywrapfstarciteratorpyobject o $^  struct pyxobj0pywrapfstarciterator p  struct pyxobj0pywrapfstarciterator o$^  if cythonusetpfinalize$^  if unlikelypytypehasfeaturepytypeo pytpflagshavefinalize  pytypeotpfinalize  pytypeisgcpytypeo  pygcfinalizedo $^    if pyobjectcallfinalizerfromdealloco return$^  $^  endif$^  pyxcalldestructorpfst$^  pyxcalldestructorpaiter$^  pytypeotpfreeo$^$^$^static pymethoddef pyxmethods0pywrapfstarciterator  $^  next pycfunctionpyxpw0pywrapfst00arciterator0next methnoargsmethcoexist 0$^  done pycfunctionpyxpw0pywrapfst00arciterator0done methnoargs pyxdoc0pywrapfst00arciterator0done$^  flags pycfunctionpyxpw0pywrapfst00arciterator00flags methnoargs pyxdoc0pywrapfst00arciterator00flags$^  next pycfunctionpyxpw0pywrapfst00arciterator00next methnoargs pyxdoc0pywrapfst00arciterator00next$^  position pycfunctionpyxpw0pywrapfst00arciterator00position methnoargs pyxdoc0pywrapfst00arciterator00position$^  reset pycfunctionpyxpw0pywrapfst00arciterator00reset methnoargs pyxdoc0pywrapfst00arciterator00reset$^  seek pycfunctionpyxpw0pywrapfst00arciterator00seek metho pyxdoc0pywrapfst00arciterator00seek$^  setflags pycfunctionpyxpw0pywrapfst00arciterator00setflags methvarargsmethkeywords pyxdoc0pywrapfst00arciterator00setflags$^  value pycfunctionpyxpw0pywrapfst00arciterator00value methnoargs pyxdoc0pywrapfst00arciterator00value$^  reducecython pycfunctionpyxpw0pywrapfst00arciterator00reducecython methnoargs 0$^  setstatecython pycfunctionpyxpw0pywrapfst00arciterator00setstatecython metho 0$^  0 0 0 0$^$^$^static pytypeobject pyxtype0pywrapfstarciterator  $^  pyvarobjectheadinit0 0$^  pywrapfst.arciterator tpname$^  sizeofstruct pyxobj0pywrapfstarciterator tpbasicsize$^  0 tpitemsize$^  pyxtpdealloc0pywrapfstarciterator tpdealloc$^  0 tpprint$^  0 tpgetattr$^  0 tpsetattr$^  if pymajorversion  0$^  0 tpcompare$^  endif$^  if pymajorversion  0$^  0 tpasasync$^  endif$^  pyxpw0pywrapfst00arciterator0repr tprepr$^  0 tpasnumber$^  0 tpassequence$^  0 tpasmapping$^  0 tphash$^  0 tpcall$^  0 tpstr$^  0 tpgetattro$^  0 tpsetattro$^  0 tpasbuffer$^  pytpflagsdefaultpytpflagshaveversiontagpytpflagschecktypespytpflagshavenewbufferpytpflagsbasetype tpflags$^  n  arciteratorifst statenn  this class is used for iterating over the arcs leaving some state of an fst.n   tpdoc$^  0 tptraverse$^  0 tpclear$^  0 tprichcompare$^  0 tpweaklistoffset$^  pyxpw0pywrapfst00arciterator0iter tpiter$^  pyxpw0pywrapfst00arciterator0next tpiternext$^  pyxmethods0pywrapfstarciterator tpmethods$^  0 tpmembers$^  0 tpgetset$^  0 tpbase$^  0 tpdict$^  0 tpdescrget$^  0 tpdescrset$^  0 tpdictoffset$^  pyxpw0pywrapfst00arciterator0init tpinit$^  0 tpalloc$^  pyxtpnew0pywrapfstarciterator tpnew$^  0 tpfree$^  0 tpisgc$^  0 tpbases$^  0 tpmro$^  0 tpcache$^  0 tpsubclasses$^  0 tpweaklist$^  0 tpdel$^  0 tpversiontag$^  if pyversionhex  0x000000a0$^  0 tpfinalize$^  endif$^$^static struct pyxvtabstruct0pywrapfstmutablearciterator pyxvtable0pywrapfstmutablearciterator$^$^static pyobject pyxtpnew0pywrapfstmutablearciteratorpytypeobject t cythonunused pyobject a cythonunused pyobject k $^  struct pyxobj0pywrapfstmutablearciterator p$^  pyobject o$^  if likelyttpflags  pytpflagsisabstract  0 $^    o  ttpalloct 0$^   else $^    o  pyobject  pybaseobjecttype.tpnewt pyxemptytuple 0$^  $^  if unlikelyo return 0$^  p  struct pyxobj0pywrapfstmutablearciterator o$^  ppyxvtab  pyxvtabptr0pywrapfstmutablearciterator$^  newvoidpmfst stdsharedptrfstscriptmutablefstclass $^  newvoidpaiter stduniqueptrfstscriptmutablearciteratorclass $^  return o$^$^$^static void pyxtpdealloc0pywrapfstmutablearciteratorpyobject o $^  struct pyxobj0pywrapfstmutablearciterator p  struct pyxobj0pywrapfstmutablearciterator o$^  if cythonusetpfinalize$^  if unlikelypytypehasfeaturepytypeo pytpflagshavefinalize  pytypeotpfinalize  pytypeisgcpytypeo  pygcfinalizedo $^    if pyobjectcallfinalizerfromdealloco return$^  $^  endif$^  pyxcalldestructorpmfst$^  pyxcalldestructorpaiter$^  pytypeotpfreeo$^$^$^static pymethoddef pyxmethods0pywrapfstmutablearciterator  $^  done pycfunctionpyxpw0pywrapfst00mutablearciterator0done methnoargs pyxdoc0pywrapfst00mutablearciterator0done$^  flags pycfunctionpyxpw0pywrapfst00mutablearciterator0flags methnoargs pyxdoc0pywrapfst00mutablearciterator0flags$^  next pycfunctionpyxpw0pywrapfst00mutablearciterator0next methnoargs pyxdoc0pywrapfst00mutablearciterator0next$^  position pycfunctionpyxpw0pywrapfst00mutablearciterator00position methnoargs pyxdoc0pywrapfst00mutablearciterator00position$^  reset pycfunctionpyxpw0pywrapfst00mutablearciterator00reset methnoargs pyxdoc0pywrapfst00mutablearciterator00reset$^  seek pycfunctionpyxpw0pywrapfst00mutablearciterator00seek metho pyxdoc0pywrapfst00mutablearciterator00seek$^  setflags pycfunctionpyxpw0pywrapfst00mutablearciterator00setflags methvarargsmethkeywords pyxdoc0pywrapfst00mutablearciterator00setflags$^  setvalue pycfunctionpyxpw0pywrapfst00mutablearciterator00setvalue metho pyxdoc0pywrapfst00mutablearciterator00setvalue$^  value pycfunctionpyxpw0pywrapfst00mutablearciterator00value methnoargs pyxdoc0pywrapfst00mutablearciterator00value$^  reducecython pycfunctionpyxpw0pywrapfst00mutablearciterator00reducecython methnoargs 0$^  setstatecython pycfunctionpyxpw0pywrapfst00mutablearciterator00setstatecython metho 0$^  0 0 0 0$^$^$^static pytypeobject pyxtype0pywrapfstmutablearciterator  $^  pyvarobjectheadinit0 0$^  pywrapfst.mutablearciterator tpname$^  sizeofstruct pyxobj0pywrapfstmutablearciterator tpbasicsize$^  0 tpitemsize$^  pyxtpdealloc0pywrapfstmutablearciterator tpdealloc$^  0 tpprint$^  0 tpgetattr$^  0 tpsetattr$^  if pymajorversion  0$^  0 tpcompare$^  endif$^  if pymajorversion  0$^  0 tpasasync$^  endif$^  pyxpw0pywrapfst00mutablearciterator0repr tprepr$^  0 tpasnumber$^  0 tpassequence$^  0 tpasmapping$^  0 tphash$^  0 tpcall$^  0 tpstr$^  0 tpgetattro$^  0 tpsetattro$^  0 tpasbuffer$^  pytpflagsdefaultpytpflagshaveversiontagpytpflagschecktypespytpflagshavenewbufferpytpflagsbasetype tpflags$^  n  mutablearciteratorifst statenn  this class is used for iterating over the arcs leaving some state of an fstn  also permitting mutation of the current arc.n   tpdoc$^  0 tptraverse$^  0 tpclear$^  0 tprichcompare$^  0 tpweaklistoffset$^  0 tpiter$^  0 tpiternext$^  pyxmethods0pywrapfstmutablearciterator tpmethods$^  0 tpmembers$^  0 tpgetset$^  0 tpbase$^  0 tpdict$^  0 tpdescrget$^  0 tpdescrset$^  0 tpdictoffset$^  pyxpw0pywrapfst00mutablearciterator0init tpinit$^  0 tpalloc$^  pyxtpnew0pywrapfstmutablearciterator tpnew$^  0 tpfree$^  0 tpisgc$^  0 tpbases$^  0 tpmro$^  0 tpcache$^  0 tpsubclasses$^  0 tpweaklist$^  0 tpdel$^  0 tpversiontag$^  if pyversionhex  0x000000a0$^  0 tpfinalize$^  endif$^$^static struct pyxvtabstruct0pywrapfststateiterator pyxvtable0pywrapfststateiterator$^$^static pyobject pyxtpnew0pywrapfststateiteratorpytypeobject t cythonunused pyobject a cythonunused pyobject k $^  struct pyxobj0pywrapfststateiterator p$^  pyobject o$^  if likelyttpflags  pytpflagsisabstract  0 $^    o  ttpalloct 0$^   else $^    o  pyobject  pybaseobjecttype.tpnewt pyxemptytuple 0$^  $^  if unlikelyo return 0$^  p  struct pyxobj0pywrapfststateiterator o$^  ppyxvtab  pyxvtabptr0pywrapfststateiterator$^  newvoidpfst stdsharedptrfstscriptfstclass $^  newvoidpsiter stduniqueptrfstscriptstateiteratorclass $^  return o$^$^$^static void pyxtpdealloc0pywrapfststateiteratorpyobject o $^  struct pyxobj0pywrapfststateiterator p  struct pyxobj0pywrapfststateiterator o$^  if cythonusetpfinalize$^  if unlikelypytypehasfeaturepytypeo pytpflagshavefinalize  pytypeotpfinalize  pytypeisgcpytypeo  pygcfinalizedo $^    if pyobjectcallfinalizerfromdealloco return$^  $^  endif$^  pyxcalldestructorpfst$^  pyxcalldestructorpsiter$^  pytypeotpfreeo$^$^$^static pymethoddef pyxmethods0pywrapfststateiterator  $^  next pycfunctionpyxpw0pywrapfst00stateiterator0next methnoargsmethcoexist 0$^  done pycfunctionpyxpw0pywrapfst00stateiterator0done methnoargs pyxdoc0pywrapfst00stateiterator0done$^  next pycfunctionpyxpw0pywrapfst00stateiterator00next methnoargs pyxdoc0pywrapfst00stateiterator00next$^  reset pycfunctionpyxpw0pywrapfst00stateiterator00reset methnoargs pyxdoc0pywrapfst00stateiterator00reset$^  value pycfunctionpyxpw0pywrapfst00stateiterator00value methnoargs pyxdoc0pywrapfst00stateiterator00value$^  reducecython pycfunctionpyxpw0pywrapfst00stateiterator00reducecython methnoargs 0$^  setstatecython pycfunctionpyxpw0pywrapfst00stateiterator00setstatecython metho 0$^  0 0 0 0$^$^$^static pytypeobject pyxtype0pywrapfststateiterator  $^  pyvarobjectheadinit0 0$^  pywrapfst.stateiterator tpname$^  sizeofstruct pyxobj0pywrapfststateiterator tpbasicsize$^  0 tpitemsize$^  pyxtpdealloc0pywrapfststateiterator tpdealloc$^  0 tpprint$^  0 tpgetattr$^  0 tpsetattr$^  if pymajorversion  0$^  0 tpcompare$^  endif$^  if pymajorversion  0$^  0 tpasasync$^  endif$^  pyxpw0pywrapfst00stateiterator0repr tprepr$^  0 tpasnumber$^  0 tpassequence$^  0 tpasmapping$^  0 tphash$^  0 tpcall$^  0 tpstr$^  0 tpgetattro$^  0 tpsetattro$^  0 tpasbuffer$^  pytpflagsdefaultpytpflagshaveversiontagpytpflagschecktypespytpflagshavenewbufferpytpflagsbasetype tpflags$^  n  stateiteratorifstnn  this class is used for iterating over the states in an fst.n   tpdoc$^  0 tptraverse$^  0 tpclear$^  0 tprichcompare$^  0 tpweaklistoffset$^  pyxpw0pywrapfst00stateiterator0iter tpiter$^  pyxpw0pywrapfst00stateiterator0next tpiternext$^  pyxmethods0pywrapfststateiterator tpmethods$^  0 tpmembers$^  0 tpgetset$^  0 tpbase$^  0 tpdict$^  0 tpdescrget$^  0 tpdescrset$^  0 tpdictoffset$^  pyxpw0pywrapfst00stateiterator0init tpinit$^  0 tpalloc$^  pyxtpnew0pywrapfststateiterator tpnew$^  0 tpfree$^  0 tpisgc$^  0 tpbases$^  0 tpmro$^  0 tpcache$^  0 tpsubclasses$^  0 tpweaklist$^  0 tpdel$^  0 tpversiontag$^  if pyversionhex  0x000000a0$^  0 tpfinalize$^  endif$^$^static struct pyxvtabstruct0pywrapfstcompiler pyxvtable0pywrapfstcompiler$^$^static pyobject pyxtpnew0pywrapfstcompilerpytypeobject t pyobject a pyobject k $^  struct pyxobj0pywrapfstcompiler p$^  pyobject o$^  if likelyttpflags  pytpflagsisabstract  0 $^    o  ttpalloct 0$^   else $^    o  pyobject  pybaseobjecttype.tpnewt pyxemptytuple 0$^  $^  if unlikelyo return 0$^  p  struct pyxobj0pywrapfstcompiler o$^  ppyxvtab  pyxvtabptr0pywrapfstcompiler$^  newvoidpsstrm stduniqueptrstdstringstream $^  newvoidpfsttype stdstring$^  newvoidparctype stdstring$^  if unlikelypyxpw0pywrapfst0compiler0cinito a k  0 goto bad$^  return o$^  bad$^  pydecrefo o  0$^  return null$^$^$^static void pyxtpdealloc0pywrapfstcompilerpyobject o $^  struct pyxobj0pywrapfstcompiler p  struct pyxobj0pywrapfstcompiler o$^  if cythonusetpfinalize$^  if unlikelypytypehasfeaturepytypeo pytpflagshavefinalize  pytypeotpfinalize  pytypeisgcpytypeo  pygcfinalizedo $^    if pyobjectcallfinalizerfromdealloco return$^  $^  endif$^  pyxcalldestructorpsstrm$^  pyxcalldestructorpfsttype$^  pyxcalldestructorparctype$^  pytypeotpfreeo$^$^$^static pymethoddef pyxmethods0pywrapfstcompiler  $^  compile pycfunctionpyxpw0pywrapfst0compiler0compile methnoargs pyxdoc0pywrapfst0compiler0compile$^  write pycfunctionpyxpw0pywrapfst0compiler0write metho pyxdoc0pywrapfst0compiler0write$^  reducecython pycfunctionpyxpw0pywrapfst0compiler0reducecython methnoargs 0$^  setstatecython pycfunctionpyxpw0pywrapfst0compiler0setstatecython metho 0$^  0 0 0 0$^$^$^static pytypeobject pyxtype0pywrapfstcompiler  $^  pyvarobjectheadinit0 0$^  pywrapfst.compiler tpname$^  sizeofstruct pyxobj0pywrapfstcompiler tpbasicsize$^  0 tpitemsize$^  pyxtpdealloc0pywrapfstcompiler tpdealloc$^  0 tpprint$^  0 tpgetattr$^  0 tpsetattr$^  if pymajorversion  0$^  0 tpcompare$^  endif$^  if pymajorversion  0$^  0 tpasasync$^  endif$^  0 tprepr$^  0 tpasnumber$^  0 tpassequence$^  0 tpasmapping$^  0 tphash$^  0 tpcall$^  0 tpstr$^  0 tpgetattro$^  0 tpsetattro$^  0 tpasbuffer$^  pytpflagsdefaultpytpflagshaveversiontagpytpflagschecktypespytpflagshavenewbufferpytpflagsbasetype tpflags$^  n  compilerfsttypevector arctypestandard isymbolsnonen           osymbolsnone ssymbolsnone acceptorfalse keepisymbolsfalsen           keeposymbolsfalse keepstatenumberingfalsen           allownegativelabelsfalsenn  class used to compile fsts from strings.nn  this class is used to compile fsts specified using the att fsm libraryn  format described herenn  httpweb.eecs.umich.eduradevnlpfall0000resourcesfsmarchivefsm.0.htmlnn  this is the same format used by the fstcompile executable.nn  compiler options symbol tables etc. are set at construction time.nn      compiler  fst.compilerisymbolsasciisyms osymbolsasciisymsnn  once constructed compiler instances behave like a file handle opened forn  writingnn       ban      print  compiler 0 0 00 00n      print  compiler 0 0 00 00n      print  compiler 0 0 00 00n      print  compiler 0nn  the compile method returns an actual fst instancenn      sheepmachine  compiler.compilenn  compilation flushes the internal buffer so the compiler instance can ben  reused to compile new machines with the same symbol tables etc.nn  argsn    fsttype a string indicating the container type for the compiled fst.n    arctype a string indicating the arc type for the compiled fst.n    isymbols an optional symboltable used to label input symbols.n    osymbols an optional symboltable used to label output symbols.n    ssymbols an optional symboltable used to label states.n    acceptor should the fst be rendered in acceptor format if possiblen    keepisymbols should the input symbol table be stored in the fstn    keeposymbols should the output symbol table be stored in the fstn    keepstatenumbering should the state numbering be preservedn    allownegativelabels should negative labels be allowed notn        recommended may cause conflicts.n   tpdoc$^  0 tptraverse$^  0 tpclear$^  0 tprichcompare$^  0 tpweaklistoffset$^  0 tpiter$^  0 tpiternext$^  pyxmethods0pywrapfstcompiler tpmethods$^  0 tpmembers$^  0 tpgetset$^  0 tpbase$^  0 tpdict$^  0 tpdescrget$^  0 tpdescrset$^  0 tpdictoffset$^  0 tpinit$^  0 tpalloc$^  pyxtpnew0pywrapfstcompiler tpnew$^  0 tpfree$^  0 tpisgc$^  0 tpbases$^  0 tpmro$^  0 tpcache$^  0 tpsubclasses$^  0 tpweaklist$^  0 tpdel$^  0 tpversiontag$^  if pyversionhex  0x000000a0$^  0 tpfinalize$^  endif$^$^static struct pyxvtabstruct0pywrapfstfarreader pyxvtable0pywrapfstfarreader$^$^static pyobject pyxtpnew0pywrapfstfarreaderpytypeobject t cythonunused pyobject a cythonunused pyobject k $^  struct pyxobj0pywrapfstfarreader p$^  pyobject o$^  if likelyttpflags  pytpflagsisabstract  0 $^    o  ttpalloct 0$^   else $^    o  pyobject  pybaseobjecttype.tpnewt pyxemptytuple 0$^  $^  if unlikelyo return 0$^  p  struct pyxobj0pywrapfstfarreader o$^  ppyxvtab  pyxvtabptr0pywrapfstfarreader$^  newvoidpreader stduniqueptrfstscriptfarreaderclass $^  return o$^$^$^static void pyxtpdealloc0pywrapfstfarreaderpyobject o $^  struct pyxobj0pywrapfstfarreader p  struct pyxobj0pywrapfstfarreader o$^  if cythonusetpfinalize$^  if unlikelypytypehasfeaturepytypeo pytpflagshavefinalize  pytypeotpfinalize  pytypeisgcpytypeo  pygcfinalizedo $^    if pyobjectcallfinalizerfromdealloco return$^  $^  endif$^  pyxcalldestructorpreader$^  pytypeotpfreeo$^$^static pyobject pyxsqitem0pywrapfstfarreaderpyobject o pyssizet i $^  pyobject r$^  pyobject x  pyintfromssizeti ifx return 0$^  r  pytypeotpasmappingmpsubscripto x$^  pydecrefx$^  return r$^$^$^static pymethoddef pyxmethods0pywrapfstfarreader  $^  open pycfunctionpyxpw0pywrapfst0farreader0open methvarargsmethkeywords pyxdoc0pywrapfst0farreader0open$^  arctype pycfunctionpyxpw0pywrapfst0farreader0arctype methnoargs pyxdoc0pywrapfst0farreader0arctype$^  done pycfunctionpyxpw0pywrapfst0farreader0done methnoargs pyxdoc0pywrapfst0farreader0done$^  error pycfunctionpyxpw0pywrapfst0farreader00error methnoargs pyxdoc0pywrapfst0farreader00error$^  fartype pycfunctionpyxpw0pywrapfst0farreader00fartype methnoargs 0$^  find pycfunctionpyxpw0pywrapfst0farreader00find metho pyxdoc0pywrapfst0farreader00find$^  getfst pycfunctionpyxpw0pywrapfst0farreader00getfst methnoargs pyxdoc0pywrapfst0farreader00getfst$^  getkey pycfunctionpyxpw0pywrapfst0farreader00getkey methnoargs pyxdoc0pywrapfst0farreader00getkey$^  next pycfunctionpyxpw0pywrapfst0farreader00next methnoargs pyxdoc0pywrapfst0farreader00next$^  reset pycfunctionpyxpw0pywrapfst0farreader00reset methnoargs pyxdoc0pywrapfst0farreader00reset$^  reducecython pycfunctionpyxpw0pywrapfst0farreader00reducecython methnoargs 0$^  setstatecython pycfunctionpyxpw0pywrapfst0farreader00setstatecython metho 0$^  0 0 0 0$^$^$^static pysequencemethods pyxtpassequencefarreader  $^  0 sqlength$^  0 sqconcat$^  0 sqrepeat$^  pyxsqitem0pywrapfstfarreader sqitem$^  0 sqslice$^  0 sqassitem$^  0 sqassslice$^  0 sqcontains$^  0 sqinplaceconcat$^  0 sqinplacerepeat$^$^$^static pymappingmethods pyxtpasmappingfarreader  $^  0 mplength$^  pyxpw0pywrapfst0farreader00getitem mpsubscript$^  0 mpasssubscript$^$^$^static pytypeobject pyxtype0pywrapfstfarreader  $^  pyvarobjectheadinit0 0$^  pywrapfst.farreader tpname$^  sizeofstruct pyxobj0pywrapfstfarreader tpbasicsize$^  0 tpitemsize$^  pyxtpdealloc0pywrapfstfarreader tpdealloc$^  0 tpprint$^  0 tpgetattr$^  0 tpsetattr$^  if pymajorversion  0$^  0 tpcompare$^  endif$^  if pymajorversion  0$^  0 tpasasync$^  endif$^  pyxpw0pywrapfst0farreader0repr tprepr$^  0 tpasnumber$^  pyxtpassequencefarreader tpassequence$^  pyxtpasmappingfarreader tpasmapping$^  0 tphash$^  0 tpcall$^  0 tpstr$^  0 tpgetattro$^  0 tpsetattro$^  0 tpasbuffer$^  pytpflagsdefaultpytpflagshaveversiontagpytpflagschecktypespytpflagshavenewbufferpytpflagsbasetype tpflags$^  n  no constructor.nn  far fst archive reader object.nn  this class is used to read a far from disk. fars contain one or more fsts ofn  the same arc type indexed by a unique string key. to construct a farreadern  object use the open class method.nn  attributesn    arctype a string indicating the arc type.n    fartype a string indicating the far type.n   tpdoc$^  0 tptraverse$^  0 tpclear$^  0 tprichcompare$^  0 tpweaklistoffset$^  0 tpiter$^  0 tpiternext$^  pyxmethods0pywrapfstfarreader tpmethods$^  0 tpmembers$^  0 tpgetset$^  0 tpbase$^  0 tpdict$^  0 tpdescrget$^  0 tpdescrset$^  0 tpdictoffset$^  pyxpw0pywrapfst0farreader0init tpinit$^  0 tpalloc$^  pyxtpnew0pywrapfstfarreader tpnew$^  0 tpfree$^  0 tpisgc$^  0 tpbases$^  0 tpmro$^  0 tpcache$^  0 tpsubclasses$^  0 tpweaklist$^  0 tpdel$^  0 tpversiontag$^  if pyversionhex  0x000000a0$^  0 tpfinalize$^  endif$^$^static struct pyxvtabstruct0pywrapfstfarwriter pyxvtable0pywrapfstfarwriter$^$^static pyobject pyxtpnew0pywrapfstfarwriterpytypeobject t cythonunused pyobject a cythonunused pyobject k $^  struct pyxobj0pywrapfstfarwriter p$^  pyobject o$^  if likelyttpflags  pytpflagsisabstract  0 $^    o  ttpalloct 0$^   else $^    o  pyobject  pybaseobjecttype.tpnewt pyxemptytuple 0$^  $^  if unlikelyo return 0$^  p  struct pyxobj0pywrapfstfarwriter o$^  ppyxvtab  pyxvtabptr0pywrapfstfarwriter$^  newvoidpwriter stduniqueptrfstscriptfarwriterclass $^  return o$^$^$^static void pyxtpdealloc0pywrapfstfarwriterpyobject o $^  struct pyxobj0pywrapfstfarwriter p  struct pyxobj0pywrapfstfarwriter o$^  if cythonusetpfinalize$^  if unlikelypytypehasfeaturepytypeo pytpflagshavefinalize  pytypeotpfinalize  pytypeisgcpytypeo  pygcfinalizedo $^    if pyobjectcallfinalizerfromdealloco return$^  $^  endif$^  pyxcalldestructorpwriter$^  pytypeotpfreeo$^$^$^static int pyxmpasssubscript0pywrapfstfarwriterpyobject o pyobject i pyobject v $^  if v $^    return pyxpw0pywrapfst0farwriter00setitemo i v$^  $^  else $^    pyerrformatpyexcnotimplementederror$^      subscript deletion not supported by .000s pytypeotpname$^    return 0$^  $^$^$^static pymethoddef pyxmethods0pywrapfstfarwriter  $^  create pycfunctionpyxpw0pywrapfst0farwriter0create methvarargsmethkeywords pyxdoc0pywrapfst0farwriter0create$^  add pycfunctionpyxpw0pywrapfst0farwriter0add methvarargsmethkeywords pyxdoc0pywrapfst0farwriter0add$^  arctype pycfunctionpyxpw0pywrapfst0farwriter0arctype methnoargs pyxdoc0pywrapfst0farwriter0arctype$^  error pycfunctionpyxpw0pywrapfst0farwriter00error methnoargs pyxdoc0pywrapfst0farwriter00error$^  fartype pycfunctionpyxpw0pywrapfst0farwriter00fartype methnoargs pyxdoc0pywrapfst0farwriter00fartype$^  reducecython pycfunctionpyxpw0pywrapfst0farwriter00reducecython methnoargs 0$^  setstatecython pycfunctionpyxpw0pywrapfst0farwriter00setstatecython metho 0$^  0 0 0 0$^$^$^static pymappingmethods pyxtpasmappingfarwriter  $^  0 mplength$^  0 mpsubscript$^  pyxmpasssubscript0pywrapfstfarwriter mpasssubscript$^$^$^static pytypeobject pyxtype0pywrapfstfarwriter  $^  pyvarobjectheadinit0 0$^  pywrapfst.farwriter tpname$^  sizeofstruct pyxobj0pywrapfstfarwriter tpbasicsize$^  0 tpitemsize$^  pyxtpdealloc0pywrapfstfarwriter tpdealloc$^  0 tpprint$^  0 tpgetattr$^  0 tpsetattr$^  if pymajorversion  0$^  0 tpcompare$^  endif$^  if pymajorversion  0$^  0 tpasasync$^  endif$^  pyxpw0pywrapfst0farwriter0repr tprepr$^  0 tpasnumber$^  0 tpassequence$^  pyxtpasmappingfarwriter tpasmapping$^  0 tphash$^  0 tpcall$^  0 tpstr$^  0 tpgetattro$^  0 tpsetattro$^  0 tpasbuffer$^  pytpflagsdefaultpytpflagshaveversiontagpytpflagschecktypespytpflagshavenewbufferpytpflagsbasetype tpflags$^  n  no constructor.nn  far fst archive writer object.nn  this class is used to write fsts of the same arc type to a far on disk. ton  construct a farwriter use the create class method.nn  note that the data is not guaranteed to flush to disk until the farwritern  is garbagecollected. if a farwriter has been assigned to only one variablen  then calling del on that variable should decrement the objects referencen  count from 0 to 0 triggering a flush to disk on the next gc cycle.nn  attributesn    arctype a string indicating the arc type.n    fartype a string indicating the far type.n   tpdoc$^  0 tptraverse$^  0 tpclear$^  0 tprichcompare$^  0 tpweaklistoffset$^  0 tpiter$^  0 tpiternext$^  pyxmethods0pywrapfstfarwriter tpmethods$^  0 tpmembers$^  0 tpgetset$^  0 tpbase$^  0 tpdict$^  0 tpdescrget$^  0 tpdescrset$^  0 tpdictoffset$^  pyxpw0pywrapfst0farwriter0init tpinit$^  0 tpalloc$^  pyxtpnew0pywrapfstfarwriter tpnew$^  0 tpfree$^  0 tpisgc$^  0 tpbases$^  0 tpmro$^  0 tpcache$^  0 tpsubclasses$^  0 tpweaklist$^  0 tpdel$^  0 tpversiontag$^  if pyversionhex  0x000000a0$^  0 tpfinalize$^  endif$^$^$^static pymethoddef pyxmethods  $^  compactsymboltable pycfunctionpyxpw0pywrapfst0compactsymboltable metho pyxdoc0pywrapfst0compactsymboltable$^  mergesymboltable pycfunctionpyxpw0pywrapfst00mergesymboltable methvarargsmethkeywords pyxdoc0pywrapfst00mergesymboltable$^  read pycfunctionpyxpw0pywrapfst00read metho 0$^  readfromstring pycfunctionpyxpw0pywrapfst00readfromstring metho 0$^  arcmap pycfunctionpyxpw0pywrapfst00arcmap methvarargsmethkeywords pyxdoc0pywrapfst00arcmap$^  compose pycfunctionpyxpw0pywrapfst00compose methvarargsmethkeywords pyxdoc0pywrapfst00compose$^  convert pycfunctionpyxpw0pywrapfst00convert methvarargsmethkeywords pyxdoc0pywrapfst00convert$^  determinize pycfunctionpyxpw0pywrapfst00determinize methvarargsmethkeywords pyxdoc0pywrapfst00determinize$^  difference pycfunctionpyxpw0pywrapfst00difference methvarargsmethkeywords pyxdoc0pywrapfst00difference$^  disambiguate pycfunctionpyxpw0pywrapfst00disambiguate methvarargsmethkeywords pyxdoc0pywrapfst00disambiguate$^  epsnormalize pycfunctionpyxpw0pywrapfst00epsnormalize methvarargsmethkeywords pyxdoc0pywrapfst00epsnormalize$^  equal pycfunctionpyxpw0pywrapfst00equal methvarargsmethkeywords pyxdoc0pywrapfst00equal$^  equivalent pycfunctionpyxpw0pywrapfst00equivalent methvarargsmethkeywords pyxdoc0pywrapfst00equivalent$^  intersect pycfunctionpyxpw0pywrapfst00intersect methvarargsmethkeywords pyxdoc0pywrapfst00intersect$^  isomorphic pycfunctionpyxpw0pywrapfst00isomorphic methvarargsmethkeywords pyxdoc0pywrapfst00isomorphic$^  prune pycfunctionpyxpw0pywrapfst00prune methvarargsmethkeywords pyxdoc0pywrapfst00prune$^  push pycfunctionpyxpw0pywrapfst00push methvarargsmethkeywords pyxdoc0pywrapfst00push$^  randequivalent pycfunctionpyxpw0pywrapfst00randequivalent methvarargsmethkeywords pyxdoc0pywrapfst00randequivalent$^  randgen pycfunctionpyxpw0pywrapfst00randgen methvarargsmethkeywords pyxdoc0pywrapfst00randgen$^  replace pycfunctionpyxpw0pywrapfst00replace methvarargsmethkeywords pyxdoc0pywrapfst00replace$^  reverse pycfunctionpyxpw0pywrapfst00reverse methvarargsmethkeywords pyxdoc0pywrapfst00reverse$^  shortestpath pycfunctionpyxpw0pywrapfst00shortestpath methvarargsmethkeywords pyxdoc0pywrapfst00shortestpath$^  statemap pycfunctionpyxpw0pywrapfst00statemap methvarargsmethkeywords pyxdoc0pywrapfst00statemap$^  synchronize pycfunctionpyxpw0pywrapfst00synchronize metho pyxdoc0pywrapfst00synchronize$^  0 0 0 0$^$^$^if pymajorversion  0$^if cythonpep000multiphaseinit$^static pyobject pyxpymodcreatepyobject spec pymoduledef def proto$^static int pyxpymodexecpywrapfstpyobject module proto$^static pymoduledefslot pyxmoduledefslots  $^  pymodcreate voidpyxpymodcreate$^  pymodexec voidpyxpymodexecpywrapfst$^  0 null$^$^endif$^$^static struct pymoduledef pyxmoduledef  $^    pymoduledefheadinit$^    pywrapfst$^    pyxkpythoninterfacetothefstscri  mdoc $^  if cythonpep000multiphaseinit$^    0  msize $^  else$^    0  msize $^  endif$^    pyxmethods  mmethods $^  if cythonpep000multiphaseinit$^    pyxmoduledefslots  mslots $^  else$^    null  mreload $^  endif$^    null  mtraverse $^    null  mclear $^    null  mfree $^$^endif$^$^static pyxstringtabentry pyxstringtab  $^  pyxnsacceptor pyxkacceptor sizeofpyxkacceptor 0 0 0 0$^  pyxnsaccessible pyxkaccessible sizeofpyxkaccessible 0 0 0 0$^  pyxnsacyclic pyxkacyclic sizeofpyxkacyclic 0 0 0 0$^  pyxnsaddarcproperties pyxkaddarcproperties sizeofpyxkaddarcproperties 0 0 0 0$^  pyxnsaddstateproperties pyxkaddstateproperties sizeofpyxkaddstateproperties 0 0 0 0$^  pyxnsaddsuperfinalproperties pyxkaddsuperfinalproperties sizeofpyxkaddsuperfinalproperties 0 0 0 0$^  pyxnsarcflags pyxkarcflags sizeofpyxkarcflags 0 0 0 0$^  pyxnsarcilabelvalue pyxkarcilabelvalue sizeofpyxkarcilabelvalue 0 0 0 0$^  pyxnsarcnextstatevalue pyxkarcnextstatevalue sizeofpyxkarcnextstatevalue 0 0 0 0$^  pyxnsarcnocache pyxkarcnocache sizeofpyxkarcnocache 0 0 0 0$^  pyxnsarcolabelvalue pyxkarcolabelvalue sizeofpyxkarcolabelvalue 0 0 0 0$^  pyxnsarcsortproperties pyxkarcsortproperties sizeofpyxkarcsortproperties 0 0 0 0$^  pyxnsarcvalueflags pyxkarcvalueflags sizeofpyxkarcvalueflags 0 0 0 0$^  pyxnsarcweightvalue pyxkarcweightvalue sizeofpyxkarcweightvalue 0 0 0 0$^  pyxkpsarciteratorat0xx pyxkarciteratorat0xx sizeofpyxkarciteratorat0xx 0 0 0 0$^  pyxkpsarcat0xx pyxkarcat0xx sizeofpyxkarcat0xx 0 0 0 0$^  pyxnsbinaryproperties pyxkbinaryproperties sizeofpyxkbinaryproperties 0 0 0 0$^  pyxnscoaccessible pyxkcoaccessible sizeofpyxkcoaccessible 0 0 0 0$^  pyxnscopyproperties pyxkcopyproperties sizeofpyxkcopyproperties 0 0 0 0$^  pyxnscyclic pyxkcyclic sizeofpyxkcyclic 0 0 0 0$^  pyxnscalledprocesserror pyxkcalledprocesserror sizeofpyxkcalledprocesserror 0 0 0 0$^  pyxkpscannotconstruct pyxkcannotconstruct sizeofpyxkcannotconstruct 0 0 0 0$^  pyxkpscannotencodeasstringr pyxkcannotencodeasstringr sizeofpyxkcannotencodeasstringr 0 0 0 0$^  pyxkpscannottopsortcyclicfst pyxkcannottopsortcyclicfst sizeofpyxkcannottopsortcyclicfst 0 0 0 0$^  pyxkpscompilationfailed pyxkcompilationfailed sizeofpyxkcompilationfailed 0 0 0 0$^  pyxkpsconversiontorfailed pyxkconversiontorfailed sizeofpyxkconversiontorfailed 0 0 0 0$^  pyxnsdeletearcproperties pyxkdeletearcproperties sizeofpyxkdeletearcproperties 0 0 0 0$^  pyxnsdeletestateproperties pyxkdeletestateproperties sizeofpyxkdeletestateproperties 0 0 0 0$^  pyxnsdottsvg pyxkdottsvg sizeofpyxkdottsvg 0 0 0 0$^  pyxnsencodeflags pyxkencodeflags sizeofpyxkencodeflags 0 0 0 0$^  pyxnsencodelabels pyxkencodelabels sizeofpyxkencodelabels 0 0 0 0$^  pyxnsencodeweights pyxkencodeweights sizeofpyxkencodeweights 0 0 0 0$^  pyxnsepsilons pyxkepsilons sizeofpyxkepsilons 0 0 0 0$^  pyxnserror pyxkerror sizeofpyxkerror 0 0 0 0$^  pyxnsexpanded pyxkexpanded sizeofpyxkexpanded 0 0 0 0$^  pyxnsextrinsicproperties pyxkextrinsicproperties sizeofpyxkextrinsicproperties 0 0 0 0$^  pyxkpsencodemapperat0xx pyxkencodemapperat0xx sizeofpyxkencodemapperat0xx 0 0 0 0$^  pyxnsfstproperties pyxkfstproperties sizeofpyxkfstproperties 0 0 0 0$^  pyxkpsfarreaderat0xx pyxkfarreaderat0xx sizeofpyxkfarreaderat0xx 0 0 0 0$^  pyxkpsfarwriterat0xx pyxkfarwriterat0xx sizeofpyxkfarwriterat0xx 0 0 0 0$^  pyxnsfst pyxkfst sizeofpyxkfst 0 0 0 0$^  pyxnsfstargerror pyxkfstargerror sizeofpyxkfstargerror 0 0 0 0$^  pyxnsfstbadweighterror pyxkfstbadweighterror sizeofpyxkfstbadweighterror 0 0 0 0$^  pyxnsfstdeletedconstructorerror pyxkfstdeletedconstructorerror sizeofpyxkfstdeletedconstructorerror 0 0 0 0$^  pyxnsfsterror pyxkfsterror sizeofpyxkfsterror 0 0 0 0$^  pyxnsfstioerror pyxkfstioerror sizeofpyxkfstioerror 0 0 0 0$^  pyxnsfstindexerror pyxkfstindexerror sizeofpyxkfstindexerror 0 0 0 0$^  pyxnsfstoperror pyxkfstoperror sizeofpyxkfstoperror 0 0 0 0$^  pyxkpsfstsymboltablerat0xx pyxkfstsymboltablerat0xx sizeofpyxkfstsymboltablerat0xx 0 0 0 0$^  pyxnsfstnew pyxkfstnew sizeofpyxkfstnew 0 0 0 0$^  pyxkpsfstarctypestandardconstruct pyxkfstarctypestandardconstruct sizeofpyxkfstarctypestandardconstruct 0 0 0 0$^  pyxkpsfstat0xx pyxkfstat0xx sizeofpyxkfstat0xx 0 0 0 0$^  pyxnsfstread pyxkfstread sizeofpyxkfstread 0 0 0 0$^  pyxnsfstreadfromstring pyxkfstreadfromstring sizeofpyxkfstreadfromstring 0 0 0 0$^  pyxnsinitialacyclic pyxkinitialacyclic sizeofpyxkinitialacyclic 0 0 0 0$^  pyxnsinitialcyclic pyxkinitialcyclic sizeofpyxkinitialcyclic 0 0 0 0$^  pyxnsintrinsicproperties pyxkintrinsicproperties sizeofpyxkintrinsicproperties 0 0 0 0$^  pyxnsioerror pyxkioerror sizeofpyxkioerror 0 0 0 0$^  pyxnsideterministic pyxkideterministic sizeofpyxkideterministic 0 0 0 0$^  pyxnsiepsilons pyxkiepsilons sizeofpyxkiepsilons 0 0 0 0$^  pyxnsilabelinvariantproperties pyxkilabelinvariantproperties sizeofpyxkilabelinvariantproperties 0 0 0 0$^  pyxnsilabelsorted pyxkilabelsorted sizeofpyxkilabelsorted 0 0 0 0$^  pyxkpsincompatibleorinvalidarctype pyxkincompatibleorinvalidarctype sizeofpyxkincompatibleorinvalidarctype 0 0 0 0$^  pyxkpsincompatibleorinvalidweight pyxkincompatibleorinvalidweight sizeofpyxkincompatibleorinvalidweight 0 0 0 0$^  pyxkpsincompatibleorinvalidweightt pyxkincompatibleorinvalidweightt sizeofpyxkincompatibleorinvalidweightt 0 0 0 0$^  pyxnsindexerror pyxkindexerror sizeofpyxkindexerror 0 0 0 0$^  pyxkpsinvalidweight pyxkinvalidweight sizeofpyxkinvalidweight 0 0 0 0$^  pyxnskeyerror pyxkkeyerror sizeofpyxkkeyerror 0 0 0 0$^  pyxkpskeyoutoforder pyxkkeyoutoforder sizeofpyxkkeyoutoforder 0 0 0 0$^  pyxnsmutable pyxkmutable sizeofpyxkmutable 0 0 0 0$^  pyxkpsmutablearciteratorat0xx pyxkmutablearciteratorat0xx sizeofpyxkmutablearciteratorat0xx 0 0 0 0$^  pyxnsnegtrinaryproperties pyxknegtrinaryproperties sizeofpyxknegtrinaryproperties 0 0 0 0$^  pyxnsnonideterministic pyxknonideterministic sizeofpyxknonideterministic 0 0 0 0$^  pyxnsnonodeterministic pyxknonodeterministic sizeofpyxknonodeterministic 0 0 0 0$^  pyxnsnotacceptor pyxknotacceptor sizeofpyxknotacceptor 0 0 0 0$^  pyxnsnotaccessible pyxknotaccessible sizeofpyxknotaccessible 0 0 0 0$^  pyxnsnotcoaccessible pyxknotcoaccessible sizeofpyxknotcoaccessible 0 0 0 0$^  pyxnsnotilabelsorted pyxknotilabelsorted sizeofpyxknotilabelsorted 0 0 0 0$^  pyxnsnotolabelsorted pyxknotolabelsorted sizeofpyxknotolabelsorted 0 0 0 0$^  pyxnsnotstring pyxknotstring sizeofpyxknotstring 0 0 0 0$^  pyxnsnottopsorted pyxknottopsorted sizeofpyxknottopsorted 0 0 0 0$^  pyxnsnoepsilons pyxknoepsilons sizeofpyxknoepsilons 0 0 0 0$^  pyxnsnoiepsilons pyxknoiepsilons sizeofpyxknoiepsilons 0 0 0 0$^  pyxnsnolabel pyxknolabel sizeofpyxknolabel 0 0 0 0$^  pyxnsnooepsilons pyxknooepsilons sizeofpyxknooepsilons 0 0 0 0$^  pyxnsnostateid pyxknostateid sizeofpyxknostateid 0 0 0 0$^  pyxnsnosymbol pyxknosymbol sizeofpyxknosymbol 0 0 0 0$^  pyxnsnullproperties pyxknullproperties sizeofpyxknullproperties 0 0 0 0$^  pyxnsnoweight pyxknoweight sizeofpyxknoweight 0 0 0 0$^  pyxkpsnonewsymboltablesspecified pyxknonewsymboltablesspecified sizeofpyxknonewsymboltablesspecified 0 0 0 0$^  pyxkpsnorelabelingpairsspecified pyxknorelabelingpairsspecified sizeofpyxknorelabelingpairsspecified 0 0 0 0$^  pyxnsnumber pyxknumber sizeofpyxknumber 0 0 0 0$^  pyxnsodeterministic pyxkodeterministic sizeofpyxkodeterministic 0 0 0 0$^  pyxnsoepsilons pyxkoepsilons sizeofpyxkoepsilons 0 0 0 0$^  pyxnsolabelinvariantproperties pyxkolabelinvariantproperties sizeofpyxkolabelinvariantproperties 0 0 0 0$^  pyxnsolabelsorted pyxkolabelsorted sizeofpyxkolabelsorted 0 0 0 0$^  pyxnsone pyxkone sizeofpyxkone 0 0 0 0$^  pyxkpsopenfailedr pyxkopenfailedr sizeofpyxkopenfailedr 0 0 0 0$^  pyxkpsoperationfailed pyxkoperationfailed sizeofpyxkoperationfailed 0 0 0 0$^  pyxnspipe pyxkpipe sizeofpyxkpipe 0 0 0 0$^  pyxnspostrinaryproperties pyxkpostrinaryproperties sizeofpyxkpostrinaryproperties 0 0 0 0$^  pyxnspopen pyxkpopen sizeofpyxkpopen 0 0 0 0$^  pyxnsrmsuperfinalproperties pyxkrmsuperfinalproperties sizeofpyxkrmsuperfinalproperties 0 0 0 0$^  pyxkpsreadfailedr pyxkreadfailedr sizeofpyxkreadfailedr 0 0 0 0$^  pyxkpsreadfailedstring pyxkreadfailedstring sizeofpyxkreadfailedstring 0 0 0 0$^  pyxnsruntimeerror pyxkruntimeerror sizeofpyxkruntimeerror 0 0 0 0$^  pyxnssetarcproperties pyxksetarcproperties sizeofpyxksetarcproperties 0 0 0 0$^  pyxnssetfinalproperties pyxksetfinalproperties sizeofpyxksetfinalproperties 0 0 0 0$^  pyxnssetstartproperties pyxksetstartproperties sizeofpyxksetstartproperties 0 0 0 0$^  pyxnsstatesortproperties pyxkstatesortproperties sizeofpyxkstatesortproperties 0 0 0 0$^  pyxnsstring pyxkstring sizeofpyxkstring 0 0 0 0$^  pyxkpsstateiteratorat0xx pyxkstateiteratorat0xx sizeofpyxkstateiteratorat0xx 0 0 0 0$^  pyxkpsstateindexoutofrange pyxkstateindexoutofrange sizeofpyxkstateindexoutofrange 0 0 0 0$^  pyxnsstopiteration pyxkstopiteration sizeofpyxkstopiteration 0 0 0 0$^  pyxkpssymboltableiteratorat0xx pyxksymboltableiteratorat0xx sizeofpyxksymboltableiteratorat0xx 0 0 0 0$^  pyxkpssymboltablerat0xx pyxksymboltablerat0xx sizeofpyxksymboltablerat0xx 0 0 0 0$^  pyxnstopsorted pyxktopsorted sizeofpyxktopsorted 0 0 0 0$^  pyxnstrinaryproperties pyxktrinaryproperties sizeofpyxktrinaryproperties 0 0 0 0$^  pyxkpstsvg pyxktsvg sizeofpyxktsvg 0 0 0 0$^  pyxnstypeerror pyxktypeerror sizeofpyxktypeerror 0 0 0 0$^  pyxnsunweighted pyxkunweighted sizeofpyxkunweighted 0 0 0 0$^  pyxnsunweightedcycles pyxkunweightedcycles sizeofpyxkunweightedcycles 0 0 0 0$^  pyxkpsunknownarctyper pyxkunknownarctyper sizeofpyxkunknownarctyper 0 0 0 0$^  pyxkpsunknowncomposefiltertyper pyxkunknowncomposefiltertyper sizeofpyxkunknowncomposefiltertyper 0 0 0 0$^  pyxkpsunknowndeterminizationtyper pyxkunknowndeterminizationtyper sizeofpyxkunknowndeterminizationtyper 0 0 0 0$^  pyxkpsunknownmaptyper pyxkunknownmaptyper sizeofpyxkunknownmaptyper 0 0 0 0$^  pyxkpsunknownqueuetyper pyxkunknownqueuetyper sizeofpyxkunknownqueuetyper 0 0 0 0$^  pyxkpsunknownrandomarcselectiontyp pyxkunknownrandomarcselectiontyp sizeofpyxkunknownrandomarcselectiontyp 0 0 0 0$^  pyxkpsunknownreplacelabeltyper pyxkunknownreplacelabeltyper sizeofpyxkunknownreplacelabeltyper 0 0 0 0$^  pyxkpsunknownsorttyper pyxkunknownsorttyper sizeofpyxkunknownsorttyper 0 0 0 0$^  pyxnsvalueerror pyxkvalueerror sizeofpyxkvalueerror 0 0 0 0$^  pyxnsweighted pyxkweighted sizeofpyxkweighted 0 0 0 0$^  pyxnsweightedcycles pyxkweightedcycles sizeofpyxkweightedcycles 0 0 0 0$^  pyxnsweightinvariantproperties pyxkweightinvariantproperties sizeofpyxkweightinvariantproperties 0 0 0 0$^  pyxkpsweightat0xx pyxkweightat0xx sizeofpyxkweightat0xx 0 0 0 0$^  pyxkpsweighttypenotfound pyxkweighttypenotfound sizeofpyxkweighttypenotfound 0 0 0 0$^  pyxkpswritefailedr pyxkwritefailedr sizeofpyxkwritefailedr 0 0 0 0$^  pyxkpswritetostringfailed pyxkwritetostringfailed sizeofpyxkwritetostringfailed 0 0 0 0$^  pyxnszero pyxkzero sizeofpyxkzero 0 0 0 0$^  pyxkpb00 pyxk00 sizeofpyxk00 0 0 0 0$^  pyxnsacceptor pyxkacceptor sizeofpyxkacceptor 0 0 0 0$^  pyxnsadd pyxkadd sizeofpyxkadd 0 0 0 0$^  pyxnsaddstate pyxkaddstate sizeofpyxkaddstate 0 0 0 0$^  pyxnsaddsymbol pyxkaddsymbol sizeofpyxkaddsymbol 0 0 0 0$^  pyxnsaddtable pyxkaddtable sizeofpyxkaddtable 0 0 0 0$^  pyxnsallownegativelabels pyxkallownegativelabels sizeofpyxkallownegativelabels 0 0 0 0$^  pyxnsallownondet pyxkallownondet sizeofpyxkallownondet 0 0 0 0$^  pyxnsarc pyxkarc sizeofpyxkarc 0 0 0 0$^  pyxnsarctype pyxkarctype sizeofpyxkarctype 0 0 0 0$^  pyxnsarcs pyxkarcs sizeofpyxkarcs 0 0 0 0$^  pyxnsatexit pyxkatexit sizeofpyxkatexit 0 0 0 0$^  pyxnsattachnewisymbols pyxkattachnewisymbols sizeofpyxkattachnewisymbols 0 0 0 0$^  pyxnsattachnewosymbols pyxkattachnewosymbols sizeofpyxkattachnewosymbols 0 0 0 0$^  pyxnbauto pyxkauto sizeofpyxkauto 0 0 0 0$^  pyxnsavailablekey pyxkavailablekey sizeofpyxkavailablekey 0 0 0 0$^  pyxnscallarclabeling pyxkcallarclabeling sizeofpyxkcallarclabeling 0 0 0 0$^  pyxnschecksum pyxkchecksum sizeofpyxkchecksum 0 0 0 0$^  pyxnsclass pyxkclass sizeofpyxkclass 0 0 0 0$^  pyxnsclineintraceback pyxkclineintraceback sizeofpyxkclineintraceback 0 0 0 0$^  pyxnsclosureplus pyxkclosureplus sizeofpyxkclosureplus 0 0 0 0$^  pyxnscls pyxkcls sizeofpyxkcls 0 0 0 0$^  pyxnscommunicate pyxkcommunicate sizeofpyxkcommunicate 0 0 0 0$^  pyxnscompile pyxkcompile sizeofpyxkcompile 0 0 0 0$^  pyxnscomposefilter pyxkcomposefilter sizeofpyxkcomposefilter 0 0 0 0$^  pyxnsconnect pyxkconnect sizeofpyxkconnect 0 0 0 0$^  pyxkpsconstencodemappersymboltable pyxkconstencodemappersymboltable sizeofpyxkconstencodemappersymboltable 0 0 0 0$^  pyxkpsconstfstsymboltablerat0xx pyxkconstfstsymboltablerat0xx sizeofpyxkconstfstsymboltablerat0xx 0 0 0 0$^  pyxnscopy pyxkcopy sizeofpyxkcopy 0 0 0 0$^  pyxnscreate pyxkcreate sizeofpyxkcreate 0 0 0 0$^  pyxnsdecode pyxkdecode sizeofpyxkdecode 0 0 0 0$^  pyxnbdefault pyxkdefault sizeofpyxkdefault 0 0 0 0$^  pyxnsdelta pyxkdelta sizeofpyxkdelta 0 0 0 0$^  pyxnsdettype pyxkdettype sizeofpyxkdettype 0 0 0 0$^  pyxnsdistance pyxkdistance sizeofpyxkdistance 0 0 0 0$^  pyxnsdivide pyxkdivide sizeofpyxkdivide 0 0 0 0$^  pyxnsdoc pyxkdoc sizeofpyxkdoc 0 0 0 0$^  pyxnsdone pyxkdone sizeofpyxkdone 0 0 0 0$^  pyxnsdot pyxkdot sizeofpyxkdot 0 0 0 0$^  pyxnsdraw pyxkdraw sizeofpyxkdraw 0 0 0 0$^  pyxnsencode pyxkencode sizeofpyxkencode 0 0 0 0$^  pyxnsencodelabels pyxkencodelabels sizeofpyxkencodelabels 0 0 0 0$^  pyxnsencodeweights pyxkencodeweights sizeofpyxkencodeweights 0 0 0 0$^  pyxnsepsnormoutput pyxkepsnormoutput sizeofpyxkepsnormoutput 0 0 0 0$^  pyxnsepsilononreplace pyxkepsilononreplace sizeofpyxkepsilononreplace 0 0 0 0$^  pyxnserror pyxkerror sizeofpyxkerror 0 0 0 0$^  pyxnsfartype pyxkfartype sizeofpyxkfartype 0 0 0 0$^  pyxnsfilename pyxkfilename sizeofpyxkfilename 0 0 0 0$^  pyxnsfinal pyxkfinal sizeofpyxkfinal 0 0 0 0$^  pyxnsfind pyxkfind sizeofpyxkfind 0 0 0 0$^  pyxnsflags pyxkflags sizeofpyxkflags 0 0 0 0$^  pyxnsfloatformat pyxkfloatformat sizeofpyxkfloatformat 0 0 0 0$^  pyxnsfontsize pyxkfontsize sizeofpyxkfontsize 0 0 0 0$^  pyxnsformat pyxkformat sizeofpyxkformat 0 0 0 0$^  pyxnsfsterrorfatalold pyxkfsterrorfatalold sizeofpyxkfsterrorfatalold 0 0 0 0$^  pyxnsfsttype pyxkfsttype sizeofpyxkfsttype 0 0 0 0$^  pyxnbfunctional pyxkfunctional sizeofpyxkfunctional 0 0 0 0$^  pyxnbg pyxkg sizeofpyxkg 0 0 0 0$^  pyxnsgetfst pyxkgetfst sizeofpyxkgetfst 0 0 0 0$^  pyxnsgetkey pyxkgetkey sizeofpyxkgetkey 0 0 0 0$^  pyxnsgetnthkey pyxkgetnthkey sizeofpyxkgetnthkey 0 0 0 0$^  pyxnsgetstate pyxkgetstate sizeofpyxkgetstate 0 0 0 0$^  pyxnsheight pyxkheight sizeofpyxkheight 0 0 0 0$^  pyxnsid pyxkid sizeofpyxkid 0 0 0 0$^  pyxnbidentity pyxkidentity sizeofpyxkidentity 0 0 0 0$^  pyxnsifst pyxkifst sizeofpyxkifst 0 0 0 0$^  pyxnsifst0 pyxkifst0 sizeofpyxkifst0 0 0 0 0$^  pyxnsifst0 pyxkifst0 sizeofpyxkifst0 0 0 0 0$^  pyxnbilabel pyxkilabel sizeofpyxkilabel 0 0 0 0$^  pyxnsilabel pyxkilabel sizeofpyxkilabel 0 0 0 0$^  pyxnsimport pyxkimport sizeofpyxkimport 0 0 0 0$^  pyxnsincrementsubsequentiallabel pyxkincrementsubsequentiallabel sizeofpyxkincrementsubsequentiallabel 0 0 0 0$^  pyxnbinput pyxkinput sizeofpyxkinput 0 0 0 0$^  pyxnsinputsymbols pyxkinputsymbols sizeofpyxkinputsymbols 0 0 0 0$^  pyxnsinputtable pyxkinputtable sizeofpyxkinputtable 0 0 0 0$^  pyxnsipairs pyxkipairs sizeofpyxkipairs 0 0 0 0$^  pyxnsisymbols pyxkisymbols sizeofpyxkisymbols 0 0 0 0$^  pyxnsknosymbol pyxkknosymbol sizeofpyxkknosymbol 0 0 0 0$^  pyxnskeepisymbols pyxkkeepisymbols sizeofpyxkkeepisymbols 0 0 0 0$^  pyxnskeeposymbols pyxkkeeposymbols sizeofpyxkkeeposymbols 0 0 0 0$^  pyxnskeepstatenumbering pyxkkeepstatenumbering sizeofpyxkkeepstatenumbering 0 0 0 0$^  pyxnskey pyxkkey sizeofpyxkkey 0 0 0 0$^  pyxnslabeledchecksum pyxklabeledchecksum sizeofpyxklabeledchecksum 0 0 0 0$^  pyxnslhs pyxklhs sizeofpyxklhs 0 0 0 0$^  pyxnslogging pyxklogging sizeofpyxklogging 0 0 0 0$^  pyxnsmain pyxkmain sizeofpyxkmain 0 0 0 0$^  pyxnsmaptype pyxkmaptype sizeofpyxkmaptype 0 0 0 0$^  pyxnsmask pyxkmask sizeofpyxkmask 0 0 0 0$^  pyxnsmaxlength pyxkmaxlength sizeofpyxkmaxlength 0 0 0 0$^  pyxnsmember pyxkmember sizeofpyxkmember 0 0 0 0$^  pyxnsmetaclass pyxkmetaclass sizeofpyxkmetaclass 0 0 0 0$^  pyxnsmissingsym pyxkmissingsym sizeofpyxkmissingsym 0 0 0 0$^  pyxnsmodule pyxkmodule sizeofpyxkmodule 0 0 0 0$^  pyxnsmutablearcs pyxkmutablearcs sizeofpyxkmutablearcs 0 0 0 0$^  pyxnsn pyxkn sizeofpyxkn 0 0 0 0$^  pyxnsname pyxkname sizeofpyxkname 0 0 0 0$^  pyxnsname0 pyxkname0 sizeofpyxkname0 0 0 0 0$^  pyxnbneither pyxkneither sizeofpyxkneither 0 0 0 0$^  pyxnsnew pyxknew sizeofpyxknew 0 0 0 0$^  pyxnsnewisymbols pyxknewisymbols sizeofpyxknewisymbols 0 0 0 0$^  pyxnsnewosymbols pyxknewosymbols sizeofpyxknewosymbols 0 0 0 0$^  pyxnsnext pyxknext sizeofpyxknext 0 0 0 0$^  pyxnsnextstate pyxknextstate sizeofpyxknextstate 0 0 0 0$^  pyxkpsnodefaultreduceduetonon pyxknodefaultreduceduetonon sizeofpyxknodefaultreduceduetonon 0 0 0 0$^  pyxnsnodesep pyxknodesep sizeofpyxknodesep 0 0 0 0$^  pyxnsnpath pyxknpath sizeofpyxknpath 0 0 0 0$^  pyxnsnshortest pyxknshortest sizeofpyxknshortest 0 0 0 0$^  pyxnsnstate pyxknstate sizeofpyxknstate 0 0 0 0$^  pyxnsnumarcs pyxknumarcs sizeofpyxknumarcs 0 0 0 0$^  pyxnsnuminputepsilons pyxknuminputepsilons sizeofpyxknuminputepsilons 0 0 0 0$^  pyxnsnumoutputepsilons pyxknumoutputepsilons sizeofpyxknumoutputepsilons 0 0 0 0$^  pyxnsnumstates pyxknumstates sizeofpyxknumstates 0 0 0 0$^  pyxnsnumsymbols pyxknumsymbols sizeofpyxknumsymbols 0 0 0 0$^  pyxnsnumbers pyxknumbers sizeofpyxknumbers 0 0 0 0$^  pyxnsobject pyxkobject sizeofpyxkobject 0 0 0 0$^  pyxnsolabel pyxkolabel sizeofpyxkolabel 0 0 0 0$^  pyxnsoldisymbols pyxkoldisymbols sizeofpyxkoldisymbols 0 0 0 0$^  pyxnsoldosymbols pyxkoldosymbols sizeofpyxkoldosymbols 0 0 0 0$^  pyxnsopairs pyxkopairs sizeofpyxkopairs 0 0 0 0$^  pyxnsopen pyxkopen sizeofpyxkopen 0 0 0 0$^  pyxnsosymbols pyxkosymbols sizeofpyxkosymbols 0 0 0 0$^  pyxnsoutputsymbols pyxkoutputsymbols sizeofpyxkoutputsymbols 0 0 0 0$^  pyxnspairs pyxkpairs sizeofpyxkpairs 0 0 0 0$^  pyxnsplus pyxkplus sizeofpyxkplus 0 0 0 0$^  pyxnsportrait pyxkportrait sizeofpyxkportrait 0 0 0 0$^  pyxnsposition pyxkposition sizeofpyxkposition 0 0 0 0$^  pyxnspotentials pyxkpotentials sizeofpyxkpotentials 0 0 0 0$^  pyxnspower pyxkpower sizeofpyxkpower 0 0 0 0$^  pyxnsprecision pyxkprecision sizeofpyxkprecision 0 0 0 0$^  pyxnsprepare pyxkprepare sizeofpyxkprepare 0 0 0 0$^  pyxnsprojectoutput pyxkprojectoutput sizeofpyxkprojectoutput 0 0 0 0$^  pyxnsproperties pyxkproperties sizeofpyxkproperties 0 0 0 0$^  pyxnsprops pyxkprops sizeofpyxkprops 0 0 0 0$^  pyxnspushlabels pyxkpushlabels sizeofpyxkpushlabels 0 0 0 0$^  pyxnspushweights pyxkpushweights sizeofpyxkpushweights 0 0 0 0$^  pyxnspywrapfst0 pyxkpywrapfst0 sizeofpyxkpywrapfst0 0 0 0 0$^  pyxkpspywrapfstpyx pyxkpywrapfstpyx sizeofpyxkpywrapfstpyx 0 0 0 0$^  pyxnspyxvtable pyxkpyxvtable sizeofpyxkpyxvtable 0 0 0 0$^  pyxnsqualname pyxkqualname sizeofpyxkqualname 0 0 0 0$^  pyxnsqueuetype pyxkqueuetype sizeofpyxkqueuetype 0 0 0 0$^  pyxnsranksep pyxkranksep sizeofpyxkranksep 0 0 0 0$^  pyxnsread pyxkread sizeofpyxkread 0 0 0 0$^  pyxnsreadfromstring pyxkreadfromstring sizeofpyxkreadfromstring 0 0 0 0$^  pyxnsreadfromstring0 pyxkreadfromstring0 sizeofpyxkreadfromstring0 0 0 0 0$^  pyxnsreadfst pyxkreadfst sizeofpyxkreadfst 0 0 0 0$^  pyxnsreadtext pyxkreadtext sizeofpyxkreadtext 0 0 0 0$^  pyxnsreduce pyxkreduce sizeofpyxkreduce 0 0 0 0$^  pyxnsreducecython pyxkreducecython sizeofpyxkreducecython 0 0 0 0$^  pyxnsreduceex pyxkreduceex sizeofpyxkreduceex 0 0 0 0$^  pyxnsregister pyxkregister sizeofpyxkregister 0 0 0 0$^  pyxnsremovecommonaffix pyxkremovecommonaffix sizeofpyxkremovecommonaffix 0 0 0 0$^  pyxnsremovetotalweight pyxkremovetotalweight sizeofpyxkremovetotalweight 0 0 0 0$^  pyxnsrequiresuperinitial pyxkrequiresuperinitial sizeofpyxkrequiresuperinitial 0 0 0 0$^  pyxnsreset pyxkreset sizeofpyxkreset 0 0 0 0$^  pyxnsresetfsterrorfatal pyxkresetfsterrorfatal sizeofpyxkresetfsterrorfatal 0 0 0 0$^  pyxnsresult pyxkresult sizeofpyxkresult 0 0 0 0$^  pyxnsreturnarclabeling pyxkreturnarclabeling sizeofpyxkreturnarclabeling 0 0 0 0$^  pyxnsreturnlabel pyxkreturnlabel sizeofpyxkreturnlabel 0 0 0 0$^  pyxnsreturncode pyxkreturncode sizeofpyxkreturncode 0 0 0 0$^  pyxnsreverse pyxkreverse sizeofpyxkreverse 0 0 0 0$^  pyxnsrhs pyxkrhs sizeofpyxkrhs 0 0 0 0$^  pyxnsseed pyxkseed sizeofpyxkseed 0 0 0 0$^  pyxnsseek pyxkseek sizeofpyxkseek 0 0 0 0$^  pyxnsselect pyxkselect sizeofpyxkselect 0 0 0 0$^  pyxkpsselfaiterselffstcannotbe pyxkselfaiterselffstcannotbe sizeofpyxkselfaiterselffstcannotbe 0 0 0 0$^  pyxkpsselfaiterselfmfstcannotbe pyxkselfaiterselfmfstcannotbe sizeofpyxkselfaiterselfmfstcannotbe 0 0 0 0$^  pyxkpsselfarccannotbeconvertedto pyxkselfarccannotbeconvertedto sizeofpyxkselfarccannotbeconvertedto 0 0 0 0$^  pyxkpsselfencodercannotbeconverte pyxkselfencodercannotbeconverte sizeofpyxkselfencodercannotbeconverte 0 0 0 0$^  pyxkpsselfencoderselftablecannot pyxkselfencoderselftablecannot sizeofpyxkselfencoderselftablecannot 0 0 0 0$^  pyxkpsselffstselfsitercannotbe pyxkselffstselfsitercannotbe sizeofpyxkselffstselfsitercannotbe 0 0 0 0$^  pyxkpsselffstselftablecannotbe pyxkselffstselftablecannotbe sizeofpyxkselffstselftablecannotbe 0 0 0 0$^  pyxkpsselfmfstselftablecannotbe pyxkselfmfstselftablecannotbe sizeofpyxkselfmfstselftablecannotbe 0 0 0 0$^  pyxkpsselfreadercannotbeconverted pyxkselfreadercannotbeconverted sizeofpyxkselfreadercannotbeconverted 0 0 0 0$^  pyxkpsselfsiterselftablecannotb pyxkselfsiterselftablecannotb sizeofpyxkselfsiterselftablecannotb 0 0 0 0$^  pyxkpsselfsmarttableselftableca pyxkselfsmarttableselftableca sizeofpyxkselfsmarttableselftableca 0 0 0 0$^  pyxkpsselftablecannotbeconverted pyxkselftablecannotbeconverted sizeofpyxkselftablecannotbeconverted 0 0 0 0$^  pyxkpsselfweightcannotbeconverted pyxkselfweightcannotbeconverted sizeofpyxkselfweightcannotbeconverted 0 0 0 0$^  pyxkpsselfwritercannotbeconverted pyxkselfwritercannotbeconverted sizeofpyxkselfwritercannotbeconverted 0 0 0 0$^  pyxnssetflags pyxksetflags sizeofpyxksetflags 0 0 0 0$^  pyxnssetinputsymbols pyxksetinputsymbols sizeofpyxksetinputsymbols 0 0 0 0$^  pyxnssetname pyxksetname sizeofpyxksetname 0 0 0 0$^  pyxnssetoutputsymbols pyxksetoutputsymbols sizeofpyxksetoutputsymbols 0 0 0 0$^  pyxnssetvalue pyxksetvalue sizeofpyxksetvalue 0 0 0 0$^  pyxnssetstate pyxksetstate sizeofpyxksetstate 0 0 0 0$^  pyxnssetstatecython pyxksetstatecython sizeofpyxksetstatecython 0 0 0 0$^  pyxnsshortestdistance pyxkshortestdistance sizeofpyxkshortestdistance 0 0 0 0$^  pyxnsshowweightone pyxkshowweightone sizeofpyxkshowweightone 0 0 0 0$^  pyxnssorttype pyxksorttype sizeofpyxksorttype 0 0 0 0$^  pyxnsssymbols pyxkssymbols sizeofpyxkssymbols 0 0 0 0$^  pyxnbstandard pyxkstandard sizeofpyxkstandard 0 0 0 0$^  pyxnsstart pyxkstart sizeofpyxkstart 0 0 0 0$^  pyxnsstate pyxkstate sizeofpyxkstate 0 0 0 0$^  pyxnsstates pyxkstates sizeofpyxkstates 0 0 0 0$^  pyxnsstaticmethod pyxkstaticmethod sizeofpyxkstaticmethod 0 0 0 0$^  pyxnsstderr pyxkstderr sizeofpyxkstderr 0 0 0 0$^  pyxnsstdin pyxkstdin sizeofpyxkstdin 0 0 0 0$^  pyxnsstdout pyxkstdout sizeofpyxkstdout 0 0 0 0$^  pyxnssubprocess pyxksubprocess sizeofpyxksubprocess 0 0 0 0$^  pyxnssubsequentiallabel pyxksubsequentiallabel sizeofpyxksubsequentiallabel 0 0 0 0$^  pyxnssymbol pyxksymbol sizeofpyxksymbol 0 0 0 0$^  pyxnssyms pyxksyms sizeofpyxksyms 0 0 0 0$^  pyxnstest pyxktest sizeofpyxktest 0 0 0 0$^  pyxnstest0 pyxktest0 sizeofpyxktest0 0 0 0 0$^  pyxnstext pyxktext sizeofpyxktext 0 0 0 0$^  pyxnstimes pyxktimes sizeofpyxktimes 0 0 0 0$^  pyxnstitle pyxktitle sizeofpyxktitle 0 0 0 0$^  pyxnstofinal pyxktofinal sizeofpyxktofinal 0 0 0 0$^  pyxnstostring pyxktostring sizeofpyxktostring 0 0 0 0$^  pyxnstype pyxktype sizeofpyxktype 0 0 0 0$^  pyxnbuniform pyxkuniform sizeofpyxkuniform 0 0 0 0$^  pyxnsunique pyxkunique sizeofpyxkunique 0 0 0 0$^  pyxnsunknownisymbol pyxkunknownisymbol sizeofpyxkunknownisymbol 0 0 0 0$^  pyxnsunknownosymbol pyxkunknownosymbol sizeofpyxkunknownosymbol 0 0 0 0$^  pyxkpbunspecified pyxkunspecified sizeofpyxkunspecified 0 0 0 0$^  pyxnsutf0 pyxkutf0 sizeofpyxkutf0 0 0 0 0$^  pyxnsvalue pyxkvalue sizeofpyxkvalue 0 0 0 0$^  pyxnbvector pyxkvector sizeofpyxkvector 0 0 0 0$^  pyxnsverify pyxkverify sizeofpyxkverify 0 0 0 0$^  pyxnsvertical pyxkvertical sizeofpyxkvertical 0 0 0 0$^  pyxnsw pyxkw sizeofpyxkw 0 0 0 0$^  pyxnswarning pyxkwarning sizeofpyxkwarning 0 0 0 0$^  pyxnsweight pyxkweight sizeofpyxkweight 0 0 0 0$^  pyxnsweighttype pyxkweighttype sizeofpyxkweighttype 0 0 0 0$^  pyxnsweighted pyxkweighted sizeofpyxkweighted 0 0 0 0$^  pyxnswidth pyxkwidth sizeofpyxkwidth 0 0 0 0$^  pyxnswrite pyxkwrite sizeofpyxkwrite 0 0 0 0$^  pyxnswritetext pyxkwritetext sizeofpyxkwritetext 0 0 0 0$^  pyxnswritetostring pyxkwritetostring sizeofpyxkwritetostring 0 0 0 0$^  0 0 0 0 0 0 0$^$^static int pyxinitcachedbuiltinsvoid $^  pyxbuiltinvalueerror  pyxgetbuiltinnamepyxnsvalueerror if pyxbuiltinvalueerror pyxerr0 000 pyxl0error$^  pyxbuiltinruntimeerror  pyxgetbuiltinnamepyxnsruntimeerror if pyxbuiltinruntimeerror pyxerr0 000 pyxl0error$^  pyxbuiltinindexerror  pyxgetbuiltinnamepyxnsindexerror if pyxbuiltinindexerror pyxerr0 000 pyxl0error$^  pyxbuiltinioerror  pyxgetbuiltinnamepyxnsioerror if pyxbuiltinioerror pyxerr0 000 pyxl0error$^  pyxbuiltinobject  pyxgetbuiltinnamepyxnsobject if pyxbuiltinobject pyxerr0 0000 pyxl0error$^  pyxbuiltinstaticmethod  pyxgetbuiltinnamepyxnsstaticmethod if pyxbuiltinstaticmethod pyxerr0 0000 pyxl0error$^  pyxbuiltinid  pyxgetbuiltinnamepyxnsid if pyxbuiltinid pyxerr0 000 pyxl0error$^  pyxbuiltintypeerror  pyxgetbuiltinnamepyxnstypeerror if pyxbuiltintypeerror pyxerr0 0 pyxl0error$^  pyxbuiltinstopiteration  pyxgetbuiltinnamepyxnsstopiteration if pyxbuiltinstopiteration pyxerr0 0000 pyxl0error$^  pyxbuiltinkeyerror  pyxgetbuiltinnamepyxnskeyerror if pyxbuiltinkeyerror pyxerr0 0000 pyxl0error$^  return 0$^  pyxl0error$^  return 0$^$^$^static int pyxinitcachedconstantsvoid $^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextpyxinitcachedconstants 0$^$^   pywrapfst.pyx000$^    cdef void checkweightself except $^      if self.type  bnone$^        raise fstargerrorweight type not found              $^      if self.tostring  bbadnumber$^        raise fstbadweighterrorinvalid weight$^ $^  pyxtuple  pytuplepack0 pyxkpsweighttypenotfound if unlikelypyxtuple pyxerr0 000 pyxl0error$^  pyxgotrefpyxtuple$^  pyxgiverefpyxtuple$^$^   pywrapfst.pyx000$^        raise fstargerrorweight type not found$^      if self.tostring  bbadnumber$^        raise fstbadweighterrorinvalid weight              $^  $^    cpdef weight copyself$^ $^  pyxtuple0  pytuplepack0 pyxkpsinvalidweight if unlikelypyxtuple0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxtuple0$^  pyxgiverefpyxtuple0$^$^   tree fragment0$^  def reducecythonself$^      raise typeerrorself.weight cannot be converted to a python object for pickling              $^  def setstatecythonself pyxstate$^      raise typeerrorself.weight cannot be converted to a python object for pickling$^ $^  pyxtuple0  pytuplepack0 pyxkpsselfweightcannotbeconverted if unlikelypyxtuple0 pyxerr0 0 pyxl0error$^  pyxgotrefpyxtuple0$^  pyxgiverefpyxtuple0$^$^   tree fragment0$^      raise typeerrorself.weight cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate$^      raise typeerrorself.weight cannot be converted to a python object for pickling              $^ $^  pyxtuple0  pytuplepack0 pyxkpsselfweightcannotbeconverted if unlikelypyxtuple0 pyxerr0 0 pyxl0error$^  pyxgotrefpyxtuple0$^  pyxgiverefpyxtuple0$^$^   pywrapfst.pyx000$^        tostringweighttype$^    if result.weight.get.type  bnone$^      raise fstargerrorweight type not found              $^    return result$^  $^ $^  pyxtuple0  pytuplepack0 pyxkpsweighttypenotfound if unlikelypyxtuple0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxtuple0$^  pyxgiverefpyxtuple0$^$^   pywrapfst.pyx000$^          fst.weightclass.onetostringweighttype$^    if result.weight.get.type  bnone$^      raise fstargerrorweight type not found              $^    return result$^  $^ $^  pyxtuple0  pytuplepack0 pyxkpsweighttypenotfound if unlikelypyxtuple0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxtuple0$^  pyxgiverefpyxtuple0$^$^   tree fragment0$^  def reducecythonself$^      raise typeerrorself.table cannot be converted to a python object for pickling              $^  def setstatecythonself pyxstate$^      raise typeerrorself.table cannot be converted to a python object for pickling$^ $^  pyxtuple0  pytuplepack0 pyxkpsselftablecannotbeconverted if unlikelypyxtuple0 pyxerr0 0 pyxl0error$^  pyxgotrefpyxtuple0$^  pyxgiverefpyxtuple0$^$^   tree fragment0$^      raise typeerrorself.table cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate$^      raise typeerrorself.table cannot be converted to a python object for pickling              $^ $^  pyxtuple0  pytuplepack0 pyxkpsselftablecannotbeconverted if unlikelypyxtuple0 pyxerr0 0 pyxl0error$^  pyxgotrefpyxtuple0$^  pyxgiverefpyxtuple0$^$^   tree fragment0$^  def reducecythonself$^      raise typeerrorself.encoderself.table cannot be converted to a python object for pickling              $^  def setstatecythonself pyxstate$^      raise typeerrorself.encoderself.table cannot be converted to a python object for pickling$^ $^  pyxtuple0  pytuplepack0 pyxkpsselfencoderselftablecannot if unlikelypyxtuple0 pyxerr0 0 pyxl0error$^  pyxgotrefpyxtuple0$^  pyxgiverefpyxtuple0$^$^   tree fragment0$^      raise typeerrorself.encoderself.table cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate$^      raise typeerrorself.encoderself.table cannot be converted to a python object for pickling              $^ $^  pyxtuple00  pytuplepack0 pyxkpsselfencoderselftablecannot if unlikelypyxtuple00 pyxerr0 0 pyxl0error$^  pyxgotrefpyxtuple00$^  pyxgiverefpyxtuple00$^$^   tree fragment0$^  def reducecythonself$^      raise typeerrorself.fstself.table cannot be converted to a python object for pickling              $^  def setstatecythonself pyxstate$^      raise typeerrorself.fstself.table cannot be converted to a python object for pickling$^ $^  pyxtuple00  pytuplepack0 pyxkpsselffstselftablecannotbe if unlikelypyxtuple00 pyxerr0 0 pyxl0error$^  pyxgotrefpyxtuple00$^  pyxgiverefpyxtuple00$^$^   tree fragment0$^      raise typeerrorself.fstself.table cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate$^      raise typeerrorself.fstself.table cannot be converted to a python object for pickling              $^ $^  pyxtuple00  pytuplepack0 pyxkpsselffstselftablecannotbe if unlikelypyxtuple00 pyxerr0 0 pyxl0error$^  pyxgotrefpyxtuple00$^  pyxgiverefpyxtuple00$^$^   tree fragment0$^  def reducecythonself$^      raise typeerrorself.table cannot be converted to a python object for pickling              $^  def setstatecythonself pyxstate$^      raise typeerrorself.table cannot be converted to a python object for pickling$^ $^  pyxtuple00  pytuplepack0 pyxkpsselftablecannotbeconverted if unlikelypyxtuple00 pyxerr0 0 pyxl0error$^  pyxgotrefpyxtuple00$^  pyxgiverefpyxtuple00$^$^   tree fragment0$^      raise typeerrorself.table cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate$^      raise typeerrorself.table cannot be converted to a python object for pickling              $^ $^  pyxtuple00  pytuplepack0 pyxkpsselftablecannotbeconverted if unlikelypyxtuple00 pyxerr0 0 pyxl0error$^  pyxgotrefpyxtuple00$^  pyxgiverefpyxtuple00$^$^   tree fragment0$^  def reducecythonself$^      raise typeerrorself.mfstself.table cannot be converted to a python object for pickling              $^  def setstatecythonself pyxstate$^      raise typeerrorself.mfstself.table cannot be converted to a python object for pickling$^ $^  pyxtuple00  pytuplepack0 pyxkpsselfmfstselftablecannotbe if unlikelypyxtuple00 pyxerr0 0 pyxl0error$^  pyxgotrefpyxtuple00$^  pyxgiverefpyxtuple00$^$^   tree fragment0$^      raise typeerrorself.mfstself.table cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate$^      raise typeerrorself.mfstself.table cannot be converted to a python object for pickling              $^ $^  pyxtuple00  pytuplepack0 pyxkpsselfmfstselftablecannotbe if unlikelypyxtuple00 pyxerr0 0 pyxl0error$^  pyxgotrefpyxtuple00$^  pyxgiverefpyxtuple00$^$^   tree fragment0$^  def reducecythonself$^      raise typeerrorself.smarttableself.table cannot be converted to a python object for pickling              $^  def setstatecythonself pyxstate$^      raise typeerrorself.smarttableself.table cannot be converted to a python object for pickling$^ $^  pyxtuple00  pytuplepack0 pyxkpsselfsmarttableselftableca if unlikelypyxtuple00 pyxerr0 0 pyxl0error$^  pyxgotrefpyxtuple00$^  pyxgiverefpyxtuple00$^$^   tree fragment0$^      raise typeerrorself.smarttableself.table cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate$^      raise typeerrorself.smarttableself.table cannot be converted to a python object for pickling              $^ $^  pyxtuple00  pytuplepack0 pyxkpsselfsmarttableselftableca if unlikelypyxtuple00 pyxerr0 0 pyxl0error$^  pyxgotrefpyxtuple00$^  pyxgiverefpyxtuple00$^$^   tree fragment0$^  def reducecythonself$^      raise typeerrorself.siterself.table cannot be converted to a python object for pickling              $^  def setstatecythonself pyxstate$^      raise typeerrorself.siterself.table cannot be converted to a python object for pickling$^ $^  pyxtuple00  pytuplepack0 pyxkpsselfsiterselftablecannotb if unlikelypyxtuple00 pyxerr0 0 pyxl0error$^  pyxgotrefpyxtuple00$^  pyxgiverefpyxtuple00$^$^   tree fragment0$^      raise typeerrorself.siterself.table cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate$^      raise typeerrorself.siterself.table cannot be converted to a python object for pickling              $^ $^  pyxtuple00  pytuplepack0 pyxkpsselfsiterselftablecannotb if unlikelypyxtuple00 pyxerr0 0 pyxl0error$^  pyxgotrefpyxtuple00$^  pyxgiverefpyxtuple00$^$^   tree fragment0$^  def reducecythonself$^      raise typeerrorself.encoder cannot be converted to a python object for pickling              $^  def setstatecythonself pyxstate$^      raise typeerrorself.encoder cannot be converted to a python object for pickling$^ $^  pyxtuple00  pytuplepack0 pyxkpsselfencodercannotbeconverte if unlikelypyxtuple00 pyxerr0 0 pyxl0error$^  pyxgotrefpyxtuple00$^  pyxgiverefpyxtuple00$^$^   tree fragment0$^      raise typeerrorself.encoder cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate$^      raise typeerrorself.encoder cannot be converted to a python object for pickling              $^ $^  pyxtuple00  pytuplepack0 pyxkpsselfencodercannotbeconverte if unlikelypyxtuple00 pyxerr0 0 pyxl0error$^  pyxgotrefpyxtuple00$^  pyxgiverefpyxtuple00$^$^   pywrapfst.pyx0000$^      if proc.returncode  0   just to be explicit.$^        raise subprocess.calledprocesserrorproc.returncode self.dottsvg$^      return sout.decodeutf0              $^  $^    def reprself$^ $^  pyxtuple00  pytuplepack0 pyxnsutf0 if unlikelypyxtuple00 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxtuple00$^  pyxgiverefpyxtuple00$^$^   pywrapfst.pyx0000$^      cdef sizet result  self.fst.get.numarcsstate$^      if result  sizemax$^        raise fstindexerrorstate index out of range              $^      return result$^  $^ $^  pyxtuple00  pytuplepack0 pyxkpsstateindexoutofrange if unlikelypyxtuple00 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxtuple00$^  pyxgiverefpyxtuple00$^$^   pywrapfst.pyx0000$^      cdef sizet result  self.fst.get.numinputepsilonsstate$^      if result  sizemax$^        raise fstindexerrorstate index out of range              $^      return result$^  $^ $^  pyxtuple00  pytuplepack0 pyxkpsstateindexoutofrange if unlikelypyxtuple00 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxtuple00$^  pyxgiverefpyxtuple00$^$^   pywrapfst.pyx0000$^      cdef sizet result  self.fst.get.numoutputepsilonsstate$^      if result  sizemax$^        raise fstindexerrorstate index out of range              $^      return result$^  $^ $^  pyxtuple00  pytuplepack0 pyxkpsstateindexoutofrange if unlikelypyxtuple00 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxtuple00$^  pyxgiverefpyxtuple00$^$^   pywrapfst.pyx0000$^      cdef stringstream sstrm$^      if not self.fst.get.writesstrm writetostring$^        raise fstioerrorwrite to string failed              $^      return sstrm.str$^  $^ $^  pyxtuple00  pytuplepack0 pyxkpswritetostringfailed if unlikelypyxtuple00 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxtuple00$^  pyxgiverefpyxtuple00$^$^   pywrapfst.pyx0000$^      $^      if self.fst.get.propertiesfst.kerror true  fst.kerror$^        raise fstoperroroperation failed              $^  $^    cdef void addarcself int00 state arc arc except $^ $^  pyxtuple00  pytuplepack0 pyxkpsoperationfailed if unlikelypyxtuple00 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxtuple00$^  pyxgiverefpyxtuple00$^$^   pywrapfst.pyx0000$^    cdef void addarcself int00 state arc arc except $^      if not self.fst.get.validstateidstate$^        raise fstindexerrorstate index out of range              $^      if not self.mfst.get.addarcstate derefarc.arc$^        raise fstoperrorincompatible or invalid weight type$^ $^  pyxtuple00  pytuplepack0 pyxkpsstateindexoutofrange if unlikelypyxtuple00 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxtuple00$^  pyxgiverefpyxtuple00$^$^   pywrapfst.pyx0000$^        raise fstindexerrorstate index out of range$^      if not self.mfst.get.addarcstate derefarc.arc$^        raise fstoperrorincompatible or invalid weight type              $^      self.checkmutatingimethod$^  $^ $^  pyxtuple00  pytuplepack0 pyxkpsincompatibleorinvalidweightt if unlikelypyxtuple00 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxtuple00$^  pyxgiverefpyxtuple00$^$^   pywrapfst.pyx0000$^      if not self.mfst.get.deletearcsstate n if n else$^              self.mfst.get.deletearcsstate$^        raise fstindexerrorstate index out of range              $^      self.checkmutatingimethod$^  $^ $^  pyxtuple00  pytuplepack0 pyxkpsstateindexoutofrange if unlikelypyxtuple00 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxtuple00$^  pyxgiverefpyxtuple00$^$^   pywrapfst.pyx0000$^      if states$^        if not self.mfst.get.deletestatesconst vectorint00 states$^          raise fstindexerrorstate index out of range              $^      else$^        self.mfst.get.deletestates$^ $^  pyxtuple00  pytuplepack0 pyxkpsstateindexoutofrange if unlikelypyxtuple00 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxtuple00$^  pyxgiverefpyxtuple00$^$^   pywrapfst.pyx0000$^          opairs.get.pushbackfst.labelpairbefore after$^      if ipairs.get.empty and opairs.get.empty$^        raise fstargerrorno relabeling pairs specified.              $^      fst.relabelself.mfst.get derefipairs derefopairs$^      self.checkmutatingimethod$^ $^  pyxtuple00  pytuplepack0 pyxkpsnorelabelingpairsspecified if unlikelypyxtuple00 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxtuple00$^  pyxgiverefpyxtuple00$^$^   pywrapfst.pyx0000$^                              bool attachnewosymbolstrue except $^      if newisymbols is none and newosymbols is none$^        raise fstargerrorno new symboltables specified              $^      cdef fst.symboltable newisymbolsptr  null$^      if newisymbols is not none$^ $^  pyxtuple00  pytuplepack0 pyxkpsnonewsymboltablesspecified if unlikelypyxtuple00 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxtuple00$^  pyxgiverefpyxtuple00$^$^   pywrapfst.pyx0000$^    cdef void reservearcsself int00 state sizet n except $^      if not self.mfst.get.reservearcsstate n$^        raise fstindexerrorstate index out of range              $^      self.checkmutatingimethod$^  $^ $^  pyxtuple00  pytuplepack0 pyxkpsstateindexoutofrange if unlikelypyxtuple00 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxtuple00$^  pyxgiverefpyxtuple00$^$^   pywrapfst.pyx0000$^    cdef void setfinalself int00 state weightnone except $^      if not self.mfst.get.validstateidstate$^        raise fstindexerrorstate index out of range              $^      cdef fst.weightclass wc  getweightclassoroneself.weighttype$^                                                        weight$^ $^  pyxtuple00  pytuplepack0 pyxkpsstateindexoutofrange if unlikelypyxtuple00 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxtuple00$^  pyxgiverefpyxtuple00$^$^   pywrapfst.pyx0000$^                                                        weight$^      if not self.mfst.get.setfinalstate wc$^        raise fstoperrorincompatible or invalid weight              $^      self.checkmutatingimethod$^  $^ $^  pyxtuple00  pytuplepack0 pyxkpsincompatibleorinvalidweight if unlikelypyxtuple00 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxtuple00$^  pyxgiverefpyxtuple00$^$^   pywrapfst.pyx0000$^    cdef void setstartself int00 state except $^      if not self.mfst.get.setstartstate$^        raise fstindexerrorstate index out of range              $^      self.checkmutatingimethod$^  $^ $^  pyxtuple00  pytuplepack0 pyxkpsstateindexoutofrange if unlikelypyxtuple00 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxtuple00$^  pyxgiverefpyxtuple00$^$^   pywrapfst.pyx0000$^       topsort returns false if the fst is cyclic and thus cant be topsorted.$^      if not fst.topsortself.mfst.get$^        logging.warningcannot topsort cyclic fst.              $^      self.checkmutatingimethod$^  $^ $^  pyxtuple00  pytuplepack0 pyxkpscannottopsortcyclicfst if unlikelypyxtuple00 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxtuple00$^  pyxgiverefpyxtuple00$^$^   pywrapfst.pyx0000$^  cdef fst initfstfstclassptr tfst$^    if tfst.propertiesfst.kerror true$^      raise fstoperroroperation failed              $^    cdef fst ofst  fst.newfst$^    ofst.fst.resettfst$^ $^  pyxtuple00  pytuplepack0 pyxkpsoperationfailed if unlikelypyxtuple00 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxtuple00$^  pyxgiverefpyxtuple00$^$^   pywrapfst.pyx0000$^  cdef mutablefst initmutablefstmutablefstclassptr tfst$^    if tfst.propertiesfst.kerror true$^      raise fstoperroroperation failed              $^    cdef mutablefst ofst  mutablefst.newmutablefst$^    ofst.fst.resettfst$^ $^  pyxtuple00  pytuplepack0 pyxkpsoperationfailed if unlikelypyxtuple00 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxtuple00$^  pyxgiverefpyxtuple00$^$^   pywrapfst.pyx0000$^    tfst.resetfst.fstclass.readfromstreamsstrm bpywrapfst$^    if tfst.get  null$^      raise fstioerrorread failed string              $^    return initxfsttfst.release$^  $^ $^  pyxtuple00  pytuplepack0 pyxkpsreadfailedstring if unlikelypyxtuple00 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxtuple00$^  pyxgiverefpyxtuple00$^$^   tree fragment0$^  def reducecythonself$^      raise typeerrorself.arc cannot be converted to a python object for pickling              $^  def setstatecythonself pyxstate$^      raise typeerrorself.arc cannot be converted to a python object for pickling$^ $^  pyxtuple00  pytuplepack0 pyxkpsselfarccannotbeconvertedto if unlikelypyxtuple00 pyxerr0 0 pyxl0error$^  pyxgotrefpyxtuple00$^  pyxgiverefpyxtuple00$^$^   tree fragment0$^      raise typeerrorself.arc cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate$^      raise typeerrorself.arc cannot be converted to a python object for pickling              $^ $^  pyxtuple00  pytuplepack0 pyxkpsselfarccannotbeconvertedto if unlikelypyxtuple00 pyxerr0 0 pyxl0error$^  pyxgotrefpyxtuple00$^  pyxgiverefpyxtuple00$^$^   pywrapfst.pyx0000$^    def initself fst ifst int00 state$^      if not ifst.fst.get.validstateidstate$^        raise fstindexerrorstate index out of range              $^       makes copy of the sharedptr potentially extending the fsts lifetime.$^      self.fst  ifst.fst$^ $^  pyxtuple00  pytuplepack0 pyxkpsstateindexoutofrange if unlikelypyxtuple00 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxtuple00$^  pyxgiverefpyxtuple00$^$^   tree fragment0$^  def reducecythonself$^      raise typeerrorself.aiterself.fst cannot be converted to a python object for pickling              $^  def setstatecythonself pyxstate$^      raise typeerrorself.aiterself.fst cannot be converted to a python object for pickling$^ $^  pyxtuple00  pytuplepack0 pyxkpsselfaiterselffstcannotbe if unlikelypyxtuple00 pyxerr0 0 pyxl0error$^  pyxgotrefpyxtuple00$^  pyxgiverefpyxtuple00$^$^   tree fragment0$^      raise typeerrorself.aiterself.fst cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate$^      raise typeerrorself.aiterself.fst cannot be converted to a python object for pickling              $^ $^  pyxtuple00  pytuplepack0 pyxkpsselfaiterselffstcannotbe if unlikelypyxtuple00 pyxerr0 0 pyxl0error$^  pyxgotrefpyxtuple00$^  pyxgiverefpyxtuple00$^$^   pywrapfst.pyx0000$^    def initself mutablefst ifst int00 state$^      if not ifst.fst.get.validstateidstate$^        raise fstindexerrorstate index out of range              $^       makes copy of the sharedptr potentially extending the fsts lifetime.$^      self.mfst  ifst.mfst$^ $^  pyxtuple00  pytuplepack0 pyxkpsstateindexoutofrange if unlikelypyxtuple00 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxtuple00$^  pyxgiverefpyxtuple00$^$^   tree fragment0$^  def reducecythonself$^      raise typeerrorself.aiterself.mfst cannot be converted to a python object for pickling              $^  def setstatecythonself pyxstate$^      raise typeerrorself.aiterself.mfst cannot be converted to a python object for pickling$^ $^  pyxtuple00  pytuplepack0 pyxkpsselfaiterselfmfstcannotbe if unlikelypyxtuple00 pyxerr0 0 pyxl0error$^  pyxgotrefpyxtuple00$^  pyxgiverefpyxtuple00$^$^   tree fragment0$^      raise typeerrorself.aiterself.mfst cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate$^      raise typeerrorself.aiterself.mfst cannot be converted to a python object for pickling              $^ $^  pyxtuple00  pytuplepack0 pyxkpsselfaiterselfmfstcannotbe if unlikelypyxtuple00 pyxerr0 0 pyxl0error$^  pyxgotrefpyxtuple00$^  pyxgiverefpyxtuple00$^$^   tree fragment0$^  def reducecythonself$^      raise typeerrorself.fstself.siter cannot be converted to a python object for pickling              $^  def setstatecythonself pyxstate$^      raise typeerrorself.fstself.siter cannot be converted to a python object for pickling$^ $^  pyxtuple00  pytuplepack0 pyxkpsselffstselfsitercannotbe if unlikelypyxtuple00 pyxerr0 0 pyxl0error$^  pyxgotrefpyxtuple00$^  pyxgiverefpyxtuple00$^$^   tree fragment0$^      raise typeerrorself.fstself.siter cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate$^      raise typeerrorself.fstself.siter cannot be converted to a python object for pickling              $^ $^  pyxtuple00  pytuplepack0 pyxkpsselffstselfsitercannotbe if unlikelypyxtuple00 pyxerr0 0 pyxl0error$^  pyxgotrefpyxtuple00$^  pyxgiverefpyxtuple00$^$^   pywrapfst.pyx0000$^      self.sstrm.resetnew stringstream$^      if tfst.get  null$^        raise fstoperrorcompilation failed              $^      return initxfsttfst.release$^  $^ $^  pyxtuple00  pytuplepack0 pyxkpscompilationfailed if unlikelypyxtuple00 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxtuple00$^  pyxgiverefpyxtuple00$^$^   tree fragment0$^  def reducecythonself$^      raise typeerrorno default reduce due to nontrivial cinit              $^  def setstatecythonself pyxstate$^      raise typeerrorno default reduce due to nontrivial cinit$^ $^  pyxtuple00  pytuplepack0 pyxkpsnodefaultreduceduetonon if unlikelypyxtuple00 pyxerr0 0 pyxl0error$^  pyxgotrefpyxtuple00$^  pyxgiverefpyxtuple00$^$^   tree fragment0$^      raise typeerrorno default reduce due to nontrivial cinit$^  def setstatecythonself pyxstate$^      raise typeerrorno default reduce due to nontrivial cinit              $^ $^  pyxtuple00  pytuplepack0 pyxkpsnodefaultreduceduetonon if unlikelypyxtuple00 pyxerr0 0 pyxl0error$^  pyxgotrefpyxtuple00$^  pyxgiverefpyxtuple00$^$^   tree fragment0$^  def reducecythonself$^      raise typeerrorself.reader cannot be converted to a python object for pickling              $^  def setstatecythonself pyxstate$^      raise typeerrorself.reader cannot be converted to a python object for pickling$^ $^  pyxtuple00  pytuplepack0 pyxkpsselfreadercannotbeconverted if unlikelypyxtuple00 pyxerr0 0 pyxl0error$^  pyxgotrefpyxtuple00$^  pyxgiverefpyxtuple00$^$^   tree fragment0$^      raise typeerrorself.reader cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate$^      raise typeerrorself.reader cannot be converted to a python object for pickling              $^ $^  pyxtuple00  pytuplepack0 pyxkpsselfreadercannotbeconverted if unlikelypyxtuple00 pyxerr0 0 pyxl0error$^  pyxgotrefpyxtuple00$^  pyxgiverefpyxtuple00$^$^   pywrapfst.pyx0000$^       used by the far was initialized to use.$^      if not self.writer.get.addtostringkey derefifst.fst$^        raise fstoperrorincompatible or invalid arc type              $^       an error here usually indicates a key out of order.$^      if self.writer.get.error$^ $^  pyxtuple00  pytuplepack0 pyxkpsincompatibleorinvalidarctype if unlikelypyxtuple00 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxtuple00$^  pyxgiverefpyxtuple00$^$^   pywrapfst.pyx0000$^       an error here usually indicates a key out of order.$^      if self.writer.get.error$^        raise fstargerrorkey out of order              $^  $^    cpdef string arctypeself$^ $^  pyxtuple00  pytuplepack0 pyxkpskeyoutoforder if unlikelypyxtuple00 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxtuple00$^  pyxgiverefpyxtuple00$^$^   tree fragment0$^  def reducecythonself$^      raise typeerrorself.writer cannot be converted to a python object for pickling              $^  def setstatecythonself pyxstate$^      raise typeerrorself.writer cannot be converted to a python object for pickling$^ $^  pyxtuple00  pytuplepack0 pyxkpsselfwritercannotbeconverted if unlikelypyxtuple00 pyxerr0 0 pyxl0error$^  pyxgotrefpyxtuple00$^  pyxgiverefpyxtuple00$^$^   tree fragment0$^      raise typeerrorself.writer cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate$^      raise typeerrorself.writer cannot be converted to a python object for pickling              $^ $^  pyxtuple00  pytuplepack0 pyxkpsselfwritercannotbeconverted if unlikelypyxtuple00 pyxerr0 0 pyxl0error$^  pyxgotrefpyxtuple00$^  pyxgiverefpyxtuple00$^$^   pywrapfst.pyx000$^  $^  $^  def plusweight lhs weight rhs              $^    $^    pluslhs rhs$^ $^  pyxtuple00  pytuplepack0 pyxnslhs pyxnsrhs pyxnsresult if unlikelypyxtuple00 pyxerr0 000 pyxl0error$^  pyxgotrefpyxtuple00$^  pyxgiverefpyxtuple00$^  pyxcodeobj000  pyobjectpyxpycodenew0 0 0 0 cooptimizedconewlocals pyxemptybytes pyxemptytuple pyxemptytuple pyxtuple00 pyxemptytuple pyxemptytuple pyxkpspywrapfstpyx pyxnsplus 000 pyxemptybytes if unlikelypyxcodeobj000 pyxerr0 000 pyxl0error$^$^   pywrapfst.pyx000$^  $^  $^  def timesweight lhs weight rhs              $^    $^    timeslhs rhs$^ $^  pyxtuple000  pytuplepack0 pyxnslhs pyxnsrhs pyxnsresult if unlikelypyxtuple000 pyxerr0 000 pyxl0error$^  pyxgotrefpyxtuple000$^  pyxgiverefpyxtuple000$^  pyxcodeobj000  pyobjectpyxpycodenew0 0 0 0 cooptimizedconewlocals pyxemptybytes pyxemptytuple pyxemptytuple pyxtuple000 pyxemptytuple pyxemptytuple pyxkpspywrapfstpyx pyxnstimes 000 pyxemptybytes if unlikelypyxcodeobj000 pyxerr0 000 pyxl0error$^$^   pywrapfst.pyx000$^  $^  $^  def divideweight lhs weight rhs              $^    $^    dividelhs rhs$^ $^  pyxtuple000  pytuplepack0 pyxnslhs pyxnsrhs pyxnsresult if unlikelypyxtuple000 pyxerr0 000 pyxl0error$^  pyxgotrefpyxtuple000$^  pyxgiverefpyxtuple000$^  pyxcodeobj000  pyobjectpyxpycodenew0 0 0 0 cooptimizedconewlocals pyxemptybytes pyxemptytuple pyxemptytuple pyxtuple000 pyxemptytuple pyxemptytuple pyxkpspywrapfstpyx pyxnsdivide 000 pyxemptybytes if unlikelypyxcodeobj000 pyxerr0 000 pyxl0error$^$^   pywrapfst.pyx000$^  $^  $^  def powerweight w sizet n              $^    $^    powerlhs rhs$^ $^  pyxtuple000  pytuplepack0 pyxnsw pyxnsn pyxnsresult if unlikelypyxtuple000 pyxerr0 000 pyxl0error$^  pyxgotrefpyxtuple000$^  pyxgiverefpyxtuple000$^  pyxcodeobj000  pyobjectpyxpycodenew0 0 0 0 cooptimizedconewlocals pyxemptybytes pyxemptytuple pyxemptytuple pyxtuple000 pyxemptytuple pyxemptytuple pyxkpspywrapfstpyx pyxnspower 000 pyxemptybytes if unlikelypyxcodeobj000 pyxerr0 000 pyxl0error$^$^   pywrapfst.pyx0000$^  $^  $^  class fstobject              $^  $^     $^ $^  pyxtuple000  pytuplepack0 pyxbuiltinobject if unlikelypyxtuple000 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxtuple000$^  pyxgiverefpyxtuple000$^$^   pywrapfst.pyx0000$^     $^  $^     def newcls arctypebstandard              $^      return createfstarctype$^  $^ $^  pyxtuple000  pytuplepack0 pyxnscls pyxnsarctype if unlikelypyxtuple000 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxtuple000$^  pyxgiverefpyxtuple000$^  pyxcodeobj000  pyobjectpyxpycodenew0 0 0 0 cooptimizedconewlocals pyxemptybytes pyxemptytuple pyxemptytuple pyxtuple000 pyxemptytuple pyxemptytuple pyxkpspywrapfstpyx pyxnsnew 0000 pyxemptybytes if unlikelypyxcodeobj000 pyxerr0 0000 pyxl0error$^  pyxtuple000  pytuplepack0 pyobjectpyxnbstandard if unlikelypyxtuple000 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxtuple000$^  pyxgiverefpyxtuple000$^$^   pywrapfst.pyx0000$^  $^     staticmethod$^     def readfilename              $^       $^       readfilename$^ $^  pyxtuple000  pytuplepack0 pyxnsfilename if unlikelypyxtuple000 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxtuple000$^  pyxgiverefpyxtuple000$^  pyxcodeobj000  pyobjectpyxpycodenew0 0 0 0 cooptimizedconewlocals pyxemptybytes pyxemptytuple pyxemptytuple pyxtuple000 pyxemptytuple pyxemptytuple pyxkpspywrapfstpyx pyxnsread 0000 pyxemptybytes if unlikelypyxcodeobj000 pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^  $^     staticmethod$^     def readfromstringstate              $^       $^       readfromstringstring fsttypenone$^ $^  pyxtuple000  pytuplepack0 pyxnsstate if unlikelypyxtuple000 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxtuple000$^  pyxgiverefpyxtuple000$^  pyxcodeobj000  pyobjectpyxpycodenew0 0 0 0 cooptimizedconewlocals pyxemptybytes pyxemptytuple pyxemptytuple pyxtuple000 pyxemptytuple pyxemptytuple pyxkpspywrapfstpyx pyxnsreadfromstring0 0000 pyxemptybytes if unlikelypyxcodeobj000 pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^  $^  $^  def shortestdistancefst ifst              $^                       float deltafst.kshortestdelta$^                       int00 nstatefst.knostateid$^ $^  pyxtuple000  pytuplepack0 pyxnsifst pyxnsdelta pyxnsnstate pyxnsqueuetype pyxnsreverse pyxnsdistance pyxnsweighttype pyxnsweight if unlikelypyxtuple000 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxtuple000$^  pyxgiverefpyxtuple000$^  pyxcodeobj000  pyobjectpyxpycodenew0 0 0 0 cooptimizedconewlocals pyxemptybytes pyxemptytuple pyxemptytuple pyxtuple000 pyxemptytuple pyxemptytuple pyxkpspywrapfstpyx pyxnsshortestdistance 0000 pyxemptybytes if unlikelypyxcodeobj000 pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^  $^  atexit.register$^  def resetfsterrorfatal              $^    fst.flagsfsterrorfatal  fsterrorfatalold$^  $^ $^  pyxcodeobj000  pyobjectpyxpycodenew0 0 0 0 cooptimizedconewlocals pyxemptybytes pyxemptytuple pyxemptytuple pyxemptytuple pyxemptytuple pyxemptytuple pyxkpspywrapfstpyx pyxnsresetfsterrorfatal 0000 pyxemptybytes if unlikelypyxcodeobj000 pyxerr0 0000 pyxl0error$^  pyxrefnannyfinishcontext$^  return 0$^  pyxl0error$^  pyxrefnannyfinishcontext$^  return 0$^$^$^static int pyxinitglobalsvoid $^  if pyxinitstringspyxstringtab  0 pyxerr0 0 pyxl0error$^  pyxint0  pyintfromlong0 if unlikelypyxint0 pyxerr0 0 pyxl0error$^  pyxintneg0  pyintfromlong0 if unlikelypyxintneg0 pyxerr0 0 pyxl0error$^  return 0$^  pyxl0error$^  return 0$^$^$^static int pyxmodinitglobalinitcodevoid proto$^static int pyxmodinitvariableexportcodevoid proto$^static int pyxmodinitfunctionexportcodevoid proto$^static int pyxmodinittypeinitcodevoid proto$^static int pyxmodinittypeimportcodevoid proto$^static int pyxmodinitvariableimportcodevoid proto$^static int pyxmodinitfunctionimportcodevoid proto$^$^static int pyxmodinitglobalinitcodevoid $^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextpyxmodinitglobalinitcode 0$^   global init code $^  pyxrefnannyfinishcontext$^  return 0$^$^$^static int pyxmodinitvariableexportcodevoid $^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextpyxmodinitvariableexportcode 0$^   variable export code $^  pyxrefnannyfinishcontext$^  return 0$^$^$^static int pyxmodinitfunctionexportcodevoid $^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextpyxmodinitfunctionexportcode 0$^   function export code $^  if pyxexportfunctiontostring void voidpyxf0pywrapfsttostring stdstring pyobject  struct pyxoptargs0pywrapfsttostring pyxoptionalargs  0 pyxerr0 0 pyxl0error$^  if pyxexportfunctionweighttostring void voidpyxf0pywrapfstweighttostring stdstring pyobject  struct pyxoptargs0pywrapfstweighttostring pyxoptionalargs  0 pyxerr0 0 pyxl0error$^  if pyxexportfunctiongetcomposefilter void voidpyxf0pywrapfstgetcomposefilter enum fstcomposefilter stdstring const   0 pyxerr0 0 pyxl0error$^  if pyxexportfunctiongetdeterminizetype void voidpyxf0pywrapfstgetdeterminizetype enum fstdeterminizetype stdstring const   0 pyxerr0 0 pyxl0error$^  if pyxexportfunctiongetqueuetype void voidpyxf0pywrapfstgetqueuetype enum fstqueuetype stdstring const   0 pyxerr0 0 pyxl0error$^  if pyxexportfunctiongetrandarcselection void voidpyxf0pywrapfstgetrandarcselection enum fstscriptrandarcselection stdstring const   0 pyxerr0 0 pyxl0error$^  if pyxexportfunctiongetreplacelabeltype void voidpyxf0pywrapfstgetreplacelabeltype enum fstreplacelabeltype stdstring const  bool  0 pyxerr0 0 pyxl0error$^  if pyxexportfunctiongetweightclassorone void voidpyxf0pywrapfstgetweightclassorone fstscriptweightclass stdstring const  pyobject   0 pyxerr0 0 pyxl0error$^  if pyxexportfunctiongetweightclassorzero void voidpyxf0pywrapfstgetweightclassorzero fstscriptweightclass stdstring const  pyobject   0 pyxerr0 0 pyxl0error$^  if pyxexportfunctionzero void voidpyxf0pywrapfstzero struct pyxobj0pywrapfstweight pyobject   0 pyxerr0 0 pyxl0error$^  if pyxexportfunctionone void voidpyxf0pywrapfstone struct pyxobj0pywrapfstweight pyobject   0 pyxerr0 0 pyxl0error$^  if pyxexportfunctionnoweight void voidpyxf0pywrapfstnoweight struct pyxobj0pywrapfstweight pyobject   0 pyxerr0 0 pyxl0error$^  if pyxexportfunctionplus void voidpyxf0pywrapfstplus struct pyxobj0pywrapfstweight struct pyxobj0pywrapfstweight  struct pyxobj0pywrapfstweight   0 pyxerr0 0 pyxl0error$^  if pyxexportfunctiontimes void voidpyxf0pywrapfsttimes struct pyxobj0pywrapfstweight struct pyxobj0pywrapfstweight  struct pyxobj0pywrapfstweight   0 pyxerr0 0 pyxl0error$^  if pyxexportfunctiondivide void voidpyxf0pywrapfstdivide struct pyxobj0pywrapfstweight struct pyxobj0pywrapfstweight  struct pyxobj0pywrapfstweight   0 pyxerr0 0 pyxl0error$^  if pyxexportfunctionpower void voidpyxf0pywrapfstpower struct pyxobj0pywrapfstweight struct pyxobj0pywrapfstweight  sizet  0 pyxerr0 0 pyxl0error$^  if pyxexportfunctioninitencodemappersymboltable void voidpyxf0pywrapfstinitencodemappersymboltable struct pyxobj0pywrapfstencodemappersymboltable fstsymboltable  stdsharedptrfstscriptencodemapperclass   0 pyxerr0 0 pyxl0error$^  if pyxexportfunctioninitfstsymboltable void voidpyxf0pywrapfstinitfstsymboltable struct pyxobj0pywrapfstfstsymboltable fstsymboltable  stdsharedptrfstscriptfstclass   0 pyxerr0 0 pyxl0error$^  if pyxexportfunctioninitmutablefstsymboltable void voidpyxf0pywrapfstinitmutablefstsymboltable struct pyxobj0pywrapfstmutablefstsymboltable fstsymboltable  stdsharedptrfstscriptmutablefstclass   0 pyxerr0 0 pyxl0error$^  if pyxexportfunctioninitsymboltable void voidpyxf0pywrapfstinitsymboltable struct pyxobj0pywrapfstsymboltable fstsymboltable   0 pyxerr0 0 pyxl0error$^  if pyxexportfunctioninitfst void voidpyxf0pywrapfstinitfst struct pyxobj0pywrapfstfst pyxt0pywrapfstfstclassptr  0 pyxerr0 0 pyxl0error$^  if pyxexportfunctioninitmutablefst void voidpyxf0pywrapfstinitmutablefst struct pyxobj0pywrapfstmutablefst pyxt0pywrapfstmutablefstclassptr  0 pyxerr0 0 pyxl0error$^  if pyxexportfunctioninitxfst void voidpyxf0pywrapfstinitxfst struct pyxobj0pywrapfstfst pyxt0pywrapfstfstclassptr  0 pyxerr0 0 pyxl0error$^  if pyxexportfunctioncreatefst void voidpyxf0pywrapfstcreatefst struct pyxobj0pywrapfstmutablefst struct pyxoptargs0pywrapfstcreatefst pyxoptionalargs  0 pyxerr0 0 pyxl0error$^  if pyxexportfunctionread void voidpyxf0pywrapfstread struct pyxobj0pywrapfstfst pyobject  int pyxskipdispatch  0 pyxerr0 0 pyxl0error$^  if pyxexportfunctionreadfromstring void voidpyxf0pywrapfstreadfromstring struct pyxobj0pywrapfstfst pyobject  int pyxskipdispatch  0 pyxerr0 0 pyxl0error$^  if pyxexportfunctioninitarc void voidpyxf0pywrapfstinitarc struct pyxobj0pywrapfstarc fstscriptarcclass const   0 pyxerr0 0 pyxl0error$^  if pyxexportfunctionmap void voidpyxf0pywrapfstmap struct pyxobj0pywrapfstfst struct pyxobj0pywrapfstfst  struct pyxoptargs0pywrapfstmap pyxoptionalargs  0 pyxerr0 0 pyxl0error$^  if pyxexportfunctionarcmap void voidpyxf0pywrapfstarcmap struct pyxobj0pywrapfstfst struct pyxobj0pywrapfstfst  int pyxskipdispatch struct pyxoptargs0pywrapfstarcmap pyxoptionalargs  0 pyxerr0 0 pyxl0error$^  if pyxexportfunctioncompose void voidpyxf0pywrapfstcompose struct pyxobj0pywrapfstmutablefst struct pyxobj0pywrapfstfst  struct pyxobj0pywrapfstfst  int pyxskipdispatch struct pyxoptargs0pywrapfstcompose pyxoptionalargs  0 pyxerr0 0 pyxl0error$^  if pyxexportfunctionconvert void voidpyxf0pywrapfstconvert struct pyxobj0pywrapfstfst struct pyxobj0pywrapfstfst  int pyxskipdispatch struct pyxoptargs0pywrapfstconvert pyxoptionalargs  0 pyxerr0 0 pyxl0error$^  if pyxexportfunctiondeterminize void voidpyxf0pywrapfstdeterminize struct pyxobj0pywrapfstmutablefst struct pyxobj0pywrapfstfst  int pyxskipdispatch struct pyxoptargs0pywrapfstdeterminize pyxoptionalargs  0 pyxerr0 0 pyxl0error$^  if pyxexportfunctiondifference void voidpyxf0pywrapfstdifference struct pyxobj0pywrapfstmutablefst struct pyxobj0pywrapfstfst  struct pyxobj0pywrapfstfst  int pyxskipdispatch struct pyxoptargs0pywrapfstdifference pyxoptionalargs  0 pyxerr0 0 pyxl0error$^  if pyxexportfunctiondisambiguate void voidpyxf0pywrapfstdisambiguate struct pyxobj0pywrapfstmutablefst struct pyxobj0pywrapfstfst  int pyxskipdispatch struct pyxoptargs0pywrapfstdisambiguate pyxoptionalargs  0 pyxerr0 0 pyxl0error$^  if pyxexportfunctionepsnormalize void voidpyxf0pywrapfstepsnormalize struct pyxobj0pywrapfstmutablefst struct pyxobj0pywrapfstfst  int pyxskipdispatch struct pyxoptargs0pywrapfstepsnormalize pyxoptionalargs  0 pyxerr0 0 pyxl0error$^  if pyxexportfunctionequal void voidpyxf0pywrapfstequal bool struct pyxobj0pywrapfstfst  struct pyxobj0pywrapfstfst  int pyxskipdispatch struct pyxoptargs0pywrapfstequal pyxoptionalargs  0 pyxerr0 0 pyxl0error$^  if pyxexportfunctionequivalent void voidpyxf0pywrapfstequivalent bool struct pyxobj0pywrapfstfst  struct pyxobj0pywrapfstfst  int pyxskipdispatch struct pyxoptargs0pywrapfstequivalent pyxoptionalargs  0 pyxerr0 0 pyxl0error$^  if pyxexportfunctionintersect void voidpyxf0pywrapfstintersect struct pyxobj0pywrapfstmutablefst struct pyxobj0pywrapfstfst  struct pyxobj0pywrapfstfst  int pyxskipdispatch struct pyxoptargs0pywrapfstintersect pyxoptionalargs  0 pyxerr0 0 pyxl0error$^  if pyxexportfunctionisomorphic void voidpyxf0pywrapfstisomorphic bool struct pyxobj0pywrapfstfst  struct pyxobj0pywrapfstfst  int pyxskipdispatch struct pyxoptargs0pywrapfstisomorphic pyxoptionalargs  0 pyxerr0 0 pyxl0error$^  if pyxexportfunctionprune void voidpyxf0pywrapfstprune struct pyxobj0pywrapfstmutablefst struct pyxobj0pywrapfstfst  int pyxskipdispatch struct pyxoptargs0pywrapfstprune pyxoptionalargs  0 pyxerr0 0 pyxl0error$^  if pyxexportfunctionpush void voidpyxf0pywrapfstpush struct pyxobj0pywrapfstmutablefst struct pyxobj0pywrapfstfst  int pyxskipdispatch struct pyxoptargs0pywrapfstpush pyxoptionalargs  0 pyxerr0 0 pyxl0error$^  if pyxexportfunctionrandequivalent void voidpyxf0pywrapfstrandequivalent bool struct pyxobj0pywrapfstfst  struct pyxobj0pywrapfstfst  int pyxskipdispatch struct pyxoptargs0pywrapfstrandequivalent pyxoptionalargs  0 pyxerr0 0 pyxl0error$^  if pyxexportfunctionrandgen void voidpyxf0pywrapfstrandgen struct pyxobj0pywrapfstmutablefst struct pyxobj0pywrapfstfst  int pyxskipdispatch struct pyxoptargs0pywrapfstrandgen pyxoptionalargs  0 pyxerr0 0 pyxl0error$^  if pyxexportfunctionreplace void voidpyxf0pywrapfstreplace struct pyxobj0pywrapfstmutablefst pyobject  int pyxskipdispatch struct pyxoptargs0pywrapfstreplace pyxoptionalargs  0 pyxerr0 0 pyxl0error$^  if pyxexportfunctionreverse void voidpyxf0pywrapfstreverse struct pyxobj0pywrapfstmutablefst struct pyxobj0pywrapfstfst  int pyxskipdispatch struct pyxoptargs0pywrapfstreverse pyxoptionalargs  0 pyxerr0 0 pyxl0error$^  if pyxexportfunctionshortestdistance void voidpyxf0pywrapfstshortestdistance stdvectorfstscriptweightclass  struct pyxobj0pywrapfstfst  struct pyxoptargs0pywrapfstshortestdistance pyxoptionalargs  0 pyxerr0 0 pyxl0error$^  if pyxexportfunctionshortestpath void voidpyxf0pywrapfstshortestpath struct pyxobj0pywrapfstmutablefst struct pyxobj0pywrapfstfst  int pyxskipdispatch struct pyxoptargs0pywrapfstshortestpath pyxoptionalargs  0 pyxerr0 0 pyxl0error$^  if pyxexportfunctionstatemap void voidpyxf0pywrapfststatemap struct pyxobj0pywrapfstfst struct pyxobj0pywrapfstfst  pyobject  int pyxskipdispatch  0 pyxerr0 0 pyxl0error$^  if pyxexportfunctionsynchronize void voidpyxf0pywrapfstsynchronize struct pyxobj0pywrapfstmutablefst struct pyxobj0pywrapfstfst  int pyxskipdispatch  0 pyxerr0 0 pyxl0error$^  pyxrefnannyfinishcontext$^  return 0$^  pyxl0error$^  pyxrefnannyfinishcontext$^  return 0$^$^$^static int pyxmodinittypeinitcodevoid $^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextpyxmodinittypeinitcode 0$^   type init code $^  pyxvtabptr0pywrapfstweight  pyxvtable0pywrapfstweight$^  pyxvtable0pywrapfstweight.checkweight  void struct pyxobj0pywrapfstweight pyxf0pywrapfst0weightcheckweight$^  pyxvtable0pywrapfstweight.copy  struct pyxobj0pywrapfstweight struct pyxobj0pywrapfstweight  int pyxskipdispatchpyxf0pywrapfst0weightcopy$^  pyxvtable0pywrapfstweight.tostring  stdstring struct pyxobj0pywrapfstweight  int pyxskipdispatchpyxf0pywrapfst0weighttostring$^  pyxvtable0pywrapfstweight.type  stdstring struct pyxobj0pywrapfstweight  int pyxskipdispatchpyxf0pywrapfst0weighttype$^  if pytypereadypyxtype0pywrapfstweight  0 pyxerr0 000 pyxl0error$^  pyxtype0pywrapfstweight.tpprint  0$^  if cythonusetypeslots  cythonusepytypelookup  likelypyxtype0pywrapfstweight.tpdictoffset  pyxtype0pywrapfstweight.tpgetattro  pyobjectgenericgetattr $^    pyxtype0pywrapfstweight.tpgetattro  pyxpyobjectgenericgetattr$^  $^  if pyxsetvtablepyxtype0pywrapfstweight.tpdict pyxvtabptr0pywrapfstweight  0 pyxerr0 000 pyxl0error$^  if pyobjectsetattrstringpyxm weight pyobject pyxtype0pywrapfstweight  0 pyxerr0 000 pyxl0error$^  if pyxsetupreducepyobjectpyxtype0pywrapfstweight  0 pyxerr0 000 pyxl0error$^  pyxptype0pywrapfstweight  pyxtype0pywrapfstweight$^  pyxvtabptr0pywrapfstsymboltable  pyxvtable0pywrapfstsymboltable$^  pyxvtable0pywrapfstsymboltable.availablekey  pyxt00basictypesint00 struct pyxobj0pywrapfstsymboltable  int pyxskipdispatchpyxf0pywrapfst00symboltableavailablekey$^  pyxvtable0pywrapfstsymboltable.checksum  stdstring struct pyxobj0pywrapfstsymboltable  int pyxskipdispatchpyxf0pywrapfst00symboltablechecksum$^  pyxvtable0pywrapfstsymboltable.copy  struct pyxobj0pywrapfstsymboltable struct pyxobj0pywrapfstsymboltable  int pyxskipdispatchpyxf0pywrapfst00symboltablecopy$^  pyxvtable0pywrapfstsymboltable.getnthkey  pyxt00basictypesint00 struct pyxobj0pywrapfstsymboltable  pyssizet int pyxskipdispatchpyxf0pywrapfst00symboltablegetnthkey$^  pyxvtable0pywrapfstsymboltable.labeledchecksum  stdstring struct pyxobj0pywrapfstsymboltable  int pyxskipdispatchpyxf0pywrapfst00symboltablelabeledchecksum$^  pyxvtable0pywrapfstsymboltable.member  bool struct pyxobj0pywrapfstsymboltable  pyobject  int pyxskipdispatchpyxf0pywrapfst00symboltablemember$^  pyxvtable0pywrapfstsymboltable.name  stdstring struct pyxobj0pywrapfstsymboltable  int pyxskipdispatchpyxf0pywrapfst00symboltablename$^  pyxvtable0pywrapfstsymboltable.numsymbols  sizet struct pyxobj0pywrapfstsymboltable  int pyxskipdispatchpyxf0pywrapfst00symboltablenumsymbols$^  pyxvtable0pywrapfstsymboltable.write  void struct pyxobj0pywrapfstsymboltable  pyobject  int pyxskipdispatchpyxf0pywrapfst00symboltablewrite$^  pyxvtable0pywrapfstsymboltable.writetext  void struct pyxobj0pywrapfstsymboltable  pyobject  int pyxskipdispatchpyxf0pywrapfst00symboltablewritetext$^  if pytypereadypyxtype0pywrapfstsymboltable  0 pyxerr0 000 pyxl0error$^  pyxtype0pywrapfstsymboltable.tpprint  0$^  if cythonusetypeslots  cythonusepytypelookup  likelypyxtype0pywrapfstsymboltable.tpdictoffset  pyxtype0pywrapfstsymboltable.tpgetattro  pyobjectgenericgetattr $^    pyxtype0pywrapfstsymboltable.tpgetattro  pyxpyobjectgenericgetattr$^  $^  if pyxsetvtablepyxtype0pywrapfstsymboltable.tpdict pyxvtabptr0pywrapfstsymboltable  0 pyxerr0 000 pyxl0error$^  if pyobjectsetattrstringpyxm symboltable pyobject pyxtype0pywrapfstsymboltable  0 pyxerr0 000 pyxl0error$^  if pyxsetupreducepyobjectpyxtype0pywrapfstsymboltable  0 pyxerr0 000 pyxl0error$^  pyxptype0pywrapfstsymboltable  pyxtype0pywrapfstsymboltable$^  pyxvtabptr0pywrapfstencodemappersymboltable  pyxvtable0pywrapfstencodemappersymboltable$^  pyxvtable0pywrapfstencodemappersymboltable.pyxbase  pyxvtabptr0pywrapfstsymboltable$^  pyxtype0pywrapfstencodemappersymboltable.tpbase  pyxptype0pywrapfstsymboltable$^  if pytypereadypyxtype0pywrapfstencodemappersymboltable  0 pyxerr0 000 pyxl0error$^  pyxtype0pywrapfstencodemappersymboltable.tpprint  0$^  if cythonusetypeslots  cythonusepytypelookup  likelypyxtype0pywrapfstencodemappersymboltable.tpdictoffset  pyxtype0pywrapfstencodemappersymboltable.tpgetattro  pyobjectgenericgetattr $^    pyxtype0pywrapfstencodemappersymboltable.tpgetattro  pyxpyobjectgenericgetattr$^  $^  if pyxsetvtablepyxtype0pywrapfstencodemappersymboltable.tpdict pyxvtabptr0pywrapfstencodemappersymboltable  0 pyxerr0 000 pyxl0error$^  if pyobjectsetattrstringpyxm encodemappersymboltable pyobject pyxtype0pywrapfstencodemappersymboltable  0 pyxerr0 000 pyxl0error$^  if pyxsetupreducepyobjectpyxtype0pywrapfstencodemappersymboltable  0 pyxerr0 000 pyxl0error$^  pyxptype0pywrapfstencodemappersymboltable  pyxtype0pywrapfstencodemappersymboltable$^  pyxvtabptr0pywrapfstfstsymboltable  pyxvtable0pywrapfstfstsymboltable$^  pyxvtable0pywrapfstfstsymboltable.pyxbase  pyxvtabptr0pywrapfstsymboltable$^  pyxtype0pywrapfstfstsymboltable.tpbase  pyxptype0pywrapfstsymboltable$^  if pytypereadypyxtype0pywrapfstfstsymboltable  0 pyxerr0 000 pyxl0error$^  pyxtype0pywrapfstfstsymboltable.tpprint  0$^  if cythonusetypeslots  cythonusepytypelookup  likelypyxtype0pywrapfstfstsymboltable.tpdictoffset  pyxtype0pywrapfstfstsymboltable.tpgetattro  pyobjectgenericgetattr $^    pyxtype0pywrapfstfstsymboltable.tpgetattro  pyxpyobjectgenericgetattr$^  $^  if pyxsetvtablepyxtype0pywrapfstfstsymboltable.tpdict pyxvtabptr0pywrapfstfstsymboltable  0 pyxerr0 000 pyxl0error$^  if pyobjectsetattrstringpyxm fstsymboltable pyobject pyxtype0pywrapfstfstsymboltable  0 pyxerr0 000 pyxl0error$^  if pyxsetupreducepyobjectpyxtype0pywrapfstfstsymboltable  0 pyxerr0 000 pyxl0error$^  pyxptype0pywrapfstfstsymboltable  pyxtype0pywrapfstfstsymboltable$^  pyxvtabptr0pywrapfstmutablesymboltable  pyxvtable0pywrapfstmutablesymboltable$^  pyxvtable0pywrapfstmutablesymboltable.pyxbase  pyxvtabptr0pywrapfstsymboltable$^  pyxvtable0pywrapfstmutablesymboltable.addsymbol  pyxt00basictypesint00 struct pyxobj0pywrapfstmutablesymboltable  pyobject  int pyxskipdispatch struct pyxoptargs0pywrapfst00mutablesymboltableaddsymbol pyxoptionalargspyxf0pywrapfst00mutablesymboltableaddsymbol$^  pyxvtable0pywrapfstmutablesymboltable.addtable  void struct pyxobj0pywrapfstmutablesymboltable  struct pyxobj0pywrapfstsymboltable  int pyxskipdispatchpyxf0pywrapfst00mutablesymboltableaddtable$^  pyxvtable0pywrapfstmutablesymboltable.setname  void struct pyxobj0pywrapfstmutablesymboltable  pyobject  int pyxskipdispatchpyxf0pywrapfst00mutablesymboltablesetname$^  pyxtype0pywrapfstmutablesymboltable.tpbase  pyxptype0pywrapfstsymboltable$^  if pytypereadypyxtype0pywrapfstmutablesymboltable  0 pyxerr0 000 pyxl0error$^  pyxtype0pywrapfstmutablesymboltable.tpprint  0$^  if cythonusetypeslots  cythonusepytypelookup  likelypyxtype0pywrapfstmutablesymboltable.tpdictoffset  pyxtype0pywrapfstmutablesymboltable.tpgetattro  pyobjectgenericgetattr $^    pyxtype0pywrapfstmutablesymboltable.tpgetattro  pyxpyobjectgenericgetattr$^  $^  if pyxsetvtablepyxtype0pywrapfstmutablesymboltable.tpdict pyxvtabptr0pywrapfstmutablesymboltable  0 pyxerr0 000 pyxl0error$^  if pyobjectsetattrstringpyxm mutablesymboltable pyobject pyxtype0pywrapfstmutablesymboltable  0 pyxerr0 000 pyxl0error$^  if pyxsetupreducepyobjectpyxtype0pywrapfstmutablesymboltable  0 pyxerr0 000 pyxl0error$^  pyxptype0pywrapfstmutablesymboltable  pyxtype0pywrapfstmutablesymboltable$^  pyxvtabptr0pywrapfstmutablefstsymboltable  pyxvtable0pywrapfstmutablefstsymboltable$^  pyxvtable0pywrapfstmutablefstsymboltable.pyxbase  pyxvtabptr0pywrapfstmutablesymboltable$^  pyxtype0pywrapfstmutablefstsymboltable.tpbase  pyxptype0pywrapfstmutablesymboltable$^  if pytypereadypyxtype0pywrapfstmutablefstsymboltable  0 pyxerr0 000 pyxl0error$^  pyxtype0pywrapfstmutablefstsymboltable.tpprint  0$^  if cythonusetypeslots  cythonusepytypelookup  likelypyxtype0pywrapfstmutablefstsymboltable.tpdictoffset  pyxtype0pywrapfstmutablefstsymboltable.tpgetattro  pyobjectgenericgetattr $^    pyxtype0pywrapfstmutablefstsymboltable.tpgetattro  pyxpyobjectgenericgetattr$^  $^  if pyxsetvtablepyxtype0pywrapfstmutablefstsymboltable.tpdict pyxvtabptr0pywrapfstmutablefstsymboltable  0 pyxerr0 000 pyxl0error$^  if pyobjectsetattrstringpyxm mutablefstsymboltable pyobject pyxtype0pywrapfstmutablefstsymboltable  0 pyxerr0 000 pyxl0error$^  if pyxsetupreducepyobjectpyxtype0pywrapfstmutablefstsymboltable  0 pyxerr0 000 pyxl0error$^  pyxptype0pywrapfstmutablefstsymboltable  pyxtype0pywrapfstmutablefstsymboltable$^  pyxvtabptr0pywrapfstsymboltable  pyxvtable0pywrapfstsymboltable$^  pyxvtable0pywrapfstsymboltable.pyxbase  pyxvtabptr0pywrapfstmutablesymboltable$^  pyxtype0pywrapfstsymboltable.tpbase  pyxptype0pywrapfstmutablesymboltable$^  if pytypereadypyxtype0pywrapfstsymboltable  0 pyxerr0 000 pyxl0error$^  pyxtype0pywrapfstsymboltable.tpprint  0$^  if cythonusetypeslots  cythonusepytypelookup  likelypyxtype0pywrapfstsymboltable.tpdictoffset  pyxtype0pywrapfstsymboltable.tpgetattro  pyobjectgenericgetattr $^    pyxtype0pywrapfstsymboltable.tpgetattro  pyxpyobjectgenericgetattr$^  $^  if pyxsetvtablepyxtype0pywrapfstsymboltable.tpdict pyxvtabptr0pywrapfstsymboltable  0 pyxerr0 000 pyxl0error$^  if pyobjectsetattrstringpyxm symboltable pyobject pyxtype0pywrapfstsymboltable  0 pyxerr0 000 pyxl0error$^  if pyxsetupreducepyobjectpyxtype0pywrapfstsymboltable  0 pyxerr0 000 pyxl0error$^  pyxptype0pywrapfstsymboltable  pyxtype0pywrapfstsymboltable$^  pyxvtabptr0pywrapfstsymboltableiterator  pyxvtable0pywrapfstsymboltableiterator$^  pyxvtable0pywrapfstsymboltableiterator.done  bool struct pyxobj0pywrapfstsymboltableiterator  int pyxskipdispatchpyxf0pywrapfst00symboltableiteratordone$^  pyxvtable0pywrapfstsymboltableiterator.next  void struct pyxobj0pywrapfstsymboltableiterator  int pyxskipdispatchpyxf0pywrapfst00symboltableiteratornext$^  pyxvtable0pywrapfstsymboltableiterator.reset  void struct pyxobj0pywrapfstsymboltableiterator  int pyxskipdispatchpyxf0pywrapfst00symboltableiteratorreset$^  pyxvtable0pywrapfstsymboltableiterator.symbol  stdstring struct pyxobj0pywrapfstsymboltableiterator  int pyxskipdispatchpyxf0pywrapfst00symboltableiteratorsymbol$^  pyxvtable0pywrapfstsymboltableiterator.value  pyxt00basictypesint00 struct pyxobj0pywrapfstsymboltableiterator  int pyxskipdispatchpyxf0pywrapfst00symboltableiteratorvalue$^  if pytypereadypyxtype0pywrapfstsymboltableiterator  0 pyxerr0 0000 pyxl0error$^  pyxtype0pywrapfstsymboltableiterator.tpprint  0$^  if cythonusetypeslots  cythonusepytypelookup  likelypyxtype0pywrapfstsymboltableiterator.tpdictoffset  pyxtype0pywrapfstsymboltableiterator.tpgetattro  pyobjectgenericgetattr $^    pyxtype0pywrapfstsymboltableiterator.tpgetattro  pyxpyobjectgenericgetattr$^  $^  if pyxsetvtablepyxtype0pywrapfstsymboltableiterator.tpdict pyxvtabptr0pywrapfstsymboltableiterator  0 pyxerr0 0000 pyxl0error$^  if pyobjectsetattrstringpyxm symboltableiterator pyobject pyxtype0pywrapfstsymboltableiterator  0 pyxerr0 0000 pyxl0error$^  if pyxsetupreducepyobjectpyxtype0pywrapfstsymboltableiterator  0 pyxerr0 0000 pyxl0error$^  pyxptype0pywrapfstsymboltableiterator  pyxtype0pywrapfstsymboltableiterator$^  pyxvtabptr0pywrapfstencodemapper  pyxvtable0pywrapfstencodemapper$^  pyxvtable0pywrapfstencodemapper.arctype  stdstring struct pyxobj0pywrapfstencodemapper  int pyxskipdispatchpyxf0pywrapfst00encodemapperarctype$^  pyxvtable0pywrapfstencodemapper.flags  pyxt00basictypesuint00 struct pyxobj0pywrapfstencodemapper  int pyxskipdispatchpyxf0pywrapfst00encodemapperflags$^  pyxvtable0pywrapfstencodemapper.inputsymbols  struct pyxobj0pywrapfstencodemappersymboltable struct pyxobj0pywrapfstencodemapper  int pyxskipdispatchpyxf0pywrapfst00encodemapperinputsymbols$^  pyxvtable0pywrapfstencodemapper.outputsymbols  struct pyxobj0pywrapfstencodemappersymboltable struct pyxobj0pywrapfstencodemapper  int pyxskipdispatchpyxf0pywrapfst00encodemapperoutputsymbols$^  pyxvtable0pywrapfstencodemapper.properties  pyxt00basictypesuint00 struct pyxobj0pywrapfstencodemapper  pyxt00basictypesuint00 int pyxskipdispatchpyxf0pywrapfst00encodemapperproperties$^  pyxvtable0pywrapfstencodemapper.setinputsymbols  void struct pyxobj0pywrapfstencodemapper  struct pyxobj0pywrapfstsymboltable  int pyxskipdispatchpyxf0pywrapfst00encodemappersetinputsymbols$^  pyxvtable0pywrapfstencodemapper.setoutputsymbols  void struct pyxobj0pywrapfstencodemapper  struct pyxobj0pywrapfstsymboltable  int pyxskipdispatchpyxf0pywrapfst00encodemappersetoutputsymbols$^  pyxvtable0pywrapfstencodemapper.weighttype  stdstring struct pyxobj0pywrapfstencodemapper  int pyxskipdispatchpyxf0pywrapfst00encodemapperweighttype$^  if pytypereadypyxtype0pywrapfstencodemapper  0 pyxerr0 0000 pyxl0error$^  pyxtype0pywrapfstencodemapper.tpprint  0$^  if cythonusetypeslots  cythonusepytypelookup  likelypyxtype0pywrapfstencodemapper.tpdictoffset  pyxtype0pywrapfstencodemapper.tpgetattro  pyobjectgenericgetattr $^    pyxtype0pywrapfstencodemapper.tpgetattro  pyxpyobjectgenericgetattr$^  $^  if cythoncompilingincpython$^  $^    pyobject wrapper  pyobjectgetattrstringpyobject pyxtype0pywrapfstencodemapper call if unlikelywrapper pyxerr0 0000 pyxl0error$^    if pytypewrapper  pywrapperdescrtype $^      pyxwrapperbase0pywrapfst00encodemapper0call  pywrapperdescrobject wrapperdbase$^      pyxwrapperbase0pywrapfst00encodemapper0call.doc  pyxdoc0pywrapfst00encodemapper0call$^      pywrapperdescrobject wrapperdbase  pyxwrapperbase0pywrapfst00encodemapper0call$^    $^  $^  endif$^  if pyxsetvtablepyxtype0pywrapfstencodemapper.tpdict pyxvtabptr0pywrapfstencodemapper  0 pyxerr0 0000 pyxl0error$^  if pyobjectsetattrstringpyxm encodemapper pyobject pyxtype0pywrapfstencodemapper  0 pyxerr0 0000 pyxl0error$^  if pyxsetupreducepyobjectpyxtype0pywrapfstencodemapper  0 pyxerr0 0000 pyxl0error$^  pyxptype0pywrapfstencodemapper  pyxtype0pywrapfstencodemapper$^  pyxvtabptr0pywrapfstfst  pyxvtable0pywrapfstfst$^  pyxvtable0pywrapfstfst.arctype  stdstring struct pyxobj0pywrapfstfst  int pyxskipdispatchpyxf0pywrapfst0fstarctype$^  pyxvtable0pywrapfstfst.arcs  struct pyxobj0pywrapfstarciterator struct pyxobj0pywrapfstfst  pyxt00basictypesint00 int pyxskipdispatchpyxf0pywrapfst0fstarcs$^  pyxvtable0pywrapfstfst.copy  struct pyxobj0pywrapfstfst struct pyxobj0pywrapfstfst  int pyxskipdispatchpyxf0pywrapfst0fstcopy$^  pyxvtable0pywrapfstfst.draw  void struct pyxobj0pywrapfstfst  pyobject  int pyxskipdispatch struct pyxoptargs0pywrapfst0fstdraw pyxoptionalargspyxf0pywrapfst0fstdraw$^  pyxvtable0pywrapfstfst.final  struct pyxobj0pywrapfstweight struct pyxobj0pywrapfstfst  pyxt00basictypesint00 int pyxskipdispatchpyxf0pywrapfst0fstfinal$^  pyxvtable0pywrapfstfst.fsttype  stdstring struct pyxobj0pywrapfstfst  int pyxskipdispatchpyxf0pywrapfst0fstfsttype$^  pyxvtable0pywrapfstfst.inputsymbols  struct pyxobj0pywrapfstfstsymboltable struct pyxobj0pywrapfstfst  int pyxskipdispatchpyxf0pywrapfst0fstinputsymbols$^  pyxvtable0pywrapfstfst.numarcs  sizet struct pyxobj0pywrapfstfst  pyxt00basictypesint00 int pyxskipdispatchpyxf0pywrapfst0fstnumarcs$^  pyxvtable0pywrapfstfst.numinputepsilons  sizet struct pyxobj0pywrapfstfst  pyxt00basictypesint00 int pyxskipdispatchpyxf0pywrapfst0fstnuminputepsilons$^  pyxvtable0pywrapfstfst.numoutputepsilons  sizet struct pyxobj0pywrapfstfst  pyxt00basictypesint00 int pyxskipdispatchpyxf0pywrapfst0fstnumoutputepsilons$^  pyxvtable0pywrapfstfst.outputsymbols  struct pyxobj0pywrapfstfstsymboltable struct pyxobj0pywrapfstfst  int pyxskipdispatchpyxf0pywrapfst0fstoutputsymbols$^  pyxvtable0pywrapfstfst.properties  pyxt00basictypesuint00 struct pyxobj0pywrapfstfst  pyxt00basictypesuint00 bool int pyxskipdispatchpyxf0pywrapfst0fstproperties$^  pyxvtable0pywrapfstfst.start  pyxt00basictypesint00 struct pyxobj0pywrapfstfst  int pyxskipdispatchpyxf0pywrapfst0fststart$^  pyxvtable0pywrapfstfst.states  struct pyxobj0pywrapfststateiterator struct pyxobj0pywrapfstfst  int pyxskipdispatchpyxf0pywrapfst0fststates$^  pyxvtable0pywrapfstfst.text  stdstring struct pyxobj0pywrapfstfst  int pyxskipdispatch struct pyxoptargs0pywrapfst0fsttext pyxoptionalargspyxf0pywrapfst0fsttext$^  pyxvtable0pywrapfstfst.verify  bool struct pyxobj0pywrapfstfst  int pyxskipdispatchpyxf0pywrapfst0fstverify$^  pyxvtable0pywrapfstfst.weighttype  stdstring struct pyxobj0pywrapfstfst  int pyxskipdispatchpyxf0pywrapfst0fstweighttype$^  pyxvtable0pywrapfstfst.write  void struct pyxobj0pywrapfstfst  pyobject  int pyxskipdispatchpyxf0pywrapfst0fstwrite$^  pyxvtable0pywrapfstfst.writetostring  stdstring struct pyxobj0pywrapfstfst  int pyxskipdispatchpyxf0pywrapfst0fstwritetostring$^  if pytypereadypyxtype0pywrapfstfst  0 pyxerr0 0000 pyxl0error$^  pyxtype0pywrapfstfst.tpprint  0$^  if cythonusetypeslots  cythonusepytypelookup  likelypyxtype0pywrapfstfst.tpdictoffset  pyxtype0pywrapfstfst.tpgetattro  pyobjectgenericgetattr $^    pyxtype0pywrapfstfst.tpgetattro  pyxpyobjectgenericgetattr$^  $^  if pyxsetvtablepyxtype0pywrapfstfst.tpdict pyxvtabptr0pywrapfstfst  0 pyxerr0 0000 pyxl0error$^  if pyobjectsetattrstringpyxm fst pyobject pyxtype0pywrapfstfst  0 pyxerr0 0000 pyxl0error$^  pyxptype0pywrapfstfst  pyxtype0pywrapfstfst$^  pyxvtabptr0pywrapfstmutablefst  pyxvtable0pywrapfstmutablefst$^  pyxvtable0pywrapfstmutablefst.pyxbase  pyxvtabptr0pywrapfstfst$^  pyxvtable0pywrapfstmutablefst.checkmutatingimethod  void struct pyxobj0pywrapfstmutablefst pyxf0pywrapfst00mutablefstcheckmutatingimethod$^  pyxvtable0pywrapfstmutablefst.addarc  void struct pyxobj0pywrapfstmutablefst  pyxt00basictypesint00 struct pyxobj0pywrapfstarc pyxf0pywrapfst00mutablefstaddarc$^  pyxvtable0pywrapfstmutablefst.addstate  pyxt00basictypesint00 struct pyxobj0pywrapfstmutablefst  int pyxskipdispatchpyxf0pywrapfst00mutablefstaddstate$^  pyxvtable0pywrapfstmutablefst.arcsort  void struct pyxobj0pywrapfstmutablefst  struct pyxoptargs0pywrapfst00mutablefstarcsort pyxoptionalargspyxf0pywrapfst00mutablefstarcsort$^  pyxvtable0pywrapfstmutablefst.closure  void struct pyxobj0pywrapfstmutablefst  struct pyxoptargs0pywrapfst00mutablefstclosure pyxoptionalargspyxf0pywrapfst00mutablefstclosure$^  pyxvtable0pywrapfstmutablefst.concat  void struct pyxobj0pywrapfstmutablefst  struct pyxobj0pywrapfstfst pyxf0pywrapfst00mutablefstconcat$^  pyxvtable0pywrapfstmutablefst.connect  void struct pyxobj0pywrapfstmutablefst pyxf0pywrapfst00mutablefstconnect$^  pyxvtable0pywrapfstmutablefst.decode  void struct pyxobj0pywrapfstmutablefst  struct pyxobj0pywrapfstencodemapper pyxf0pywrapfst00mutablefstdecode$^  pyxvtable0pywrapfstmutablefst.deletearcs  void struct pyxobj0pywrapfstmutablefst  pyxt00basictypesint00 struct pyxoptargs0pywrapfst00mutablefstdeletearcs pyxoptionalargspyxf0pywrapfst00mutablefstdeletearcs$^  pyxvtable0pywrapfstmutablefst.deletestates  void struct pyxobj0pywrapfstmutablefst  struct pyxoptargs0pywrapfst00mutablefstdeletestates pyxoptionalargspyxf0pywrapfst00mutablefstdeletestates$^  pyxvtable0pywrapfstmutablefst.encode  void struct pyxobj0pywrapfstmutablefst  struct pyxobj0pywrapfstencodemapper pyxf0pywrapfst00mutablefstencode$^  pyxvtable0pywrapfstmutablefst.invert  void struct pyxobj0pywrapfstmutablefst pyxf0pywrapfst00mutablefstinvert$^  pyxvtable0pywrapfstmutablefst.minimize  void struct pyxobj0pywrapfstmutablefst  struct pyxoptargs0pywrapfst00mutablefstminimize pyxoptionalargspyxf0pywrapfst00mutablefstminimize$^  pyxvtable0pywrapfstmutablefst.mutablearcs  struct pyxobj0pywrapfstmutablearciterator struct pyxobj0pywrapfstmutablefst  pyxt00basictypesint00 int pyxskipdispatchpyxf0pywrapfst00mutablefstmutablearcs$^  pyxvtable0pywrapfstmutablefst.numstates  pyxt00basictypesint00 struct pyxobj0pywrapfstmutablefst  int pyxskipdispatchpyxf0pywrapfst00mutablefstnumstates$^  pyxvtable0pywrapfstmutablefst.project  void struct pyxobj0pywrapfstmutablefst  struct pyxoptargs0pywrapfst00mutablefstproject pyxoptionalargspyxf0pywrapfst00mutablefstproject$^  pyxvtable0pywrapfstmutablefst.prune  void struct pyxobj0pywrapfstmutablefst  struct pyxoptargs0pywrapfst00mutablefstprune pyxoptionalargspyxf0pywrapfst00mutablefstprune$^  pyxvtable0pywrapfstmutablefst.push  void struct pyxobj0pywrapfstmutablefst  struct pyxoptargs0pywrapfst00mutablefstpush pyxoptionalargspyxf0pywrapfst00mutablefstpush$^  pyxvtable0pywrapfstmutablefst.relabelpairs  void struct pyxobj0pywrapfstmutablefst  struct pyxoptargs0pywrapfst00mutablefstrelabelpairs pyxoptionalargspyxf0pywrapfst00mutablefstrelabelpairs$^  pyxvtable0pywrapfstmutablefst.relabeltables  void struct pyxobj0pywrapfstmutablefst  struct pyxoptargs0pywrapfst00mutablefstrelabeltables pyxoptionalargspyxf0pywrapfst00mutablefstrelabeltables$^  pyxvtable0pywrapfstmutablefst.reservearcs  void struct pyxobj0pywrapfstmutablefst  pyxt00basictypesint00 sizetpyxf0pywrapfst00mutablefstreservearcs$^  pyxvtable0pywrapfstmutablefst.reservestates  void struct pyxobj0pywrapfstmutablefst  pyxt00basictypesint00pyxf0pywrapfst00mutablefstreservestates$^  pyxvtable0pywrapfstmutablefst.reweight  void struct pyxobj0pywrapfstmutablefst  pyobject  struct pyxoptargs0pywrapfst00mutablefstreweight pyxoptionalargspyxf0pywrapfst00mutablefstreweight$^  pyxvtable0pywrapfstmutablefst.rmepsilon  void struct pyxobj0pywrapfstmutablefst  struct pyxoptargs0pywrapfst00mutablefstrmepsilon pyxoptionalargspyxf0pywrapfst00mutablefstrmepsilon$^  pyxvtable0pywrapfstmutablefst.setfinal  void struct pyxobj0pywrapfstmutablefst  pyxt00basictypesint00 struct pyxoptargs0pywrapfst00mutablefstsetfinal pyxoptionalargspyxf0pywrapfst00mutablefstsetfinal$^  pyxvtable0pywrapfstmutablefst.setproperties  void struct pyxobj0pywrapfstmutablefst  pyxt00basictypesuint00 pyxt00basictypesuint00pyxf0pywrapfst00mutablefstsetproperties$^  pyxvtable0pywrapfstmutablefst.setstart  void struct pyxobj0pywrapfstmutablefst  pyxt00basictypesint00pyxf0pywrapfst00mutablefstsetstart$^  pyxvtable0pywrapfstmutablefst.setinputsymbols  void struct pyxobj0pywrapfstmutablefst  struct pyxobj0pywrapfstsymboltable pyxf0pywrapfst00mutablefstsetinputsymbols$^  pyxvtable0pywrapfstmutablefst.setoutputsymbols  void struct pyxobj0pywrapfstmutablefst  struct pyxobj0pywrapfstsymboltable pyxf0pywrapfst00mutablefstsetoutputsymbols$^  pyxvtable0pywrapfstmutablefst.topsort  void struct pyxobj0pywrapfstmutablefst pyxf0pywrapfst00mutablefsttopsort$^  pyxvtable0pywrapfstmutablefst.union  void struct pyxobj0pywrapfstmutablefst  struct pyxobj0pywrapfstfst pyxf0pywrapfst00mutablefstunion$^  pyxtype0pywrapfstmutablefst.tpbase  pyxptype0pywrapfstfst$^  if pytypereadypyxtype0pywrapfstmutablefst  0 pyxerr0 0000 pyxl0error$^  pyxtype0pywrapfstmutablefst.tpprint  0$^  if cythonusetypeslots  cythonusepytypelookup  likelypyxtype0pywrapfstmutablefst.tpdictoffset  pyxtype0pywrapfstmutablefst.tpgetattro  pyobjectgenericgetattr $^    pyxtype0pywrapfstmutablefst.tpgetattro  pyxpyobjectgenericgetattr$^  $^  if pyxsetvtablepyxtype0pywrapfstmutablefst.tpdict pyxvtabptr0pywrapfstmutablefst  0 pyxerr0 0000 pyxl0error$^  if pyobjectsetattrstringpyxm mutablefst pyobject pyxtype0pywrapfstmutablefst  0 pyxerr0 0000 pyxl0error$^  pyxptype0pywrapfstmutablefst  pyxtype0pywrapfstmutablefst$^  pyxvtabptr0pywrapfstarc  pyxvtable0pywrapfstarc$^  pyxvtable0pywrapfstarc.copy  struct pyxobj0pywrapfstarc struct pyxobj0pywrapfstarc  int pyxskipdispatchpyxf0pywrapfst0arccopy$^  if pytypereadypyxtype0pywrapfstarc  0 pyxerr0 0000 pyxl0error$^  pyxtype0pywrapfstarc.tpprint  0$^  if cythonusetypeslots  cythonusepytypelookup  likelypyxtype0pywrapfstarc.tpdictoffset  pyxtype0pywrapfstarc.tpgetattro  pyobjectgenericgetattr $^    pyxtype0pywrapfstarc.tpgetattro  pyxpyobjectgenericgetattr$^  $^  if pyxsetvtablepyxtype0pywrapfstarc.tpdict pyxvtabptr0pywrapfstarc  0 pyxerr0 0000 pyxl0error$^  if pyobjectsetattrstringpyxm arc pyobject pyxtype0pywrapfstarc  0 pyxerr0 0000 pyxl0error$^  if pyxsetupreducepyobjectpyxtype0pywrapfstarc  0 pyxerr0 0000 pyxl0error$^  pyxptype0pywrapfstarc  pyxtype0pywrapfstarc$^  pyxvtabptr0pywrapfstarciterator  pyxvtable0pywrapfstarciterator$^  pyxvtable0pywrapfstarciterator.done  bool struct pyxobj0pywrapfstarciterator  int pyxskipdispatchpyxf0pywrapfst00arciteratordone$^  pyxvtable0pywrapfstarciterator.flags  pyxt00basictypesuint00 struct pyxobj0pywrapfstarciterator  int pyxskipdispatchpyxf0pywrapfst00arciteratorflags$^  pyxvtable0pywrapfstarciterator.next  void struct pyxobj0pywrapfstarciterator  int pyxskipdispatchpyxf0pywrapfst00arciteratornext$^  pyxvtable0pywrapfstarciterator.position  sizet struct pyxobj0pywrapfstarciterator  int pyxskipdispatchpyxf0pywrapfst00arciteratorposition$^  pyxvtable0pywrapfstarciterator.reset  void struct pyxobj0pywrapfstarciterator  int pyxskipdispatchpyxf0pywrapfst00arciteratorreset$^  pyxvtable0pywrapfstarciterator.seek  void struct pyxobj0pywrapfstarciterator  sizet int pyxskipdispatchpyxf0pywrapfst00arciteratorseek$^  pyxvtable0pywrapfstarciterator.setflags  void struct pyxobj0pywrapfstarciterator  pyxt00basictypesuint00 pyxt00basictypesuint00 int pyxskipdispatchpyxf0pywrapfst00arciteratorsetflags$^  pyxvtable0pywrapfstarciterator.value  pyobject struct pyxobj0pywrapfstarciterator  int pyxskipdispatchpyxf0pywrapfst00arciteratorvalue$^  if pytypereadypyxtype0pywrapfstarciterator  0 pyxerr0 0000 pyxl0error$^  pyxtype0pywrapfstarciterator.tpprint  0$^  if cythonusetypeslots  cythonusepytypelookup  likelypyxtype0pywrapfstarciterator.tpdictoffset  pyxtype0pywrapfstarciterator.tpgetattro  pyobjectgenericgetattr $^    pyxtype0pywrapfstarciterator.tpgetattro  pyxpyobjectgenericgetattr$^  $^  if pyxsetvtablepyxtype0pywrapfstarciterator.tpdict pyxvtabptr0pywrapfstarciterator  0 pyxerr0 0000 pyxl0error$^  if pyobjectsetattrstringpyxm arciterator pyobject pyxtype0pywrapfstarciterator  0 pyxerr0 0000 pyxl0error$^  if pyxsetupreducepyobjectpyxtype0pywrapfstarciterator  0 pyxerr0 0000 pyxl0error$^  pyxptype0pywrapfstarciterator  pyxtype0pywrapfstarciterator$^  pyxvtabptr0pywrapfstmutablearciterator  pyxvtable0pywrapfstmutablearciterator$^  pyxvtable0pywrapfstmutablearciterator.done  bool struct pyxobj0pywrapfstmutablearciterator  int pyxskipdispatchpyxf0pywrapfst00mutablearciteratordone$^  pyxvtable0pywrapfstmutablearciterator.flags  pyxt00basictypesuint00 struct pyxobj0pywrapfstmutablearciterator  int pyxskipdispatchpyxf0pywrapfst00mutablearciteratorflags$^  pyxvtable0pywrapfstmutablearciterator.next  void struct pyxobj0pywrapfstmutablearciterator  int pyxskipdispatchpyxf0pywrapfst00mutablearciteratornext$^  pyxvtable0pywrapfstmutablearciterator.position  sizet struct pyxobj0pywrapfstmutablearciterator  int pyxskipdispatchpyxf0pywrapfst00mutablearciteratorposition$^  pyxvtable0pywrapfstmutablearciterator.reset  void struct pyxobj0pywrapfstmutablearciterator  int pyxskipdispatchpyxf0pywrapfst00mutablearciteratorreset$^  pyxvtable0pywrapfstmutablearciterator.seek  void struct pyxobj0pywrapfstmutablearciterator  sizet int pyxskipdispatchpyxf0pywrapfst00mutablearciteratorseek$^  pyxvtable0pywrapfstmutablearciterator.setflags  void struct pyxobj0pywrapfstmutablearciterator  pyxt00basictypesuint00 pyxt00basictypesuint00 int pyxskipdispatchpyxf0pywrapfst00mutablearciteratorsetflags$^  pyxvtable0pywrapfstmutablearciterator.setvalue  void struct pyxobj0pywrapfstmutablearciterator  struct pyxobj0pywrapfstarc  int pyxskipdispatchpyxf0pywrapfst00mutablearciteratorsetvalue$^  pyxvtable0pywrapfstmutablearciterator.value  pyobject struct pyxobj0pywrapfstmutablearciterator  int pyxskipdispatchpyxf0pywrapfst00mutablearciteratorvalue$^  if pytypereadypyxtype0pywrapfstmutablearciterator  0 pyxerr0 0000 pyxl0error$^  pyxtype0pywrapfstmutablearciterator.tpprint  0$^  if cythonusetypeslots  cythonusepytypelookup  likelypyxtype0pywrapfstmutablearciterator.tpdictoffset  pyxtype0pywrapfstmutablearciterator.tpgetattro  pyobjectgenericgetattr $^    pyxtype0pywrapfstmutablearciterator.tpgetattro  pyxpyobjectgenericgetattr$^  $^  if pyxsetvtablepyxtype0pywrapfstmutablearciterator.tpdict pyxvtabptr0pywrapfstmutablearciterator  0 pyxerr0 0000 pyxl0error$^  if pyobjectsetattrstringpyxm mutablearciterator pyobject pyxtype0pywrapfstmutablearciterator  0 pyxerr0 0000 pyxl0error$^  if pyxsetupreducepyobjectpyxtype0pywrapfstmutablearciterator  0 pyxerr0 0000 pyxl0error$^  pyxptype0pywrapfstmutablearciterator  pyxtype0pywrapfstmutablearciterator$^  pyxvtabptr0pywrapfststateiterator  pyxvtable0pywrapfststateiterator$^  pyxvtable0pywrapfststateiterator.done  bool struct pyxobj0pywrapfststateiterator  int pyxskipdispatchpyxf0pywrapfst00stateiteratordone$^  pyxvtable0pywrapfststateiterator.next  void struct pyxobj0pywrapfststateiterator  int pyxskipdispatchpyxf0pywrapfst00stateiteratornext$^  pyxvtable0pywrapfststateiterator.reset  void struct pyxobj0pywrapfststateiterator  int pyxskipdispatchpyxf0pywrapfst00stateiteratorreset$^  pyxvtable0pywrapfststateiterator.value  pyxt00basictypesint00 struct pyxobj0pywrapfststateiterator  int pyxskipdispatchpyxf0pywrapfst00stateiteratorvalue$^  if pytypereadypyxtype0pywrapfststateiterator  0 pyxerr0 0000 pyxl0error$^  pyxtype0pywrapfststateiterator.tpprint  0$^  if cythonusetypeslots  cythonusepytypelookup  likelypyxtype0pywrapfststateiterator.tpdictoffset  pyxtype0pywrapfststateiterator.tpgetattro  pyobjectgenericgetattr $^    pyxtype0pywrapfststateiterator.tpgetattro  pyxpyobjectgenericgetattr$^  $^  if pyxsetvtablepyxtype0pywrapfststateiterator.tpdict pyxvtabptr0pywrapfststateiterator  0 pyxerr0 0000 pyxl0error$^  if pyobjectsetattrstringpyxm stateiterator pyobject pyxtype0pywrapfststateiterator  0 pyxerr0 0000 pyxl0error$^  if pyxsetupreducepyobjectpyxtype0pywrapfststateiterator  0 pyxerr0 0000 pyxl0error$^  pyxptype0pywrapfststateiterator  pyxtype0pywrapfststateiterator$^  pyxvtabptr0pywrapfstcompiler  pyxvtable0pywrapfstcompiler$^  pyxvtable0pywrapfstcompiler.compile  struct pyxobj0pywrapfstfst struct pyxobj0pywrapfstcompiler  int pyxskipdispatchpyxf0pywrapfst0compilercompile$^  pyxvtable0pywrapfstcompiler.write  void struct pyxobj0pywrapfstcompiler  pyobject  int pyxskipdispatchpyxf0pywrapfst0compilerwrite$^  if pytypereadypyxtype0pywrapfstcompiler  0 pyxerr0 0000 pyxl0error$^  pyxtype0pywrapfstcompiler.tpprint  0$^  if cythonusetypeslots  cythonusepytypelookup  likelypyxtype0pywrapfstcompiler.tpdictoffset  pyxtype0pywrapfstcompiler.tpgetattro  pyobjectgenericgetattr $^    pyxtype0pywrapfstcompiler.tpgetattro  pyxpyobjectgenericgetattr$^  $^  if pyxsetvtablepyxtype0pywrapfstcompiler.tpdict pyxvtabptr0pywrapfstcompiler  0 pyxerr0 0000 pyxl0error$^  if pyobjectsetattrstringpyxm compiler pyobject pyxtype0pywrapfstcompiler  0 pyxerr0 0000 pyxl0error$^  if pyxsetupreducepyobjectpyxtype0pywrapfstcompiler  0 pyxerr0 0000 pyxl0error$^  pyxptype0pywrapfstcompiler  pyxtype0pywrapfstcompiler$^  pyxvtabptr0pywrapfstfarreader  pyxvtable0pywrapfstfarreader$^  pyxvtable0pywrapfstfarreader.arctype  stdstring struct pyxobj0pywrapfstfarreader  int pyxskipdispatchpyxf0pywrapfst0farreaderarctype$^  pyxvtable0pywrapfstfarreader.done  bool struct pyxobj0pywrapfstfarreader  int pyxskipdispatchpyxf0pywrapfst0farreaderdone$^  pyxvtable0pywrapfstfarreader.error  bool struct pyxobj0pywrapfstfarreader  int pyxskipdispatchpyxf0pywrapfst0farreadererror$^  pyxvtable0pywrapfstfarreader.fartype  stdstring struct pyxobj0pywrapfstfarreader  int pyxskipdispatchpyxf0pywrapfst0farreaderfartype$^  pyxvtable0pywrapfstfarreader.find  bool struct pyxobj0pywrapfstfarreader  pyobject  int pyxskipdispatchpyxf0pywrapfst0farreaderfind$^  pyxvtable0pywrapfstfarreader.getfst  struct pyxobj0pywrapfstfst struct pyxobj0pywrapfstfarreader  int pyxskipdispatchpyxf0pywrapfst0farreadergetfst$^  pyxvtable0pywrapfstfarreader.getkey  stdstring struct pyxobj0pywrapfstfarreader  int pyxskipdispatchpyxf0pywrapfst0farreadergetkey$^  pyxvtable0pywrapfstfarreader.next  void struct pyxobj0pywrapfstfarreader  int pyxskipdispatchpyxf0pywrapfst0farreadernext$^  pyxvtable0pywrapfstfarreader.reset  void struct pyxobj0pywrapfstfarreader  int pyxskipdispatchpyxf0pywrapfst0farreaderreset$^  if pytypereadypyxtype0pywrapfstfarreader  0 pyxerr0 0000 pyxl0error$^  pyxtype0pywrapfstfarreader.tpprint  0$^  if cythonusetypeslots  cythonusepytypelookup  likelypyxtype0pywrapfstfarreader.tpdictoffset  pyxtype0pywrapfstfarreader.tpgetattro  pyobjectgenericgetattr $^    pyxtype0pywrapfstfarreader.tpgetattro  pyxpyobjectgenericgetattr$^  $^  if pyxsetvtablepyxtype0pywrapfstfarreader.tpdict pyxvtabptr0pywrapfstfarreader  0 pyxerr0 0000 pyxl0error$^  if pyobjectsetattrstringpyxm farreader pyobject pyxtype0pywrapfstfarreader  0 pyxerr0 0000 pyxl0error$^  if pyxsetupreducepyobjectpyxtype0pywrapfstfarreader  0 pyxerr0 0000 pyxl0error$^  pyxptype0pywrapfstfarreader  pyxtype0pywrapfstfarreader$^  pyxvtabptr0pywrapfstfarwriter  pyxvtable0pywrapfstfarwriter$^  pyxvtable0pywrapfstfarwriter.arctype  stdstring struct pyxobj0pywrapfstfarwriter  int pyxskipdispatchpyxf0pywrapfst0farwriterarctype$^  pyxvtable0pywrapfstfarwriter.close  void struct pyxobj0pywrapfstfarwriter pyxf0pywrapfst0farwriterclose$^  pyxvtable0pywrapfstfarwriter.add  void struct pyxobj0pywrapfstfarwriter  pyobject  struct pyxobj0pywrapfstfst  int pyxskipdispatchpyxf0pywrapfst0farwriteradd$^  pyxvtable0pywrapfstfarwriter.error  bool struct pyxobj0pywrapfstfarwriter  int pyxskipdispatchpyxf0pywrapfst0farwritererror$^  pyxvtable0pywrapfstfarwriter.fartype  stdstring struct pyxobj0pywrapfstfarwriter  int pyxskipdispatchpyxf0pywrapfst0farwriterfartype$^  if pytypereadypyxtype0pywrapfstfarwriter  0 pyxerr0 0000 pyxl0error$^  pyxtype0pywrapfstfarwriter.tpprint  0$^  if cythonusetypeslots  cythonusepytypelookup  likelypyxtype0pywrapfstfarwriter.tpdictoffset  pyxtype0pywrapfstfarwriter.tpgetattro  pyobjectgenericgetattr $^    pyxtype0pywrapfstfarwriter.tpgetattro  pyxpyobjectgenericgetattr$^  $^  if pyxsetvtablepyxtype0pywrapfstfarwriter.tpdict pyxvtabptr0pywrapfstfarwriter  0 pyxerr0 0000 pyxl0error$^  if pyobjectsetattrstringpyxm farwriter pyobject pyxtype0pywrapfstfarwriter  0 pyxerr0 0000 pyxl0error$^  if pyxsetupreducepyobjectpyxtype0pywrapfstfarwriter  0 pyxerr0 0000 pyxl0error$^  pyxptype0pywrapfstfarwriter  pyxtype0pywrapfstfarwriter$^  pyxrefnannyfinishcontext$^  return 0$^  pyxl0error$^  pyxrefnannyfinishcontext$^  return 0$^$^$^static int pyxmodinittypeimportcodevoid $^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextpyxmodinittypeimportcode 0$^   type import code $^  pyxrefnannyfinishcontext$^  return 0$^$^$^static int pyxmodinitvariableimportcodevoid $^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextpyxmodinitvariableimportcode 0$^   variable import code $^  pyxrefnannyfinishcontext$^  return 0$^$^$^static int pyxmodinitfunctionimportcodevoid $^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextpyxmodinitfunctionimportcode 0$^   function import code $^  pyxrefnannyfinishcontext$^  return 0$^$^$^$^if pymajorversion  0$^ifdef cythonnopyinitexport$^define pyxpymodinitfunc void$^else$^define pyxpymodinitfunc pymodinitfunc$^endif$^else$^ifdef cythonnopyinitexport$^define pyxpymodinitfunc pyobject $^else$^define pyxpymodinitfunc pymodinitfunc$^endif$^endif$^ifndef cythonsmallcode$^if definedclang$^    define cythonsmallcode$^elif definedgnuc  definedcplusplus  gnuc  0  gnuc  0  gnucminor  0$^    define cythonsmallcode attributeoptimizeos$^else$^    define cythonsmallcode$^endif$^endif$^$^$^if pymajorversion  0$^pyxpymodinitfunc initpywrapfstvoid cythonsmallcode proto$^pyxpymodinitfunc initpywrapfstvoid$^else$^pyxpymodinitfunc pyinitpywrapfstvoid cythonsmallcode proto$^pyxpymodinitfunc pyinitpywrapfstvoid$^if cythonpep000multiphaseinit$^$^  return pymoduledefinitpyxmoduledef$^$^static int pyxcopyspectomodulepyobject spec pyobject moddict const char fromname const char toname $^    pyobject value  pyobjectgetattrstringspec fromname$^    int result  0$^    if likelyvalue $^        result  pydictsetitemstringmoddict toname value$^        pydecrefvalue$^     else if pyerrexceptionmatchespyexcattributeerror $^        pyerrclear$^     else $^        result  0$^    $^    return result$^$^static pyobject pyxpymodcreatepyobject spec cythonunused pymoduledef def $^    pyobject module  null moddict modname$^    if pyxm$^        return pyxnewrefpyxm$^    modname  pyobjectgetattrstringspec name$^    if unlikelymodname goto bad$^    module  pymodulenewobjectmodname$^    pydecrefmodname$^    if unlikelymodule goto bad$^    moddict  pymodulegetdictmodule$^    if unlikelymoddict goto bad$^    if unlikelypyxcopyspectomodulespec moddict loader loader  0 goto bad$^    if unlikelypyxcopyspectomodulespec moddict origin file  0 goto bad$^    if unlikelypyxcopyspectomodulespec moddict parent package  0 goto bad$^    if unlikelypyxcopyspectomodulespec moddict submodulesearchlocations path  0 goto bad$^    return module$^bad$^    pyxdecrefmodule$^    return null$^$^$^$^static int pyxpymodexecpywrapfstpyobject pyxpyinitmodule$^endif$^endif$^$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxt00basictypesint00 pyxt0$^  stdstring pyxt0$^  pyxrefnannydeclarations$^  if cythonpep000multiphaseinit$^  if pyxm  pyxm  pyxpyinitmodule return 0$^  elif pymajorversion  0$^  if pyxm return pyxnewrefpyxm$^  endif$^  if cythonrefnanny$^pyxrefnanny  pyxrefnannyimportapirefnanny$^if pyxrefnanny $^  pyerrclear$^  pyxrefnanny  pyxrefnannyimportapicython.runtime.refnanny$^  if pyxrefnanny$^      pyfatalerrorfailed to import refnanny module$^$^endif$^  pyxrefnannysetupcontextpyxpymodinitfunc pyinitpywrapfstvoid 0$^  if pyxcheckbinaryversion  0 pyxerr0 0 pyxl0error$^  pyxemptytuple  pytuplenew0 if unlikelypyxemptytuple pyxerr0 0 pyxl0error$^  pyxemptybytes  pybytesfromstringandsize 0 if unlikelypyxemptybytes pyxerr0 0 pyxl0error$^  pyxemptyunicode  pyunicodefromstringandsize 0 if unlikelypyxemptyunicode pyxerr0 0 pyxl0error$^  ifdef pyxcyfunctionused$^  if pyxcyfunctioninit  0 pyxerr0 0 pyxl0error$^  endif$^  ifdef pyxfusedfunctionused$^  if pyxfusedfunctioninit  0 pyxerr0 0 pyxl0error$^  endif$^  ifdef pyxcoroutineused$^  if pyxcoroutineinit  0 pyxerr0 0 pyxl0error$^  endif$^  ifdef pyxgeneratorused$^  if pyxgeneratorinit  0 pyxerr0 0 pyxl0error$^  endif$^  ifdef pyxasyncgenused$^  if pyxasyncgeninit  0 pyxerr0 0 pyxl0error$^  endif$^  ifdef pyxstopasynciterationused$^  if pyxstopasynciterationinit  0 pyxerr0 0 pyxl0error$^  endif$^   library function declarations $^   threads initialization code $^  if definedpyxforceinitthreads  pyxforceinitthreads$^  ifdef withthread  python build with threading support $^  pyevalinitthreads$^  endif$^  endif$^   module creation code $^  if cythonpep000multiphaseinit$^  pyxm  pyxpyinitmodule$^  pyincrefpyxm$^  else$^  if pymajorversion  0$^  pyxm  pyinitmodule0pywrapfst pyxmethods pyxkpythoninterfacetothefstscri 0 pythonapiversion pyxincrefpyxm$^  else$^  pyxm  pymodulecreatepyxmoduledef$^  endif$^  if unlikelypyxm pyxerr0 0 pyxl0error$^  endif$^  pyxd  pymodulegetdictpyxm if unlikelypyxd pyxerr0 0 pyxl0error$^  pyincrefpyxd$^  pyxb  pyimportaddmodulepyxbuiltinmodulename if unlikelypyxb pyxerr0 0 pyxl0error$^  pyxcythonruntime  pyimportaddmodulechar  cythonruntime if unlikelypyxcythonruntime pyxerr0 0 pyxl0error$^  if cythoncompilinginpypy$^  pyincrefpyxb$^  endif$^  if pyobjectsetattrstringpyxm builtins pyxb  0 pyxerr0 0 pyxl0error$^   initialize various global constants etc. $^  if pyxinitglobals  0 pyxerr0 0 pyxl0error$^  if pymajorversion  0  pyxdefaultstringencodingisascii  pyxdefaultstringencodingisdefault$^  if pyxinitsysgetdefaultencodingparams  0 pyxerr0 0 pyxl0error$^  endif$^  if pyxmoduleismainpywrapfst $^    if pyobjectsetattrstringpyxm name pyxnsmain  0 pyxerr0 0 pyxl0error$^  $^  if pymajorversion  0$^  $^    pyobject modules  pyimportgetmoduledict if unlikelymodules pyxerr0 0 pyxl0error$^    if pydictgetitemstringmodules pywrapfst $^      if unlikelypydictsetitemstringmodules pywrapfst pyxm  0 pyxerr0 0 pyxl0error$^    $^  $^  endif$^   builtin init code $^  if pyxinitcachedbuiltins  0 pyxerr0 0 pyxl0error$^   constants init code $^  if pyxinitcachedconstants  0 pyxerr0 0 pyxl0error$^   global typefunction init code $^  voidpyxmodinitglobalinitcode$^  voidpyxmodinitvariableexportcode$^  if unlikelypyxmodinitfunctionexportcode  0 goto pyxl0error$^  if unlikelypyxmodinittypeinitcode  0 goto pyxl0error$^  voidpyxmodinittypeimportcode$^  voidpyxmodinitvariableimportcode$^  voidpyxmodinitfunctionimportcode$^   execution code $^  if definedpyxgeneratorused  definedpyxcoroutineused$^  if pyxpatchabc  0 pyxerr0 0 pyxl0error$^  endif$^$^   pywrapfst.pyx000$^  $^   python imports.$^  import atexit              $^  import numbers$^  import subprocess$^ $^  pyxt0  pyximportpyxnsatexit 0 0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  if pydictsetitempyxd pyxnsatexit pyxt0  0 pyxerr0 000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^$^   pywrapfst.pyx000$^   python imports.$^  import atexit$^  import numbers              $^  import subprocess$^  import logging$^ $^  pyxt0  pyximportpyxnsnumbers 0 0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  if pydictsetitempyxd pyxnsnumbers pyxt0  0 pyxerr0 000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^$^   pywrapfst.pyx000$^  import atexit$^  import numbers$^  import subprocess              $^  import logging$^  $^ $^  pyxt0  pyximportpyxnssubprocess 0 0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  if pydictsetitempyxd pyxnssubprocess pyxt0  0 pyxerr0 000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^$^   pywrapfst.pyx000$^  import numbers$^  import subprocess$^  import logging              $^  $^  $^ $^  pyxt0  pyximportpyxnslogging 0 0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  if pydictsetitempyxd pyxnslogging pyxt0  0 pyxerr0 000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^$^   pywrapfst.pyx000$^   todokbg figure out how to access static class variables so i dont have$^   to do it this way.$^  knosymbol  0              $^  $^  $^ $^  if pydictsetitempyxd pyxnsknosymbol pyxintneg0  0 pyxerr0 000 pyxl0error$^$^   pywrapfst.pyx000$^  $^  $^  class fsterrorexception              $^  $^    pass$^ $^  pyxt0  pytuplenew0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxincrefpyobject pytypeobjectpyexcexception0$^  pyxgiverefpyobject pytypeobjectpyexcexception0$^  pytuplesetitempyxt0 0 pyobject pytypeobjectpyexcexception0$^  pyxt0  pyxcalculatemetaclassnull pyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxt0  pyxpy0metaclasspreparepyxt0 pyxt0 pyxnsfsterror pyxnsfsterror pyobject  null pyxnspywrapfst0 pyobject  null if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxt0  pyxpy0classcreatepyxt0 pyxnsfsterror pyxt0 pyxt0 null 0 0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  if pydictsetitempyxd pyxnsfsterror pyxt0  0 pyxerr0 000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^  pyxdecrefpyxt0 pyxt0  0$^  pyxdecrefpyxt0 pyxt0  0$^  pyxdecrefpyxt0 pyxt0  0$^$^   pywrapfst.pyx000$^  $^  $^  class fstargerrorfsterror valueerror              $^  $^    pass$^ $^  pyxt0  pyxgetmoduleglobalnamepyxnsfsterror if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxt0  pytuplenew0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxgiverefpyxt0$^  pytuplesetitempyxt0 0 pyxt0$^  pyxincrefpyxbuiltinvalueerror$^  pyxgiverefpyxbuiltinvalueerror$^  pytuplesetitempyxt0 0 pyxbuiltinvalueerror$^  pyxt0  0$^  pyxt0  pyxcalculatemetaclassnull pyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxt0  pyxpy0metaclasspreparepyxt0 pyxt0 pyxnsfstargerror pyxnsfstargerror pyobject  null pyxnspywrapfst0 pyobject  null if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxt0  pyxpy0classcreatepyxt0 pyxnsfstargerror pyxt0 pyxt0 null 0 0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  if pydictsetitempyxd pyxnsfstargerror pyxt0  0 pyxerr0 000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^  pyxdecrefpyxt0 pyxt0  0$^  pyxdecrefpyxt0 pyxt0  0$^  pyxdecrefpyxt0 pyxt0  0$^$^   pywrapfst.pyx000$^  $^  $^  class fstbadweighterrorfsterror valueerror              $^  $^    pass$^ $^  pyxt0  pyxgetmoduleglobalnamepyxnsfsterror if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxt0  pytuplenew0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxgiverefpyxt0$^  pytuplesetitempyxt0 0 pyxt0$^  pyxincrefpyxbuiltinvalueerror$^  pyxgiverefpyxbuiltinvalueerror$^  pytuplesetitempyxt0 0 pyxbuiltinvalueerror$^  pyxt0  0$^  pyxt0  pyxcalculatemetaclassnull pyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxt0  pyxpy0metaclasspreparepyxt0 pyxt0 pyxnsfstbadweighterror pyxnsfstbadweighterror pyobject  null pyxnspywrapfst0 pyobject  null if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxt0  pyxpy0classcreatepyxt0 pyxnsfstbadweighterror pyxt0 pyxt0 null 0 0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  if pydictsetitempyxd pyxnsfstbadweighterror pyxt0  0 pyxerr0 000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^  pyxdecrefpyxt0 pyxt0  0$^  pyxdecrefpyxt0 pyxt0  0$^  pyxdecrefpyxt0 pyxt0  0$^$^   pywrapfst.pyx000$^  $^  $^  class fstdeletedconstructorerrorfsterror runtimeerror              $^  $^    pass$^ $^  pyxt0  pyxgetmoduleglobalnamepyxnsfsterror if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxt0  pytuplenew0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxgiverefpyxt0$^  pytuplesetitempyxt0 0 pyxt0$^  pyxincrefpyxbuiltinruntimeerror$^  pyxgiverefpyxbuiltinruntimeerror$^  pytuplesetitempyxt0 0 pyxbuiltinruntimeerror$^  pyxt0  0$^  pyxt0  pyxcalculatemetaclassnull pyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxt0  pyxpy0metaclasspreparepyxt0 pyxt0 pyxnsfstdeletedconstructorerror pyxnsfstdeletedconstructorerror pyobject  null pyxnspywrapfst0 pyobject  null if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxt0  pyxpy0classcreatepyxt0 pyxnsfstdeletedconstructorerror pyxt0 pyxt0 null 0 0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  if pydictsetitempyxd pyxnsfstdeletedconstructorerror pyxt0  0 pyxerr0 000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^  pyxdecrefpyxt0 pyxt0  0$^  pyxdecrefpyxt0 pyxt0  0$^  pyxdecrefpyxt0 pyxt0  0$^$^   pywrapfst.pyx000$^  $^  $^  class fstindexerrorfsterror indexerror              $^  $^    pass$^ $^  pyxt0  pyxgetmoduleglobalnamepyxnsfsterror if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxt0  pytuplenew0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxgiverefpyxt0$^  pytuplesetitempyxt0 0 pyxt0$^  pyxincrefpyxbuiltinindexerror$^  pyxgiverefpyxbuiltinindexerror$^  pytuplesetitempyxt0 0 pyxbuiltinindexerror$^  pyxt0  0$^  pyxt0  pyxcalculatemetaclassnull pyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxt0  pyxpy0metaclasspreparepyxt0 pyxt0 pyxnsfstindexerror pyxnsfstindexerror pyobject  null pyxnspywrapfst0 pyobject  null if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxt0  pyxpy0classcreatepyxt0 pyxnsfstindexerror pyxt0 pyxt0 null 0 0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  if pydictsetitempyxd pyxnsfstindexerror pyxt0  0 pyxerr0 000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^  pyxdecrefpyxt0 pyxt0  0$^  pyxdecrefpyxt0 pyxt0  0$^  pyxdecrefpyxt0 pyxt0  0$^$^   pywrapfst.pyx000$^  $^  $^  class fstioerrorfsterror ioerror              $^  $^    pass$^ $^  pyxt0  pyxgetmoduleglobalnamepyxnsfsterror if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxt0  pytuplenew0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxgiverefpyxt0$^  pytuplesetitempyxt0 0 pyxt0$^  pyxincrefpyxbuiltinioerror$^  pyxgiverefpyxbuiltinioerror$^  pytuplesetitempyxt0 0 pyxbuiltinioerror$^  pyxt0  0$^  pyxt0  pyxcalculatemetaclassnull pyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxt0  pyxpy0metaclasspreparepyxt0 pyxt0 pyxnsfstioerror pyxnsfstioerror pyobject  null pyxnspywrapfst0 pyobject  null if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxt0  pyxpy0classcreatepyxt0 pyxnsfstioerror pyxt0 pyxt0 null 0 0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  if pydictsetitempyxd pyxnsfstioerror pyxt0  0 pyxerr0 000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^  pyxdecrefpyxt0 pyxt0  0$^  pyxdecrefpyxt0 pyxt0  0$^  pyxdecrefpyxt0 pyxt0  0$^$^   pywrapfst.pyx000$^  $^  $^  class fstoperrorfsterror runtimeerror              $^  $^    pass$^ $^  pyxt0  pyxgetmoduleglobalnamepyxnsfsterror if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxt0  pytuplenew0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxgiverefpyxt0$^  pytuplesetitempyxt0 0 pyxt0$^  pyxincrefpyxbuiltinruntimeerror$^  pyxgiverefpyxbuiltinruntimeerror$^  pytuplesetitempyxt0 0 pyxbuiltinruntimeerror$^  pyxt0  0$^  pyxt0  pyxcalculatemetaclassnull pyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxt0  pyxpy0metaclasspreparepyxt0 pyxt0 pyxnsfstoperror pyxnsfstoperror pyobject  null pyxnspywrapfst0 pyobject  null if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxt0  pyxpy0classcreatepyxt0 pyxnsfstoperror pyxt0 pyxt0 null 0 0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  if pydictsetitempyxd pyxnsfstoperror pyxt0  0 pyxerr0 000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^  pyxdecrefpyxt0 pyxt0  0$^  pyxdecrefpyxt0 pyxt0  0$^  pyxdecrefpyxt0 pyxt0  0$^$^   pywrapfst.pyx000$^  $^    classmethod$^    def zerocls weighttype              $^      $^      weight.zeroweighttype$^ $^  pyxt0  pyxgetnameinclasspyobject pyxptype0pywrapfstweight pyxnszero if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^$^   pywrapfst.pyx000$^     c part outofclass and then call it from within.$^  $^    classmethod              $^    def zerocls weighttype$^      $^ $^  pyxt0  pyxmethodclassmethodpyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxdecrefpyxt0 pyxt0  0$^  if pydictsetitempyobject pyxptype0pywrapfstweighttpdict pyxnszero pyxt0  0 pyxerr0 000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^  pytypemodifiedpyxptype0pywrapfstweight$^$^   pywrapfst.pyx000$^  $^    classmethod$^    def onecls weighttype              $^      $^      weight.oneweighttype$^ $^  pyxt0  pyxgetnameinclasspyobject pyxptype0pywrapfstweight pyxnsone if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^$^   pywrapfst.pyx000$^      return zeroweighttype$^  $^    classmethod              $^    def onecls weighttype$^      $^ $^  pyxt0  pyxmethodclassmethodpyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxdecrefpyxt0 pyxt0  0$^  if pydictsetitempyobject pyxptype0pywrapfstweighttpdict pyxnsone pyxt0  0 pyxerr0 000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^  pytypemodifiedpyxptype0pywrapfstweight$^$^   pywrapfst.pyx000$^  $^    classmethod$^    def noweightcls weighttype              $^      $^      weight.noweightweighttype$^ $^  pyxt0  pyxgetnameinclasspyobject pyxptype0pywrapfstweight pyxnsnoweight if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^$^   pywrapfst.pyx000$^      return oneweighttype$^  $^    classmethod              $^    def noweightcls weighttype$^      $^ $^  pyxt0  pyxmethodclassmethodpyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxdecrefpyxt0 pyxt0  0$^  if pydictsetitempyobject pyxptype0pywrapfstweighttpdict pyxnsnoweight pyxt0  0 pyxerr0 000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^  pytypemodifiedpyxptype0pywrapfstweight$^$^   pywrapfst.pyx000$^  $^  $^  def plusweight lhs weight rhs              $^    $^    pluslhs rhs$^ $^  pyxt0  pycfunctionnewexpyxmdef0pywrapfst0plus null pyxnspywrapfst0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  if pydictsetitempyxd pyxnsplus pyxt0  0 pyxerr0 000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^$^   pywrapfst.pyx000$^  $^  $^  def timesweight lhs weight rhs              $^    $^    timeslhs rhs$^ $^  pyxt0  pycfunctionnewexpyxmdef0pywrapfst0times null pyxnspywrapfst0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  if pydictsetitempyxd pyxnstimes pyxt0  0 pyxerr0 000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^$^   pywrapfst.pyx000$^  $^  $^  def divideweight lhs weight rhs              $^    $^    dividelhs rhs$^ $^  pyxt0  pycfunctionnewexpyxmdef0pywrapfst0divide null pyxnspywrapfst0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  if pydictsetitempyxd pyxnsdivide pyxt0  0 pyxerr0 000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^$^   pywrapfst.pyx000$^  $^  $^  def powerweight w sizet n              $^    $^    powerlhs rhs$^ $^  pyxt0  pycfunctionnewexpyxmdef0pywrapfst0power null pyxnspywrapfst0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  if pydictsetitempyxd pyxnspower pyxt0  0 pyxerr0 000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^$^   pywrapfst.pyx000$^    $^  $^    cpdef int00 addsymbolself symbol int00 keyknosymbol              $^      $^      addsymbolself symbol keynosymbol$^ $^  pyxt0  pyxgetmoduleglobalnamepyxnsknosymbol if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxt0  pyxpyintasint00tpyxt0 if unlikelypyxt0  int00t0  pyerroccurred pyxerr0 000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^  pyxk00  pyxt0$^  pyxt0  pyxgetmoduleglobalnamepyxnsknosymbol if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxt0  pyxpyintasint00tpyxt0 if unlikelypyxt0  int00t0  pyerroccurred pyxerr0 000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^  pyxk00  pyxt0$^$^   pywrapfst.pyx000$^  $^    classmethod$^    def readcls filename              $^      $^      symboltable.readfilename$^ $^  pyxt0  pyxgetnameinclasspyobject pyxptype0pywrapfstsymboltable pyxnsread if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^$^   pywrapfst.pyx000$^      self.smarttable.resetself.table$^  $^    classmethod              $^    def readcls filename$^      $^ $^  pyxt0  pyxmethodclassmethodpyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxdecrefpyxt0 pyxt0  0$^  if pydictsetitempyobject pyxptype0pywrapfstsymboltabletpdict pyxnsread pyxt0  0 pyxerr0 000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^  pytypemodifiedpyxptype0pywrapfstsymboltable$^$^   pywrapfst.pyx000$^  $^    classmethod$^    def readtextcls filename bool allownegativelabelsfalse              $^      $^      symboltable.readtextfilename$^ $^  pyxt0  pyxgetnameinclasspyobject pyxptype0pywrapfstsymboltable pyxnsreadtext if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^$^   pywrapfst.pyx000$^      return initsymboltabletsyms$^  $^    classmethod              $^    def readtextcls filename bool allownegativelabelsfalse$^      $^ $^  pyxt0  pyxmethodclassmethodpyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxdecrefpyxt0 pyxt0  0$^  if pydictsetitempyobject pyxptype0pywrapfstsymboltabletpdict pyxnsreadtext pyxt0  0 pyxerr0 000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^  pytypemodifiedpyxptype0pywrapfstsymboltable$^$^   pywrapfst.pyx0000$^  $^    classmethod$^    def readfstcls filename bool inputtable              $^      $^      symboltable.readfstfilename inputtable$^ $^  pyxt0  pyxgetnameinclasspyobject pyxptype0pywrapfstsymboltable pyxnsreadfst if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^$^   pywrapfst.pyx0000$^      return initsymboltabletsyms$^  $^    classmethod              $^    def readfstcls filename bool inputtable$^      $^ $^  pyxt0  pyxmethodclassmethodpyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxdecrefpyxt0 pyxt0  0$^  if pydictsetitempyobject pyxptype0pywrapfstsymboltabletpdict pyxnsreadfst pyxt0  0 pyxerr0 0000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^  pytypemodifiedpyxptype0pywrapfstsymboltable$^$^   pywrapfst.pyx0000$^      return self$^  $^    cdef void minimizeself float deltafst.kshortestdelta              $^                        bool allownondetfalse except $^       this runs inplace when the second argument is null.$^ $^  pyxk00  fstkshortestdelta$^$^   pywrapfst.pyx0000$^      self.checkmutatingimethod$^  $^    def minimizeself float deltafst.kshortestdelta bool allownondetfalse              $^      $^      minimizeself delta0e0 allownondetfalse$^ $^  pyxk00  fstkshortestdelta$^$^   pywrapfst.pyx0000$^      return self$^  $^    cdef void pruneself float deltafst.kdelta int00 nstatefst.knostateid              $^                     weightnone except $^       threshold is set to semiring zero no pruning if no weight is specified.$^ $^  pyxk00  fstkdelta$^  pyxk00  fstknostateid$^$^   pywrapfst.pyx0000$^  $^    def pruneself$^              float deltafst.kdelta              $^              int00 nstatefst.knostateid$^              weightnone$^ $^  pyxk00  fstkdelta$^$^   pywrapfst.pyx0000$^    def pruneself$^              float deltafst.kdelta$^              int00 nstatefst.knostateid              $^              weightnone$^      $^ $^  pyxk00  fstknostateid$^$^   pywrapfst.pyx0000$^  $^    cdef void pushself$^                    float deltafst.kdelta              $^                    bool removetotalweightfalse$^                    bool tofinalfalse except $^ $^  pyxk00  fstkdelta$^$^   pywrapfst.pyx0000$^  $^    def pushself$^             float deltafst.kdelta              $^             bool removetotalweightfalse$^             bool tofinalfalse$^ $^  pyxk00  fstkdelta$^$^   pywrapfst.pyx0000$^                         bool connecttrue$^                         weightnone$^                         int00 nstatefst.knostateid              $^                         float deltafst.kshortestdelta except $^      cdef fst.weightclass wc  getweightclassorzeroself.weighttype$^ $^  pyxk00  fstknostateid$^$^   pywrapfst.pyx0000$^                         weightnone$^                         int00 nstatefst.knostateid$^                         float deltafst.kshortestdelta except               $^      cdef fst.weightclass wc  getweightclassorzeroself.weighttype$^                                                         weight$^ $^  pyxk00  fstkshortestdelta$^$^   pywrapfst.pyx0000$^                  bool connecttrue$^                  weightnone$^                  int00 nstatefst.knostateid              $^                  float deltafst.kshortestdelta$^      $^ $^  pyxk00  fstknostateid$^$^   pywrapfst.pyx0000$^                  weightnone$^                  int00 nstatefst.knostateid$^                  float deltafst.kshortestdelta              $^      $^      rmepsilonself queuetypeauto connecttrue weightnone$^ $^  pyxk00  fstkshortestdelta$^$^   pywrapfst.pyx0000$^  $^  $^  class fstobject              $^  $^     $^ $^  pyxt0  pyxcalculatemetaclassnull pyxtuple000 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxt0  pyxpy0metaclasspreparepyxt0 pyxtuple000 pyxnsfst pyxnsfst pyobject  null pyxnspywrapfst0 pyxkpsfstarctypestandardconstruct if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^$^   pywrapfst.pyx0000$^     $^  $^     def newcls arctypebstandard              $^      return createfstarctype$^  $^ $^  pyxt0  pyxcyfunctionnewexpyxmdef0pywrapfst0fst0new pyxcyfunctionstaticmethod pyxnsfstnew null pyxnspywrapfst0 pyxd pyobject pyxcodeobj000 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxcyfunctionsetdefaultstuplepyxt0 pyxtuple000$^  if pyxsetnameinclasspyxt0 pyxnsnew pyxt0  0 pyxerr0 0000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^$^   pywrapfst.pyx0000$^  $^     staticmethod$^     def readfilename              $^       $^       readfilename$^ $^  pyxt0  pyxcyfunctionnewexpyxmdef0pywrapfst0fst0read pyxcyfunctionstaticmethod pyxnsfstread null pyxnspywrapfst0 pyxd pyobject pyxcodeobj000 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^$^   pywrapfst.pyx0000$^      return createfstarctype$^  $^     staticmethod              $^     def readfilename$^       $^ $^  pyxt0  pyxpyobjectcalloneargpyxbuiltinstaticmethod pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxdecrefpyxt0 pyxt0  0$^  if pyxsetnameinclasspyxt0 pyxnsread pyxt0  0 pyxerr0 0000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^$^   pywrapfst.pyx0000$^  $^     staticmethod$^     def readfromstringstate              $^       $^       readfromstringstring fsttypenone$^ $^  pyxt0  pyxcyfunctionnewexpyxmdef0pywrapfst0fst0readfromstring pyxcyfunctionstaticmethod pyxnsfstreadfromstring null pyxnspywrapfst0 pyxd pyobject pyxcodeobj000 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^$^   pywrapfst.pyx0000$^       return readfilename$^  $^     staticmethod              $^     def readfromstringstate$^       $^ $^  pyxt0  pyxpyobjectcalloneargpyxbuiltinstaticmethod pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxdecrefpyxt0 pyxt0  0$^  if pyxsetnameinclasspyxt0 pyxnsreadfromstring0 pyxt0  0 pyxerr0 0000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^$^   pywrapfst.pyx0000$^  $^  $^  class fstobject              $^  $^     $^ $^  pyxt0  pyxpy0classcreatepyxt0 pyxnsfst pyxtuple000 pyxt0 null 0 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  if pydictsetitempyxd pyxnsfst pyxt0  0 pyxerr0 0000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^  pyxdecrefpyxt0 pyxt0  0$^  pyxdecrefpyxt0 pyxt0  0$^$^   pywrapfst.pyx0000$^  $^  $^  nolabel  fst.knolabel              $^  nostateid  fst.knostateid$^   todokbg figure out how to access static class variables so i dont have$^ $^  pyxt0  pyxpyintfromintfstknolabel if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  if pydictsetitempyxd pyxnsnolabel pyxt0  0 pyxerr0 0000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^$^   pywrapfst.pyx0000$^  $^  nolabel  fst.knolabel$^  nostateid  fst.knostateid              $^   todokbg figure out how to access static class variables so i dont have$^   to do it this way.$^ $^  pyxt0  pyxpyintfromintfstknostateid if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  if pydictsetitempyxd pyxnsnostateid pyxt0  0 pyxerr0 0000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^$^   pywrapfst.pyx0000$^   todokbg figure out how to access static class variables so i dont have$^   to do it this way.$^  nosymbol  knosymbol              $^  $^  $^ $^  pyxt0  pyxgetmoduleglobalnamepyxnsknosymbol if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  if pydictsetitempyxd pyxnsnosymbol pyxt0  0 pyxerr0 0000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^$^   pywrapfst.pyx0000$^  $^  $^  expanded  fst.kexpanded              $^  mutable  fst.kmutable$^  error  fst.kerror$^ $^  pyxt0  pyxpyintfromuint00tfstkexpanded if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  if pydictsetitempyxd pyxnsexpanded pyxt0  0 pyxerr0 0000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^$^   pywrapfst.pyx0000$^  $^  expanded  fst.kexpanded$^  mutable  fst.kmutable              $^  error  fst.kerror$^  acceptor  fst.kacceptor$^ $^  pyxt0  pyxpyintfromuint00tfstkmutable if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  if pydictsetitempyxd pyxnsmutable pyxt0  0 pyxerr0 0000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^$^   pywrapfst.pyx0000$^  expanded  fst.kexpanded$^  mutable  fst.kmutable$^  error  fst.kerror              $^  acceptor  fst.kacceptor$^  notacceptor  fst.knotacceptor$^ $^  pyxt0  pyxpyintfromuint00tfstkerror if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  if pydictsetitempyxd pyxnserror pyxt0  0 pyxerr0 0000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^$^   pywrapfst.pyx0000$^  mutable  fst.kmutable$^  error  fst.kerror$^  acceptor  fst.kacceptor              $^  notacceptor  fst.knotacceptor$^  ideterministic  fst.kideterministic$^ $^  pyxt0  pyxpyintfromuint00tfstkacceptor if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  if pydictsetitempyxd pyxnsacceptor pyxt0  0 pyxerr0 0000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^$^   pywrapfst.pyx0000$^  error  fst.kerror$^  acceptor  fst.kacceptor$^  notacceptor  fst.knotacceptor              $^  ideterministic  fst.kideterministic$^  nonideterministic  fst.knonideterministic$^ $^  pyxt0  pyxpyintfromuint00tfstknotacceptor if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  if pydictsetitempyxd pyxnsnotacceptor pyxt0  0 pyxerr0 0000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^$^   pywrapfst.pyx0000$^  acceptor  fst.kacceptor$^  notacceptor  fst.knotacceptor$^  ideterministic  fst.kideterministic              $^  nonideterministic  fst.knonideterministic$^  odeterministic  fst.kodeterministic$^ $^  pyxt0  pyxpyintfromuint00tfstkideterministic if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  if pydictsetitempyxd pyxnsideterministic pyxt0  0 pyxerr0 0000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^$^   pywrapfst.pyx0000$^  notacceptor  fst.knotacceptor$^  ideterministic  fst.kideterministic$^  nonideterministic  fst.knonideterministic              $^  odeterministic  fst.kodeterministic$^  nonodeterministic  fst.knonodeterministic$^ $^  pyxt0  pyxpyintfromuint00tfstknonideterministic if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  if pydictsetitempyxd pyxnsnonideterministic pyxt0  0 pyxerr0 0000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^$^   pywrapfst.pyx0000$^  ideterministic  fst.kideterministic$^  nonideterministic  fst.knonideterministic$^  odeterministic  fst.kodeterministic              $^  nonodeterministic  fst.knonodeterministic$^  epsilons  fst.kepsilons$^ $^  pyxt0  pyxpyintfromuint00tfstkodeterministic if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  if pydictsetitempyxd pyxnsodeterministic pyxt0  0 pyxerr0 0000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^$^   pywrapfst.pyx0000$^  nonideterministic  fst.knonideterministic$^  odeterministic  fst.kodeterministic$^  nonodeterministic  fst.knonodeterministic              $^  epsilons  fst.kepsilons$^  noepsilons  fst.knoepsilons$^ $^  pyxt0  pyxpyintfromuint00tfstknonodeterministic if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  if pydictsetitempyxd pyxnsnonodeterministic pyxt0  0 pyxerr0 0000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^$^   pywrapfst.pyx0000$^  odeterministic  fst.kodeterministic$^  nonodeterministic  fst.knonodeterministic$^  epsilons  fst.kepsilons              $^  noepsilons  fst.knoepsilons$^  iepsilons  fst.kiepsilons$^ $^  pyxt0  pyxpyintfromuint00tfstkepsilons if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  if pydictsetitempyxd pyxnsepsilons pyxt0  0 pyxerr0 0000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^$^   pywrapfst.pyx0000$^  nonodeterministic  fst.knonodeterministic$^  epsilons  fst.kepsilons$^  noepsilons  fst.knoepsilons              $^  iepsilons  fst.kiepsilons$^  noiepsilons  fst.knoiepsilons$^ $^  pyxt0  pyxpyintfromuint00tfstknoepsilons if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  if pydictsetitempyxd pyxnsnoepsilons pyxt0  0 pyxerr0 0000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^$^   pywrapfst.pyx0000$^  epsilons  fst.kepsilons$^  noepsilons  fst.knoepsilons$^  iepsilons  fst.kiepsilons              $^  noiepsilons  fst.knoiepsilons$^  oepsilons  fst.koepsilons$^ $^  pyxt0  pyxpyintfromuint00tfstkiepsilons if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  if pydictsetitempyxd pyxnsiepsilons pyxt0  0 pyxerr0 0000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^$^   pywrapfst.pyx0000$^  noepsilons  fst.knoepsilons$^  iepsilons  fst.kiepsilons$^  noiepsilons  fst.knoiepsilons              $^  oepsilons  fst.koepsilons$^  nooepsilons  fst.knooepsilons$^ $^  pyxt0  pyxpyintfromuint00tfstknoiepsilons if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  if pydictsetitempyxd pyxnsnoiepsilons pyxt0  0 pyxerr0 0000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^$^   pywrapfst.pyx0000$^  iepsilons  fst.kiepsilons$^  noiepsilons  fst.knoiepsilons$^  oepsilons  fst.koepsilons              $^  nooepsilons  fst.knooepsilons$^  ilabelsorted  fst.kilabelsorted$^ $^  pyxt0  pyxpyintfromuint00tfstkoepsilons if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  if pydictsetitempyxd pyxnsoepsilons pyxt0  0 pyxerr0 0000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^$^   pywrapfst.pyx0000$^  noiepsilons  fst.knoiepsilons$^  oepsilons  fst.koepsilons$^  nooepsilons  fst.knooepsilons              $^  ilabelsorted  fst.kilabelsorted$^  notilabelsorted  fst.knotilabelsorted$^ $^  pyxt0  pyxpyintfromuint00tfstknooepsilons if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  if pydictsetitempyxd pyxnsnooepsilons pyxt0  0 pyxerr0 0000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^$^   pywrapfst.pyx0000$^  oepsilons  fst.koepsilons$^  nooepsilons  fst.knooepsilons$^  ilabelsorted  fst.kilabelsorted              $^  notilabelsorted  fst.knotilabelsorted$^  olabelsorted  fst.kolabelsorted$^ $^  pyxt0  pyxpyintfromuint00tfstkilabelsorted if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  if pydictsetitempyxd pyxnsilabelsorted pyxt0  0 pyxerr0 0000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^$^   pywrapfst.pyx0000$^  nooepsilons  fst.knooepsilons$^  ilabelsorted  fst.kilabelsorted$^  notilabelsorted  fst.knotilabelsorted              $^  olabelsorted  fst.kolabelsorted$^  notolabelsorted  fst.knotolabelsorted$^ $^  pyxt0  pyxpyintfromuint00tfstknotilabelsorted if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  if pydictsetitempyxd pyxnsnotilabelsorted pyxt0  0 pyxerr0 0000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^$^   pywrapfst.pyx0000$^  ilabelsorted  fst.kilabelsorted$^  notilabelsorted  fst.knotilabelsorted$^  olabelsorted  fst.kolabelsorted              $^  notolabelsorted  fst.knotolabelsorted$^  weighted  fst.kweighted$^ $^  pyxt0  pyxpyintfromuint00tfstkolabelsorted if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  if pydictsetitempyxd pyxnsolabelsorted pyxt0  0 pyxerr0 0000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^$^   pywrapfst.pyx0000$^  notilabelsorted  fst.knotilabelsorted$^  olabelsorted  fst.kolabelsorted$^  notolabelsorted  fst.knotolabelsorted              $^  weighted  fst.kweighted$^  unweighted  fst.kunweighted$^ $^  pyxt0  pyxpyintfromuint00tfstknotolabelsorted if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  if pydictsetitempyxd pyxnsnotolabelsorted pyxt0  0 pyxerr0 0000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^$^   pywrapfst.pyx0000$^  olabelsorted  fst.kolabelsorted$^  notolabelsorted  fst.knotolabelsorted$^  weighted  fst.kweighted              $^  unweighted  fst.kunweighted$^  cyclic  fst.kcyclic$^ $^  pyxt0  pyxpyintfromuint00tfstkweighted if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  if pydictsetitempyxd pyxnsweighted pyxt0  0 pyxerr0 0000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^$^   pywrapfst.pyx0000$^  notolabelsorted  fst.knotolabelsorted$^  weighted  fst.kweighted$^  unweighted  fst.kunweighted              $^  cyclic  fst.kcyclic$^  acyclic  fst.kacyclic$^ $^  pyxt0  pyxpyintfromuint00tfstkunweighted if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  if pydictsetitempyxd pyxnsunweighted pyxt0  0 pyxerr0 0000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^$^   pywrapfst.pyx0000$^  weighted  fst.kweighted$^  unweighted  fst.kunweighted$^  cyclic  fst.kcyclic              $^  acyclic  fst.kacyclic$^  initialcyclic  fst.kinitialcyclic$^ $^  pyxt0  pyxpyintfromuint00tfstkcyclic if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  if pydictsetitempyxd pyxnscyclic pyxt0  0 pyxerr0 0000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^$^   pywrapfst.pyx0000$^  unweighted  fst.kunweighted$^  cyclic  fst.kcyclic$^  acyclic  fst.kacyclic              $^  initialcyclic  fst.kinitialcyclic$^  initialacyclic  fst.kinitialacyclic$^ $^  pyxt0  pyxpyintfromuint00tfstkacyclic if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  if pydictsetitempyxd pyxnsacyclic pyxt0  0 pyxerr0 0000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^$^   pywrapfst.pyx0000$^  cyclic  fst.kcyclic$^  acyclic  fst.kacyclic$^  initialcyclic  fst.kinitialcyclic              $^  initialacyclic  fst.kinitialacyclic$^  topsorted  fst.ktopsorted$^ $^  pyxt0  pyxpyintfromuint00tfstkinitialcyclic if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  if pydictsetitempyxd pyxnsinitialcyclic pyxt0  0 pyxerr0 0000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^$^   pywrapfst.pyx0000$^  acyclic  fst.kacyclic$^  initialcyclic  fst.kinitialcyclic$^  initialacyclic  fst.kinitialacyclic              $^  topsorted  fst.ktopsorted$^  nottopsorted  fst.knottopsorted$^ $^  pyxt0  pyxpyintfromuint00tfstkinitialacyclic if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  if pydictsetitempyxd pyxnsinitialacyclic pyxt0  0 pyxerr0 0000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^$^   pywrapfst.pyx0000$^  initialcyclic  fst.kinitialcyclic$^  initialacyclic  fst.kinitialacyclic$^  topsorted  fst.ktopsorted              $^  nottopsorted  fst.knottopsorted$^  accessible  fst.kaccessible$^ $^  pyxt0  pyxpyintfromuint00tfstktopsorted if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  if pydictsetitempyxd pyxnstopsorted pyxt0  0 pyxerr0 0000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^$^   pywrapfst.pyx0000$^  initialacyclic  fst.kinitialacyclic$^  topsorted  fst.ktopsorted$^  nottopsorted  fst.knottopsorted              $^  accessible  fst.kaccessible$^  notaccessible  fst.knotaccessible$^ $^  pyxt0  pyxpyintfromuint00tfstknottopsorted if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  if pydictsetitempyxd pyxnsnottopsorted pyxt0  0 pyxerr0 0000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^$^   pywrapfst.pyx0000$^  topsorted  fst.ktopsorted$^  nottopsorted  fst.knottopsorted$^  accessible  fst.kaccessible              $^  notaccessible  fst.knotaccessible$^  coaccessible  fst.kcoaccessible$^ $^  pyxt0  pyxpyintfromuint00tfstkaccessible if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  if pydictsetitempyxd pyxnsaccessible pyxt0  0 pyxerr0 0000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^$^   pywrapfst.pyx0000$^  nottopsorted  fst.knottopsorted$^  accessible  fst.kaccessible$^  notaccessible  fst.knotaccessible              $^  coaccessible  fst.kcoaccessible$^  notcoaccessible  fst.knotcoaccessible$^ $^  pyxt0  pyxpyintfromuint00tfstknotaccessible if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  if pydictsetitempyxd pyxnsnotaccessible pyxt0  0 pyxerr0 0000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^$^   pywrapfst.pyx0000$^  accessible  fst.kaccessible$^  notaccessible  fst.knotaccessible$^  coaccessible  fst.kcoaccessible              $^  notcoaccessible  fst.knotcoaccessible$^  string  fst.kstring$^ $^  pyxt0  pyxpyintfromuint00tfstkcoaccessible if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  if pydictsetitempyxd pyxnscoaccessible pyxt0  0 pyxerr0 0000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^$^   pywrapfst.pyx0000$^  notaccessible  fst.knotaccessible$^  coaccessible  fst.kcoaccessible$^  notcoaccessible  fst.knotcoaccessible              $^  string  fst.kstring$^  notstring  fst.knotstring$^ $^  pyxt0  pyxpyintfromuint00tfstknotcoaccessible if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  if pydictsetitempyxd pyxnsnotcoaccessible pyxt0  0 pyxerr0 0000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^$^   pywrapfst.pyx0000$^  coaccessible  fst.kcoaccessible$^  notcoaccessible  fst.knotcoaccessible$^  string  fst.kstring              $^  notstring  fst.knotstring$^  weightedcycles  fst.kweightedcycles$^ $^  pyxt0  pyxpyintfromuint00tfstkstring if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  if pydictsetitempyxd pyxnsstring pyxt0  0 pyxerr0 0000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^$^   pywrapfst.pyx0000$^  notcoaccessible  fst.knotcoaccessible$^  string  fst.kstring$^  notstring  fst.knotstring              $^  weightedcycles  fst.kweightedcycles$^  unweightedcycles  fst.kunweightedcycles$^ $^  pyxt0  pyxpyintfromuint00tfstknotstring if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  if pydictsetitempyxd pyxnsnotstring pyxt0  0 pyxerr0 0000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^$^   pywrapfst.pyx0000$^  string  fst.kstring$^  notstring  fst.knotstring$^  weightedcycles  fst.kweightedcycles              $^  unweightedcycles  fst.kunweightedcycles$^  nullproperties  fst.knullproperties$^ $^  pyxt0  pyxpyintfromuint00tfstkweightedcycles if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  if pydictsetitempyxd pyxnsweightedcycles pyxt0  0 pyxerr0 0000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^$^   pywrapfst.pyx0000$^  notstring  fst.knotstring$^  weightedcycles  fst.kweightedcycles$^  unweightedcycles  fst.kunweightedcycles              $^  nullproperties  fst.knullproperties$^  copyproperties  fst.kcopyproperties$^ $^  pyxt0  pyxpyintfromuint00tfstkunweightedcycles if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  if pydictsetitempyxd pyxnsunweightedcycles pyxt0  0 pyxerr0 0000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^$^   pywrapfst.pyx0000$^  weightedcycles  fst.kweightedcycles$^  unweightedcycles  fst.kunweightedcycles$^  nullproperties  fst.knullproperties              $^  copyproperties  fst.kcopyproperties$^  intrinsicproperties  fst.kintrinsicproperties$^ $^  pyxt0  pyxpyintfromuint00tfstknullproperties if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  if pydictsetitempyxd pyxnsnullproperties pyxt0  0 pyxerr0 0000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^$^   pywrapfst.pyx0000$^  unweightedcycles  fst.kunweightedcycles$^  nullproperties  fst.knullproperties$^  copyproperties  fst.kcopyproperties              $^  intrinsicproperties  fst.kintrinsicproperties$^  extrinsicproperties  fst.kextrinsicproperties$^ $^  pyxt0  pyxpyintfromuint00tfstkcopyproperties if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  if pydictsetitempyxd pyxnscopyproperties pyxt0  0 pyxerr0 0000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^$^   pywrapfst.pyx0000$^  nullproperties  fst.knullproperties$^  copyproperties  fst.kcopyproperties$^  intrinsicproperties  fst.kintrinsicproperties              $^  extrinsicproperties  fst.kextrinsicproperties$^  setstartproperties  fst.ksetstartproperties$^ $^  pyxt0  pyxpyintfromuint00tfstkintrinsicproperties if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  if pydictsetitempyxd pyxnsintrinsicproperties pyxt0  0 pyxerr0 0000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^$^   pywrapfst.pyx0000$^  copyproperties  fst.kcopyproperties$^  intrinsicproperties  fst.kintrinsicproperties$^  extrinsicproperties  fst.kextrinsicproperties              $^  setstartproperties  fst.ksetstartproperties$^  setfinalproperties  fst.ksetfinalproperties$^ $^  pyxt0  pyxpyintfromuint00tfstkextrinsicproperties if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  if pydictsetitempyxd pyxnsextrinsicproperties pyxt0  0 pyxerr0 0000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^$^   pywrapfst.pyx0000$^  intrinsicproperties  fst.kintrinsicproperties$^  extrinsicproperties  fst.kextrinsicproperties$^  setstartproperties  fst.ksetstartproperties              $^  setfinalproperties  fst.ksetfinalproperties$^  addstateproperties  fst.kaddstateproperties$^ $^  pyxt0  pyxpyintfromuint00tfstksetstartproperties if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  if pydictsetitempyxd pyxnssetstartproperties pyxt0  0 pyxerr0 0000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^$^   pywrapfst.pyx0000$^  extrinsicproperties  fst.kextrinsicproperties$^  setstartproperties  fst.ksetstartproperties$^  setfinalproperties  fst.ksetfinalproperties              $^  addstateproperties  fst.kaddstateproperties$^  addarcproperties  fst.kaddarcproperties$^ $^  pyxt0  pyxpyintfromuint00tfstksetfinalproperties if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  if pydictsetitempyxd pyxnssetfinalproperties pyxt0  0 pyxerr0 0000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^$^   pywrapfst.pyx0000$^  setstartproperties  fst.ksetstartproperties$^  setfinalproperties  fst.ksetfinalproperties$^  addstateproperties  fst.kaddstateproperties              $^  addarcproperties  fst.kaddarcproperties$^  setarcproperties  fst.ksetarcproperties$^ $^  pyxt0  pyxpyintfromuint00tfstkaddstateproperties if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  if pydictsetitempyxd pyxnsaddstateproperties pyxt0  0 pyxerr0 0000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^$^   pywrapfst.pyx0000$^  setfinalproperties  fst.ksetfinalproperties$^  addstateproperties  fst.kaddstateproperties$^  addarcproperties  fst.kaddarcproperties              $^  setarcproperties  fst.ksetarcproperties$^  deletestateproperties  fst.kdeletestatesproperties$^ $^  pyxt0  pyxpyintfromuint00tfstkaddarcproperties if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  if pydictsetitempyxd pyxnsaddarcproperties pyxt0  0 pyxerr0 0000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^$^   pywrapfst.pyx0000$^  addstateproperties  fst.kaddstateproperties$^  addarcproperties  fst.kaddarcproperties$^  setarcproperties  fst.ksetarcproperties              $^  deletestateproperties  fst.kdeletestatesproperties$^  deletearcproperties  fst.kdeletearcsproperties$^ $^  pyxt0  pyxpyintfromuint00tfstksetarcproperties if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  if pydictsetitempyxd pyxnssetarcproperties pyxt0  0 pyxerr0 0000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^$^   pywrapfst.pyx0000$^  addarcproperties  fst.kaddarcproperties$^  setarcproperties  fst.ksetarcproperties$^  deletestateproperties  fst.kdeletestatesproperties              $^  deletearcproperties  fst.kdeletearcsproperties$^  statesortproperties  fst.kstatesortproperties$^ $^  pyxt0  pyxpyintfromuint00tfstkdeletestatesproperties if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  if pydictsetitempyxd pyxnsdeletestateproperties pyxt0  0 pyxerr0 0000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^$^   pywrapfst.pyx0000$^  setarcproperties  fst.ksetarcproperties$^  deletestateproperties  fst.kdeletestatesproperties$^  deletearcproperties  fst.kdeletearcsproperties              $^  statesortproperties  fst.kstatesortproperties$^  arcsortproperties  fst.karcsortproperties$^ $^  pyxt0  pyxpyintfromuint00tfstkdeletearcsproperties if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  if pydictsetitempyxd pyxnsdeletearcproperties pyxt0  0 pyxerr0 0000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^$^   pywrapfst.pyx0000$^  deletestateproperties  fst.kdeletestatesproperties$^  deletearcproperties  fst.kdeletearcsproperties$^  statesortproperties  fst.kstatesortproperties              $^  arcsortproperties  fst.karcsortproperties$^  ilabelinvariantproperties  fst.kilabelinvariantproperties$^ $^  pyxt0  pyxpyintfromuint00tfstkstatesortproperties if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  if pydictsetitempyxd pyxnsstatesortproperties pyxt0  0 pyxerr0 0000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^$^   pywrapfst.pyx0000$^  deletearcproperties  fst.kdeletearcsproperties$^  statesortproperties  fst.kstatesortproperties$^  arcsortproperties  fst.karcsortproperties              $^  ilabelinvariantproperties  fst.kilabelinvariantproperties$^  olabelinvariantproperties  fst.kolabelinvariantproperties$^ $^  pyxt0  pyxpyintfromuint00tfstkarcsortproperties if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  if pydictsetitempyxd pyxnsarcsortproperties pyxt0  0 pyxerr0 0000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^$^   pywrapfst.pyx0000$^  statesortproperties  fst.kstatesortproperties$^  arcsortproperties  fst.karcsortproperties$^  ilabelinvariantproperties  fst.kilabelinvariantproperties              $^  olabelinvariantproperties  fst.kolabelinvariantproperties$^  weightinvariantproperties  fst.kweightinvariantproperties$^ $^  pyxt0  pyxpyintfromuint00tfstkilabelinvariantproperties if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  if pydictsetitempyxd pyxnsilabelinvariantproperties pyxt0  0 pyxerr0 0000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^$^   pywrapfst.pyx0000$^  arcsortproperties  fst.karcsortproperties$^  ilabelinvariantproperties  fst.kilabelinvariantproperties$^  olabelinvariantproperties  fst.kolabelinvariantproperties              $^  weightinvariantproperties  fst.kweightinvariantproperties$^  addsuperfinalproperties  fst.kaddsuperfinalproperties$^ $^  pyxt0  pyxpyintfromuint00tfstkolabelinvariantproperties if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  if pydictsetitempyxd pyxnsolabelinvariantproperties pyxt0  0 pyxerr0 0000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^$^   pywrapfst.pyx0000$^  ilabelinvariantproperties  fst.kilabelinvariantproperties$^  olabelinvariantproperties  fst.kolabelinvariantproperties$^  weightinvariantproperties  fst.kweightinvariantproperties              $^  addsuperfinalproperties  fst.kaddsuperfinalproperties$^  rmsuperfinalproperties  fst.krmsuperfinalproperties$^ $^  pyxt0  pyxpyintfromuint00tfstkweightinvariantproperties if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  if pydictsetitempyxd pyxnsweightinvariantproperties pyxt0  0 pyxerr0 0000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^$^   pywrapfst.pyx0000$^  olabelinvariantproperties  fst.kolabelinvariantproperties$^  weightinvariantproperties  fst.kweightinvariantproperties$^  addsuperfinalproperties  fst.kaddsuperfinalproperties              $^  rmsuperfinalproperties  fst.krmsuperfinalproperties$^  binaryproperties  fst.kbinaryproperties$^ $^  pyxt0  pyxpyintfromuint00tfstkaddsuperfinalproperties if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  if pydictsetitempyxd pyxnsaddsuperfinalproperties pyxt0  0 pyxerr0 0000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^$^   pywrapfst.pyx0000$^  weightinvariantproperties  fst.kweightinvariantproperties$^  addsuperfinalproperties  fst.kaddsuperfinalproperties$^  rmsuperfinalproperties  fst.krmsuperfinalproperties              $^  binaryproperties  fst.kbinaryproperties$^  trinaryproperties  fst.ktrinaryproperties$^ $^  pyxt0  pyxpyintfromuint00tfstkrmsuperfinalproperties if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  if pydictsetitempyxd pyxnsrmsuperfinalproperties pyxt0  0 pyxerr0 0000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^$^   pywrapfst.pyx0000$^  addsuperfinalproperties  fst.kaddsuperfinalproperties$^  rmsuperfinalproperties  fst.krmsuperfinalproperties$^  binaryproperties  fst.kbinaryproperties              $^  trinaryproperties  fst.ktrinaryproperties$^  postrinaryproperties  fst.kpostrinaryproperties$^ $^  pyxt0  pyxpyintfromuint00tfstkbinaryproperties if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  if pydictsetitempyxd pyxnsbinaryproperties pyxt0  0 pyxerr0 0000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^$^   pywrapfst.pyx0000$^  rmsuperfinalproperties  fst.krmsuperfinalproperties$^  binaryproperties  fst.kbinaryproperties$^  trinaryproperties  fst.ktrinaryproperties              $^  postrinaryproperties  fst.kpostrinaryproperties$^  negtrinaryproperties  fst.knegtrinaryproperties$^ $^  pyxt0  pyxpyintfromuint00tfstktrinaryproperties if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  if pydictsetitempyxd pyxnstrinaryproperties pyxt0  0 pyxerr0 0000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^$^   pywrapfst.pyx0000$^  binaryproperties  fst.kbinaryproperties$^  trinaryproperties  fst.ktrinaryproperties$^  postrinaryproperties  fst.kpostrinaryproperties              $^  negtrinaryproperties  fst.knegtrinaryproperties$^  fstproperties  fst.kfstproperties$^ $^  pyxt0  pyxpyintfromuint00tfstkpostrinaryproperties if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  if pydictsetitempyxd pyxnspostrinaryproperties pyxt0  0 pyxerr0 0000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^$^   pywrapfst.pyx0000$^  trinaryproperties  fst.ktrinaryproperties$^  postrinaryproperties  fst.kpostrinaryproperties$^  negtrinaryproperties  fst.knegtrinaryproperties              $^  fstproperties  fst.kfstproperties$^  $^ $^  pyxt0  pyxpyintfromuint00tfstknegtrinaryproperties if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  if pydictsetitempyxd pyxnsnegtrinaryproperties pyxt0  0 pyxerr0 0000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^$^   pywrapfst.pyx0000$^  postrinaryproperties  fst.kpostrinaryproperties$^  negtrinaryproperties  fst.knegtrinaryproperties$^  fstproperties  fst.kfstproperties              $^  $^  $^ $^  pyxt0  pyxpyintfromuint00tfstkfstproperties if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  if pydictsetitempyxd pyxnsfstproperties pyxt0  0 pyxerr0 0000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^$^   pywrapfst.pyx0000$^  $^  $^  arcilabelvalue  fst.karcilabelvalue              $^  arcolabelvalue  fst.karcolabelvalue$^  arcweightvalue  fst.karcweightvalue$^ $^  pyxt0  pyxpyintfromuint00tfstkarcilabelvalue if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  if pydictsetitempyxd pyxnsarcilabelvalue pyxt0  0 pyxerr0 0000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^$^   pywrapfst.pyx0000$^  $^  arcilabelvalue  fst.karcilabelvalue$^  arcolabelvalue  fst.karcolabelvalue              $^  arcweightvalue  fst.karcweightvalue$^  arcnextstatevalue  fst.karcnextstatevalue$^ $^  pyxt0  pyxpyintfromuint00tfstkarcolabelvalue if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  if pydictsetitempyxd pyxnsarcolabelvalue pyxt0  0 pyxerr0 0000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^$^   pywrapfst.pyx0000$^  arcilabelvalue  fst.karcilabelvalue$^  arcolabelvalue  fst.karcolabelvalue$^  arcweightvalue  fst.karcweightvalue              $^  arcnextstatevalue  fst.karcnextstatevalue$^  arcnocache  fst.karcnocache$^ $^  pyxt0  pyxpyintfromuint00tfstkarcweightvalue if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  if pydictsetitempyxd pyxnsarcweightvalue pyxt0  0 pyxerr0 0000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^$^   pywrapfst.pyx0000$^  arcolabelvalue  fst.karcolabelvalue$^  arcweightvalue  fst.karcweightvalue$^  arcnextstatevalue  fst.karcnextstatevalue              $^  arcnocache  fst.karcnocache$^  arcvalueflags  fst.karcvalueflags$^ $^  pyxt0  pyxpyintfromuint00tfstkarcnextstatevalue if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  if pydictsetitempyxd pyxnsarcnextstatevalue pyxt0  0 pyxerr0 0000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^$^   pywrapfst.pyx0000$^  arcweightvalue  fst.karcweightvalue$^  arcnextstatevalue  fst.karcnextstatevalue$^  arcnocache  fst.karcnocache              $^  arcvalueflags  fst.karcvalueflags$^  arcflags  fst.karcflags$^ $^  pyxt0  pyxpyintfromuint00tfstkarcnocache if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  if pydictsetitempyxd pyxnsarcnocache pyxt0  0 pyxerr0 0000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^$^   pywrapfst.pyx0000$^  arcnextstatevalue  fst.karcnextstatevalue$^  arcnocache  fst.karcnocache$^  arcvalueflags  fst.karcvalueflags              $^  arcflags  fst.karcflags$^  $^ $^  pyxt0  pyxpyintfromuint00tfstkarcvalueflags if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  if pydictsetitempyxd pyxnsarcvalueflags pyxt0  0 pyxerr0 0000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^$^   pywrapfst.pyx0000$^  arcnocache  fst.karcnocache$^  arcvalueflags  fst.karcvalueflags$^  arcflags  fst.karcflags              $^  $^  $^ $^  pyxt0  pyxpyintfromuint00tfstkarcflags if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  if pydictsetitempyxd pyxnsarcflags pyxt0  0 pyxerr0 0000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^$^   pywrapfst.pyx0000$^  $^  $^  encodelabels  fst.kencodelabels              $^  encodeweights  fst.kencodeweights$^  encodeflags  fst.kencodeflags$^ $^  pyxt0  pyxpyintfromuint00tfstkencodelabels if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  if pydictsetitempyxd pyxnsencodelabels pyxt0  0 pyxerr0 0000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^$^   pywrapfst.pyx0000$^  $^  encodelabels  fst.kencodelabels$^  encodeweights  fst.kencodeweights              $^  encodeflags  fst.kencodeflags$^  $^ $^  pyxt0  pyxpyintfromuint00tfstkencodeweights if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  if pydictsetitempyxd pyxnsencodeweights pyxt0  0 pyxerr0 0000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^$^   pywrapfst.pyx0000$^  encodelabels  fst.kencodelabels$^  encodeweights  fst.kencodeweights$^  encodeflags  fst.kencodeflags              $^  $^  $^ $^  pyxt0  pyxpyintfromuint00tfstkencodeflags if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  if pydictsetitempyxd pyxnsencodeflags pyxt0  0 pyxerr0 0000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^$^   pywrapfst.pyx0000$^  $^  cdef fst mapfst ifst$^                 float deltafst.kdelta              $^                 maptypebidentity$^                 double power0.$^ $^  pyxk00  fstkdelta$^$^   pywrapfst.pyx0000$^  $^  cpdef fst arcmapfst ifst$^                    float deltafst.kdelta              $^                    maptypebidentity$^                    double power0.$^ $^  pyxk00  fstkdelta$^$^   pywrapfst.pyx0000$^  $^  $^  cpdef fst arcmapfst ifst              $^                    float deltafst.kdelta$^                    maptypebidentity$^ $^  pyxk00  fstkdelta$^$^   pywrapfst.pyx0000$^  $^  cpdef mutablefst determinizefst ifst$^                                float deltafst.kshortestdelta              $^                                dettypebfunctional$^                                int00 nstatefst.knostateid$^ $^  pyxk00  fstkshortestdelta$^$^   pywrapfst.pyx0000$^                                float deltafst.kshortestdelta$^                                dettypebfunctional$^                                int00 nstatefst.knostateid              $^                                int00 subsequentiallabel0$^                                weightnone$^ $^  pyxk00  fstknostateid$^$^   pywrapfst.pyx0000$^  $^  cpdef mutablefst determinizefst ifst$^                                float deltafst.kshortestdelta              $^                                dettypebfunctional$^                                int00 nstatefst.knostateid$^ $^  pyxk00  fstkshortestdelta$^$^   pywrapfst.pyx0000$^                                float deltafst.kshortestdelta$^                                dettypebfunctional$^                                int00 nstatefst.knostateid              $^                                int00 subsequentiallabel0$^                                weightnone$^ $^  pyxk00  fstknostateid$^$^   pywrapfst.pyx0000$^  $^  cpdef mutablefst disambiguatefst ifst$^                                 float deltafst.kdelta              $^                                 int00 nstatefst.knostateid$^                                 int00 subsequentiallabel0$^ $^  pyxk00  fstkdelta$^$^   pywrapfst.pyx0000$^  cpdef mutablefst disambiguatefst ifst$^                                 float deltafst.kdelta$^                                 int00 nstatefst.knostateid              $^                                 int00 subsequentiallabel0$^                                 weightnone$^ $^  pyxk00  fstknostateid$^$^   pywrapfst.pyx0000$^  $^  cpdef mutablefst disambiguatefst ifst$^                                 float deltafst.kdelta              $^                                 int00 nstatefst.knostateid$^                                 int00 subsequentiallabel0$^ $^  pyxk00  fstkdelta$^$^   pywrapfst.pyx0000$^  cpdef mutablefst disambiguatefst ifst$^                                 float deltafst.kdelta$^                                 int00 nstatefst.knostateid              $^                                 int00 subsequentiallabel0$^                                 weightnone$^ $^  pyxk00  fstknostateid$^$^   pywrapfst.pyx0000$^  $^  $^  cpdef bool equalfst ifst0 fst ifst0 float deltafst.kdelta              $^    $^    equalifst0 ifst0 delta0.0000000000$^ $^  pyxk00  fstkdelta$^  pyxk00  fstkdelta$^$^   pywrapfst.pyx0000$^  $^  $^  cpdef bool equivalentfst ifst0 fst ifst0 float deltafst.kdelta except               $^    $^    equivalentifst0 ifst0 delta0.0000000000$^ $^  pyxk00  fstkdelta$^  pyxk00  fstkdelta$^$^   pywrapfst.pyx0000$^  $^  $^  cpdef bool isomorphicfst ifst0 fst ifst0 float deltafst.kdelta              $^    $^    isomorphicifst0 ifst0 delta0.0000000000$^ $^  pyxk00  fstkdelta$^  pyxk00  fstkdelta$^$^   pywrapfst.pyx0000$^  $^  cpdef mutablefst prunefst ifst$^                          float deltafst.kdelta              $^                          int00 nstatefst.knostateid$^                          weightnone$^ $^  pyxk00  fstkdelta$^$^   pywrapfst.pyx0000$^  cpdef mutablefst prunefst ifst$^                          float deltafst.kdelta$^                          int00 nstatefst.knostateid              $^                          weightnone$^    $^ $^  pyxk00  fstknostateid$^$^   pywrapfst.pyx0000$^  $^  cpdef mutablefst prunefst ifst$^                          float deltafst.kdelta              $^                          int00 nstatefst.knostateid$^                          weightnone$^ $^  pyxk00  fstkdelta$^$^   pywrapfst.pyx0000$^  cpdef mutablefst prunefst ifst$^                          float deltafst.kdelta$^                          int00 nstatefst.knostateid              $^                          weightnone$^    $^ $^  pyxk00  fstknostateid$^$^   pywrapfst.pyx0000$^  $^  cpdef mutablefst pushfst ifst$^                         float deltafst.kdelta              $^                         bool pushweightsfalse$^                         bool pushlabelsfalse$^ $^  pyxk00  fstkdelta$^$^   pywrapfst.pyx0000$^  $^  $^  cpdef mutablefst pushfst ifst              $^                         float deltafst.kdelta$^                         bool pushweightsfalse$^ $^  pyxk00  fstkdelta$^$^   pywrapfst.pyx0000$^                            fst ifst0$^                            int00 npath0$^                            float deltafst.kdelta              $^                            timet seed0$^                            selectbuniform$^ $^  pyxk00  fstkdelta$^$^   pywrapfst.pyx0000$^                            timet seed0$^                            selectbuniform$^                            int00 maxlengthint00max except               $^    $^    randequivalentifst0 ifst0 npath0 delta0.0000000000 seed0$^ $^  pyxk00  int00max$^$^   pywrapfst.pyx0000$^                            fst ifst0$^                            int00 npath0$^                            float deltafst.kdelta              $^                            timet seed0$^                            selectbuniform$^ $^  pyxk00  fstkdelta$^$^   pywrapfst.pyx0000$^                            timet seed0$^                            selectbuniform$^                            int00 maxlengthint00max except               $^    $^    randequivalentifst0 ifst0 npath0 delta0.0000000000 seed0$^ $^  pyxk00  int00max$^$^   pywrapfst.pyx0000$^                            timet seed0$^                            selectbuniform$^                            int00 maxlengthint00max              $^                            bool weightedfalse$^                            bool removetotalweightfalse$^ $^  pyxk00  int00max$^$^   pywrapfst.pyx0000$^  $^  $^  cpdef mutablefst randgenfst ifst              $^                            int00 npath0$^                            timet seed0$^ $^  pyxk00  int00max$^$^   pywrapfst.pyx0000$^  $^  cdef vectorfst.weightclass shortestdistancefst ifst$^                                                  float deltafst.kshortestdelta              $^                                                  int00 nstatefst.knostateid$^                                                  queuetypebauto$^ $^  pyxk00  fstkshortestdelta$^$^   pywrapfst.pyx0000$^  cdef vectorfst.weightclass shortestdistancefst ifst$^                                                  float deltafst.kshortestdelta$^                                                  int00 nstatefst.knostateid              $^                                                  queuetypebauto$^                                                  bool reversefalse except $^ $^  pyxk00  fstknostateid$^$^   pywrapfst.pyx0000$^  $^  def shortestdistancefst ifst$^                       float deltafst.kshortestdelta              $^                       int00 nstatefst.knostateid$^                       queuetypebauto$^ $^  pyxk00  fstkshortestdelta$^$^   pywrapfst.pyx0000$^  def shortestdistancefst ifst$^                       float deltafst.kshortestdelta$^                       int00 nstatefst.knostateid              $^                       queuetypebauto$^                       bool reversefalse$^ $^  pyxk00  fstknostateid$^$^   pywrapfst.pyx0000$^  $^  $^  def shortestdistancefst ifst              $^                       float deltafst.kshortestdelta$^                       int00 nstatefst.knostateid$^ $^  pyxt0  pycfunctionnewexpyxmdef0pywrapfst00shortestdistance null pyxnspywrapfst0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  if pydictsetitempyxd pyxnsshortestdistance pyxt0  0 pyxerr0 0000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^$^   pywrapfst.pyx0000$^  $^  cpdef mutablefst shortestpathfst ifst$^                                 float deltafst.kshortestdelta              $^                                 int00 nshortest0$^                                 int00 nstatefst.knostateid$^ $^  pyxk00  fstkshortestdelta$^$^   pywrapfst.pyx0000$^                                 float deltafst.kshortestdelta$^                                 int00 nshortest0$^                                 int00 nstatefst.knostateid              $^                                 queuetypebauto$^                                 bool uniquefalse$^ $^  pyxk00  fstknostateid$^$^   pywrapfst.pyx0000$^  $^  cpdef mutablefst shortestpathfst ifst$^                                 float deltafst.kshortestdelta              $^                                 int00 nshortest0$^                                 int00 nstatefst.knostateid$^ $^  pyxk00  fstkshortestdelta$^$^   pywrapfst.pyx0000$^                                 float deltafst.kshortestdelta$^                                 int00 nshortest0$^                                 int00 nstatefst.knostateid              $^                                 queuetypebauto$^                                 bool uniquefalse$^ $^  pyxk00  fstknostateid$^$^   pywrapfst.pyx0000$^  $^    def cinitself$^                  string fsttypebvector              $^                  string arctypebstandard$^                  symboltable isymbolsnone$^ $^  pyxt0  pyxconvertstringfrompystdinstringpyxnbvector if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^  pyxk00  pyxt0$^$^   pywrapfst.pyx0000$^    def cinitself$^                  string fsttypebvector$^                  string arctypebstandard              $^                  symboltable isymbolsnone$^                  symboltable osymbolsnone$^ $^  pyxt0  pyxconvertstringfrompystdinstringpyxnbstandard if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^  pyxk00  pyxt0$^$^   pywrapfst.pyx0000$^  $^    classmethod$^    def opencls filenames              $^      $^      farreader.openfilenames$^ $^  pyxt0  pyxgetnameinclasspyobject pyxptype0pywrapfstfarreader pyxnsopen if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^$^   pywrapfst.pyx0000$^      return  farreader at 0xx.formatself.fartype idself$^  $^    classmethod              $^    def opencls filenames$^      $^ $^  pyxt0  pyxmethodclassmethodpyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxdecrefpyxt0 pyxt0  0$^  if pydictsetitempyobject pyxptype0pywrapfstfarreadertpdict pyxnsopen pyxt0  0 pyxerr0 0000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^  pytypemodifiedpyxptype0pywrapfstfarreader$^$^   pywrapfst.pyx0000$^  $^    classmethod$^    def createcls filename arctypebstandard fartypebdefault              $^      $^      farwriter.$^ $^  pyxt0  pyxgetnameinclasspyobject pyxptype0pywrapfstfarwriter pyxnscreate if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^$^   pywrapfst.pyx0000$^      return  farwriter at 0xx.formatself.fartype idself$^  $^    classmethod              $^    def createcls filename arctypebstandard fartypebdefault$^      $^ $^  pyxt0  pyxmethodclassmethodpyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxdecrefpyxt0 pyxt0  0$^  if pydictsetitempyobject pyxptype0pywrapfstfarwritertpdict pyxnscreate pyxt0  0 pyxerr0 0000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^  pytypemodifiedpyxptype0pywrapfstfarwriter$^$^   pywrapfst.pyx0000$^  $^  $^  fsterrorfatalold  fst.flagsfsterrorfatal              $^  fst.flagsfsterrorfatal  false$^  $^ $^  pyxt0  pyxpyboolfromlongflagsfsterrorfatal if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  if pydictsetitempyxd pyxnsfsterrorfatalold pyxt0  0 pyxerr0 0000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^$^   pywrapfst.pyx0000$^  $^  fsterrorfatalold  fst.flagsfsterrorfatal$^  fst.flagsfsterrorfatal  false              $^  $^  $^ $^  flagsfsterrorfatal  0$^$^   pywrapfst.pyx0000$^  $^  $^  atexit.register              $^  def resetfsterrorfatal$^    fst.flagsfsterrorfatal  fsterrorfatalold$^ $^  pyxt0  pyxgetmoduleglobalnamepyxnsatexit if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxt0  pyxpyobjectgetattrstrpyxt0 pyxnsregister if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxdecrefpyxt0 pyxt0  0$^$^   pywrapfst.pyx0000$^  $^  atexit.register$^  def resetfsterrorfatal              $^    fst.flagsfsterrorfatal  fsterrorfatalold$^  $^ $^  pyxt0  pycfunctionnewexpyxmdef0pywrapfst00resetfsterrorfatal null pyxnspywrapfst0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^$^   pywrapfst.pyx0000$^  $^  $^  atexit.register              $^  def resetfsterrorfatal$^    fst.flagsfsterrorfatal  fsterrorfatalold$^ $^  pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxdecrefpyxt0 pyxt0  0$^  pyxdecrefpyxt0 pyxt0  0$^  if pydictsetitempyxd pyxnsresetfsterrorfatal pyxt0  0 pyxerr0 0000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^$^   pywrapfst.pyx0$^  cython nonechecktrue              $^   licensed under the apache license version 0.0 the license$^   you may not use this file except in compliance with the license.$^ $^  pyxt0  pyxpydictnewpresized0 if unlikelypyxt0 pyxerr0 0 pyxl0error$^  pyxgotrefpyxt0$^  if pydictsetitempyxd pyxnstest0 pyxt0  0 pyxerr0 0 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^$^   vector.frompy00$^  $^  cnamepyxconvertvectorfrompystd0a0astring$^  cdef vectorx pyxconvertvectorfrompystd0a0astringobject o except               $^      cdef vectorx v$^      for item in o$^ $^$^   wrapped vars code $^$^  goto pyxl0$^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  if pyxm $^    if pyxd $^      pyxaddtracebackinit pywrapfst 0 pyxlineno pyxfilename$^    $^    pydecrefpyxm pyxm  0$^   else if pyerroccurred $^    pyerrsetstringpyexcimporterror init pywrapfst$^  $^  pyxl0$^  pyxrefnannyfinishcontext$^  if cythonpep000multiphaseinit$^  return pyxm  null  0  0$^  elif pymajorversion  0$^  return pyxm$^  else$^  return$^  endif$^$^$^  runtime support code  $^ refnanny $^if cythonrefnanny$^static pyxrefnannyapistruct pyxrefnannyimportapiconst char modname $^    pyobject m  null p  null$^    void r  null$^    m  pyimportimportmodulechar modname$^    if m goto end$^    p  pyobjectgetattrstringm char refnannyapi$^    if p goto end$^    r  pylongasvoidptrp$^end$^    pyxdecrefp$^    pyxdecrefm$^    return pyxrefnannyapistruct r$^$^endif$^$^ pyobjectgetattrstr $^if cythonusetypeslots$^static cythoninline pyobject pyxpyobjectgetattrstrpyobject obj pyobject attrname $^    pytypeobject tp  pytypeobj$^    if likelytptpgetattro$^        return tptpgetattroobj attrname$^if pymajorversion  0$^    if likelytptpgetattr$^        return tptpgetattrobj pystringasstringattrname$^endif$^    return pyobjectgetattrobj attrname$^$^endif$^$^ getbuiltinname $^static pyobject pyxgetbuiltinnamepyobject name $^    pyobject result  pyxpyobjectgetattrstrpyxb name$^    if unlikelyresult $^        pyerrformatpyexcnameerror$^if pymajorversion  0$^            name u is not defined name$^else$^            name .000s is not defined pystringasstringname$^endif$^    $^    return result$^$^$^ pycfunctionfastcall $^if cythonfastpyccall$^static cythoninline pyobject  pyxpycfunctionfastcallpyobject funcobj pyobject args pyssizet nargs $^    pycfunctionobject func  pycfunctionobjectfuncobj$^    pycfunction meth  pycfunctiongetfunctionfunc$^    pyobject self  pycfunctiongetselffunc$^    int flags  pycfunctiongetflagsfunc$^    assertpycfunctioncheckfunc$^    assertmethfastcall  flags  methclass  methstatic  methcoexist  methkeywords$^    assertnargs  0$^    assertnargs  0  args  null$^     pycfunctionfastcalldict must not be called with an exception set$^       because it may clear it directly or indirectly and so the$^       caller loses its exception $^    assertpyerroccurred$^    if pyversionhex  0x000000a0  unlikelyflags  methkeywords $^        return pyxpycfunctionfastwithkeywordsmeth self args nargs null$^     else $^        return pyxpycfunctionfastmeth self args nargs$^    $^$^endif$^$^ pyfunctionfastcall $^if cythonfastpycall$^include frameobject.h$^static pyobject pyxpyfunctionfastcallnokwpycodeobject co pyobject args pyssizet na$^                                               pyobject globals $^    pyframeobject f$^    pythreadstate tstate  pyxpythreadstatecurrent$^    pyobject fastlocals$^    pyssizet i$^    pyobject result$^    assertglobals  null$^     xxx perhaps we should create a specialized$^       pyframenew that doesnt take locals but does$^       take builtins without sanity checking them.$^       $^    asserttstate  null$^    f  pyframenewtstate co globals null$^    if f  null $^        return null$^    $^    fastlocals  fflocalsplus$^    for i  0 i  na i $^        pyincrefargs$^        fastlocalsi  args$^    $^    result  pyevalevalframeexf0$^    tstaterecursiondepth$^    pydecreff$^    tstaterecursiondepth$^    return result$^$^if 0  pyversionhex  0x000000b0$^static pyobject pyxpyfunctionfastcalldictpyobject func pyobject args int nargs pyobject kwargs $^    pycodeobject co  pycodeobject pyfunctiongetcodefunc$^    pyobject globals  pyfunctiongetglobalsfunc$^    pyobject argdefs  pyfunctiongetdefaultsfunc$^    pyobject closure$^if pymajorversion  0$^    pyobject kwdefs$^endif$^    pyobject kwtuple k$^    pyobject d$^    pyssizet nd$^    pyssizet nk$^    pyobject result$^    assertkwargs  null  pydictcheckkwargs$^    nk  kwargs  pydictsizekwargs  0$^    if pyenterrecursivecallchar while calling a python object $^        return null$^    $^    if $^if pymajorversion  0$^            cocokwonlyargcount  0 $^endif$^            likelykwargs  null  nk  0 $^            cocoflags  cooptimized  conewlocals  conofree $^        if argdefs  null  cocoargcount  nargs $^            result  pyxpyfunctionfastcallnokwco args nargs globals$^            goto done$^        $^        else if nargs  0  argdefs  null$^                  cocoargcount  pysizeargdefs $^             function called with no arguments but all parameters have$^               a default value use default values as arguments .$^            args  pytuplegetitemargdefs 0$^            result pyxpyfunctionfastcallnokwco args pysizeargdefs globals$^            goto done$^        $^    $^    if kwargs  null $^        pyssizet pos i$^        kwtuple  pytuplenew0  nk$^        if kwtuple  null $^            result  null$^            goto done$^        $^        k  pytuplegetitemkwtuple 0$^        pos  i  0$^        while pydictnextkwargs pos ki ki0 $^            pyincrefki$^            pyincrefki0$^            i  0$^        $^        nk  i  0$^    $^    else $^        kwtuple  null$^        k  null$^    $^    closure  pyfunctiongetclosurefunc$^if pymajorversion  0$^    kwdefs  pyfunctiongetkwdefaultsfunc$^endif$^    if argdefs  null $^        d  pytuplegetitemargdefs 0$^        nd  pysizeargdefs$^    $^    else $^        d  null$^        nd  0$^    $^if pymajorversion  0$^    result  pyevalevalcodeexpyobjectco globals pyobject null$^                               args nargs$^                               k intnk$^                               d intnd kwdefs closure$^else$^    result  pyevalevalcodeexco globals pyobject null$^                               args nargs$^                               k intnk$^                               d intnd closure$^endif$^    pyxdecrefkwtuple$^done$^    pyleaverecursivecall$^    return result$^$^endif$^endif$^$^ pyobjectcall $^if cythoncompilingincpython$^static cythoninline pyobject pyxpyobjectcallpyobject func pyobject arg pyobject kw $^    pyobject result$^    ternaryfunc call  funcobtypetpcall$^    if unlikelycall$^        return pyobjectcallfunc arg kw$^    if unlikelypyenterrecursivecallchar while calling a python object$^        return null$^    result  callfunc arg kw$^    pyleaverecursivecall$^    if unlikelyresult  unlikelypyerroccurred $^        pyerrsetstring$^            pyexcsystemerror$^            null result without error in pyobjectcall$^    $^    return result$^$^endif$^$^ pyobjectcallmetho $^if cythoncompilingincpython$^static cythoninline pyobject pyxpyobjectcallmethopyobject func pyobject arg $^    pyobject self result$^    pycfunction cfunc$^    cfunc  pycfunctiongetfunctionfunc$^    self  pycfunctiongetselffunc$^    if unlikelypyenterrecursivecallchar while calling a python object$^        return null$^    result  cfuncself arg$^    pyleaverecursivecall$^    if unlikelyresult  unlikelypyerroccurred $^        pyerrsetstring$^            pyexcsystemerror$^            null result without error in pyobjectcall$^    $^    return result$^$^endif$^$^ pyobjectcallonearg $^if cythoncompilingincpython$^static pyobject pyxpyobjectcalloneargpyobject func pyobject arg $^    pyobject result$^    pyobject args  pytuplenew0$^    if unlikelyargs return null$^    pyincrefarg$^    pytuplesetitemargs 0 arg$^    result  pyxpyobjectcallfunc args null$^    pydecrefargs$^    return result$^$^static cythoninline pyobject pyxpyobjectcalloneargpyobject func pyobject arg $^if cythonfastpycall$^    if pyfunctioncheckfunc $^        return pyxpyfunctionfastcallfunc arg 0$^    $^endif$^    if likelypycfunctioncheckfunc $^        if likelypycfunctiongetflagsfunc  metho $^            return pyxpyobjectcallmethofunc arg$^if cythonfastpyccall$^         else if pycfunctiongetflagsfunc  methfastcall $^            return pyxpycfunctionfastcallfunc arg 0$^endif$^        $^    $^    return pyxpyobjectcalloneargfunc arg$^$^else$^static cythoninline pyobject pyxpyobjectcalloneargpyobject func pyobject arg $^    pyobject result$^    pyobject args  pytuplepack0 arg$^    if unlikelyargs return null$^    result  pyxpyobjectcallfunc args null$^    pydecrefargs$^    return result$^$^endif$^$^ getmoduleglobalname $^static cythoninline pyobject pyxgetmoduleglobalnamepyobject name $^    pyobject result$^if cythonavoidborrowedrefs$^if cythoncompilingincpython  pyversionhex  0x000000a0$^    result  pydictgetitemknownhashpyxd name pyasciiobject  namehash$^    if likelyresult $^        pyincrefresult$^     else if unlikelypyerroccurred $^        result  null$^     else $^else$^    result  pydictgetitempyxd name$^    if likelyresult $^        pyincrefresult$^     else $^endif$^else$^    result  pyobjectgetitempyxd name$^    if result $^        pyerrclear$^endif$^        result  pyxgetbuiltinnamename$^    $^    return result$^$^$^ pyerrfetchrestore $^    if cythonfastthreadstate$^static cythoninline void pyxerrrestoreinstatepythreadstate tstate pyobject type pyobject value pyobject tb $^    pyobject tmptype tmpvalue tmptb$^    tmptype  tstatecurexctype$^    tmpvalue  tstatecurexcvalue$^    tmptb  tstatecurexctraceback$^    tstatecurexctype  type$^    tstatecurexcvalue  value$^    tstatecurexctraceback  tb$^    pyxdecreftmptype$^    pyxdecreftmpvalue$^    pyxdecreftmptb$^$^static cythoninline void pyxerrfetchinstatepythreadstate tstate pyobject type pyobject value pyobject tb $^    type  tstatecurexctype$^    value  tstatecurexcvalue$^    tb  tstatecurexctraceback$^    tstatecurexctype  0$^    tstatecurexcvalue  0$^    tstatecurexctraceback  0$^$^endif$^$^ raiseexception $^    if pymajorversion  0$^static void pyxraisepyobject type pyobject value pyobject tb$^                        cythonunused pyobject cause $^    pyxpythreadstatedeclare$^    pyxincreftype$^    if value  value  pynone$^        value  null$^    else$^        pyincrefvalue$^    if tb  tb  pynone$^        tb  null$^    else $^        pyincreftb$^        if pytracebackchecktb $^            pyerrsetstringpyexctypeerror$^                raise arg 0 must be a traceback or none$^            goto raiseerror$^        $^    $^    if pytypechecktype $^if cythoncompilinginpypy$^        if value $^            pyincrefpynone$^            value  pynone$^        $^endif$^        pyerrnormalizeexceptiontype value tb$^     else $^        if value $^            pyerrsetstringpyexctypeerror$^                instance exception may not have a separate value$^            goto raiseerror$^        $^        value  type$^        type  pyobject pytypetype$^        pyincreftype$^        if pytypeissubtypepytypeobject type pytypeobject pyexcbaseexception $^            pyerrsetstringpyexctypeerror$^                raise exception class must be a subclass of baseexception$^            goto raiseerror$^        $^    $^    pyxpythreadstateassign$^    pyxerrrestoretype value tb$^    return$^raiseerror$^    pyxdecrefvalue$^    pyxdecreftype$^    pyxdecreftb$^    return$^$^else$^static void pyxraisepyobject type pyobject value pyobject tb pyobject cause $^    pyobject ownedinstance  null$^    if tb  pynone $^        tb  0$^     else if tb  pytracebackchecktb $^        pyerrsetstringpyexctypeerror$^            raise arg 0 must be a traceback or none$^        goto bad$^    $^    if value  pynone$^        value  0$^    if pyexceptioninstancechecktype $^        if value $^            pyerrsetstringpyexctypeerror$^                instance exception may not have a separate value$^            goto bad$^        $^        value  type$^        type  pyobject pytypevalue$^     else if pyexceptionclasschecktype $^        pyobject instanceclass  null$^        if value  pyexceptioninstancecheckvalue $^            instanceclass  pyobject pytypevalue$^            if instanceclass  type $^                int issubclass  pyobjectissubclassinstanceclass type$^                if issubclass $^                    instanceclass  null$^                 else if unlikelyissubclass  0 $^                    goto bad$^                 else $^                    type  instanceclass$^                $^            $^        $^        if instanceclass $^            pyobject args$^            if value$^                args  pytuplenew0$^            else if pytuplecheckvalue $^                pyincrefvalue$^                args  value$^             else$^                args  pytuplepack0 value$^            if args$^                goto bad$^            ownedinstance  pyobjectcalltype args null$^            pydecrefargs$^            if ownedinstance$^                goto bad$^            value  ownedinstance$^            if pyexceptioninstancecheckvalue $^                pyerrformatpyexctypeerror$^                             calling r should have returned an instance of $^                             baseexception not r$^                             type pytypevalue$^                goto bad$^            $^        $^     else $^        pyerrsetstringpyexctypeerror$^            raise exception class must be a subclass of baseexception$^        goto bad$^    $^    if cause $^        pyobject fixedcause$^        if cause  pynone $^            fixedcause  null$^         else if pyexceptionclasscheckcause $^            fixedcause  pyobjectcallobjectcause null$^            if fixedcause  null$^                goto bad$^         else if pyexceptioninstancecheckcause $^            fixedcause  cause$^            pyincreffixedcause$^         else $^            pyerrsetstringpyexctypeerror$^                            exception causes must derive from $^                            baseexception$^            goto bad$^        $^        pyexceptionsetcausevalue fixedcause$^    $^    pyerrsetobjecttype value$^    if tb $^if cythoncompilinginpypy$^        pyobject tmptype tmpvalue tmptb$^        pyerrfetchtmptype tmpvalue tmptb$^        pyincreftb$^        pyerrrestoretmptype tmpvalue tb$^        pyxdecreftmptb$^else$^        pythreadstate tstate  pyxpythreadstatecurrent$^        pyobject tmptb  tstatecurexctraceback$^        if tb  tmptb $^            pyincreftb$^            tstatecurexctraceback  tb$^            pyxdecreftmptb$^        $^endif$^    $^bad$^    pyxdecrefownedinstance$^    return$^$^endif$^$^ raiseargtupleinvalid $^    static void pyxraiseargtupleinvalid$^    const char funcname$^    int exact$^    pyssizet nummin$^    pyssizet nummax$^    pyssizet numfound$^$^    pyssizet numexpected$^    const char moreorless$^    if numfound  nummin $^        numexpected  nummin$^        moreorless  at least$^     else $^        numexpected  nummax$^        moreorless  at most$^    $^    if exact $^        moreorless  exactly$^    $^    pyerrformatpyexctypeerror$^                 .000s takes .0s  cythonformatssizet d positional argument.0s  cythonformatssizet d given$^                 funcname moreorless numexpected$^                 numexpected  0    s numfound$^$^$^ raisedoublekeywords $^    static void pyxraisedoublekeywordserror$^    const char funcname$^    pyobject kwname$^$^    pyerrformatpyexctypeerror$^        if pymajorversion  0$^        s got multiple values for keyword argument u funcname kwname$^        else$^        s got multiple values for keyword argument s funcname$^        pystringasstringkwname$^        endif$^$^$^ parsekeywords $^    static int pyxparseoptionalkeywords$^    pyobject kwds$^    pyobject argnames$^    pyobject kwds0$^    pyobject values$^    pyssizet numposargs$^    const char functionname$^$^    pyobject key  0 value  0$^    pyssizet pos  0$^    pyobject name$^    pyobject firstkwarg  argnames  numposargs$^    while pydictnextkwds pos key value $^        name  firstkwarg$^        while name  name  key name$^        if name $^            valuesnameargnames  value$^            continue$^        $^        name  firstkwarg$^        if pymajorversion  0$^        if likelypystringcheckexactkey  likelypystringcheckkey $^            while name $^                if cythoncompilinginpypy  pystringgetsizename  pystringgetsizekey$^                         pystringeqname key $^                    valuesnameargnames  value$^                    break$^                $^                name$^            $^            if name continue$^            else $^                pyobject argname  argnames$^                while argname  firstkwarg $^                    if argname  key  $^                            cythoncompilinginpypy  pystringgetsizeargname  pystringgetsizekey$^                              pystringeqargname key $^                        goto argpassedtwice$^                    $^                    argname$^                $^            $^         else$^        endif$^        if likelypyunicodecheckkey $^            while name $^                int cmp  name  key  0 $^                if cythoncompilinginpypy  pymajorversion  0$^                    pyunicodegetsizename  pyunicodegetsizekey  0 $^                endif$^                    pyunicodecomparename key$^                if cmp  0  unlikelypyerroccurred goto bad$^                if cmp  0 $^                    valuesnameargnames  value$^                    break$^                $^                name$^            $^            if name continue$^            else $^                pyobject argname  argnames$^                while argname  firstkwarg $^                    int cmp  argname  key  0 $^                    if cythoncompilinginpypy  pymajorversion  0$^                        pyunicodegetsizeargname  pyunicodegetsizekey  0 $^                    endif$^                        pyunicodecompareargname key$^                    if cmp  0  unlikelypyerroccurred goto bad$^                    if cmp  0 goto argpassedtwice$^                    argname$^                $^            $^         else$^            goto invalidkeywordtype$^        if kwds0 $^            if unlikelypydictsetitemkwds0 key value goto bad$^         else $^            goto invalidkeyword$^        $^    $^    return 0$^argpassedtwice$^    pyxraisedoublekeywordserrorfunctionname key$^    goto bad$^invalidkeywordtype$^    pyerrformatpyexctypeerror$^        .000s keywords must be strings functionname$^    goto bad$^invalidkeyword$^    pyerrformatpyexctypeerror$^    if pymajorversion  0$^        .000s got an unexpected keyword argument .000s$^        functionname pystringasstringkey$^    else$^        s got an unexpected keyword argument u$^        functionname key$^    endif$^bad$^    return 0$^$^$^ pyobjectcallnoarg $^    if cythoncompilingincpython$^static cythoninline pyobject pyxpyobjectcallnoargpyobject func $^if cythonfastpycall$^    if pyfunctioncheckfunc $^        return pyxpyfunctionfastcallfunc null 0$^    $^endif$^ifdef pyxcyfunctionused$^    if likelypycfunctioncheckfunc  pyxtypecheckfunc pyxcyfunctiontype $^else$^    if likelypycfunctioncheckfunc $^endif$^        if likelypycfunctiongetflagsfunc  methnoargs $^            return pyxpyobjectcallmethofunc null$^        $^    $^    return pyxpyobjectcallfunc pyxemptytuple null$^$^endif$^$^ exttypetest $^      static cythoninline int pyxtypetestpyobject obj pytypeobject type $^    if unlikelytype $^        pyerrsetstringpyexcsystemerror missing type object$^        return 0$^    $^    if likelypyxtypecheckobj type$^        return 0$^    pyerrformatpyexctypeerror cannot convert .000s to .000s$^                 pytypeobjtpname typetpname$^    return 0$^$^$^ argtypetest $^      static int pyxargtypetestpyobject obj pytypeobject type const char name int exact$^$^    if unlikelytype $^        pyerrsetstringpyexcsystemerror missing type object$^        return 0$^    $^    else if exact $^        if pymajorversion  0$^        if type  pybasestringtype  likelypyxpybasestringcheckexactobj return 0$^        endif$^    $^    else $^        if likelypyxtypecheckobj type return 0$^    $^    pyerrformatpyexctypeerror$^        argument .000s has incorrect type expected .000s got .000s$^        name typetpname pytypeobjtpname$^    return 0$^$^$^ writeunraisableexception $^      static void pyxwriteunraisableconst char name cythonunused int clineno$^                                  cythonunused int lineno cythonunused const char filename$^                                  int fulltraceback cythonunused int nogil $^    pyobject oldexc oldval oldtb$^    pyobject ctx$^    pyxpythreadstatedeclare$^ifdef withthread$^    pygilstatestate state$^    if nogil$^        state  pygilstateensure$^ifdef mscver$^    else state  pygilstatestate0$^endif$^endif$^    pyxpythreadstateassign$^    pyxerrfetcholdexc oldval oldtb$^    if fulltraceback $^        pyxincrefoldexc$^        pyxincrefoldval$^        pyxincrefoldtb$^        pyxerrrestoreoldexc oldval oldtb$^        pyerrprintex0$^    $^    if pymajorversion  0$^    ctx  pystringfromstringname$^    else$^    ctx  pyunicodefromstringname$^    endif$^    pyxerrrestoreoldexc oldval oldtb$^    if ctx $^        pyerrwriteunraisablepynone$^     else $^        pyerrwriteunraisablectx$^        pydecrefctx$^    $^ifdef withthread$^    if nogil$^        pygilstatereleasestate$^endif$^$^$^ keywordstringcheck $^      static int pyxcheckkeywordstrings$^    pyobject kwdict$^    const char functionname$^    int kwallowed$^$^    pyobject key  0$^    pyssizet pos  0$^if cythoncompilinginpypy$^    if kwallowed  pydictnextkwdict pos key 0$^        goto invalidkeyword$^    return 0$^else$^    while pydictnextkwdict pos key 0 $^        if pymajorversion  0$^        if unlikelypystringcheckkey$^        endif$^            if unlikelypyunicodecheckkey$^                goto invalidkeywordtype$^    $^    if kwallowed  unlikelykey$^        goto invalidkeyword$^    return 0$^invalidkeywordtype$^    pyerrformatpyexctypeerror$^        .000s keywords must be strings functionname$^    return 0$^endif$^invalidkeyword$^    pyerrformatpyexctypeerror$^    if pymajorversion  0$^        .000s got an unexpected keyword argument .000s$^        functionname pystringasstringkey$^    else$^        s got an unexpected keyword argument u$^        functionname key$^    endif$^    return 0$^$^$^ saveresetexception $^      if cythonfastthreadstate$^static cythoninline void pyxexceptionsavepythreadstate tstate pyobject type pyobject value pyobject tb $^    if pyversionhex  0x000000a0$^    type  tstateexcstate.exctype$^    value  tstateexcstate.excvalue$^    tb  tstateexcstate.exctraceback$^    else$^    type  tstateexctype$^    value  tstateexcvalue$^    tb  tstateexctraceback$^    endif$^    pyxincreftype$^    pyxincrefvalue$^    pyxincreftb$^$^static cythoninline void pyxexceptionresetpythreadstate tstate pyobject type pyobject value pyobject tb $^    pyobject tmptype tmpvalue tmptb$^    if pyversionhex  0x000000a0$^    tmptype  tstateexcstate.exctype$^    tmpvalue  tstateexcstate.excvalue$^    tmptb  tstateexcstate.exctraceback$^    tstateexcstate.exctype  type$^    tstateexcstate.excvalue  value$^    tstateexcstate.exctraceback  tb$^    else$^    tmptype  tstateexctype$^    tmpvalue  tstateexcvalue$^    tmptb  tstateexctraceback$^    tstateexctype  type$^    tstateexcvalue  value$^    tstateexctraceback  tb$^    endif$^    pyxdecreftmptype$^    pyxdecreftmpvalue$^    pyxdecreftmptb$^$^endif$^$^ fasttypechecks $^      if cythoncompilingincpython$^static int pyxinbasespytypeobject a pytypeobject b $^    while a $^        a  atpbase$^        if a  b$^            return 0$^    $^    return b  pybaseobjecttype$^$^static cythoninline int pyxissubtypepytypeobject a pytypeobject b $^    pyobject mro$^    if a  b return 0$^    mro  atpmro$^    if likelymro $^        pyssizet i n$^        n  pytuplegetsizemro$^        for i  0 i  n i $^            if pytuplegetitemmro i  pyobject b$^                return 0$^        $^        return 0$^    $^    return pyxinbasesa b$^$^if pymajorversion  0$^static int pyxinnerpyerrgivenexceptionmatches0pyobject err pyobject exctype0 pyobject exctype0 $^    pyobject exception value tb$^    int res$^    pyxpythreadstatedeclare$^    pyxpythreadstateassign$^    pyxerrfetchexception value tb$^    res  exctype0  pyobjectissubclasserr exctype0  0$^    if unlikelyres  0 $^        pyerrwriteunraisableerr$^        res  0$^    $^    if res $^        res  pyobjectissubclasserr exctype0$^        if unlikelyres  0 $^            pyerrwriteunraisableerr$^            res  0$^        $^    $^    pyxerrrestoreexception value tb$^    return res$^$^else$^static cythoninline int pyxinnerpyerrgivenexceptionmatches0pyobject err pyobject exctype0 pyobject exctype0 $^    int res  exctype0  pyxissubtypepytypeobjecterr pytypeobjectexctype0  0$^    if res $^        res  pyxissubtypepytypeobjecterr pytypeobjectexctype0$^    $^    return res$^$^endif$^static cythoninline int pyxpyerrgivenexceptionmatchespyobject err pyobject exctype $^    if likelyerr  exctype return 0$^    if likelypyexceptionclasscheckerr $^        return pyxinnerpyerrgivenexceptionmatches0err null exctype$^    $^    return pyerrgivenexceptionmatcheserr exctype$^$^static cythoninline int pyxpyerrgivenexceptionmatches0pyobject err pyobject exctype0 pyobject exctype0 $^    if likelyerr  exctype0  err  exctype0 return 0$^    if likelypyexceptionclasscheckerr $^        return pyxinnerpyerrgivenexceptionmatches0err exctype0 exctype0$^    $^    return pyerrgivenexceptionmatcheserr exctype0  pyerrgivenexceptionmatcheserr exctype0$^$^endif$^$^ getexception $^      if cythonfastthreadstate$^static int pyxgetexceptionpythreadstate tstate pyobject type pyobject value pyobject tb $^else$^static int pyxgetexceptionpyobject type pyobject value pyobject tb $^endif$^    pyobject localtype localvalue localtb$^if cythonfastthreadstate$^    pyobject tmptype tmpvalue tmptb$^    localtype  tstatecurexctype$^    localvalue  tstatecurexcvalue$^    localtb  tstatecurexctraceback$^    tstatecurexctype  0$^    tstatecurexcvalue  0$^    tstatecurexctraceback  0$^else$^    pyerrfetchlocaltype localvalue localtb$^endif$^    pyerrnormalizeexceptionlocaltype localvalue localtb$^if cythonfastthreadstate$^    if unlikelytstatecurexctype$^else$^    if unlikelypyerroccurred$^endif$^        goto bad$^    if pymajorversion  0$^    if localtb $^        if unlikelypyexceptionsettracebacklocalvalue localtb  0$^            goto bad$^    $^    endif$^    pyxincreflocaltb$^    pyxincreflocaltype$^    pyxincreflocalvalue$^    type  localtype$^    value  localvalue$^    tb  localtb$^if cythonfastthreadstate$^    if pyversionhex  0x000000a0$^    tmptype  tstateexcstate.exctype$^    tmpvalue  tstateexcstate.excvalue$^    tmptb  tstateexcstate.exctraceback$^    tstateexcstate.exctype  localtype$^    tstateexcstate.excvalue  localvalue$^    tstateexcstate.exctraceback  localtb$^    else$^    tmptype  tstateexctype$^    tmpvalue  tstateexcvalue$^    tmptb  tstateexctraceback$^    tstateexctype  localtype$^    tstateexcvalue  localvalue$^    tstateexctraceback  localtb$^    endif$^    pyxdecreftmptype$^    pyxdecreftmpvalue$^    pyxdecreftmptb$^else$^    pyerrsetexcinfolocaltype localvalue localtb$^endif$^    return 0$^bad$^    type  0$^    value  0$^    tb  0$^    pyxdecreflocaltype$^    pyxdecreflocalvalue$^    pyxdecreflocaltb$^    return 0$^$^$^ raisetoomanyvaluestounpack $^        static cythoninline void pyxraisetoomanyvalueserrorpyssizet expected $^    pyerrformatpyexcvalueerror$^                 too many values to unpack expected  cythonformatssizet d expected$^$^$^ raiseneedmorevaluestounpack $^        static cythoninline void pyxraiseneedmorevalueserrorpyssizet index $^    pyerrformatpyexcvalueerror$^                 need more than  cythonformatssizet d value.0s to unpack$^                 index index  0    s$^$^$^ iterfinish $^        static cythoninline int pyxiterfinishvoid $^if cythonfastthreadstate$^    pythreadstate tstate  pyxpythreadstatecurrent$^    pyobject exctype  tstatecurexctype$^    if unlikelyexctype $^        if likelypyxpyerrgivenexceptionmatchesexctype pyexcstopiteration $^            pyobject excvalue exctb$^            excvalue  tstatecurexcvalue$^            exctb  tstatecurexctraceback$^            tstatecurexctype  0$^            tstatecurexcvalue  0$^            tstatecurexctraceback  0$^            pydecrefexctype$^            pyxdecrefexcvalue$^            pyxdecrefexctb$^            return 0$^         else $^            return 0$^        $^    $^    return 0$^else$^    if unlikelypyerroccurred $^        if likelypyerrexceptionmatchespyexcstopiteration $^            pyerrclear$^            return 0$^         else $^            return 0$^        $^    $^    return 0$^endif$^$^$^ unpackitemendcheck $^        static int pyxiternextunpackendcheckpyobject retval pyssizet expected $^    if unlikelyretval $^        pydecrefretval$^        pyxraisetoomanyvalueserrorexpected$^        return 0$^     else $^        return pyxiterfinish$^    $^    return 0$^$^$^ iternext $^        static pyobject pyxpyiternext0defaultpyobject defval $^    pyobject exctype$^    pyxpythreadstatedeclare$^    pyxpythreadstateassign$^    exctype  pyxpyerroccurred$^    if unlikelyexctype $^        if defval  unlikelypyxpyerrgivenexceptionmatchesexctype pyexcstopiteration$^            return null$^        pyxpyerrclear$^        pyincrefdefval$^        return defval$^    $^    if defval $^        pyincrefdefval$^        return defval$^    $^    pyxpyerrsetnonepyexcstopiteration$^    return null$^$^static void pyxpyiternexterrornoiteratorpyobject iterator $^    pyerrformatpyexctypeerror$^        .000s object is not an iterator pytypeiteratortpname$^$^static cythoninline pyobject pyxpyiternext0pyobject iterator pyobject defval $^    pyobject next$^    iternextfunc iternext  pytypeiteratortpiternext$^    if likelyiternext $^if cythonusetypeslots$^        next  iternextiterator$^        if likelynext$^            return next$^        if pyversionhex  0x00000000$^        if unlikelyiternext  pyobjectnextnotimplemented$^            return null$^        endif$^else$^        next  pyiternextiterator$^        if likelynext$^            return next$^endif$^     else if cythonusetypeslots  unlikelypyitercheckiterator $^        pyxpyiternexterrornoiteratoriterator$^        return null$^    $^if cythonusetypeslots$^    else $^        next  pyiternextiterator$^        if likelynext$^            return next$^    $^endif$^    return pyxpyiternext0defaultdefval$^$^$^ pyobjectgenericgetattrnodict $^        if cythonusetypeslots  cythonusepytypelookup  pyversionhex  0x00000000$^static pyobject pyxraisegenericgetattributeerrorpytypeobject tp pyobject attrname $^    pyerrformatpyexcattributeerror$^if pymajorversion  0$^                 .00s object has no attribute u$^                 tptpname attrname$^else$^                 .00s object has no attribute .000s$^                 tptpname pystringasstringattrname$^endif$^    return null$^$^static cythoninline pyobject pyxpyobjectgenericgetattrnodictpyobject obj pyobject attrname $^    pyobject descr$^    pytypeobject tp  pytypeobj$^    if unlikelypystringcheckattrname $^        return pyobjectgenericgetattrobj attrname$^    $^    asserttptpdictoffset$^    descr  pytypelookuptp attrname$^    if unlikelydescr $^        return pyxraisegenericgetattributeerrortp attrname$^    $^    pyincrefdescr$^    if pymajorversion  0$^    if likelypytypehasfeaturepytypedescr pytpflagshaveclass$^    endif$^    $^        descrgetfunc f  pytypedescrtpdescrget$^        if unlikelyf $^            pyobject res  fdescr obj pyobject tp$^            pydecrefdescr$^            return res$^        $^    $^    return descr$^$^endif$^$^ pyobjectgenericgetattr $^        if cythonusetypeslots  cythonusepytypelookup  pyversionhex  0x00000000$^static pyobject pyxpyobjectgenericgetattrpyobject obj pyobject attrname $^    if unlikelypytypeobjtpdictoffset $^        return pyobjectgenericgetattrobj attrname$^    $^    return pyxpyobjectgenericgetattrnodictobj attrname$^$^endif$^$^ setvtable $^        static int pyxsetvtablepyobject dict void vtable $^if pyversionhex  0x00000000$^    pyobject ob  pycapsulenewvtable 0 0$^else$^    pyobject ob  pycobjectfromvoidptrvtable 0$^endif$^    if ob$^        goto bad$^    if pydictsetitemdict pyxnspyxvtable ob  0$^        goto bad$^    pydecrefob$^    return 0$^bad$^    pyxdecrefob$^    return 0$^$^$^ setupreduce $^        static int pyxsetupreduceisnamedpyobject meth pyobject name $^  int ret$^  pyobject nameattr$^  nameattr  pyxpyobjectgetattrstrmeth pyxnsname$^  if likelynameattr $^      ret  pyobjectrichcompareboolnameattr name pyeq$^   else $^      ret  0$^  $^  if unlikelyret  0 $^      pyerrclear$^      ret  0$^  $^  pyxdecrefnameattr$^  return ret$^$^static int pyxsetupreducepyobject typeobj $^    int ret  0$^    pyobject objectreduce  null$^    pyobject objectreduceex  null$^    pyobject reduce  null$^    pyobject reduceex  null$^    pyobject reducecython  null$^    pyobject setstate  null$^    pyobject setstatecython  null$^if cythonusepytypelookup$^    if pytypelookuppytypeobjecttypeobj pyxnsgetstate goto good$^else$^    if pyobjecthasattrtypeobj pyxnsgetstate goto good$^endif$^if cythonusepytypelookup$^    objectreduceex  pytypelookuppybaseobjecttype pyxnsreduceex if objectreduceex goto bad$^else$^    objectreduceex  pyxpyobjectgetattrstrpyobjectpybaseobjecttype pyxnsreduceex if objectreduceex goto bad$^endif$^    reduceex  pyxpyobjectgetattrstrtypeobj pyxnsreduceex if unlikelyreduceex goto bad$^    if reduceex  objectreduceex $^if cythonusepytypelookup$^        objectreduce  pytypelookuppybaseobjecttype pyxnsreduce if objectreduce goto bad$^else$^        objectreduce  pyxpyobjectgetattrstrpyobjectpybaseobjecttype pyxnsreduce if objectreduce goto bad$^endif$^        reduce  pyxpyobjectgetattrstrtypeobj pyxnsreduce if unlikelyreduce goto bad$^        if reduce  objectreduce  pyxsetupreduceisnamedreduce pyxnsreducecython $^            reducecython  pyxpyobjectgetattrstrtypeobj pyxnsreducecython if unlikelyreducecython goto bad$^            ret  pydictsetitempytypeobjecttypeobjtpdict pyxnsreduce reducecython if unlikelyret  0 goto bad$^            ret  pydictdelitempytypeobjecttypeobjtpdict pyxnsreducecython if unlikelyret  0 goto bad$^            setstate  pyxpyobjectgetattrstrtypeobj pyxnssetstate$^            if setstate pyerrclear$^            if setstate  pyxsetupreduceisnamedsetstate pyxnssetstatecython $^                setstatecython  pyxpyobjectgetattrstrtypeobj pyxnssetstatecython if unlikelysetstatecython goto bad$^                ret  pydictsetitempytypeobjecttypeobjtpdict pyxnssetstate setstatecython if unlikelyret  0 goto bad$^                ret  pydictdelitempytypeobjecttypeobjtpdict pyxnssetstatecython if unlikelyret  0 goto bad$^            $^            pytypemodifiedpytypeobjecttypeobj$^        $^    $^    goto good$^bad$^    if pyerroccurred$^        pyerrformatpyexcruntimeerror unable to initialize pickling for s pytypeobjecttypeobjtpname$^    ret  0$^good$^if cythonusepytypelookup$^    pyxdecrefobjectreduce$^    pyxdecrefobjectreduceex$^endif$^    pyxdecrefreduce$^    pyxdecrefreduceex$^    pyxdecrefreducecython$^    pyxdecrefsetstate$^    pyxdecrefsetstatecython$^    return ret$^$^$^ import $^        static pyobject pyximportpyobject name pyobject fromlist int level $^    pyobject emptylist  0$^    pyobject module  0$^    pyobject globaldict  0$^    pyobject emptydict  0$^    pyobject list$^    if pymajorversion  0$^    pyobject pyimport$^    pyimport  pyxpyobjectgetattrstrpyxb pyxnsimport$^    if pyimport$^        goto bad$^    endif$^    if fromlist$^        list  fromlist$^    else $^        emptylist  pylistnew0$^        if emptylist$^            goto bad$^        list  emptylist$^    $^    globaldict  pymodulegetdictpyxm$^    if globaldict$^        goto bad$^    emptydict  pydictnew$^    if emptydict$^        goto bad$^    $^        if pymajorversion  0$^        if level  0 $^            if strchrpyxmodulename . $^                module  pyimportimportmodulelevelobject$^                    name globaldict emptydict list 0$^                if module $^                    if pyerrexceptionmatchespyexcimporterror$^                        goto bad$^                    pyerrclear$^                $^            $^            level  0$^        $^        endif$^        if module $^            if pymajorversion  0$^            pyobject pylevel  pyintfromlonglevel$^            if pylevel$^                goto bad$^            module  pyobjectcallfunctionobjargspyimport$^                name globaldict emptydict list pylevel null$^            pydecrefpylevel$^            else$^            module  pyimportimportmodulelevelobject$^                name globaldict emptydict list level$^            endif$^        $^    $^bad$^    if pymajorversion  0$^    pyxdecrefpyimport$^    endif$^    pyxdecrefemptylist$^    pyxdecrefemptydict$^    return module$^$^$^ calculatemetaclass $^        static pyobject pyxcalculatemetaclasspytypeobject metaclass pyobject bases $^    pyssizet i nbases  pytuplegetsizebases$^    for i0 i  nbases i $^        pytypeobject tmptype$^        pyobject tmp  pytuplegetitembases i$^        tmptype  pytypetmp$^if pymajorversion  0$^        if tmptype  pyclasstype$^            continue$^endif$^        if metaclass $^            metaclass  tmptype$^            continue$^        $^        if pytypeissubtypemetaclass tmptype$^            continue$^        if pytypeissubtypetmptype metaclass $^            metaclass  tmptype$^            continue$^        $^        pyerrsetstringpyexctypeerror$^                        metaclass conflict $^                        the metaclass of a derived class $^                        must be a nonstrict subclass $^                        of the metaclasses of all its bases$^        return null$^    $^    if metaclass $^if pymajorversion  0$^        metaclass  pyclasstype$^else$^        metaclass  pytypetype$^endif$^    $^    pyincrefpyobject metaclass$^    return pyobject metaclass$^$^$^ py0classcreate $^        static pyobject pyxpy0metaclasspreparepyobject metaclass pyobject bases pyobject name$^                                           pyobject qualname pyobject mkw pyobject modname pyobject doc $^    pyobject ns$^    if metaclass $^        pyobject prep  pyxpyobjectgetattrstrmetaclass pyxnsprepare$^        if prep $^            pyobject pargs  pytuplepack0 name bases$^            if unlikelypargs $^                pydecrefprep$^                return null$^            $^            ns  pyobjectcallprep pargs mkw$^            pydecrefprep$^            pydecrefpargs$^         else $^            if unlikelypyerrexceptionmatchespyexcattributeerror$^                return null$^            pyerrclear$^            ns  pydictnew$^        $^     else $^        ns  pydictnew$^    $^    if unlikelyns$^        return null$^    if unlikelypyobjectsetitemns pyxnsmodule modname  0 goto bad$^    if unlikelypyobjectsetitemns pyxnsqualname qualname  0 goto bad$^    if unlikelydoc  pyobjectsetitemns pyxnsdoc doc  0 goto bad$^    return ns$^bad$^    pydecrefns$^    return null$^$^static pyobject pyxpy0classcreatepyobject metaclass pyobject name pyobject bases$^                                      pyobject dict pyobject mkw$^                                      int calculatemetaclass int allowpy0metaclass $^    pyobject result margs$^    pyobject ownedmetaclass  null$^    if allowpy0metaclass $^        ownedmetaclass  pyobjectgetitemdict pyxnsmetaclass$^        if ownedmetaclass $^            metaclass  ownedmetaclass$^         else if likelypyerrexceptionmatchespyexckeyerror $^            pyerrclear$^         else $^            return null$^        $^    $^    if calculatemetaclass  metaclass  pytypecheckmetaclass $^        metaclass  pyxcalculatemetaclasspytypeobject metaclass bases$^        pyxdecrefownedmetaclass$^        if unlikelymetaclass$^            return null$^        ownedmetaclass  metaclass$^    $^    margs  pytuplepack0 name bases dict$^    if unlikelymargs $^        result  null$^     else $^        result  pyobjectcallmetaclass margs mkw$^        pydecrefmargs$^    $^    pyxdecrefownedmetaclass$^    return result$^$^$^ classmethod $^        static pyobject pyxmethodclassmethodpyobject method $^if cythoncompilinginpypy  pypyversionnum  0x00000000$^    if pyobjecttypecheckmethod pywrapperdescrtype $^        return pyclassmethodnewmethod$^    $^else$^if cythoncompilinginpyston  cythoncompilinginpypy$^    if pymethoddescrcheckmethod $^else$^    static pytypeobject methoddescrtype  null$^    if methoddescrtype  null $^       pyobject meth  pyobjectgetattrstringpyobjectpylisttype append$^       if meth return null$^       methoddescrtype  pytypemeth$^       pydecrefmeth$^    $^    if pyxtypecheckmethod methoddescrtype $^endif$^        pymethoddescrobject descr  pymethoddescrobject method$^        if pyversionhex  0x00000000$^        pytypeobject dtype  descrdtype$^        else$^        pytypeobject dtype  descrdcommon.dtype$^        endif$^        return pydescrnewclassmethoddtype descrdmethod$^    $^endif$^    else if pymethodcheckmethod $^        return pyclassmethodnewpymethodgetfunctionmethod$^    $^    else if pycfunctioncheckmethod $^        return pyclassmethodnewmethod$^    $^ifdef pyxcyfunctionused$^    else if pyxtypecheckmethod pyxcyfunctiontype $^        return pyclassmethodnewmethod$^    $^endif$^    pyerrsetstringpyexctypeerror$^                   classlevel classmethod can only be called on $^                   a methoddescriptor or instance method.$^    return null$^$^$^ pyerrexceptionmatches $^          if cythonfastthreadstate$^static int pyxpyerrexceptionmatchestuplepyobject exctype pyobject tuple $^    pyssizet i n$^    n  pytuplegetsizetuple$^if pymajorversion  0$^    for i0 in i $^        if exctype  pytuplegetitemtuple i return 0$^    $^endif$^    for i0 in i $^        if pyxpyerrgivenexceptionmatchesexctype pytuplegetitemtuple i return 0$^    $^    return 0$^$^static cythoninline int pyxpyerrexceptionmatchesinstatepythreadstate tstate pyobject err $^    pyobject exctype  tstatecurexctype$^    if exctype  err return 0$^    if unlikelyexctype return 0$^    if unlikelypytuplecheckerr$^        return pyxpyerrexceptionmatchestupleexctype err$^    return pyxpyerrgivenexceptionmatchesexctype err$^$^endif$^$^ getnameinclass $^          static pyobject pyxgetglobalnameafterattributelookuppyobject name $^    pyxpythreadstatedeclare$^    pyxpythreadstateassign$^    if unlikelypyxpyerrexceptionmatchespyexcattributeerror$^        return null$^    pyxpyerrclear$^    return pyxgetmoduleglobalnamename$^$^static pyobject pyxgetnameinclasspyobject nmspace pyobject name $^    pyobject result$^    result  pyxpyobjectgetattrstrnmspace name$^    if result $^        result  pyxgetglobalnameafterattributelookupname$^    $^    return result$^$^$^ fetchcommontype $^          static pytypeobject pyxfetchcommontypepytypeobject type $^    pyobject fakemodule$^    pytypeobject cachedtype  null$^    fakemodule  pyimportaddmodulechar cython cythonabi$^    if fakemodule return null$^    pyincreffakemodule$^    cachedtype  pytypeobject pyobjectgetattrstringfakemodule typetpname$^    if cachedtype $^        if pytypecheckpyobjectcachedtype $^            pyerrformatpyexctypeerror$^                shared cython type .000s is not a type object$^                typetpname$^            goto bad$^        $^        if cachedtypetpbasicsize  typetpbasicsize $^            pyerrformatpyexctypeerror$^                shared cython type .000s has the wrong size try recompiling$^                typetpname$^            goto bad$^        $^     else $^        if pyerrexceptionmatchespyexcattributeerror goto bad$^        pyerrclear$^        if pytypereadytype  0 goto bad$^        if pyobjectsetattrstringfakemodule typetpname pyobject type  0$^            goto bad$^        pyincreftype$^        cachedtype  type$^    $^done$^    pydecreffakemodule$^    return cachedtype$^bad$^    pyxdecrefcachedtype$^    cachedtype  null$^    goto done$^$^$^ cythonfunction $^          include structmember.h$^static pyobject $^pyxcyfunctiongetdocpyxcyfunctionobject op cythonunused void closure$^$^    if unlikelyopfuncdoc  null $^        if opfunc.mmlmldoc $^if pymajorversion  0$^            opfuncdoc  pyunicodefromstringopfunc.mmlmldoc$^else$^            opfuncdoc  pystringfromstringopfunc.mmlmldoc$^endif$^            if unlikelyopfuncdoc  null$^                return null$^         else $^            pyincrefpynone$^            return pynone$^        $^    $^    pyincrefopfuncdoc$^    return opfuncdoc$^$^static int$^pyxcyfunctionsetdocpyxcyfunctionobject op pyobject value$^$^    pyobject tmp  opfuncdoc$^    if value  null $^        value  pynone$^    $^    pyincrefvalue$^    opfuncdoc  value$^    pyxdecreftmp$^    return 0$^$^static pyobject $^pyxcyfunctiongetnamepyxcyfunctionobject op$^$^    if unlikelyopfuncname  null $^if pymajorversion  0$^        opfuncname  pyunicodeinternfromstringopfunc.mmlmlname$^else$^        opfuncname  pystringinternfromstringopfunc.mmlmlname$^endif$^        if unlikelyopfuncname  null$^            return null$^    $^    pyincrefopfuncname$^    return opfuncname$^$^static int$^pyxcyfunctionsetnamepyxcyfunctionobject op pyobject value$^$^    pyobject tmp$^if pymajorversion  0$^    if unlikelyvalue  null  pyunicodecheckvalue $^else$^    if unlikelyvalue  null  pystringcheckvalue $^endif$^        pyerrsetstringpyexctypeerror$^                        name must be set to a string object$^        return 0$^    $^    tmp  opfuncname$^    pyincrefvalue$^    opfuncname  value$^    pyxdecreftmp$^    return 0$^$^static pyobject $^pyxcyfunctiongetqualnamepyxcyfunctionobject op$^$^    pyincrefopfuncqualname$^    return opfuncqualname$^$^static int$^pyxcyfunctionsetqualnamepyxcyfunctionobject op pyobject value$^$^    pyobject tmp$^if pymajorversion  0$^    if unlikelyvalue  null  pyunicodecheckvalue $^else$^    if unlikelyvalue  null  pystringcheckvalue $^endif$^        pyerrsetstringpyexctypeerror$^                        qualname must be set to a string object$^        return 0$^    $^    tmp  opfuncqualname$^    pyincrefvalue$^    opfuncqualname  value$^    pyxdecreftmp$^    return 0$^$^static pyobject $^pyxcyfunctiongetselfpyxcyfunctionobject m cythonunused void closure$^$^    pyobject self$^    self  mfuncclosure$^    if self  null$^        self  pynone$^    pyincrefself$^    return self$^$^static pyobject $^pyxcyfunctiongetdictpyxcyfunctionobject op$^$^    if unlikelyopfuncdict  null $^        opfuncdict  pydictnew$^        if unlikelyopfuncdict  null$^            return null$^    $^    pyincrefopfuncdict$^    return opfuncdict$^$^static int$^pyxcyfunctionsetdictpyxcyfunctionobject op pyobject value$^$^    pyobject tmp$^    if unlikelyvalue  null $^        pyerrsetstringpyexctypeerror$^               functions dictionary may not be deleted$^        return 0$^    $^    if unlikelypydictcheckvalue $^        pyerrsetstringpyexctypeerror$^               setting functions dictionary to a nondict$^        return 0$^    $^    tmp  opfuncdict$^    pyincrefvalue$^    opfuncdict  value$^    pyxdecreftmp$^    return 0$^$^static pyobject $^pyxcyfunctiongetglobalspyxcyfunctionobject op$^$^    pyincrefopfuncglobals$^    return opfuncglobals$^$^static pyobject $^pyxcyfunctiongetclosurecythonunused pyxcyfunctionobject op$^$^    pyincrefpynone$^    return pynone$^$^static pyobject $^pyxcyfunctiongetcodepyxcyfunctionobject op$^$^    pyobject result  opfunccode  opfunccode  pynone$^    pyincrefresult$^    return result$^$^static int$^pyxcyfunctioninitdefaultspyxcyfunctionobject op $^    int result  0$^    pyobject res  opdefaultsgetterpyobject  op$^    if unlikelyres$^        return 0$^    if cythonassumesafemacros  cythonavoidborrowedrefs$^    opdefaultstuple  pytuplegetitemres 0$^    pyincrefopdefaultstuple$^    opdefaultskwdict  pytuplegetitemres 0$^    pyincrefopdefaultskwdict$^    else$^    opdefaultstuple  pysequenceitemres 0$^    if unlikelyopdefaultstuple result  0$^    else $^        opdefaultskwdict  pysequenceitemres 0$^        if unlikelyopdefaultskwdict result  0$^    $^    endif$^    pydecrefres$^    return result$^$^static int$^pyxcyfunctionsetdefaultspyxcyfunctionobject op pyobject value $^    pyobject tmp$^    if value $^        value  pynone$^     else if value  pynone  pytuplecheckvalue $^        pyerrsetstringpyexctypeerror$^                        defaults must be set to a tuple object$^        return 0$^    $^    pyincrefvalue$^    tmp  opdefaultstuple$^    opdefaultstuple  value$^    pyxdecreftmp$^    return 0$^$^static pyobject $^pyxcyfunctiongetdefaultspyxcyfunctionobject op $^    pyobject result  opdefaultstuple$^    if unlikelyresult $^        if opdefaultsgetter $^            if pyxcyfunctioninitdefaultsop  0 return null$^            result  opdefaultstuple$^         else $^            result  pynone$^        $^    $^    pyincrefresult$^    return result$^$^static int$^pyxcyfunctionsetkwdefaultspyxcyfunctionobject op pyobject value $^    pyobject tmp$^    if value $^        value  pynone$^     else if value  pynone  pydictcheckvalue $^        pyerrsetstringpyexctypeerror$^                        kwdefaults must be set to a dict object$^        return 0$^    $^    pyincrefvalue$^    tmp  opdefaultskwdict$^    opdefaultskwdict  value$^    pyxdecreftmp$^    return 0$^$^static pyobject $^pyxcyfunctiongetkwdefaultspyxcyfunctionobject op $^    pyobject result  opdefaultskwdict$^    if unlikelyresult $^        if opdefaultsgetter $^            if pyxcyfunctioninitdefaultsop  0 return null$^            result  opdefaultskwdict$^         else $^            result  pynone$^        $^    $^    pyincrefresult$^    return result$^$^static int$^pyxcyfunctionsetannotationspyxcyfunctionobject op pyobject value $^    pyobject tmp$^    if value  value  pynone $^        value  null$^     else if pydictcheckvalue $^        pyerrsetstringpyexctypeerror$^                        annotations must be set to a dict object$^        return 0$^    $^    pyxincrefvalue$^    tmp  opfuncannotations$^    opfuncannotations  value$^    pyxdecreftmp$^    return 0$^$^static pyobject $^pyxcyfunctiongetannotationspyxcyfunctionobject op $^    pyobject result  opfuncannotations$^    if unlikelyresult $^        result  pydictnew$^        if unlikelyresult return null$^        opfuncannotations  result$^    $^    pyincrefresult$^    return result$^$^static pygetsetdef pyxcyfunctiongetsets  $^    char  funcdoc getterpyxcyfunctiongetdoc setterpyxcyfunctionsetdoc 0 0$^    char  doc  getterpyxcyfunctiongetdoc setterpyxcyfunctionsetdoc 0 0$^    char  funcname getterpyxcyfunctiongetname setterpyxcyfunctionsetname 0 0$^    char  name getterpyxcyfunctiongetname setterpyxcyfunctionsetname 0 0$^    char  qualname getterpyxcyfunctiongetqualname setterpyxcyfunctionsetqualname 0 0$^    char  self getterpyxcyfunctiongetself 0 0 0$^    char  funcdict getterpyxcyfunctiongetdict setterpyxcyfunctionsetdict 0 0$^    char  dict getterpyxcyfunctiongetdict setterpyxcyfunctionsetdict 0 0$^    char  funcglobals getterpyxcyfunctiongetglobals 0 0 0$^    char  globals getterpyxcyfunctiongetglobals 0 0 0$^    char  funcclosure getterpyxcyfunctiongetclosure 0 0 0$^    char  closure getterpyxcyfunctiongetclosure 0 0 0$^    char  funccode getterpyxcyfunctiongetcode 0 0 0$^    char  code getterpyxcyfunctiongetcode 0 0 0$^    char  funcdefaults getterpyxcyfunctiongetdefaults setterpyxcyfunctionsetdefaults 0 0$^    char  defaults getterpyxcyfunctiongetdefaults setterpyxcyfunctionsetdefaults 0 0$^    char  kwdefaults getterpyxcyfunctiongetkwdefaults setterpyxcyfunctionsetkwdefaults 0 0$^    char  annotations getterpyxcyfunctiongetannotations setterpyxcyfunctionsetannotations 0 0$^    0 0 0 0 0$^$^static pymemberdef pyxcyfunctionmembers  $^    char  module tobject offsetofpycfunctionobject mmodule pywriterestricted 0$^    0 0 0  0 0$^$^static pyobject $^pyxcyfunctionreducepyxcyfunctionobject m cythonunused pyobject args$^$^if pymajorversion  0$^    return pyunicodefromstringmfunc.mmlmlname$^else$^    return pystringfromstringmfunc.mmlmlname$^endif$^$^static pymethoddef pyxcyfunctionmethods  $^    reduce pycfunctionpyxcyfunctionreduce methvarargs 0$^    0 0 0 0$^$^if pyversionhex  0x000000a0$^define pyxcyfunctionweakreflistcyfunc cyfuncfuncweakreflist$^else$^define pyxcyfunctionweakreflistcyfunc cyfuncfunc.mweakreflist$^endif$^static pyobject pyxcyfunctionnewpytypeobject type pymethoddef ml int flags pyobject qualname$^                                      pyobject closure pyobject module pyobject globals pyobject code $^    pyxcyfunctionobject op  pyobjectgcnewpyxcyfunctionobject type$^    if op  null$^        return null$^    opflags  flags$^    pyxcyfunctionweakreflistop  null$^    opfunc.mml  ml$^    opfunc.mself  pyobject  op$^    pyxincrefclosure$^    opfuncclosure  closure$^    pyxincrefmodule$^    opfunc.mmodule  module$^    opfuncdict  null$^    opfuncname  null$^    pyincrefqualname$^    opfuncqualname  qualname$^    opfuncdoc  null$^    opfuncclassobj  null$^    opfuncglobals  globals$^    pyincrefopfuncglobals$^    pyxincrefcode$^    opfunccode  code$^    opdefaultspyobjects  0$^    opdefaults  null$^    opdefaultstuple  null$^    opdefaultskwdict  null$^    opdefaultsgetter  null$^    opfuncannotations  null$^    pyobjectgctrackop$^    return pyobject  op$^$^static int$^pyxcyfunctionclearpyxcyfunctionobject m$^$^    pyclearmfuncclosure$^    pyclearmfunc.mmodule$^    pyclearmfuncdict$^    pyclearmfuncname$^    pyclearmfuncqualname$^    pyclearmfuncdoc$^    pyclearmfuncglobals$^    pyclearmfunccode$^    pyclearmfuncclassobj$^    pyclearmdefaultstuple$^    pyclearmdefaultskwdict$^    pyclearmfuncannotations$^    if mdefaults $^        pyobject pydefaults  pyxcyfunctiondefaultspyobject  m$^        int i$^        for i  0 i  mdefaultspyobjects i$^            pyxdecrefpydefaultsi$^        pyobjectfreemdefaults$^        mdefaults  null$^    $^    return 0$^$^static void pyxcyfunctiondeallocpyxcyfunctionobject m$^$^    if pyxcyfunctionweakreflistm  null$^        pyobjectclearweakrefspyobject  m$^    pyxcyfunctionclearm$^    pyobjectgcdelm$^$^static void pyxcyfunctiondeallocpyxcyfunctionobject m$^$^    pyobjectgcuntrackm$^    pyxcyfunctiondeallocm$^$^static int pyxcyfunctiontraversepyxcyfunctionobject m visitproc visit void arg$^$^    pyvisitmfuncclosure$^    pyvisitmfunc.mmodule$^    pyvisitmfuncdict$^    pyvisitmfuncname$^    pyvisitmfuncqualname$^    pyvisitmfuncdoc$^    pyvisitmfuncglobals$^    pyvisitmfunccode$^    pyvisitmfuncclassobj$^    pyvisitmdefaultstuple$^    pyvisitmdefaultskwdict$^    if mdefaults $^        pyobject pydefaults  pyxcyfunctiondefaultspyobject  m$^        int i$^        for i  0 i  mdefaultspyobjects i$^            pyvisitpydefaultsi$^    $^    return 0$^$^static pyobject pyxcyfunctiondescrgetpyobject func pyobject obj pyobject type$^$^    pyxcyfunctionobject m  pyxcyfunctionobject  func$^    if mflags  pyxcyfunctionstaticmethod $^        pyincreffunc$^        return func$^    $^    if mflags  pyxcyfunctionclassmethod $^        if type  null$^            type  pyobject pytypeobj$^        return pyxpymethodnewfunc type pyobject pytypetype$^    $^    if obj  pynone$^        obj  null$^    return pyxpymethodnewfunc obj type$^$^static pyobject$^pyxcyfunctionreprpyxcyfunctionobject op$^$^if pymajorversion  0$^    return pyunicodefromformatcyfunction u at p$^                                opfuncqualname void op$^else$^    return pystringfromformatcyfunction s at p$^                               pystringasstringopfuncqualname void op$^endif$^$^static pyobject  pyxcyfunctioncallmethodpyobject func pyobject self pyobject arg pyobject kw $^    pycfunctionobject f  pycfunctionobjectfunc$^    pycfunction meth  fmmlmlmeth$^    pyssizet size$^    switch fmmlmlflags  methvarargs  methkeywords  methnoargs  metho $^    case methvarargs$^        if likelykw  null  pydictsizekw  0$^            return methself arg$^        break$^    case methvarargs  methkeywords$^        return pycfunctionwithkeywordsmethself arg kw$^    case methnoargs$^        if likelykw  null  pydictsizekw  0 $^            size  pytuplegetsizearg$^            if likelysize  0$^                return methself null$^            pyerrformatpyexctypeerror$^                .000s takes no arguments  cythonformatssizet d given$^                fmmlmlname size$^            return null$^        $^        break$^    case metho$^        if likelykw  null  pydictsizekw  0 $^            size  pytuplegetsizearg$^            if likelysize  0 $^                pyobject result arg0$^                if cythonassumesafemacros  cythonavoidborrowedrefs$^                arg0  pytuplegetitemarg 0$^                else$^                arg0  pysequenceitemarg 0 if unlikelyarg0 return null$^                endif$^                result  methself arg0$^                if cythonassumesafemacros  cythonavoidborrowedrefs$^                pydecrefarg0$^                endif$^                return result$^            $^            pyerrformatpyexctypeerror$^                .000s takes exactly one argument  cythonformatssizet d given$^                fmmlmlname size$^            return null$^        $^        break$^    default$^        pyerrsetstringpyexcsystemerror bad call flags in $^                        pyxcyfunctioncall. metholdargs is no $^                        longer supported$^        return null$^    $^    pyerrformatpyexctypeerror .000s takes no keyword arguments$^                 fmmlmlname$^    return null$^$^static cythoninline pyobject pyxcyfunctioncallpyobject func pyobject arg pyobject kw $^    return pyxcyfunctioncallmethodfunc pycfunctionobjectfuncmself arg kw$^$^static pyobject pyxcyfunctioncallasmethodpyobject func pyobject args pyobject kw $^    pyobject result$^    pyxcyfunctionobject cyfunc  pyxcyfunctionobject  func$^    if cyfuncflags  pyxcyfunctioncclass  cyfuncflags  pyxcyfunctionstaticmethod $^        pyssizet argc$^        pyobject newargs$^        pyobject self$^        argc  pytuplegetsizeargs$^        newargs  pytuplegetsliceargs 0 argc$^        if unlikelynewargs$^            return null$^        self  pytuplegetitemargs 0$^        if unlikelyself $^            pydecrefnewargs$^            return null$^        $^        result  pyxcyfunctioncallmethodfunc self newargs kw$^        pydecrefnewargs$^     else $^        result  pyxcyfunctioncallfunc args kw$^    $^    return result$^$^static pytypeobject pyxcyfunctiontypetype  $^    pyvarobjectheadinit0 0$^    cythonfunctionormethod$^    sizeofpyxcyfunctionobject$^    0$^    destructor pyxcyfunctiondealloc$^    0$^    0$^    0$^if pymajorversion  0$^    0$^else$^    0$^endif$^    reprfunc pyxcyfunctionrepr$^    0$^    0$^    0$^    0$^    pyxcyfunctioncallasmethod$^    0$^    0$^    0$^    0$^    pytpflagsdefault  pytpflagshavegc$^    0$^    traverseproc pyxcyfunctiontraverse$^    inquiry pyxcyfunctionclear$^    0$^if pyversionhex  0x000000a0$^    offsetofpyxcyfunctionobject funcweakreflist$^else$^    offsetofpycfunctionobject mweakreflist$^endif$^    0$^    0$^    pyxcyfunctionmethods$^    pyxcyfunctionmembers$^    pyxcyfunctiongetsets$^    0$^    0$^    pyxcyfunctiondescrget$^    0$^    offsetofpyxcyfunctionobject funcdict$^    0$^    0$^    0$^    0$^    0$^    0$^    0$^    0$^    0$^    0$^    0$^    0$^if pyversionhex  0x000000a0$^    0$^endif$^$^static int pyxcyfunctioninitvoid $^    pyxcyfunctiontype  pyxfetchcommontypepyxcyfunctiontypetype$^    if unlikelypyxcyfunctiontype  null $^        return 0$^    $^    return 0$^$^static cythoninline void pyxcyfunctioninitdefaultspyobject func sizet size int pyobjects $^    pyxcyfunctionobject m  pyxcyfunctionobject  func$^    mdefaults  pyobjectmallocsize$^    if unlikelymdefaults$^        return pyerrnomemory$^    memsetmdefaults 0 size$^    mdefaultspyobjects  pyobjects$^    return mdefaults$^$^static cythoninline void pyxcyfunctionsetdefaultstuplepyobject func pyobject tuple $^    pyxcyfunctionobject m  pyxcyfunctionobject  func$^    mdefaultstuple  tuple$^    pyincreftuple$^$^static cythoninline void pyxcyfunctionsetdefaultskwdictpyobject func pyobject dict $^    pyxcyfunctionobject m  pyxcyfunctionobject  func$^    mdefaultskwdict  dict$^    pyincrefdict$^$^static cythoninline void pyxcyfunctionsetannotationsdictpyobject func pyobject dict $^    pyxcyfunctionobject m  pyxcyfunctionobject  func$^    mfuncannotations  dict$^    pyincrefdict$^$^$^ clineintraceback $^              ifndef cythonclineintraceback$^static int pyxclinefortracebackcythonunused pythreadstate tstate int cline $^    pyobject usecline$^    pyobject ptype pvalue ptraceback$^if cythoncompilingincpython$^    pyobject cythonruntimedict$^endif$^    if unlikelypyxcythonruntime $^        return cline$^    $^    pyxerrfetchinstatetstate ptype pvalue ptraceback$^if cythoncompilingincpython$^    cythonruntimedict  pyobjectgetdictptrpyxcythonruntime$^    if likelycythonruntimedict $^      usecline  pyxpydictgetitemstrcythonruntimedict pyxnsclineintraceback$^     else$^endif$^    $^      pyobject useclineobj  pyxpyobjectgetattrstrpyxcythonruntime pyxnsclineintraceback$^      if useclineobj $^        usecline  pyobjectnotuseclineobj  pyfalse  pytrue$^        pydecrefuseclineobj$^       else $^        pyerrclear$^        usecline  null$^      $^    $^    if usecline $^        cline  0$^        pyobjectsetattrpyxcythonruntime pyxnsclineintraceback pyfalse$^    $^    else if pyobjectnotusecline  0 $^        cline  0$^    $^    pyxerrrestoreinstatetstate ptype pvalue ptraceback$^    return cline$^$^endif$^$^ codeobjectcache $^              static int pyxbisectcodeobjectspyxcodeobjectcacheentry entries int count int codeline $^    int start  0 mid  0 end  count  0$^    if end  0  codeline  entriesend.codeline $^        return count$^    $^    while start  end $^        mid  start  end  start  0$^        if codeline  entriesmid.codeline $^            end  mid$^         else if codeline  entriesmid.codeline $^             start  mid  0$^         else $^            return mid$^        $^    $^    if codeline  entriesmid.codeline $^        return mid$^     else $^        return mid  0$^    $^$^static pycodeobject pyxfindcodeobjectint codeline $^    pycodeobject codeobject$^    int pos$^    if unlikelycodeline  unlikelypyxcodecache.entries $^        return null$^    $^    pos  pyxbisectcodeobjectspyxcodecache.entries pyxcodecache.count codeline$^    if unlikelypos  pyxcodecache.count  unlikelypyxcodecache.entriespos.codeline  codeline $^        return null$^    $^    codeobject  pyxcodecache.entriespos.codeobject$^    pyincrefcodeobject$^    return codeobject$^$^static void pyxinsertcodeobjectint codeline pycodeobject codeobject $^    int pos i$^    pyxcodeobjectcacheentry entries  pyxcodecache.entries$^    if unlikelycodeline $^        return$^    $^    if unlikelyentries $^        entries  pyxcodeobjectcacheentrypymemmalloc00sizeofpyxcodeobjectcacheentry$^        if likelyentries $^            pyxcodecache.entries  entries$^            pyxcodecache.maxcount  00$^            pyxcodecache.count  0$^            entries0.codeline  codeline$^            entries0.codeobject  codeobject$^            pyincrefcodeobject$^        $^        return$^    $^    pos  pyxbisectcodeobjectspyxcodecache.entries pyxcodecache.count codeline$^    if pos  pyxcodecache.count  unlikelypyxcodecache.entriespos.codeline  codeline $^        pycodeobject tmp  entriespos.codeobject$^        entriespos.codeobject  codeobject$^        pydecreftmp$^        return$^    $^    if pyxcodecache.count  pyxcodecache.maxcount $^        int newmax  pyxcodecache.maxcount  00$^        entries  pyxcodeobjectcacheentrypymemrealloc$^            pyxcodecache.entries sizetnewmaxsizeofpyxcodeobjectcacheentry$^        if unlikelyentries $^            return$^        $^        pyxcodecache.entries  entries$^        pyxcodecache.maxcount  newmax$^    $^    for ipyxcodecache.count ipos i $^        entriesi  entriesi0$^    $^    entriespos.codeline  codeline$^    entriespos.codeobject  codeobject$^    pyxcodecache.count$^    pyincrefcodeobject$^$^$^ addtraceback $^              include compile.h$^include frameobject.h$^include traceback.h$^static pycodeobject pyxcreatecodeobjectfortraceback$^            const char funcname int cline$^            int pyline const char filename $^    pycodeobject pycode  0$^    pyobject pysrcfile  0$^    pyobject pyfuncname  0$^    if pymajorversion  0$^    pysrcfile  pystringfromstringfilename$^    else$^    pysrcfile  pyunicodefromstringfilename$^    endif$^    if pysrcfile goto bad$^    if cline $^        if pymajorversion  0$^        pyfuncname  pystringfromformat s sd funcname pyxcfilenm cline$^        else$^        pyfuncname  pyunicodefromformat s sd funcname pyxcfilenm cline$^        endif$^    $^    else $^        if pymajorversion  0$^        pyfuncname  pystringfromstringfuncname$^        else$^        pyfuncname  pyunicodefromstringfuncname$^        endif$^    $^    if pyfuncname goto bad$^    pycode  pyxpycodenew$^        0$^        0$^        0$^        0$^        0$^        pyxemptybytes pyobject code$^        pyxemptytuple pyobject consts$^        pyxemptytuple pyobject names$^        pyxemptytuple pyobject varnames$^        pyxemptytuple pyobject freevars$^        pyxemptytuple pyobject cellvars$^        pysrcfile   pyobject filename$^        pyfuncname  pyobject name$^        pyline$^        pyxemptybytes  pyobject lnotab$^    $^    pydecrefpysrcfile$^    pydecrefpyfuncname$^    return pycode$^bad$^    pyxdecrefpysrcfile$^    pyxdecrefpyfuncname$^    return null$^$^static void pyxaddtracebackconst char funcname int cline$^                               int pyline const char filename $^    pycodeobject pycode  0$^    pyframeobject pyframe  0$^    pythreadstate tstate  pyxpythreadstatecurrent$^    if cline $^        cline  pyxclinefortracebacktstate cline$^    $^    pycode  pyxfindcodeobjectcline  cline  pyline$^    if pycode $^        pycode  pyxcreatecodeobjectfortraceback$^            funcname cline pyline filename$^        if pycode goto bad$^        pyxinsertcodeobjectcline  cline  pyline pycode$^    $^    pyframe  pyframenew$^        tstate            pythreadstate tstate$^        pycode           pycodeobject code$^        pyxd    pyobject globals$^        0                  pyobject locals$^    $^    if pyframe goto bad$^    pyxpyframesetlinenumberpyframe pyline$^    pytracebackherepyframe$^bad$^    pyxdecrefpycode$^    pyxdecrefpyframe$^$^$^ cintfrompyverify $^              define pyxverifyreturninttargettype functype funcvalue$^    pyxverifyreturninttargettype functype funcvalue 0$^define pyxverifyreturnintexctargettype functype funcvalue$^    pyxverifyreturninttargettype functype funcvalue 0$^define pyxverifyreturninttargettype functype funcvalue exc$^    $^        functype value  funcvalue$^        if sizeoftargettype  sizeoffunctype $^            if unlikelyvalue  functype targettype value $^                functype zero  0$^                if exc  unlikelyvalue  functype0  pyerroccurred$^                    return targettype 0$^                if isunsigned  unlikelyvalue  zero$^                    goto raisenegoverflow$^                else$^                    goto raiseoverflow$^            $^        $^        return targettype value$^    $^$^ cinttopy $^              static cythoninline pyobject pyxpyintfromintint value $^    const int negone  int 0 constzero  int 0$^    const int isunsigned  negone  constzero$^    if isunsigned $^        if sizeofint  sizeoflong $^            return pyintfromlonglong value$^         else if sizeofint  sizeofunsigned long $^            return pylongfromunsignedlongunsigned long value$^ifdef havelonglong$^         else if sizeofint  sizeofunsigned pylonglong $^            return pylongfromunsignedlonglongunsigned pylonglong value$^endif$^        $^     else $^        if sizeofint  sizeoflong $^            return pyintfromlonglong value$^ifdef havelonglong$^         else if sizeofint  sizeofpylonglong $^            return pylongfromlonglongpylonglong value$^endif$^        $^    $^    $^        int one  0 int little  intunsigned char one$^        unsigned char bytes  unsigned char value$^        return pylongfrombytearraybytes sizeofint$^                                     little isunsigned$^    $^$^$^ cinttopy $^              static cythoninline pyobject pyxpyintfromuint00tuint00t value $^    const uint00t negone  uint00t 0 constzero  uint00t 0$^    const int isunsigned  negone  constzero$^    if isunsigned $^        if sizeofuint00t  sizeoflong $^            return pyintfromlonglong value$^         else if sizeofuint00t  sizeofunsigned long $^            return pylongfromunsignedlongunsigned long value$^ifdef havelonglong$^         else if sizeofuint00t  sizeofunsigned pylonglong $^            return pylongfromunsignedlonglongunsigned pylonglong value$^endif$^        $^     else $^        if sizeofuint00t  sizeoflong $^            return pyintfromlonglong value$^ifdef havelonglong$^         else if sizeofuint00t  sizeofpylonglong $^            return pylongfromlonglongpylonglong value$^endif$^        $^    $^    $^        int one  0 int little  intunsigned char one$^        unsigned char bytes  unsigned char value$^        return pylongfrombytearraybytes sizeofuint00t$^                                     little isunsigned$^    $^$^$^ cinttopy $^              static cythoninline pyobject pyxpyintfromuint00tuint00t value $^    const uint00t negone  uint00t 0 constzero  uint00t 0$^    const int isunsigned  negone  constzero$^    if isunsigned $^        if sizeofuint00t  sizeoflong $^            return pyintfromlonglong value$^         else if sizeofuint00t  sizeofunsigned long $^            return pylongfromunsignedlongunsigned long value$^ifdef havelonglong$^         else if sizeofuint00t  sizeofunsigned pylonglong $^            return pylongfromunsignedlonglongunsigned pylonglong value$^endif$^        $^     else $^        if sizeofuint00t  sizeoflong $^            return pyintfromlonglong value$^ifdef havelonglong$^         else if sizeofuint00t  sizeofpylonglong $^            return pylongfromlonglongpylonglong value$^endif$^        $^    $^    $^        int one  0 int little  intunsigned char one$^        unsigned char bytes  unsigned char value$^        return pylongfrombytearraybytes sizeofuint00t$^                                     little isunsigned$^    $^$^$^ cinttopy $^              static cythoninline pyobject pyxpyintfromint00tint00t value $^    const int00t negone  int00t 0 constzero  int00t 0$^    const int isunsigned  negone  constzero$^    if isunsigned $^        if sizeofint00t  sizeoflong $^            return pyintfromlonglong value$^         else if sizeofint00t  sizeofunsigned long $^            return pylongfromunsignedlongunsigned long value$^ifdef havelonglong$^         else if sizeofint00t  sizeofunsigned pylonglong $^            return pylongfromunsignedlonglongunsigned pylonglong value$^endif$^        $^     else $^        if sizeofint00t  sizeoflong $^            return pyintfromlonglong value$^ifdef havelonglong$^         else if sizeofint00t  sizeofpylonglong $^            return pylongfromlonglongpylonglong value$^endif$^        $^    $^    $^        int one  0 int little  intunsigned char one$^        unsigned char bytes  unsigned char value$^        return pylongfrombytearraybytes sizeofint00t$^                                     little isunsigned$^    $^$^$^ cinttopy $^              static cythoninline pyobject pyxpyintfromint00tint00t value $^    const int00t negone  int00t 0 constzero  int00t 0$^    const int isunsigned  negone  constzero$^    if isunsigned $^        if sizeofint00t  sizeoflong $^            return pyintfromlonglong value$^         else if sizeofint00t  sizeofunsigned long $^            return pylongfromunsignedlongunsigned long value$^ifdef havelonglong$^         else if sizeofint00t  sizeofunsigned pylonglong $^            return pylongfromunsignedlonglongunsigned pylonglong value$^endif$^        $^     else $^        if sizeofint00t  sizeoflong $^            return pyintfromlonglong value$^ifdef havelonglong$^         else if sizeofint00t  sizeofpylonglong $^            return pylongfromlonglongpylonglong value$^endif$^        $^    $^    $^        int one  0 int little  intunsigned char one$^        unsigned char bytes  unsigned char value$^        return pylongfrombytearraybytes sizeofint00t$^                                     little isunsigned$^    $^$^$^ cintfrompy $^              static cythoninline sizet pyxpyintassizetpyobject x $^    const sizet negone  sizet 0 constzero  sizet 0$^    const int isunsigned  negone  constzero$^if pymajorversion  0$^    if likelypyintcheckx $^        if sizeofsizet  sizeoflong $^            pyxverifyreturnintsizet long pyintaslongx$^         else $^            long val  pyintaslongx$^            if isunsigned  unlikelyval  0 $^                goto raisenegoverflow$^            $^            return sizet val$^        $^     else$^endif$^    if likelypylongcheckx $^        if isunsigned $^if cythonusepylonginternals$^            const digit digits  pylongobjectxobdigit$^            switch pysizex $^                case  0 return sizet 0$^                case  0 pyxverifyreturnintsizet digit digits0$^                case 0$^                    if 0  sizeofsizet  0  pylongshift $^                        if 0  sizeofunsigned long  0  pylongshift $^                            pyxverifyreturnintsizet unsigned long unsigned longdigits0  pylongshift  unsigned longdigits0$^                         else if 0  sizeofsizet  0  pylongshift $^                            return sizet sizetdigits0  pylongshift  sizetdigits0$^                        $^                    $^                    break$^                case 0$^                    if 0  sizeofsizet  0  pylongshift $^                        if 0  sizeofunsigned long  0  pylongshift $^                            pyxverifyreturnintsizet unsigned long unsigned longdigits0  pylongshift  unsigned longdigits0  pylongshift  unsigned longdigits0$^                         else if 0  sizeofsizet  0  pylongshift $^                            return sizet sizetdigits0  pylongshift  sizetdigits0  pylongshift  sizetdigits0$^                        $^                    $^                    break$^                case 0$^                    if 0  sizeofsizet  0  pylongshift $^                        if 0  sizeofunsigned long  0  pylongshift $^                            pyxverifyreturnintsizet unsigned long unsigned longdigits0  pylongshift  unsigned longdigits0  pylongshift  unsigned longdigits0  pylongshift  unsigned longdigits0$^                         else if 0  sizeofsizet  0  pylongshift $^                            return sizet sizetdigits0  pylongshift  sizetdigits0  pylongshift  sizetdigits0  pylongshift  sizetdigits0$^                        $^                    $^                    break$^            $^endif$^if cythoncompilingincpython$^            if unlikelypysizex  0 $^                goto raisenegoverflow$^            $^else$^            $^                int result  pyobjectrichcompareboolx pyfalse pylt$^                if unlikelyresult  0$^                    return sizet 0$^                if unlikelyresult  0$^                    goto raisenegoverflow$^            $^endif$^            if sizeofsizet  sizeofunsigned long $^                pyxverifyreturnintexcsizet unsigned long pylongasunsignedlongx$^ifdef havelonglong$^             else if sizeofsizet  sizeofunsigned pylonglong $^                pyxverifyreturnintexcsizet unsigned pylonglong pylongasunsignedlonglongx$^endif$^            $^         else $^if cythonusepylonginternals$^            const digit digits  pylongobjectxobdigit$^            switch pysizex $^                case  0 return sizet 0$^                case 0 pyxverifyreturnintsizet sdigit sdigit sdigitdigits0$^                case  0 pyxverifyreturnintsizet  digit digits0$^                case 0$^                    if 0  sizeofsizet  0  0  pylongshift $^                        if 0  sizeofunsigned long  0  pylongshift $^                            pyxverifyreturnintsizet long long unsigned longdigits0  pylongshift  unsigned longdigits0$^                         else if 0  sizeofsizet  0  0  pylongshift $^                            return sizet sizet0sizetdigits0  pylongshift  sizetdigits0$^                        $^                    $^                    break$^                case 0$^                    if 0  sizeofsizet  0  pylongshift $^                        if 0  sizeofunsigned long  0  pylongshift $^                            pyxverifyreturnintsizet unsigned long unsigned longdigits0  pylongshift  unsigned longdigits0$^                         else if 0  sizeofsizet  0  0  pylongshift $^                            return sizet sizetdigits0  pylongshift  sizetdigits0$^                        $^                    $^                    break$^                case 0$^                    if 0  sizeofsizet  0  0  pylongshift $^                        if 0  sizeofunsigned long  0  pylongshift $^                            pyxverifyreturnintsizet long long unsigned longdigits0  pylongshift  unsigned longdigits0  pylongshift  unsigned longdigits0$^                         else if 0  sizeofsizet  0  0  pylongshift $^                            return sizet sizet0sizetdigits0  pylongshift  sizetdigits0  pylongshift  sizetdigits0$^                        $^                    $^                    break$^                case 0$^                    if 0  sizeofsizet  0  pylongshift $^                        if 0  sizeofunsigned long  0  pylongshift $^                            pyxverifyreturnintsizet unsigned long unsigned longdigits0  pylongshift  unsigned longdigits0  pylongshift  unsigned longdigits0$^                         else if 0  sizeofsizet  0  0  pylongshift $^                            return sizet sizetdigits0  pylongshift  sizetdigits0  pylongshift  sizetdigits0$^                        $^                    $^                    break$^                case 0$^                    if 0  sizeofsizet  0  0  pylongshift $^                        if 0  sizeofunsigned long  0  pylongshift $^                            pyxverifyreturnintsizet long long unsigned longdigits0  pylongshift  unsigned longdigits0  pylongshift  unsigned longdigits0  pylongshift  unsigned longdigits0$^                         else if 0  sizeofsizet  0  0  pylongshift $^                            return sizet sizet0sizetdigits0  pylongshift  sizetdigits0  pylongshift  sizetdigits0  pylongshift  sizetdigits0$^                        $^                    $^                    break$^                case 0$^                    if 0  sizeofsizet  0  pylongshift $^                        if 0  sizeofunsigned long  0  pylongshift $^                            pyxverifyreturnintsizet unsigned long unsigned longdigits0  pylongshift  unsigned longdigits0  pylongshift  unsigned longdigits0  pylongshift  unsigned longdigits0$^                         else if 0  sizeofsizet  0  0  pylongshift $^                            return sizet sizetdigits0  pylongshift  sizetdigits0  pylongshift  sizetdigits0  pylongshift  sizetdigits0$^                        $^                    $^                    break$^            $^endif$^            if sizeofsizet  sizeoflong $^                pyxverifyreturnintexcsizet long pylongaslongx$^ifdef havelonglong$^             else if sizeofsizet  sizeofpylonglong $^                pyxverifyreturnintexcsizet pylonglong pylongaslonglongx$^endif$^            $^        $^        $^if cythoncompilinginpypy  definedpylongasbytearray$^            pyerrsetstringpyexcruntimeerror$^                            pylongasbytearray not available in pypy cannot convert large numbers$^else$^            sizet val$^            pyobject v  pyxpynumberintorlongx$^ if pymajorversion  0$^            if likelyv  pylongcheckv $^                pyobject tmp  v$^                v  pynumberlongtmp$^                pydecreftmp$^            $^ endif$^            if likelyv $^                int one  0 int islittle  intunsigned char one$^                unsigned char bytes  unsigned char val$^                int ret  pylongasbytearraypylongobject v$^                                              bytes sizeofval$^                                              islittle isunsigned$^                pydecrefv$^                if likelyret$^                    return val$^            $^endif$^            return sizet 0$^        $^     else $^        sizet val$^        pyobject tmp  pyxpynumberintorlongx$^        if tmp return sizet 0$^        val  pyxpyintassizettmp$^        pydecreftmp$^        return val$^    $^raiseoverflow$^    pyerrsetstringpyexcoverflowerror$^        value too large to convert to sizet$^    return sizet 0$^raisenegoverflow$^    pyerrsetstringpyexcoverflowerror$^        cant convert negative value to sizet$^    return sizet 0$^$^$^ cintfrompy $^              static cythoninline int00t pyxpyintasint00tpyobject x $^    const int00t negone  int00t 0 constzero  int00t 0$^    const int isunsigned  negone  constzero$^if pymajorversion  0$^    if likelypyintcheckx $^        if sizeofint00t  sizeoflong $^            pyxverifyreturnintint00t long pyintaslongx$^         else $^            long val  pyintaslongx$^            if isunsigned  unlikelyval  0 $^                goto raisenegoverflow$^            $^            return int00t val$^        $^     else$^endif$^    if likelypylongcheckx $^        if isunsigned $^if cythonusepylonginternals$^            const digit digits  pylongobjectxobdigit$^            switch pysizex $^                case  0 return int00t 0$^                case  0 pyxverifyreturnintint00t digit digits0$^                case 0$^                    if 0  sizeofint00t  0  pylongshift $^                        if 0  sizeofunsigned long  0  pylongshift $^                            pyxverifyreturnintint00t unsigned long unsigned longdigits0  pylongshift  unsigned longdigits0$^                         else if 0  sizeofint00t  0  pylongshift $^                            return int00t int00tdigits0  pylongshift  int00tdigits0$^                        $^                    $^                    break$^                case 0$^                    if 0  sizeofint00t  0  pylongshift $^                        if 0  sizeofunsigned long  0  pylongshift $^                            pyxverifyreturnintint00t unsigned long unsigned longdigits0  pylongshift  unsigned longdigits0  pylongshift  unsigned longdigits0$^                         else if 0  sizeofint00t  0  pylongshift $^                            return int00t int00tdigits0  pylongshift  int00tdigits0  pylongshift  int00tdigits0$^                        $^                    $^                    break$^                case 0$^                    if 0  sizeofint00t  0  pylongshift $^                        if 0  sizeofunsigned long  0  pylongshift $^                            pyxverifyreturnintint00t unsigned long unsigned longdigits0  pylongshift  unsigned longdigits0  pylongshift  unsigned longdigits0  pylongshift  unsigned longdigits0$^                         else if 0  sizeofint00t  0  pylongshift $^                            return int00t int00tdigits0  pylongshift  int00tdigits0  pylongshift  int00tdigits0  pylongshift  int00tdigits0$^                        $^                    $^                    break$^            $^endif$^if cythoncompilingincpython$^            if unlikelypysizex  0 $^                goto raisenegoverflow$^            $^else$^            $^                int result  pyobjectrichcompareboolx pyfalse pylt$^                if unlikelyresult  0$^                    return int00t 0$^                if unlikelyresult  0$^                    goto raisenegoverflow$^            $^endif$^            if sizeofint00t  sizeofunsigned long $^                pyxverifyreturnintexcint00t unsigned long pylongasunsignedlongx$^ifdef havelonglong$^             else if sizeofint00t  sizeofunsigned pylonglong $^                pyxverifyreturnintexcint00t unsigned pylonglong pylongasunsignedlonglongx$^endif$^            $^         else $^if cythonusepylonginternals$^            const digit digits  pylongobjectxobdigit$^            switch pysizex $^                case  0 return int00t 0$^                case 0 pyxverifyreturnintint00t sdigit sdigit sdigitdigits0$^                case  0 pyxverifyreturnintint00t  digit digits0$^                case 0$^                    if 0  sizeofint00t  0  0  pylongshift $^                        if 0  sizeofunsigned long  0  pylongshift $^                            pyxverifyreturnintint00t long long unsigned longdigits0  pylongshift  unsigned longdigits0$^                         else if 0  sizeofint00t  0  0  pylongshift $^                            return int00t int00t0int00tdigits0  pylongshift  int00tdigits0$^                        $^                    $^                    break$^                case 0$^                    if 0  sizeofint00t  0  pylongshift $^                        if 0  sizeofunsigned long  0  pylongshift $^                            pyxverifyreturnintint00t unsigned long unsigned longdigits0  pylongshift  unsigned longdigits0$^                         else if 0  sizeofint00t  0  0  pylongshift $^                            return int00t int00tdigits0  pylongshift  int00tdigits0$^                        $^                    $^                    break$^                case 0$^                    if 0  sizeofint00t  0  0  pylongshift $^                        if 0  sizeofunsigned long  0  pylongshift $^                            pyxverifyreturnintint00t long long unsigned longdigits0  pylongshift  unsigned longdigits0  pylongshift  unsigned longdigits0$^                         else if 0  sizeofint00t  0  0  pylongshift $^                            return int00t int00t0int00tdigits0  pylongshift  int00tdigits0  pylongshift  int00tdigits0$^                        $^                    $^                    break$^                case 0$^                    if 0  sizeofint00t  0  pylongshift $^                        if 0  sizeofunsigned long  0  pylongshift $^                            pyxverifyreturnintint00t unsigned long unsigned longdigits0  pylongshift  unsigned longdigits0  pylongshift  unsigned longdigits0$^                         else if 0  sizeofint00t  0  0  pylongshift $^                            return int00t int00tdigits0  pylongshift  int00tdigits0  pylongshift  int00tdigits0$^                        $^                    $^                    break$^                case 0$^                    if 0  sizeofint00t  0  0  pylongshift $^                        if 0  sizeofunsigned long  0  pylongshift $^                            pyxverifyreturnintint00t long long unsigned longdigits0  pylongshift  unsigned longdigits0  pylongshift  unsigned longdigits0  pylongshift  unsigned longdigits0$^                         else if 0  sizeofint00t  0  0  pylongshift $^                            return int00t int00t0int00tdigits0  pylongshift  int00tdigits0  pylongshift  int00tdigits0  pylongshift  int00tdigits0$^                        $^                    $^                    break$^                case 0$^                    if 0  sizeofint00t  0  pylongshift $^                        if 0  sizeofunsigned long  0  pylongshift $^                            pyxverifyreturnintint00t unsigned long unsigned longdigits0  pylongshift  unsigned longdigits0  pylongshift  unsigned longdigits0  pylongshift  unsigned longdigits0$^                         else if 0  sizeofint00t  0  0  pylongshift $^                            return int00t int00tdigits0  pylongshift  int00tdigits0  pylongshift  int00tdigits0  pylongshift  int00tdigits0$^                        $^                    $^                    break$^            $^endif$^            if sizeofint00t  sizeoflong $^                pyxverifyreturnintexcint00t long pylongaslongx$^ifdef havelonglong$^             else if sizeofint00t  sizeofpylonglong $^                pyxverifyreturnintexcint00t pylonglong pylongaslonglongx$^endif$^            $^        $^        $^if cythoncompilinginpypy  definedpylongasbytearray$^            pyerrsetstringpyexcruntimeerror$^                            pylongasbytearray not available in pypy cannot convert large numbers$^else$^            int00t val$^            pyobject v  pyxpynumberintorlongx$^ if pymajorversion  0$^            if likelyv  pylongcheckv $^                pyobject tmp  v$^                v  pynumberlongtmp$^                pydecreftmp$^            $^ endif$^            if likelyv $^                int one  0 int islittle  intunsigned char one$^                unsigned char bytes  unsigned char val$^                int ret  pylongasbytearraypylongobject v$^                                              bytes sizeofval$^                                              islittle isunsigned$^                pydecrefv$^                if likelyret$^                    return val$^            $^endif$^            return int00t 0$^        $^     else $^        int00t val$^        pyobject tmp  pyxpynumberintorlongx$^        if tmp return int00t 0$^        val  pyxpyintasint00ttmp$^        pydecreftmp$^        return val$^    $^raiseoverflow$^    pyerrsetstringpyexcoverflowerror$^        value too large to convert to int00t$^    return int00t 0$^raisenegoverflow$^    pyerrsetstringpyexcoverflowerror$^        cant convert negative value to int00t$^    return int00t 0$^$^$^ cintfrompy $^              static cythoninline uint00t pyxpyintasuint00tpyobject x $^    const uint00t negone  uint00t 0 constzero  uint00t 0$^    const int isunsigned  negone  constzero$^if pymajorversion  0$^    if likelypyintcheckx $^        if sizeofuint00t  sizeoflong $^            pyxverifyreturnintuint00t long pyintaslongx$^         else $^            long val  pyintaslongx$^            if isunsigned  unlikelyval  0 $^                goto raisenegoverflow$^            $^            return uint00t val$^        $^     else$^endif$^    if likelypylongcheckx $^        if isunsigned $^if cythonusepylonginternals$^            const digit digits  pylongobjectxobdigit$^            switch pysizex $^                case  0 return uint00t 0$^                case  0 pyxverifyreturnintuint00t digit digits0$^                case 0$^                    if 0  sizeofuint00t  0  pylongshift $^                        if 0  sizeofunsigned long  0  pylongshift $^                            pyxverifyreturnintuint00t unsigned long unsigned longdigits0  pylongshift  unsigned longdigits0$^                         else if 0  sizeofuint00t  0  pylongshift $^                            return uint00t uint00tdigits0  pylongshift  uint00tdigits0$^                        $^                    $^                    break$^                case 0$^                    if 0  sizeofuint00t  0  pylongshift $^                        if 0  sizeofunsigned long  0  pylongshift $^                            pyxverifyreturnintuint00t unsigned long unsigned longdigits0  pylongshift  unsigned longdigits0  pylongshift  unsigned longdigits0$^                         else if 0  sizeofuint00t  0  pylongshift $^                            return uint00t uint00tdigits0  pylongshift  uint00tdigits0  pylongshift  uint00tdigits0$^                        $^                    $^                    break$^                case 0$^                    if 0  sizeofuint00t  0  pylongshift $^                        if 0  sizeofunsigned long  0  pylongshift $^                            pyxverifyreturnintuint00t unsigned long unsigned longdigits0  pylongshift  unsigned longdigits0  pylongshift  unsigned longdigits0  pylongshift  unsigned longdigits0$^                         else if 0  sizeofuint00t  0  pylongshift $^                            return uint00t uint00tdigits0  pylongshift  uint00tdigits0  pylongshift  uint00tdigits0  pylongshift  uint00tdigits0$^                        $^                    $^                    break$^            $^endif$^if cythoncompilingincpython$^            if unlikelypysizex  0 $^                goto raisenegoverflow$^            $^else$^            $^                int result  pyobjectrichcompareboolx pyfalse pylt$^                if unlikelyresult  0$^                    return uint00t 0$^                if unlikelyresult  0$^                    goto raisenegoverflow$^            $^endif$^            if sizeofuint00t  sizeofunsigned long $^                pyxverifyreturnintexcuint00t unsigned long pylongasunsignedlongx$^ifdef havelonglong$^             else if sizeofuint00t  sizeofunsigned pylonglong $^                pyxverifyreturnintexcuint00t unsigned pylonglong pylongasunsignedlonglongx$^endif$^            $^         else $^if cythonusepylonginternals$^            const digit digits  pylongobjectxobdigit$^            switch pysizex $^                case  0 return uint00t 0$^                case 0 pyxverifyreturnintuint00t sdigit sdigit sdigitdigits0$^                case  0 pyxverifyreturnintuint00t  digit digits0$^                case 0$^                    if 0  sizeofuint00t  0  0  pylongshift $^                        if 0  sizeofunsigned long  0  pylongshift $^                            pyxverifyreturnintuint00t long long unsigned longdigits0  pylongshift  unsigned longdigits0$^                         else if 0  sizeofuint00t  0  0  pylongshift $^                            return uint00t uint00t0uint00tdigits0  pylongshift  uint00tdigits0$^                        $^                    $^                    break$^                case 0$^                    if 0  sizeofuint00t  0  pylongshift $^                        if 0  sizeofunsigned long  0  pylongshift $^                            pyxverifyreturnintuint00t unsigned long unsigned longdigits0  pylongshift  unsigned longdigits0$^                         else if 0  sizeofuint00t  0  0  pylongshift $^                            return uint00t uint00tdigits0  pylongshift  uint00tdigits0$^                        $^                    $^                    break$^                case 0$^                    if 0  sizeofuint00t  0  0  pylongshift $^                        if 0  sizeofunsigned long  0  pylongshift $^                            pyxverifyreturnintuint00t long long unsigned longdigits0  pylongshift  unsigned longdigits0  pylongshift  unsigned longdigits0$^                         else if 0  sizeofuint00t  0  0  pylongshift $^                            return uint00t uint00t0uint00tdigits0  pylongshift  uint00tdigits0  pylongshift  uint00tdigits0$^                        $^                    $^                    break$^                case 0$^                    if 0  sizeofuint00t  0  pylongshift $^                        if 0  sizeofunsigned long  0  pylongshift $^                            pyxverifyreturnintuint00t unsigned long unsigned longdigits0  pylongshift  unsigned longdigits0  pylongshift  unsigned longdigits0$^                         else if 0  sizeofuint00t  0  0  pylongshift $^                            return uint00t uint00tdigits0  pylongshift  uint00tdigits0  pylongshift  uint00tdigits0$^                        $^                    $^                    break$^                case 0$^                    if 0  sizeofuint00t  0  0  pylongshift $^                        if 0  sizeofunsigned long  0  pylongshift $^                            pyxverifyreturnintuint00t long long unsigned longdigits0  pylongshift  unsigned longdigits0  pylongshift  unsigned longdigits0  pylongshift  unsigned longdigits0$^                         else if 0  sizeofuint00t  0  0  pylongshift $^                            return uint00t uint00t0uint00tdigits0  pylongshift  uint00tdigits0  pylongshift  uint00tdigits0  pylongshift  uint00tdigits0$^                        $^                    $^                    break$^                case 0$^                    if 0  sizeofuint00t  0  pylongshift $^                        if 0  sizeofunsigned long  0  pylongshift $^                            pyxverifyreturnintuint00t unsigned long unsigned longdigits0  pylongshift  unsigned longdigits0  pylongshift  unsigned longdigits0  pylongshift  unsigned longdigits0$^                         else if 0  sizeofuint00t  0  0  pylongshift $^                            return uint00t uint00tdigits0  pylongshift  uint00tdigits0  pylongshift  uint00tdigits0  pylongshift  uint00tdigits0$^                        $^                    $^                    break$^            $^endif$^            if sizeofuint00t  sizeoflong $^                pyxverifyreturnintexcuint00t long pylongaslongx$^ifdef havelonglong$^             else if sizeofuint00t  sizeofpylonglong $^                pyxverifyreturnintexcuint00t pylonglong pylongaslonglongx$^endif$^            $^        $^        $^if cythoncompilinginpypy  definedpylongasbytearray$^            pyerrsetstringpyexcruntimeerror$^                            pylongasbytearray not available in pypy cannot convert large numbers$^else$^            uint00t val$^            pyobject v  pyxpynumberintorlongx$^ if pymajorversion  0$^            if likelyv  pylongcheckv $^                pyobject tmp  v$^                v  pynumberlongtmp$^                pydecreftmp$^            $^ endif$^            if likelyv $^                int one  0 int islittle  intunsigned char one$^                unsigned char bytes  unsigned char val$^                int ret  pylongasbytearraypylongobject v$^                                              bytes sizeofval$^                                              islittle isunsigned$^                pydecrefv$^                if likelyret$^                    return val$^            $^endif$^            return uint00t 0$^        $^     else $^        uint00t val$^        pyobject tmp  pyxpynumberintorlongx$^        if tmp return uint00t 0$^        val  pyxpyintasuint00ttmp$^        pydecreftmp$^        return val$^    $^raiseoverflow$^    pyerrsetstringpyexcoverflowerror$^        value too large to convert to uint00t$^    return uint00t 0$^raisenegoverflow$^    pyerrsetstringpyexcoverflowerror$^        cant convert negative value to uint00t$^    return uint00t 0$^$^$^ cintfrompy $^              static cythoninline int00t pyxpyintasint00tpyobject x $^    const int00t negone  int00t 0 constzero  int00t 0$^    const int isunsigned  negone  constzero$^if pymajorversion  0$^    if likelypyintcheckx $^        if sizeofint00t  sizeoflong $^            pyxverifyreturnintint00t long pyintaslongx$^         else $^            long val  pyintaslongx$^            if isunsigned  unlikelyval  0 $^                goto raisenegoverflow$^            $^            return int00t val$^        $^     else$^endif$^    if likelypylongcheckx $^        if isunsigned $^if cythonusepylonginternals$^            const digit digits  pylongobjectxobdigit$^            switch pysizex $^                case  0 return int00t 0$^                case  0 pyxverifyreturnintint00t digit digits0$^                case 0$^                    if 0  sizeofint00t  0  pylongshift $^                        if 0  sizeofunsigned long  0  pylongshift $^                            pyxverifyreturnintint00t unsigned long unsigned longdigits0  pylongshift  unsigned longdigits0$^                         else if 0  sizeofint00t  0  pylongshift $^                            return int00t int00tdigits0  pylongshift  int00tdigits0$^                        $^                    $^                    break$^                case 0$^                    if 0  sizeofint00t  0  pylongshift $^                        if 0  sizeofunsigned long  0  pylongshift $^                            pyxverifyreturnintint00t unsigned long unsigned longdigits0  pylongshift  unsigned longdigits0  pylongshift  unsigned longdigits0$^                         else if 0  sizeofint00t  0  pylongshift $^                            return int00t int00tdigits0  pylongshift  int00tdigits0  pylongshift  int00tdigits0$^                        $^                    $^                    break$^                case 0$^                    if 0  sizeofint00t  0  pylongshift $^                        if 0  sizeofunsigned long  0  pylongshift $^                            pyxverifyreturnintint00t unsigned long unsigned longdigits0  pylongshift  unsigned longdigits0  pylongshift  unsigned longdigits0  pylongshift  unsigned longdigits0$^                         else if 0  sizeofint00t  0  pylongshift $^                            return int00t int00tdigits0  pylongshift  int00tdigits0  pylongshift  int00tdigits0  pylongshift  int00tdigits0$^                        $^                    $^                    break$^            $^endif$^if cythoncompilingincpython$^            if unlikelypysizex  0 $^                goto raisenegoverflow$^            $^else$^            $^                int result  pyobjectrichcompareboolx pyfalse pylt$^                if unlikelyresult  0$^                    return int00t 0$^                if unlikelyresult  0$^                    goto raisenegoverflow$^            $^endif$^            if sizeofint00t  sizeofunsigned long $^                pyxverifyreturnintexcint00t unsigned long pylongasunsignedlongx$^ifdef havelonglong$^             else if sizeofint00t  sizeofunsigned pylonglong $^                pyxverifyreturnintexcint00t unsigned pylonglong pylongasunsignedlonglongx$^endif$^            $^         else $^if cythonusepylonginternals$^            const digit digits  pylongobjectxobdigit$^            switch pysizex $^                case  0 return int00t 0$^                case 0 pyxverifyreturnintint00t sdigit sdigit sdigitdigits0$^                case  0 pyxverifyreturnintint00t  digit digits0$^                case 0$^                    if 0  sizeofint00t  0  0  pylongshift $^                        if 0  sizeofunsigned long  0  pylongshift $^                            pyxverifyreturnintint00t long long unsigned longdigits0  pylongshift  unsigned longdigits0$^                         else if 0  sizeofint00t  0  0  pylongshift $^                            return int00t int00t0int00tdigits0  pylongshift  int00tdigits0$^                        $^                    $^                    break$^                case 0$^                    if 0  sizeofint00t  0  pylongshift $^                        if 0  sizeofunsigned long  0  pylongshift $^                            pyxverifyreturnintint00t unsigned long unsigned longdigits0  pylongshift  unsigned longdigits0$^                         else if 0  sizeofint00t  0  0  pylongshift $^                            return int00t int00tdigits0  pylongshift  int00tdigits0$^                        $^                    $^                    break$^                case 0$^                    if 0  sizeofint00t  0  0  pylongshift $^                        if 0  sizeofunsigned long  0  pylongshift $^                            pyxverifyreturnintint00t long long unsigned longdigits0  pylongshift  unsigned longdigits0  pylongshift  unsigned longdigits0$^                         else if 0  sizeofint00t  0  0  pylongshift $^                            return int00t int00t0int00tdigits0  pylongshift  int00tdigits0  pylongshift  int00tdigits0$^                        $^                    $^                    break$^                case 0$^                    if 0  sizeofint00t  0  pylongshift $^                        if 0  sizeofunsigned long  0  pylongshift $^                            pyxverifyreturnintint00t unsigned long unsigned longdigits0  pylongshift  unsigned longdigits0  pylongshift  unsigned longdigits0$^                         else if 0  sizeofint00t  0  0  pylongshift $^                            return int00t int00tdigits0  pylongshift  int00tdigits0  pylongshift  int00tdigits0$^                        $^                    $^                    break$^                case 0$^                    if 0  sizeofint00t  0  0  pylongshift $^                        if 0  sizeofunsigned long  0  pylongshift $^                            pyxverifyreturnintint00t long long unsigned longdigits0  pylongshift  unsigned longdigits0  pylongshift  unsigned longdigits0  pylongshift  unsigned longdigits0$^                         else if 0  sizeofint00t  0  0  pylongshift $^                            return int00t int00t0int00tdigits0  pylongshift  int00tdigits0  pylongshift  int00tdigits0  pylongshift  int00tdigits0$^                        $^                    $^                    break$^                case 0$^                    if 0  sizeofint00t  0  pylongshift $^                        if 0  sizeofunsigned long  0  pylongshift $^                            pyxverifyreturnintint00t unsigned long unsigned longdigits0  pylongshift  unsigned longdigits0  pylongshift  unsigned longdigits0  pylongshift  unsigned longdigits0$^                         else if 0  sizeofint00t  0  0  pylongshift $^                            return int00t int00tdigits0  pylongshift  int00tdigits0  pylongshift  int00tdigits0  pylongshift  int00tdigits0$^                        $^                    $^                    break$^            $^endif$^            if sizeofint00t  sizeoflong $^                pyxverifyreturnintexcint00t long pylongaslongx$^ifdef havelonglong$^             else if sizeofint00t  sizeofpylonglong $^                pyxverifyreturnintexcint00t pylonglong pylongaslonglongx$^endif$^            $^        $^        $^if cythoncompilinginpypy  definedpylongasbytearray$^            pyerrsetstringpyexcruntimeerror$^                            pylongasbytearray not available in pypy cannot convert large numbers$^else$^            int00t val$^            pyobject v  pyxpynumberintorlongx$^ if pymajorversion  0$^            if likelyv  pylongcheckv $^                pyobject tmp  v$^                v  pynumberlongtmp$^                pydecreftmp$^            $^ endif$^            if likelyv $^                int one  0 int islittle  intunsigned char one$^                unsigned char bytes  unsigned char val$^                int ret  pylongasbytearraypylongobject v$^                                              bytes sizeofval$^                                              islittle isunsigned$^                pydecrefv$^                if likelyret$^                    return val$^            $^endif$^            return int00t 0$^        $^     else $^        int00t val$^        pyobject tmp  pyxpynumberintorlongx$^        if tmp return int00t 0$^        val  pyxpyintasint00ttmp$^        pydecreftmp$^        return val$^    $^raiseoverflow$^    pyerrsetstringpyexcoverflowerror$^        value too large to convert to int00t$^    return int00t 0$^raisenegoverflow$^    pyerrsetstringpyexcoverflowerror$^        cant convert negative value to int00t$^    return int00t 0$^$^$^ cintfrompy $^              static cythoninline uint00t pyxpyintasuint00tpyobject x $^    const uint00t negone  uint00t 0 constzero  uint00t 0$^    const int isunsigned  negone  constzero$^if pymajorversion  0$^    if likelypyintcheckx $^        if sizeofuint00t  sizeoflong $^            pyxverifyreturnintuint00t long pyintaslongx$^         else $^            long val  pyintaslongx$^            if isunsigned  unlikelyval  0 $^                goto raisenegoverflow$^            $^            return uint00t val$^        $^     else$^endif$^    if likelypylongcheckx $^        if isunsigned $^if cythonusepylonginternals$^            const digit digits  pylongobjectxobdigit$^            switch pysizex $^                case  0 return uint00t 0$^                case  0 pyxverifyreturnintuint00t digit digits0$^                case 0$^                    if 0  sizeofuint00t  0  pylongshift $^                        if 0  sizeofunsigned long  0  pylongshift $^                            pyxverifyreturnintuint00t unsigned long unsigned longdigits0  pylongshift  unsigned longdigits0$^                         else if 0  sizeofuint00t  0  pylongshift $^                            return uint00t uint00tdigits0  pylongshift  uint00tdigits0$^                        $^                    $^                    break$^                case 0$^                    if 0  sizeofuint00t  0  pylongshift $^                        if 0  sizeofunsigned long  0  pylongshift $^                            pyxverifyreturnintuint00t unsigned long unsigned longdigits0  pylongshift  unsigned longdigits0  pylongshift  unsigned longdigits0$^                         else if 0  sizeofuint00t  0  pylongshift $^                            return uint00t uint00tdigits0  pylongshift  uint00tdigits0  pylongshift  uint00tdigits0$^                        $^                    $^                    break$^                case 0$^                    if 0  sizeofuint00t  0  pylongshift $^                        if 0  sizeofunsigned long  0  pylongshift $^                            pyxverifyreturnintuint00t unsigned long unsigned longdigits0  pylongshift  unsigned longdigits0  pylongshift  unsigned longdigits0  pylongshift  unsigned longdigits0$^                         else if 0  sizeofuint00t  0  pylongshift $^                            return uint00t uint00tdigits0  pylongshift  uint00tdigits0  pylongshift  uint00tdigits0  pylongshift  uint00tdigits0$^                        $^                    $^                    break$^            $^endif$^if cythoncompilingincpython$^            if unlikelypysizex  0 $^                goto raisenegoverflow$^            $^else$^            $^                int result  pyobjectrichcompareboolx pyfalse pylt$^                if unlikelyresult  0$^                    return uint00t 0$^                if unlikelyresult  0$^                    goto raisenegoverflow$^            $^endif$^            if sizeofuint00t  sizeofunsigned long $^                pyxverifyreturnintexcuint00t unsigned long pylongasunsignedlongx$^ifdef havelonglong$^             else if sizeofuint00t  sizeofunsigned pylonglong $^                pyxverifyreturnintexcuint00t unsigned pylonglong pylongasunsignedlonglongx$^endif$^            $^         else $^if cythonusepylonginternals$^            const digit digits  pylongobjectxobdigit$^            switch pysizex $^                case  0 return uint00t 0$^                case 0 pyxverifyreturnintuint00t sdigit sdigit sdigitdigits0$^                case  0 pyxverifyreturnintuint00t  digit digits0$^                case 0$^                    if 0  sizeofuint00t  0  0  pylongshift $^                        if 0  sizeofunsigned long  0  pylongshift $^                            pyxverifyreturnintuint00t long long unsigned longdigits0  pylongshift  unsigned longdigits0$^                         else if 0  sizeofuint00t  0  0  pylongshift $^                            return uint00t uint00t0uint00tdigits0  pylongshift  uint00tdigits0$^                        $^                    $^                    break$^                case 0$^                    if 0  sizeofuint00t  0  pylongshift $^                        if 0  sizeofunsigned long  0  pylongshift $^                            pyxverifyreturnintuint00t unsigned long unsigned longdigits0  pylongshift  unsigned longdigits0$^                         else if 0  sizeofuint00t  0  0  pylongshift $^                            return uint00t uint00tdigits0  pylongshift  uint00tdigits0$^                        $^                    $^                    break$^                case 0$^                    if 0  sizeofuint00t  0  0  pylongshift $^                        if 0  sizeofunsigned long  0  pylongshift $^                            pyxverifyreturnintuint00t long long unsigned longdigits0  pylongshift  unsigned longdigits0  pylongshift  unsigned longdigits0$^                         else if 0  sizeofuint00t  0  0  pylongshift $^                            return uint00t uint00t0uint00tdigits0  pylongshift  uint00tdigits0  pylongshift  uint00tdigits0$^                        $^                    $^                    break$^                case 0$^                    if 0  sizeofuint00t  0  pylongshift $^                        if 0  sizeofunsigned long  0  pylongshift $^                            pyxverifyreturnintuint00t unsigned long unsigned longdigits0  pylongshift  unsigned longdigits0  pylongshift  unsigned longdigits0$^                         else if 0  sizeofuint00t  0  0  pylongshift $^                            return uint00t uint00tdigits0  pylongshift  uint00tdigits0  pylongshift  uint00tdigits0$^                        $^                    $^                    break$^                case 0$^                    if 0  sizeofuint00t  0  0  pylongshift $^                        if 0  sizeofunsigned long  0  pylongshift $^                            pyxverifyreturnintuint00t long long unsigned longdigits0  pylongshift  unsigned longdigits0  pylongshift  unsigned longdigits0  pylongshift  unsigned longdigits0$^                         else if 0  sizeofuint00t  0  0  pylongshift $^                            return uint00t uint00t0uint00tdigits0  pylongshift  uint00tdigits0  pylongshift  uint00tdigits0  pylongshift  uint00tdigits0$^                        $^                    $^                    break$^                case 0$^                    if 0  sizeofuint00t  0  pylongshift $^                        if 0  sizeofunsigned long  0  pylongshift $^                            pyxverifyreturnintuint00t unsigned long unsigned longdigits0  pylongshift  unsigned longdigits0  pylongshift  unsigned longdigits0  pylongshift  unsigned longdigits0$^                         else if 0  sizeofuint00t  0  0  pylongshift $^                            return uint00t uint00tdigits0  pylongshift  uint00tdigits0  pylongshift  uint00tdigits0  pylongshift  uint00tdigits0$^                        $^                    $^                    break$^            $^endif$^            if sizeofuint00t  sizeoflong $^                pyxverifyreturnintexcuint00t long pylongaslongx$^ifdef havelonglong$^             else if sizeofuint00t  sizeofpylonglong $^                pyxverifyreturnintexcuint00t pylonglong pylongaslonglongx$^endif$^            $^        $^        $^if cythoncompilinginpypy  definedpylongasbytearray$^            pyerrsetstringpyexcruntimeerror$^                            pylongasbytearray not available in pypy cannot convert large numbers$^else$^            uint00t val$^            pyobject v  pyxpynumberintorlongx$^ if pymajorversion  0$^            if likelyv  pylongcheckv $^                pyobject tmp  v$^                v  pynumberlongtmp$^                pydecreftmp$^            $^ endif$^            if likelyv $^                int one  0 int islittle  intunsigned char one$^                unsigned char bytes  unsigned char val$^                int ret  pylongasbytearraypylongobject v$^                                              bytes sizeofval$^                                              islittle isunsigned$^                pydecrefv$^                if likelyret$^                    return val$^            $^endif$^            return uint00t 0$^        $^     else $^        uint00t val$^        pyobject tmp  pyxpynumberintorlongx$^        if tmp return uint00t 0$^        val  pyxpyintasuint00ttmp$^        pydecreftmp$^        return val$^    $^raiseoverflow$^    pyerrsetstringpyexcoverflowerror$^        value too large to convert to uint00t$^    return uint00t 0$^raisenegoverflow$^    pyerrsetstringpyexcoverflowerror$^        cant convert negative value to uint00t$^    return uint00t 0$^$^$^ cintfrompy $^              static cythoninline timet pyxpyintastimetpyobject x $^    const timet negone  timet 0 constzero  timet 0$^    const int isunsigned  negone  constzero$^if pymajorversion  0$^    if likelypyintcheckx $^        if sizeoftimet  sizeoflong $^            pyxverifyreturninttimet long pyintaslongx$^         else $^            long val  pyintaslongx$^            if isunsigned  unlikelyval  0 $^                goto raisenegoverflow$^            $^            return timet val$^        $^     else$^endif$^    if likelypylongcheckx $^        if isunsigned $^if cythonusepylonginternals$^            const digit digits  pylongobjectxobdigit$^            switch pysizex $^                case  0 return timet 0$^                case  0 pyxverifyreturninttimet digit digits0$^                case 0$^                    if 0  sizeoftimet  0  pylongshift $^                        if 0  sizeofunsigned long  0  pylongshift $^                            pyxverifyreturninttimet unsigned long unsigned longdigits0  pylongshift  unsigned longdigits0$^                         else if 0  sizeoftimet  0  pylongshift $^                            return timet timetdigits0  pylongshift  timetdigits0$^                        $^                    $^                    break$^                case 0$^                    if 0  sizeoftimet  0  pylongshift $^                        if 0  sizeofunsigned long  0  pylongshift $^                            pyxverifyreturninttimet unsigned long unsigned longdigits0  pylongshift  unsigned longdigits0  pylongshift  unsigned longdigits0$^                         else if 0  sizeoftimet  0  pylongshift $^                            return timet timetdigits0  pylongshift  timetdigits0  pylongshift  timetdigits0$^                        $^                    $^                    break$^                case 0$^                    if 0  sizeoftimet  0  pylongshift $^                        if 0  sizeofunsigned long  0  pylongshift $^                            pyxverifyreturninttimet unsigned long unsigned longdigits0  pylongshift  unsigned longdigits0  pylongshift  unsigned longdigits0  pylongshift  unsigned longdigits0$^                         else if 0  sizeoftimet  0  pylongshift $^                            return timet timetdigits0  pylongshift  timetdigits0  pylongshift  timetdigits0  pylongshift  timetdigits0$^                        $^                    $^                    break$^            $^endif$^if cythoncompilingincpython$^            if unlikelypysizex  0 $^                goto raisenegoverflow$^            $^else$^            $^                int result  pyobjectrichcompareboolx pyfalse pylt$^                if unlikelyresult  0$^                    return timet 0$^                if unlikelyresult  0$^                    goto raisenegoverflow$^            $^endif$^            if sizeoftimet  sizeofunsigned long $^                pyxverifyreturnintexctimet unsigned long pylongasunsignedlongx$^ifdef havelonglong$^             else if sizeoftimet  sizeofunsigned pylonglong $^                pyxverifyreturnintexctimet unsigned pylonglong pylongasunsignedlonglongx$^endif$^            $^         else $^if cythonusepylonginternals$^            const digit digits  pylongobjectxobdigit$^            switch pysizex $^                case  0 return timet 0$^                case 0 pyxverifyreturninttimet sdigit sdigit sdigitdigits0$^                case  0 pyxverifyreturninttimet  digit digits0$^                case 0$^                    if 0  sizeoftimet  0  0  pylongshift $^                        if 0  sizeofunsigned long  0  pylongshift $^                            pyxverifyreturninttimet long long unsigned longdigits0  pylongshift  unsigned longdigits0$^                         else if 0  sizeoftimet  0  0  pylongshift $^                            return timet timet0timetdigits0  pylongshift  timetdigits0$^                        $^                    $^                    break$^                case 0$^                    if 0  sizeoftimet  0  pylongshift $^                        if 0  sizeofunsigned long  0  pylongshift $^                            pyxverifyreturninttimet unsigned long unsigned longdigits0  pylongshift  unsigned longdigits0$^                         else if 0  sizeoftimet  0  0  pylongshift $^                            return timet timetdigits0  pylongshift  timetdigits0$^                        $^                    $^                    break$^                case 0$^                    if 0  sizeoftimet  0  0  pylongshift $^                        if 0  sizeofunsigned long  0  pylongshift $^                            pyxverifyreturninttimet long long unsigned longdigits0  pylongshift  unsigned longdigits0  pylongshift  unsigned longdigits0$^                         else if 0  sizeoftimet  0  0  pylongshift $^                            return timet timet0timetdigits0  pylongshift  timetdigits0  pylongshift  timetdigits0$^                        $^                    $^                    break$^                case 0$^                    if 0  sizeoftimet  0  pylongshift $^                        if 0  sizeofunsigned long  0  pylongshift $^                            pyxverifyreturninttimet unsigned long unsigned longdigits0  pylongshift  unsigned longdigits0  pylongshift  unsigned longdigits0$^                         else if 0  sizeoftimet  0  0  pylongshift $^                            return timet timetdigits0  pylongshift  timetdigits0  pylongshift  timetdigits0$^                        $^                    $^                    break$^                case 0$^                    if 0  sizeoftimet  0  0  pylongshift $^                        if 0  sizeofunsigned long  0  pylongshift $^                            pyxverifyreturninttimet long long unsigned longdigits0  pylongshift  unsigned longdigits0  pylongshift  unsigned longdigits0  pylongshift  unsigned longdigits0$^                         else if 0  sizeoftimet  0  0  pylongshift $^                            return timet timet0timetdigits0  pylongshift  timetdigits0  pylongshift  timetdigits0  pylongshift  timetdigits0$^                        $^                    $^                    break$^                case 0$^                    if 0  sizeoftimet  0  pylongshift $^                        if 0  sizeofunsigned long  0  pylongshift $^                            pyxverifyreturninttimet unsigned long unsigned longdigits0  pylongshift  unsigned longdigits0  pylongshift  unsigned longdigits0  pylongshift  unsigned longdigits0$^                         else if 0  sizeoftimet  0  0  pylongshift $^                            return timet timetdigits0  pylongshift  timetdigits0  pylongshift  timetdigits0  pylongshift  timetdigits0$^                        $^                    $^                    break$^            $^endif$^            if sizeoftimet  sizeoflong $^                pyxverifyreturnintexctimet long pylongaslongx$^ifdef havelonglong$^             else if sizeoftimet  sizeofpylonglong $^                pyxverifyreturnintexctimet pylonglong pylongaslonglongx$^endif$^            $^        $^        $^if cythoncompilinginpypy  definedpylongasbytearray$^            pyerrsetstringpyexcruntimeerror$^                            pylongasbytearray not available in pypy cannot convert large numbers$^else$^            timet val$^            pyobject v  pyxpynumberintorlongx$^ if pymajorversion  0$^            if likelyv  pylongcheckv $^                pyobject tmp  v$^                v  pynumberlongtmp$^                pydecreftmp$^            $^ endif$^            if likelyv $^                int one  0 int islittle  intunsigned char one$^                unsigned char bytes  unsigned char val$^                int ret  pylongasbytearraypylongobject v$^                                              bytes sizeofval$^                                              islittle isunsigned$^                pydecrefv$^                if likelyret$^                    return val$^            $^endif$^            return timet 0$^        $^     else $^        timet val$^        pyobject tmp  pyxpynumberintorlongx$^        if tmp return timet 0$^        val  pyxpyintastimettmp$^        pydecreftmp$^        return val$^    $^raiseoverflow$^    pyerrsetstringpyexcoverflowerror$^        value too large to convert to timet$^    return timet 0$^raisenegoverflow$^    pyerrsetstringpyexcoverflowerror$^        cant convert negative value to timet$^    return timet 0$^$^$^ cinttopy $^              static cythoninline pyobject pyxpyintfromlonglong value $^    const long negone  long 0 constzero  long 0$^    const int isunsigned  negone  constzero$^    if isunsigned $^        if sizeoflong  sizeoflong $^            return pyintfromlonglong value$^         else if sizeoflong  sizeofunsigned long $^            return pylongfromunsignedlongunsigned long value$^ifdef havelonglong$^         else if sizeoflong  sizeofunsigned pylonglong $^            return pylongfromunsignedlonglongunsigned pylonglong value$^endif$^        $^     else $^        if sizeoflong  sizeoflong $^            return pyintfromlonglong value$^ifdef havelonglong$^         else if sizeoflong  sizeofpylonglong $^            return pylongfromlonglongpylonglong value$^endif$^        $^    $^    $^        int one  0 int little  intunsigned char one$^        unsigned char bytes  unsigned char value$^        return pylongfrombytearraybytes sizeoflong$^                                     little isunsigned$^    $^$^$^ cintfrompy $^              static cythoninline long pyxpyintaslongpyobject x $^    const long negone  long 0 constzero  long 0$^    const int isunsigned  negone  constzero$^if pymajorversion  0$^    if likelypyintcheckx $^        if sizeoflong  sizeoflong $^            pyxverifyreturnintlong long pyintaslongx$^         else $^            long val  pyintaslongx$^            if isunsigned  unlikelyval  0 $^                goto raisenegoverflow$^            $^            return long val$^        $^     else$^endif$^    if likelypylongcheckx $^        if isunsigned $^if cythonusepylonginternals$^            const digit digits  pylongobjectxobdigit$^            switch pysizex $^                case  0 return long 0$^                case  0 pyxverifyreturnintlong digit digits0$^                case 0$^                    if 0  sizeoflong  0  pylongshift $^                        if 0  sizeofunsigned long  0  pylongshift $^                            pyxverifyreturnintlong unsigned long unsigned longdigits0  pylongshift  unsigned longdigits0$^                         else if 0  sizeoflong  0  pylongshift $^                            return long longdigits0  pylongshift  longdigits0$^                        $^                    $^                    break$^                case 0$^                    if 0  sizeoflong  0  pylongshift $^                        if 0  sizeofunsigned long  0  pylongshift $^                            pyxverifyreturnintlong unsigned long unsigned longdigits0  pylongshift  unsigned longdigits0  pylongshift  unsigned longdigits0$^                         else if 0  sizeoflong  0  pylongshift $^                            return long longdigits0  pylongshift  longdigits0  pylongshift  longdigits0$^                        $^                    $^                    break$^                case 0$^                    if 0  sizeoflong  0  pylongshift $^                        if 0  sizeofunsigned long  0  pylongshift $^                            pyxverifyreturnintlong unsigned long unsigned longdigits0  pylongshift  unsigned longdigits0  pylongshift  unsigned longdigits0  pylongshift  unsigned longdigits0$^                         else if 0  sizeoflong  0  pylongshift $^                            return long longdigits0  pylongshift  longdigits0  pylongshift  longdigits0  pylongshift  longdigits0$^                        $^                    $^                    break$^            $^endif$^if cythoncompilingincpython$^            if unlikelypysizex  0 $^                goto raisenegoverflow$^            $^else$^            $^                int result  pyobjectrichcompareboolx pyfalse pylt$^                if unlikelyresult  0$^                    return long 0$^                if unlikelyresult  0$^                    goto raisenegoverflow$^            $^endif$^            if sizeoflong  sizeofunsigned long $^                pyxverifyreturnintexclong unsigned long pylongasunsignedlongx$^ifdef havelonglong$^             else if sizeoflong  sizeofunsigned pylonglong $^                pyxverifyreturnintexclong unsigned pylonglong pylongasunsignedlonglongx$^endif$^            $^         else $^if cythonusepylonginternals$^            const digit digits  pylongobjectxobdigit$^            switch pysizex $^                case  0 return long 0$^                case 0 pyxverifyreturnintlong sdigit sdigit sdigitdigits0$^                case  0 pyxverifyreturnintlong  digit digits0$^                case 0$^                    if 0  sizeoflong  0  0  pylongshift $^                        if 0  sizeofunsigned long  0  pylongshift $^                            pyxverifyreturnintlong long long unsigned longdigits0  pylongshift  unsigned longdigits0$^                         else if 0  sizeoflong  0  0  pylongshift $^                            return long long0longdigits0  pylongshift  longdigits0$^                        $^                    $^                    break$^                case 0$^                    if 0  sizeoflong  0  pylongshift $^                        if 0  sizeofunsigned long  0  pylongshift $^                            pyxverifyreturnintlong unsigned long unsigned longdigits0  pylongshift  unsigned longdigits0$^                         else if 0  sizeoflong  0  0  pylongshift $^                            return long longdigits0  pylongshift  longdigits0$^                        $^                    $^                    break$^                case 0$^                    if 0  sizeoflong  0  0  pylongshift $^                        if 0  sizeofunsigned long  0  pylongshift $^                            pyxverifyreturnintlong long long unsigned longdigits0  pylongshift  unsigned longdigits0  pylongshift  unsigned longdigits0$^                         else if 0  sizeoflong  0  0  pylongshift $^                            return long long0longdigits0  pylongshift  longdigits0  pylongshift  longdigits0$^                        $^                    $^                    break$^                case 0$^                    if 0  sizeoflong  0  pylongshift $^                        if 0  sizeofunsigned long  0  pylongshift $^                            pyxverifyreturnintlong unsigned long unsigned longdigits0  pylongshift  unsigned longdigits0  pylongshift  unsigned longdigits0$^                         else if 0  sizeoflong  0  0  pylongshift $^                            return long longdigits0  pylongshift  longdigits0  pylongshift  longdigits0$^                        $^                    $^                    break$^                case 0$^                    if 0  sizeoflong  0  0  pylongshift $^                        if 0  sizeofunsigned long  0  pylongshift $^                            pyxverifyreturnintlong long long unsigned longdigits0  pylongshift  unsigned longdigits0  pylongshift  unsigned longdigits0  pylongshift  unsigned longdigits0$^                         else if 0  sizeoflong  0  0  pylongshift $^                            return long long0longdigits0  pylongshift  longdigits0  pylongshift  longdigits0  pylongshift  longdigits0$^                        $^                    $^                    break$^                case 0$^                    if 0  sizeoflong  0  pylongshift $^                        if 0  sizeofunsigned long  0  pylongshift $^                            pyxverifyreturnintlong unsigned long unsigned longdigits0  pylongshift  unsigned longdigits0  pylongshift  unsigned longdigits0  pylongshift  unsigned longdigits0$^                         else if 0  sizeoflong  0  0  pylongshift $^                            return long longdigits0  pylongshift  longdigits0  pylongshift  longdigits0  pylongshift  longdigits0$^                        $^                    $^                    break$^            $^endif$^            if sizeoflong  sizeoflong $^                pyxverifyreturnintexclong long pylongaslongx$^ifdef havelonglong$^             else if sizeoflong  sizeofpylonglong $^                pyxverifyreturnintexclong pylonglong pylongaslonglongx$^endif$^            $^        $^        $^if cythoncompilinginpypy  definedpylongasbytearray$^            pyerrsetstringpyexcruntimeerror$^                            pylongasbytearray not available in pypy cannot convert large numbers$^else$^            long val$^            pyobject v  pyxpynumberintorlongx$^ if pymajorversion  0$^            if likelyv  pylongcheckv $^                pyobject tmp  v$^                v  pynumberlongtmp$^                pydecreftmp$^            $^ endif$^            if likelyv $^                int one  0 int islittle  intunsigned char one$^                unsigned char bytes  unsigned char val$^                int ret  pylongasbytearraypylongobject v$^                                              bytes sizeofval$^                                              islittle isunsigned$^                pydecrefv$^                if likelyret$^                    return val$^            $^endif$^            return long 0$^        $^     else $^        long val$^        pyobject tmp  pyxpynumberintorlongx$^        if tmp return long 0$^        val  pyxpyintaslongtmp$^        pydecreftmp$^        return val$^    $^raiseoverflow$^    pyerrsetstringpyexcoverflowerror$^        value too large to convert to long$^    return long 0$^raisenegoverflow$^    pyerrsetstringpyexcoverflowerror$^        cant convert negative value to long$^    return long 0$^$^$^ cintfrompy $^              static cythoninline int pyxpyintasintpyobject x $^    const int negone  int 0 constzero  int 0$^    const int isunsigned  negone  constzero$^if pymajorversion  0$^    if likelypyintcheckx $^        if sizeofint  sizeoflong $^            pyxverifyreturnintint long pyintaslongx$^         else $^            long val  pyintaslongx$^            if isunsigned  unlikelyval  0 $^                goto raisenegoverflow$^            $^            return int val$^        $^     else$^endif$^    if likelypylongcheckx $^        if isunsigned $^if cythonusepylonginternals$^            const digit digits  pylongobjectxobdigit$^            switch pysizex $^                case  0 return int 0$^                case  0 pyxverifyreturnintint digit digits0$^                case 0$^                    if 0  sizeofint  0  pylongshift $^                        if 0  sizeofunsigned long  0  pylongshift $^                            pyxverifyreturnintint unsigned long unsigned longdigits0  pylongshift  unsigned longdigits0$^                         else if 0  sizeofint  0  pylongshift $^                            return int intdigits0  pylongshift  intdigits0$^                        $^                    $^                    break$^                case 0$^                    if 0  sizeofint  0  pylongshift $^                        if 0  sizeofunsigned long  0  pylongshift $^                            pyxverifyreturnintint unsigned long unsigned longdigits0  pylongshift  unsigned longdigits0  pylongshift  unsigned longdigits0$^                         else if 0  sizeofint  0  pylongshift $^                            return int intdigits0  pylongshift  intdigits0  pylongshift  intdigits0$^                        $^                    $^                    break$^                case 0$^                    if 0  sizeofint  0  pylongshift $^                        if 0  sizeofunsigned long  0  pylongshift $^                            pyxverifyreturnintint unsigned long unsigned longdigits0  pylongshift  unsigned longdigits0  pylongshift  unsigned longdigits0  pylongshift  unsigned longdigits0$^                         else if 0  sizeofint  0  pylongshift $^                            return int intdigits0  pylongshift  intdigits0  pylongshift  intdigits0  pylongshift  intdigits0$^                        $^                    $^                    break$^            $^endif$^if cythoncompilingincpython$^            if unlikelypysizex  0 $^                goto raisenegoverflow$^            $^else$^            $^                int result  pyobjectrichcompareboolx pyfalse pylt$^                if unlikelyresult  0$^                    return int 0$^                if unlikelyresult  0$^                    goto raisenegoverflow$^            $^endif$^            if sizeofint  sizeofunsigned long $^                pyxverifyreturnintexcint unsigned long pylongasunsignedlongx$^ifdef havelonglong$^             else if sizeofint  sizeofunsigned pylonglong $^                pyxverifyreturnintexcint unsigned pylonglong pylongasunsignedlonglongx$^endif$^            $^         else $^if cythonusepylonginternals$^            const digit digits  pylongobjectxobdigit$^            switch pysizex $^                case  0 return int 0$^                case 0 pyxverifyreturnintint sdigit sdigit sdigitdigits0$^                case  0 pyxverifyreturnintint  digit digits0$^                case 0$^                    if 0  sizeofint  0  0  pylongshift $^                        if 0  sizeofunsigned long  0  pylongshift $^                            pyxverifyreturnintint long long unsigned longdigits0  pylongshift  unsigned longdigits0$^                         else if 0  sizeofint  0  0  pylongshift $^                            return int int0intdigits0  pylongshift  intdigits0$^                        $^                    $^                    break$^                case 0$^                    if 0  sizeofint  0  pylongshift $^                        if 0  sizeofunsigned long  0  pylongshift $^                            pyxverifyreturnintint unsigned long unsigned longdigits0  pylongshift  unsigned longdigits0$^                         else if 0  sizeofint  0  0  pylongshift $^                            return int intdigits0  pylongshift  intdigits0$^                        $^                    $^                    break$^                case 0$^                    if 0  sizeofint  0  0  pylongshift $^                        if 0  sizeofunsigned long  0  pylongshift $^                            pyxverifyreturnintint long long unsigned longdigits0  pylongshift  unsigned longdigits0  pylongshift  unsigned longdigits0$^                         else if 0  sizeofint  0  0  pylongshift $^                            return int int0intdigits0  pylongshift  intdigits0  pylongshift  intdigits0$^                        $^                    $^                    break$^                case 0$^                    if 0  sizeofint  0  pylongshift $^                        if 0  sizeofunsigned long  0  pylongshift $^                            pyxverifyreturnintint unsigned long unsigned longdigits0  pylongshift  unsigned longdigits0  pylongshift  unsigned longdigits0$^                         else if 0  sizeofint  0  0  pylongshift $^                            return int intdigits0  pylongshift  intdigits0  pylongshift  intdigits0$^                        $^                    $^                    break$^                case 0$^                    if 0  sizeofint  0  0  pylongshift $^                        if 0  sizeofunsigned long  0  pylongshift $^                            pyxverifyreturnintint long long unsigned longdigits0  pylongshift  unsigned longdigits0  pylongshift  unsigned longdigits0  pylongshift  unsigned longdigits0$^                         else if 0  sizeofint  0  0  pylongshift $^                            return int int0intdigits0  pylongshift  intdigits0  pylongshift  intdigits0  pylongshift  intdigits0$^                        $^                    $^                    break$^                case 0$^                    if 0  sizeofint  0  pylongshift $^                        if 0  sizeofunsigned long  0  pylongshift $^                            pyxverifyreturnintint unsigned long unsigned longdigits0  pylongshift  unsigned longdigits0  pylongshift  unsigned longdigits0  pylongshift  unsigned longdigits0$^                         else if 0  sizeofint  0  0  pylongshift $^                            return int intdigits0  pylongshift  intdigits0  pylongshift  intdigits0  pylongshift  intdigits0$^                        $^                    $^                    break$^            $^endif$^            if sizeofint  sizeoflong $^                pyxverifyreturnintexcint long pylongaslongx$^ifdef havelonglong$^             else if sizeofint  sizeofpylonglong $^                pyxverifyreturnintexcint pylonglong pylongaslonglongx$^endif$^            $^        $^        $^if cythoncompilinginpypy  definedpylongasbytearray$^            pyerrsetstringpyexcruntimeerror$^                            pylongasbytearray not available in pypy cannot convert large numbers$^else$^            int val$^            pyobject v  pyxpynumberintorlongx$^ if pymajorversion  0$^            if likelyv  pylongcheckv $^                pyobject tmp  v$^                v  pynumberlongtmp$^                pydecreftmp$^            $^ endif$^            if likelyv $^                int one  0 int islittle  intunsigned char one$^                unsigned char bytes  unsigned char val$^                int ret  pylongasbytearraypylongobject v$^                                              bytes sizeofval$^                                              islittle isunsigned$^                pydecrefv$^                if likelyret$^                    return val$^            $^endif$^            return int 0$^        $^     else $^        int val$^        pyobject tmp  pyxpynumberintorlongx$^        if tmp return int 0$^        val  pyxpyintasinttmp$^        pydecreftmp$^        return val$^    $^raiseoverflow$^    pyerrsetstringpyexcoverflowerror$^        value too large to convert to int$^    return int 0$^raisenegoverflow$^    pyerrsetstringpyexcoverflowerror$^        cant convert negative value to int$^    return int 0$^$^$^ checkbinaryversion $^              static int pyxcheckbinaryversionvoid $^    char ctversion0 rtversion0$^    pyossnprintfctversion 0 d.d pymajorversion pyminorversion$^    pyossnprintfrtversion 0 s pygetversion$^    if ctversion0  rtversion0  ctversion0  rtversion0 $^        char message000$^        pyossnprintfmessage sizeofmessage$^                      compiletime version s of module .000s $^                      does not match runtime version s$^                      ctversion pyxmodulename rtversion$^        return pyerrwarnexnull message 0$^    $^    return 0$^$^$^ functionexport $^              static int pyxexportfunctionconst char name void fvoid const char sig $^    pyobject d  0$^    pyobject cobj  0$^    union $^        void fpvoid$^        void p$^     tmp$^    d  pyobjectgetattrstringpyxm char pyxcapi$^    if d $^        pyerrclear$^        d  pydictnew$^        if d$^            goto bad$^        pyincrefd$^        if pymoduleaddobjectpyxm char pyxcapi d  0$^            goto bad$^    $^    tmp.fp  f$^if pyversionhex  0x00000000$^    cobj  pycapsulenewtmp.p sig 0$^else$^    cobj  pycobjectfromvoidptranddesctmp.p void sig 0$^endif$^    if cobj$^        goto bad$^    if pydictsetitemstringd name cobj  0$^        goto bad$^    pydecrefcobj$^    pydecrefd$^    return 0$^bad$^    pyxdecrefcobj$^    pyxdecrefd$^    return 0$^$^$^ initstrings $^              static int pyxinitstringspyxstringtabentry t $^    while tp $^        if pymajorversion  0$^        if tisunicode $^            tp  pyunicodedecodeutf0ts tn  0 null$^         else if tintern $^            tp  pystringinternfromstringts$^         else $^            tp  pystringfromstringandsizets tn  0$^        $^        else$^        if tisunicode  tisstr $^            if tintern $^                tp  pyunicodeinternfromstringts$^             else if tencoding $^                tp  pyunicodedecodets tn  0 tencoding null$^             else $^                tp  pyunicodefromstringandsizets tn  0$^            $^         else $^            tp  pybytesfromstringandsizets tn  0$^        $^        endif$^        if tp$^            return 0$^        if pyobjecthashtp  0$^            return 0$^        t$^    $^    return 0$^$^$^static cythoninline pyobject pyxpyunicodefromstringconst char cstr $^    return pyxpyunicodefromstringandsizecstr pyssizetstrlencstr$^$^static cythoninline const char pyxpyobjectasstringpyobject o $^    pyssizet ignore$^    return pyxpyobjectasstringandsizeo ignore$^$^if pyxdefaultstringencodingisascii  pyxdefaultstringencodingisdefault$^if cythonpep000enabled$^static const char pyxpyunicodeasstringandsizepyobject o pyssizet length $^    char defencc$^    pyobject defenc  pyunicodeasdefaultencodedstringo null$^    if defenc return null$^    defencc  pybytesasstringdefenc$^if pyxdefaultstringencodingisascii$^    $^        char end  defencc  pybytesgetsizedefenc$^        char c$^        for c  defencc c  end c $^            if unsigned char c  000 $^                pyunicodeasasciistringo$^                return null$^            $^        $^    $^endif$^    length  pybytesgetsizedefenc$^    return defencc$^$^else$^static cythoninline const char pyxpyunicodeasstringandsizepyobject o pyssizet length $^    if unlikelypyxpyunicodereadyo  0 return null$^if pyxdefaultstringencodingisascii$^    if likelypyunicodeisasciio $^        length  pyunicodegetlengtho$^        return pyunicodeasutf0o$^     else $^        pyunicodeasasciistringo$^        return null$^    $^else$^    return pyunicodeasutf0andsizeo length$^endif$^$^endif$^endif$^static cythoninline const char pyxpyobjectasstringandsizepyobject o pyssizet length $^if pyxdefaultstringencodingisascii  pyxdefaultstringencodingisdefault$^    if $^if pymajorversion  0  pyxdefaultstringencodingisascii$^            pyxsysgetdefaultencodingnotascii $^endif$^            pyunicodechecko $^        return pyxpyunicodeasstringandsizeo length$^     else$^endif$^if cythoncompilinginpypy  definedpybytearrayasstring  definedpybytearraygetsize$^    if pybytearraychecko $^        length  pybytearraygetsizeo$^        return pybytearrayasstringo$^     else$^endif$^    $^        char result$^        int r  pybytesasstringandsizeo result length$^        if unlikelyr  0 $^            return null$^         else $^            return result$^        $^    $^$^static cythoninline int pyxpyobjectistruepyobject x $^   int istrue  x  pytrue$^   if istrue  x  pyfalse  x  pynone return istrue$^   else return pyobjectistruex$^$^static pyobject pyxpynumberintorlongwrongresulttypepyobject result const char typename $^if pymajorversion  0$^    if pylongcheckresult $^        if pyerrwarnformatpyexcdeprecationwarning 0$^                int returned nonint type .000s.  $^                the ability to return an instance of a strict subclass of int $^                is deprecated and may be removed in a future version of python.$^                pytyperesulttpname $^            pydecrefresult$^            return null$^        $^        return result$^    $^endif$^    pyerrformatpyexctypeerror$^                 .0s returned non.0s type .000s$^                 typename typename pytyperesulttpname$^    pydecrefresult$^    return null$^$^static cythoninline pyobject pyxpynumberintorlongpyobject x $^if cythonusetypeslots$^  pynumbermethods m$^endif$^  const char name  null$^  pyobject res  null$^if pymajorversion  0$^  if likelypyintcheckx  pylongcheckx$^else$^  if likelypylongcheckx$^endif$^    return pyxnewrefx$^if cythonusetypeslots$^  m  pytypextpasnumber$^  if pymajorversion  0$^  if m  mnbint $^    name  int$^    res  mnbintx$^  $^  else if m  mnblong $^    name  long$^    res  mnblongx$^  $^  else$^  if likelym  mnbint $^    name  int$^    res  mnbintx$^  $^  endif$^else$^  if pybytescheckexactx  pyunicodecheckexactx $^    res  pynumberintx$^  $^endif$^  if likelyres $^if pymajorversion  0$^    if unlikelypyintcheckres  pylongcheckres $^else$^    if unlikelypylongcheckexactres $^endif$^        return pyxpynumberintorlongwrongresulttyperes name$^    $^  $^  else if pyerroccurred $^    pyerrsetstringpyexctypeerror$^                    an integer is required$^  $^  return res$^$^static cythoninline pyssizet pyxpyindexasssizetpyobject b $^  pyssizet ival$^  pyobject x$^if pymajorversion  0$^  if likelypyintcheckexactb $^    if sizeofpyssizet  sizeoflong$^        return pyintaslongb$^    else$^        return pyintasssizetx$^  $^endif$^  if likelypylongcheckexactb $^    if cythonusepylonginternals$^    const digit digits  pylongobjectbobdigit$^    const pyssizet size  pysizeb$^    if likelypyxsstabssize  0 $^        ival  likelysize  digits0  0$^        if size  0 ival  ival$^        return ival$^     else $^      switch size $^         case 0$^           if 0  sizeofpyssizet  0  pylongshift $^             return pyssizet sizetdigits0  pylongshift  sizetdigits0$^           $^           break$^         case 0$^           if 0  sizeofpyssizet  0  pylongshift $^             return pyssizet sizetdigits0  pylongshift  sizetdigits0$^           $^           break$^         case 0$^           if 0  sizeofpyssizet  0  pylongshift $^             return pyssizet sizetdigits0  pylongshift  sizetdigits0  pylongshift  sizetdigits0$^           $^           break$^         case 0$^           if 0  sizeofpyssizet  0  pylongshift $^             return pyssizet sizetdigits0  pylongshift  sizetdigits0  pylongshift  sizetdigits0$^           $^           break$^         case 0$^           if 0  sizeofpyssizet  0  pylongshift $^             return pyssizet sizetdigits0  pylongshift  sizetdigits0  pylongshift  sizetdigits0  pylongshift  sizetdigits0$^           $^           break$^         case 0$^           if 0  sizeofpyssizet  0  pylongshift $^             return pyssizet sizetdigits0  pylongshift  sizetdigits0  pylongshift  sizetdigits0  pylongshift  sizetdigits0$^           $^           break$^      $^    $^    endif$^    return pylongasssizetb$^  $^  x  pynumberindexb$^  if x return 0$^  ival  pyintasssizetx$^  pydecrefx$^  return ival$^$^static cythoninline pyobject  pyxpyboolfromlonglong b $^  return b  pyxnewrefpytrue  pyxnewrefpyfalse$^$^static cythoninline pyobject  pyxpyintfromsizetsizet ival $^    return pyintfromsizetival$^$^$^$^endif  pypythonh $^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstextensionslinearlinearfst.h$^include fstregister.h$^$^using fstlinearclassifierfst$^using fststdarc$^using fstlogarc$^$^registerfstlinearclassifierfst stdarc$^registerfstlinearclassifierfst logarc$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include cctype$^include cstdio$^include set$^$^include fstcompat.h$^include fstflags.h$^include fstextensionslinearlinearscript.h$^include fstarc.h$^include fstream$^include fstscriptscriptimpl.h$^$^definestringdelimiter $^              single nonwhitespace character delimiter inside sequences of $^              feature symbols and output symbols$^definestringemptysymbol empty$^              special symbol that designates an empty sequence$^$^definestringstartsymbol s start of sentence symbol$^definestringendsymbol s end of sentence symbol$^$^defineboolclassifier false$^            treat input model as a classifier instead of a tagger$^$^namespace fst $^namespace script $^$^bool validatedelimiter $^  if flagsdelimiter.size  0  stdisspaceflagsdelimiter0$^    return true$^  return false$^$^$^bool validateemptysymbol $^  bool okay  flagsemptysymbol.empty$^  for sizet i  0 i  flagsemptysymbol.size i $^    char c  flagsemptysymboli$^    if stdisspacec okay  false$^  $^  return okay$^$^$^void linearcompileconst string arctype const string epsilonsymbol$^                   const string unknownsymbol const string vocab$^                   char models int modelslen const string out$^                   const string saveisymbols const string savefsymbols$^                   const string saveosymbols $^  linearcompileargs argsepsilonsymbol unknownsymbol vocab models$^                         modelslen out saveisymbols savefsymbols$^                         saveosymbols$^  applyoperationlinearcompileargslinearcompiletpl arctype args$^$^$^ instantiate templates for common arc types$^registerfstlinearoperationsstdarc$^registerfstlinearoperationslogarc$^$^void splitbywhitespaceconst string str stdvectorstring out $^  outclear$^  stdistringstream strmstr$^  string buf$^  while strm  buf outpushbackbuf$^$^$^int scannumclasseschar models int modelslen $^  stdsetstring preds$^  for int i  0 i  modelslen i $^    stdifstream inmodelsi$^    if in logfatal  failed to open   modelsi$^$^    string line$^    stdgetlinein line$^$^    sizet numline  0$^    while stdgetlinein line $^      numline$^      stdvectorstring fields$^      splitbywhitespaceline fields$^      if fields.size  0$^        logfatal  wrong number of fields in source   modelsi$^                     line   numline$^      preds.insertfields0$^    $^  $^  return preds.size$^$^$^   namespace script$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstextensionslinearlinearscript.h$^$^include fstflags.h$^$^definestringarctype standard output arc type$^$^definestringepsilonsymbol eps epsilon symbol$^definestringunknownsymbol unk unknown word symbol$^$^definestringvocab  path to the vocabulary file$^definestringout  path to the output binary$^$^definestringsaveisymbols  save input symbol table to file$^definestringsavefsymbols  save feature symbol table to file$^definestringsaveosymbols  save output symbol table to file$^$^int mainint argc char argv $^   todowuke more detailed usage$^  stdsetnewhandlerfailednewhandler$^  setflagsargv0 argc argv true$^  fstscriptvalidatedelimiter$^  fstscriptvalidateemptysymbol$^$^  if argc  0 $^    showusage$^    return 0$^  $^$^  fstscriptlinearcompileflagsarctype flagsepsilonsymbol$^                                 flagsunknownsymbol flagsvocab argv  0$^                                 argc  0 flagsout flagssaveisymbols$^                                 flagssavefsymbols flagssaveosymbols$^$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstcompat.h$^include fstextensionslinearlinearfst.h$^include fstextensionslinearloglinearapply.h$^include fstvectorfst.h$^$^include fstflags.h$^include fstlog.h$^$^defineboolnormalize true normalize to get posterior$^$^int mainint argc char argv $^  string usage $^      applies an fst to another fst treating the second as a loglinear $^      model.nn  $^      usage $^  usage  argv0$^  usage   in.fst linear.fst out.fstn$^$^  stdsetnewhandlerfailednewhandler$^  setflagsusage.cstr argc argv true$^  if argc  0  argc  0 $^    showusage$^    return 0$^  $^$^  string inname  strcmpargv0   0  argv0  $^  string linearname  argc  0  strcmpargv0   0  argv0  $^  string outname  argc  0  argv0  $^$^  if inname.empty  linearname.empty $^    logerror  argv0   cant take both inputs from standard input.$^    return 0$^  $^$^  fststdfst ifst0  fststdfstreadinname$^  if ifst0 return 0$^$^  fststdfst ifst0  fststdfstreadlinearname$^  if ifst0 return 0$^$^  fststdvectorfst ofst$^$^  loglinearapplyifst0 ifst0 ofst flagsnormalize$^$^  ofst.writeoutname$^$^  return 0$^$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstextensionslinearlinearfst.h$^include fstregister.h$^$^using fstlineartaggerfst$^using fststdarc$^using fstlogarc$^$^registerfstlineartaggerfst stdarc$^registerfstlineartaggerfst logarc$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^ converts an rtn represented by fsts and nonterminal labels into a pdt.$^$^include cstring$^$^include string$^include vector$^$^include fstflags.h$^$^include fstextensionspdtgetters.h$^include fstextensionspdtpdtscript.h$^include fstutil.h$^include fstvectorfst.h$^$^definestringpdtparentheses  pdt parenthesis label pairs$^definestringpdtparsertype left$^              construction method one of left leftsr$^defineint00startparenlabels fstknolabel$^             index to use for the first inserted parentheses if not $^             specified the next available label beyond the highest output $^             label is used$^definestringleftparenprefix  prefix to attach to symboltable $^              labels for inserted left parentheses$^definestringrightparenprefix  prefix to attach to symboltable $^              labels for inserted right parentheses$^$^void cleanupstdvectorfstscriptlabelfstclasspair pairs $^  for const auto pair  pairs $^    delete pair.second$^  $^  pairsclear$^$^$^int mainint argc char argv $^  namespace s  fstscript$^  using fstscriptfstclass$^  using fstscriptvectorfstclass$^  using fstpdtparsertype$^  using fstwritelabelpairs$^$^  string usage  converts an rtn represented by fsts$^  usage   and nonterminal labels into pdt.nn  usage $^  usage  argv0$^  usage   root.fst rootlabel rule0.fst label0 ... out.fstn$^$^  stdsetnewhandlerfailednewhandler$^  setflagsusage.cstr argc argv true$^  if argc  0 $^    showusage$^    return 0$^  $^$^  const string inname  argv0$^  const string outname  argc  0  0  argvargc  0  $^$^  auto ifst  fstclassreadinname$^  if ifst return 0$^$^  pdtparsertype parsertype$^  if sgetpdtparsertypeflagspdtparsertype parsertype $^    logerror  argv0   unknown pdt parser type $^                flagspdtparsertype$^    delete ifst$^    return 0$^  $^$^  stdvectorslabelfstclasspair pairs$^   note that if the root label is beyond the range of the underlying fsts$^   labels truncation will occur.$^  const auto root  atollargv0$^  pairs.emplacebackroot ifst$^$^  for auto i  0 i  argc  0 i  0 $^    ifst  fstclassreadargvi$^    if ifst $^      cleanuppairs$^      return 0$^    $^     note that if the root label is beyond the range of the underlying fsts$^     labels truncation will occur.$^    const auto label  atollargvi  0$^    pairs.emplacebacklabel ifst$^  $^$^  vectorfstclass ofstifstarctype$^  stdvectorslabelpair parens$^  spdtreplacepairs ofst parens root parsertype$^                flagsstartparenlabels flagsleftparenprefix$^                flagsrightparenprefix$^  cleanuppairs$^$^  if flagspdtparentheses.empty $^    if writelabelpairsflagspdtparentheses parens return 0$^  $^$^  ofst.writeoutname$^$^  return 0$^$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^ prints out various information about a pdt such as number of states arcs$^ and parentheses.$^$^include cstring$^$^include memory$^include string$^include vector$^$^include fstflags.h$^include fstlog.h$^$^include fstextensionspdtpdtscript.h$^include fstutil.h$^$^definestringpdtparentheses  pdt parenthesis label pairs$^$^int mainint argc char argv $^  namespace s  fstscript$^  using fstreadlabelpairs$^  using fstscriptfstclass$^$^  string usage  prints out information about a pdt.nn  usage $^  usage  argv0$^  usage   in.pdtn$^$^  stdsetnewhandlerfailednewhandler$^  setflagsusage.cstr argc argv true$^  if argc  0 $^    showusage$^    return 0$^  $^$^  const string inname $^      argc  0  strcmpargv0   0  argv0  $^$^  stduniqueptrfstclass ifstfstclassreadinname$^  if ifst return 0$^$^  if flagspdtparentheses.empty $^    logerror  argv0   no pdt parenthesis label pairs provided$^    return 0$^  $^$^  stdvectorslabelpair parens$^  if readlabelpairsflagspdtparentheses parens false return 0$^$^  sprintpdtinfoifst parens$^$^  return 0$^$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^ definitions of scriptable versions of pdt operations that is$^ those that can be called with fstclasstype arguments.$^$^ see comments in nlpfstscriptscriptimpl.h for how the registration$^ mechanism allows these to work with various arc types.$^$^include string$^include vector$^$^include fstextensionspdtcompose.h$^include fstextensionspdtexpand.h$^include fstextensionspdtpdtscript.h$^include fstextensionspdtreplace.h$^include fstextensionspdtreverse.h$^include fstextensionspdtshortestpath.h$^include fstscriptscriptimpl.h$^$^namespace fst $^namespace script $^$^void pdtcomposeconst fstclass ifst0 const fstclass ifst0$^                const stdvectorlabelpair parens$^                mutablefstclass ofst const pdtcomposeoptions copts$^                bool leftpdt $^  if internalarctypesmatchifst0 ifst0 pdtcompose $^      internalarctypesmatchifst0 ofst pdtcompose$^    return$^  pdtcomposeargs argsifst0 ifst0 parens ofst copts leftpdt$^  applyoperationpdtcomposeargspdtcompose ifst0.arctype args$^$^$^void pdtexpandconst fstclass ifst$^               const stdvectorlabelpair parens$^               mutablefstclass ofst const pdtexpandoptions opts $^  pdtexpandargs argsifst parens ofst opts$^  applyoperationpdtexpandargspdtexpand ifst.arctype args$^$^$^void pdtexpandconst fstclass ifst$^               const stdvectorstdpairint00 int00 parens$^               mutablefstclass ofst bool connect bool keepparentheses$^               const weightclass weightthreshold $^  pdtexpandifst parens ofst$^            pdtexpandoptionsconnect keepparentheses weightthreshold$^$^$^void pdtreplaceconst stdvectorlabelfstclasspair pairs$^                mutablefstclass ofst stdvectorlabelpair parens$^                int00 root pdtparsertype parsertype int00 startparenlabels$^                const string leftparenprefix$^                const string rightparenprefix $^  for sizet i  0 i  pairs.size i $^    if internalarctypesmatchpairsi  0.second pairsi.second$^                                 pdtreplace$^      return$^  $^  if internalarctypesmatchpairs0.second ofst pdtreplace return$^  pdtreplaceargs argspairs ofst parens root parsertype$^                      startparenlabels leftparenprefix$^                      rightparenprefix$^  applyoperationpdtreplaceargspdtreplace ofstarctype args$^$^$^void pdtreverseconst fstclass ifst$^                const stdvectorlabelpair parens$^                mutablefstclass ofst $^  pdtreverseargs argsifst parens ofst$^  applyoperationpdtreverseargspdtreverse ifst.arctype args$^$^$^void pdtshortestpathconst fstclass ifst$^                     const stdvectorlabelpair parens$^                     mutablefstclass ofst$^                     const pdtshortestpathoptions opts $^  pdtshortestpathargs argsifst parens ofst opts$^  applyoperationpdtshortestpathargspdtshortestpath ifst.arctype$^                                        args$^$^$^void printpdtinfoconst fstclass ifst$^                  const stdvectorlabelpair parens $^  printpdtinfoargs argsifst parens$^  applyoperationprintpdtinfoargsprintpdtinfo ifst.arctype args$^$^$^ register operations for common arc types.$^$^registerfstpdtoperationsstdarc$^registerfstpdtoperationslogarc$^registerfstpdtoperationslog00arc$^$^   namespace script$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^ reverses a pdt.$^$^include cstring$^$^include memory$^include string$^include vector$^$^include fstflags.h$^include fstlog.h$^$^include fstextensionspdtpdtscript.h$^include fstutil.h$^$^definestringpdtparentheses  pdt parenthesis label pairs$^$^int mainint argc char argv $^  namespace s  fstscript$^  using fstreadlabelpairs$^  using fstscriptfstclass$^  using fstscriptvectorfstclass$^$^  string usage  reverse a pdt.nn  usage $^  usage  argv0$^  usage   in.pdt out.fstn$^$^  stdsetnewhandlerfailednewhandler$^  setflagsusage.cstr argc argv true$^  if argc  0 $^    showusage$^    return 0$^  $^$^  const string inname $^      argc  0  strcmpargv0   0  argv0  $^  const string outname  argc  0  argv0  $^$^  stduniqueptrfstclass ifstfstclassreadinname$^  if ifst return 0$^$^  if flagspdtparentheses.empty $^    logerror  argv0   no pdt parenthesis label pairs provided$^    return 0$^  $^$^  stdvectorslabelpair parens$^  if readlabelpairsflagspdtparentheses parens false return 0$^$^  vectorfstclass ofstifstarctype$^$^  spdtreverseifst parens ofst$^$^  ofst.writeoutname$^$^  return 0$^$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^ expands a boundedstack pdt as an fst.$^$^include cstring$^$^include memory$^include string$^include vector$^$^include fstflags.h$^include fstlog.h$^$^include fstextensionspdtpdtscript.h$^include fstutil.h$^$^definestringpdtparentheses  pdt parenthesis label pairs$^defineboolconnect true trim output$^defineboolkeepparentheses false keep pdt parentheses in result$^definestringweight  weight threshold$^$^int mainint argc char argv $^  namespace s  fstscript$^  using fstscriptfstclass$^  using fstscriptvectorfstclass$^  using fstscriptweightclass$^  using fstreadlabelpairs$^$^  string usage  expand a boundedstack pdt as an fst.nn  usage $^  usage  argv0$^  usage   in.pdt out.fstn$^$^  stdsetnewhandlerfailednewhandler$^  setflagsusage.cstr argc argv true$^  if argc  0 $^    showusage$^    return 0$^  $^$^  const string inname $^      argc  0  strcmpargv0   0  argv0  $^  const string outname  argc  0  argv0  $^$^  stduniqueptrfstclass ifstfstclassreadinname$^  if ifst return 0$^$^  if flagspdtparentheses.empty $^    logerror  argv0   no pdt parenthesis label pairs provided$^    return 0$^  $^$^  stdvectorslabelpair parens$^  if readlabelpairsflagspdtparentheses parens false return 0$^$^  const auto weightthreshold $^      flagsweight.empty  weightclasszeroifstweighttype$^                            weightclassifstweighttype flagsweight$^$^  vectorfstclass ofstifstarctype$^  spdtexpandifst parens ofst$^               spdtexpandoptionsflagsconnect flagskeepparentheses$^                                   weightthreshold$^$^  ofst.writeoutname$^$^  return 0$^$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstextensionspdtgetters.h$^$^namespace fst $^namespace script $^$^bool getpdtcomposefilterconst string str pdtcomposefilter cf $^  if str  expand $^    cf  expandfilter$^   else if str  expandparen $^    cf  expandparenfilter$^   else if str  paren $^    cf  parenfilter$^   else $^    return false$^  $^  return true$^$^$^bool getpdtparsertypeconst string str pdtparsertype pt $^  if str  left $^    pt  pdtleftparser$^   else if str  leftsr $^    pt  pdtleftsrparser$^   else $^    return false$^  $^  return true$^$^$^   namespace script$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^ returns the shortest path in a boundedstack pdt.$^$^include cstring$^$^include memory$^include string$^include vector$^$^include fstflags.h$^include fstlog.h$^$^include fstextensionspdtpdtscript.h$^include fstutil.h$^$^defineboolkeepparentheses false keep pdt parentheses in result$^definestringqueuetype fifo$^              queue type one of $^              fifo lifo state$^defineboolpathgc true garbage collect shortest path data$^definestringpdtparentheses  pdt parenthesis label pairs$^$^int mainint argc char argv $^  namespace s  fstscript$^  using fstscriptfstclass$^  using fstscriptvectorfstclass$^  using fstqueuetype$^  using fstreadlabelpairs$^$^  string usage  shortest path in a boundedstack pdt.nn  usage $^  usage  argv0$^  usage   in.pdt out.fstn$^$^  stdsetnewhandlerfailednewhandler$^  setflagsusage.cstr argc argv true$^  if argc  0 $^    showusage$^    return 0$^  $^$^  const string inname $^      argc  0  strcmpargv0   0  argv0  $^  const string outname  argc  0  argv0  $^$^  stduniqueptrfstclass ifstfstclassreadinname$^  if ifst return 0$^$^  if flagspdtparentheses.empty $^    logerror  argv0   no pdt parenthesis label pairs provided$^    return 0$^  $^$^  stdvectorslabelpair parens$^  if readlabelpairsflagspdtparentheses parens false return 0$^$^  vectorfstclass ofstifstarctype$^$^  queuetype qt$^  if flagsqueuetype  fifo $^    qt  fstfifoqueue$^   else if flagsqueuetype  lifo $^    qt  fstlifoqueue$^   else if flagsqueuetype  state $^    qt  fststateorderqueue$^   else $^    logerror  unknown queue type   flagsqueuetype$^    return 0$^  $^$^  const spdtshortestpathoptions optsqt flagskeepparentheses$^                                       flagspathgc$^$^  spdtshortestpathifst parens ofst opts$^$^  ofst.writeoutname$^$^  return 0$^$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^ composes a pdt and an fst.$^$^include cstring$^$^include memory$^include string$^include vector$^$^include fstflags.h$^include fstlog.h$^$^include fstextensionspdtgetters.h$^include fstextensionspdtpdtscript.h$^include fstutil.h$^$^definestringpdtparentheses  pdt parenthesis label pairs$^defineboolleftpdt true is the first argument the pdt$^defineboolconnect true trim output$^definestringcomposefilter paren$^              composition filter one of expand expandparen $^              paren$^$^int mainint argc char argv $^  namespace s  fstscript$^  using fstreadlabelpairs$^  using fstpdtcomposefilter$^  using fstpdtcomposeoptions$^  using fstscriptfstclass$^  using fstscriptvectorfstclass$^$^  string usage  compose a pdt and an fst.nn  usage $^  usage  argv0$^  usage   in.pdt in.fst out.pdtn$^  usage   in.fst in.pdt out.pdtn$^$^  stdsetnewhandlerfailednewhandler$^  setflagsusage.cstr argc argv true$^  if argc  0  argc  0 $^    showusage$^    return 0$^  $^$^  const string in0name  strcmpargv0   0    argv0$^  const string in0name  strcmpargv0   0    argv0$^  const string outname  argc  0  argv0  $^$^  if in0name.empty  in0name.empty $^    logerror  argv0   cant take both inputs from standard input.$^    return 0$^  $^$^  stduniqueptrfstclass ifst0fstclassreadin0name$^  if ifst0 return 0$^  stduniqueptrfstclass ifst0fstclassreadin0name$^  if ifst0 return 0$^$^  if flagspdtparentheses.empty $^    logerror  argv0   no pdt parenthesis label pairs provided$^    return 0$^  $^$^  stdvectorslabelpair parens$^  if readlabelpairsflagspdtparentheses parens false return 0$^$^  vectorfstclass ofstifst0arctype$^$^  pdtcomposefilter composefilter$^  if sgetpdtcomposefilterflagscomposefilter composefilter $^    logerror  argv0   unknown or unsupported compose filter type $^                flagscomposefilter$^    return 0$^  $^$^  const pdtcomposeoptions coptsflagsconnect composefilter$^$^  spdtcomposeifst0 ifst0 parens ofst copts flagsleftpdt$^$^  ofst.writeoutname$^$^  return 0$^$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstextensionsngramnthbit.h$^$^ this table is generated using$^$^  unsigned int nthbitscanuint00 v unsigned int r $^    int i0$^    for  i00 i $^      if r  v  0  0 return i$^      v  0$^    $^    return i$^  $^$^  for sizet i  0 i  000 i $^    uint00 offsets  0$^    for sizet b  0 b  0 b $^      uint00 offset  minuint00nthbitscani b 0$^      offsets  offset  b  0  0$^    $^    bitoffset  offsets$^    printf0xx  bitoffset$^    if i  0  0 printfn$^  $^$^uint00 nthbitbitoffset  $^    0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000$^    0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000$^    0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000$^    0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000$^    0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000$^    0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000$^    0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000$^    0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000$^    0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000$^    0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000$^    0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000$^    0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000$^    0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000$^    0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000$^    0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000$^    0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000$^    0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000$^    0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000$^    0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000$^    0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000$^    0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000$^    0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000$^    0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000$^    0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000$^    0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000$^    0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000$^    0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000$^    0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000$^    0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000$^    0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000$^    0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000$^    0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000$^    0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000$^    0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000$^    0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000$^    0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000$^    0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000$^    0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000$^    0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000$^    0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000$^    0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000$^    0x00000000 0x00000000 0x00000000 0x00000000 0x00000000 0x00000000$^    0x00000000 0x00000000 0x00000000 0x00000000$^$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstextensionsngrambitmapindex.h$^$^include algorithm$^include iterator$^$^include fstlog.h$^include fstextensionsngramnthbit.h$^$^namespace fst $^namespace $^const sizet kprimaryblockbits $^    bitmapindexkstoragebitsize  bitmapindexksecondaryblocksize$^$^ if begin beginsize is a monotonically increasing running sum of$^ popcounts for a bitmap this will return the index of the word that contains$^ the valueth zero.  if value is larger then the number of zeros in the$^ bitmap size will be returned.  the idea is that the number of zerocounts$^ i.e. the popcount of logical not of values is offset  kstoragebitsize$^ minus the value for each element of the running sum.$^template sizet blocksize typename container$^sizet invertedsearchconst container c$^                      sizet firstidx$^                      sizet lastidx$^                      sizet value $^  const sizet beginidx  firstidx$^  while firstidx  lastidx $^     invariant firstidx lastidx is the search range.$^    sizet mididx  firstidx  lastidx  firstidx  0$^    sizet midvalue  blocksize  0  mididx  beginidx  cmididx$^    if midvalue  value $^      firstidx  mididx  0$^     else $^      lastidx  mididx$^    $^  $^  return firstidx$^$^   namespace$^$^sizet bitmapindexrank0sizet end const $^  if end  0 return 0$^  const uint00 endword  end  0  bitmapindexkstoragelogbitsize$^  const uint00 sum  getindexonescountendword$^  const sizet masked  end  kstorageblockmask$^  if masked  0 $^    return sum  builtinpopcountllbitsendword$^   else $^    const uint00 zero  0$^    return sum  builtinpopcountllbitsendword $^                                      zero  kstoragebitsize  masked$^  $^$^$^sizet bitmapindexselect0sizet bitindex const $^  if bitindex  getonescount return bits$^   search primary index for the relevant block$^  uint00 rembits  bitindex  0$^  const uint00 block  findprimaryblockbitindex  0$^  uint00 offset  0$^  if block  0 $^    rembits  primaryindexblock  0$^    offset  block  ksecondaryblocksize$^  $^   search the secondary index$^  uint00 word  findsecondaryblockoffset rembits$^  if word  0 $^    rembits  secondaryindexoffset  word  0$^    offset  word$^  $^  int nth  nthbitbitsoffset rembits$^  return offset  bitmapindexkstoragelogbitsize  nth$^$^$^sizet bitmapindexselect0sizet bitindex const $^  if bitindex  bits  getonescount return bits$^   search inverted primary index for relevant block$^  uint00 remzeros  bitindex  0$^  uint00 offset  0$^  const uint00 block  findinvertedprimaryblockbitindex  0$^  if block  0 $^    remzeros  kprimaryblockbits  block  primaryindexblock  0$^    offset  block  ksecondaryblocksize$^  $^   search the inverted secondary index$^  uint00 word  findinvertedsecondaryblockoffset remzeros$^  if word  0 $^    remzeros  bitmapindexkstoragebitsize  word $^                secondaryindexoffset  word  0$^    offset  word$^  $^  int nth  nthbitbitsoffset remzeros$^  return offset  bitmapindexkstoragelogbitsize  nth$^$^$^stdpairsizet sizet bitmapindexselect0ssizet bitindex const $^  const uint00 zero  0$^  const uint00 ones  zero$^  sizet zeroscount  bits  getonescount$^  if bitindex  zeroscount return stdmakepairbits bits$^  if bitindex  0  zeroscount $^    return stdmakepairselect0bitindex bits$^  $^   search inverted primary index for relevant block$^  uint00 remzeros  bitindex  0$^  uint00 offset  0$^  const uint00 block  findinvertedprimaryblockbitindex  0$^  sizet numzerosinblock $^      kprimaryblockbits  0  block  primaryindexblock$^  if block  0 $^    sizet numzerosnext $^        kprimaryblockbits  block  primaryindexblock  0$^    numzerosinblock  numzerosnext$^    remzeros  numzerosnext$^    offset  block  ksecondaryblocksize$^  $^   search the inverted secondary index$^  uint00 word  findinvertedsecondaryblockoffset remzeros$^  uint00 sumzerosnextword  bitmapindexkstoragebitsize  0  word $^                               secondaryindexoffset  word$^  uint00 sumzerosthisword  0$^  if word  0 $^    sumzerosthisword  bitmapindexkstoragebitsize  word $^                          secondaryindexoffset  word  0$^    remzeros  sumzerosthisword$^    offset  word$^  $^  int nth  nthbitbitsoffset remzeros$^  sizet currentzero  offset  bitmapindexkstoragelogbitsize  nth$^$^  sizet nextzero$^   does the current block contain the next zero$^  if numzerosinblock  remzeros  0 $^    if sumzerosnextword  sumzerosthisword  remzeros  0 $^       the next zero is in this word$^      nextzero  offset  bitmapindexkstoragelogbitsize $^                  nthbitbitsoffset remzeros  0$^     else $^       find the first field that is not all ones by linear scan.$^       in the worst case this may scan 0kbytes.  the alternative is$^       to inspect secondaryindex looking for a place to jump to but$^       that would probably use more cache.$^      while bitsoffset  ones $^      $^      nextzero  offset  bitmapindexkstoragelogbitsize $^                  builtinctzllbitsoffset$^    $^   else $^     the next zero is in a different block a full search is required.$^    nextzero  select0bitindex  0$^  $^  return stdmakepaircurrentzero nextzero$^$^$^sizet bitmapindexgetindexonescountsizet arrayindex const $^  uint00 sum  0$^  if arrayindex  0 $^    sum  secondaryindexarrayindex  0$^    uint00 endblock  arrayindex  0  ksecondaryblocksize$^    if endblock  0 sum  primaryindexendblock  0$^  $^  return sum$^$^$^void bitmapindexbuildindexconst uint00 bits sizet size $^  bits  bits$^  size  size$^  primaryindex.resizeprimaryindexsize$^  secondaryindex.resizearraysize$^  const uint00 zero  0$^  const uint00 ones  zero$^  uint00 popcount  0$^  for uint00 block  0 block  ksecondaryblocksize  arraysize block $^    uint00 blockpopcount  0$^    uint00 blockbegin  block  ksecondaryblocksize$^    uint00 blockend  blockbegin  ksecondaryblocksize$^    if blockend  arraysize blockend  arraysize$^    for uint00 j  blockbegin j  blockend j $^      uint00 mask  ones$^      if j  arraysize  0 $^        mask  ones  size  bitmapindexkstorageblockmask$^      $^      blockpopcount  builtinpopcountllbitsj  mask$^      secondaryindexj  blockpopcount$^    $^    popcount  blockpopcount$^    primaryindexblock  popcount$^  $^$^$^sizet bitmapindexfindsecondaryblocksizet blockbegin$^                                         sizet rembitindex const $^  sizet blockend  blockbegin  ksecondaryblocksize$^  if blockend  arraysize blockend  arraysize$^  return stddistance$^      secondaryindex.begin  blockbegin$^      stdlowerboundsecondaryindex.begin  blockbegin$^                       secondaryindex.begin  blockend rembitindex$^$^$^sizet bitmapindexfindinvertedsecondaryblocksizet blockbegin$^                                                  sizet rembitindex const $^  sizet blockend  blockbegin  ksecondaryblocksize$^  if blockend  arraysize blockend  arraysize$^  return invertedsearchbitmapindexkstoragebitsizesecondaryindex$^                                                      blockbegin blockend$^                                                      rembitindex$^       blockbegin$^$^$^inline sizet bitmapindexfindprimaryblocksizet bitindex const $^  return stddistance$^      primaryindex.begin$^      stdlowerboundprimaryindex.begin$^                       primaryindex.begin  primaryindexsize$^                       bitindex$^$^$^sizet bitmapindexfindinvertedprimaryblocksizet bitindex const $^  return invertedsearchkprimaryblockbits$^      primaryindex 0 primaryindex.size bitindex$^$^   end namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstextensionsngramngramfst.h$^$^include systypes.h$^$^include fstarc.h$^include fstregister.h$^$^using fstngramfst$^using fststdarc$^using fstlogarc$^$^registerfstngramfst stdarc$^registerfstngramfst logarc$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstfst.h$^include fstextensionsspecialphifst.h$^$^defineint00phifstphilabel 0$^             label of transitions to be interpreted as phi failure $^              transitions$^defineboolphifstphiloop true$^            when true a phi self loop consumes a symbol$^definestringphifstrewritemode auto$^              rewrite both sides when matching one of$^               auto rewrite iff acceptor always never$^$^namespace fst $^$^const char phifsttype  phi$^const char inputphifsttype  inputphi$^const char outputphifsttype  outputphi$^$^static fstregistererstdphifst phifststdarcregisterer$^static fstregistererlogphifst phifstlogarcregisterer$^static fstregistererlog00phifst phifstlog00arcregisterer$^$^static fstregistererstdinputphifst inputphifststdarcregisterer$^static fstregistererloginputphifst inputphifstlogarcregisterer$^static fstregistererlog00inputphifst inputphifstlog00arcregisterer$^$^static fstregistererstdoutputphifst outputphifststdarcregisterer$^static fstregistererlogoutputphifst outputphifstlogarcregisterer$^static fstregistererlog00outputphifst outputphifstlog00arcregisterer$^$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstextensionsspecialsigmafst.h$^$^include fstfst.h$^$^defineint00sigmafstsigmalabel 0$^             label of transitions to be interpreted as sigma any $^             transitions$^definestringsigmafstrewritemode auto$^              rewrite both sides when matching one of$^               auto rewrite iff acceptor always never$^$^namespace fst $^$^const char sigmafsttype  sigma$^const char inputsigmafsttype  inputsigma$^const char outputsigmafsttype  outputsigma$^$^static fstregistererstdsigmafst sigmafststdarcregisterer$^static fstregistererlogsigmafst sigmafstlogarcregisterer$^static fstregistererlog00sigmafst sigmafstlog00arcregisterer$^$^static fstregistererstdinputsigmafst inputsigmafststdarcregisterer$^static fstregistererloginputsigmafst inputsigmafstlogarcregisterer$^static fstregistererlog00inputsigmafst inputsigmafstlog00arcregisterer$^$^static fstregistererstdoutputsigmafst outputsigmafststdarcregisterer$^static fstregistererlogoutputsigmafst outputsigmafstlogarcregisterer$^static fstregistererlog00outputsigmafst outputsigmafstlog00arcregisterer$^$^   namespace fst$^ workaround to correctly build e.g. distclean with autotools$^ using files in another directory that are also built there.$^ see httpsstackoverflow.comquestions00000000.$^$^include fstconvertmain.cc    nolint$^include fstconvert.cc         nolint$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstextensionsspecialrhofst.h$^$^include fstfst.h$^$^defineint00rhofstrholabel 0$^             label of transitions to be interpreted as rho rest $^             transitions$^definestringrhofstrewritemode auto$^              rewrite both sides when matching one of$^               auto rewrite iff acceptor always never$^$^namespace fst $^$^const char rhofsttype  rho$^const char inputrhofsttype  inputrho$^const char outputrhofsttype  outputrho$^$^static fstregistererstdrhofst rhofststdarcregisterer$^static fstregistererlogrhofst rhofstlogarcregisterer$^static fstregistererlog00rhofst rhofstlog00arcregisterer$^$^static fstregistererstdinputrhofst inputrhofststdarcregisterer$^static fstregistererloginputrhofst inputrhofstlogarcregisterer$^static fstregistererlog00inputrhofst inputrhofstlog00arcregisterer$^$^static fstregistererstdoutputrhofst outputrhofststdarcregisterer$^static fstregistererlogoutputrhofst outputrhofstlogarcregisterer$^static fstregistererlog00outputrhofst outputrhofstlog00arcregisterer$^$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstfst.h$^include fstconstfst.h$^$^namespace fst $^$^static fstregistererconstfststdarc uint00$^    constfststdarcuint00registerer$^static fstregistererconstfstlogarc uint00$^    constfstlogarcuint00registerer$^static fstregistererconstfstlog00arc uint00$^    constfstlog00arcuint00registerer$^$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstfst.h$^include fstconstfst.h$^$^namespace fst $^$^static fstregistererconstfststdarc uint0 constfststdarcuint0registerer$^static fstregistererconstfstlogarc uint0 constfstlogarcuint0registerer$^static fstregistererconstfstlog00arc uint0$^    constfstlog00arcuint0registerer$^$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstfst.h$^include fstconstfst.h$^$^namespace fst $^$^static fstregistererconstfststdarc uint00$^    constfststdarcuint00registerer$^static fstregistererconstfstlogarc uint00$^    constfstlogarcuint00registerer$^static fstregistererconstfstlog00arc uint00$^    constfstlog00arcuint00registerer$^$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^ prints some basic information about the fsts in an fst archive.$^$^include string$^include vector$^$^include fstflags.h$^include fstextensionsfarfarscript.h$^include fstextensionsfargetters.h$^$^definestringbeginkey $^              first key to extract default first key in archive$^definestringendkey $^              last key to extract default last key in archive$^$^defineboollistfsts false display fst information for each key$^$^int mainint argc char argv $^  namespace s  fstscript$^$^  string usage  prints some basic information about the fsts in an fst $^  usage  archive.nn  usage$^  usage  argv0$^  usage   in0.far in0.far...n$^  usage    flags beginkey endkey listfsts$^$^  stdsetnewhandlerfailednewhandler$^  setflagsusage.cstr argc argv true$^  sexpandargsargc argv argc argv$^$^  stdvectorstring infnames$^  for int i  0 i  argc i infnames.pushbackargvi$^  if infnames.empty infnames.pushback$^$^  const auto arctype  sloadarctypefromfarinfnames0$^  if arctype.empty return 0$^$^  sfarinfoinfnames arctype flagsbeginkey flagsendkey$^             flagslistfsts$^$^  return 0$^$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^ tests if two far files contains isomorphic keyfst pairs.$^$^include string$^$^include fstflags.h$^include fstextensionsfarfarscript.h$^include fstextensionsfargetters.h$^$^definestringbeginkey $^              first key to extract def first key in archive$^definestringendkey  last key to extract def last key in archive$^definedoubledelta fstkdelta comparisonquantization delta$^$^int mainint argc char argv $^  namespace s  fstscript$^$^  string usage  compares the fsts in two fst archives for isomorphism.$^  usage  nn  usage$^  usage  argv0$^  usage   in0.far in0.farn$^  usage    flags beginkey endkey$^$^  stdsetnewhandlerfailednewhandler$^  setflagsusage.cstr argc argv true$^  sexpandargsargc argv argc argv$^$^  if argc  0 $^    showusage$^    return 0$^  $^$^  const auto arctype  sloadarctypefromfarargv0$^  if arctype.empty return 0$^$^  bool result  sfarisomorphicargv0 argv0 arctype$^                                 flagsdelta flagsbeginkey flagsendkey$^$^  if result vlog0  fars are not isomorphic.$^$^  return result  0  0$^$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^ outputs as strings the string fsts in a finitestate archive.$^$^include string$^include vector$^$^include fstflags.h$^include fstextensionsfarfarscript.h$^include fstextensionsfargetters.h$^$^definestringfilenameprefix  prefix to append to filenames$^definestringfilenamesuffix  suffix to append to filenames$^defineint00generatefilenames 0$^             generate n digit numeric filenames def use keys$^definestringbeginkey $^              first key to extract def first key in archive$^definestringendkey  last key to extract def last key in archive$^ printstringsmain specific flag definitions.$^defineboolprintkey false prefix each string by its key$^defineboolprintweight false suffix each string by its weight$^definestringentrytype line$^              entry type one of  $^              file one fst per file line one fst per line$^definestringtokentype symbol$^              token type one of  $^              symbol byte utf0$^definestringsymbols  label symbol table$^defineboolinitialsymbols true$^            uses symbol table from the first fst in archive for all entries.$^$^int mainint argc char argv $^  namespace s  fstscript$^$^  string usage  print as string the string fsts in an archive.nn  usage$^  usage  argv0$^  usage   in0.far in0.far ...n$^$^  stdsetnewhandlerfailednewhandler$^  setflagsusage.cstr argc argv true$^  sexpandargsargc argv argc argv$^$^  stdvectorstring infnames$^  for int i  0 i  argc i infnames.pushbackargvi$^  if infnames.empty infnames.pushback$^$^  const auto arctype  sloadarctypefromfarinfnames0$^  if arctype.empty return 0$^$^  fstfarentrytype entrytype$^  if sgetfarentrytypeflagsentrytype entrytype $^    logerror  unknown or unsupported far entry type   flagsentrytype$^    return 0$^  $^$^  fstfartokentype tokentype$^  if sgetfartokentypeflagstokentype tokentype $^    logerror  unknown or unsupported far token type   flagstokentype$^    return 0$^  $^$^  sfarprintstringsinfnames arctype entrytype tokentype$^                     flagsbeginkey flagsendkey flagsprintkey$^                     flagsprintweight flagssymbols flagsinitialsymbols$^                     flagsgeneratefilenames flagsfilenameprefix$^                     flagsfilenamesuffix$^$^  return 0$^$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^ definitions of scriptable versions of far operations that is$^ those that can be called with fstclasstype arguments.$^$^include fstextensionsfarfarscript.h$^include fstextensionsfarfar.h$^include fstscriptscriptimpl.h$^$^namespace fst $^namespace script $^$^void farcompilestringsconst stdvectorstring infnames$^                       const string outfname const string arctype$^                       const string fsttype const fartype fartype$^                       int00 generatekeys farentrytype fet fartokentype tt$^                       const string symbolsfname$^                       const string unknownsymbol bool keepsymbols$^                       bool initialsymbols bool allownegativelabels$^                       const string keyprefix const string keysuffix $^  farcompilestringsargs argsinfnames outfname fsttype fartype$^                             generatekeys fet tt symbolsfname$^                             unknownsymbol keepsymbols initialsymbols$^                             allownegativelabels keyprefix keysuffix$^  applyoperationfarcompilestringsargsfarcompilestrings arctype args$^$^$^void farcreateconst stdvectorstring infnames const string outfname$^               const string arctype const int00 generatekeys$^               const fartype fartype const string keyprefix$^               const string keysuffix $^  farcreateargs argsinfnames outfname generatekeys fartype keyprefix$^                     keysuffix$^  applyoperationfarcreateargsfarcreate arctype args$^$^$^bool farequalconst string filename0 const string filename0$^              const string arctype float delta const string beginkey$^              const string endkey $^  farequalinnerargs argsfilename0 filename0 delta beginkey endkey$^  farequalargs argswithretvalargs$^  applyoperationfarequalargsfarequal arctype argswithretval$^  return argswithretval.retval$^$^$^void farextractconst stdvectorstring ifilenames const string arctype$^                int00 generatefilenames const string keys$^                const string keyseparator const string rangedelimiter$^                const string filenameprefix const string filenamesuffix $^  farextractargs argsifilenames generatefilenames keys keyseparator$^                      rangedelimiter filenameprefix filenamesuffix$^  applyoperationfarextractargsfarextract arctype args$^$^$^void farinfoconst stdvectorstring filenames const string arctype$^             const string beginkey const string endkey$^             const bool listfsts $^  farinfoargs argsfilenames beginkey endkey listfsts$^  applyoperationfarinfoargsfarinfo arctype args$^$^$^void getfarinfoconst stdvectorstring filenames const string arctype$^                const string beginkey const string endkey$^                const bool listfsts farinfodata data $^  getfarinfoargs argsfilenames beginkey endkey listfsts data$^  applyoperationgetfarinfoargsgetfarinfo arctype args$^$^$^bool farisomorphicconst string filename0 const string filename0$^                   const string arctype float delta const string beginkey$^                   const string endkey $^  farisomorphicinnerargs argsfilename0 filename0 delta beginkey endkey$^  farisomorphicargs argswithretvalargs$^  applyoperationfarisomorphicargsfarisomorphic arctype$^                                      argswithretval$^  return argswithretval.retval$^$^$^void farprintstringsconst stdvectorstring ifilenames$^                     const string arctype const farentrytype entrytype$^                     const fartokentype tokentype const string beginkey$^                     const string endkey const bool printkey$^                     const bool printweight const string symbolsfname$^                     const bool initialsymbols const int00 generatefilenames$^                     const string filenameprefix$^                     const string filenamesuffix $^  farprintstringsargs argsifilenames entrytype tokentype beginkey$^                           endkey printkey printweight symbolsfname$^                           initialsymbols generatefilenames filenameprefix$^                           filenamesuffix$^  applyoperationfarprintstringsargsfarprintstrings arctype args$^$^$^ instantiate all templates for common arc types.$^$^registerfstfaroperationsstdarc$^registerfstfaroperationslogarc$^registerfstfaroperationslog00arc$^$^   namespace script$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstream$^include fstextensionsfarsttable.h$^$^namespace fst $^$^bool issttableconst string filename $^  stdifstream strmfilename$^  if strm.good return false$^$^  int00 magicnumber  0$^  readtypestrm magicnumber$^  return magicnumber  ksttablemagicnumber$^$^$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include cmath$^include string$^$^include fstflags.h$^include fstextensionsfarcompilestrings.h$^include fstream$^$^definestringfarfieldseparator t$^              set of characters used as a separator between printed fields$^$^namespace fst $^$^ computes the minimal length required to encode each line number as a decimal$^ number.$^int keysizeconst char filename $^  stdifstream istrmfilename$^  istrm.seekg0$^  string s$^  int nline  0$^  while getlineistrm s nline$^  istrm.seekg0$^  return nline  ceillog00nline  0  0$^$^$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^ extracts component fsts from an finitestate archive.$^$^include string$^include vector$^$^include fstflags.h$^include fstextensionsfarfarscript.h$^include fstextensionsfargetters.h$^$^definestringfilenameprefix  prefix to append to filenames$^definestringfilenamesuffix  suffix to append to filenames$^defineint00generatefilenames 0$^             generate n digit numeric filenames def use keys$^definestringkeys $^              extract set of keys separated by comma default $^              including ranges delimited by dash default$^definestringkeyseparator  separator for individual keys$^definestringrangedelimiter  delimiter for ranges of keys$^$^int mainint argc char argv $^  namespace s  fstscript$^$^  string usage  extracts fsts from a finitestate archive.nn usage$^  usage  argv0$^  usage   in0.far in0.far...n$^$^  stdsetnewhandlerfailednewhandler$^  setflagsusage.cstr argc argv true$^  sexpandargsargc argv argc argv$^$^  stdvectorstring infnames$^  for int i  0 i  argc i infnames.pushbackargvi$^  if infnames.empty infnames.pushback$^$^  const auto arctype  sloadarctypefromfarinfnames0$^  if arctype.empty return 0$^$^  sfarextractinfnames arctype flagsgeneratefilenames flagskeys$^                flagskeyseparator flagsrangedelimiter$^                flagsfilenameprefix flagsfilenamesuffix$^$^  return 0$^$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^ definitions and functions for invoking and using far main functions that$^ support multiple and extensible arc types.$^$^include fstextensionsfarscriptimpl.h$^$^include string$^$^include fstextensionsfarfar.h$^include fstream$^$^namespace fst $^namespace script $^$^string loadarctypefromfarconst string farfname $^  farheader hdr$^  if hdr.readfarfname $^    logerror  error reading far   farfname$^    return $^  $^  string atype  hdr.arctype$^  if atype  unknown $^    logerror  empty fst archive   farfname$^    return $^  $^  return atype$^$^$^string loadarctypefromfstconst string fstfname $^  fstheader hdr$^  stdifstream infstfname stdiosbasein  stdiosbasebinary$^  if hdr.readin fstfname $^    logerror  error reading fst   fstfname$^    return $^  $^  return hdr.arctype$^$^$^   namespace script$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstextensionsfarfarclass.h$^$^include fstscriptscriptimpl.h$^include fstextensionsfarscriptimpl.h$^$^namespace fst $^namespace script $^$^$^ farreaderclass.$^$^farreaderclass farreaderclassopenconst string filename $^  openfarreaderclassargs0 argsfilename$^  args.retval  nullptr$^  applyoperationopenfarreaderclassargs0openfarreaderclass$^                                            loadarctypefromfarfilename$^                                            args$^  return args.retval$^$^$^farreaderclass farreaderclassopenconst stdvectorstring filenames $^  if filenames.empty $^    logerror  farreaderclassopen no files specified$^    return nullptr$^  $^  const auto arctype  loadarctypefromfarfilenames.front$^  if arctype.empty return nullptr$^  openfarreaderclassargs0 argsfilenames$^  args.retval  nullptr$^  applyoperationopenfarreaderclassargs0openfarreaderclass arctype$^                                            args$^  return args.retval$^$^$^registerfstoperationopenfarreaderclass stdarc openfarreaderclassargs0$^registerfstoperationopenfarreaderclass logarc openfarreaderclassargs0$^registerfstoperationopenfarreaderclass log00arc openfarreaderclassargs0$^$^registerfstoperationopenfarreaderclass stdarc openfarreaderclassargs0$^registerfstoperationopenfarreaderclass logarc openfarreaderclassargs0$^registerfstoperationopenfarreaderclass log00arc openfarreaderclassargs0$^$^ farwriterclass.$^$^farwriterclass farwriterclasscreateconst string filename$^                                       const string arctype fartype type $^  createfarwriterclassinnerargs iargsfilename type$^  createfarwriterclassargs argsiargs$^  args.retval  nullptr$^  applyoperationcreatefarwriterclassargscreatefarwriterclass arctype$^                                             args$^  return args.retval$^$^$^registerfstoperationcreatefarwriterclass stdarc createfarwriterclassargs$^registerfstoperationcreatefarwriterclass logarc createfarwriterclassargs$^registerfstoperationcreatefarwriterclass log00arc$^                       createfarwriterclassargs$^$^   namespace script$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^ tests if two far files contains the same keyfst pairs.$^$^include string$^$^include fstflags.h$^include fstextensionsfarfarscript.h$^include fstextensionsfargetters.h$^$^definestringbeginkey $^              first key to extract def first key in archive$^definestringendkey  last key to extract def last key in archive$^definedoubledelta fstkdelta comparisonquantization delta$^$^int mainint argc char argv $^  namespace s  fstscript$^$^  string usage  compares the fsts in two fst archives for equality.$^  usage  nn  usage$^  usage  argv0$^  usage   in0.far in0.far$^$^  stdsetnewhandlerfailednewhandler$^  setflagsusage.cstr argc argv true$^  sexpandargsargc argv argc argv$^  if argc  0 $^    showusage$^    return 0$^  $^$^  const auto arctype  sloadarctypefromfarargv0$^  if arctype.empty return 0$^$^  bool result  sfarequalargv0 argv0 arctype flagsdelta$^                            flagsbeginkey flagsendkey$^$^  if result vlog0  fars are not equal.$^$^  return result  0  0$^$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^ compiles a set of stings as fsts and stores them in a finitestate archive.$^$^include string$^include vector$^$^include fstflags.h$^include fstextensionsfarfarscript.h$^include fstextensionsfargetters.h$^include fstream$^$^definestringkeyprefix  prefix to append to keys$^definestringkeysuffix  suffix to append to keys$^defineint00generatekeys 0$^             generate n digit numeric keys def use file basenames$^definestringfartype default$^              far file format type one of default fst $^              stlist sttable$^defineboolallownegativelabels false$^            allow negative labels not recommended may cause conflicts$^definestringarctype standard output arc type$^definestringentrytype line$^              entry type one of  $^              file one fst per file line one fst per line$^definestringfsttype vector output fst type$^definestringtokentype symbol$^              token type one of  $^              symbol byte utf0$^definestringsymbols  label symbol table$^definestringunknownsymbol  $^defineboolfilelistinput false$^            each input file contains a list of files to be processed$^defineboolkeepsymbols false store symbol table in the far file$^defineboolinitialsymbols true$^            when keepsymbols is true stores symbol table only for the first$^             fst in archive.$^$^int mainint argc char argv $^  namespace s  fstscript$^$^  string usage  compiles a set of strings as fsts and stores them in$^  usage   a finitestate archive.nn  usage$^  usage  argv0$^  usage   in0.txt in0.txt ... out.farn$^$^  stdsetnewhandlerfailednewhandler$^  setflagsusage.cstr argc argv true$^  sexpandargsargc argv argc argv$^$^  stdvectorstring infnames$^  if flagsfilelistinput $^    for int i  0 i  argc  0 i $^      stdifstream istrmargvi$^      string str$^      while getlineistrm str infnames.pushbackstr$^    $^   else $^    for int i  0 i  argc  0 i$^      infnames.pushbackargvi$^  $^  if infnames.empty $^    infnames.pushbackargc  0  strcmpargv0   0  argv0  $^  $^$^  string outfname $^      argc  0  strcmpargvargc  0   0  argvargc  0  $^$^  fstfarentrytype entrytype$^  if sgetfarentrytypeflagsentrytype entrytype $^    logerror  unknown or unsupported far entry type   flagsentrytype$^    return 0$^  $^$^  fstfartokentype tokentype$^  if sgetfartokentypeflagstokentype tokentype $^    logerror  unkonwn or unsupported far token type   flagstokentype$^    return 0$^  $^$^  const auto fartype  sgetfartypeflagsfartype$^$^  sfarcompilestringsinfnames outfname flagsarctype flagsfsttype$^                       fartype flagsgeneratekeys entrytype tokentype$^                       flagssymbols flagsunknownsymbol flagskeepsymbols$^                       flagsinitialsymbols flagsallownegativelabels$^                       flagskeyprefix flagskeysuffix$^$^  return 0$^$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^$^ definitions and functions for invoking and using far main functions that$^ support multiple and extensible arc types.$^$^include fstextensionsfargetters.h$^$^include string$^include vector$^$^include fstream$^$^namespace fst $^$^namespace script $^$^fartype getfartypeconst string str $^  if str  fst $^    return farfst$^   else if str  stlist $^    return farstlist$^   else if str  sttable $^    return farsttable$^   else $^    return fardefault$^  $^$^$^bool getfarentrytypeconst string str farentrytype entrytype $^  if str  line $^    entrytype  fetline$^   else if str  file $^    entrytype  fetfile$^   else $^    return false$^  $^  return true$^$^$^bool getfartokentypeconst string str fartokentype tokentype $^  if str  symbol $^    tokentype  fttsymbol$^   else if str  byte $^    tokentype  fttbyte$^   else if str  utf0 $^    tokentype  fttutf0$^   else $^    return false$^  $^  return true$^$^$^void expandargsint argc char argv int argcp char argvp $^$^$^   namespace script$^$^string getfartypestringfartype type $^  switch type $^    case farfst$^      return fst$^    case farstlist$^      return stlist$^    case farsttable$^      return sttable$^    case fardefault$^      return default$^    default$^      return unknown$^  $^$^$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^ creates a finitestate archive from input fsts.$^$^include string$^include vector$^$^include fstflags.h$^include fstextensionsfarfarscript.h$^include fstextensionsfargetters.h$^include fstream$^$^definestringkeyprefix  prefix to append to keys$^definestringkeysuffix  suffix to append to keys$^defineint00generatekeys 0$^             generate n digit numeric keys def use file basenames$^definestringfartype default$^              far file format type one of default $^              stlist sttable$^defineboolfilelistinput false$^            each input file contains a list of files to be processed$^$^int mainint argc char argv $^  namespace s  fstscript$^$^  string usage  creates a finitestate archive from input fsts.nn usage$^  usage  argv0$^  usage   in0.fst in0.fst ... out.farn$^$^  stdsetnewhandlerfailednewhandler$^  setflagsusage.cstr argc argv true$^  sexpandargsargc argv argc argv$^$^  stdvectorstring infnames$^  if flagsfilelistinput $^    for int i  0 i  argc  0 i $^      stdifstream istrmargvi$^      string str$^      while getlineistrm str infnames.pushbackstr$^    $^   else $^    for int i  0 i  argc  0 i$^      infnames.pushbackargvi$^  $^  if infnames.empty$^    infnames.pushbackargc  0  strcmpargv0   0  argv0  $^$^  string outfname $^      argc  0  strcmpargvargc  0   0  argvargc  0  $^$^  const auto arctype  sloadarctypefromfstinfnames0$^  if arctype.empty return 0$^$^  const auto fartype  sgetfartypeflagsfartype$^$^  sfarcreateinfnames outfname arctype flagsgeneratekeys fartype$^               flagskeyprefix flagskeysuffix$^$^  return 0$^$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include ios$^$^include fstextensionsfarstlist.h$^include fstream$^$^namespace fst $^$^bool isstlistconst string filename $^  stdifstream strmfilename stdiosbasein  stdiosbasebinary$^  if strm return false$^  int00 magicnumber  0$^  readtypestrm magicnumber$^  return magicnumber  kstlistmagicnumber$^$^$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^ reverses an mpdt.$^$^include cstring$^$^include memory$^include string$^include vector$^$^include fstflags.h$^include fstlog.h$^$^include fstextensionsmpdtmpdtscript.h$^include fstextensionsmpdtreadwriteutils.h$^include fstutil.h$^$^definestringmpdtparentheses $^              mpdt parenthesis label pairs with assignments.$^$^definestringmpdtnewparentheses $^              output for reassigned parentheses and stacks$^$^int mainint argc char argv $^  namespace s  fstscript$^  using fstreadlabeltriples$^  using fstwritelabeltriples$^  using fstscriptfstclass$^  using fstscriptvectorfstclass$^$^  string usage  reverse an mpdt.nn  usage $^  usage  argv0$^  usage   in.pdt out.fstn$^$^  stdsetnewhandlerfailednewhandler$^  setflagsusage.cstr argc argv true$^  if argc  0 $^    showusage$^    return 0$^  $^$^  const string inname $^      argc  0  strcmpargv0   0  argv0  $^  const string outname  argc  0  argv0  $^$^  stduniqueptrfstclass ifstfstclassreadinname$^  if ifst return 0$^$^  if flagsmpdtparentheses.empty $^    logerror  argv0   no mpdt parenthesis label pairs provided$^    return 0$^  $^$^  if flagsmpdtnewparentheses.empty $^    logerror  argv0   no mpdt output parenthesis label file provided$^    return 0$^  $^$^  stdvectorslabelpair parens$^  stdvectorint00 assignments$^  if readlabeltriplesflagsmpdtparentheses parens assignments false$^    return 0$^$^  vectorfstclass ofstifstarctype$^$^  smpdtreverseifst parens assignments ofst$^$^  ofst.writeoutname$^$^  if writelabeltriplesflagsmpdtnewparentheses parens assignments$^    return 0$^$^  return 0$^$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^ composes an mpdt and an fst.$^$^include cstring$^$^include memory$^include string$^include vector$^$^include fstflags.h$^include fstlog.h$^$^include fstextensionsmpdtmpdtscript.h$^include fstextensionsmpdtreadwriteutils.h$^include fstextensionspdtgetters.h$^include fstutil.h$^$^definestringmpdtparentheses $^              mpdt parenthesis label pairs with assignments$^defineboolleftmpdt true is the first argument the mpdt$^defineboolconnect true trim output$^definestringcomposefilter paren$^              composition filter one of expand expandparen $^              paren$^$^int mainint argc char argv $^  namespace s  fstscript$^  using fstmpdtcomposeoptions$^  using fstpdtcomposefilter$^  using fstreadlabeltriples$^  using fstscriptfstclass$^  using fstscriptvectorfstclass$^$^  string usage  compose an mpdt and an fst.nn  usage $^  usage  argv0$^  usage   in.pdt in.fst out.mpdtn$^  usage   in.fst in.pdt out.mpdtn$^$^  stdsetnewhandlerfailednewhandler$^  setflagsusage.cstr argc argv true$^  if argc  0  argc  0 $^    showusage$^    return 0$^  $^$^  const string in0name  strcmpargv0   0    argv0$^  const string in0name  strcmpargv0   0    argv0$^  const string outname  argc  0  argv0  $^$^  if in0name.empty  in0name.empty $^    logerror  argv0   cant take both inputs from standard input.$^    return 0$^  $^$^  stduniqueptrfstclass ifst0fstclassreadin0name$^  if ifst0 return 0$^  stduniqueptrfstclass ifst0fstclassreadin0name$^  if ifst0 return 0$^$^  if flagsmpdtparentheses.empty $^    logerror  argv0   no mpdt parenthesis label pairs provided$^    return 0$^  $^$^  stdvectorslabelpair parens$^  stdvectorint00 assignments$^  if readlabeltriplesflagsmpdtparentheses parens assignments false$^    return 0$^$^  vectorfstclass ofstifst0arctype$^$^  pdtcomposefilter composefilter$^  if sgetpdtcomposefilterflagscomposefilter composefilter $^    logerror  argv0   unknown or unsupported compose filter type $^                flagscomposefilter$^    return 0$^  $^$^  const mpdtcomposeoptions optsflagsconnect composefilter$^$^  smpdtcomposeifst0 ifst0 parens assignments ofst opts$^                 flagsleftmpdt$^$^  ofst.writeoutname$^$^  return 0$^$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^ prints out various information about an mpdt such as number of states arcs$^ and parentheses.$^$^include cstring$^$^include memory$^include string$^include vector$^$^include fstflags.h$^include fstlog.h$^$^include fstextensionsmpdtmpdtscript.h$^include fstextensionsmpdtreadwriteutils.h$^include fstutil.h$^$^definestringmpdtparentheses $^              mpdt parenthesis label pairs with assignments$^$^int mainint argc char argv $^  namespace s  fstscript$^  using fstscriptfstclass$^  using fstreadlabeltriples$^$^  string usage  prints out information about an mpdt.nn  usage $^  usage  argv0$^  usage   in.pdtn$^$^  stdsetnewhandlerfailednewhandler$^  setflagsusage.cstr argc argv true$^  if argc  0 $^    showusage$^    return 0$^  $^$^  const string inname $^      argc  0  strcmpargv0   0  argv0  $^$^  stduniqueptrfstclass ifstfstclassreadinname$^  if ifst return 0$^$^  if flagsmpdtparentheses.empty $^    logerror  argv0   no mpdt parenthesis label pairs provided$^    return 0$^  $^$^  stdvectorslabelpair parens$^  stdvectorint00 assignments$^  if readlabeltriplesflagsmpdtparentheses parens assignments false$^    return 0$^$^  sprintmpdtinfoifst parens assignments$^$^  return 0$^$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^ expands a boundedstack mpdt as an fst.$^$^include cstring$^$^include memory$^include string$^include vector$^$^include fstflags.h$^include fstlog.h$^$^include fstextensionsmpdtmpdtscript.h$^include fstextensionsmpdtreadwriteutils.h$^include fstutil.h$^$^definestringmpdtparentheses $^              mpdt parenthesis label pairs with assignments$^defineboolconnect true trim output$^defineboolkeepparentheses false keep pdt parentheses in result$^$^int mainint argc char argv $^  namespace s  fstscript$^  using fstscriptfstclass$^  using fstscriptvectorfstclass$^  using fstreadlabeltriples$^  using fstmpdtexpandoptions$^$^  string usage  expand a boundedstack mpdt as an fst.nn  usage $^  usage  argv0$^  usage   in.pdt out.fstn$^$^  stdsetnewhandlerfailednewhandler$^  setflagsusage.cstr argc argv true$^  if argc  0 $^    showusage$^    return 0$^  $^$^  const string inname $^      argc  0  strcmpargv0   0  argv0  $^  const string outname  argc  0  argv0  $^$^  stduniqueptrfstclass ifstfstclassreadinname$^  if ifst return 0$^$^  if flagsmpdtparentheses.empty $^    logerror  argv0   no mpdt parenthesis label pairs provided$^    return 0$^  $^$^  stdvectorslabelpair parens$^  stdvectorint00 assignments$^  if readlabeltriplesflagsmpdtparentheses parens assignments false$^    return 0$^$^  vectorfstclass ofstifstarctype$^$^  const mpdtexpandoptions optsflagsconnect flagskeepparentheses$^$^  smpdtexpandifst parens assignments ofst opts$^$^  ofst.writeoutname$^$^  return 0$^$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^ definitions of scriptable versions of mpdt operations that is$^ those that can be called with fstclasstype arguments.$^$^ see comments in nlpfstscriptscriptimpl.h for how the registration$^ mechanism allows these to work with various arc types.$^$^include string$^include vector$^$^include fstextensionsmpdtcompose.h$^include fstextensionsmpdtexpand.h$^include fstextensionsmpdtmpdtscript.h$^include fstextensionsmpdtreverse.h$^include fstscriptscriptimpl.h$^$^namespace fst $^namespace script $^$^void mpdtcomposeconst fstclass ifst0 const fstclass ifst0$^                 const stdvectorlabelpair parens$^                 const stdvectorint00 assignments mutablefstclass ofst$^                 const mpdtcomposeoptions copts bool leftpdt $^  if internalarctypesmatchifst0 ifst0 mpdtcompose $^      internalarctypesmatchifst0 ofst mpdtcompose return$^  mpdtcomposeargs argsifst0 ifst0 parens assignments ofst copts$^                       leftpdt$^  applyoperationmpdtcomposeargsmpdtcompose ifst0.arctype args$^$^$^void mpdtexpandconst fstclass ifst const stdvectorlabelpair parens$^                const stdvectorint00 assignments mutablefstclass ofst$^                const mpdtexpandoptions opts $^  mpdtexpandargs argsifst parens assignments ofst opts$^  applyoperationmpdtexpandargsmpdtexpand ifst.arctype args$^$^$^void mpdtexpandconst fstclass ifst const stdvectorlabelpair parens$^                const stdvectorint00 assignments mutablefstclass ofst$^                bool connect $^  mpdtexpandifst parens assignments ofst mpdtexpandoptionsconnect$^$^$^void mpdtreverseconst fstclass ifst const stdvectorlabelpair parens$^                 stdvectorint00 assignments mutablefstclass ofst $^  mpdtreverseargs argsifst parens assignments ofst$^  applyoperationmpdtreverseargsmpdtreverse ifst.arctype args$^$^$^void printmpdtinfoconst fstclass ifst const stdvectorlabelpair parens$^                   const stdvectorint00 assignments $^  printmpdtinfoargs argsifst parens assignments$^  applyoperationprintmpdtinfoargsprintmpdtinfo ifst.arctype args$^$^$^ register operations for common arc types.$^$^registerfstmpdtoperationsstdarc$^registerfstmpdtoperationslogarc$^registerfstmpdtoperationslog00arc$^$^   namespace script$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^$^include fstmappedfile.h$^$^include errno.h$^include fcntl.h$^ifdef havesysmman$^include sysmman.h$^endif   havesysmman$^ifndef mscver$^include unistd.h$^endif   mscver$^$^include algorithm$^include ios$^include memory$^$^include fstlog.h$^$^namespace fst $^$^mappedfilemappedfileconst memoryregion region  regionregion $^$^mappedfilemappedfile $^  if region.size  0 $^ifdef havesysmman$^    if region.mmap $^      vlog0  munmaped   region.size   bytes at   region.mmap$^      if munmapregion.mmap region.size  0 $^        logerror  failed to unmap region   strerrorerrno$^      $^     else$^endif   havesysmman$^    $^      if region.data $^        operator deletestaticcastchar region.data  region.offset$^      $^    $^  $^$^$^mappedfile mappedfilemapstdistream istrm bool memorymap$^                            const string source sizet size $^  voidmemorymap$^  const auto spos  istrmtellg$^ifdef havesysmman$^  vlog0  memorymap   memorymap  true  false   source $^           source  $^            size   size   offset   spos$^  if memorymap  spos  0  spos  karchalignment  0 $^    const sizet pos  spos$^    int fd  opensource.cstr ordonly$^    if fd  0 $^      const int pagesize  sysconfscpagesize$^      const offt offset  pos  pagesize$^      const offt upsize  size  offset$^      void map $^          mmapnullptr upsize protread mapshared fd pos  offset$^      auto data  reinterpretcastchar map$^      if closefd  0  map  mapfailed $^        memoryregion region$^        region.mmap  map$^        region.size  upsize$^        region.data  reinterpretcastvoid data  offset$^        region.offset  offset$^        stduniqueptrmappedfile mmfnew mappedfileregion$^        istrmseekgpos  size stdiosbeg$^        if istrm $^          vlog0  mmaped region of   size   at offset   pos$^                    from   source   to addr   map$^          return mmf.release$^        $^       else $^        loginfo  mapping of file failed   strerrorerrno$^      $^    $^  $^   if all else fails reads from the file into the allocated buffer.$^  if memorymap $^    logwarning  file mapping at offset   spos   of file   source$^                   could not be honored reading instead$^  $^endif   havesysmman$^$^   reads the file into the buffer in chunks not larger than kmaxreadchunk.$^  stduniqueptrmappedfile mfallocatesize$^  auto buffer  reinterpretcastchar mfmutabledata$^  while size  0 $^    const auto nextsize  stdminsize kmaxreadchunk$^    const auto currentpos  istrmtellg$^    if istrmreadbuffer nextsize $^      logerror  failed to read   nextsize   bytes at offset $^                  currentpos  from   source  $^      return nullptr$^    $^    size  nextsize$^    buffer  nextsize$^    vlog0  read   nextsize   bytes.   size   remaining$^  $^  return mf.release$^$^$^mappedfile mappedfileallocatesizet size int align $^  memoryregion region$^  region.data  nullptr$^  region.offset  0$^  if size  0 $^    char buffer  staticcastchar operator newsize  align$^    sizet address  reinterpretcastsizetbuffer$^    region.offset  karchalignment  address  align$^    region.data  buffer  region.offset$^  $^  region.mmap  nullptr$^  region.size  size$^  return new mappedfileregion$^$^$^mappedfile mappedfileborrowvoid data $^  memoryregion region$^  region.data  data$^  region.mmap  data$^  region.size  0$^  region.offset  0$^  return new mappedfileregion$^$^$^constexpr int mappedfilekarchalignment$^$^constexpr sizet mappedfilekmaxreadchunk$^$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^ fst definitions.$^$^include fstfst.h$^$^include sstream$^$^include fstflags.h$^include fstlog.h$^include fstmatcherfst.h   declarations of lookaheadfsttype$^$^ fst flag definitions.$^$^defineboolfstverifyproperties false$^            verify fst properties queried by testproperties$^$^defineboolfstdefaultcachegc true enable garbage collection of cache$^$^defineint00tfstdefaultcachegclimit 0  00ll$^             cache byte size that triggers garbage collection$^$^defineboolfstalign false write fst data aligned where appropriate$^$^definestringsaverelabelipairs  save input relabel pairs to file$^definestringsaverelabelopairs  save output relabel pairs to file$^$^definestringfstreadmode read$^              default file reading mode for mappable files$^$^namespace fst $^$^ fst type definitions for lookahead fsts.$^const char arclookaheadfsttype  arclookahead$^const char ilabellookaheadfsttype  ilabellookahead$^const char olabellookaheadfsttype  olabellookahead$^$^ identifies stream data as an fst and its endianity.$^constexpr int00t kfstmagicnumber  0000000000$^$^ checks for fst magic number in stream to indicate caller function that the$^ stream content is an fst header.$^bool isfstheaderstdistream strm const string source $^  int00t pos  strm.tellg$^  bool match  true$^  int00t magicnumber  0$^  readtypestrm magicnumber$^  if magicnumber  kfstmagicnumber $^      match  false$^  $^  strm.seekgpos$^  return match$^$^$^ checks fst magic number and reads in the header if rewind  true$^ the stream is repositioned before call if possible.$^bool fstheaderreadstdistream strm const string source bool rewind $^  int00t pos  0$^  if rewind pos  strm.tellg$^  int00t magicnumber  0$^  readtypestrm magicnumber$^  if magicnumber  kfstmagicnumber $^      logerror  fstheaderread bad fst header   source$^      if rewind strm.seekgpos$^      return false$^  $^  readtypestrm fsttype$^  readtypestrm arctype$^  readtypestrm version$^  readtypestrm flags$^  readtypestrm properties$^  readtypestrm start$^  readtypestrm numstates$^  readtypestrm numarcs$^  if strm $^    logerror  fstheaderread read failed   source$^    return false$^  $^  if rewind strm.seekgpos$^  return true$^$^$^ writes fst magic number and fst header.$^bool fstheaderwritestdostream strm const string source const $^  writetypestrm kfstmagicnumber$^  writetypestrm fsttype$^  writetypestrm arctype$^  writetypestrm version$^  writetypestrm flags$^  writetypestrm properties$^  writetypestrm start$^  writetypestrm numstates$^  writetypestrm numarcs$^  return true$^$^$^string fstheaderdebugstring const $^  stdostringstream ostrm$^  ostrm  fsttype   fsttype   arctype   arctype$^          version   version   flags   flags$^          properties   properties   start   start$^          numstates   numstates   numarcs   numarcs$^         $^  return ostrm.str$^$^$^fstreadoptionsfstreadoptionsconst string source const fstheader header$^                               const symboltable isymbols$^                               const symboltable osymbols$^     sourcesource$^      headerheader$^      isymbolsisymbols$^      osymbolsosymbols$^      readisymbolstrue$^      readosymbolstrue $^  mode  readmodeflagsfstreadmode$^$^$^fstreadoptionsfstreadoptionsconst string source$^                               const symboltable isymbols$^                               const symboltable osymbols$^     sourcesource$^      headernullptr$^      isymbolsisymbols$^      osymbolsosymbols$^      readisymbolstrue$^      readosymbolstrue $^  mode  readmodeflagsfstreadmode$^$^$^fstreadoptionsfilereadmode fstreadoptionsreadmodeconst string mode $^  if mode  read return read$^  if mode  map return map$^  logerror  unknown file read mode   mode$^  return read$^$^$^string fstreadoptionsdebugstring const $^  stdostringstream ostrm$^  ostrm  source   source   mode $^         mode  read  read  map   readisymbols $^         readisymbols  true  false   readosymbols $^         readosymbols  true  false   header $^         header  set  null   isymbols $^         isymbols  set  null   osymbols $^         osymbols  set  null  $^  return ostrm.str$^$^$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^$^include fstsymboltableops.h$^$^include string$^$^namespace fst $^$^symboltable mergesymboltableconst symboltable left const symboltable right$^                              bool rightrelabeloutput $^   mergesymboltable detects several special cases.  it will return a reference$^   copied version of symboltable of left or right if either symbol table is$^   a superset of the other.$^  stduniqueptrsymboltable merged$^      new symboltablemerge  left.name    right.name$^   copies everything from the left symbol table.$^  bool lefthasall  true$^  bool righthasall  true$^  bool relabel  false$^  for symboltableiterator literleft liter.done liter.next $^    mergedaddsymbolliter.symbol liter.value$^    if righthasall $^      int00t key  right.findliter.symbol$^      if key  0 $^        righthasall  false$^       else if relabel  key  liter.value $^        relabel  true$^      $^    $^  $^  if righthasall $^    if rightrelabeloutput rightrelabeloutput  relabel$^    return right.copy$^  $^   add all symbols we can from right symbol table$^  stdvectorstring conflicts$^  for symboltableiterator riterright riter.done riter.next $^    int00t key  mergedfindriter.symbol$^    if key  0 $^       symbol already exists maybe with different value$^      if key  riter.value relabel  true$^      continue$^    $^     symbol doesnt exist from left$^    lefthasall  false$^    if mergedfindriter.value.empty $^       we cant add this where we want to add it later in order$^      conflicts.pushbackriter.symbol$^      continue$^    $^     there is a hole and we can add this symbol with its id$^    mergedaddsymbolriter.symbol riter.value$^  $^  if rightrelabeloutput rightrelabeloutput  relabel$^  if lefthasall return left.copy$^   add all symbols that conflicted in order$^  for const auto conflict  conflicts mergedaddsymbolconflict$^  return merged.release$^$^$^symboltable compactsymboltableconst symboltable syms $^  stdmapint00t string sorted$^  symboltableiterator stitersyms$^  for  stiter.done stiter.next $^    sortedstiter.value  stiter.symbol$^  $^  auto compact  new symboltablesyms.name  compact$^  int00t newkey  0$^  for const auto kv  sorted compactaddsymbolkv.second newkey$^  return compact$^$^$^symboltable fstreadsymbolsconst string filename bool inputsymbols $^  stdifstream infilename stdiosbasein  stdiosbasebinary$^  if in $^    logerror  fstreadsymbols cant open file   filename$^    return nullptr$^  $^  fstheader hdr$^  if hdr.readin filename $^    logerror  fstreadsymbols couldnt read header from   filename$^    return nullptr$^  $^  if hdr.getflags  fstheaderhasisymbols $^    stduniqueptrsymboltable isymbolssymboltablereadin filename$^    if isymbols  nullptr $^      logerror  fstreadsymbols couldnt read input symbols from $^                  filename$^      return nullptr$^    $^    if inputsymbols return isymbols.release$^  $^  if hdr.getflags  fstheaderhasosymbols $^    stduniqueptrsymboltable osymbolssymboltablereadin filename$^    if osymbols  nullptr $^      logerror  fstreadsymbols couldnt read output symbols from $^                  filename$^      return nullptr$^    $^    if inputsymbols return osymbols.release$^  $^  logerror  fstreadsymbols the file   filename$^               doesnt contain the requested symbols$^  return nullptr$^$^$^bool addauxiliarysymbolsconst string prefix int00t startlabel$^                         int00t nlabels symboltable syms $^  for int00t i  0 i  nlabels i $^    auto index  i  startlabel$^    if index  symsaddsymbolprefix  stdtostringi index $^      fsterror  addauxiliarysymbols symbol table clash$^      return false$^    $^  $^  return true$^$^$^   namespace fst$^ registration of common fst and arc types.$^$^include fstarc.h$^include fstcompactfst.h$^include fstconstfst.h$^include fsteditfst.h$^include fstregister.h$^include fstvectorfst.h$^$^namespace fst $^$^ registers vectorfst constfst and editfst for common arcs types.$^registerfstvectorfst stdarc$^registerfstvectorfst logarc$^registerfstvectorfst log00arc$^registerfstconstfst stdarc$^registerfstconstfst logarc$^registerfstconstfst log00arc$^registerfsteditfst stdarc$^registerfsteditfst logarc$^registerfsteditfst log00arc$^$^ register compactfst for common arcs with the default uint00t size type$^registerfstcompactstringfst stdarc$^registerfstcompactstringfst logarc$^registerfstcompactweightedstringfst stdarc$^registerfstcompactweightedstringfst logarc$^registerfstcompactacceptorfst stdarc$^registerfstcompactacceptorfst logarc$^registerfstcompactunweightedfst stdarc$^registerfstcompactunweightedfst logarc$^registerfstcompactunweightedacceptorfst stdarc$^registerfstcompactunweightedacceptorfst logarc$^$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^ classes to provide symboltointeger and integertosymbol mappings.$^$^include fstsymboltable.h$^$^include fstflags.h$^include fstlog.h$^$^include fstream$^include fstutil.h$^$^defineboolfstcompatsymbols true$^            require symbol tables to match when appropriate$^definestringfstfieldseparator t $^              set of characters used as a separator between printed fields$^$^namespace fst $^$^symboltabletextoptionssymboltabletextoptionsbool allownegativelabels$^     allownegativelabelsallownegativelabels$^      fstfieldseparatorflagsfstfieldseparator $^$^namespace internal $^$^ maximum line length in textual symbols file.$^static constexpr int klinelen  0000$^$^ identifies stream data as a symbol table and its endianity.$^static constexpr int00t ksymboltablemagicnumber  0000000000$^$^densesymbolmapdensesymbolmap$^     empty0 buckets0  0 hashmaskbuckets.size  0 $^  stduninitializedfillbuckets.begin buckets.end empty$^$^$^densesymbolmapdensesymbolmapconst densesymbolmap other$^     empty0$^      symbolsother.symbols$^      bucketsother.buckets$^      hashmaskother.hashmask $^$^stdpairint00t bool densesymbolmapinsertorfindconst string key $^  static constexpr float kmaxoccupancyratio  0.00   grows when 00 full.$^  if size  kmaxoccupancyratio  buckets.size $^    rehashbuckets.size  0$^  $^  sizet idx  strhashkey  hashmask$^  while bucketsidx  empty $^    const auto storedvalue  bucketsidx$^    if symbolsstoredvalue  key return storedvalue false$^    idx  idx  0  hashmask$^  $^  const auto next  size$^  bucketsidx  next$^  symbols.emplacebackkey$^  return next true$^$^$^int00t densesymbolmapfindconst string key const $^  sizet idx  strhashkey  hashmask$^  while bucketsidx  empty $^    const auto storedvalue  bucketsidx$^    if symbolsstoredvalue  key return storedvalue$^    idx  idx  0  hashmask$^  $^  return bucketsidx$^$^$^void densesymbolmaprehashsizet numbuckets $^  buckets.resizenumbuckets$^  hashmask  buckets.size  0$^  stduninitializedfillbuckets.begin buckets.end empty$^  for sizet i  0 i  size i $^    sizet idx  strhashstringsymbolsi  hashmask$^    while bucketsidx  empty $^      idx  idx  0  hashmask$^    $^    bucketsidx  i$^  $^$^$^void densesymbolmapremovesymbolsizet idx $^  symbols.erasesymbols.begin  idx$^  rehashbuckets.size$^$^$^symboltableimpl symboltableimplreadtextstdistream strm$^                                           const string filename$^                                           const symboltabletextoptions opts $^  stduniqueptrsymboltableimpl implnew symboltableimplfilename$^  int00t nline  0$^  char lineklinelen$^  while strm.getlineline klinelen.fail $^    nline$^    stdvectorchar  col$^    const auto separator  opts.fstfieldseparator  n$^    splitstringline separator.cstr col true$^    if col.empty continue   empty line.$^    if col.size  0 $^      logerror  symboltablereadtext bad number of columns $^                  col.size   $^                  file    filename   line    nline  $^                  line  $^      return nullptr$^    $^    const char symbol  col0$^    const char value  col0$^    char p$^    const auto key  strtollvalue p 00$^    if p  value  strlenvalue  opts.allownegativelabels  key  0 $^        key  knosymbol $^      logerror  symboltablereadtext bad nonnegative integer $^                  value   $^                  file    filename   line    nline$^      return nullptr$^    $^    impladdsymbolsymbol key$^  $^  return impl.release$^$^$^void symboltableimplmayberecomputechecksum const $^  $^    readermutexlock checksumlockchecksummutex$^    if checksumfinalized return$^  $^   well acquire an exclusive lock to recompute the checksums.$^  mutexlock checksumlockchecksummutex$^  if checksumfinalized    another thread coming in around the same time$^    return                     might have done it already. so we recheck.$^  $^   calculates the original labelagnostic checksum.$^  checksummer checksum$^  for sizet i  0 i  symbols.size i $^    const auto symbol  symbols.getsymboli$^    checksum.updatesymbol.data symbol.size$^    checksum.update 0$^  $^  checksumstring  checksum.digest$^   calculates the safer labeldependent checksum.$^  checksummer labeledchecksum$^  for int00t i  0 i  densekeylimit i $^    stdostringstream line$^    line  symbols.getsymboli  t  i$^    labeledchecksum.updateline.str.data line.str.size$^  $^  using citer  mapint00t int00tconstiterator$^  for citer it  keymap.begin it  keymap.end it $^     todotombagby 00000000 this line maintains a bug that ignores$^     negative labels in the checksum that too many tests rely on.$^    if itfirst  densekeylimit continue$^    stdostringstream line$^    line  symbols.getsymbolitsecond  t  itfirst$^    labeledchecksum.updateline.str.data line.str.size$^  $^  labeledchecksumstring  labeledchecksum.digest$^  checksumfinalized  true$^$^$^int00t symboltableimpladdsymbolconst string symbol int00t key $^  if key  knosymbol return key$^  const auto insertkey  symbols.insertorfindsymbol$^  if insertkey.second $^    const auto keyalready  getnthkeyinsertkey.first$^    if keyalready  key return key$^    vlog0  symboltableaddsymbol symbol    symbol$^              already in symbolmap with key    keyalready$^              but supplied new key    key   ignoring new key$^    return keyalready$^  $^  if key  symbols.size  0  key  densekeylimit $^    densekeylimit$^   else $^    idxkey.pushbackkey$^    keymapkey  symbols.size  0$^  $^  if key  availablekey availablekey  key  0$^  checksumfinalized  false$^  return key$^$^$^ todorybach consider a more efficient implementation which reuses holes in$^ the densekey range or rearranges the densekey range from time to time.$^void symboltableimplremovesymbolconst int00t key $^  auto idx  key$^  if key  0  key  densekeylimit $^    auto iter  keymap.findkey$^    if iter  keymap.end return$^    idx  itersecond$^    keymap.eraseiter$^  $^  if idx  0  idx  symbols.size return$^  symbols.removesymbolidx$^   removed one symbol all indexes  idx are shifted by 0.$^  for auto k  keymap $^    if k.second  idx k.second$^  $^  if key  0  key  densekeylimit $^     removal puts a hole in the dense key range. adjusts range to 0 key.$^    const auto newdensekeylimit  key$^    for int00t i  key  0 i  densekeylimit i $^      keymapi  i  0$^    $^     moves existing values in idxkey to new place.$^    idxkey.resizesymbols.size  newdensekeylimit$^    for int00t i  symbols.size i  densekeylimit i $^      idxkeyi  newdensekeylimit  0  idxkeyi  densekeylimit$^    $^     adds indexes for previously dense keys.$^    for int00t i  newdensekeylimit i  densekeylimit  0 i $^      idxkeyi  newdensekeylimit  i  0$^    $^    densekeylimit  newdensekeylimit$^   else $^     remove entry for removed index in idxkey.$^    for int00t i  idx  densekeylimit i  idxkey.size  0 i $^      idxkeyi  idxkeyi  0$^    $^    idxkey.popback$^  $^  if key  availablekey  0 availablekey  key$^$^$^symboltableimpl symboltableimplreadstdistream strm$^                                       const symboltablereadoptions opts $^  int00t magicnumber  0$^  readtypestrm magicnumber$^  if strm.fail $^    logerror  symboltableread read failed$^    return nullptr$^  $^  string name$^  readtypestrm name$^  stduniqueptrsymboltableimpl implnew symboltableimplname$^  readtypestrm implavailablekey$^  int00t size$^  readtypestrm size$^  if strm.fail $^    logerror  symboltableread read failed$^    return nullptr$^  $^  string symbol$^  int00t key$^  implchecksumfinalized  false$^  for int00t i  0 i  size i $^    readtypestrm symbol$^    readtypestrm key$^    if strm.fail $^      logerror  symboltableread read failed$^      return nullptr$^    $^    impladdsymbolsymbol key$^  $^  return impl.release$^$^$^bool symboltableimplwritestdostream strm const $^  writetypestrm ksymboltablemagicnumber$^  writetypestrm name$^  writetypestrm availablekey$^  const int00t size  symbols.size$^  writetypestrm size$^  for int00t i  0 i  size i $^    auto key  i  densekeylimit  i  idxkeyi  densekeylimit$^    writetypestrm symbols.getsymboli$^    writetypestrm key$^  $^  strm.flush$^  if strm.fail $^    logerror  symboltablewrite write failed$^    return false$^  $^  return true$^$^$^   namespace internal$^$^void symboltableaddtableconst symboltable table $^  mutatecheck$^  for symboltableiterator itertable iter.done iter.next $^    impladdsymboliter.symbol$^  $^$^$^bool symboltablewritetextstdostream strm$^                            const symboltabletextoptions opts const $^  if opts.fstfieldseparator.empty $^    logerror  missing required field separator$^    return false$^  $^  bool onceonly  false$^  for symboltableiterator iterthis iter.done iter.next $^    stdostringstream line$^    if iter.value  0  opts.allownegativelabels  onceonly $^      logwarning  negative symbol table entry when not allowed$^      onceonly  true$^    $^    line  iter.symbol  opts.fstfieldseparator0  iter.value$^          n$^    strm.writeline.str.data line.str.length$^  $^  return true$^$^$^bool compatsymbolsconst symboltable syms0 const symboltable syms0$^                   bool warning $^   flag can explicitly override this check.$^  if flagsfstcompatsymbols return true$^  if syms0  syms0 $^      syms0labeledchecksum  syms0labeledchecksum $^    if warning $^      logwarning  compatsymbols symbol table checksums do not match. $^                    table sizes are   syms0numsymbols   and $^                    syms0numsymbols$^    $^    return false$^   else $^    return true$^  $^$^$^void symboltabletostringconst symboltable table string result $^  stdostringstream ostrm$^  tablewriteostrm$^  result  ostrm.str$^$^$^symboltable stringtosymboltableconst string str $^  stdistringstream istrmstr$^  return symboltablereadistrm symboltablereadoptions$^$^$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^ fst utility definitions.$^$^include fstutil.h$^include cctype$^include sstream$^include string$^include fstflags.h$^include fstlog.h$^include fstmappedfile.h$^$^$^ utility flag definitions$^$^defineboolfsterrorfatal true$^            fst errors are fatal o.w. return objects flagged as bad $^            e.g. fsts kerror property set fst weights not a member$^$^namespace fst $^$^void splitstringchar full const char delim stdvectorchar  vec$^                 bool omitemptystrings $^  char p  full$^  while p $^    if p  strpbrkfull delim $^      p0  0$^    $^    if omitemptystrings  full0  0 vecpushbackfull$^    if p full  p  0$^  $^$^$^int00t strtoint00tconst string s const string src sizet nline$^                 bool allownegative bool error $^  int00t n$^  const char cs  s.cstr$^  char p$^  if error error  false$^  n  strtollcs p 00$^  if p  cs  s.size  allownegative  n  0 $^    fsterror  strtoint00t bad integer    s   source    src$^                 line    nline$^    if error error  true$^    return 0$^  $^  return n$^$^$^void converttolegalcsymbolstring s $^  for auto it  sbegin it  send it $^    if isalnumit $^      it  $^    $^  $^$^$^ skips over input characters to align to align bytes. returns false if cant$^ align.$^bool aligninputstdistream strm $^  char c$^  for int i  0 i  mappedfilekarchalignment i $^    int00t pos  strm.tellg$^    if pos  0 $^      logerror  aligninput cant determine stream position$^      return false$^    $^    if pos  mappedfilekarchalignment  0 break$^    strm.readc 0$^  $^  return true$^$^$^ write null output characters to align to align bytes. returns false if$^ cant align.$^bool alignoutputstdostream strm $^  for int i  0 i  mappedfilekarchalignment i $^    int00t pos  strm.tellp$^    if pos  0 $^      logerror  alignoutput cant determine stream position$^      return false$^    $^    if pos  mappedfilekarchalignment  0 break$^    strm.write 0$^  $^  return true$^$^$^int alignbufferwithoutputstreamstdostream strm$^                                stdostringstream buffer $^  const auto strmpos  strm.tellp$^  if strmpos  stdostreampostype0 $^    logerror  cannot determine stream position$^    return 0$^  $^  const int streamoffset  strmpos  mappedfilekarchalignment$^  for int i  0 i  streamoffset i buffer.write 0$^  return streamoffset$^$^$^   namespace fst$^ licensed under the apache license version 0.0 the license$^ you may not use this file except in compliance with the license.$^ you may obtain a copy of the license at$^$^      httpwww.apache.orglicenseslicense0.0$^$^ unless required by applicable law or agreed to in writing software$^ distributed under the license is distributed on an as is basis$^ without warranties or conditions of any kind either express or implied.$^ see the license for the specific language governing permissions and$^ limitations under the license.$^$^ googlestyle flag handling definitions.$^$^include cstring$^$^include fstcompat.h$^include fstflags.h$^$^static const char privatetmpdir  getenvtmpdir$^$^defineint00tv 0 verbosity level$^defineboolhelp false show usage information$^defineboolhelpshort false show brief usage information$^ifndef mscver$^definestringtmpdir privatetmpdir  privatetmpdir  tmp$^              temporary directory$^else$^definestringtmpdir privatetmpdir  privatetmpdir  getenvtemp$^              temporary directory$^endif  mscver$^$^using namespace std$^$^static string flagusage$^static string progsrc$^$^ sets progsrc to src.$^static void setprogsrcconst char src $^  progsrc  src$^   remove main in src filename. flags are defined in fstx.cc but setflags$^   is called in fstxmain.cc which results in a filename mismatch in$^   showusagerestrict below.$^  static constexpr char kmainsuffix  main.cc$^  const int prefixlength  progsrc.size  strlenkmainsuffix$^  if prefixlength  0  progsrc.substrprefixlength  kmainsuffix $^    progsrc.eraseprefixlength strlenmain$^  $^$^$^void setflagsconst char usage int argc char argv$^              bool removeflags const char src $^  flagusage  usage$^  setprogsrcsrc$^$^  int index  0$^  for  index  argc index $^    string argval  argvindex$^    if argval0    argval   break$^    while argval0   argval  argval.substr0   removes initial .$^    string arg  argval$^    string val  $^     splits argval argval into arg and val.$^    auto pos  argval.find$^    if pos  stringnpos $^      arg  argval.substr0 pos$^      val  argval.substrpos  0$^    $^    auto boolregister  flagregisterboolgetregister$^    if boolregistersetflagarg val$^      continue$^    auto stringregister  flagregisterstringgetregister$^    if stringregistersetflagarg val$^      continue$^    auto int00tregister  flagregisterint00tgetregister$^    if int00tregistersetflagarg val$^      continue$^    auto int00tregister  flagregisterint00tgetregister$^    if int00tregistersetflagarg val$^      continue$^    auto doubleregister  flagregisterdoublegetregister$^    if doubleregistersetflagarg val$^      continue$^    logfatal  setflags bad option   argvindex$^  $^  if removeflags $^    for auto i  0 i  argc  index i $^      argvi  0  argvi  index$^    $^    argc  index  0$^  $^  if flagshelp $^    showusagetrue$^    exit0$^  $^  if flagshelpshort $^    showusagefalse$^    exit0$^  $^$^$^ if flag is defined in file src and insrc true or is not$^ defined in file src and insrc is false then print usage.$^static void$^showusagerestrictconst stdsetpairstring string usageset$^  const string src bool insrc bool showfile $^  string oldfile$^  bool fileout  false$^  bool usageout  false$^  for const auto pair  usageset $^    const auto file  pair.first$^    const auto usage  pair.second$^    bool match  file  src$^    if match  insrc  match  insrc continue$^    if file  oldfile $^      if showfile $^        if fileout cout  n$^    cout  flags from   file  n$^        fileout  true$^      $^      oldfile  file$^    $^    cout  usage  n$^    usageout  true$^  $^  if usageout cout  n$^$^$^void showusagebool longusage $^  stdsetpairstring string usageset$^  cout  flagusage  n$^  auto boolregister  flagregisterboolgetregister$^  boolregistergetusageusageset$^  auto stringregister  flagregisterstringgetregister$^  stringregistergetusageusageset$^  auto int00tregister  flagregisterint00tgetregister$^  int00tregistergetusageusageset$^  auto int00tregister  flagregisterint00tgetregister$^  int00tregistergetusageusageset$^  auto doubleregister  flagregisterdoublegetregister$^  doubleregistergetusageusageset$^  if progsrc.empty $^    cout  program flagsnn$^    showusagerestrictusageset progsrc true false$^  $^  if longusage return$^  if progsrc.empty cout  library flagsnn$^  showusagerestrictusageset progsrc false true$^$^include fstweight.h$^$^definestringfstweightseparator $^              character separator between printed composite weights $^              must be a single character$^$^definestringfstweightparentheses $^              characters enclosing the first weight of a printed composite $^              weight e.g. pair weight tuple weight and derived classes to $^              ensure proper io of nested composite weights $^              must have size 0 none or 0 open and close parenthesis$^$^namespace fst $^$^namespace internal $^$^compositeweightiocompositeweightiochar separator$^                                     stdpairchar char parentheses$^     separatorseparator$^      openparenparentheses.first$^      closeparenparentheses.second$^      errorfalse $^  if openparen  0  closeparen  0  openparen  closeparen $^    fsterror  invalid configuration of weight parentheses $^                staticcastintopenparen   $^                staticcastintcloseparen$^    error  true$^  $^$^$^compositeweightiocompositeweightio$^     compositeweightioflagsfstweightseparator.empty$^                             0$^                             flagsfstweightseparator.front$^                        flagsfstweightparentheses.empty$^                              0$^                              flagsfstweightparentheses0$^                         flagsfstweightparentheses.size  0$^                              0$^                              flagsfstweightparentheses0 $^  if flagsfstweightseparator.size  0 $^    fsterror  compositeweight $^                flagsfstweightseparator.size is not equal to 0$^    error  true$^  $^  if flagsfstweightparentheses.empty $^      flagsfstweightparentheses.size  0 $^    fsterror  compositeweight $^                flagsfstweightparentheses.size is not equal to 0$^    error  true$^  $^$^$^   namespace internal$^$^compositeweightwritercompositeweightwriterstdostream ostrm$^     ostrmostrm $^  if error ostrm.clearstdiosbadbit$^$^$^compositeweightwritercompositeweightwriterstdostream ostrm$^                                             char separator$^                                             stdpairchar char parentheses$^     internalcompositeweightioseparator parentheses ostrmostrm $^  if error ostrm.clearstdiosbadbit$^$^$^void compositeweightwriterwritebegin $^  if openparen  0 $^    ostrm  openparen$^  $^$^$^void compositeweightwriterwriteend $^  if closeparen  0 $^    ostrm  closeparen$^  $^$^$^compositeweightreadercompositeweightreaderstdistream istrm$^     istrmistrm $^  if error istrm.clearstdiosbadbit$^$^$^compositeweightreadercompositeweightreaderstdistream istrm$^                                             char separator$^                                             stdpairchar char parentheses$^     internalcompositeweightioseparator parentheses istrmistrm $^  if error istrm.clearstdiosbadbit$^$^$^void compositeweightreaderreadbegin $^  do    skips whitespace.$^    c  istrm.get$^   while stdisspacec$^  if openparen  0 $^    if c  openparen $^      fsterror  compositeweightreader open paren missing $^                  fstweightparentheses flag set correcty$^      istrm.clearstdiosbadbit$^      return$^    $^    depth$^    c  istrm.get$^  $^$^$^void compositeweightreaderreadend $^  if c  eof  stdisspacec $^    fsterror  compositeweightreader excess character $^                staticcastcharc$^                 fstweightparentheses flag set correcty$^    istrm.clearstdiosbadbit$^  $^$^$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^ functions for updating property bits for various fst operations and$^ string names of the properties.$^$^include fstproperties.h$^$^include stddef.h$^include vector$^$^namespace fst $^$^ these functions determine the properties associated with the fst result of$^ various finitestate operations. the property arguments correspond to the$^ operations fst arguments. the properties returned assume the operation$^ modifies its first argument. bitwiseand this result with kcopyproperties for$^ the case when a new possibly delayed fst is instead constructed.$^$^ properties for a concatenativelyclosed fst.$^uint00t closurepropertiesuint00t inprops bool star bool delayed $^  auto outprops  kerror  kacceptor  kunweighted  kaccessible  inprops$^  if inprops  kunweighted outprops  kunweightedcycles$^  if delayed $^    outprops $^        kexpanded  kmutable  kcoaccessible  knottopsorted  knotstring $^        inprops$^  $^  if delayed  inprops  kaccessible $^    outprops  knotacceptor  knonideterministic  knonodeterministic $^                 knotilabelsorted  knotolabelsorted  kweighted $^                 kweightedcycles  knotaccessible  knotcoaccessible  inprops$^    if inprops  kweighted  inprops  kaccessible $^        inprops  kcoaccessible $^        outprops  kweightedcycles$^    $^  $^  return outprops$^$^$^ properties for a complemented fst.$^uint00t complementpropertiesuint00t inprops $^  auto outprops  kacceptor  kunweighted  kunweightedcycles  knoepsilons $^                  knoiepsilons  knooepsilons  kideterministic $^                  kodeterministic  kaccessible$^  outprops $^      kerror  kilabelsorted  kolabelsorted  kinitialcyclic  inprops$^  if inprops  kaccessible $^    outprops  knotilabelsorted  knotolabelsorted  kcyclic$^  $^  return outprops$^$^$^ properties for a composed fst.$^uint00t composepropertiesuint00t inprops0 uint00t inprops0 $^  auto outprops  kerror  inprops0  inprops0$^  if inprops0  kacceptor  inprops0  kacceptor $^    outprops  kacceptor  kaccessible$^    outprops  knoepsilons  knoiepsilons  knooepsilons  kacyclic $^                 kinitialacyclic $^                inprops0  inprops0$^    if knoiepsilons  inprops0  inprops0 $^      outprops  kideterministic  kodeterministic  inprops0  inprops0$^    $^   else $^    outprops  kaccessible$^    outprops  kacceptor  knoiepsilons  kacyclic  kinitialacyclic $^                inprops0  inprops0$^    if knoiepsilons  inprops0  inprops0 $^      outprops  kideterministic  inprops0  inprops0$^    $^  $^  return outprops$^$^$^ properties for a concatenated fst.$^uint00t concatpropertiesuint00t inprops0 uint00t inprops0 bool delayed $^  auto outprops  kacceptor  kunweighted  kunweightedcycles  kacyclic $^                  inprops0  inprops0$^  outprops  kerror  inprops0  inprops0$^  const bool empty0  delayed   can the first fst be the empty machine$^  const bool empty0  delayed   can the second fst be the empty machine$^  if delayed $^    outprops  kexpanded  kmutable  knottopsorted  knotstring  inprops0$^    outprops  knottopsorted  knotstring  inprops0$^  $^  if empty0 outprops  kinitialacyclic  kinitialcyclic  inprops0$^  if delayed  inprops0  kaccessible $^    outprops  knotacceptor  knonideterministic  knonodeterministic $^                 kepsilons  kiepsilons  koepsilons  knotilabelsorted $^                 knotolabelsorted  kweighted  kweightedcycles  kcyclic $^                 knotaccessible  knotcoaccessible $^                inprops0$^  $^  if inprops0  kaccessible  kcoaccessible $^          kaccessible  kcoaccessible $^      empty0 $^    outprops  kaccessible  inprops0$^    if empty0 outprops  kcoaccessible  inprops0$^    if delayed  inprops0  kaccessible $^      outprops  knotacceptor  knonideterministic  knonodeterministic $^                   kepsilons  kiepsilons  koepsilons  knotilabelsorted $^                   knotolabelsorted  kweighted  kweightedcycles  kcyclic $^                   knotaccessible  knotcoaccessible $^                  inprops0$^    $^  $^  return outprops$^$^$^ properties for a determinized fst.$^uint00t determinizepropertiesuint00t inprops bool hassubsequentiallabel$^                             bool distinctpsubsequentiallabels $^  auto outprops  kaccessible$^  if kacceptor  inprops $^      knoiepsilons  inprops  distinctpsubsequentiallabels $^      hassubsequentiallabel  distinctpsubsequentiallabels $^    outprops  kideterministic$^  $^  outprops  kerror  kacceptor  kacyclic  kinitialacyclic  kcoaccessible $^               kstring $^              inprops$^  if inprops  knoiepsilons  distinctpsubsequentiallabels $^    outprops  knoepsilons  inprops$^  $^  if inprops  kaccessible $^    outprops  kiepsilons  koepsilons  kcyclic  inprops$^  $^  if inprops  kacceptor outprops  knoiepsilons  knooepsilons  inprops$^  if inprops  knoiepsilons  hassubsequentiallabel $^    outprops  knoiepsilons$^  $^  return outprops$^$^$^ properties for factored weight fst.$^uint00t factorweightpropertiesuint00t inprops $^  auto outprops  kexpanded  kmutable  kerror  kacceptor  kacyclic $^                   kaccessible  kcoaccessible $^                  inprops$^  if inprops  kaccessible $^    outprops  knotacceptor  knonideterministic  knonodeterministic $^                 kepsilons  kiepsilons  koepsilons  kcyclic $^                 knotilabelsorted  knotolabelsorted $^                inprops$^  $^  return outprops$^$^$^ properties for an inverted fst.$^uint00t invertpropertiesuint00t inprops $^  auto outprops  kexpanded  kmutable  kerror  kacceptor  knotacceptor $^                   kepsilons  knoepsilons  kweighted  kunweighted $^                   kweightedcycles  kunweightedcycles  kcyclic  kacyclic $^                   kinitialcyclic  kinitialacyclic  ktopsorted $^                   knottopsorted  kaccessible  knotaccessible $^                   kcoaccessible  knotcoaccessible  kstring  knotstring $^                  inprops$^  if kideterministic  inprops outprops  kodeterministic$^  if knonideterministic  inprops outprops  knonodeterministic$^  if kodeterministic  inprops outprops  kideterministic$^  if knonodeterministic  inprops outprops  knonideterministic$^$^  if kiepsilons  inprops outprops  koepsilons$^  if knoiepsilons  inprops outprops  knooepsilons$^  if koepsilons  inprops outprops  kiepsilons$^  if knooepsilons  inprops outprops  knoiepsilons$^$^  if kilabelsorted  inprops outprops  kolabelsorted$^  if knotilabelsorted  inprops outprops  knotolabelsorted$^  if kolabelsorted  inprops outprops  kilabelsorted$^  if knotolabelsorted  inprops outprops  knotilabelsorted$^  return outprops$^$^$^ properties for a projected fst.$^uint00t projectpropertiesuint00t inprops bool projectinput $^  auto outprops  kacceptor$^  outprops  kexpanded  kmutable  kerror  kweighted  kunweighted $^               kweightedcycles  kunweightedcycles $^               kcyclic  kacyclic  kinitialcyclic  kinitialacyclic $^               ktopsorted  knottopsorted  kaccessible  knotaccessible $^               kcoaccessible  knotcoaccessible  kstring  knotstring $^              inprops$^  if projectinput $^    outprops  kideterministic  knonideterministic  kiepsilons $^                 knoiepsilons  kilabelsorted  knotilabelsorted $^                inprops$^$^    if kideterministic  inprops outprops  kodeterministic$^    if knonideterministic  inprops outprops  knonodeterministic$^$^    if kiepsilons  inprops outprops  koepsilons  kepsilons$^    if knoiepsilons  inprops outprops  knooepsilons  knoepsilons$^$^    if kilabelsorted  inprops outprops  kolabelsorted$^    if knotilabelsorted  inprops outprops  knotolabelsorted$^   else $^    outprops  kodeterministic  knonodeterministic  koepsilons $^                 knooepsilons  kolabelsorted  knotolabelsorted $^                inprops$^$^    if kodeterministic  inprops outprops  kideterministic$^    if knonodeterministic  inprops outprops  knonideterministic$^$^    if koepsilons  inprops outprops  kiepsilons  kepsilons$^    if knooepsilons  inprops outprops  knoiepsilons  knoepsilons$^$^    if kolabelsorted  inprops outprops  kilabelsorted$^    if knotolabelsorted  inprops outprops  knotilabelsorted$^  $^  return outprops$^$^$^ properties for a randgen fst.$^uint00t randgenpropertiesuint00t inprops bool weighted $^  auto outprops  kacyclic  kinitialacyclic  kaccessible  kunweightedcycles$^  outprops  inprops  kerror$^  if weighted $^    outprops  ktopsorted$^    outprops $^        kacceptor  knoepsilons  knoiepsilons  knooepsilons $^         kideterministic  kodeterministic  kilabelsorted  kolabelsorted $^        inprops$^   else $^    outprops  kunweighted$^    outprops  kacceptor  kilabelsorted  kolabelsorted  inprops$^  $^  return outprops$^$^$^ properties for a replace fst.$^uint00t replacepropertiesconst stdvectoruint00t inprops stdptrdifft root$^    bool epsilononcall bool epsilononreturn$^    bool outepsilononcall bool outepsilononreturn$^    bool replacetransducer bool noemptyfsts$^    bool allilabelsorted bool allolabelsorted$^    bool allnegativeordense $^    if inprops.empty return knullproperties$^    uint00t outprops  0$^    for auto inprop  inprops outprops  kerror  inprop$^    uint00t accessprops  noemptyfsts  kaccessible  kcoaccessible  0$^    for auto inprop  inprops $^        accessprops  inprop  kaccessible  kcoaccessible$^    $^    if accessprops  kaccessible  kcoaccessible $^        outprops  accessprops$^        if inpropsroot  kinitialcyclic outprops  kinitialcyclic$^        uint00t props  0$^        bool string  true$^        for auto inprop  inprops $^            if replacetransducer props  knotacceptor  inprop$^            props  knonideterministic  knonodeterministic  kepsilons $^                kiepsilons  koepsilons  kweighted  kweightedcycles $^                kcyclic  knottopsorted  knotstring  inprop$^            if inprop  kstring string  false$^        $^        outprops  props$^        if string outprops  kstring$^    $^    bool acceptor  replacetransducer$^    bool ideterministic  epsilononcall  epsilononreturn$^    bool noiepsilons  epsilononcall  epsilononreturn$^    bool acyclic  true$^    bool unweighted  true$^    for sizet i  0 i  inprops.size i $^        if inpropsi  kacceptor acceptor  false$^        if inpropsi  kideterministic ideterministic  false$^        if inpropsi  knoiepsilons noiepsilons  false$^        if inpropsi  kacyclic acyclic  false$^        if inpropsi  kunweighted unweighted  false$^        if i  root  inpropsi  knoiepsilons ideterministic  false$^    $^    if acceptor outprops  kacceptor$^    if ideterministic outprops  kideterministic$^    if noiepsilons outprops  knoiepsilons$^    if acyclic outprops  kacyclic$^    if unweighted outprops  kunweighted$^    if inpropsroot  kinitialacyclic outprops  kinitialacyclic$^     we assume that all terminals are positive. the resulting replacefst is$^     known to be kilabelsorted when 0 all subfsts are kilabelsorted 0 the$^     input label of the return arc is epsilon and 0 one of the 0 following$^     conditions is satisfied$^    $^      0. the input label of the call arc is not epsilon$^      0. all nonterminals are negative or$^      0. all nonterninals are positive and form a dense range containing 0.$^    if allilabelsorted  epsilononreturn $^        epsilononcall  allnegativeordense $^        outprops  kilabelsorted$^    $^     similarly the resulting replacefst is known to be kolabelsorted when 0$^     all subfsts are kolabelsorted 0 the output label of the return arc is$^     epsilon and 0 one of the 0 following conditions is satisfied$^    $^      0. the output label of the call arc is not epsilon$^      0. all nonterminals are negative or$^      0. all nonterninals are positive and form a dense range containing 0.$^    if allolabelsorted  outepsilononreturn $^        outepsilononcall  allnegativeordense $^        outprops  kolabelsorted$^    $^    return outprops$^$^$^ properties for a relabeled fst.$^uint00t relabelpropertiesuint00t inprops $^  static constexpr auto outprops $^      kexpanded  kmutable  kerror  kweighted  kunweighted $^      kweightedcycles  kunweightedcycles  kcyclic  kacyclic $^      kinitialcyclic  kinitialacyclic  ktopsorted  knottopsorted $^      kaccessible  knotaccessible  kcoaccessible  knotcoaccessible $^      kstring  knotstring$^  return outprops  inprops$^$^$^ properties for a reversed fst the superinitial state limits this set.$^uint00t reversepropertiesuint00t inprops bool hassuperinitial $^  auto outprops  kexpanded  kmutable  kerror  kacceptor  knotacceptor $^                   kepsilons  kiepsilons  koepsilons  kunweighted  kcyclic $^                   kacyclic  kweightedcycles  kunweightedcycles $^                  inprops$^  if hassuperinitial outprops  kweighted  inprops$^  return outprops$^$^$^ properties for reweighted fst.$^uint00t reweightpropertiesuint00t inprops $^  auto outprops  inprops  kweightinvariantproperties$^  outprops  outprops  kcoaccessible$^  return outprops$^$^$^ properties for an epsilonremoved fst.$^uint00t rmepsilonpropertiesuint00t inprops bool delayed $^  auto outprops  knoepsilons$^  outprops  kerror  kacceptor  kacyclic  kinitialacyclic  inprops$^  if inprops  kacceptor outprops  knoiepsilons  knooepsilons$^  if delayed $^    outprops  kexpanded  kmutable$^    outprops  ktopsorted  inprops$^  $^  if delayed  inprops  kaccessible outprops  knotacceptor  inprops$^  return outprops$^$^$^ properties for shortest path. this function computes how the properties of$^ the output of shortest path need to be updated given that props is already$^ known.$^uint00t shortestpathpropertiesuint00t props bool tree $^  auto outprops $^      props  kacyclic  kinitialacyclic  kaccessible  kunweightedcycles$^  if tree outprops  kcoaccessible$^  return outprops$^$^$^ properties for a synchronized fst.$^uint00t synchronizepropertiesuint00t inprops $^  auto outprops  kerror  kacceptor  kacyclic  kaccessible  kcoaccessible $^                   kunweighted  kunweightedcycles $^                  inprops$^  if inprops  kaccessible $^    outprops  kcyclic  knotcoaccessible  kweighted  kweightedcycles $^        inprops$^  $^  return outprops$^$^$^ properties for a unioned fst.$^uint00t unionpropertiesuint00t inprops0 uint00t inprops0 bool delayed $^  auto outprops $^      kacceptor  kunweighted  kunweightedcycles  kacyclic  kaccessible $^      inprops0  inprops0$^  outprops  kerror  inprops0  inprops0$^  outprops  kinitialacyclic$^  bool empty0  delayed   can the first fst be the empty machine$^  bool empty0  delayed   can the second fst be the empty machine$^  if delayed $^    outprops  kexpanded  kmutable  knottopsorted  inprops0$^    outprops  knottopsorted  inprops0$^  $^  if empty0  empty0 $^    outprops  kepsilons  kiepsilons  koepsilons$^    outprops  kcoaccessible  inprops0  inprops0$^  $^   note knotcoaccessible does not hold because of kinitialacyclic option.$^  if delayed  inprops0  kaccessible $^    outprops $^        knotacceptor  knonideterministic  knonodeterministic  kepsilons $^         kiepsilons  koepsilons  knotilabelsorted  knotolabelsorted $^         kweighted  kweightedcycles  kcyclic  knotaccessible $^        inprops0$^  $^  if delayed  inprops0  kaccessible $^    outprops  knotacceptor  knonideterministic  knonodeterministic $^                 kepsilons  kiepsilons  koepsilons  knotilabelsorted $^                 knotolabelsorted  kweighted  kweightedcycles  kcyclic $^                 knotaccessible  knotcoaccessible $^                inprops0$^  $^  return outprops$^$^$^ property string names indexed by bit position.$^const char propertynames  $^     binary.$^    expanded mutable error           $^     $^     ternary.$^    acceptor not acceptor input deterministic$^    non input deterministic output deterministic$^    non output deterministic inputoutput epsilons$^    no inputoutput epsilons input epsilons no input epsilons$^    output epsilons no output epsilons input label sorted$^    not input label sorted output label sorted not output label sorted$^    weighted unweighted cyclic acyclic cyclic at initial state$^    acyclic at initial state top sorted not top sorted accessible$^    not accessible coaccessible not coaccessible string$^    not string weighted cycles unweighted cycles$^$^   namespace fst$^ compat.cc$^$^ licensed under the apache license version 0.0 the license$^ you may not use this file except in compliance with the license.$^ you may obtain a copy of the license at$^$^      httpwww.apache.orglicenseslicense0.0$^$^ unless required by applicable law or agreed to in writing software$^ distributed under the license is distributed on an as is basis$^ without warranties or conditions of any kind either express or implied.$^ see the license for the specific language governing permissions and$^ limitations under the license.$^$^ author rileygoogle.com michael riley$^$^ file$^ google compatibility definitions.$^$^include cstring$^include fstcompat.h$^$^using namespace std$^$^void failednewhandler $^  cerr  memory allocation failedn$^  exit0$^$^$^ifdef mscver$^$^const char basenameconst char path $^  the man page for the original basename states the function$^  can return a pointer to an internal static structure$^  so this might be ugly but still within the scope of acceptable behavior$^  char basenamemaxfname$^  char extmaxext$^  static char fullpathmaxext  maxfname$^$^  splitpathpath null null basename ext$^  makepathfullpath null null basename ext$^  return fullpath$^$^$^endif   mscver$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^ regression test for various fst algorithms.$^$^include .algotest.h$^$^include cstdlib$^$^include vector$^$^include fstflags.h$^$^ defines determine which semirings are tested these are controlled by$^ the defines attributes of the associated build rules.$^$^defineint00seed 0 random seed$^defineint00repeat 00 number of test repetitions$^$^using fstalgotester$^using fstarctpl$^using fstgallicarc$^using fstgallicweight$^using fstlexicographicarc$^using fstlexicographicweight$^using fstlogarc$^using fstlogweight$^using fstminmaxarc$^using fstminmaxweight$^using fstpowerweight$^using fststringleft$^using fststringright$^using fststdarc$^using fststringarc$^using fststringweight$^using fsttropicalweight$^using fstweightgenerate$^$^int mainint argc char argv $^  flagsfstverifyproperties  true$^  stdsetnewhandlerfailednewhandler$^  setflagsargv0 argc argv true$^$^  static const int kcachegclimit  00$^$^  srandflagsseed$^  loginfo  seed    flagsseed$^$^  flagsfstdefaultcachegc  rand  0$^  flagsfstdefaultcachegclimit  rand  kcachegclimit$^  vlog0  defaultcachegc  flagsfstdefaultcachegc$^  vlog0  defaultcachegclimit  flagsfstdefaultcachegclimit$^$^ifdef testtropical$^  using tropicalweightgenerate  weightgeneratetropicalweight$^  tropicalweightgenerate tropicalgeneratorfalse$^  algotesterstdarc tropicalweightgenerate tropicaltester$^      tropicalgenerator flagsseed$^  tropicaltester.test$^endif   testtropical$^$^ifdef testlog$^  using logweightgenerate  weightgeneratelogweight$^  logweightgenerate loggeneratorfalse$^  algotesterlogarc logweightgenerate logtesterloggenerator flagsseed$^  logtester.test$^endif   testlog$^$^ifdef testminmax$^  using minmaxweightgenerate  weightgenerateminmaxweight$^  minmaxweightgenerate minmaxgeneratorfalse$^  algotesterminmaxarc minmaxweightgenerate minmaxtesterminmaxgenerator$^                                                             flagsseed$^  minmaxtester.test$^endif$^$^ifdef testleftstring$^  using stringweightgenerate  weightgeneratestringweightint stringleft$^  stringweightgenerate leftstringgeneratorfalse$^  algotesterstringarc stringweightgenerate leftstringtester$^      leftstringgenerator flagsseed$^  leftstringtester.test$^endif   testleftstring$^$^ifdef testrightstring$^  using stringweightgenerate $^      weightgeneratestringweightint stringright$^  stringweightgenerate rightstringgeneratorfalse$^  algotesterstringarcstringright stringweightgenerate$^      rightstringtesterrightstringgenerator flagsseed$^  rightstringtester.test$^endif   testrightstring$^$^ifdef testgallic$^  using stdgallicarc  gallicarcstdarc$^  using tropicalgallicweightgenerate $^      weightgenerategallicweightint tropicalweight$^  tropicalgallicweightgenerate tropicalgallicgeneratorfalse$^  algotesterstdgallicarc tropicalgallicweightgenerate gallictester$^      tropicalgallicgenerator flagsseed$^  gallictester.test$^endif   testgallic$^$^ifdef testlexicographic$^  using tropicallexicographicarc $^      lexicographicarctropicalweight tropicalweight$^  using tropicallexicographicweightgenerate $^      weightgeneratelexicographicweighttropicalweight tropicalweight$^  tropicallexicographicweightgenerate lexicographicgeneratorfalse$^  algotestertropicallexicographicarc tropicallexicographicweightgenerate$^      lexicographictesterlexicographicgenerator flagsseed$^  lexicographictester.test$^endif   testlexicographic$^$^ifdef testpower$^  using tropicalcubeweight  powerweighttropicalweight 0$^  using tropicalcubearc  arctpltropicalcubeweight$^  using tropicalcubeweightgenerate  weightgeneratetropicalcubeweight$^  tropicalcubeweightgenerate tropicalcubegeneratorfalse$^  algotestertropicalcubearc tropicalcubeweightgenerate tropicalcubetester$^      tropicalcubegenerator flagsseed$^  tropicalcubetester.test$^endif   testpower$^$^  stdcout  pass  stdendl$^$^  return 0$^$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^ regression test for fst weights.$^$^include cstdlib$^include ctime$^$^include fstflags.h$^include fstlog.h$^include fstexpectationweight.h$^include fstfloatweight.h$^include fstlexicographicweight.h$^include fstpowerweight.h$^include fstproductweight.h$^include fstsetweight.h$^include fstsignedlogweight.h$^include fstsparsepowerweight.h$^include fststringweight.h$^include fstunionweight.h$^include .weighttester.h$^$^defineint00seed 0 random seed$^defineint00repeat 00000 number of test repetitions$^$^namespace $^$^using fstadder$^using fstexpectationweight$^using fstgallic$^using fstgallicweight$^using fstlexicographicweight$^using fstlogweight$^using fstlogweighttpl$^using fstminmaxweight$^using fstminmaxweighttpl$^using fstnaturalless$^using fstpowerweight$^using fstproductweight$^using fstsetweight$^using fstsetintersectunion$^using fstsetunionintersect$^using fstsetboolean$^using fstsignedlogweight$^using fstsignedlogweighttpl$^using fstsparsepowerweight$^using fststringweight$^using fststringleft$^using fststringright$^using fsttropicalweight$^using fsttropicalweighttpl$^using fstunionweight$^using fstweightconvert$^using fstweightgenerate$^using fstweighttester$^$^template class t$^void testtemplatedweightsint repeat $^  using tropicalweightgenerate  weightgeneratetropicalweighttplt$^  tropicalweightgenerate tropicalgenerate$^  weighttestertropicalweighttplt tropicalweightgenerate tropicaltester$^      tropicalgenerate$^  tropicaltester.testrepeat$^$^  using logweightgenerate  weightgeneratelogweighttplt$^  logweightgenerate loggenerate$^  weighttesterlogweighttplt logweightgenerate logtesterloggenerate$^  logtester.testrepeat$^$^  using minmaxweightgenerate  weightgenerateminmaxweighttplt$^  minmaxweightgenerate minmaxgeneratetrue$^  weighttesterminmaxweighttplt minmaxweightgenerate minmaxtester$^      minmaxgenerate$^  minmaxtester.testrepeat$^$^  using signedlogweightgenerate  weightgeneratesignedlogweighttplt$^  signedlogweightgenerate signedloggenerate$^  weighttestersignedlogweighttplt signedlogweightgenerate$^      signedlogtestersignedloggenerate$^  signedlogtester.testrepeat$^$^$^template class weight$^void testadderint n $^  weight sum  weightzero$^  adderweight adder$^  for int i  0 i  n i $^    sum  plussum weightone$^    adder.addweightone$^  $^  checkapproxequalsum adder.sum$^$^$^template class weight$^void testsignedadderint n $^  weight sum  weightzero$^  adderweight adder$^  const weight minusone  minusweightzero weightone$^  for int i  0 i  n i $^    if i  n0  i  0n0 $^      sum  plussum weightone$^      adder.addweightone$^     else $^      sum  minussum weightone$^      adder.addminusone$^    $^  $^  checkapproxequalsum adder.sum$^$^$^template typename weight0 typename weight0$^void testweightconversionweight0 w0 $^   tests roundtrp conversion.$^  weightconvertweight0 weight0 tow0$^  weightconvertweight0 weight0 tow0$^  weight0 w0  tow0w0$^  weight0 nw0  tow0w0$^  checkeqw0 nw0$^$^$^template typename fromweight typename toweight$^void testweightcopyfromweight w $^   test copy constructor.$^  const toweight tocopiedw$^  const fromweight roundtripcopiedtocopied$^  checkeqw roundtripcopied$^$^   test copy assign.$^  toweight tocopyassigned$^  tocopyassigned  w$^  checkeqtocopied tocopyassigned$^$^  fromweight roundtripcopyassigned$^  roundtripcopyassigned  tocopyassigned$^  checkeqw roundtripcopyassigned$^$^$^template typename fromweight typename toweight$^void testweightmovefromweight w $^   assume fromweight  fromweight copy works.$^  const fromweight origw$^  toweight tomovedstdmovew$^  const fromweight roundtripmovedstdmovetomoved$^  checkeqorig roundtripmoved$^$^   test move assign.$^  w  orig$^  toweight tomoveassigned$^  tomoveassigned  stdmovew$^  fromweight roundtripmoveassigned$^  roundtripmoveassigned  stdmovetomoveassigned$^  checkeqorig roundtripmoveassigned$^$^$^template class weight$^void testimplicitconversion $^   only test a few of the operations assumes they are implemented with the$^   same pattern.$^  checkweight0.0f  0.0f$^  checkweight0.0  0.0$^  check0.0f  weight0.0f$^  check0.0  weight0.0$^$^  checkeqweightzero timesweightzero 0.0f$^  checkeqweightzero timesweightzero 0.0$^  checkeqweightzero times0.0 weightzero$^$^  checkeqweight0.0 plusweightzero 0.0f$^  checkeqweight0.0 plusweightzero 0.0$^  checkeqweight0.0 plus0.0 weightzero$^$^$^void testpowerweightgetsetvalue $^  powerweightlogweight 0 w$^   logweight has unspecified initial value so dont check it.$^  w.setvalue0 logweight0$^  w.setvalue0 logweight0$^  checkeqlogweight0 w.value0$^  checkeqlogweight0 w.value0$^$^$^void testsparsepowerweightgetsetvalue $^  const logweight defaultvalue00$^  sparsepowerweightlogweight w$^  w.setdefaultvaluedefaultvalue$^$^   all gets should be the default.$^  checkeqdefaultvalue w.value0$^  checkeqdefaultvalue w.value000$^$^   first set should fill first.$^  w.setvalue00 logweight00$^  checkeqlogweight00 w.value00$^  w.setvalue00 logweight00$^  checkeqlogweight00 w.value00$^$^   add a smaller index.$^  w.setvalue0 logweight0$^  checkeqlogweight0 w.value0$^  checkeqlogweight00 w.value00$^$^   add some larger indices.$^  w.setvalue00 logweight00$^  checkeqlogweight0 w.value0$^  checkeqlogweight00 w.value00$^  checkeqlogweight00 w.value00$^$^  w.setvalue00 logweight00$^  checkeqlogweight0 w.value0$^  checkeqlogweight00 w.value00$^  checkeqlogweight00 w.value00$^  checkeqlogweight00 w.value00$^$^  w.setvalue00 logweight00$^  checkeqlogweight0 w.value0$^  checkeqlogweight00 w.value00$^  checkeqlogweight00 w.value00$^  checkeqlogweight00 w.value00$^  checkeqlogweight00 w.value00$^$^   replace a value.$^  w.setvalue00 logweight00$^  checkeqlogweight00 w.value00$^$^   replace a value with the default.$^  checkeq0 w.size$^  w.setvalue00 defaultvalue$^  checkeqdefaultvalue w.value00$^  checkeq0 w.size$^$^   replace lowest index by the default value.$^  w.setvalue0 defaultvalue$^  checkeqdefaultvalue w.value0$^  checkeq0 w.size$^$^   clear out everything.$^  w.setvalue00 defaultvalue$^  w.setvalue00 defaultvalue$^  w.setvalue00 defaultvalue$^  checkeq0 w.size$^$^  checkeqdefaultvalue w.value0$^  checkeqdefaultvalue w.value00$^  checkeqdefaultvalue w.value00$^  checkeqdefaultvalue w.value00$^  checkeqdefaultvalue w.value00$^$^$^   namespace$^$^int mainint argc char argv $^  stdsetnewhandlerfailednewhandler$^  setflagsargv0 argc argv true$^$^  loginfo  seed    flagsseed$^  srandflagsseed$^$^  testtemplatedweightsfloatflagsrepeat$^  testtemplatedweightsdoubleflagsrepeat$^  flagsfstweightparentheses  $^  testtemplatedweightsfloatflagsrepeat$^  testtemplatedweightsdoubleflagsrepeat$^  flagsfstweightparentheses  $^$^   makes sure type names for templated weights are consistent.$^  checktropicalweighttype  tropical$^  checktropicalweighttpldoubletype  tropicalweighttplfloattype$^  checklogweighttype  log$^  checklogweighttpldoubletype  logweighttplfloattype$^  tropicalweighttpldouble w0.0$^  tropicalweight tw0.0$^$^  testaddertropicalweight0000$^  testadderlogweight0000$^  testsignedaddersignedlogweight0000$^$^  testimplicitconversionlogweight$^  testimplicitconversiontropicalweight$^  testimplicitconversionminmaxweight$^$^  testweightconversiontropicalweight logweight0.0$^$^  using leftstringweight  stringweightint$^  using leftstringweightgenerate  weightgenerateleftstringweight$^  leftstringweightgenerate leftstringgenerate$^  weighttesterleftstringweight leftstringweightgenerate leftstringtester$^      leftstringgenerate$^  leftstringtester.testflagsrepeat$^$^  using rightstringweight  stringweightint stringright$^  using rightstringweightgenerate  weightgeneraterightstringweight$^  rightstringweightgenerate rightstringgenerate$^  weighttesterrightstringweight rightstringweightgenerate$^      rightstringtesterrightstringgenerate$^  rightstringtester.testflagsrepeat$^$^   stringrestrict not tested since it requires equal strings$^   so would fail.$^$^  using iusetweight  setweightint setintersectunion$^  using iusetweightgenerate  weightgenerateiusetweight$^  iusetweightgenerate iusetgenerate$^  weighttesteriusetweight iusetweightgenerate$^      iusettesteriusetgenerate$^  iusettester.testflagsrepeat$^$^  using uisetweight  setweightint setunionintersect$^  using uisetweightgenerate  weightgenerateuisetweight$^  uisetweightgenerate uisetgenerate$^  weighttesteruisetweight uisetweightgenerate$^      uisettesteruisetgenerate$^  uisettester.testflagsrepeat$^$^   setintersectunionrestrict not tested since it requires equal sets$^   so would fail.$^$^  using boolsetweight  setweightint setboolean$^  using boolsetweightgenerate  weightgenerateboolsetweight$^  boolsetweightgenerate boolsetgenerate$^  weighttesterboolsetweight boolsetweightgenerate$^      boolsettesterboolsetgenerate$^  boolsettester.testflagsrepeat$^$^  testweightconversioniusetweight uisetweightiusetgenerate$^$^  testweightcopyiusetweight uisetweightiusetgenerate$^  testweightcopyiusetweight boolsetweightiusetgenerate$^  testweightcopyuisetweight iusetweightuisetgenerate$^  testweightcopyuisetweight boolsetweightuisetgenerate$^  testweightcopyboolsetweight iusetweightboolsetgenerate$^  testweightcopyboolsetweight uisetweightboolsetgenerate$^$^  testweightmoveiusetweight uisetweightiusetgenerate$^  testweightmoveiusetweight boolsetweightiusetgenerate$^  testweightmoveuisetweight iusetweightuisetgenerate$^  testweightmoveuisetweight boolsetweightuisetgenerate$^  testweightmoveboolsetweight iusetweightboolsetgenerate$^  testweightmoveboolsetweight uisetweightboolsetgenerate$^$^   composite weights and testers  definitions$^$^  using tropicalgallicweight  gallicweightint tropicalweight$^  using tropicalgallicweightgenerate  weightgeneratetropicalgallicweight$^  tropicalgallicweightgenerate tropicalgallicgeneratetrue$^  weighttestertropicalgallicweight tropicalgallicweightgenerate$^      tropicalgallictestertropicalgallicgenerate$^$^  using tropicalgengallicweight  gallicweightint tropicalweight gallic$^  using tropicalgengallicweightgenerate $^      weightgeneratetropicalgengallicweight$^  tropicalgengallicweightgenerate tropicalgengallicgeneratefalse$^  weighttestertropicalgengallicweight tropicalgengallicweightgenerate$^      tropicalgengallictestertropicalgengallicgenerate$^$^  using tropicalproductweight  productweighttropicalweight tropicalweight$^  using tropicalproductweightgenerate  weightgeneratetropicalproductweight$^  tropicalproductweightgenerate tropicalproductgenerate$^  weighttestertropicalproductweight tropicalproductweightgenerate$^      tropicalproducttestertropicalproductgenerate$^$^  using tropicallexicographicweight $^      lexicographicweighttropicalweight tropicalweight$^  using tropicallexicographicweightgenerate $^      weightgeneratetropicallexicographicweight$^  tropicallexicographicweightgenerate tropicallexicographicgenerate$^  weighttestertropicallexicographicweight$^               tropicallexicographicweightgenerate$^      tropicallexicographictestertropicallexicographicgenerate$^$^  using tropicalcubeweight  powerweighttropicalweight 0$^  using tropicalcubeweightgenerate  weightgeneratetropicalcubeweight$^  tropicalcubeweightgenerate tropicalcubegenerate$^  weighttestertropicalcubeweight tropicalcubeweightgenerate$^      tropicalcubetestertropicalcubegenerate$^$^  using firstnestedproductweight $^      productweighttropicalproductweight tropicalweight$^  using firstnestedproductweightgenerate $^      weightgeneratefirstnestedproductweight$^  firstnestedproductweightgenerate firstnestedproductgenerate$^  weighttesterfirstnestedproductweight firstnestedproductweightgenerate$^      firstnestedproducttesterfirstnestedproductgenerate$^$^  using secondnestedproductweight $^      productweighttropicalweight tropicalproductweight$^  using secondnestedproductweightgenerate $^      weightgeneratesecondnestedproductweight$^  secondnestedproductweightgenerate secondnestedproductgenerate$^  weighttestersecondnestedproductweight secondnestedproductweightgenerate$^      secondnestedproducttestersecondnestedproductgenerate$^$^  using nestedproductcubeweight  powerweightfirstnestedproductweight 0$^  using nestedproductcubeweightgenerate $^      weightgeneratenestedproductcubeweight$^  nestedproductcubeweightgenerate nestedproductcubegenerate$^  weighttesternestedproductcubeweight nestedproductcubeweightgenerate$^      nestedproductcubetesternestedproductcubegenerate$^$^  using sparsenestedproductcubeweight $^      sparsepowerweightnestedproductcubeweight sizet$^  using sparsenestedproductcubeweightgenerate $^      weightgeneratesparsenestedproductcubeweight$^  sparsenestedproductcubeweightgenerate sparsenestedproductcubegenerate$^  weighttestersparsenestedproductcubeweight$^               sparsenestedproductcubeweightgenerate$^      sparsenestedproductcubetestersparsenestedproductcubegenerate$^$^  using logsparsepowerweight  sparsepowerweightlogweight sizet$^  using logsparsepowerweightgenerate  weightgeneratelogsparsepowerweight$^  logsparsepowerweightgenerate logsparsepowergenerate$^  weighttesterlogsparsepowerweight logsparsepowerweightgenerate$^      logsparsepowertesterlogsparsepowergenerate$^$^  using loglogexpectationweight  expectationweightlogweight logweight$^  using loglogexpectationweightgenerate $^      weightgenerateloglogexpectationweight$^  loglogexpectationweightgenerate loglogexpectationgenerate$^  weighttesterloglogexpectationweight loglogexpectationweightgenerate$^      loglogexpectationtesterloglogexpectationgenerate$^$^  using loglogsparseexpectationweight $^      expectationweightlogweight logsparsepowerweight$^  using loglogsparseexpectationweightgenerate $^      weightgenerateloglogsparseexpectationweight$^  loglogsparseexpectationweightgenerate loglogsparseexpectationgenerate$^  weighttesterloglogsparseexpectationweight$^               loglogsparseexpectationweightgenerate$^      loglogsparseexpectationtesterloglogsparseexpectationgenerate$^$^  struct unionweightoptions $^    using compare  naturallesstropicalweight$^$^    struct merge $^      tropicalweight operatorconst tropicalweight w0$^                                const tropicalweight w0 const $^        return w0$^      $^    $^$^    using reverseoptions  unionweightoptions$^  $^$^  using tropicalunionweight  unionweighttropicalweight unionweightoptions$^  using tropicalunionweightgenerate  weightgeneratetropicalunionweight$^  tropicalunionweightgenerate tropicaluniongenerate$^  weighttestertropicalunionweight tropicalunionweightgenerate$^      tropicaluniontestertropicaluniongenerate$^$^   composite weights and testers  testing$^$^   tests composite weight io with parentheses.$^  flagsfstweightparentheses  $^$^   unnested composite.$^  tropicalgallictester.testflagsrepeat$^  tropicalgengallictester.testflagsrepeat$^  tropicalproducttester.testflagsrepeat$^  tropicallexicographictester.testflagsrepeat$^  tropicalcubetester.testflagsrepeat$^  logsparsepowertester.testflagsrepeat$^  loglogexpectationtester.testflagsrepeat false$^  tropicaluniontester.testflagsrepeat false$^$^   nested composite.$^  firstnestedproducttester.testflagsrepeat$^  secondnestedproducttester.test0$^  nestedproductcubetester.testflagsrepeat$^  sparsenestedproductcubetester.testflagsrepeat$^  loglogsparseexpectationtester.testflagsrepeat false$^$^   ... and tests composite weight io without parentheses.$^  flagsfstweightparentheses  $^$^   unnested composite.$^  tropicalgallictester.testflagsrepeat$^  tropicalproducttester.testflagsrepeat$^  tropicallexicographictester.testflagsrepeat$^  tropicalcubetester.testflagsrepeat$^  logsparsepowertester.testflagsrepeat$^  loglogexpectationtester.testflagsrepeat false$^  tropicaluniontester.testflagsrepeat false$^$^   nested composite.$^  secondnestedproducttester.testflagsrepeat$^  loglogsparseexpectationtester.testflagsrepeat false$^$^  testpowerweightgetsetvalue$^  testsparsepowerweightgetsetvalue$^$^  stdcout  pass  stdendl$^$^  return 0$^$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^ regression test for fst classes.$^$^include .fsttest.h$^$^include utility$^$^include fstflags.h$^include fstlog.h$^include fstcompactfst.h$^include fstconstfst.h$^include fsteditfst.h$^include fstmatcherfst.h$^$^namespace fst $^namespace $^$^ a userdefined arc type.$^struct customarc $^  typedef int00 label$^  typedef productweighttropicalweight logweight weight$^  typedef int00 stateid$^$^  customarclabel i label o weight w stateid s$^       ilabeli olabelo weightstdmovew nextstates $^  customarc $^$^  static const string type    arc type name$^    static const string const type  new stringmy$^    return type$^  $^$^  label ilabel        transition input label$^  label olabel        transition output label$^  weight weight       transition weight$^  stateid nextstate   transition destination state$^$^$^ a userdefined compactor for test fst.$^template class a$^class customcompactor $^ public$^  typedef a arc$^  typedef typename alabel label$^  typedef typename astateid stateid$^  typedef typename aweight weight$^  typedef stdpairlabel weight element$^$^  element compactstateid s const a arc const $^    return stdmakepairarc.ilabel arc.weight$^  $^$^  arc expandstateid s const element p uint00 f  karcvalueflags const $^    return p.first  knolabel  arcknolabel knolabel p.second knostateid$^                                arcp.first 0 p.second s$^  $^$^  ssizet size const  return 0 $^$^  uint00 properties const  return 0ull $^$^  bool compatibleconst fsta fst const  return true $^$^  static const string type $^    static const string const type  new stringmy$^    return type$^  $^$^  bool writestdostream strm const  return true $^$^  static customcompactor readstdistream strm $^    return new customcompactor$^  $^$^$^registerfstvectorfst customarc$^registerfstconstfst customarc$^static fstfstregisterercompactfststdarc customcompactorstdarc$^    compactfststdarccustomcompactorregisterer$^static fstfstregisterercompactfstcustomarc customcompactorcustomarc$^    compactfstcustomarccustomcompactorregisterer$^static fstfstregistererconstfststdarc uint00$^    constfststdarcuint00registerer$^static fstfstregisterer$^    compactfststdarc customcompactorstdarc uint00$^    compactfststdarccustomcompactoruint00registerer$^$^   namespace$^   namespace fst$^$^using fstfsttester$^using fstvectorfst$^using fstconstfst$^using fstmatcherfst$^using fstcompactfst$^using fstfst$^using fststdarc$^using fstcustomarc$^using fstcustomcompactor$^using fststdarclookaheadfst$^using fsteditfst$^$^int mainint argc char argv $^  flagsfstverifyproperties  true$^  stdsetnewhandlerfailednewhandler$^  setflagsargv0 argc argv true$^$^   vectorfststdarc tests$^  $^    fsttestervectorfststdarc stdvectortester$^    stdvectortester.testbase$^    stdvectortester.testexpanded$^    stdvectortester.testassign$^    stdvectortester.testcopy$^    stdvectortester.testio$^    stdvectortester.testmutable$^  $^$^   constfststdarc tests$^  $^    fsttesterconstfststdarc stdconsttester$^    stdconsttester.testbase$^    stdconsttester.testexpanded$^    stdconsttester.testcopy$^    stdconsttester.testio$^  $^$^   compactfststdarc customcompactorstdarc$^  $^    fsttestercompactfststdarc customcompactorstdarc stdcompacttester$^    stdcompacttester.testbase$^    stdcompacttester.testexpanded$^    stdcompacttester.testcopy$^    stdcompacttester.testio$^  $^$^   vectorfstcustomarc tests$^  $^    fsttestervectorfstcustomarc stdvectortester$^    stdvectortester.testbase$^    stdvectortester.testexpanded$^    stdvectortester.testassign$^    stdvectortester.testcopy$^    stdvectortester.testio$^    stdvectortester.testmutable$^  $^$^   constfstcustomarc tests$^  $^    fsttesterconstfstcustomarc stdconsttester$^    stdconsttester.testbase$^    stdconsttester.testexpanded$^    stdconsttester.testcopy$^    stdconsttester.testio$^  $^$^   compactfstcustomarc customcompactorcustomarc$^  $^    fsttestercompactfstcustomarc customcompactorcustomarc$^        stdcompacttester$^    stdcompacttester.testbase$^    stdcompacttester.testexpanded$^    stdcompacttester.testcopy$^    stdcompacttester.testio$^  $^$^   constfststdarc uint00 tests$^  $^    fsttesterconstfststdarc uint00 stdconsttester$^    stdconsttester.testbase$^    stdconsttester.testexpanded$^    stdconsttester.testcopy$^    stdconsttester.testio$^  $^$^   compactfststdarc customcompactorstdarc uint00$^  $^    fsttestercompactfststdarc customcompactorstdarc uint00$^        stdcompacttester$^    stdcompacttester.testbase$^    stdcompacttester.testexpanded$^    stdcompacttester.testcopy$^    stdcompacttester.testio$^  $^$^   fsttesterstdarclookaheadfst$^  $^    fsttesterstdarclookaheadfst stdmatchertester$^    stdmatchertester.testbase$^    stdmatchertester.testexpanded$^    stdmatchertester.testcopy$^  $^$^   editfststdarc tests$^  $^    fsttestereditfststdarc stdedittester$^    stdedittester.testbase$^    stdedittester.testexpanded$^    stdedittester.testassign$^    stdedittester.testcopy$^    stdedittester.testmutable$^  $^$^  stdcout  pass  stdendl$^$^  return 0$^$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstflags.h$^$^defineboolrequiresuperinitial true always create a superinitial state$^$^int fstreversemainint argc char argv$^$^int mainint argc char argv  return fstreversemainargc argv $^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstflags.h$^$^definestringisymbols  input label symbol table$^definestringosymbols  output label symbol table$^definestringrelabelisymbols  input symbol set to relabel to$^definestringrelabelosymbols  output symbol set to relabel to$^definestringrelabelipairs  input relabel pairs numeric$^definestringrelabelopairs  output relabel pairs numeric$^definestringunknownisymbol $^    input symbol to use to relabel oovs default oovs are errors$^definestringunknownosymbol $^    output symbol to use to relabel oovs default oovs are errors$^defineboolallownegativelabels false$^    allow negative labels not recommended may cause conflicts$^$^int fstrelabelmainint argc char argv$^$^int mainint argc char argv  return fstrelabelmainargc argv $^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^ applies an operation to each arc of an fst.$^$^include cstring$^$^include memory$^include string$^$^include fstflags.h$^include fstlog.h$^include fstscriptgetters.h$^include fstscriptmap.h$^$^declaredoubledelta$^declarestringmaptype$^declaredoublepower$^declarestringweight$^$^int fstmapmainint argc char argv $^  namespace s  fstscript$^  using fstscriptfstclass$^  using fstscriptweightclass$^$^  string usage  applies an operation to each arc of an fst.nn  usage $^  usage  argv0$^  usage   in.fst out.fstn$^$^  stdsetnewhandlerfailednewhandler$^  setflagsusage.cstr argc argv true$^  if argc  0 $^    showusage$^    return 0$^  $^$^  const string inname  argc  0  strcmpargv0   0  argv0  $^  const string outname  argc  0  argv0  $^$^  stduniqueptrfstclass ifstfstclassreadinname$^  if ifst return 0$^$^  smaptype maptype$^  if sgetmaptypeflagsmaptype maptype $^    logerror  argv0   unknown or unsupported map type $^                flagsmaptype$^    return 0$^  $^$^  const auto weightparam $^      flagsweight.empty$^           weightclassifstweighttype flagsweight$^           flagsmaptype  times  weightclassoneifstweighttype$^                                        weightclasszeroifstweighttype$^$^  stduniqueptrfstclass ofst$^      smapifst maptype flagsdelta flagspower weightparam$^$^  return ofstwriteoutname$^$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^ removes useless inaccessible or noncoaccessible states and arcs from an$^ fst.$^$^include cstring$^$^include memory$^include string$^$^include fstflags.h$^include fstscriptconnect.h$^$^int fstconnectmainint argc char argv $^  namespace s  fstscript$^  using fstscriptfstclass$^  using fstscriptmutablefstclass$^$^  string usage  removes useless states and arcs from an fst.nn  usage $^  usage  argv0$^  usage   in.fst out.fstn$^$^  stdsetnewhandlerfailednewhandler$^  setflagsusage.cstr argc argv true$^  if argc  0 $^    showusage$^    return 0$^  $^$^  const string inname  argc  0  strcmpargv0   0  argv0  $^  const string outname  argc  0  argv0  $^$^  stduniqueptrmutablefstclass fstmutablefstclassreadinname true$^  if fst return 0$^$^  sconnectfst.get$^$^  return fstwriteoutname$^$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstflags.h$^include fstweight.h$^$^definedoubledelta fstkdelta comparisonquantization delta$^$^int fstisomorphicmainint argc char argv$^$^int mainint argc char argv  return fstisomorphicmainargc argv $^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstflags.h$^$^definestringfsttype vector output fst type$^$^int fstconvertmainint argc char argv$^$^int mainint argc char argv  return fstconvertmainargc argv $^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^ epsilonnormalizes an fst.$^$^include cstring$^$^include memory$^include string$^$^include fstflags.h$^include fstscriptepsnormalize.h$^include fstscriptgetters.h$^$^declareboolepsnormoutput$^$^int fstepsnormalizemainint argc char argv $^  namespace s  fstscript$^  using fstscriptfstclass$^  using fstscriptvectorfstclass$^$^  string usage  epsilon normalizes an fst.nn  usage $^  usage  argv0$^  usage   in.fst out.fstn$^$^  stdsetnewhandlerfailednewhandler$^  setflagsusage.cstr argc argv true$^  if argc  0 $^    showusage$^    return 0$^  $^$^  const string inname  argc  0  strcmpargv0   0  argv0  $^  const string outname  argc  0  argv0  $^$^  stduniqueptrfstclass ifstfstclassreadinname$^  if ifst return 0$^$^  vectorfstclass ofstifstarctype$^$^  sepsnormalizeifst ofst sgetepsnormalizetypeflagsepsnormoutput$^$^  return ofst.writeoutname$^$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^ two fsts are isomorphic equal up to state and arc reordering iff their$^ exit status is zero. fsts should be deterministic when viewed as unweighted$^ automata.$^$^include cstring$^$^include memory$^include string$^$^include fstflags.h$^include fstlog.h$^include fstscriptisomorphic.h$^$^declaredoubledelta$^$^int fstisomorphicmainint argc char argv $^  namespace s  fstscript$^  using fstscriptfstclass$^$^  string usage $^      two fsts are isomorphic iff the exit status is zero.nn  usage $^  usage  argv0$^  usage   in0.fst in0.fstn$^$^  stdsetnewhandlerfailednewhandler$^  setflagsusage.cstr argc argv true$^  if argc  0 $^    showusage$^    return 0$^  $^$^  const string in0name  strcmpargv0   0    argv0$^  const string in0name  strcmpargv0   0    argv0$^$^  if in0name.empty  in0name.empty $^    logerror  argv0   cant take both inputs from standard input$^    return 0$^  $^$^  stduniqueptrfstclass ifst0fstclassreadin0name$^  if ifst0 return 0$^$^  stduniqueptrfstclass ifst0fstclassreadin0name$^  if ifst0 return 0$^$^  bool result  sisomorphicifst0 ifst0 flagsdelta$^  if result vlog0  fsts are not isomorphic$^$^  return result  0  0$^$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^ projects a transduction onto its input or output language.$^$^include cstring$^$^include memory$^include string$^$^include fstflags.h$^include fstscriptgetters.h$^include fstscriptproject.h$^$^declareboolprojectoutput$^$^int fstprojectmainint argc char argv $^  namespace s  fstscript$^  using fstscriptmutablefstclass$^$^  string usage $^      projects a transduction onto its input$^       or output language.nn  usage $^  usage  argv0$^  usage   in.fst out.fstn$^$^  stdsetnewhandlerfailednewhandler$^  setflagsusage.cstr argc argv true$^  if argc  0 $^    showusage$^    return 0$^  $^$^  const string inname  argc  0  strcmpargv0   0  argv0  $^  const string outname  argc  0  argv0  $^$^  stduniqueptrmutablefstclass fstmutablefstclassreadinname true$^  if fst return 0$^$^  sprojectfst.get sgetprojecttypeflagsprojectoutput$^$^  return fstwriteoutname$^$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^ topologically sorts an fst.$^$^include cstring$^$^include memory$^include string$^$^include fstflags.h$^include fstlog.h$^include fstscripttopsort.h$^$^int fsttopsortmainint argc char argv $^  namespace s  fstscript$^  using fstscriptmutablefstclass$^$^  string usage  topologically sorts an fst.nn  usage $^  usage  argv0$^  usage   in.fst out.fstn$^$^  stdsetnewhandlerfailednewhandler$^  setflagsusage.cstr argc argv true$^  if argc  0 $^    showusage$^    return 0$^  $^$^  const string inname  argc  0  strcmpargv0   0  argv0  $^  const string outname  argc  0  argv0  $^$^  stduniqueptrmutablefstclass fstmutablefstclassreadinname true$^  if fst return 0$^$^  bool acyclic  topsortfst.get$^$^  if acyclic logwarning  argv0   input fst is cyclic$^$^  return fstwriteoutname$^$^include unistd.h$^$^include climits$^include ctime$^$^include fstflags.h$^include fstweight.h$^$^definedoubledelta fstkdelta comparisonquantization delta$^defineboolrandom false$^            test equivalence by randomly selecting paths in the input fsts$^defineint00maxlength int00max maximum path length$^defineint00npath 0 number of paths to generate$^defineint00seed timenullptr  getpid random seed$^definestringselect uniform$^              selection type one of $^               uniform logprob when appropriate$^               fastlogprob when appropriate$^$^int fstequivalentmainint argc char argv$^$^int mainint argc char argv  return fstequivalentmainargc argv $^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^ reweights an fst.$^$^include cstring$^$^include memory$^include string$^include vector$^$^include fstflags.h$^include fstscriptgetters.h$^include fstscriptreweight.h$^include fstscripttextio.h$^$^declarebooltofinal$^$^int fstreweightmainint argc char argv $^  namespace s  fstscript$^  using fstscriptmutablefstclass$^  using fstscriptweightclass$^$^  string usage  reweights an fst.nn  usage $^  usage  argv0$^  usage   in.fst potential.txt out.fstn$^$^  stdsetnewhandlerfailednewhandler$^  setflagsusage.cstr argc argv true$^  if argc  0  argc  0 $^    showusage$^    return 0$^  $^$^  const string inname  argv0$^  const string potentialsname  argv0$^  const string outname  argc  0  argv0  $^$^  stduniqueptrmutablefstclass fstmutablefstclassreadinname true$^  if fst return 0$^$^  stdvectorweightclass potential$^  if sreadpotentialsfstweighttype potentialsname potential $^    return 0$^  $^$^  sreweightfst.get potential sgetreweighttypeflagstofinal$^$^  return fstwriteoutname$^$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^ creates binary fsts from simple text format used by att.$^$^include cstring$^$^include fstream$^include istream$^include memory$^include string$^$^include fstflags.h$^include fstlog.h$^include fstscriptcompile.h$^$^declareboolacceptor$^declarestringarctype$^declarestringfsttype$^declarestringisymbols$^declarestringosymbols$^declarestringssymbols$^declareboolkeepisymbols$^declareboolkeeposymbols$^declareboolkeepstatenumbering$^declareboolallownegativelabels$^$^int fstcompilemainint argc char argv $^  namespace s  fstscript$^  using fstsymboltable$^  using fstsymboltabletextoptions$^$^  string usage  creates binary fsts from simple text format.nn  usage $^  usage  argv0$^  usage   text.fst binary.fstn$^$^  stdsetnewhandlerfailednewhandler$^  setflagsusage.cstr argc argv true$^  if argc  0 $^    showusage$^    return 0$^  $^$^  string source  standard input$^  stdifstream fstrm$^  if argc  0  strcmpargv0   0 $^    fstrm.openargv0$^    if fstrm $^      logerror  argv0   open failed file    argv0$^      return 0$^    $^    source  argv0$^  $^  stdistream istrm  fstrm.isopen  fstrm  stdcin$^$^  const symboltabletextoptions optsflagsallownegativelabels$^$^  stduniqueptrconst symboltable isyms$^  if flagsisymbols.empty $^    isyms.resetsymboltablereadtextflagsisymbols opts$^    if isyms return 0$^  $^$^  stduniqueptrconst symboltable osyms$^  if flagsosymbols.empty $^    osyms.resetsymboltablereadtextflagsosymbols opts$^    if osyms return 0$^  $^$^  stduniqueptrconst symboltable ssyms$^  if flagsssymbols.empty $^    ssyms.resetsymboltablereadtextflagsssymbols$^    if ssyms return 0$^  $^$^  const string dest  argc  0  argv0  $^$^  scompilefstistrm source dest flagsfsttype flagsarctype$^                isyms.get osyms.get ssyms.get flagsacceptor$^                flagskeepisymbols flagskeeposymbols$^                flagskeepstatenumbering flagsallownegativelabels$^$^  return 0$^$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^ converts an fst to another type.$^$^include cstring$^$^include memory$^include string$^$^include fstflags.h$^include fstscriptconvert.h$^$^declarestringfsttype$^$^int fstconvertmainint argc char argv $^  namespace s  fstscript$^  using fstscriptfstclass$^$^  string usage  converts an fst to another type.nn  usage $^  usage  argv0$^  usage   in.fst out.fstn$^$^  stdsetnewhandlerfailednewhandler$^  setflagsusage.cstr argc argv true$^  if argc  0 $^    showusage$^    return 0$^  $^$^  const string inname  argc  0  strcmpargv0   0  argv0  $^  const string outname  argc  0  argv0  $^$^  stduniqueptrfstclass ifstfstclassreadinname$^  if ifst return 0$^$^  if ifstfsttype  flagsfsttype $^    stduniqueptrfstclass ofstsconvertifst flagsfsttype$^    if ofst return 0$^    return ofstwriteoutname$^   else $^    return ifstwriteoutname$^  $^$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^ encode transducer labels andor weights.$^$^include cstring$^$^include memory$^include string$^$^include fstflags.h$^include fstscriptdecode.h$^include fstscriptencode.h$^include fstscriptgetters.h$^$^declareboolencodelabels$^declareboolencodeweights$^declareboolencodereuse$^declarebooldecode$^$^int fstencodemainint argc char argv $^  namespace s  fstscript$^  using fstscriptfstclass$^  using fstscriptmutablefstclass$^$^  string usage  encodes transducer labels andor weights.nn  usage $^  usage  argv0$^  usage   in.fst codex out.fstn$^$^  stdsetnewhandlerfailednewhandler$^  setflagsusage.cstr argc argv true$^  if argc  0  argc  0 $^    showusage$^    return 0$^  $^$^  const string inname  strcmpargv0   0  argv0  $^  const string codexname  argv0$^  const string outname  argc  0  argv0  $^$^  stduniqueptrmutablefstclass fstmutablefstclassreadinname true$^  if fst return 0$^$^  if flagsdecode $^    sdecodefst.get codexname$^    return fstwriteoutname$^   else $^    const auto flags $^        sgetencodeflagsflagsencodelabels flagsencodeweights$^    sencodefst.get flags flagsencodereuse codexname$^    return fstwriteoutname$^  $^$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^ relabels input or output space of an fst.$^$^include cstring$^$^include memory$^include string$^include vector$^$^include fstflags.h$^include fstutil.h$^include fstscriptrelabel.h$^include fstscriptweightclass.h$^$^declarestringisymbols$^declarestringosymbols$^declarestringrelabelisymbols$^declarestringrelabelosymbols$^declarestringrelabelipairs$^declarestringrelabelopairs$^declarestringunknownisymbol$^declarestringunknownosymbol$^declareboolallownegativelabels$^$^int fstrelabelmainint argc char argv $^  namespace s  fstscript$^  using fstscriptmutablefstclass$^  using fstsymboltable$^  using fstsymboltabletextoptions$^$^  string usage $^      relabels the input andor the output labels of the fst.nn$^        usage $^  usage  argv0$^  usage   in.fst out.fstn$^  usage  n using symboltables flagsn$^  usage    relabelisymbols isyms.mapn$^  usage    relabelosymbols osyms.mapn$^  usage  n using numeric labels flagsn$^  usage    relabelipairs ipairs.txtn$^  usage    relabelopairs opairs.txtn$^$^  stdsetnewhandlerfailednewhandler$^  setflagsusage.cstr argc argv true$^  if argc  0 $^    showusage$^    return 0$^  $^$^  const string inname $^      argc  0  strcmpargv0   0  argv0  $^  const string outname  argc  0  argv0  $^$^  stduniqueptrmutablefstclass fstmutablefstclassreadinname true$^  if fst return 0$^$^   relabel with symbol tables.$^  const symboltabletextoptions optsflagsallownegativelabels$^$^  if flagsrelabelisymbols.empty  flagsrelabelosymbols.empty $^    bool attachnewisymbols  fstinputsymbols  nullptr$^    stduniqueptrconst symboltable oldisymbols$^        flagsisymbols.empty  nullptr$^                                symboltablereadtextflagsisymbols opts$^    const stduniqueptrconst symboltable relabelisymbols$^        flagsrelabelisymbols.empty$^             nullptr$^             symboltablereadtextflagsrelabelisymbols opts$^    bool attachnewosymbols  fstoutputsymbols  nullptr$^    stduniqueptrconst symboltable oldosymbols$^        flagsosymbols.empty  nullptr$^                                symboltablereadtextflagsosymbols opts$^    const stduniqueptrconst symboltable relabelosymbols$^        flagsrelabelosymbols.empty$^             nullptr$^             symboltablereadtextflagsrelabelosymbols opts$^    srelabelfst.get$^               oldisymbols  oldisymbols.get  fstinputsymbols$^               relabelisymbols.get flagsunknownisymbol$^               attachnewisymbols$^               oldosymbols  oldosymbols.get  fstoutputsymbols$^               relabelosymbols.get flagsunknownosymbol$^               attachnewosymbols$^   else $^     reads in relabeling pairs.$^    stdvectorslabelpair ipairs$^    stdvectorslabelpair opairs$^    if flagsrelabelipairs.empty $^      if fstreadlabelpairsflagsrelabelipairs ipairs$^                                   flagsallownegativelabels$^        return 0$^    $^    if flagsrelabelopairs.empty $^      if fstreadlabelpairsflagsrelabelopairs opairs$^                                   flagsallownegativelabels$^        return 0$^    $^    srelabelfst.get ipairs opairs$^  $^$^  return fstwriteoutname$^$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^ prunes states and arcs of an fst w.r.t. the shortest path weight.$^$^include cstring$^$^include memory$^include string$^$^include fstflags.h$^include fstscriptprune.h$^$^declaredoubledelta$^declareint00nstate$^declarestringweight$^$^int fstprunemainint argc char argv $^  namespace s  fstscript$^  using fstscriptmutablefstclass$^  using fstscriptweightclass$^$^  string usage  prunes states and arcs of an fst.nn  usage $^  usage  argv0$^  usage   in.fst out.fstn$^$^  stdsetnewhandlerfailednewhandler$^  setflagsusage.cstr argc argv true$^  if argc  0 $^    showusage$^    return 0$^  $^$^  const string inname  argc  0  strcmpargv0   0  argv0  $^  const string outname  argc  0  argv0  $^$^  stduniqueptrmutablefstclass fstmutablefstclassreadinname true$^  if fst return 0$^$^  const auto weightthreshold $^      flagsweight.empty  weightclasszerofstweighttype$^                            weightclassfstweighttype flagsweight$^$^  sprunefst.get weightthreshold flagsnstate flagsdelta$^$^  return fstwriteoutname$^$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstcompat.h$^include fstflags.h$^$^definestringsorttype ilabel$^              comparison method one of ilabel olabel$^$^int fstarcsortmainint argc char argv$^$^int mainint argc char argv  return fstarcsortmainargc argv $^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^ composes two fsts.$^$^include cstring$^$^include memory$^include string$^$^include fstflags.h$^include fstlog.h$^include fstscriptcompose.h$^include fstscriptgetters.h$^$^declarestringcomposefilter$^declareboolconnect$^$^int fstcomposemainint argc char argv $^  namespace s  fstscript$^  using fstcomposefilter$^  using fstcomposeoptions$^  using fstscriptfstclass$^  using fstscriptvectorfstclass$^$^  string usage  composes two fsts.nn  usage $^  usage  argv0$^  usage   in0.fst in0.fst out.fstn$^$^  stdsetnewhandlerfailednewhandler$^  setflagsusage.cstr argc argv true$^  if argc  0  argc  0 $^    showusage$^    return 0$^  $^$^  const string in0name  strcmpargv0   0  argv0  $^  const string in0name $^      argc  0  strcmpargv0   0  argv0  $^  const string outname  argc  0  argv0  $^$^  if in0name.empty  in0name.empty $^    logerror  argv0   cant take both inputs from standard input$^    return 0$^  $^$^  stduniqueptrfstclass ifst0fstclassreadin0name$^  if ifst0 return 0$^$^  stduniqueptrfstclass ifst0fstclassreadin0name$^  if ifst0 return 0$^$^  if ifst0arctype  ifst0arctype $^    logerror  argv0   input fsts must have the same arc type$^    return 0$^  $^$^  vectorfstclass ofstifst0arctype$^$^  composefilter composefilter$^  if sgetcomposefilterflagscomposefilter composefilter $^    logerror  argv0   unknown or unsupported compose filter type $^                flagscomposefilter$^    return 0$^  $^$^  const composeoptions optsflagsconnect composefilter$^$^  scomposeifst0 ifst0 ofst opts$^$^  return ofst.writeoutname$^$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstflags.h$^include fstshortestdistance.h$^include fstweight.h$^$^definedoubledelta fstkshortestdelta comparisonquantization delta$^defineboolallownondet false minimize nondeterministic fsts$^$^int fstminimizemainint argc char argv$^$^int mainint argc char argv  return fstminimizemainargc argv $^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^ subtracts an unweighted dfa from an fsa.$^$^include cstring$^$^include memory$^include string$^$^include fstflags.h$^include fstlog.h$^include fstscriptgetters.h$^include fstscriptdifference.h$^$^declarestringcomposefilter$^declareboolconnect$^$^int fstdifferencemainint argc char argv $^  namespace s  fstscript$^  using fstcomposefilter$^  using fstdifferenceoptions$^  using fstscriptfstclass$^  using fstscriptvectorfstclass$^$^  string usage  subtracts an unweighted dfa from an fsa.nn  usage $^  usage  argv0$^  usage   in0.fst in0.fst out.fstn$^$^  stdsetnewhandlerfailednewhandler$^  setflagsusage.cstr argc argv true$^  if argc  0  argc  0 $^    showusage$^    return 0$^  $^$^  const string in0name  strcmpargv0   0    argv0$^  const string in0name  strcmpargv0   0    argv0$^  const string outname  argc  0  argv0  $^$^  if in0name.empty  in0name.empty $^    logerror  argv0   cant take both inputs from standard input$^    return 0$^  $^$^  stduniqueptrfstclass ifst0fstclassreadin0name$^  if ifst0 return 0$^$^  stduniqueptrfstclass ifst0fstclassreadin0name$^  if ifst0 return 0$^$^  vectorfstclass ofstifst0arctype$^$^  composefilter composefilter$^  if sgetcomposefilterflagscomposefilter composefilter $^    logerror  argv0   unknown or unsupported compose filter type $^                flagscomposefilter$^    return 0$^  $^$^  const differenceoptions optsflagsconnect composefilter$^$^  sdifferenceifst0 ifst0 ofst opts$^$^  return ofst.writeoutname$^$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^int fstinvertmainint argc char argv$^$^int mainint argc char argv  return fstinvertmainargc argv $^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstflags.h$^include fstfst.h$^include fstweight.h$^$^definedoubledelta fstkdelta comparisonquantization delta$^definestringweight  weight threshold$^defineint00nstate fstknostateid state number threshold$^defineint00subsequentiallabel 0$^             input label of arc corresponding to residual final output when$^              producing a subsequential transducer$^definestringdettype functional$^              type of determinization functional $^              nonfunctional disambiguate$^defineboolincrementsubsequentiallabel false$^            increment subsequentiallabel to obtain distinct labels for $^             subsequential arcs at a given state$^$^int fstdeterminizemainint argc char argv$^$^int mainint argc char argv  return fstdeterminizemainargc argv $^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^ creates the kleene closure of an fst.$^$^include cstring$^$^include memory$^include string$^$^include fstflags.h$^include fstscriptclosure.h$^include fstscriptgetters.h$^$^declareboolclosureplus$^$^int fstclosuremainint argc char argv $^  namespace s  fstscript$^  using fstscriptmutablefstclass$^$^  string usage  creates the kleene closure of an fst.nn  usage $^  usage  argv0$^  usage   in.fst out.fstn$^$^  stdsetnewhandlerfailednewhandler$^  setflagsusage.cstr argc argv true$^  if argc  0 $^    showusage$^    return 0$^  $^$^  const string inname  argc  0  strcmpargv0   0  argv0  $^  const string outname  argc  0  argv0  $^$^  stduniqueptrmutablefstclass fstmutablefstclassreadinname true$^  if fst return 0$^$^  sclosurefst.get sgetclosuretypeflagsclosureplus$^$^  return fstwriteoutname$^$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstflags.h$^$^definestringcomposefilter auto$^              composition filter one of altsequence auto $^              match null sequence trivial$^defineboolconnect true trim output$^$^int fstdifferencemainint argc char argv$^$^int mainint argc char argv  return fstdifferencemainargc argv $^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstflags.h$^include fstweight.h$^$^definedoubledelta fstkdelta comparisonquantization delta$^$^int fstequalmainint argc char argv$^$^int mainint argc char argv  return fstequalmainargc argv $^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^ prints out binary fsts in simple text format used by att.$^$^include cstring$^$^include fstream$^include memory$^include ostream$^include string$^$^include fstflags.h$^include fstlog.h$^include fstscriptprint.h$^$^declareboolacceptor$^declarestringisymbols$^declarestringosymbols$^declarestringssymbols$^declareboolnumeric$^declarestringsaveisymbols$^declarestringsaveosymbols$^declareboolshowweightone$^declareboolallownegativelabels$^declarestringmissingsymbol$^$^int fstprintmainint argc char argv $^  namespace s  fstscript$^  using fstscriptfstclass$^  using fstsymboltable$^  using fstsymboltabletextoptions$^$^  string usage  prints out binary fsts in simple text format.nn  usage $^  usage  argv0$^  usage   binary.fst text.fstn$^$^  stdsetnewhandlerfailednewhandler$^  setflagsusage.cstr argc argv true$^  if argc  0 $^    showusage$^    return 0$^  $^$^  const string inname  argc  0  strcmpargv0   0  argv0  $^  const string outname  argc  0  argv0  $^$^  stduniqueptrfstclass fstfstclassreadinname$^  if fst return 0$^$^  string dest  standard output$^  stdofstream fstrm$^  if argc  0 $^    fstrm.openargv0$^    if fstrm $^      logerror  argv0   open failed file    argv0$^      return 0$^    $^    dest  argv0$^  $^  stdostream ostrm  fstrm.isopen  fstrm  stdcout$^  ostrm.precision0$^$^  const symboltabletextoptions optsflagsallownegativelabels$^$^  stduniqueptrconst symboltable isyms$^  if flagsisymbols.empty  flagsnumeric $^    isyms.resetsymboltablereadtextflagsisymbols opts$^    if isyms return 0$^  $^$^  stduniqueptrconst symboltable osyms$^  if flagsosymbols.empty  flagsnumeric $^    osyms.resetsymboltablereadtextflagsosymbols opts$^    if osyms return 0$^  $^$^  stduniqueptrconst symboltable ssyms$^  if flagsssymbols.empty  flagsnumeric $^    ssyms.resetsymboltablereadtextflagsssymbols$^    if ssyms return 0$^  $^$^  if isyms  flagsnumeric  fstinputsymbols $^    isyms.resetfstinputsymbolscopy$^  $^$^  if osyms  flagsnumeric  fstoutputsymbols $^    osyms.resetfstoutputsymbolscopy$^  $^$^  sprintfstfst ostrm dest isyms.get osyms.get ssyms.get$^              flagsacceptor flagsshowweightone flagsmissingsymbol$^$^  if isyms  flagssaveisymbols.empty $^    if isymswritetextflagssaveisymbols return 0$^  $^$^  if osyms  flagssaveosymbols.empty $^    if osymswritetextflagssaveosymbols return 0$^  $^$^  return 0$^$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^ synchronizes an fst.$^$^include cstring$^$^include memory$^include string$^$^include fstflags.h$^include fstscriptsynchronize.h$^$^int fstsynchronizemainint argc char argv $^  namespace s  fstscript$^  using fstscriptfstclass$^  using fstscriptvectorfstclass$^$^  string usage  synchronizes an fst.nn  usage $^  usage  argv0$^  usage   in.fst out.fstn$^$^  stdsetnewhandlerfailednewhandler$^  setflagsusage.cstr argc argv true$^  if argc  0 $^    showusage$^    return 0$^  $^$^  const string inname  argc  0  strcmpargv0   0  argv0  $^  const string outname  argc  0  argv0  $^$^  stduniqueptrfstclass ifstfstclassreadinname$^  if ifst return 0$^$^  vectorfstclass ofstifstarctype$^$^  ssynchronizeifst ofst$^$^  return ofst.writeoutname$^$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^ find shortest distances in an fst.$^$^include cstring$^$^include memory$^include string$^include vector$^$^include fstflags.h$^include fstlog.h$^include fstscriptgetters.h$^include fstscriptshortestdistance.h$^include fstscripttextio.h$^$^declareboolreverse$^declaredoubledelta$^declareint00nstate$^declarestringqueuetype$^$^int fstshortestdistancemainint argc char argv $^  namespace s  fstscript$^  using fstscriptfstclass$^  using fstscriptweightclass$^  using fstqueuetype$^  using fstautoqueue$^$^  string usage  finds shortest distances in an fst.nn  usage $^  usage  argv0$^  usage   in.fst distance.txtn$^$^  stdsetnewhandlerfailednewhandler$^  setflagsusage.cstr argc argv true$^  if argc  0 $^    showusage$^    return 0$^  $^$^  string inname  argc  0  strcmpargv0   0  argv0  $^  string outname  argc  0  argv0  $^$^  stduniqueptrfstclass ifstfstclassreadinname$^  if ifst return 0$^$^  stdvectorweightclass distance$^$^  queuetype queuetype$^  if sgetqueuetypeflagsqueuetype queuetype $^    logerror  argv0$^                 unknown or unsupported queue type   flagsqueuetype$^    return 0$^  $^$^  if flagsreverse  queuetype  autoqueue $^    logerror  argv0   cant use nondefault queue with reverse$^    return 0$^  $^$^  if flagsreverse $^    sshortestdistanceifst distance flagsreverse flagsdelta$^   else $^    const sshortestdistanceoptions optsqueuetype sanyarcfilter$^                                          flagsnstate flagsdelta$^    sshortestdistanceifst distance opts$^  $^$^  return swritepotentialsoutname distance$^$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^ two fsts are equal iff their exit status is zero.$^$^include cstring$^$^include memory$^include string$^$^include fstflags.h$^include fstlog.h$^include fstscriptequal.h$^$^declaredoubledelta$^$^int fstequalmainint argc char argv $^  namespace s  fstscript$^  using fstscriptfstclass$^$^  string usage  two fsts are equal iff the exit status is zero.nn  usage $^  usage  argv0$^  usage   in0.fst in0.fstn$^$^  stdsetnewhandlerfailednewhandler$^  setflagsusage.cstr argc argv true$^  if argc  0 $^    showusage$^    return 0$^  $^$^  const string in0name  strcmpargv0   0    argv0$^  const string in0name  strcmpargv0   0    argv0$^$^  if in0name.empty  in0name.empty $^    logerror  argv0   cant take both inputs from standard input$^    return 0$^  $^$^  stduniqueptrfstclass ifst0fstclassreadin0name$^  if ifst0 return 0$^$^  stduniqueptrfstclass ifst0fstclassreadin0name$^  if ifst0 return 0$^$^  bool result  sequalifst0 ifst0 flagsdelta$^  if result vlog0  fsts are not equal.$^$^  return result  0  0$^$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^int fstconnectmainint argc char argv$^$^int mainint argc char argv  return fstconnectmainargc argv $^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstflags.h$^$^definestringcomposefilter auto$^              composition filter one of altsequence auto $^              match null sequence trivial$^defineboolconnect true trim output$^$^int fstcomposemainint argc char argv$^$^int mainint argc char argv  return fstcomposemainargc argv $^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^ determinizes an fst.$^$^include cstring$^$^include memory$^include string$^$^include fstflags.h$^include fstscriptdeterminize.h$^include fstscriptgetters.h$^$^declaredoubledelta$^declarestringweight$^declareint00nstate$^declareint00subsequentiallabel$^declarestringdettype$^declareboolincrementsubsequentiallabel$^$^int fstdeterminizemainint argc char argv $^  namespace s  fstscript$^  using fstdeterminizetype$^  using fstscriptfstclass$^  using fstscriptvectorfstclass$^  using fstscriptweightclass$^$^  string usage  determinizes an fst.nn  usage $^  usage  argv0$^  usage   in.fst out.fstn$^$^  stdsetnewhandlerfailednewhandler$^  setflagsusage.cstr argc argv true$^  if argc  0 $^    showusage$^    return 0$^  $^$^  determinizetype dettype$^  if sgetdeterminizetypeflagsdettype dettype $^    logerror  argv0   unknown or unsupported determinization type $^                           flagsdettype$^    return 0$^  $^$^  const string inname  argc  0  strcmpargv0   0  argv0  $^  const string outname  argc  0  argv0  $^$^  stduniqueptrfstclass ifstfstclassreadinname$^  if ifst return 0$^$^  vectorfstclass ofstifstarctype$^$^  const auto weightthreshold $^      flagsweight.empty  weightclasszeroifstweighttype$^                            weightclassifstweighttype flagsweight$^$^  const sdeterminizeoptions optsflagsdelta weightthreshold flagsnstate$^                                   flagssubsequentiallabel dettype$^                                   flagsincrementsubsequentiallabel$^$^  sdeterminizeifst ofst opts$^$^  return ofst.writeoutname$^$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^int fstsynchronizemainint argc char argv$^$^int mainint argc char argv  return fstsynchronizemainargc argv $^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstflags.h$^include fstfst.h$^include fstshortestdistance.h$^include fstweight.h$^$^defineboolreverse false perform in the reverse direction$^definedoubledelta fstkshortestdelta comparisonquantization delta$^defineint00nstate fstknostateid state number threshold$^definestringqueuetype auto$^              queue type one of auto $^              fifo lifo shortest state top$^$^int fstshortestdistancemainint argc char argv$^$^int mainint argc char argv  return fstshortestdistancemainargc argv $^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^int fstunionmainint argc char argv$^$^int mainint argc char argv  return fstunionmainargc argv $^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^ generates random paths through an fst.$^$^include cstring$^$^include memory$^include string$^$^include fstflags.h$^include fstlog.h$^include fstscriptgetters.h$^include fstscriptrandgen.h$^$^declareint00maxlength$^declareint00npath$^declareint00seed$^declarestringselect$^declareboolweighted$^declareboolremovetotalweight$^$^int fstrandgenmainint argc char argv $^  namespace s  fstscript$^  using fstscriptfstclass$^  using fstscriptvectorfstclass$^$^  string usage  generates random paths through an fst.nn  usage $^  usage  argv0$^  usage   in.fst out.fstn$^$^  stdsetnewhandlerfailednewhandler$^  setflagsusage.cstr argc argv true$^  if argc  0 $^    showusage$^    return 0$^  $^$^  vlog0  argv0   seed    flagsseed$^$^  const string inname  argc  0  strcmpargv0   0  argv0  $^  const string outname  argc  0  argv0  $^$^  stduniqueptrfstclass ifstfstclassreadinname$^  if ifst return 0$^$^  vectorfstclass ofstifstarctype$^$^  srandarcselection ras$^  if sgetrandarcselectionflagsselect ras $^    logerror  argv0   unknown or unsupported select type $^                flagsselect$^    return 0$^  $^$^  srandgenifst ofst flagsseed$^             fstrandgenoptionssrandarcselection$^                 ras flagsmaxlength flagsnpath flagsweighted$^                 flagsremovetotalweight$^$^  return ofst.writeoutname$^$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^ creates the union of two fsts.$^$^include cstring$^$^include memory$^include string$^$^include fstflags.h$^include fstlog.h$^include fstscriptunion.h$^$^int fstunionmainint argc char argv $^  namespace s  fstscript$^  using fstscriptfstclass$^  using fstscriptmutablefstclass$^$^  string usage  creates the union of two fsts.nn  usage $^  usage  argv0$^  usage   in0.fst in0.fst out.fstn$^$^  stdsetnewhandlerfailednewhandler$^  setflagsusage.cstr argc argv true$^  if argc  0  argc  0 $^    showusage$^    return 0$^  $^$^  const string in0name  strcmpargv0   0  argv0  $^  const string in0name  strcmpargv0   0  argv0  $^  const string outname  argc  0  argv0  $^$^  if in0name    in0name   $^    logerror  argv0   cant take both inputs from standard input$^    return 0$^  $^$^  stduniqueptrmutablefstclass fst0mutablefstclassreadin0name true$^  if fst0 return 0$^$^  stduniqueptrfstclass fst0fstclassreadin0name$^  if fst0 return 0$^$^  sunionfst0.get fst0$^$^  return fst0writeoutname$^$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^ inverts a transduction.$^$^include cstring$^$^include memory$^include string$^$^include fstflags.h$^include fstscriptinvert.h$^$^int fstinvertmainint argc char argv $^  namespace s  fstscript$^  using fstscriptmutablefstclass$^$^  string usage  inverts a transduction.nn  usage $^  usage  argv0$^  usage   in.fst out.fstn$^$^  stdsetnewhandlerfailednewhandler$^  setflagsusage.cstr argc argv true$^  if argc  0 $^    showusage$^    return 0$^  $^$^  const string inname  argc  0  strcmpargv0   0  argv0  $^  const string outname  argc  0  argv0  $^$^  stduniqueptrmutablefstclass fstmutablefstclassreadinname true$^  if fst return 0$^$^  sinvertfst.get$^$^  return fstwriteoutname$^$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstflags.h$^include fstfst.h$^include fstweight.h$^$^definedoubledelta fstkdelta comparisonquantization delta$^defineint00nstate fstknostateid state number threshold$^definestringweight  weight threshold$^defineint00subsequentiallabel 0$^             input label of arc corresponding to residual final output when$^              producing a subsequential transducer$^$^int fstdisambiguatemainint argc char argv$^$^int mainint argc char argv  return fstdisambiguatemainargc argv $^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^ removes epsilons from an fst.$^$^include cstring$^$^include memory$^include string$^$^include fstflags.h$^include fstlog.h$^include fstscriptgetters.h$^include fstscriptrmepsilon.h$^$^declareboolconnect$^declaredoubledelta$^declareint00nstate$^declarestringqueuetype$^declarestringweight$^$^int fstrmepsilonmainint argc char argv $^  namespace s  fstscript$^  using fstscriptmutablefstclass$^  using fstscriptweightclass$^$^  string usage  removes epsilons from an fst.nn  usage $^  usage  argv0$^  usage   in.fst out.fstn$^$^  stdsetnewhandlerfailednewhandler$^  setflagsusage.cstr argc argv true$^  if argc  0 $^    showusage$^    return 0$^  $^$^  const string inname  argc  0  strcmpargv0   0  argv0  $^  const string outname  argc  0  argv0  $^$^  stduniqueptrmutablefstclass fstmutablefstclassreadinname true$^  if fst return 0$^$^  const auto weightthreshold $^      flagsweight.empty  weightclasszerofstweighttype$^                            weightclassfstweighttype flagsweight$^$^  fstqueuetype queuetype$^  if sgetqueuetypeflagsqueuetype queuetype $^    logerror  argv0$^                 unknown or unsupported queue type   flagsqueuetype$^    return 0$^  $^$^  const srmepsilonoptions optsqueuetype flagsconnect weightthreshold$^                                 flagsnstate flagsdelta$^$^  srmepsilonfst.get opts$^$^  return fstwriteoutname$^$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstflags.h$^$^definebooltofinal false pushreweight to final vs. to initial states$^$^int fstreweightmainint argc char argv$^$^int mainint argc char argv  return fstreweightmainargc argv $^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstflags.h$^include fstfst.h$^include fstshortestdistance.h$^include fstweight.h$^$^definedoubledelta fstkshortestdelta comparisonquantization delta$^defineint00nshortest 0 return nshortest paths$^defineint00nstate fstknostateid state number threshold$^definestringqueuetype auto$^              queue type one of auto $^              fifo lifo shortest state top$^defineboolunique false return unique strings$^definestringweight  weight threshold$^$^int fstshortestpathmainint argc char argv$^$^int mainint argc char argv  return fstshortestpathmainargc argv $^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^ intersects two fsts.$^$^include cstring$^$^include memory$^include string$^$^include fstflags.h$^include fstlog.h$^include fstscriptgetters.h$^include fstscriptintersect.h$^$^declarestringcomposefilter$^declareboolconnect$^$^int fstintersectmainint argc char argv $^  namespace s  fstscript$^  using fstcomposefilter$^  using fstscriptfstclass$^  using fstscriptvectorfstclass$^$^  string usage  intersects two fsas.nn  usage $^  usage  argv0$^  usage   in0.fst in0.fst out.fstn$^  usage    flags connectn$^$^  stdsetnewhandlerfailednewhandler$^  setflagsusage.cstr argc argv true$^  if argc  0  argc  0 $^    showusage$^    return 0$^  $^$^  const string in0name  strcmpargv0   0    argv0$^  const string in0name  strcmpargv0   0    argv0$^  const string outname  argc  0  argv0  $^$^  if in0name.empty  in0name.empty $^    logerror  argv0   cant take both inputs from standard input$^    return 0$^  $^$^  stduniqueptrfstclass ifst0fstclassreadin0name$^  if ifst0 return 0$^  stduniqueptrfstclass ifst0fstclassreadin0name$^  if ifst0 return 0$^$^  vectorfstclass ofstifst0arctype$^$^  composefilter composefilter$^  if sgetcomposefilterflagscomposefilter composefilter $^    logerror  argv0   unknown or unsupported compose filter type $^                flagscomposefilter$^    return 0$^  $^$^  const fstintersectoptions optsflagsconnect composefilter$^$^  sintersectifst0 ifst0 ofst opts$^$^  return ofst.writeoutname$^$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstflags.h$^$^definestringcomposefilter auto$^             composition filter one of altsequence auto $^              match null sequence trivial$^defineboolconnect true trim output$^$^int fstintersectmainint argc char argv$^$^int mainint argc char argv  return fstintersectmainargc argv $^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstflags.h$^$^defineboolprojectoutput false project on output vs. input$^$^int fstprojectmainint argc char argv$^$^int mainint argc char argv  return fstprojectmainargc argv $^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstflags.h$^$^defineboolepsnormoutput false normalize output epsilons$^$^int fstepsnormalizemainint argc char argv$^$^int mainint argc char argv  return fstepsnormalizemainargc argv $^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstflags.h$^$^defineboolclosureplus false$^            do not add the empty path t instead of t$^$^int fstclosuremainint argc char argv$^$^int mainint argc char argv  return fstclosuremainargc argv $^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstflags.h$^$^definestringcallarclabeling input$^              which labels to make nonepsilon on the call arc. $^              one of input default output both neither$^definestringreturnarclabeling neither$^              which labels to make nonepsilon on the return arc. $^              one of input output both neither default$^defineint00returnlabel 0 label to put on return arc$^defineboolepsilononreplace false callreturn arcs are epsilon arcs$^$^int fstreplacemainint argc char argv$^$^int mainint argc char argv  return fstreplacemainargc argv $^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^ performs operations set clear relabel on the symbols table attached to an$^ input fst.$^$^include cstring$^$^include memory$^include string$^include vector$^$^include fstflags.h$^include fstutil.h$^include fstscriptfstclass.h$^include fstscriptverify.h$^$^declarestringisymbols$^declarestringosymbols$^declareboolclearisymbols$^declareboolclearosymbols$^declarestringrelabelipairs$^declarestringrelabelopairs$^declarestringsaveisymbols$^declarestringsaveosymbols$^declareboolallownegativelabels$^declareboolverify$^$^int fstsymbolsmainint argc char argv $^  namespace s  fstscript$^  using fstscriptmutablefstclass$^  using fstreadlabelpairs$^  using fstsymboltable$^  using fstsymboltabletextoptions$^$^  string usage $^      performs operations set clear relabel on the symbol$^       tables attached to an fst.nn  usage $^  usage  argv0$^  usage   in.fst out.fstn$^$^  stdsetnewhandlerfailednewhandler$^  setflagsusage.cstr argc argv true$^  if argc  0 $^    showusage$^    return 0$^  $^$^  const string inname  argc  0  strcmpargv0   0  argv0  $^  const string outname  argc  0  argv0  $^$^  stduniqueptrmutablefstclass fstmutablefstclassreadinname true$^  if fst return 0$^$^  if flagssaveisymbols.empty $^    const auto isyms  fstinputsymbols$^    if isyms $^      isymswritetextflagssaveisymbols$^     else $^      logerror  argv0$^                   saving isymbols but there are no input symbols.$^    $^  $^$^  if flagssaveosymbols.empty $^    const auto osyms  fstoutputsymbols$^    if osyms $^      osymswritetextflagssaveosymbols$^     else $^      logerror  argv0$^                   saving osymbols but there are no output symbols.$^    $^  $^$^  const symboltabletextoptions optsflagsallownegativelabels$^$^  stduniqueptrsymboltable isyms$^  if flagsisymbols.empty $^    isyms.resetsymboltablereadtextflagsisymbols opts$^    fstsetinputsymbolsisyms.get$^   else if flagsclearisymbols $^    fstsetinputsymbolsnullptr$^  $^  stduniqueptrsymboltable osyms$^  if flagsosymbols.empty $^    osyms.resetsymboltablereadtextflagsosymbols opts$^    fstsetoutputsymbolsosyms.get$^   else if flagsclearosymbols $^    fstsetoutputsymbolsnullptr$^  $^$^  using label  int00$^  if flagsrelabelipairs.empty $^    stdvectorstdpairlabel label ipairs$^    readlabelpairsflagsrelabelipairs ipairs flagsallownegativelabels$^    stduniqueptrsymboltable isymsrelabel$^        relabelsymboltablefstinputsymbols ipairs$^    fstsetinputsymbolsisymsrelabel.get$^  $^  if flagsrelabelopairs.empty $^    stdvectorstdpairlabel label opairs$^    readlabelpairsflagsrelabelopairs opairs flagsallownegativelabels$^    stduniqueptrsymboltable osymsrelabel$^        relabelsymboltablefstoutputsymbols opairs$^    fstsetoutputsymbolsosymsrelabel.get$^  $^$^  if flagsverify  sverifyfst return 0$^$^  return fstwriteoutname$^$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^ two dfas are equivalent iff their exit status is zero.$^$^include cstring$^$^include memory$^include string$^$^include fstflags.h$^include fstlog.h$^include fstscriptequivalent.h$^include fstscriptgetters.h$^include fstscriptrandequivalent.h$^$^declaredoubledelta$^declareboolrandom$^declareint00maxlength$^declareint00npath$^declareint00seed$^declarestringselect$^$^int fstequivalentmainint argc char argv $^  namespace s  fstscript$^  using fstrandgenoptions$^  using fstscriptfstclass$^$^  string usage $^      two dfas are equivalent iff the exit status is zero.nn$^        usage $^  usage  argv0$^  usage   in0.fst in0.fstn$^$^  stdsetnewhandlerfailednewhandler$^  setflagsusage.cstr argc argv true$^  if argc  0 $^    showusage$^    return 0$^  $^$^  const string in0name  strcmpargv0   0    argv0$^  const string in0name  strcmpargv0   0    argv0$^$^  if in0name.empty  in0name.empty $^    logerror  argv0   cant take both inputs from standard input$^    return 0$^  $^$^  stduniqueptrfstclass ifst0fstclassreadin0name$^  if ifst0 return 0$^$^  stduniqueptrfstclass ifst0fstclassreadin0name$^  if ifst0 return 0$^$^  if flagsrandom $^    bool result  sequivalentifst0 ifst0 flagsdelta$^    if result vlog0  fsts are not equivalent$^    return result  0  0$^   else $^    srandarcselection ras$^    if sgetrandarcselectionflagsselect ras $^      logerror  argv0   unknown or unsupported select type $^                             flagsselect$^      return 0$^    $^    const randgenoptionssrandarcselection optsras flagsmaxlength$^    bool result  srandequivalentifst0 ifst0 flagsnpath flagsdelta$^                                    flagsseed opts$^    if result vlog0  fsts are not equivalent$^    return result  0  0$^  $^$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^ prints out various information about an fst such as number of states$^ and arcs and property values see properties.h.$^$^include cstring$^$^include memory$^include string$^$^include fstflags.h$^include fstscriptinfo.h$^$^declarestringarcfilter$^declarestringinfotype$^declareboolpipe$^declarebooltestproperties$^declareboolfstverify$^$^int fstinfomainint argc char argv $^  namespace s  fstscript$^  using fstscriptfstclass$^$^  string usage  prints out information about an fst.nn  usage $^  usage  argv0$^  usage   in.fstn$^$^  stdsetnewhandlerfailednewhandler$^  setflagsusage.cstr argc argv true$^  if argc  0 $^    showusage$^    return 0$^  $^$^  const string inname $^      argc  0  strcmpargv0   0  argv0  $^$^  stduniqueptrfstclass ifstfstclassreadinname$^  if ifst return 0$^$^  sprintfstinfoifst flagstestproperties flagsarcfilter$^                  flagsinfotype flagsfstverify flagspipe$^$^  return 0$^$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^int fstconcatmainint argc char argv$^$^int mainint argc char argv  return fstconcatmainargc argv $^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstflags.h$^$^definestringarcfilter any$^              arc filter one of$^               any epsilon iepsilon oepsilon $^              this only affects the counts of coaccessible states $^              connected states and strongly connected components$^definestringinfotype auto$^              info format one of auto long short$^defineboolpipe false send info to stderr input to stdout$^definebooltestproperties true$^            compute property values if unknown to fst$^defineboolfstverify true verify fst sanity$^$^int fstinfomainint argc char argv$^$^int mainint argc char argv  return fstinfomainargc argv $^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstflags.h$^$^defineboolacceptor false input in acceptor format$^definestringisymbols  input label symbol table$^definestringosymbols  output label symbol table$^definestringssymbols  state label symbol table$^defineboolnumeric false print numeric labels$^definestringsaveisymbols  save input symbol table to file$^definestringsaveosymbols  save output symbol table to file$^defineboolshowweightone false$^            printdraw arc weights and final weights equal to semiring one$^defineboolallownegativelabels false$^            allow negative labels not recommended may cause conflicts$^definestringmissingsymbol $^              symbol to print when lookup fails default raises error$^$^int fstprintmainint argc char argv$^$^int mainint argc char argv  return fstprintmainargc argv $^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstflags.h$^include fstfst.h$^include fstweight.h$^$^definedoubledelta fstkdelta comparisonquantization delta$^defineint00nstate fstknostateid state number threshold$^definestringweight  weight threshold$^$^int fstprunemainint argc char argv$^$^int mainint argc char argv  return fstprunemainargc argv $^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^ find shortest paths in an fst.$^$^include cstring$^$^include memory$^include string$^include vector$^$^include fstflags.h$^include fstlog.h$^include fstscriptgetters.h$^include fstscriptshortestpath.h$^$^declaredoubledelta$^declareint00nshortest$^declareint00nstate$^declarestringqueuetype$^declareboolunique$^declarestringweight$^$^int fstshortestpathmainint argc char argv $^  namespace s  fstscript$^  using fstscriptfstclass$^  using fstscriptweightclass$^  using fstscriptvectorfstclass$^$^  string usage  finds shortest paths in an fst.nn  usage $^  usage  argv0$^  usage   in.fst out.fstn$^$^  stdsetnewhandlerfailednewhandler$^  setflagsusage.cstr argc argv true$^  if argc  0 $^    showusage$^    return 0$^  $^$^  const string inname $^      argc  0  strcmpargv0   0  argv0  $^  const string outname  argc  0  argv0  $^$^  stduniqueptrfstclass ifstfstclassreadinname$^  if ifst return 0$^$^  const auto weightthreshold $^      flagsweight.empty  weightclasszeroifstweighttype$^                            weightclassifstweighttype flagsweight$^$^  vectorfstclass ofstifstarctype$^$^  fstqueuetype queuetype$^  if sgetqueuetypeflagsqueuetype queuetype $^    logerror  unknown or unsupported queue type   flagsqueuetype$^    return 0$^  $^$^  const sshortestpathoptions optsqueuetype flagsnshortest$^                                    flagsunique flagsdelta$^                                    weightthreshold flagsnstate$^$^  sshortestpathifst ofst opts$^$^  return ofst.writeoutname$^$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^ pushes weights andor output labels in an fst toward the initial or final$^ states.$^$^include cstring$^$^include memory$^include string$^$^include fstflags.h$^include fstscriptgetters.h$^include fstscriptpush.h$^$^declaredoubledelta$^declareboolpushweights$^declareboolpushlabels$^declareboolremovetotalweight$^declareboolremovecommonaffix$^declarebooltofinal$^$^int fstpushmainint argc char argv $^  namespace s  fstscript$^  using fstscriptfstclass$^  using fstscriptvectorfstclass$^$^  string usage  pushes weights andor olabels in an fst.nn  usage $^  usage  argv0$^  usage   in.fst out.fstn$^$^  stdsetnewhandlerfailednewhandler$^  setflagsusage.cstr argc argv true$^  if argc  0 $^    showusage$^    return 0$^  $^$^  string inname  argc  0  strcmpargv0   0  argv0  $^  string outname  argc  0  argv0  $^$^  stduniqueptrfstclass ifstfstclassreadinname$^  if ifst return 0$^$^  const auto flags $^      sgetpushflagsflagspushweights flagspushlabels$^                      flagsremovetotalweight flagsremovecommonaffix$^$^  vectorfstclass ofstifstarctype$^$^  spushifst ofst flags sgetreweighttypeflagstofinal$^          flagsdelta$^$^  return ofst.writeoutname$^$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstflags.h$^$^definestringisymbols  input label symbol table$^definestringosymbols  output label symbol table$^defineboolclearisymbols false clear input symbol table$^defineboolclearosymbols false clear output symbol table$^definestringrelabelipairs  input relabel pairs numeric$^definestringrelabelopairs  output relabel pairs numeric$^definestringsaveisymbols  save fst files input symbol table to file$^definestringsaveosymbols  save fst files output symbol table to file$^defineboolallownegativelabels false$^            allow negative labels not recommended may cause conflicts$^defineboolverify false verify fst properities before saving$^$^int fstsymbolsmainint argc char argv$^$^int mainint argc char argv  return fstsymbolsmainargc argv $^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^ draws a binary fsts in the graphviz dot text format.$^$^include cstring$^$^include fstream$^include memory$^include ostream$^include string$^$^include fstflags.h$^include fstlog.h$^include fstscriptdraw.h$^$^declareboolacceptor$^declarestringisymbols$^declarestringosymbols$^declarestringssymbols$^declareboolnumeric$^declareint00precision$^declarestringfloatformat$^declareboolshowweightone$^declarestringtitle$^declareboolportrait$^declareboolvertical$^declareint00fontsize$^declaredoubleheight$^declaredoublewidth$^declaredoublenodesep$^declaredoubleranksep$^declareboolallownegativelabels$^$^int fstdrawmainint argc char argv $^  namespace s  fstscript$^  using fstscriptfstclass$^  using fstsymboltable$^  using fstsymboltabletextoptions$^$^  string usage  prints out binary fsts in dot text format.nn  usage $^  usage  argv0$^  usage   binary.fst text.dotn$^$^  stdsetnewhandlerfailednewhandler$^  setflagsusage.cstr argc argv true$^  if argc  0 $^    showusage$^    return 0$^  $^$^  const string inname  argc  0  strcmpargv0   0  argv0  $^$^  stduniqueptrfstclass fstfstclassreadinname$^  if fst return 0$^$^  string dest  stdout$^  stdofstream fstrm$^  if argc  0 $^    fstrm.openargv0$^    if fstrm $^      logerror  argv0   open failed file    argv0$^      return 0$^    $^    dest  argv0$^  $^  stdostream ostrm  fstrm.isopen  fstrm  stdcout$^$^  const symboltabletextoptions optsflagsallownegativelabels$^$^  stduniqueptrconst symboltable isyms$^  if flagsisymbols.empty  flagsnumeric $^    isyms.resetsymboltablereadtextflagsisymbols opts$^    if isyms return 0$^  $^$^  stduniqueptrconst symboltable osyms$^  if flagsosymbols.empty  flagsnumeric $^    osyms.resetsymboltablereadtextflagsosymbols opts$^    if osyms return 0$^  $^$^  stduniqueptrconst symboltable ssyms$^  if flagsssymbols.empty  flagsnumeric $^    ssyms.resetsymboltablereadtextflagsssymbols$^    if ssyms return 0$^  $^$^  if isyms  flagsnumeric  fstinputsymbols $^    isyms.resetfstinputsymbolscopy$^  $^$^  if osyms  flagsnumeric  fstoutputsymbols $^    osyms.resetfstoutputsymbolscopy$^  $^$^  sdrawfstfst isyms.get osyms.get ssyms.get flagsacceptor$^             flagstitle flagswidth flagsheight flagsportrait$^             flagsvertical flagsranksep flagsnodesep flagsfontsize$^             flagsprecision flagsfloatformat flagsshowweightone$^             ostrm dest$^$^  return 0$^$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstflags.h$^$^defineboolencodelabels false encode output labels$^defineboolencodeweights false encode weights$^defineboolencodereuse false reuse existing codex$^definebooldecode false decode labels andor weights$^$^int fstencodemainint argc char argv$^$^int mainint argc char argv  return fstencodemainargc argv $^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^ minimizes a deterministic fst.$^$^include cstring$^$^include memory$^include string$^$^include fstflags.h$^include fstlog.h$^include fstscriptminimize.h$^$^declaredoubledelta$^declareboolallownondet$^$^int fstminimizemainint argc char argv $^  namespace s  fstscript$^  using fstscriptmutablefstclass$^  using fstscriptvectorfstclass$^$^  string usage  minimizes a deterministic fst.nn  usage $^  usage  argv0$^  usage   in.fst out0.fst out0.fstn$^$^  stdsetnewhandlerfailednewhandler$^  setflagsusage.cstr argc argv true$^  if argc  0 $^    showusage$^    return 0$^  $^$^  const string inname  argc  0  strcmpargv0   0  argv0  $^  const string out0name $^      argc  0  strcmpargv0   0  argv0  $^  const string out0name $^      argc  0  strcmpargv0   0  argv0  $^$^  if out0name.empty  out0name.empty  argc  0 $^    logerror  argv0   both outputs cant be standard output.$^    return 0$^  $^$^  stduniqueptrmutablefstclass fst0mutablefstclassreadinname true$^  if fst0 return 0$^$^  if argc  0 $^    stduniqueptrmutablefstclass fst0new vectorfstclassfst0arctype$^    sminimizefst0.get fst0.get flagsdelta flagsallownondet$^    if fst0writeout0name return 0$^   else $^    sminimizefst0.get nullptr flagsdelta flagsallownondet$^  $^$^  return fst0writeout0name$^$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^ sorts arcs of an fst.$^$^include cstring$^$^include memory$^include string$^$^include fstflags.h$^include fstlog.h$^include fstscriptarcsort.h$^include fstscriptgetters.h$^$^declarestringsorttype$^$^int fstarcsortmainint argc char argv $^  namespace s  fstscript$^  using fstscriptmutablefstclass$^$^  string usage  sorts arcs of an fst.nn  usage $^  usage  argv0$^  usage   in.fst out.fstn$^$^  stdsetnewhandlerfailednewhandler$^  setflagsusage.cstr argc argv true$^$^  if argc  0 $^    showusage$^    return 0$^  $^$^  const string inname $^      argc  0  strcmpargv0   0  argv0  $^  const string outname  argc  0  argv0  $^$^  stduniqueptrmutablefstclass fstmutablefstclassreadinname true$^  if fst return 0$^$^  sarcsorttype sorttype$^  if sgetarcsorttypeflagssorttype sorttype $^    logerror  argv0   unknown or unsupported sort type $^                flagssorttype$^    return 0$^  $^$^  sarcsortfst.get sorttype$^$^  return fstwriteoutname$^$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstflags.h$^$^defineboolacceptor false input in acceptor format$^definestringarctype standard output arc type$^definestringfsttype vector output fst type$^definestringisymbols  input label symbol table$^definestringosymbols  output label symbol table$^definestringssymbols  state label symbol table$^defineboolkeepisymbols false store input label symbol table with fst$^defineboolkeeposymbols false store output label symbol table with fst$^defineboolkeepstatenumbering false do not renumber input states$^defineboolallownegativelabels false$^            allow negative labels not recommended may cause conflicts$^$^int fstcompilemainint argc char argv$^$^int mainint argc char argv  return fstcompilemainargc argv $^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstflags.h$^include fstweight.h$^$^definedoubledelta fstkdelta comparisonquantization delta$^defineboolpushweights false push weights$^defineboolpushlabels false push output labels$^defineboolremovetotalweight false$^            remove total weight when pushing weights$^defineboolremovecommonaffix false$^            remove common prefixsuffix when pushing labels$^definebooltofinal false pushreweight to final vs. to initial states$^$^int fstpushmainint argc char argv$^$^int mainint argc char argv  return fstpushmainargc argv $^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^ reverses the paths in an fst.$^$^include cstring$^$^include memory$^include string$^$^include fstflags.h$^include fstscriptfstclass.h$^include fstscriptreverse.h$^$^declareboolrequiresuperinitial$^$^int fstreversemainint argc char argv $^  namespace s  fstscript$^  using fstscriptfstclass$^  using fstscriptvectorfstclass$^$^  string usage  reverses the paths in an fst.nn  usage $^  usage  argv0$^  usage   in.fst out.fstn$^$^  stdsetnewhandlerfailednewhandler$^  setflagsusage.cstr argc argv true$^  if argc  0 $^    showusage$^    return 0$^  $^$^  const string inname $^      argc  0  strcmpargv0   0  argv0  $^  const string outname  argc  0  argv0  $^$^  stduniqueptrfstclass ifstfstclassreadinname$^  if ifst return 0$^$^  vectorfstclass ofstifstarctype$^$^  sreverseifst ofst flagsrequiresuperinitial$^$^  return ofst.writeoutname$^$^include unistd.h$^$^include climits$^include ctime$^$^include fstflags.h$^$^defineint00maxlength int00max maximum path length$^defineint00npath 0 number of paths to generate$^defineint00seed timenullptr  getpid random seed$^definestringselect uniform$^              selection type one of $^               uniform logprob when appropriate$^               fastlogprob when appropriate$^defineboolweighted false$^            output tree weighted by path count vs. unweighted paths$^defineboolremovetotalweight false$^            remove total weight when output weighted$^$^int fstrandgenmainint argc char argv$^$^int mainint argc char argv  return fstrandgenmainargc argv $^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^ concatenates two fsts.$^$^include cstring$^$^include memory$^include string$^$^include fstflags.h$^include fstlog.h$^include fstscriptconcat.h$^$^int fstconcatmainint argc char argv $^  namespace s  fstscript$^  using fstscriptfstclass$^  using fstscriptmutablefstclass$^$^  string usage  concatenates two fsts.nn  usage $^  usage  argv0$^  usage   in0.fst in0.fst out.fstn$^$^  stdsetnewhandlerfailednewhandler$^  setflagsusage.cstr argc argv true$^  if argc  0  argc  0 $^    showusage$^    return 0$^  $^$^  const string in0name  strcmpargv0   0    argv0$^  const string in0name  strcmpargv0   0    argv0$^  const string outname  argc  0  argv0  $^$^  if in0name.empty  in0name.empty $^    logerror  argv0   cant take both inputs from standard input$^    return 0$^  $^$^  stduniqueptrmutablefstclass fst0mutablefstclassreadin0name true$^  if fst0 return 0$^$^  stduniqueptrfstclass fst0fstclassreadin0name$^  if fst0 return 0$^$^  sconcatfst0.get fst0$^$^  return fst0writeoutname$^$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstflags.h$^include fstweight.h$^$^definedoubledelta fstkdelta comparisonquantization delta$^definestringmaptype identity$^              map operation one of arcsum arcunique $^              floatpower power identity inputepsilon $^              invert outputepsilon plus weight $^              quantize delta rmweight superfinal $^              power power times weight tolog $^              tolog00 tostd$^definedoublepower 0.0 power parameter$^definestringweight  weight parameter$^$^int fstmapmainint argc char argv$^$^int mainint argc char argv  return fstmapmainargc argv $^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstflags.h$^include fstfst.h$^include fstshortestdistance.h$^include fstweight.h$^$^defineboolconnect true trim output$^definedoubledelta fstkshortestdelta comparisonquantization delta$^defineint00nstate fstknostateid state number threshold$^definestringqueuetype auto$^              queue type one of auto $^              fifo lifo shortest state top$^definestringweight  weight threshold$^$^int fstrmepsilonmainint argc char argv$^$^int mainint argc char argv  return fstrmepsilonmainargc argv $^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^ performs the dynamic replacement of arcs in one fst with another fst$^ allowing for the definition of fsts analogous to rtns.$^$^include cstring$^$^include string$^include vector$^$^include fstflags.h$^include fstscriptgetters.h$^include fstscriptreplace.h$^$^declarestringcallarclabeling$^declarestringreturnarclabeling$^declareint00returnlabel$^declareboolepsilononreplace$^$^void cleanupstdvectorfstscriptlabelfstclasspair pairs $^  for const auto pair  pairs $^    delete pair.second$^  $^  pairsclear$^$^$^int fstreplacemainint argc char argv $^  namespace s  fstscript$^  using fstscriptfstclass$^  using fstscriptvectorfstclass$^  using fstreplacelabeltype$^$^  string usage  recursively replaces fst arcs with other fsts.nn$^                   usage $^  usage  argv0$^  usage   root.fst rootlabel rule0.fst label0 ... out.fstn$^$^  stdsetnewhandlerfailednewhandler$^  setflagsusage.cstr argc argv true$^  if argc  0 $^    showusage$^    return 0$^  $^$^  const string inname  argv0$^  const string outname  argc  0  0  argvargc  0  $^$^  auto ifst  fstclassreadinname$^  if ifst return 0$^$^  stdvectorslabelfstclasspair pairs$^   note that if the root label is beyond the range of the underlying fsts$^   labels truncation will occur.$^  const auto root  atollargv0$^  pairs.emplacebackroot ifst$^$^  for auto i  0 i  argc  0 i  0 $^    ifst  fstclassreadargvi$^    if ifst $^      cleanuppairs$^      return 0$^    $^     note that if the root label is beyond the range of the underlying fsts$^     labels truncation will occur.$^    const auto label  atollargvi  0$^    pairs.emplacebacklabel ifst$^  $^$^  replacelabeltype calllabeltype$^  if sgetreplacelabeltypeflagscallarclabeling flagsepsilononreplace$^                              calllabeltype $^    logerror  argv0   unknown or unsupported call arc replace $^                label type   flagscallarclabeling$^  $^  replacelabeltype returnlabeltype$^  if sgetreplacelabeltypeflagsreturnarclabeling$^                              flagsepsilononreplace returnlabeltype $^    logerror  argv0   unknown or unsupported return arc replace $^                label type   flagsreturnarclabeling$^  $^$^  sreplaceoptions optsroot calllabeltype returnlabeltype$^                         flagsreturnlabel$^$^  vectorfstclass ofstifstarctype$^  sreplacepairs ofst opts$^  cleanuppairs$^$^  return ofst.writeoutname$^$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^ disambiguates an fst.$^$^include cstring$^$^include memory$^include string$^$^include fstflags.h$^include fstscriptdisambiguate.h$^$^declaredoubledelta$^declareint00nstate$^declarestringweight$^declareint00subsequentiallabel$^$^int fstdisambiguatemainint argc char argv $^  namespace s  fstscript$^  using fstscriptfstclass$^  using fstscriptvectorfstclass$^  using fstscriptweightclass$^$^  string usage  disambiguates an fst.nn  usage $^  usage  argv0$^  usage   in.fst out.fstn$^$^  stdsetnewhandlerfailednewhandler$^  setflagsusage.cstr argc argv true$^  if argc  0 $^    showusage$^    return 0$^  $^$^  const string inname  argc  0  strcmpargv0   0  argv0  $^  const string outname  argc  0  argv0  $^$^  stduniqueptrfstclass ifstfstclassreadinname$^  if ifst return 0$^$^  vectorfstclass ofstifstarctype$^$^  const auto weightthreshold $^      flagsweight.empty  weightclasszeroifstweighttype$^                            weightclassifstweighttype flagsweight$^$^  const sdisambiguateoptions optsflagsdelta weightthreshold flagsnstate$^                                    flagssubsequentiallabel$^$^  sdisambiguateifst ofst opts$^$^  return ofst.writeoutname$^$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstflags.h$^$^defineboolacceptor false input in acceptor format$^definestringisymbols  input label symbol table$^definestringosymbols  output label symbol table$^definestringssymbols  state label symbol table$^defineboolnumeric false print numeric labels$^defineint00precision 0 set precision number of charfloat$^definestringfloatformat g$^              floatingpoint format one of e f or g$^defineboolshowweightone false$^            printdraw arc weights and final weights equal to weightone$^definestringtitle  set figure title$^defineboolportrait false portrait mode def landscape$^defineboolvertical false draw bottomtotop instead of lefttoright$^defineint00fontsize 00 set fontsize$^definedoubleheight 00 set height$^definedoublewidth 0.0 set width$^definedoublenodesep 0.00$^              set minimum separation between nodes see dot documentation$^definedoubleranksep 0.00$^              set minimum separation between ranks see dot documentation$^defineboolallownegativelabels false$^            allow negative labels not recommended may cause conflicts$^$^int fstdrawmainint argc char argv$^$^int mainint argc char argv  return fstdrawmainargc argv $^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^int fsttopsortmainint argc char argv$^$^int mainint argc char argv  return fsttopsortmainargc argv $^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstscriptfstclass.h$^include fstscriptrmepsilon.h$^include fstscriptscriptimpl.h$^$^namespace fst $^namespace script $^$^void rmepsilonmutablefstclass fst const rmepsilonoptions opts $^  if fstweighttypesmatchopts.weightthreshold rmepsilon $^    fstsetpropertieskerror kerror$^    return$^  $^  rmepsilonargs argsfst opts$^  applyoperationrmepsilonargsrmepsilon fstarctype args$^$^$^registerfstoperationrmepsilon stdarc rmepsilonargs$^registerfstoperationrmepsilon logarc rmepsilonargs$^registerfstoperationrmepsilon log00arc rmepsilonargs$^$^   namespace script$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstscriptfstclass.h$^include fstencode.h$^include fstscriptdecode.h$^include fstscriptscriptimpl.h$^$^namespace fst $^namespace script $^$^void decodemutablefstclass fst const string coderfname $^  decodeargs0 argsfst coderfname$^  applyoperationdecodeargs0decode fstarctype args$^$^$^void decodemutablefstclass fst const encodemapperclass encoder $^  if internalarctypesmatchfst encoder decode $^    fstsetpropertieskerror kerror$^    return$^  $^  decodeargs0 argsfst encoder$^  applyoperationdecodeargs0decode fstarctype args$^$^$^registerfstoperationdecode stdarc decodeargs0$^registerfstoperationdecode logarc decodeargs0$^registerfstoperationdecode log00arc decodeargs0$^$^registerfstoperationdecode stdarc decodeargs0$^registerfstoperationdecode logarc decodeargs0$^registerfstoperationdecode log00arc decodeargs0$^$^   namespace script$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include string$^$^include fstscriptfstclass.h$^include fstscriptinfo.h$^include fstscriptscriptimpl.h$^$^namespace fst $^namespace script $^$^void printfstinfoconst fstclass fst bool testproperties$^                  const string arcfilter const string infotype bool pipe$^                  bool verify $^  infoargs argsfst testproperties arcfilter infotype pipe verify$^  applyoperationinfoargsprintfstinfo fst.arctype args$^$^$^void getfstinfoconst fstclass fst bool testproperties$^                const string arcfilter const string infotype bool verify$^                fstinfo result $^  getinfoargs argsfst testproperties arcfilter infotype verify result$^  applyoperationgetinfoargsgetfstinfo fst.arctype args$^$^$^registerfstoperationprintfstinfo stdarc infoargs$^registerfstoperationprintfstinfo logarc infoargs$^registerfstoperationprintfstinfo log00arc infoargs$^$^registerfstoperationgetfstinfo stdarc getinfoargs$^registerfstoperationgetfstinfo logarc getinfoargs$^registerfstoperationgetfstinfo log00arc getinfoargs$^$^   namespace script$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstscriptfstclass.h$^include fstscriptinvert.h$^include fstscriptscriptimpl.h$^$^namespace fst $^namespace script $^$^void invertmutablefstclass fst $^  applyoperationmutablefstclassinvert fstarctype fst$^$^$^registerfstoperationinvert stdarc mutablefstclass$^registerfstoperationinvert logarc mutablefstclass$^registerfstoperationinvert log00arc mutablefstclass$^$^   namespace script$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstscriptfstclass.h$^include fstscriptscriptimpl.h$^include fstscriptverify.h$^$^namespace fst $^namespace script $^$^bool verifyconst fstclass fst $^  verifyargs argsfst$^  applyoperationverifyargsverify fst.arctype args$^  return args.retval$^$^$^registerfstoperationverify stdarc verifyargs$^registerfstoperationverify logarc verifyargs$^registerfstoperationverify log00arc verifyargs$^$^   namespace script$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstscriptfstclass.h$^include fstscriptscriptimpl.h$^include fstscriptunion.h$^$^namespace fst $^namespace script $^$^void unionmutablefstclass fst0 const fstclass fst0 $^  if internalarctypesmatchfst0 fst0 union $^    fst0setpropertieskerror kerror$^    return$^  $^  unionargs argsfst0 fst0$^  applyoperationunionargsunion fst0arctype args$^$^$^registerfstoperationunion stdarc unionargs$^registerfstoperationunion logarc unionargs$^registerfstoperationunion log00arc unionargs$^$^   namespace script$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstscriptfstclass.h$^include fstscriptclosure.h$^include fstscriptscriptimpl.h$^$^namespace fst $^namespace script $^$^void closuremutablefstclass fst closuretype closuretype $^  closureargs argsfst closuretype$^  applyoperationclosureargsclosure fstarctype args$^$^$^registerfstoperationclosure stdarc closureargs$^registerfstoperationclosure logarc closureargs$^registerfstoperationclosure log00arc closureargs$^$^   namespace script$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstscriptfstclass.h$^include fstscriptproject.h$^include fstscriptscriptimpl.h$^$^namespace fst $^namespace script $^$^$^void projectmutablefstclass ofst projecttype projecttype $^  projectargs argsofst projecttype$^  applyoperationprojectargsproject ofstarctype args$^$^$^registerfstoperationproject stdarc projectargs$^registerfstoperationproject logarc projectargs$^registerfstoperationproject log00arc projectargs$^$^   namespace script$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstscriptfstclass.h$^include fstscriptpush.h$^include fstscriptscriptimpl.h$^$^namespace fst $^namespace script $^$^void pushmutablefstclass fst reweighttype rewtype float delta$^          bool removetotalweight $^  pushargs0 argsfst rewtype delta removetotalweight$^  applyoperationpushargs0push fstarctype args$^$^$^void pushconst fstclass ifst mutablefstclass ofst uint00 flags$^          reweighttype rewtype float delta $^  if internalarctypesmatchifst ofst push $^    ofstsetpropertieskerror kerror$^    return$^  $^  pushargs0 argsifst ofst flags rewtype delta$^  applyoperationpushargs0push ifst.arctype args$^$^$^registerfstoperationpush stdarc pushargs0$^registerfstoperationpush logarc pushargs0$^registerfstoperationpush log00arc pushargs0$^$^registerfstoperationpush stdarc pushargs0$^registerfstoperationpush logarc pushargs0$^registerfstoperationpush log00arc pushargs0$^$^   namespace script$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstscriptfstclass.h$^include fstscriptreplace.h$^include fstscriptscriptimpl.h$^$^namespace fst $^namespace script $^$^void replaceconst stdvectorlabelfstclasspair pairs mutablefstclass ofst$^             const replaceoptions opts $^  if pairs.empty $^    for auto it  pairs.begin it  pairs.end  0 it $^      if internalarctypesmatchitsecond it  0second replace $^        ofstsetpropertieskerror kerror$^        return$^      $^    $^    if internalarctypesmatchpairs0.second ofst replace $^      ofstsetpropertieskerror kerror$^      return$^    $^  $^  replaceargs argspairs ofst opts$^  applyoperationreplaceargsreplace ofstarctype args$^$^$^registerfstoperationreplace stdarc replaceargs$^registerfstoperationreplace logarc replaceargs$^registerfstoperationreplace log00arc replaceargs$^$^   namespace script$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstscriptfstclass.h$^include fstscriptreweight.h$^include fstscriptscriptimpl.h$^$^namespace fst $^namespace script $^$^void reweightmutablefstclass fst const stdvectorweightclass potential$^              reweighttype reweighttype $^  reweightargs argsfst potential reweighttype$^  applyoperationreweightargsreweight fstarctype args$^$^$^registerfstoperationreweight stdarc reweightargs$^registerfstoperationreweight logarc reweightargs$^registerfstoperationreweight log00arc reweightargs$^$^   namespace script$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstscripttextio.h$^$^include cstring$^include fstream$^include ostream$^include sstream$^include utility$^$^include fstlog.h$^include fstream$^include fstutil.h$^$^namespace fst $^namespace script $^$^ reads vector of weights returns true on success.$^bool readpotentialsconst string weighttype const string filename$^                    stdvectorweightclass potentials $^  stdifstream istrmfilename$^  if istrm.good $^    logerror  readpotentials cant open file   filename$^    return false$^  $^  static constexpr int klinelen  0000$^  char lineklinelen$^  sizet nline  0$^  potentialsclear$^  while istrm.getlineline klinelen.fail $^    nline$^    stdvectorchar  col$^    splitstringline nt  col true$^    if col.empty  col00  0 continue$^    if col.size  0 $^      fsterror  readpotentials bad number of columns $^                  file    filename   line    nline$^      return false$^    $^    const ssizet s  strtoint00col0 filename nline false$^    const weightclass weightweighttype col0$^    while potentialssize  s $^      potentialspushbackweightclasszeroweighttype$^    $^    potentialsback  weight$^  $^  return true$^$^$^ writes vector of weights returns true on success.$^bool writepotentialsconst string filename$^                     const stdvectorweightclass potentials $^  stdofstream ostrm$^  if filename.empty $^    ostrm.openfilename$^    if ostrm.good $^      logerror  writepotentials cant open file   filename$^      return false$^    $^  $^  stdostream strm  ostrm.isopen  ostrm  stdcout$^  strm.precision0$^  for sizet s  0 s  potentials.size s $^    strm  s  t  potentialss  n$^  $^  if strm.fail $^    logerror  writepotentials write failed $^                filename.empty  standard output  filename$^    return false$^  $^  return true$^$^$^   namespace script$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include ostream$^include string$^$^include fstscriptdraw.h$^include fstscriptfstclass.h$^include fstscriptscriptimpl.h$^$^namespace fst $^namespace script $^$^void drawfstconst fstclass fst const symboltable isyms$^             const symboltable osyms const symboltable ssyms bool accep$^             const string title float width float height bool portrait$^             bool vertical float ranksep float nodesep int fontsize$^             int precision const string floatformat bool showweightone$^             stdostream ostrm const string dest $^  fstdrawerargs argsfst isyms osyms ssyms accep title width height$^                     portrait vertical ranksep nodesep fontsize precision$^                     floatformat showweightone ostrm dest$^  applyoperationfstdrawerargsdrawfst fst.arctype args$^$^$^registerfstoperationdrawfst stdarc fstdrawerargs$^registerfstoperationdrawfst logarc fstdrawerargs$^registerfstoperationdrawfst log00arc fstdrawerargs$^$^   namespace script$^   namespace fst$^include fstscriptinfoimpl.h$^$^namespace fst $^$^void printfstinfoimplconst fstinfo fstinfo bool pipe $^  stdostream ostrm  pipe  stdcerr  stdcout$^  const auto old  ostrm.setfstdiosleft$^  ostrm.width00$^  ostrm  fst type  fstinfo.fsttype  stdendl$^  ostrm.width00$^  ostrm  arc type  fstinfo.arctype  stdendl$^  ostrm.width00$^  ostrm  input symbol table  fstinfo.inputsymbols  stdendl$^  ostrm.width00$^  ostrm  output symbol table  fstinfo.outputsymbols  stdendl$^  if fstinfo.longinfo $^    ostrm.setfold$^    return$^  $^  ostrm.width00$^  ostrm   of states  fstinfo.numstates  stdendl$^  ostrm.width00$^  ostrm   of arcs  fstinfo.numarcs  stdendl$^  ostrm.width00$^  ostrm  initial state  fstinfo.start  stdendl$^  ostrm.width00$^  ostrm   of final states  fstinfo.numfinal  stdendl$^  ostrm.width00$^  ostrm   of inputoutput epsilons  fstinfo.numepsilons  stdendl$^  ostrm.width00$^  ostrm   of input epsilons  fstinfo.numinputepsilons  stdendl$^  ostrm.width00$^  ostrm   of output epsilons  fstinfo.numoutputepsilons  stdendl$^  ostrm.width00$^  ostrm  input label multiplicity  fstinfo.inputlabelmultiplicity$^         stdendl$^  ostrm.width00$^  ostrm  output label multiplicity  fstinfo.outputlabelmultiplicity$^         stdendl$^  ostrm.width00$^  string arctype  $^  if fstinfo.arcfiltertype  epsilon$^    arctype  epsilon $^  else if fstinfo.arcfiltertype  iepsilon$^    arctype  inputepsilon $^  else if fstinfo.arcfiltertype  oepsilon$^    arctype  outputepsilon $^  const auto accessiblelabel   of   arctype  accessible states$^  ostrm.width00$^  ostrm  accessiblelabel  fstinfo.numaccessible  stdendl$^  const auto coaccessiblelabel   of   arctype  coaccessible states$^  ostrm.width00$^  ostrm  coaccessiblelabel  fstinfo.numcoaccessible  stdendl$^  const auto connectedlabel   of   arctype  connected states$^  ostrm.width00$^  ostrm  connectedlabel  fstinfo.numconnected  stdendl$^  const auto numcclabel   of   arctype  connected components$^  ostrm.width00$^  ostrm  numcclabel  fstinfo.numcc  stdendl$^  const auto numscclabel   of   arctype  strongly conn components$^  ostrm.width00$^  ostrm  numscclabel  fstinfo.numscc  stdendl$^  ostrm.width00$^  ostrm  input matcher$^         fstinfo.inputmatchtype  matchinput$^                 y$^                 fstinfo.inputmatchtype  matchnone  n  $^         stdendl$^  ostrm.width00$^  ostrm  output matcher$^         fstinfo.outputmatchtype  matchoutput$^                 y$^                 fstinfo.outputmatchtype  matchnone  n  $^         stdendl$^  ostrm.width00$^  ostrm  input lookahead  fstinfo.inputlookahead  y  n$^         stdendl$^  ostrm.width00$^  ostrm  output lookahead  fstinfo.outputlookahead  y  n$^         stdendl$^  uint00 prop  0$^  for auto i  0 i  00 i prop  0 $^    if prop  kbinaryproperties $^      char value  n$^      if fstinfo.properties  prop value  y$^      ostrm.width00$^      ostrm  propertynamesi  value  stdendl$^     else if prop  kpostrinaryproperties $^      char value  $^      if fstinfo.properties  prop$^        value  y$^      else if fstinfo.properties  prop  0$^        value  n$^      ostrm.width00$^      ostrm  propertynamesi  value  stdendl$^    $^  $^  ostrm.setfold$^$^$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstscriptscriptimpl.h$^include fstscriptstateiteratorclass.h$^$^namespace fst $^namespace script $^$^stateiteratorclassstateiteratorclassconst fstclass fst  implnullptr $^  initstateiteratorclassargs argsfst this$^  applyoperationinitstateiteratorclassargsinitstateiteratorclass$^                                               fst.arctype args$^$^$^registerfstoperationinitstateiteratorclass stdarc$^                       initstateiteratorclassargs$^registerfstoperationinitstateiteratorclass logarc$^                       initstateiteratorclassargs$^registerfstoperationinitstateiteratorclass log00arc$^                       initstateiteratorclassargs$^$^   namespace script$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstscriptweightclass.h$^$^namespace fst $^namespace script $^$^registerfstweightstdarcweight$^registerfstweightlogarcweight$^registerfstweightlog00arcweight$^$^weightclassweightclassconst string weighttype const string weightstr $^  weightclassregister reg  weightclassregistergetregister$^  strtoweightimplbaset stw  reggetentryweighttype$^  if stw $^    fsterror  unknown weight type   weighttype$^    impl.reset$^    return$^  $^  impl.resetstwweightstr weightclass 0$^$^$^weightclass weightclasszeroconst string weighttype $^  return weightclassweighttype zero$^$^$^weightclass weightclassoneconst string weighttype $^  return weightclassweighttype one$^$^$^weightclass weightclassnoweightconst string weighttype $^  return weightclassweighttype noweight$^$^$^bool weightclassweighttypesmatchconst weightclass other$^                                   const string opname const $^  if type  other.type $^    fsterror  weights with nonmatching types passed to   opname$^                   type   and   other.type$^    return false$^  $^  return true$^$^$^bool operatorconst weightclass lhs const weightclass rhs $^  const auto lhsimpl  lhs.getimpl$^  const auto rhsimpl  rhs.getimpl$^  if lhsimpl  rhsimpl  lhs.weighttypesmatchrhs operator $^    return false$^  $^  return lhsimpl  rhsimpl$^$^$^bool operatorconst weightclass lhs const weightclass rhs $^  return lhs  rhs$^$^$^weightclass plusconst weightclass lhs const weightclass rhs $^  const auto rhsimpl  rhs.getimpl$^  if lhs.getimpl  rhsimpl  lhs.weighttypesmatchrhs plus $^    return weightclass$^  $^  weightclass resultlhs$^  result.getimplpluseqrhsimpl$^  return result$^$^$^weightclass timesconst weightclass lhs const weightclass rhs $^  const auto rhsimpl  rhs.getimpl$^  if lhs.getimpl  rhsimpl  lhs.weighttypesmatchrhs plus $^    return weightclass$^  $^  weightclass resultlhs$^  result.getimpltimeseqrhsimpl$^  return result$^$^$^weightclass divideconst weightclass lhs const weightclass rhs $^  const auto rhsimpl  rhs.getimpl$^  if lhs.getimpl  rhsimpl  lhs.weighttypesmatchrhs divide $^    return weightclass$^  $^  weightclass resultlhs$^  result.getimpldivideeqrhsimpl$^  return result$^$^$^weightclass powerconst weightclass weight sizet n $^  if weight.getimpl return weightclass$^  weightclass resultweight$^  result.getimplpowereqn$^  return result$^$^$^stdostream operatorstdostream ostrm const weightclass weight $^  weight.implprintostrm$^  return ostrm$^$^$^   namespace script$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstscriptfstclass.h$^include fstscriptmap.h$^include fstscriptscriptimpl.h$^$^namespace fst $^namespace script $^$^fstclass mapconst fstclass ifst maptype maptype float delta double power$^              const weightclass weight $^  if ifst.weighttypesmatchweight map return nullptr$^  mapinnerargs iargsifst maptype delta power weight$^  mapargs argsiargs$^  applyoperationmapargsmap ifst.arctype args$^  return args.retval$^$^$^registerfstoperationmap stdarc mapargs$^registerfstoperationmap logarc mapargs$^registerfstoperationmap log00arc mapargs$^$^   namespace script$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstscriptfstclass.h$^include fstscriptintersect.h$^include fstscriptscriptimpl.h$^$^namespace fst $^namespace script $^$^void intersectconst fstclass ifst0 const fstclass ifst0$^               mutablefstclass ofst const composeoptions opts $^  if internalarctypesmatchifst0 ifst0 intersect $^      internalarctypesmatchofst ifst0 intersect $^    ofstsetpropertieskerror kerror$^    return$^  $^  intersectargs argsifst0 ifst0 ofst opts$^  applyoperationintersectargsintersect ifst0.arctype args$^$^$^registerfstoperationintersect stdarc intersectargs$^registerfstoperationintersect logarc intersectargs$^registerfstoperationintersect log00arc intersectargs$^$^   namespace script$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstscriptfstclass.h$^include fstscriptprune.h$^include fstscriptscriptimpl.h$^$^namespace fst $^namespace script $^$^void pruneconst fstclass ifst mutablefstclass ofst$^           const weightclass weightthreshold$^           int00 statethreshold float delta $^  if internalarctypesmatchifst ofst prune $^      ofstweighttypesmatchweightthreshold prune $^    ofstsetpropertieskerror kerror$^    return$^  $^  pruneargs0 argsifst ofst weightthreshold statethreshold delta$^  applyoperationpruneargs0prune ifst.arctype args$^$^$^void prunemutablefstclass fst const weightclass weightthreshold$^           int00 statethreshold float delta $^  if fstweighttypesmatchweightthreshold prune $^    fstsetpropertieskerror kerror$^    return$^  $^  pruneargs0 argsfst weightthreshold statethreshold delta$^  applyoperationpruneargs0prune fstarctype args$^$^$^registerfstoperationprune stdarc pruneargs0$^registerfstoperationprune logarc pruneargs0$^registerfstoperationprune log00arc pruneargs0$^$^registerfstoperationprune stdarc pruneargs0$^registerfstoperationprune logarc pruneargs0$^registerfstoperationprune log00arc pruneargs0$^$^   namespace script$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstscriptfstclass.h$^include fstscriptepsnormalize.h$^include fstscriptscriptimpl.h$^$^namespace fst $^namespace script $^$^void epsnormalizeconst fstclass ifst mutablefstclass ofst$^                  epsnormalizetype normtype $^  if internalarctypesmatchifst ofst epsnormalize $^    ofstsetpropertieskerror kerror$^    return$^  $^  epsnormalizeargs argsifst ofst normtype$^  applyoperationepsnormalizeargsepsnormalize ifst.arctype args$^$^$^registerfstoperationepsnormalize stdarc epsnormalizeargs$^registerfstoperationepsnormalize logarc epsnormalizeargs$^registerfstoperationepsnormalize log00arc epsnormalizeargs$^$^   namespace script$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstscriptfstclass.h$^include fstscriptscriptimpl.h$^include fstscripttopsort.h$^$^namespace fst $^namespace script $^$^bool topsortmutablefstclass fst $^  topsortargs argsfst$^  applyoperationtopsortargstopsort fstarctype args$^  return args.retval$^$^$^registerfstoperationtopsort stdarc topsortargs$^registerfstoperationtopsort logarc topsortargs$^registerfstoperationtopsort log00arc topsortargs$^$^   namespace script$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstscriptfstclass.h$^include fstscriptrandequivalent.h$^include fstscriptscriptimpl.h$^$^namespace fst $^namespace script $^$^bool randequivalentconst fstclass fst0 const fstclass fst0 int00 npath$^                    float delta timet seed$^                    const randgenoptionsrandarcselection opts $^  if internalarctypesmatchfst0 fst0 randequivalent return false$^  randequivalentinnerargs iargsfst0 fst0 npath delta seed opts$^  randequivalentargs argsiargs$^  applyoperationrandequivalentargsrandequivalent fst0.arctype args$^  return args.retval$^$^$^registerfstoperationrandequivalent stdarc randequivalentargs$^registerfstoperationrandequivalent logarc randequivalentargs$^registerfstoperationrandequivalent log00arc randequivalentargs$^$^   namespace script$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include istream$^include string$^$^include fstscriptcompile.h$^include fstscriptfstclass.h$^include fstscriptscriptimpl.h$^$^namespace fst $^namespace script $^$^void compilefststdistream istrm const string source const string dest$^                const string fsttype const string arctype$^                const symboltable isyms const symboltable osyms$^                const symboltable ssyms bool accep bool ikeep bool okeep$^                bool nkeep bool allownegativelabels $^  stduniqueptrfstclass fst$^      compilefstinternalistrm source fsttype arctype isyms osyms ssyms$^                         accep ikeep okeep nkeep allownegativelabels$^  fstwritedest$^$^$^fstclass compilefstinternalstdistream istrm const string source$^                             const string fsttype const string arctype$^                             const symboltable isyms const symboltable osyms$^                             const symboltable ssyms bool accep bool ikeep$^                             bool okeep bool nkeep$^                             bool allownegativelabels $^  compilefstinnerargs iargsistrm source fsttype isyms osyms ssyms accep$^                            ikeep okeep nkeep allownegativelabels$^  compilefstargs argsiargs$^  applyoperationcompilefstargscompilefstinternal arctype args$^  return args.retval$^$^$^ this registers 0 0 does not require registration.$^registerfstoperationcompilefstinternal stdarc compilefstargs$^registerfstoperationcompilefstinternal logarc compilefstargs$^registerfstoperationcompilefstinternal log00arc compilefstargs$^$^   namespace script$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include ostream$^include string$^$^include fstscriptfstclass.h$^include fstscriptprint.h$^include fstscriptscriptimpl.h$^$^namespace fst $^namespace script $^$^void printfstconst fstclass fst stdostream ostrm const string dest$^              const symboltable isyms const symboltable osyms$^              const symboltable ssyms bool accept bool showweightone$^              const string missingsym $^  const auto sep  flagsfstfieldseparator.substr0 0$^  fstprinterargs argsfst isyms osyms ssyms accept showweightone ostrm$^                      dest sep missingsym$^  applyoperationfstprinterargsprintfst fst.arctype args$^$^$^registerfstoperationprintfst stdarc fstprinterargs$^registerfstoperationprintfst logarc fstprinterargs$^registerfstoperationprintfst log00arc fstprinterargs$^$^   namespace script$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstscriptfstclass.h$^include fstscriptrandgen.h$^include fstscriptscriptimpl.h$^$^namespace fst $^namespace script $^$^void randgenconst fstclass ifst mutablefstclass ofst timet seed$^             const randgenoptionsrandarcselection opts $^  if internalarctypesmatchifst ofst randgen $^    ofstsetpropertieskerror kerror$^    return$^  $^  randgenargs argsifst ofst seed opts$^  applyoperationrandgenargsrandgen ifst.arctype args$^$^$^registerfstoperationrandgen stdarc randgenargs$^registerfstoperationrandgen logarc randgenargs$^registerfstoperationrandgen log00arc randgenargs$^$^   namespace script$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstscriptfstclass.h$^include fstscriptdisambiguate.h$^include fstscriptscriptimpl.h$^$^namespace fst $^namespace script $^$^void disambiguateconst fstclass ifst mutablefstclass ofst$^                  const disambiguateoptions opts $^  if internalarctypesmatchifst ofst disambiguate $^      ofstweighttypesmatchopts.weightthreshold disambiguate $^    ofstsetpropertieskerror kerror$^    return$^  $^  disambiguateargs argsifst ofst opts$^  applyoperationdisambiguateargsdisambiguate ifst.arctype args$^$^$^registerfstoperationdisambiguate stdarc disambiguateargs$^registerfstoperationdisambiguate logarc disambiguateargs$^registerfstoperationdisambiguate log00arc disambiguateargs$^$^   namespace script$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstscriptfstclass.h$^include fstscriptscriptimpl.h$^include fstscriptsynchronize.h$^$^namespace fst $^namespace script $^$^void synchronizeconst fstclass ifst mutablefstclass ofst $^  if internalarctypesmatchifst ofst synchronize $^    ofstsetpropertieskerror kerror$^    return$^  $^  synchronizeargs argsifst ofst$^  applyoperationsynchronizeargssynchronize ifst.arctype args$^$^$^registerfstoperationsynchronize stdarc synchronizeargs$^registerfstoperationsynchronize logarc synchronizeargs$^registerfstoperationsynchronize log00arc synchronizeargs$^$^   namespace script$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstscriptencodemapperclass.h$^include fstscriptscriptimpl.h$^$^namespace fst $^namespace script $^$^encodemapperclassencodemapperclassconst string arctype uint00 flags$^                                      encodetype type  implnullptr $^  initencodemapperclassargs argsflags type this$^  applyoperationinitencodemapperclassargsinitencodemapperclass$^                                              arctype args$^$^$^registerfstoperationinitencodemapperclass stdarc$^                       initencodemapperclassargs$^registerfstoperationinitencodemapperclass logarc$^                       initencodemapperclassargs$^registerfstoperationinitencodemapperclass log00arc$^                       initencodemapperclassargs$^$^   namespace script$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstscriptfstclass.h$^include fstscriptconvert.h$^include fstscriptscriptimpl.h$^$^namespace fst $^namespace script $^$^fstclass convertconst fstclass ifst const string newtype $^  convertinnerargs iargsifst newtype$^  convertargs argsiargs$^  applyoperationconvertargsconvert ifst.arctype args$^  return args.retval$^$^$^registerfstoperationconvert stdarc convertargs$^registerfstoperationconvert logarc convertargs$^registerfstoperationconvert log00arc convertargs$^$^   namespace script$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstscriptfstclass.h$^include fstscriptreverse.h$^include fstscriptscriptimpl.h$^$^namespace fst $^namespace script $^$^void reverseconst fstclass ifst mutablefstclass ofst$^             bool requiresuperinitial $^  if internalarctypesmatchifst ofst reverse $^    ofstsetpropertieskerror kerror$^    return$^  $^  reverseargs argsifst ofst requiresuperinitial$^  applyoperationreverseargsreverse ifst.arctype args$^$^$^registerfstoperationreverse stdarc reverseargs$^registerfstoperationreverse logarc reverseargs$^registerfstoperationreverse log00arc reverseargs$^$^   namespace script$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstscriptfstclass.h$^include fstscriptrelabel.h$^include fstscriptscriptimpl.h$^$^namespace fst $^namespace script $^$^void relabelmutablefstclass ofst$^             const symboltable oldisyms const symboltable relabelisyms$^             const string unknownisymbol bool attachnewisyms$^             const symboltable oldosyms const symboltable relabelosyms$^             const string unknownosymbol bool attachnewosyms $^  relabelargs0 argsofst oldisyms relabelisyms unknownisymbol$^                    attachnewisyms oldosyms relabelosyms$^                    unknownosymbol attachnewosyms$^  applyoperationrelabelargs0relabel ofstarctype args$^$^$^void relabelmutablefstclass ofst const stdvectorlabelpair ipairs$^             const stdvectorlabelpair opairs $^  relabelargs0 argsofst ipairs opairs$^  applyoperationrelabelargs0relabel ofstarctype args$^$^$^registerfstoperationrelabel stdarc relabelargs0$^registerfstoperationrelabel logarc relabelargs0$^registerfstoperationrelabel log00arc relabelargs0$^$^registerfstoperationrelabel stdarc relabelargs0$^registerfstoperationrelabel logarc relabelargs0$^registerfstoperationrelabel log00arc relabelargs0$^$^   namespace script$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstscriptfstclass.h$^include fstscriptarcsort.h$^include fstscriptscriptimpl.h$^$^namespace fst $^namespace script $^$^void arcsortmutablefstclass fst arcsorttype sorttype $^  arcsortargs argsfst sorttype$^  applyoperationarcsortargsarcsort fstarctype args$^$^$^registerfstoperationarcsort stdarc arcsortargs$^registerfstoperationarcsort logarc arcsortargs$^registerfstoperationarcsort log00arc arcsortargs$^$^   namespace script$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstscriptfstclass.h$^include fstscriptscriptimpl.h$^include fstscriptshortestdistance.h$^$^namespace fst $^namespace script $^$^void shortestdistanceconst fstclass fst stdvectorweightclass distance$^                      const shortestdistanceoptions opts $^  shortestdistanceargs0 argsfst distance opts$^  applyoperationshortestdistanceargs0shortestdistance fst.arctype$^                                          args$^$^$^void shortestdistanceconst fstclass ifst stdvectorweightclass distance$^                      bool reverse double delta $^  shortestdistanceargs0 argsifst distance reverse delta$^  applyoperationshortestdistanceargs0shortestdistance ifst.arctype$^                                          args$^$^$^registerfstoperationshortestdistance stdarc shortestdistanceargs0$^registerfstoperationshortestdistance logarc shortestdistanceargs0$^registerfstoperationshortestdistance log00arc shortestdistanceargs0$^$^registerfstoperationshortestdistance stdarc shortestdistanceargs0$^registerfstoperationshortestdistance logarc shortestdistanceargs0$^registerfstoperationshortestdistance log00arc shortestdistanceargs0$^$^   namespace script$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstscriptarciteratorclass.h$^include fstscriptscriptimpl.h$^$^namespace fst $^namespace script $^$^arciteratorclassarciteratorclassconst fstclass fst int00 s$^     implnullptr $^  initarciteratorclassargs argsfst s this$^  applyoperationinitarciteratorclassargsinitarciteratorclass$^                                             fst.arctype args$^$^$^mutablearciteratorclassmutablearciteratorclassmutablefstclass fst$^                                                 int00 s  implnullptr $^  initmutablearciteratorclassargs argsfst s this$^  applyoperationinitmutablearciteratorclassargs$^      initmutablearciteratorclass fstarctype args$^$^$^registerfstoperationinitarciteratorclass stdarc initarciteratorclassargs$^registerfstoperationinitarciteratorclass logarc initarciteratorclassargs$^registerfstoperationinitarciteratorclass log00arc$^                       initarciteratorclassargs$^$^registerfstoperationinitmutablearciteratorclass stdarc$^                       initmutablearciteratorclassargs$^registerfstoperationinitmutablearciteratorclass logarc$^                       initmutablearciteratorclassargs$^registerfstoperationinitmutablearciteratorclass log00arc$^                       initmutablearciteratorclassargs$^$^   namespace script$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstscriptfstclass.h$^include fstscriptisomorphic.h$^include fstscriptscriptimpl.h$^$^namespace fst $^namespace script $^$^bool isomorphicconst fstclass fst0 const fstclass fst0 float delta $^  if internalarctypesmatchfst0 fst0 isomorphic return false$^  isomorphicinnerargs iargsfst0 fst0 delta$^  isomorphicargs argsiargs$^  applyoperationisomorphicargsisomorphic fst0.arctype args$^  return args.retval$^$^$^registerfstoperationisomorphic stdarc isomorphicargs$^registerfstoperationisomorphic logarc isomorphicargs$^registerfstoperationisomorphic log00arc isomorphicargs$^$^   namespace script$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^ these classes are only recommended for use in highlevel scripting$^ applications. most users should use the lowerlevel templated versions$^ corresponding to these classes.$^$^include istream$^$^include fstlog.h$^$^include fstequal.h$^include fstfstdecl.h$^include fstreverse.h$^include fstunion.h$^include fstscriptfstclass.h$^include fstscriptregister.h$^$^namespace fst $^namespace script $^$^ registration.$^$^registerfstclassesstdarc$^registerfstclasseslogarc$^registerfstclasseslog00arc$^$^ fstclass methods.$^$^namespace $^$^template class f$^f readfststdistream istrm const string fname $^  if istrm $^    logerror  readfst cant open file   fname$^    return nullptr$^  $^  fstheader hdr$^  if hdr.readistrm fname return nullptr$^  const fstreadoptions readoptionsfname hdr$^  const auto arctype  hdr.arctype$^  static const auto ioregister  ioregistrationfregistergetregister$^  const auto reader  ioregistergetreaderarctype$^  if reader $^    logerror  readfst unknown arc type   arctype$^    return nullptr$^  $^  return readeristrm readoptions$^$^$^   namespace$^$^fstclass fstclassreadconst string fname $^  if fname.empty $^    stdifstream istrmfname stdiosbasein  stdiosbasebinary$^    return readfstfstclassistrm fname$^   else $^    return readfstfstclassstdcin standard input$^  $^$^$^fstclass fstclassreadstdistream istrm const string source $^  return readfstfstclassistrm source$^$^$^bool fstclassweighttypesmatchconst weightclass weight$^                                const string opname const $^  if weighttype  weight.type $^    fsterror  fst and weight with nonmatching weight types passed to $^                opname     weighttype   and   weight.type$^    return false$^  $^  return true$^$^$^ mutablefstclass methods.$^$^mutablefstclass mutablefstclassreadconst string fname bool convert $^  if convert  false $^    if fname.empty $^      stdifstream infname stdiosbasein  stdiosbasebinary$^      return readfstmutablefstclassin fname$^     else $^      return readfstmutablefstclassstdcin standard input$^    $^   else    converts to vectorfstclass if not mutable.$^    stduniqueptrfstclass ifstfstclassreadfname$^    if ifst return nullptr$^    if ifstpropertieskmutable false  kmutable $^      return staticcastmutablefstclass ifst.release$^     else $^      return new vectorfstclassifst.release$^    $^  $^$^$^ vectorfstclass methods.$^$^vectorfstclass vectorfstclassreadconst string fname $^  if fname.empty $^    stdifstream infname stdiosbasein  stdiosbasebinary$^    return readfstvectorfstclassin fname$^   else $^    return readfstvectorfstclassstdcin standard input$^  $^$^$^ioregistrationvectorfstclassentry getvfstregisterentry$^    const string arctype $^  static const auto ioregister $^      ioregistrationvectorfstclassregistergetregister$^  return ioregistergetentryarctype$^$^$^vectorfstclassvectorfstclassconst string arctype$^     mutablefstclassgetvfstregisterentryarctype.creator $^  if propertieskerror true  kerror $^    fsterror  vectorfstclass unknown arc type   arctype$^  $^$^$^vectorfstclassvectorfstclassconst fstclass other$^     mutablefstclassgetvfstregisterentryother.arctype.converterother $^$^   namespace script$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstscriptfstclass.h$^include fstscriptequivalent.h$^include fstscriptscriptimpl.h$^$^namespace fst $^namespace script $^$^bool equivalentconst fstclass fst0 const fstclass fst0 float delta $^  if internalarctypesmatchfst0 fst0 equivalent return false$^  equivalentinnerargs iargsfst0 fst0 delta$^  equivalentargs argsiargs$^  applyoperationequivalentargsequivalent fst0.arctype args$^  return args.retval$^$^$^registerfstoperationequivalent stdarc equivalentargs$^registerfstoperationequivalent logarc equivalentargs$^registerfstoperationequivalent log00arc equivalentargs$^$^   namespace script$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstscriptfstclass.h$^include fstscriptminimize.h$^include fstscriptscriptimpl.h$^$^namespace fst $^namespace script $^$^void minimizemutablefstclass ofst0 mutablefstclass ofst0 float delta$^              bool allownondet $^  if ofst0  internalarctypesmatchofst0 ofst0 minimize $^    ofst0setpropertieskerror kerror$^    ofst0setpropertieskerror kerror$^    return$^  $^  minimizeargs argsofst0 ofst0 delta allownondet$^  applyoperationminimizeargsminimize ofst0arctype args$^$^$^registerfstoperationminimize stdarc minimizeargs$^registerfstoperationminimize logarc minimizeargs$^registerfstoperationminimize log00arc minimizeargs$^$^   namespace script$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstscriptfstclass.h$^include fstscriptdeterminize.h$^include fstscriptscriptimpl.h$^$^namespace fst $^namespace script $^$^void determinizeconst fstclass ifst mutablefstclass ofst$^                 const determinizeoptions opts $^  if internalarctypesmatchifst ofst determinize $^      ofstweighttypesmatchopts.weightthreshold determinize $^    ofstsetpropertieskerror kerror$^    return$^  $^  determinizeargs argsifst ofst opts$^  applyoperationdeterminizeargsdeterminize ifst.arctype args$^$^$^registerfstoperationdeterminize stdarc determinizeargs$^registerfstoperationdeterminize logarc determinizeargs$^registerfstoperationdeterminize log00arc determinizeargs$^$^   namespace script$^   namespace fst$^include fstscriptgetters.h$^$^namespace fst $^namespace script $^$^bool getarcsorttypeconst string str arcsorttype sorttype $^  if str  ilabel $^    sorttype  ilabelsort$^   else if str  olabel $^    sorttype  olabelsort$^   else $^    return false$^  $^  return true$^$^$^bool getcomposefilterconst string str composefilter composefilter $^  if str  altsequence $^    composefilter  altsequencefilter$^   else if str  auto $^    composefilter  autofilter$^   else if str  match $^    composefilter  matchfilter$^   else if str  null $^    composefilter  nullfilter$^   else if str  sequence $^    composefilter  sequencefilter$^   else if str  trivial $^    composefilter  trivialfilter$^   else $^    return false$^  $^  return true$^$^$^bool getdeterminizetypeconst string str determinizetype dettype $^  if str  functional $^    dettype  determinizefunctional$^   else if str  nonfunctional $^    dettype  determinizenonfunctional$^   else if str  disambiguate $^    dettype  determinizedisambiguate$^   else $^    return false$^  $^  return true$^$^$^bool getmaptypeconst string str maptype maptype $^  if str  arcsum $^    maptype  arcsummapper$^   else if str  arcunique $^    maptype  arcuniquemapper$^   else if str  identity $^    maptype  identitymapper$^   else if str  inputepsilon $^    maptype  inputepsilonmapper$^   else if str  invert $^    maptype  invertmapper$^   else if str  outputepsilon $^    maptype  outputepsilonmapper$^   else if str  plus $^    maptype  plusmapper$^   else if str  power $^    maptype  powermapper$^   else if str  quantize $^    maptype  quantizemapper$^   else if str  rmweight $^    maptype  rmweightmapper$^   else if str  superfinal $^    maptype  superfinalmapper$^   else if str  times $^    maptype  timesmapper$^   else if str  tolog $^    maptype  tologmapper$^   else if str  tolog00 $^    maptype  tolog00mapper$^   else if str  tostd  str  tostandard $^    maptype  tostdmapper$^   else $^    return false$^  $^  return true$^$^$^bool getrandarcselectionconst string str randarcselection ras $^  if str  uniform $^    ras  uniformarcselector$^   else if str  logprob $^    ras  logprobarcselector$^   else if str  fastlogprob $^    ras  fastlogprobarcselector$^   else $^    return false$^  $^  return true$^$^$^bool getqueuetypeconst string str queuetype queuetype $^  if str  auto $^    queuetype  autoqueue$^   else if str  fifo $^    queuetype  fifoqueue$^   else if str  lifo $^    queuetype  lifoqueue$^   else if str  shortest $^    queuetype  shortestfirstqueue$^   else if str  state $^    queuetype  stateorderqueue$^   else if str  top $^    queuetype  toporderqueue$^   else $^    return false$^  $^  return true$^$^$^bool getreplacelabeltypeconst string str bool epsilononreplace$^                         replacelabeltype rlt $^  if epsilononreplace  str  neither $^    rlt  replacelabelneither$^   else if str  input $^    rlt  replacelabelinput$^   else if str  output $^    rlt  replacelabeloutput$^   else if str  both $^    rlt  replacelabelboth$^   else $^    return false$^  $^  return true$^$^$^   namespace script$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstscriptfstclass.h$^include fstscriptscriptimpl.h$^include fstscriptshortestpath.h$^$^namespace fst $^namespace script $^$^void shortestpathconst fstclass ifst mutablefstclass ofst$^                  const shortestpathoptions opts $^  if internalarctypesmatchifst ofst shortestpath $^    ofstsetpropertieskerror kerror$^    return$^  $^  shortestpathargs argsifst ofst opts$^  applyoperationshortestpathargsshortestpath ifst.arctype args$^$^$^registerfstoperationshortestpath stdarc shortestpathargs$^registerfstoperationshortestpath logarc shortestpathargs$^registerfstoperationshortestpath log00arc shortestpathargs$^$^   namespace script$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstscriptfstclass.h$^include fstscriptconnect.h$^include fstscriptscriptimpl.h$^$^namespace fst $^namespace script $^$^void connectmutablefstclass fst $^  applyoperationmutablefstclassconnect fstarctype fst$^$^$^registerfstoperationconnect stdarc mutablefstclass$^registerfstoperationconnect logarc mutablefstclass$^registerfstoperationconnect log00arc mutablefstclass$^$^   namespace script$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstscriptfstclass.h$^include fstscriptconcat.h$^include fstscriptscriptimpl.h$^$^namespace fst $^namespace script $^$^ 0$^void concatmutablefstclass ofst const fstclass ifst $^  if internalarctypesmatchofst ifst concat $^    ofstsetpropertieskerror kerror$^    return$^  $^  concatargs0 argsofst ifst$^  applyoperationconcatargs0concat ofstarctype args$^$^$^ 0$^void concatconst fstclass ifst mutablefstclass ofst $^  if internalarctypesmatchifst ofst concat $^    ofstsetpropertieskerror kerror$^    return$^  $^  concatargs0 argsifst ofst$^  applyoperationconcatargs0concat ofstarctype args$^$^$^registerfstoperationconcat stdarc concatargs0$^registerfstoperationconcat logarc concatargs0$^registerfstoperationconcat log00arc concatargs0$^$^registerfstoperationconcat stdarc concatargs0$^registerfstoperationconcat logarc concatargs0$^registerfstoperationconcat log00arc concatargs0$^$^   namespace script$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstscriptfstclass.h$^include fstscriptcompose.h$^include fstscriptscriptimpl.h$^$^namespace fst $^namespace script $^$^void composeconst fstclass ifst0 const fstclass ifst0$^             mutablefstclass ofst const composeoptions opts $^  if internalarctypesmatchifst0 ifst0 compose $^      internalarctypesmatchofst ifst0 compose $^    ofstsetpropertieskerror kerror$^    return$^  $^  composeargs argsifst0 ifst0 ofst opts$^  applyoperationcomposeargscompose ifst0.arctype args$^$^$^registerfstoperationcompose stdarc composeargs$^registerfstoperationcompose logarc composeargs$^registerfstoperationcompose log00arc composeargs$^$^   namespace script$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstscriptfstclass.h$^include fstscriptdifference.h$^include fstscriptscriptimpl.h$^$^namespace fst $^namespace script $^$^void differenceconst fstclass ifst0 const fstclass ifst0$^                mutablefstclass ofst const composeoptions opts $^  if internalarctypesmatchifst0 ifst0 difference $^      internalarctypesmatchofst ifst0 difference $^    ofstsetpropertieskerror kerror$^    return$^  $^  differenceargs argsifst0 ifst0 ofst opts$^  applyoperationdifferenceargsdifference ifst0.arctype args$^$^$^registerfstoperationdifference stdarc differenceargs$^registerfstoperationdifference logarc differenceargs$^registerfstoperationdifference log00arc differenceargs$^$^   namespace script$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstscriptfstclass.h$^include fstencode.h$^include fstscriptencode.h$^include fstscriptscriptimpl.h$^$^namespace fst $^namespace script $^$^void encodemutablefstclass fst uint00 flags bool reuseencoder$^            const string coderfname $^  encodeargs0 argsfst flags reuseencoder coderfname$^  applyoperationencodeargs0encode fstarctype args$^$^$^void encodemutablefstclass fst encodemapperclass encoder $^  if internalarctypesmatchfst encoder encode $^    fstsetpropertieskerror kerror$^    return$^  $^  encodeargs0 argsfst encoder$^  applyoperationencodeargs0encode fstarctype args$^$^$^registerfstoperationencode stdarc encodeargs0$^registerfstoperationencode logarc encodeargs0$^registerfstoperationencode log00arc encodeargs0$^$^registerfstoperationencode stdarc encodeargs0$^registerfstoperationencode logarc encodeargs0$^registerfstoperationencode log00arc encodeargs0$^$^   namespace script$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstscriptfstclass.h$^include fstscriptequal.h$^include fstscriptscriptimpl.h$^$^namespace fst $^namespace script $^$^bool equalconst fstclass fst0 const fstclass fst0 float delta $^  if internalarctypesmatchfst0 fst0 equal return false$^  equalinnerargs iargsfst0 fst0 delta$^  equalargs argsiargs$^  applyoperationequalargsequal fst0.arctype args$^  return args.retval$^$^$^registerfstoperationequal stdarc equalargs$^registerfstoperationequal logarc equalargs$^registerfstoperationequal log00arc equalargs$^$^   namespace script$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^ generates a random fst according to a classspecific transition model.$^$^include cstdlib$^include ctime$^include memory$^include string$^$^include fstextensionscompressrandmod.h$^$^include fstflags.h$^include fstlog.h$^include fstfstlib.h$^include fstutil.h$^$^defineint00seed time0 random seed$^defineint00states 00  of states$^defineint00labels 0  of labels$^defineint00classes 0  of probability distributions$^definebooltransducer false output a transducer$^defineboolweights false output a weighted fst$^$^int mainint argc char argv $^  using fststdvectorfst$^  using fststdarc$^  using fsttropicalweight$^  using fstweightgenerate$^$^  string usage  generates a random fst.nn  usage $^  usage  argv0$^  usage  out.fstn$^$^  stdsetnewhandlerfailednewhandler$^  setflagsusage.cstr argc argv true$^  if argc  0 $^    showusage$^    return 0$^  $^$^  string outname  argc  0  strcmpargv0   0  argv0  $^$^  srandflagsseed$^$^  int numstates  rand  flagsstates  0     nolint$^  int numclasses  rand  flagsclasses  0   nolint$^  int numlabels  rand  flagslabels  0     nolint$^$^  stdvectorfst fst$^  using tropicalweightgenerate  weightgeneratetropicalweight$^  stduniqueptrtropicalweightgenerate generateflagsweights $^      new tropicalweightgeneratefalse  nullptr$^  fstrandmodstdarc tropicalweightgenerate randmodnumstates$^      numclasses numlabels flagstransducer generate.get$^  randmod.generatefst$^  fst.writeoutname$^  return 0$^$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^ definitions of scriptable versions of compression operations that is$^ those that can be called with fstclasstype arguments.$^$^ see comments in nlpfstscriptscriptimpl.h for how the registration$^ mechanism allows these to work with various arc types.$^$^include utility$^include vector$^$^include fstextensionscompresscompressscript.h$^$^include fstscriptscriptimpl.h$^$^namespace fst $^namespace script $^$^void compressconst fstclass fst const string filename const bool gzip $^  compressargs argsfst filename gzip$^  applyoperationcompressargscompress fst.arctype args$^$^$^void decompressconst string filename mutablefstclass fst const bool gzip $^  decompressargs argsfilename fst gzip$^  applyoperationdecompressargsdecompress fstarctype args$^$^$^ register operations for common arc types.$^$^registerfstoperationcompress stdarc compressargs$^registerfstoperationcompress logarc compressargs$^registerfstoperationcompress log00arc compressargs$^$^registerfstoperationdecompress stdarc decompressargs$^registerfstoperationdecompress logarc decompressargs$^registerfstoperationdecompress log00arc decompressargs$^$^   namespace script$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^ compressesdecompresses an fst.$^$^include memory$^include string$^$^include fstextensionscompresscompressscript.h$^$^include fstflags.h$^include fstlog.h$^include fstutil.h$^include fstscriptfstclass.h$^$^definestringarctype standard output arc type$^definebooldecode false decode$^defineboolgzip false$^            applies gzip compression after lza compression and $^            gzip decompression before lza decompression $^            recommended$^            $^$^int mainint argc char argv $^  namespace s  fstscript$^$^  using sfstclass$^  using svectorfstclass$^$^  string usage  compressesdecompresses an fst.nn  usage $^  usage  argv0$^  usage   in.fst out.fstzn$^  usage   decode in.fstz out.fstn$^$^  stdsetnewhandlerfailednewhandler$^  setflagsusage.cstr argc argv true$^  if argc  0 $^    showusage$^    return 0$^  $^$^  string inname  argc  0  strcmpargv0   0  argv0  $^  string outname  argc  0  argv0  $^$^  if flagsdecode  false $^    stduniqueptrfstclass ifstfstclassreadinname$^    if ifst return 0$^    scompressifst outname flagsgzip$^   else $^    vectorfstclass ofstflagsarctype$^    sdecompressinname ofst flagsgzip$^    ofst.writeoutname$^  $^  return 0$^$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstfst.h$^include fstcompactfst.h$^$^namespace fst $^$^static fstregisterer$^    compactunweightedacceptorfststdarc uint0$^    compactunweightedacceptorfststdarcuint0registerer$^static fstregisterer$^    compactunweightedacceptorfstlogarc uint0$^    compactunweightedacceptorfstlogarcuint0registerer$^$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstfst.h$^include fstcompactfst.h$^$^namespace fst $^$^static fstregisterercompactacceptorfststdarc uint00$^    compactacceptorfststdarcuint00registerer$^static fstregisterercompactacceptorfstlogarc uint00$^    compactacceptorfstlogarcuint00registerer$^$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstfst.h$^include fstcompactfst.h$^$^namespace fst $^$^static fstregisterercompactstringfststdarc uint00$^    compactstringfststdarcuint00registerer$^static fstregisterercompactstringfstlogarc uint00$^    compactstringfstlogarcuint00registerer$^$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstfst.h$^include fstcompactfst.h$^$^namespace fst $^$^static fstregisterercompactacceptorfststdarc uint00$^    compactacceptorfststdarcuint00registerer$^$^static fstregisterercompactacceptorfstlogarc uint00$^    compactacceptorfstlogarcuint00registerer$^$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstfst.h$^include fstcompactfst.h$^$^namespace fst $^$^static fstregisterercompactunweightedfststdarc uint00$^    compactunweightedfststdarcuint00registerer$^static fstregisterercompactunweightedfstlogarc uint00$^    compactunweightedfstlogarcuint00registerer$^$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstfst.h$^include fstcompactfst.h$^$^namespace fst $^$^static fstregisterer$^    compactunweightedacceptorfststdarc uint00$^    compactunweightedacceptorfststdarcuint00registerer$^static fstregisterer$^    compactunweightedacceptorfstlogarc uint00$^    compactunweightedacceptorfstlogarcuint00registerer$^$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstfst.h$^include fstcompactfst.h$^$^namespace fst $^$^static fstregisterer$^    compactweightedstringfststdarc uint00$^    compactweightedstringfststdarcuint00registerer$^static fstregisterer$^    compactweightedstringfstlogarc uint00$^    compactweightedstringfstlogarcuint00registerer$^$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstfst.h$^include fstcompactfst.h$^$^namespace fst $^$^static fstregisterercompactunweightedfststdarc uint00$^    compactunweightedfststdarcuint00registerer$^static fstregisterercompactunweightedfstlogarc uint00$^    compactunweightedfstlogarcuint00registerer$^$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstfst.h$^include fstcompactfst.h$^$^namespace fst $^$^static fstregisterercompactstringfststdarc uint00$^    compactstringfststdarcuint00registerer$^static fstregisterercompactstringfstlogarc uint00$^    compactstringfstlogarcuint00registerer$^$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstfst.h$^include fstcompactfst.h$^$^namespace fst $^$^static fstregisterer$^    compactweightedstringfststdarc uint00$^    compactweightedstringfststdarcuint00registerer$^$^static fstregisterer$^    compactweightedstringfstlogarc uint00$^    compactweightedstringfstlogarcuint00registerer$^$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstfst.h$^include fstcompactfst.h$^$^namespace fst $^$^static fstregisterer$^    compactweightedstringfststdarc uint0$^    compactweightedstringfststdarcuint0registerer$^static fstregisterer$^    compactweightedstringfstlogarc uint0$^    compactweightedstringfstlogarcuint0registerer$^$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstfst.h$^include fstcompactfst.h$^$^namespace fst $^$^static fstregisterercompactacceptorfststdarc uint0$^    compactacceptorfststdarcuint0registerer$^static fstregisterercompactacceptorfstlogarc uint0$^    compactacceptorfstlogarcuint0registerer$^$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstfst.h$^include fstcompactfst.h$^$^namespace fst $^$^static fstregisterercompactstringfststdarc uint0$^    compactstringfststdarcuint0registerer$^static fstregisterercompactstringfstlogarc uint0$^    compactstringfstlogarcuint0registerer$^$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstfst.h$^include fstcompactfst.h$^$^namespace fst $^$^static fstregisterer$^    compactunweightedacceptorfststdarc uint00$^    compactunweightedacceptorfststdarcuint00registerer$^static fstregisterer$^    compactunweightedacceptorfstlogarc uint00$^    compactunweightedacceptorfstlogarcuint00registerer$^$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstfst.h$^include fstcompactfst.h$^$^namespace fst $^$^static fstregisterercompactunweightedfststdarc uint0$^    compactunweightedfststdarcuint0registerer$^static fstregisterercompactunweightedfstlogarc uint0$^    compactunweightedfstlogarcuint0registerer$^$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstfst.h$^include fstmatcherfst.h$^$^namespace fst $^$^static fstregistererstdarclookaheadfst arclookaheadfststdarcregisterer$^static fstregisterermatcherfst$^    constfstlogarc arclookaheadmatchersortedmatcherconstfstlogarc$^    arclookaheadfsttype$^    arclookaheadfstlogarcregisterer$^static fstregisterermatcherfst$^    constfstlog00arc arclookaheadmatchersortedmatcherconstfstlog00arc$^    arclookaheadfsttype$^    arclookaheadfstlog00arcregisterer$^$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstfst.h$^include fstmatcherfst.h$^$^namespace fst $^$^static fstregistererstdolabellookaheadfst$^    olabellookaheadfststdarcregisterer$^static fstregisterermatcherfst$^    constfstlogarc$^    labellookaheadmatchersortedmatcherconstfstlogarc$^                          olabellookaheadflags fastlogaccumulatorlogarc$^    olabellookaheadfsttype labellookaheadrelabelerlogarc$^    olabellookaheadfstlogarcregisterer$^static fstregisterermatcherfst$^    constfstlog00arc$^    labellookaheadmatchersortedmatcherconstfstlog00arc$^                          olabellookaheadflags fastlogaccumulatorlog00arc$^    olabellookaheadfsttype labellookaheadrelabelerlog00arc$^    olabellookaheadfstlog00arcregisterer$^$^   namespace fst$^ see www.openfst.org for extensive documentation on this weighted$^ finitestate transducer library.$^$^include fstfst.h$^include fstmatcherfst.h$^$^namespace fst $^$^static fstregistererstdilabellookaheadfst$^    ilabellookaheadfststdarcregisterer$^static fstregisterermatcherfst$^    constfstlogarc$^    labellookaheadmatchersortedmatcherconstfstlogarc$^                          ilabellookaheadflags fastlogaccumulatorlogarc$^    ilabellookaheadfsttype labellookaheadrelabelerlogarc$^    ilabellookaheadfstlogarcregisterer$^static fstregisterermatcherfst$^    constfstlog00arc$^    labellookaheadmatchersortedmatcherconstfstlog00arc$^                          ilabellookaheadflags fastlogaccumulatorlog00arc$^    ilabellookaheadfsttype labellookaheadrelabelerlog00arc$^    ilabellookaheadfstlog00arcregisterer$^$^   namespace fst$^ generated by cython 0.00.0 $^$^define pyssizetclean$^include python.h$^ifndef pypythonh$^    error python headers needed to compile c extensions please install development version of python.$^elif pyversionhex  0x00000000  0x00000000  pyversionhex  pyversionhex  0x00000000$^    error cython requires python 0.0 or python 0.0.$^else$^define cythonabi 0000$^define cythonfuturedivision 0$^include stddef.h$^ifndef offsetof$^  define offsetoftype member  sizet  type0  member $^endif$^if definedwin00  definedmswindows$^  ifndef stdcall$^    define stdcall$^  endif$^  ifndef cdecl$^    define cdecl$^  endif$^  ifndef fastcall$^    define fastcall$^  endif$^endif$^ifndef dlimport$^  define dlimportt t$^endif$^ifndef dlexport$^  define dlexportt t$^endif$^define pyxcomma $^ifndef havelonglong$^  if pyversionhex  0x00000000$^    define havelonglong$^  endif$^endif$^ifndef pylonglong$^  define pylonglong longlong$^endif$^ifndef pyhugeval$^  define pyhugeval hugeval$^endif$^ifdef pypyversion$^  define cythoncompilinginpypy 0$^  define cythoncompilinginpyston 0$^  define cythoncompilingincpython 0$^  undef cythonusetypeslots$^  define cythonusetypeslots 0$^  undef cythonusepytypelookup$^  define cythonusepytypelookup 0$^  if pyversionhex  0x00000000$^    undef cythonuseasyncslots$^    define cythonuseasyncslots 0$^  elif definedcythonuseasyncslots$^    define cythonuseasyncslots 0$^  endif$^  undef cythonusepylistinternals$^  define cythonusepylistinternals 0$^  undef cythonuseunicodeinternals$^  define cythonuseunicodeinternals 0$^  undef cythonuseunicodewriter$^  define cythonuseunicodewriter 0$^  undef cythonusepylonginternals$^  define cythonusepylonginternals 0$^  undef cythonavoidborrowedrefs$^  define cythonavoidborrowedrefs 0$^  undef cythonassumesafemacros$^  define cythonassumesafemacros 0$^  undef cythonunpackmethods$^  define cythonunpackmethods 0$^  undef cythonfastthreadstate$^  define cythonfastthreadstate 0$^  undef cythonfastpycall$^  define cythonfastpycall 0$^  undef cythonpep000multiphaseinit$^  define cythonpep000multiphaseinit 0$^  undef cythonusetpfinalize$^  define cythonusetpfinalize 0$^elif definedpystonversion$^  define cythoncompilinginpypy 0$^  define cythoncompilinginpyston 0$^  define cythoncompilingincpython 0$^  ifndef cythonusetypeslots$^    define cythonusetypeslots 0$^  endif$^  undef cythonusepytypelookup$^  define cythonusepytypelookup 0$^  undef cythonuseasyncslots$^  define cythonuseasyncslots 0$^  undef cythonusepylistinternals$^  define cythonusepylistinternals 0$^  ifndef cythonuseunicodeinternals$^    define cythonuseunicodeinternals 0$^  endif$^  undef cythonuseunicodewriter$^  define cythonuseunicodewriter 0$^  undef cythonusepylonginternals$^  define cythonusepylonginternals 0$^  ifndef cythonavoidborrowedrefs$^    define cythonavoidborrowedrefs 0$^  endif$^  ifndef cythonassumesafemacros$^    define cythonassumesafemacros 0$^  endif$^  ifndef cythonunpackmethods$^    define cythonunpackmethods 0$^  endif$^  undef cythonfastthreadstate$^  define cythonfastthreadstate 0$^  undef cythonfastpycall$^  define cythonfastpycall 0$^  undef cythonpep000multiphaseinit$^  define cythonpep000multiphaseinit 0$^  undef cythonusetpfinalize$^  define cythonusetpfinalize 0$^else$^  define cythoncompilinginpypy 0$^  define cythoncompilinginpyston 0$^  define cythoncompilingincpython 0$^  ifndef cythonusetypeslots$^    define cythonusetypeslots 0$^  endif$^  if pyversionhex  0x00000000$^    undef cythonusepytypelookup$^    define cythonusepytypelookup 0$^  elif definedcythonusepytypelookup$^    define cythonusepytypelookup 0$^  endif$^  if pymajorversion  0$^    undef cythonuseasyncslots$^    define cythonuseasyncslots 0$^  elif definedcythonuseasyncslots$^    define cythonuseasyncslots 0$^  endif$^  if pyversionhex  0x00000000$^    undef cythonusepylonginternals$^    define cythonusepylonginternals 0$^  elif definedcythonusepylonginternals$^    define cythonusepylonginternals 0$^  endif$^  ifndef cythonusepylistinternals$^    define cythonusepylistinternals 0$^  endif$^  ifndef cythonuseunicodeinternals$^    define cythonuseunicodeinternals 0$^  endif$^  if pyversionhex  0x000000f0$^    undef cythonuseunicodewriter$^    define cythonuseunicodewriter 0$^  elif definedcythonuseunicodewriter$^    define cythonuseunicodewriter 0$^  endif$^  ifndef cythonavoidborrowedrefs$^    define cythonavoidborrowedrefs 0$^  endif$^  ifndef cythonassumesafemacros$^    define cythonassumesafemacros 0$^  endif$^  ifndef cythonunpackmethods$^    define cythonunpackmethods 0$^  endif$^  ifndef cythonfastthreadstate$^    define cythonfastthreadstate 0$^  endif$^  ifndef cythonfastpycall$^    define cythonfastpycall 0$^  endif$^  ifndef cythonpep000multiphaseinit$^    define cythonpep000multiphaseinit 0  pyversionhex  0x00000000$^  endif$^  ifndef cythonusetpfinalize$^    define cythonusetpfinalize pyversionhex  0x000000a0$^  endif$^endif$^if definedcythonfastpyccall$^define cythonfastpyccall  cythonfastpycall  pyversionhex  0x000000b0$^endif$^if cythonusepylonginternals$^  include longintrepr.h$^  undef shift$^  undef base$^  undef mask$^endif$^if cythoncompilinginpypy  pyversionhex  0x00000000  definedpyoptimizeflag$^  define pyoptimizeflag 0$^endif$^define pyxbuildpyssizet n$^define cythonformatssizet z$^if pymajorversion  0$^  define pyxbuiltinmodulename builtin$^  define pyxpycodenewa k l s f code c n v fv cell fn name fline lnos$^          pycodenewak l s f code c n v fv cell fn name fline lnos$^  define pyxdefaultclasstype pyclasstype$^else$^  define pyxbuiltinmodulename builtins$^  define pyxpycodenewa k l s f code c n v fv cell fn name fline lnos$^          pycodenewa k l s f code c n v fv cell fn name fline lnos$^  define pyxdefaultclasstype pytypetype$^endif$^ifndef pytpflagschecktypes$^  define pytpflagschecktypes 0$^endif$^ifndef pytpflagshaveindex$^  define pytpflagshaveindex 0$^endif$^ifndef pytpflagshavenewbuffer$^  define pytpflagshavenewbuffer 0$^endif$^ifndef pytpflagshavefinalize$^  define pytpflagshavefinalize 0$^endif$^if pyversionhex  0x000000a0  definedmethfastcall$^  ifndef methfastcall$^     define methfastcall 0x00$^  endif$^  typedef pyobject pyxpycfunctionfast pyobject self pyobject args pyssizet nargs$^  typedef pyobject pyxpycfunctionfastwithkeywords pyobject self pyobject args$^                                                          pyssizet nargs pyobject kwnames$^else$^  define pyxpycfunctionfast pycfunctionfast$^  define pyxpycfunctionfastwithkeywords pycfunctionfastwithkeywords$^endif$^if cythonfastpyccall$^define pyxpyfastcfunctioncheckfunc$^    pycfunctioncheckfunc  methfastcall  pycfunctiongetflagsfunc  methclass  methstatic  methcoexist  methkeywords$^else$^define pyxpyfastcfunctioncheckfunc 0$^endif$^if cythonfastthreadstate  pyversionhex  0x00000000$^  define pyxpythreadstatecurrent pythreadstateget$^elif pyversionhex  0x00000000$^  define pyxpythreadstatecurrent pythreadstateuncheckedget$^elif pyversionhex  0x00000000$^  define pyxpythreadstatecurrent pythreadstateget$^else$^  define pyxpythreadstatecurrent pythreadstatecurrent$^endif$^if cythoncompilingincpython  definedpydictnewpresized$^define pyxpydictnewpresizedn  n  0  pydictnew  pydictnewpresizedn$^else$^define pyxpydictnewpresizedn  pydictnew$^endif$^if pymajorversion  0  cythonfuturedivision$^  define pyxpynumberdividexy         pynumbertruedividexy$^  define pyxpynumberinplacedividexy  pynumberinplacetruedividexy$^else$^  define pyxpynumberdividexy         pynumberdividexy$^  define pyxpynumberinplacedividexy  pynumberinplacedividexy$^endif$^if pyversionhex  0x00000000  definedpyunicodekind$^  define cythonpep000enabled 0$^  define pyxpyunicodereadyop       likelypyunicodeisreadyop $^                                              0  pyunicodereadypyobject op$^  define pyxpyunicodegetlengthu   pyunicodegetlengthu$^  define pyxpyunicodereadcharu i pyunicodereadcharu i$^  define pyxpyunicodemaxcharvalueu   pyunicodemaxcharvalueu$^  define pyxpyunicodekindu         pyunicodekindu$^  define pyxpyunicodedatau         pyunicodedatau$^  define pyxpyunicodereadk d i   pyunicodereadk d i$^  define pyxpyunicodewritek d i ch  pyunicodewritek d i ch$^  define pyxpyunicodeistrueu      0  likelypyunicodeisreadyu  pyunicodegetlengthu  pyunicodegetsizeu$^else$^  define cythonpep000enabled 0$^  define pyunicode0bytekind  0$^  define pyunicode0bytekind  0$^  define pyunicode0bytekind  0$^  define pyxpyunicodereadyop       0$^  define pyxpyunicodegetlengthu   pyunicodegetsizeu$^  define pyxpyunicodereadcharu i pyucs0pyunicodeasunicodeui$^  define pyxpyunicodemaxcharvalueu   sizeofpyunicode  0  00000  0000000$^  define pyxpyunicodekindu         sizeofpyunicode$^  define pyxpyunicodedatau         voidpyunicodeasunicodeu$^  define pyxpyunicodereadk d i   voidk pyucs0pyunicodedi$^  define pyxpyunicodewritek d i ch  voidk pyunicodedi  ch$^  define pyxpyunicodeistrueu      0  pyunicodegetsizeu$^endif$^if cythoncompilinginpypy$^  define pyxpyunicodeconcata b      pynumberadda b$^  define pyxpyunicodeconcatsafea b  pynumberadda b$^else$^  define pyxpyunicodeconcata b      pyunicodeconcata b$^  define pyxpyunicodeconcatsafea b  unlikelya  pynone  unlikelyb  pynone $^      pynumberadda b  pyxpyunicodeconcata b$^endif$^if cythoncompilinginpypy  definedpyunicodecontains$^  define pyunicodecontainsu s  pysequencecontainsu s$^endif$^if cythoncompilinginpypy  definedpybytearraycheck$^  define pybytearraycheckobj  pyobjecttypecheckobj pybytearraytype$^endif$^if cythoncompilinginpypy  definedpyobjectformat$^  define pyobjectformatobj fmt  pyobjectcallmethodobj format o fmt$^endif$^if cythoncompilinginpypy  definedpyobjectmalloc$^  define pyobjectmallocs   pymemmallocs$^  define pyobjectfreep     pymemfreep$^  define pyobjectreallocp  pymemreallocp$^endif$^if cythoncompilinginpyston$^  define pyxpycodehasfreevarsco  pycodehasfreevarsco$^  define pyxpyframesetlinenumberframe lineno pyframesetlinenumberframe lineno$^else$^  define pyxpycodehasfreevarsco  pycodegetnumfreeco  0$^  define pyxpyframesetlinenumberframe lineno  frameflineno  lineno$^endif$^define pyxpystringformatsafea b   unlikelya  pynone  pynumberremaindera b  pyxpystringformata b$^define pyxpyunicodeformatsafea b  unlikelya  pynone  pynumberremaindera b  pyunicodeformata b$^if pymajorversion  0$^  define pyxpystringformata b  pyunicodeformata b$^else$^  define pyxpystringformata b  pystringformata b$^endif$^if pymajorversion  0  definedpyobjectascii$^  define pyobjectasciio            pyobjectrepro$^endif$^if pymajorversion  0$^  define pybasestringtype            pyunicodetype$^  define pystringobject               pyunicodeobject$^  define pystringtype                pyunicodetype$^  define pystringcheck               pyunicodecheck$^  define pystringcheckexact          pyunicodecheckexact$^endif$^if pymajorversion  0$^  define pyxpybasestringcheckobj pyunicodecheckobj$^  define pyxpybasestringcheckexactobj pyunicodecheckexactobj$^else$^  define pyxpybasestringcheckobj pystringcheckobj  pyunicodecheckobj$^  define pyxpybasestringcheckexactobj pystringcheckexactobj  pyunicodecheckexactobj$^endif$^ifndef pysetcheckexact$^  define pysetcheckexactobj        pytypeobj  pysettype$^endif$^define pyxpyexceptioncheckobj pyxtypecheckobj pyexcexception$^if pymajorversion  0$^  define pyintobject                  pylongobject$^  define pyinttype                   pylongtype$^  define pyintcheckop              pylongcheckop$^  define pyintcheckexactop         pylongcheckexactop$^  define pyintfromstring             pylongfromstring$^  define pyintfromunicode            pylongfromunicode$^  define pyintfromlong               pylongfromlong$^  define pyintfromsizet             pylongfromsizet$^  define pyintfromssizet            pylongfromssizet$^  define pyintaslong                 pylongaslong$^  define pyintaslong                pylongaslong$^  define pyintasssizet              pylongasssizet$^  define pyintasunsignedlongmask     pylongasunsignedlongmask$^  define pyintasunsignedlonglongmask pylongasunsignedlonglongmask$^  define pynumberint                 pynumberlong$^endif$^if pymajorversion  0$^  define pyboolobject                 pylongobject$^endif$^if pymajorversion  0  cythoncompilinginpypy$^  ifndef pyunicodeinternfromstring$^    define pyunicodeinternfromstrings pyunicodefromstrings$^  endif$^endif$^if pyversionhex  0x000000a0$^  typedef long pyhasht$^  define pyxpyintfromhasht pyintfromlong$^  define pyxpyintashasht   pyintaslong$^else$^  define pyxpyintfromhasht pyintfromssizet$^  define pyxpyintashasht   pyintasssizet$^endif$^if pymajorversion  0$^  define pyxpymethodnewfunc self klass self  pymethodnewfunc self  pyinstancemethodnewfunc$^else$^  define pyxpymethodnewfunc self klass pymethodnewfunc self klass$^endif$^ifndef hasattribute$^  define hasattributex 0$^endif$^ifndef hascppattribute$^  define hascppattributex 0$^endif$^if cythonuseasyncslots$^  if pyversionhex  0x000000b0$^    define pyxpyasyncmethodsstruct pyasyncmethods$^    define pyxpytypeasasyncobj pytypeobjtpasasync$^  else$^    define pyxpytypeasasyncobj pyxpyasyncmethodsstruct pytypeobjtpreserved$^  endif$^else$^  define pyxpytypeasasyncobj null$^endif$^ifndef pyxpyasyncmethodsstruct$^    typedef struct $^        unaryfunc amawait$^        unaryfunc amaiter$^        unaryfunc amanext$^     pyxpyasyncmethodsstruct$^endif$^ifndef cythonrestrict$^  if definedgnuc$^    define cythonrestrict restrict$^  elif definedmscver  mscver  0000$^    define cythonrestrict restrict$^  elif defined stdcversion  stdcversion  000000l$^    define cythonrestrict restrict$^  else$^    define cythonrestrict$^  endif$^endif$^ifndef cythonunused$^ if definedgnuc$^   if definedcplusplus  gnuc  0  gnuc  0  gnucminor  0$^     define cythonunused attribute unused$^   else$^     define cythonunused$^   endif$^ elif definedicc  definedintelcompiler  definedmscver$^   define cythonunused attribute unused$^ else$^   define cythonunused$^ endif$^endif$^ifndef cythonmaybeunusedvar$^  if definedcplusplus$^     templateclass t void cythonmaybeunusedvar const t   $^  else$^    define cythonmaybeunusedvarx voidx$^  endif$^endif$^ifndef cythonncpunused$^ if cythoncompilingincpython$^  define cythonncpunused$^ else$^  define cythonncpunused cythonunused$^ endif$^endif$^define pyxvoidtononevoidresult voidvoidresult pyincrefpynone pynone$^ifdef mscver$^    ifndef mscstdinth$^        if mscver  0000$^           typedef unsigned char     uint0t$^           typedef unsigned int      uint00t$^        else$^           typedef unsigned int0   uint0t$^           typedef unsigned int00  uint00t$^        endif$^    endif$^else$^   include stdint.h$^endif$^ifndef cythonfallthrough$^  if definedcplusplus  cplusplus  000000l$^    if hascppattributefallthrough$^      define cythonfallthrough fallthrough$^    elif hascppattributeclangfallthrough$^      define cythonfallthrough clangfallthrough$^    elif hascppattributegnufallthrough$^      define cythonfallthrough gnufallthrough$^    endif$^  endif$^  ifndef cythonfallthrough$^    if hasattributefallthrough$^      define cythonfallthrough attributefallthrough$^    else$^      define cythonfallthrough$^    endif$^  endif$^  if definedclang   definedapplebuildversion$^    if applebuildversion  0000000$^      undef  cythonfallthrough$^      define cythonfallthrough$^    endif$^  endif$^endif$^$^ifndef cplusplus$^  error cython files generated with the c option must be compiled with a c compiler.$^endif$^ifndef cythoninline$^  if definedclang$^    define cythoninline inline attribute unused$^  else$^    define cythoninline inline$^  endif$^endif$^templatetypename t$^void pyxcalldestructort x $^    x.t$^$^templatetypename t$^class pyxfakereference $^  public$^    pyxfakereference  ptrnull  $^    pyxfakereferenceconst t ref  ptrconstcasttref  $^    t operator  return ptr $^    t operator  return ptr $^    operator t  return ptr $^    templatetypename u bool operator u other  return ptr  other $^    templatetypename u bool operator u other  return ptr  other $^  private$^    t ptr$^$^$^if definedwin00  definedmswindows$^  define usemathdefines$^endif$^include math.h$^ifdef nan$^define pyxnan float nan$^else$^static cythoninline float pyxnan $^  float value$^  memsetvalue 0xff sizeofvalue$^  return value$^$^endif$^if definedcygwin  definedldbleqdbl$^define pyxtruncl trunc$^else$^define pyxtruncl truncl$^endif$^$^$^define pyxerrfindex lineno lnerror $^ $^  pyxfilename  pyxffindex pyxlineno  lineno pyxclineno  line goto lnerror $^$^$^ifndef pyxexternc$^  ifdef cplusplus$^    define pyxexternc extern c$^  else$^    define pyxexternc extern$^  endif$^endif$^$^define pyxhavepywrapfst$^define pyxhaveapipywrapfst$^include stddef.h$^include time.h$^include memory$^include ios$^include new$^include stdexcept$^include typeinfo$^include utility$^include vector$^include string.h$^include string$^include stdint.h$^include iostream$^include fstream$^include sstream$^include fstutil.h$^include fstfstlib.h$^include fstscriptfstscript.h$^include fstscriptgetters.h$^include fstextensionsfarfar.h$^include fstextensionsfargetters.h$^include fstextensionsfarfarclass.h$^include systypes.h$^include unistd.h$^ifdef openmp$^include omp.h$^endif  openmp $^$^if definedpyrexwithoutassertions  definedcythonwithoutassertions$^define cythonwithoutassertions$^endif$^$^typedef struct pyobject p const char s const pyssizet n const char encoding$^                const char isunicode const char isstr const char intern  pyxstringtabentry$^$^define pyxdefaultstringencodingisascii 0$^define pyxdefaultstringencodingisdefault 0$^define pyxdefaultstringencoding $^define pyxpyobjectfromstring pyxpybytesfromstring$^define pyxpyobjectfromstringandsize pyxpybytesfromstringandsize$^define pyxucharcastc unsigned charc$^define pyxlongcastx longx$^define pyxfitspyssizetv type issigned  $^    sizeoftype  sizeofpyssizet  $^    sizeoftype  sizeofpyssizet $^          likelyv  typepyssizetmax $^                 v  typepyssizetmax  $^          issigned  likelyv  typepyssizetmin $^                                v  typepyssizetmin  $^    sizeoftype  sizeofpyssizet $^          issigned  likelyv  typepyssizetmax $^                               v  typepyssizetmax  $^if defined cplusplus  cplusplus  000000l$^    include cstdlib$^    define pyxsstabsvalue stdabsvalue$^elif sizeofint  sizeofsizet$^    define pyxsstabsvalue absvalue$^elif sizeoflong  sizeofsizet$^    define pyxsstabsvalue labsvalue$^elif defined mscver$^    define pyxsstabsvalue pyssizetabs00value$^elif defined stdcversion  stdcversion  000000l$^    define pyxsstabsvalue llabsvalue$^elif defined gnuc$^    define pyxsstabsvalue builtinllabsvalue$^else$^    define pyxsstabsvalue value0  value  value$^endif$^static cythoninline const char pyxpyobjectasstringpyobject$^static cythoninline const char pyxpyobjectasstringandsizepyobject pyssizet length$^define pyxpybytearrayfromstrings pybytearrayfromstringandsizeconst chars strlenconst chars$^define pyxpybytearrayfromstringandsizes l pybytearrayfromstringandsizeconst chars l$^define pyxpybytesfromstring        pybytesfromstring$^define pyxpybytesfromstringandsize pybytesfromstringandsize$^static cythoninline pyobject pyxpyunicodefromstringconst char$^if pymajorversion  0$^    define pyxpystrfromstring        pyxpybytesfromstring$^    define pyxpystrfromstringandsize pyxpybytesfromstringandsize$^else$^    define pyxpystrfromstring        pyxpyunicodefromstring$^    define pyxpystrfromstringandsize pyxpyunicodefromstringandsize$^endif$^define pyxpybytesaswritablestrings     char pybytesasstrings$^define pyxpybytesaswritablesstrings    signed char pybytesasstrings$^define pyxpybytesaswritableustrings    unsigned char pybytesasstrings$^define pyxpybytesasstrings     const char pybytesasstrings$^define pyxpybytesassstrings    const signed char pybytesasstrings$^define pyxpybytesasustrings    const unsigned char pybytesasstrings$^define pyxpyobjectaswritablestrings    char pyxpyobjectasstrings$^define pyxpyobjectaswritablesstrings    signed char pyxpyobjectasstrings$^define pyxpyobjectaswritableustrings    unsigned char pyxpyobjectasstrings$^define pyxpyobjectassstrings    const signed char pyxpyobjectasstrings$^define pyxpyobjectasustrings    const unsigned char pyxpyobjectasstrings$^define pyxpyobjectfromcstrings  pyxpyobjectfromstringconst chars$^define pyxpybytesfromcstrings   pyxpybytesfromstringconst chars$^define pyxpybytearrayfromcstrings   pyxpybytearrayfromstringconst chars$^define pyxpystrfromcstrings     pyxpystrfromstringconst chars$^define pyxpyunicodefromcstrings pyxpyunicodefromstringconst chars$^static cythoninline sizet pyxpyunicodestrlenconst pyunicode u $^    const pyunicode uend  u$^    while uend $^    return sizetuend  u  0$^$^define pyxpyunicodefromunicodeu       pyunicodefromunicodeu pyxpyunicodestrlenu$^define pyxpyunicodefromunicodeandlength pyunicodefromunicode$^define pyxpyunicodeasunicode            pyunicodeasunicode$^define pyxnewrefobj pyincrefobj obj$^define pyxownedpynoneb pyxnewrefpynone$^define pyxpyboolfromlongb b  pyxnewrefpytrue  pyxnewrefpyfalse$^static cythoninline int pyxpyobjectistruepyobject$^static cythoninline pyobject pyxpynumberintorlongpyobject x$^define pyxpysequencetupleobj$^    likelypytuplecheckexactobj  pyxnewrefobj  pysequencetupleobj$^static cythoninline pyssizet pyxpyindexasssizetpyobject$^static cythoninline pyobject  pyxpyintfromsizetsizet$^if cythonassumesafemacros$^define pyxpyfloatasdoublex pyfloatcheckexactx  pyfloatasdoublex  pyfloatasdoublex$^else$^define pyxpyfloatasdoublex pyfloatasdoublex$^endif$^define pyxpyfloatasfloatx float pyxpyfloatasdoublex$^if pymajorversion  0$^define pyxpynumberintx pylongcheckexactx  pyxnewrefx  pynumberlongx$^else$^define pyxpynumberintx pyintcheckexactx  pyxnewrefx  pynumberintx$^endif$^define pyxpynumberfloatx pyfloatcheckexactx  pyxnewrefx  pynumberfloatx$^if pymajorversion  0  pyxdefaultstringencodingisascii$^static int pyxsysgetdefaultencodingnotascii$^static int pyxinitsysgetdefaultencodingparamsvoid $^    pyobject sys$^    pyobject defaultencoding  null$^    pyobject asciicharsu  null$^    pyobject asciicharsb  null$^    const char defaultencodingc$^    sys  pyimportimportmodulesys$^    if sys goto bad$^    defaultencoding  pyobjectcallmethodsys char getdefaultencoding null$^    pydecrefsys$^    if defaultencoding goto bad$^    defaultencodingc  pybytesasstringdefaultencoding$^    if defaultencodingc goto bad$^    if strcmpdefaultencodingc ascii  0 $^        pyxsysgetdefaultencodingnotascii  0$^     else $^        char asciichars000$^        int c$^        for c  0 c  000 c $^            asciicharsc  c$^        $^        pyxsysgetdefaultencodingnotascii  0$^        asciicharsu  pyunicodedecodeasciiasciichars 000 null$^        if asciicharsu goto bad$^        asciicharsb  pyunicodeasencodedstringasciicharsu defaultencodingc null$^        if asciicharsb  pybytescheckasciicharsb  memcmpasciichars pybytesasstringasciicharsb 000  0 $^            pyerrformat$^                pyexcvalueerror$^                this module compiled with cstringencodingascii but default encoding .000s is not a superset of ascii.$^                defaultencodingc$^            goto bad$^        $^        pydecrefasciicharsu$^        pydecrefasciicharsb$^    $^    pydecrefdefaultencoding$^    return 0$^bad$^    pyxdecrefdefaultencoding$^    pyxdecrefasciicharsu$^    pyxdecrefasciicharsb$^    return 0$^$^endif$^if pyxdefaultstringencodingisdefault  pymajorversion  0$^define pyxpyunicodefromstringandsizecstr size pyunicodedecodeutf0cstr size null$^else$^define pyxpyunicodefromstringandsizecstr size pyunicodedecodecstr size pyxdefaultstringencoding null$^if pyxdefaultstringencodingisdefault$^static char pyxdefaultstringencoding$^static int pyxinitsysgetdefaultencodingparamsvoid $^    pyobject sys$^    pyobject defaultencoding  null$^    char defaultencodingc$^    sys  pyimportimportmodulesys$^    if sys goto bad$^    defaultencoding  pyobjectcallmethodsys char const char getdefaultencoding null$^    pydecrefsys$^    if defaultencoding goto bad$^    defaultencodingc  pybytesasstringdefaultencoding$^    if defaultencodingc goto bad$^    pyxdefaultstringencoding  char mallocstrlendefaultencodingc$^    if pyxdefaultstringencoding goto bad$^    strcpypyxdefaultstringencoding defaultencodingc$^    pydecrefdefaultencoding$^    return 0$^bad$^    pyxdecrefdefaultencoding$^    return 0$^$^endif$^endif$^$^$^ test for gcc  0.00 $^if definedgnuc      gnuc  0  gnuc  0  gnucminor  00$^  define likelyx   builtinexpectx 0$^  define unlikelyx builtinexpectx 0$^else  gnuc or gcc  0.00 $^  define likelyx   x$^  define unlikelyx x$^endif  gnuc $^static cythoninline void pyxpretendtoinitializevoid ptr  voidptr $^$^static pyobject pyxm  null$^static pyobject pyxd$^static pyobject pyxb$^static pyobject pyxcythonruntime$^static pyobject pyxemptytuple$^static pyobject pyxemptybytes$^static pyobject pyxemptyunicode$^static int pyxlineno$^static int pyxclineno  0$^static const char  pyxcfilenm file$^static const char pyxfilename$^$^$^static const char pyxf  $^  pywrapfst.pyx$^  stringsource$^$^$^ basictypes.pxd00$^  $^  $^  ctypedef int0t int0              $^  ctypedef int00t int00$^  ctypedef int00t int00$^ $^typedef int0t pyxt00basictypesint0$^$^ basictypes.pxd00$^  $^  ctypedef int0t int0$^  ctypedef int00t int00              $^  ctypedef int00t int00$^  ctypedef int00t int00$^ $^typedef int00t pyxt00basictypesint00$^$^ basictypes.pxd00$^  ctypedef int0t int0$^  ctypedef int00t int00$^  ctypedef int00t int00              $^  ctypedef int00t int00$^  ctypedef uint0t uint0$^ $^typedef int00t pyxt00basictypesint00$^$^ basictypes.pxd00$^  ctypedef int00t int00$^  ctypedef int00t int00$^  ctypedef int00t int00              $^  ctypedef uint0t uint0$^  ctypedef uint00t uint00$^ $^typedef int00t pyxt00basictypesint00$^$^ basictypes.pxd00$^  ctypedef int00t int00$^  ctypedef int00t int00$^  ctypedef uint0t uint0              $^  ctypedef uint00t uint00$^  ctypedef uint00t uint00$^ $^typedef uint0t pyxt00basictypesuint0$^$^ basictypes.pxd00$^  ctypedef int00t int00$^  ctypedef uint0t uint0$^  ctypedef uint00t uint00              $^  ctypedef uint00t uint00$^  ctypedef uint00t uint00$^ $^typedef uint00t pyxt00basictypesuint00$^$^ basictypes.pxd00$^  ctypedef uint0t uint0$^  ctypedef uint00t uint00$^  ctypedef uint00t uint00              $^  ctypedef uint00t uint00$^ $^typedef uint00t pyxt00basictypesuint00$^$^ basictypes.pxd00$^  ctypedef uint00t uint00$^  ctypedef uint00t uint00$^  ctypedef uint00t uint00              $^ $^typedef uint00t pyxt00basictypesuint00$^$^ type declarations $^struct pyxobj0pywrapfstweight$^struct pyxobj0pywrapfstsymboltable$^struct pyxobj0pywrapfstencodemappersymboltable$^struct pyxobj0pywrapfstfstsymboltable$^struct pyxobj0pywrapfstmutablesymboltable$^struct pyxobj0pywrapfstmutablefstsymboltable$^struct pyxobj0pywrapfstsymboltable$^struct pyxobj0pywrapfstsymboltableiterator$^struct pyxobj0pywrapfstencodemapper$^struct pyxobj0pywrapfstfst$^struct pyxobj0pywrapfstmutablefst$^struct pyxobj0pywrapfstarc$^struct pyxobj0pywrapfstarciterator$^struct pyxobj0pywrapfstmutablearciterator$^struct pyxobj0pywrapfststateiterator$^struct pyxobj0pywrapfstcompiler$^struct pyxobj0pywrapfstfarreader$^struct pyxobj0pywrapfstfarwriter$^$^ fst.pxd000$^  $^  $^  ctypedef pairint00 const fstclass  labelfstclasspair              $^  $^  ctypedef pairint00 int00 labelpair$^ $^typedef stdpairpyxt00basictypesint00fstscriptfstclass const   pyxt0fstlabelfstclasspair$^$^ fst.pxd000$^  ctypedef pairint00 const fstclass  labelfstclasspair$^  $^  ctypedef pairint00 int00 labelpair              $^  $^  $^ $^typedef stdpairpyxt00basictypesint00pyxt00basictypesint00  pyxt0fstlabelpair$^struct pyxoptargs0pywrapfsttostring$^struct pyxoptargs0pywrapfstweighttostring$^struct pyxoptargs0pywrapfst00mutablesymboltableaddsymbol$^struct pyxoptargs0pywrapfst0fstdraw$^struct pyxoptargs0pywrapfst0fsttext$^struct pyxoptargs0pywrapfst00mutablefstarcsort$^struct pyxoptargs0pywrapfst00mutablefstclosure$^struct pyxoptargs0pywrapfst00mutablefstdeletearcs$^struct pyxoptargs0pywrapfst00mutablefstdeletestates$^struct pyxoptargs0pywrapfst00mutablefstminimize$^struct pyxoptargs0pywrapfst00mutablefstproject$^struct pyxoptargs0pywrapfst00mutablefstprune$^struct pyxoptargs0pywrapfst00mutablefstpush$^struct pyxoptargs0pywrapfst00mutablefstrelabelpairs$^struct pyxoptargs0pywrapfst00mutablefstrelabeltables$^struct pyxoptargs0pywrapfst00mutablefstreweight$^struct pyxoptargs0pywrapfst00mutablefstrmepsilon$^struct pyxoptargs0pywrapfst00mutablefstsetfinal$^struct pyxoptargs0pywrapfstcreatefst$^struct pyxoptargs0pywrapfstmap$^struct pyxoptargs0pywrapfstarcmap$^struct pyxoptargs0pywrapfstcompose$^struct pyxoptargs0pywrapfstconvert$^struct pyxoptargs0pywrapfstdeterminize$^struct pyxoptargs0pywrapfstdifference$^struct pyxoptargs0pywrapfstdisambiguate$^struct pyxoptargs0pywrapfstepsnormalize$^struct pyxoptargs0pywrapfstequal$^struct pyxoptargs0pywrapfstequivalent$^struct pyxoptargs0pywrapfstintersect$^struct pyxoptargs0pywrapfstisomorphic$^struct pyxoptargs0pywrapfstprune$^struct pyxoptargs0pywrapfstpush$^struct pyxoptargs0pywrapfstrandequivalent$^struct pyxoptargs0pywrapfstrandgen$^struct pyxoptargs0pywrapfstreplace$^struct pyxoptargs0pywrapfstreverse$^struct pyxoptargs0pywrapfstshortestdistance$^struct pyxoptargs0pywrapfstshortestpath$^$^ pywrapfst.pxd00$^  $^  $^  cdef string tostringdata encoding except               $^  $^  cdef string weighttostringdata encoding except $^ $^struct pyxoptargs0pywrapfsttostring $^  int pyxn$^  pyobject encoding$^$^$^ pywrapfst.pxd00$^  cdef string tostringdata encoding except $^  $^  cdef string weighttostringdata encoding except               $^  $^  cdef fst.composefilter getcomposefilter$^ $^struct pyxoptargs0pywrapfstweighttostring $^  int pyxn$^  pyobject encoding$^$^$^ pywrapfst.pxd00$^   symboltable.$^  $^  ctypedef fst.symboltable  symboltableptr              $^  $^  $^ $^typedef fstsymboltable pyxt0pywrapfstsymboltableptr$^$^ pywrapfst.pxd000$^  cdef class mutablesymboltablesymboltable$^  $^    cpdef int00 addsymbolself symbol int00 key              $^  $^    cpdef void addtableself symboltable syms$^ $^struct pyxoptargs0pywrapfst00mutablesymboltableaddsymbol $^  int pyxn$^  pyxt00basictypesint00 key$^$^$^ pywrapfst.pxd000$^  $^  $^  ctypedef fst.fstclass  fstclassptr              $^  ctypedef fst.mutablefstclass  mutablefstclassptr$^  ctypedef fst.vectorfstclass  vectorfstclassptr$^ $^typedef fstscriptfstclass pyxt0pywrapfstfstclassptr$^$^ pywrapfst.pxd000$^  $^  ctypedef fst.fstclass  fstclassptr$^  ctypedef fst.mutablefstclass  mutablefstclassptr              $^  ctypedef fst.vectorfstclass  vectorfstclassptr$^  $^ $^typedef fstscriptmutablefstclass pyxt0pywrapfstmutablefstclassptr$^$^ pywrapfst.pxd000$^  ctypedef fst.fstclass  fstclassptr$^  ctypedef fst.mutablefstclass  mutablefstclassptr$^  ctypedef fst.vectorfstclass  vectorfstclassptr              $^  $^  $^ $^typedef fstscriptvectorfstclass pyxt0pywrapfstvectorfstclassptr$^$^ pywrapfst.pxd000$^    cpdef fst copyself$^  $^    cpdef void drawself filename symboltable isymbols              $^                    symboltable osymbols symboltable ssymbols$^                    bool acceptor title double width$^ $^struct pyxoptargs0pywrapfst0fstdraw $^  int pyxn$^  struct pyxobj0pywrapfstsymboltable isymbols$^  struct pyxobj0pywrapfstsymboltable osymbols$^  struct pyxobj0pywrapfstsymboltable ssymbols$^  bool acceptor$^  pyobject title$^  double width$^  double height$^  bool portrait$^  bool vertical$^  double ranksep$^  double nodesep$^  pyxt00basictypesint00 fontsize$^  pyxt00basictypesint00 precision$^  pyobject floatformat$^  bool showweightone$^$^$^ pywrapfst.pxd000$^    cpdef stateiterator statesself$^  $^    cpdef string textself symboltable isymbols symboltable osymbols              $^                      symboltable ssymbols bool acceptor$^                      bool showweightone missingsym$^ $^struct pyxoptargs0pywrapfst0fsttext $^  int pyxn$^  struct pyxobj0pywrapfstsymboltable isymbols$^  struct pyxobj0pywrapfstsymboltable osymbols$^  struct pyxobj0pywrapfstsymboltable ssymbols$^  bool acceptor$^  bool showweightone$^  pyobject missingsym$^$^$^ pywrapfst.pxd000$^    cpdef int00 addstateself except $^  $^    cdef void arcsortself sorttype except               $^  $^    cdef void closureself bool closureplus except $^ $^struct pyxoptargs0pywrapfst00mutablefstarcsort $^  int pyxn$^  pyobject sorttype$^$^$^ pywrapfst.pxd000$^    cdef void arcsortself sorttype except $^  $^    cdef void closureself bool closureplus except               $^  $^    cdef void concatself fst ifst except $^ $^struct pyxoptargs0pywrapfst00mutablefstclosure $^  int pyxn$^  bool closureplus$^$^$^ pywrapfst.pxd000$^    cdef void decodeself encodemapper except $^  $^    cdef void deletearcsself int00 state sizet n except               $^  $^    cdef void deletestatesself states except $^ $^struct pyxoptargs0pywrapfst00mutablefstdeletearcs $^  int pyxn$^  sizet n$^$^$^ pywrapfst.pxd000$^    cdef void deletearcsself int00 state sizet n except $^  $^    cdef void deletestatesself states except               $^  $^    cdef void encodeself encodemapper except $^ $^struct pyxoptargs0pywrapfst00mutablefstdeletestates $^  int pyxn$^  pyobject states$^$^$^ pywrapfst.pxd000$^    cdef void invertself except $^  $^    cdef void minimizeself float delta bool allownondet except               $^  $^    cpdef mutablearciterator mutablearcsself int00 state$^ $^struct pyxoptargs0pywrapfst00mutablefstminimize $^  int pyxn$^  float delta$^  bool allownondet$^$^$^ pywrapfst.pxd000$^    cpdef int00 numstatesself$^  $^    cdef void projectself bool projectoutput except               $^  $^    cdef void pruneself float delta int00 nstate weight except $^ $^struct pyxoptargs0pywrapfst00mutablefstproject $^  int pyxn$^  bool projectoutput$^$^$^ pywrapfst.pxd000$^    cdef void projectself bool projectoutput except $^  $^    cdef void pruneself float delta int00 nstate weight except               $^  $^    cdef void pushself float delta bool removetotalweight$^ $^struct pyxoptargs0pywrapfst00mutablefstprune $^  int pyxn$^  float delta$^  pyxt00basictypesint00 nstate$^  pyobject weight$^$^$^ pywrapfst.pxd000$^    cdef void pruneself float delta int00 nstate weight except $^  $^    cdef void pushself float delta bool removetotalweight              $^                    bool tofinal except $^  $^ $^struct pyxoptargs0pywrapfst00mutablefstpush $^  int pyxn$^  float delta$^  bool removetotalweight$^  bool tofinal$^$^$^ pywrapfst.pxd000$^                    bool tofinal except $^  $^    cdef void relabelpairsself ipairs opairs except               $^  $^    cdef void relabeltablesself symboltable oldisymbols$^ $^struct pyxoptargs0pywrapfst00mutablefstrelabelpairs $^  int pyxn$^  pyobject ipairs$^  pyobject opairs$^$^$^ pywrapfst.pxd000$^    cdef void relabelpairsself ipairs opairs except $^  $^    cdef void relabeltablesself symboltable oldisymbols              $^        symboltable newisymbols unknownisymbol$^        bool attachnewisymbols$^ $^struct pyxoptargs0pywrapfst00mutablefstrelabeltables $^  int pyxn$^  struct pyxobj0pywrapfstsymboltable oldisymbols$^  struct pyxobj0pywrapfstsymboltable newisymbols$^  pyobject unknownisymbol$^  bool attachnewisymbols$^  struct pyxobj0pywrapfstsymboltable oldosymbols$^  struct pyxobj0pywrapfstsymboltable newosymbols$^  pyobject unknownosymbol$^  bool attachnewosymbols$^$^$^ pywrapfst.pxd000$^    cdef void reservestatesself int00 n except $^  $^    cdef void reweightself potentials bool tofinal except               $^  $^    cdef void rmepsilonself queuetype bool connect weight$^ $^struct pyxoptargs0pywrapfst00mutablefstreweight $^  int pyxn$^  bool tofinal$^$^$^ pywrapfst.pxd000$^    cdef void reweightself potentials bool tofinal except $^  $^    cdef void rmepsilonself queuetype bool connect weight              $^                         int00 nstate float delta except $^  $^ $^struct pyxoptargs0pywrapfst00mutablefstrmepsilon $^  int pyxn$^  pyobject queuetype$^  bool connect$^  pyobject weight$^  pyxt00basictypesint00 nstate$^  float delta$^$^$^ pywrapfst.pxd000$^                         int00 nstate float delta except $^  $^    cdef void setfinalself int00 state weight except               $^  $^    cdef void setpropertiesself uint00 props uint00 mask$^ $^struct pyxoptargs0pywrapfst00mutablefstsetfinal $^  int pyxn$^  pyobject weight$^$^$^ pywrapfst.pxd000$^  cdef fst initxfstfstclassptr tfst$^  $^  cdef mutablefst createfstarctype              $^  $^  cpdef fst readfilename$^ $^struct pyxoptargs0pywrapfstcreatefst $^  int pyxn$^  pyobject arctype$^$^$^ pywrapfst.pxd000$^  $^  $^  cdef fst mapfst ifst float delta maptype double power weight              $^  $^  cpdef fst arcmapfst ifst float delta maptype double power weight$^ $^struct pyxoptargs0pywrapfstmap $^  int pyxn$^  float delta$^  pyobject maptype$^  double power$^  pyobject weight$^$^$^ pywrapfst.pxd000$^  cdef fst mapfst ifst float delta maptype double power weight$^  $^  cpdef fst arcmapfst ifst float delta maptype double power weight              $^  $^  cpdef mutablefst composefst ifst0 fst ifst0 composefilter$^ $^struct pyxoptargs0pywrapfstarcmap $^  int pyxn$^  float delta$^  pyobject maptype$^  double power$^  pyobject weight$^$^$^ pywrapfst.pxd000$^  cpdef fst arcmapfst ifst float delta maptype double power weight$^  $^  cpdef mutablefst composefst ifst0 fst ifst0 composefilter              $^                            bool connect$^  $^ $^struct pyxoptargs0pywrapfstcompose $^  int pyxn$^  pyobject composefilter$^  bool connect$^$^$^ pywrapfst.pxd000$^                            bool connect$^  $^  cpdef fst convertfst ifst fsttype              $^  $^  cpdef mutablefst determinizefst ifst float delta dettype$^ $^struct pyxoptargs0pywrapfstconvert $^  int pyxn$^  pyobject fsttype$^$^$^ pywrapfst.pxd000$^  cpdef fst convertfst ifst fsttype$^  $^  cpdef mutablefst determinizefst ifst float delta dettype              $^                                int00 nstate int00 subsequentiallabel$^                                weight bool incrementsubsequentiallabel$^ $^struct pyxoptargs0pywrapfstdeterminize $^  int pyxn$^  float delta$^  pyobject dettype$^  pyxt00basictypesint00 nstate$^  pyxt00basictypesint00 subsequentiallabel$^  pyobject weight$^  bool incrementsubsequentiallabel$^$^$^ pywrapfst.pxd000$^                                weight bool incrementsubsequentiallabel$^  $^  cpdef mutablefst differencefst ifst0 fst ifst0 composefilter              $^                               bool connect$^  $^ $^struct pyxoptargs0pywrapfstdifference $^  int pyxn$^  pyobject composefilter$^  bool connect$^$^$^ pywrapfst.pxd000$^                               bool connect$^  $^  cpdef mutablefst disambiguatefst ifst float delta int00 nstate              $^                                 int00 subsequentiallabel weight$^  $^ $^struct pyxoptargs0pywrapfstdisambiguate $^  int pyxn$^  float delta$^  pyxt00basictypesint00 nstate$^  pyxt00basictypesint00 subsequentiallabel$^  pyobject weight$^$^$^ pywrapfst.pxd000$^                                 int00 subsequentiallabel weight$^  $^  cpdef mutablefst epsnormalizefst ifst bool epsnormoutput              $^  $^  cpdef bool equalfst ifst0 fst ifst0 float delta$^ $^struct pyxoptargs0pywrapfstepsnormalize $^  int pyxn$^  bool epsnormoutput$^$^$^ pywrapfst.pxd000$^  cpdef mutablefst epsnormalizefst ifst bool epsnormoutput$^  $^  cpdef bool equalfst ifst0 fst ifst0 float delta              $^  $^  cpdef bool equivalentfst ifst0 fst ifst0 float delta except $^ $^struct pyxoptargs0pywrapfstequal $^  int pyxn$^  float delta$^$^$^ pywrapfst.pxd000$^  cpdef bool equalfst ifst0 fst ifst0 float delta$^  $^  cpdef bool equivalentfst ifst0 fst ifst0 float delta except               $^  $^  cpdef mutablefst intersectfst ifst0 fst ifst0 composefilter$^ $^struct pyxoptargs0pywrapfstequivalent $^  int pyxn$^  float delta$^$^$^ pywrapfst.pxd000$^  cpdef bool equivalentfst ifst0 fst ifst0 float delta except $^  $^  cpdef mutablefst intersectfst ifst0 fst ifst0 composefilter              $^                              bool connect$^  $^ $^struct pyxoptargs0pywrapfstintersect $^  int pyxn$^  pyobject composefilter$^  bool connect$^$^$^ pywrapfst.pxd000$^                              bool connect$^  $^  cpdef bool isomorphicfst ifst0 fst ifst0 float delta              $^  $^  cpdef mutablefst prunefst ifst float delta int00 nstate$^ $^struct pyxoptargs0pywrapfstisomorphic $^  int pyxn$^  float delta$^$^$^ pywrapfst.pxd000$^  cpdef bool isomorphicfst ifst0 fst ifst0 float delta$^  $^  cpdef mutablefst prunefst ifst float delta int00 nstate              $^                          weight$^  $^ $^struct pyxoptargs0pywrapfstprune $^  int pyxn$^  float delta$^  pyxt00basictypesint00 nstate$^  pyobject weight$^$^$^ pywrapfst.pxd000$^                          weight$^  $^  cpdef mutablefst pushfst ifst float delta bool pushweights              $^                         bool pushlabels bool removecommonaffix$^                         bool removetotalweight bool tofinal$^ $^struct pyxoptargs0pywrapfstpush $^  int pyxn$^  float delta$^  bool pushweights$^  bool pushlabels$^  bool removecommonaffix$^  bool removetotalweight$^  bool tofinal$^$^$^ pywrapfst.pxd000$^                         bool removetotalweight bool tofinal$^  $^  cpdef bool randequivalentfst ifst0 fst ifst0 int00 npath              $^                            float delta timet seed select$^                            int00 maxlength except $^ $^struct pyxoptargs0pywrapfstrandequivalent $^  int pyxn$^  pyxt00basictypesint00 npath$^  float delta$^  timet seed$^  pyobject select$^  pyxt00basictypesint00 maxlength$^$^$^ pywrapfst.pxd000$^                            int00 maxlength except $^  $^  cpdef mutablefst randgenfst ifst int00 npath timet seed              $^                            select int00 maxlength$^                            bool removetotalweight bool weighted$^ $^struct pyxoptargs0pywrapfstrandgen $^  int pyxn$^  pyxt00basictypesint00 npath$^  timet seed$^  pyobject select$^  pyxt00basictypesint00 maxlength$^  bool removetotalweight$^  bool weighted$^$^$^ pywrapfst.pxd000$^      bool epsilononreplace except $^  $^  cpdef mutablefst replacepairs callarclabeling returnarclabeling              $^                            bool epsilononreplace int00 returnlabel$^  $^ $^struct pyxoptargs0pywrapfstreplace $^  int pyxn$^  pyobject callarclabeling$^  pyobject returnarclabeling$^  bool epsilononreplace$^  pyxt00basictypesint00 returnlabel$^$^$^ pywrapfst.pxd000$^                            bool epsilononreplace int00 returnlabel$^  $^  cpdef mutablefst reversefst ifst bool requiresuperinitial              $^  $^  cdef vectorfst.weightclass shortestdistancefst ifst float delta$^ $^struct pyxoptargs0pywrapfstreverse $^  int pyxn$^  bool requiresuperinitial$^$^$^ pywrapfst.pxd000$^  cpdef mutablefst reversefst ifst bool requiresuperinitial$^  $^  cdef vectorfst.weightclass shortestdistancefst ifst float delta              $^                                                  int00 nstate queuetype$^                                                  bool reverse except $^ $^struct pyxoptargs0pywrapfstshortestdistance $^  int pyxn$^  float delta$^  pyxt00basictypesint00 nstate$^  pyobject queuetype$^  bool reverse$^$^$^ pywrapfst.pxd000$^                                                  bool reverse except $^  $^  cpdef mutablefst shortestpathfst ifst float delta int00 nshortest              $^                                 int00 nstate queuetype bool unique$^                                 weight$^ $^struct pyxoptargs0pywrapfstshortestpath $^  int pyxn$^  float delta$^  pyxt00basictypesint00 nshortest$^  pyxt00basictypesint00 nstate$^  pyobject queuetype$^  bool unique$^  pyobject weight$^$^$^ pywrapfst.pxd00$^  $^  $^  cdef class weightobject              $^  $^    cdef uniqueptrfst.weightclass weight$^ $^struct pyxobj0pywrapfstweight $^  pyobjecthead$^  struct pyxvtabstruct0pywrapfstweight pyxvtab$^  stduniqueptrfstscriptweightclass  weight$^$^$^$^ pywrapfst.pxd000$^  $^  $^  cdef class symboltableobject              $^  $^    cdef fst.symboltable table$^ $^struct pyxobj0pywrapfstsymboltable $^  pyobjecthead$^  struct pyxvtabstruct0pywrapfstsymboltable pyxvtab$^  fstsymboltable table$^$^$^$^ pywrapfst.pxd000$^  $^  $^  cdef class encodemappersymboltablesymboltable              $^  $^    cdef sharedptrfst.encodemapperclass encoder$^ $^struct pyxobj0pywrapfstencodemappersymboltable $^  struct pyxobj0pywrapfstsymboltable pyxbase$^  stdsharedptrfstscriptencodemapperclass  encoder$^$^$^$^ pywrapfst.pxd000$^  $^  $^  cdef class fstsymboltablesymboltable              $^  $^    cdef sharedptrfst.fstclass fst$^ $^struct pyxobj0pywrapfstfstsymboltable $^  struct pyxobj0pywrapfstsymboltable pyxbase$^  stdsharedptrfstscriptfstclass  fst$^$^$^$^ pywrapfst.pxd000$^  $^  $^  cdef class mutablesymboltablesymboltable              $^  $^    cpdef int00 addsymbolself symbol int00 key$^ $^struct pyxobj0pywrapfstmutablesymboltable $^  struct pyxobj0pywrapfstsymboltable pyxbase$^$^$^$^ pywrapfst.pxd000$^  $^  $^  cdef class mutablefstsymboltablemutablesymboltable              $^  $^    cdef sharedptrfst.mutablefstclass mfst$^ $^struct pyxobj0pywrapfstmutablefstsymboltable $^  struct pyxobj0pywrapfstmutablesymboltable pyxbase$^  stdsharedptrfstscriptmutablefstclass  mfst$^$^$^$^ pywrapfst.pxd000$^  $^  $^  cdef class symboltablemutablesymboltable              $^  $^    cdef uniqueptrfst.symboltable smarttable$^ $^struct pyxobj0pywrapfstsymboltable $^  struct pyxobj0pywrapfstmutablesymboltable pyxbase$^  stduniqueptrfstsymboltable  smarttable$^$^$^$^ pywrapfst.pxd000$^  $^  $^  cdef class symboltableiteratorobject              $^  $^    cdef sharedptrfst.symboltable table$^ $^struct pyxobj0pywrapfstsymboltableiterator $^  pyobjecthead$^  struct pyxvtabstruct0pywrapfstsymboltableiterator pyxvtab$^  stdsharedptrfstsymboltable  table$^  stduniqueptrfstsymboltableiterator  siter$^$^$^$^ pywrapfst.pxd000$^  $^  $^  cdef class encodemapperobject              $^  $^    cdef sharedptrfst.encodemapperclass encoder$^ $^struct pyxobj0pywrapfstencodemapper $^  pyobjecthead$^  struct pyxvtabstruct0pywrapfstencodemapper pyxvtab$^  stdsharedptrfstscriptencodemapperclass  encoder$^$^$^$^ pywrapfst.pxd000$^  $^  $^  cdef class fstobject              $^  $^    cdef sharedptrfst.fstclass fst$^ $^struct pyxobj0pywrapfstfst $^  pyobjecthead$^  struct pyxvtabstruct0pywrapfstfst pyxvtab$^  stdsharedptrfstscriptfstclass  fst$^$^$^$^ pywrapfst.pxd000$^  $^  $^  cdef class mutablefstfst              $^  $^    cdef sharedptrfst.mutablefstclass mfst$^ $^struct pyxobj0pywrapfstmutablefst $^  struct pyxobj0pywrapfstfst pyxbase$^  stdsharedptrfstscriptmutablefstclass  mfst$^$^$^$^ pywrapfst.pxd000$^  $^  $^  cdef class arcobject              $^  $^    cdef uniqueptrfst.arcclass arc$^ $^struct pyxobj0pywrapfstarc $^  pyobjecthead$^  struct pyxvtabstruct0pywrapfstarc pyxvtab$^  stduniqueptrfstscriptarcclass  arc$^$^$^$^ pywrapfst.pxd000$^  $^  $^  cdef class arciteratorobject              $^  $^    cdef sharedptrfst.fstclass fst$^ $^struct pyxobj0pywrapfstarciterator $^  pyobjecthead$^  struct pyxvtabstruct0pywrapfstarciterator pyxvtab$^  stdsharedptrfstscriptfstclass  fst$^  stduniqueptrfstscriptarciteratorclass  aiter$^$^$^$^ pywrapfst.pxd000$^  $^  $^  cdef class mutablearciteratorobject              $^  $^    cdef sharedptrfst.mutablefstclass mfst$^ $^struct pyxobj0pywrapfstmutablearciterator $^  pyobjecthead$^  struct pyxvtabstruct0pywrapfstmutablearciterator pyxvtab$^  stdsharedptrfstscriptmutablefstclass  mfst$^  stduniqueptrfstscriptmutablearciteratorclass  aiter$^$^$^$^ pywrapfst.pxd000$^  $^  $^  cdef class stateiteratorobject              $^  $^    cdef sharedptrfst.fstclass fst$^ $^struct pyxobj0pywrapfststateiterator $^  pyobjecthead$^  struct pyxvtabstruct0pywrapfststateiterator pyxvtab$^  stdsharedptrfstscriptfstclass  fst$^  stduniqueptrfstscriptstateiteratorclass  siter$^$^$^$^ pywrapfst.pxd000$^  $^  $^  cdef class compilerobject              $^  $^    cdef uniqueptrstringstream sstrm$^ $^struct pyxobj0pywrapfstcompiler $^  pyobjecthead$^  struct pyxvtabstruct0pywrapfstcompiler pyxvtab$^  stduniqueptrstdstringstream  sstrm$^  stdstring fsttype$^  stdstring arctype$^  fstsymboltable const isymbols$^  fstsymboltable const osymbols$^  fstsymboltable const ssymbols$^  bool acceptor$^  bool keepisymbols$^  bool keeposymbols$^  bool keepstatenumbering$^  bool allownegativelabels$^$^$^$^ pywrapfst.pxd000$^   farreader.$^  $^  cdef class farreaderobject              $^  $^    cdef uniqueptrfst.farreaderclass reader$^ $^struct pyxobj0pywrapfstfarreader $^  pyobjecthead$^  struct pyxvtabstruct0pywrapfstfarreader pyxvtab$^  stduniqueptrfstscriptfarreaderclass  reader$^$^$^$^ pywrapfst.pxd000$^   farwriter.$^  $^  cdef class farwriterobject              $^  $^    cdef uniqueptrfst.farwriterclass writer$^ $^struct pyxobj0pywrapfstfarwriter $^  pyobjecthead$^  struct pyxvtabstruct0pywrapfstfarwriter pyxvtab$^  stduniqueptrfstscriptfarwriterclass  writer$^$^$^$^$^ pywrapfst.pyx000$^  $^  $^  cdef class weightobject              $^  $^    $^ $^$^struct pyxvtabstruct0pywrapfstweight $^  void checkweightstruct pyxobj0pywrapfstweight $^  struct pyxobj0pywrapfstweight copystruct pyxobj0pywrapfstweight  int pyxskipdispatch$^  stdstring tostringstruct pyxobj0pywrapfstweight  int pyxskipdispatch$^  stdstring typestruct pyxobj0pywrapfstweight  int pyxskipdispatch$^$^static struct pyxvtabstruct0pywrapfstweight pyxvtabptr0pywrapfstweight$^$^$^ pywrapfst.pyx000$^  $^  $^  cdef class symboltableobject              $^  $^    $^ $^$^struct pyxvtabstruct0pywrapfstsymboltable $^  pyxt00basictypesint00 availablekeystruct pyxobj0pywrapfstsymboltable  int pyxskipdispatch$^  stdstring checksumstruct pyxobj0pywrapfstsymboltable  int pyxskipdispatch$^  struct pyxobj0pywrapfstsymboltable copystruct pyxobj0pywrapfstsymboltable  int pyxskipdispatch$^  pyxt00basictypesint00 getnthkeystruct pyxobj0pywrapfstsymboltable  pyssizet int pyxskipdispatch$^  stdstring labeledchecksumstruct pyxobj0pywrapfstsymboltable  int pyxskipdispatch$^  bool memberstruct pyxobj0pywrapfstsymboltable  pyobject  int pyxskipdispatch$^  stdstring namestruct pyxobj0pywrapfstsymboltable  int pyxskipdispatch$^  sizet numsymbolsstruct pyxobj0pywrapfstsymboltable  int pyxskipdispatch$^  void writestruct pyxobj0pywrapfstsymboltable  pyobject  int pyxskipdispatch$^  void writetextstruct pyxobj0pywrapfstsymboltable  pyobject  int pyxskipdispatch$^$^static struct pyxvtabstruct0pywrapfstsymboltable pyxvtabptr0pywrapfstsymboltable$^$^$^ pywrapfst.pyx000$^  $^  $^  cdef class encodemappersymboltablesymboltable              $^  $^    $^ $^$^struct pyxvtabstruct0pywrapfstencodemappersymboltable $^  struct pyxvtabstruct0pywrapfstsymboltable pyxbase$^$^static struct pyxvtabstruct0pywrapfstencodemappersymboltable pyxvtabptr0pywrapfstencodemappersymboltable$^$^$^ pywrapfst.pyx000$^  $^  $^  cdef class fstsymboltablesymboltable              $^  $^    $^ $^$^struct pyxvtabstruct0pywrapfstfstsymboltable $^  struct pyxvtabstruct0pywrapfstsymboltable pyxbase$^$^static struct pyxvtabstruct0pywrapfstfstsymboltable pyxvtabptr0pywrapfstfstsymboltable$^$^$^ pywrapfst.pyx000$^  $^  $^  cdef class mutablesymboltablesymboltable              $^  $^    $^ $^$^struct pyxvtabstruct0pywrapfstmutablesymboltable $^  struct pyxvtabstruct0pywrapfstsymboltable pyxbase$^  pyxt00basictypesint00 addsymbolstruct pyxobj0pywrapfstmutablesymboltable  pyobject  int pyxskipdispatch struct pyxoptargs0pywrapfst00mutablesymboltableaddsymbol pyxoptionalargs$^  void addtablestruct pyxobj0pywrapfstmutablesymboltable  struct pyxobj0pywrapfstsymboltable  int pyxskipdispatch$^  void setnamestruct pyxobj0pywrapfstmutablesymboltable  pyobject  int pyxskipdispatch$^$^static struct pyxvtabstruct0pywrapfstmutablesymboltable pyxvtabptr0pywrapfstmutablesymboltable$^$^$^ pywrapfst.pyx000$^  $^  $^  cdef class mutablefstsymboltablemutablesymboltable              $^    $^    no constructor.$^ $^$^struct pyxvtabstruct0pywrapfstmutablefstsymboltable $^  struct pyxvtabstruct0pywrapfstmutablesymboltable pyxbase$^$^static struct pyxvtabstruct0pywrapfstmutablefstsymboltable pyxvtabptr0pywrapfstmutablefstsymboltable$^$^$^ pywrapfst.pyx000$^  $^  $^  cdef class symboltablemutablesymboltable              $^  $^    $^ $^$^struct pyxvtabstruct0pywrapfstsymboltable $^  struct pyxvtabstruct0pywrapfstmutablesymboltable pyxbase$^$^static struct pyxvtabstruct0pywrapfstsymboltable pyxvtabptr0pywrapfstsymboltable$^$^$^ pywrapfst.pyx0000$^  $^  $^  cdef class symboltableiteratorobject              $^  $^    $^ $^$^struct pyxvtabstruct0pywrapfstsymboltableiterator $^  bool donestruct pyxobj0pywrapfstsymboltableiterator  int pyxskipdispatch$^  void nextstruct pyxobj0pywrapfstsymboltableiterator  int pyxskipdispatch$^  void resetstruct pyxobj0pywrapfstsymboltableiterator  int pyxskipdispatch$^  stdstring symbolstruct pyxobj0pywrapfstsymboltableiterator  int pyxskipdispatch$^  pyxt00basictypesint00 valuestruct pyxobj0pywrapfstsymboltableiterator  int pyxskipdispatch$^$^static struct pyxvtabstruct0pywrapfstsymboltableiterator pyxvtabptr0pywrapfstsymboltableiterator$^$^$^ pywrapfst.pyx0000$^  $^  $^  cdef class encodemapperobject              $^  $^    $^ $^$^struct pyxvtabstruct0pywrapfstencodemapper $^  stdstring arctypestruct pyxobj0pywrapfstencodemapper  int pyxskipdispatch$^  pyxt00basictypesuint00 flagsstruct pyxobj0pywrapfstencodemapper  int pyxskipdispatch$^  struct pyxobj0pywrapfstencodemappersymboltable inputsymbolsstruct pyxobj0pywrapfstencodemapper  int pyxskipdispatch$^  struct pyxobj0pywrapfstencodemappersymboltable outputsymbolsstruct pyxobj0pywrapfstencodemapper  int pyxskipdispatch$^  pyxt00basictypesuint00 propertiesstruct pyxobj0pywrapfstencodemapper  pyxt00basictypesuint00 int pyxskipdispatch$^  void setinputsymbolsstruct pyxobj0pywrapfstencodemapper  struct pyxobj0pywrapfstsymboltable  int pyxskipdispatch$^  void setoutputsymbolsstruct pyxobj0pywrapfstencodemapper  struct pyxobj0pywrapfstsymboltable  int pyxskipdispatch$^  stdstring weighttypestruct pyxobj0pywrapfstencodemapper  int pyxskipdispatch$^$^static struct pyxvtabstruct0pywrapfstencodemapper pyxvtabptr0pywrapfstencodemapper$^$^$^ pywrapfst.pyx0000$^  $^  $^  cdef class fstobject              $^  $^    $^ $^$^struct pyxvtabstruct0pywrapfstfst $^  stdstring arctypestruct pyxobj0pywrapfstfst  int pyxskipdispatch$^  struct pyxobj0pywrapfstarciterator arcsstruct pyxobj0pywrapfstfst  pyxt00basictypesint00 int pyxskipdispatch$^  struct pyxobj0pywrapfstfst copystruct pyxobj0pywrapfstfst  int pyxskipdispatch$^  void drawstruct pyxobj0pywrapfstfst  pyobject  int pyxskipdispatch struct pyxoptargs0pywrapfst0fstdraw pyxoptionalargs$^  struct pyxobj0pywrapfstweight finalstruct pyxobj0pywrapfstfst  pyxt00basictypesint00 int pyxskipdispatch$^  stdstring fsttypestruct pyxobj0pywrapfstfst  int pyxskipdispatch$^  struct pyxobj0pywrapfstfstsymboltable inputsymbolsstruct pyxobj0pywrapfstfst  int pyxskipdispatch$^  sizet numarcsstruct pyxobj0pywrapfstfst  pyxt00basictypesint00 int pyxskipdispatch$^  sizet numinputepsilonsstruct pyxobj0pywrapfstfst  pyxt00basictypesint00 int pyxskipdispatch$^  sizet numoutputepsilonsstruct pyxobj0pywrapfstfst  pyxt00basictypesint00 int pyxskipdispatch$^  struct pyxobj0pywrapfstfstsymboltable outputsymbolsstruct pyxobj0pywrapfstfst  int pyxskipdispatch$^  pyxt00basictypesuint00 propertiesstruct pyxobj0pywrapfstfst  pyxt00basictypesuint00 bool int pyxskipdispatch$^  pyxt00basictypesint00 startstruct pyxobj0pywrapfstfst  int pyxskipdispatch$^  struct pyxobj0pywrapfststateiterator statesstruct pyxobj0pywrapfstfst  int pyxskipdispatch$^  stdstring textstruct pyxobj0pywrapfstfst  int pyxskipdispatch struct pyxoptargs0pywrapfst0fsttext pyxoptionalargs$^  bool verifystruct pyxobj0pywrapfstfst  int pyxskipdispatch$^  stdstring weighttypestruct pyxobj0pywrapfstfst  int pyxskipdispatch$^  void writestruct pyxobj0pywrapfstfst  pyobject  int pyxskipdispatch$^  stdstring writetostringstruct pyxobj0pywrapfstfst  int pyxskipdispatch$^$^static struct pyxvtabstruct0pywrapfstfst pyxvtabptr0pywrapfstfst$^$^$^ pywrapfst.pyx0000$^  $^  $^  cdef class mutablefstfst              $^  $^    $^ $^$^struct pyxvtabstruct0pywrapfstmutablefst $^  struct pyxvtabstruct0pywrapfstfst pyxbase$^  void checkmutatingimethodstruct pyxobj0pywrapfstmutablefst $^  void addarcstruct pyxobj0pywrapfstmutablefst  pyxt00basictypesint00 struct pyxobj0pywrapfstarc $^  pyxt00basictypesint00 addstatestruct pyxobj0pywrapfstmutablefst  int pyxskipdispatch$^  void arcsortstruct pyxobj0pywrapfstmutablefst  struct pyxoptargs0pywrapfst00mutablefstarcsort pyxoptionalargs$^  void closurestruct pyxobj0pywrapfstmutablefst  struct pyxoptargs0pywrapfst00mutablefstclosure pyxoptionalargs$^  void concatstruct pyxobj0pywrapfstmutablefst  struct pyxobj0pywrapfstfst $^  void connectstruct pyxobj0pywrapfstmutablefst $^  void decodestruct pyxobj0pywrapfstmutablefst  struct pyxobj0pywrapfstencodemapper $^  void deletearcsstruct pyxobj0pywrapfstmutablefst  pyxt00basictypesint00 struct pyxoptargs0pywrapfst00mutablefstdeletearcs pyxoptionalargs$^  void deletestatesstruct pyxobj0pywrapfstmutablefst  struct pyxoptargs0pywrapfst00mutablefstdeletestates pyxoptionalargs$^  void encodestruct pyxobj0pywrapfstmutablefst  struct pyxobj0pywrapfstencodemapper $^  void invertstruct pyxobj0pywrapfstmutablefst $^  void minimizestruct pyxobj0pywrapfstmutablefst  struct pyxoptargs0pywrapfst00mutablefstminimize pyxoptionalargs$^  struct pyxobj0pywrapfstmutablearciterator mutablearcsstruct pyxobj0pywrapfstmutablefst  pyxt00basictypesint00 int pyxskipdispatch$^  pyxt00basictypesint00 numstatesstruct pyxobj0pywrapfstmutablefst  int pyxskipdispatch$^  void projectstruct pyxobj0pywrapfstmutablefst  struct pyxoptargs0pywrapfst00mutablefstproject pyxoptionalargs$^  void prunestruct pyxobj0pywrapfstmutablefst  struct pyxoptargs0pywrapfst00mutablefstprune pyxoptionalargs$^  void pushstruct pyxobj0pywrapfstmutablefst  struct pyxoptargs0pywrapfst00mutablefstpush pyxoptionalargs$^  void relabelpairsstruct pyxobj0pywrapfstmutablefst  struct pyxoptargs0pywrapfst00mutablefstrelabelpairs pyxoptionalargs$^  void relabeltablesstruct pyxobj0pywrapfstmutablefst  struct pyxoptargs0pywrapfst00mutablefstrelabeltables pyxoptionalargs$^  void reservearcsstruct pyxobj0pywrapfstmutablefst  pyxt00basictypesint00 sizet$^  void reservestatesstruct pyxobj0pywrapfstmutablefst  pyxt00basictypesint00$^  void reweightstruct pyxobj0pywrapfstmutablefst  pyobject  struct pyxoptargs0pywrapfst00mutablefstreweight pyxoptionalargs$^  void rmepsilonstruct pyxobj0pywrapfstmutablefst  struct pyxoptargs0pywrapfst00mutablefstrmepsilon pyxoptionalargs$^  void setfinalstruct pyxobj0pywrapfstmutablefst  pyxt00basictypesint00 struct pyxoptargs0pywrapfst00mutablefstsetfinal pyxoptionalargs$^  void setpropertiesstruct pyxobj0pywrapfstmutablefst  pyxt00basictypesuint00 pyxt00basictypesuint00$^  void setstartstruct pyxobj0pywrapfstmutablefst  pyxt00basictypesint00$^  void setinputsymbolsstruct pyxobj0pywrapfstmutablefst  struct pyxobj0pywrapfstsymboltable $^  void setoutputsymbolsstruct pyxobj0pywrapfstmutablefst  struct pyxobj0pywrapfstsymboltable $^  void topsortstruct pyxobj0pywrapfstmutablefst $^  void unionstruct pyxobj0pywrapfstmutablefst  struct pyxobj0pywrapfstfst $^$^static struct pyxvtabstruct0pywrapfstmutablefst pyxvtabptr0pywrapfstmutablefst$^$^$^ pywrapfst.pyx0000$^  $^  $^  cdef class arcobject              $^  $^    $^ $^$^struct pyxvtabstruct0pywrapfstarc $^  struct pyxobj0pywrapfstarc copystruct pyxobj0pywrapfstarc  int pyxskipdispatch$^$^static struct pyxvtabstruct0pywrapfstarc pyxvtabptr0pywrapfstarc$^$^$^ pywrapfst.pyx0000$^  $^  $^  cdef class arciteratorobject              $^  $^    $^ $^$^struct pyxvtabstruct0pywrapfstarciterator $^  bool donestruct pyxobj0pywrapfstarciterator  int pyxskipdispatch$^  pyxt00basictypesuint00 flagsstruct pyxobj0pywrapfstarciterator  int pyxskipdispatch$^  void nextstruct pyxobj0pywrapfstarciterator  int pyxskipdispatch$^  sizet positionstruct pyxobj0pywrapfstarciterator  int pyxskipdispatch$^  void resetstruct pyxobj0pywrapfstarciterator  int pyxskipdispatch$^  void seekstruct pyxobj0pywrapfstarciterator  sizet int pyxskipdispatch$^  void setflagsstruct pyxobj0pywrapfstarciterator  pyxt00basictypesuint00 pyxt00basictypesuint00 int pyxskipdispatch$^  pyobject valuestruct pyxobj0pywrapfstarciterator  int pyxskipdispatch$^$^static struct pyxvtabstruct0pywrapfstarciterator pyxvtabptr0pywrapfstarciterator$^$^$^ pywrapfst.pyx0000$^  $^  $^  cdef class mutablearciteratorobject              $^  $^    $^ $^$^struct pyxvtabstruct0pywrapfstmutablearciterator $^  bool donestruct pyxobj0pywrapfstmutablearciterator  int pyxskipdispatch$^  pyxt00basictypesuint00 flagsstruct pyxobj0pywrapfstmutablearciterator  int pyxskipdispatch$^  void nextstruct pyxobj0pywrapfstmutablearciterator  int pyxskipdispatch$^  sizet positionstruct pyxobj0pywrapfstmutablearciterator  int pyxskipdispatch$^  void resetstruct pyxobj0pywrapfstmutablearciterator  int pyxskipdispatch$^  void seekstruct pyxobj0pywrapfstmutablearciterator  sizet int pyxskipdispatch$^  void setflagsstruct pyxobj0pywrapfstmutablearciterator  pyxt00basictypesuint00 pyxt00basictypesuint00 int pyxskipdispatch$^  void setvaluestruct pyxobj0pywrapfstmutablearciterator  struct pyxobj0pywrapfstarc  int pyxskipdispatch$^  pyobject valuestruct pyxobj0pywrapfstmutablearciterator  int pyxskipdispatch$^$^static struct pyxvtabstruct0pywrapfstmutablearciterator pyxvtabptr0pywrapfstmutablearciterator$^$^$^ pywrapfst.pyx0000$^  $^  $^  cdef class stateiteratorobject              $^  $^    $^ $^$^struct pyxvtabstruct0pywrapfststateiterator $^  bool donestruct pyxobj0pywrapfststateiterator  int pyxskipdispatch$^  void nextstruct pyxobj0pywrapfststateiterator  int pyxskipdispatch$^  void resetstruct pyxobj0pywrapfststateiterator  int pyxskipdispatch$^  pyxt00basictypesint00 valuestruct pyxobj0pywrapfststateiterator  int pyxskipdispatch$^$^static struct pyxvtabstruct0pywrapfststateiterator pyxvtabptr0pywrapfststateiterator$^$^$^ pywrapfst.pyx0000$^  $^  $^  cdef class compilerobject              $^  $^    $^ $^$^struct pyxvtabstruct0pywrapfstcompiler $^  struct pyxobj0pywrapfstfst compilestruct pyxobj0pywrapfstcompiler  int pyxskipdispatch$^  void writestruct pyxobj0pywrapfstcompiler  pyobject  int pyxskipdispatch$^$^static struct pyxvtabstruct0pywrapfstcompiler pyxvtabptr0pywrapfstcompiler$^$^$^ pywrapfst.pyx0000$^  $^  $^  cdef class farreaderobject              $^  $^    $^ $^$^struct pyxvtabstruct0pywrapfstfarreader $^  stdstring arctypestruct pyxobj0pywrapfstfarreader  int pyxskipdispatch$^  bool donestruct pyxobj0pywrapfstfarreader  int pyxskipdispatch$^  bool errorstruct pyxobj0pywrapfstfarreader  int pyxskipdispatch$^  stdstring fartypestruct pyxobj0pywrapfstfarreader  int pyxskipdispatch$^  bool findstruct pyxobj0pywrapfstfarreader  pyobject  int pyxskipdispatch$^  struct pyxobj0pywrapfstfst getfststruct pyxobj0pywrapfstfarreader  int pyxskipdispatch$^  stdstring getkeystruct pyxobj0pywrapfstfarreader  int pyxskipdispatch$^  void nextstruct pyxobj0pywrapfstfarreader  int pyxskipdispatch$^  void resetstruct pyxobj0pywrapfstfarreader  int pyxskipdispatch$^$^static struct pyxvtabstruct0pywrapfstfarreader pyxvtabptr0pywrapfstfarreader$^$^$^ pywrapfst.pyx0000$^  $^  $^  cdef class farwriterobject              $^  $^    $^ $^$^struct pyxvtabstruct0pywrapfstfarwriter $^  stdstring arctypestruct pyxobj0pywrapfstfarwriter  int pyxskipdispatch$^  void closestruct pyxobj0pywrapfstfarwriter $^  void addstruct pyxobj0pywrapfstfarwriter  pyobject  struct pyxobj0pywrapfstfst  int pyxskipdispatch$^  bool errorstruct pyxobj0pywrapfstfarwriter  int pyxskipdispatch$^  stdstring fartypestruct pyxobj0pywrapfstfarwriter  int pyxskipdispatch$^$^static struct pyxvtabstruct0pywrapfstfarwriter pyxvtabptr0pywrapfstfarwriter$^$^  runtime support code head  $^ refnanny.proto $^ifndef cythonrefnanny$^  define cythonrefnanny 0$^endif$^if cythonrefnanny$^  typedef struct $^    void increfvoid pyobject int$^    void decrefvoid pyobject int$^    void gotrefvoid pyobject int$^    void giverefvoid pyobject int$^    void setupcontextconst char int const char$^    void finishcontextvoid$^   pyxrefnannyapistruct$^  static pyxrefnannyapistruct pyxrefnanny  null$^  static pyxrefnannyapistruct pyxrefnannyimportapiconst char modname$^  define pyxrefnannydeclarations void pyxrefnanny  null$^ifdef withthread$^  define pyxrefnannysetupcontextname acquiregil$^          if acquiregil $^              pygilstatestate pyxgilstatesave  pygilstateensure$^              pyxrefnanny  pyxrefnannysetupcontextname line file$^              pygilstatereleasepyxgilstatesave$^           else $^              pyxrefnanny  pyxrefnannysetupcontextname line file$^          $^else$^  define pyxrefnannysetupcontextname acquiregil$^          pyxrefnanny  pyxrefnannysetupcontextname line file$^endif$^  define pyxrefnannyfinishcontext$^          pyxrefnannyfinishcontextpyxrefnanny$^  define pyxincrefr  pyxrefnannyincrefpyxrefnanny pyobject r line$^  define pyxdecrefr  pyxrefnannydecrefpyxrefnanny pyobject r line$^  define pyxgotrefr  pyxrefnannygotrefpyxrefnanny pyobject r line$^  define pyxgiverefr pyxrefnannygiverefpyxrefnanny pyobject r line$^  define pyxxincrefr  do  ifr  null pyxincrefr  while0$^  define pyxxdecrefr  do  ifr  null pyxdecrefr  while0$^  define pyxxgotrefr  do  ifr  null pyxgotrefr  while0$^  define pyxxgiverefr do  ifr  null pyxgiverefr while0$^else$^  define pyxrefnannydeclarations$^  define pyxrefnannysetupcontextname acquiregil$^  define pyxrefnannyfinishcontext$^  define pyxincrefr pyincrefr$^  define pyxdecrefr pydecrefr$^  define pyxgotrefr$^  define pyxgiverefr$^  define pyxxincrefr pyxincrefr$^  define pyxxdecrefr pyxdecrefr$^  define pyxxgotrefr$^  define pyxxgiverefr$^endif$^define pyxxdecrefsetr v do $^        pyobject tmp  pyobject  r$^        r  v pyxxdecreftmp$^     while 0$^define pyxdecrefsetr v do $^        pyobject tmp  pyobject  r$^        r  v pyxdecreftmp$^     while 0$^define pyxclearr    do  pyobject tmp  pyobjectr r  null pyxdecreftmp while0$^define pyxxclearr   do  ifr  null pyobject tmp  pyobjectr r  null pyxdecreftmp while0$^$^ pyobjectgetattrstr.proto $^if cythonusetypeslots$^static cythoninline pyobject pyxpyobjectgetattrstrpyobject obj pyobject attrname $^    pytypeobject tp  pytypeobj$^    if likelytptpgetattro$^        return tptpgetattroobj attrname$^if pymajorversion  0$^    if likelytptpgetattr$^        return tptpgetattrobj pystringasstringattrname$^endif$^    return pyobjectgetattrobj attrname$^$^else$^define pyxpyobjectgetattrstron pyobjectgetattron$^endif$^$^ getbuiltinname.proto $^static pyobject pyxgetbuiltinnamepyobject name$^$^ pycfunctionfastcall.proto $^if cythonfastpyccall$^static cythoninline pyobject pyxpycfunctionfastcallpyobject func pyobject args pyssizet nargs$^else$^define pyxpycfunctionfastcallfunc args nargs  assert0 null$^endif$^$^ pyfunctionfastcall.proto $^if cythonfastpycall$^define pyxpyfunctionfastcallfunc args nargs$^    pyxpyfunctionfastcalldictfunc args nargs null$^if 0  pyversionhex  0x000000b0$^static pyobject pyxpyfunctionfastcalldictpyobject func pyobject args int nargs pyobject kwargs$^else$^define pyxpyfunctionfastcalldictfunc args nargs kwargs pyfunctionfastcalldictfunc args nargs kwargs$^endif$^endif$^$^ pyobjectcall.proto $^if cythoncompilingincpython$^static cythoninline pyobject pyxpyobjectcallpyobject func pyobject arg pyobject kw$^else$^define pyxpyobjectcallfunc arg kw pyobjectcallfunc arg kw$^endif$^$^ pyobjectcallmetho.proto $^if cythoncompilingincpython$^static cythoninline pyobject pyxpyobjectcallmethopyobject func pyobject arg$^endif$^$^ pyobjectcallonearg.proto $^static cythoninline pyobject pyxpyobjectcalloneargpyobject func pyobject arg$^$^ getmoduleglobalname.proto $^static cythoninline pyobject pyxgetmoduleglobalnamepyobject name$^$^ pythreadstateget.proto $^if cythonfastthreadstate$^define pyxpythreadstatedeclare  pythreadstate pyxtstate$^define pyxpythreadstateassign  pyxtstate  pyxpythreadstatecurrent$^define pyxpyerroccurred  pyxtstatecurexctype$^else$^define pyxpythreadstatedeclare$^define pyxpythreadstateassign$^define pyxpyerroccurred  pyerroccurred$^endif$^$^ pyerrfetchrestore.proto $^if cythonfastthreadstate$^define pyxpyerrclear pyxerrrestorenull null null$^define pyxerrrestorewithstatetype value tb  pyxerrrestoreinstatepythreadstateget type value tb$^define pyxerrfetchwithstatetype value tb    pyxerrfetchinstatepythreadstateget type value tb$^define pyxerrrestoretype value tb  pyxerrrestoreinstatepyxtstate type value tb$^define pyxerrfetchtype value tb    pyxerrfetchinstatepyxtstate type value tb$^static cythoninline void pyxerrrestoreinstatepythreadstate tstate pyobject type pyobject value pyobject tb$^static cythoninline void pyxerrfetchinstatepythreadstate tstate pyobject type pyobject value pyobject tb$^if cythoncompilingincpython$^define pyxpyerrsetnoneexc pyincrefexc pyxerrrestoreexc null null$^else$^define pyxpyerrsetnoneexc pyerrsetnoneexc$^endif$^else$^define pyxpyerrclear pyerrclear$^define pyxpyerrsetnoneexc pyerrsetnoneexc$^define pyxerrrestorewithstatetype value tb  pyerrrestoretype value tb$^define pyxerrfetchwithstatetype value tb  pyerrfetchtype value tb$^define pyxerrrestoreinstatetstate type value tb  pyerrrestoretype value tb$^define pyxerrfetchinstatetstate type value tb  pyerrfetchtype value tb$^define pyxerrrestoretype value tb  pyerrrestoretype value tb$^define pyxerrfetchtype value tb  pyerrfetchtype value tb$^endif$^$^ raiseexception.proto $^static void pyxraisepyobject type pyobject value pyobject tb pyobject cause$^$^ raiseargtupleinvalid.proto $^static void pyxraiseargtupleinvalidconst char funcname int exact$^    pyssizet nummin pyssizet nummax pyssizet numfound$^$^ raisedoublekeywords.proto $^static void pyxraisedoublekeywordserrorconst char funcname pyobject kwname$^$^ parsekeywords.proto $^static int pyxparseoptionalkeywordspyobject kwds pyobject argnames$^    pyobject kwds0 pyobject values pyssizet numposargs$^    const char functionname$^$^ pyobjectcallnoarg.proto $^if cythoncompilingincpython$^static cythoninline pyobject pyxpyobjectcallnoargpyobject func$^else$^define pyxpyobjectcallnoargfunc pyxpyobjectcallfunc pyxemptytuple null$^endif$^$^ exttypetest.proto $^static cythoninline int pyxtypetestpyobject obj pytypeobject type$^$^ argtypetest.proto $^define pyxargtypetestobj type noneallowed name exact$^    likelypytypeobj  type  noneallowed  obj  pynone  0 $^        pyxargtypetestobj type name exact$^static int pyxargtypetestpyobject obj pytypeobject type const char name int exact$^$^ writeunraisableexception.proto $^static void pyxwriteunraisableconst char name int clineno$^                                  int lineno const char filename$^                                  int fulltraceback int nogil$^$^ keywordstringcheck.proto $^static int pyxcheckkeywordstringspyobject kwdict const char functionname int kwallowed$^$^ saveresetexception.proto $^if cythonfastthreadstate$^define pyxexceptionsavetype value tb  pyxexceptionsavepyxtstate type value tb$^static cythoninline void pyxexceptionsavepythreadstate tstate pyobject type pyobject value pyobject tb$^define pyxexceptionresettype value tb  pyxexceptionresetpyxtstate type value tb$^static cythoninline void pyxexceptionresetpythreadstate tstate pyobject type pyobject value pyobject tb$^else$^define pyxexceptionsavetype value tb   pyerrgetexcinfotype value tb$^define pyxexceptionresettype value tb  pyerrsetexcinfotype value tb$^endif$^$^ pyerrexceptionmatches.proto $^if cythonfastthreadstate$^define pyxpyerrexceptionmatcheserr pyxpyerrexceptionmatchesinstatepyxtstate err$^static cythoninline int pyxpyerrexceptionmatchesinstatepythreadstate tstate pyobject err$^else$^define pyxpyerrexceptionmatcheserr  pyerrexceptionmatcheserr$^endif$^$^ getexception.proto $^if cythonfastthreadstate$^define pyxgetexceptiontype value tb  pyxgetexceptionpyxtstate type value tb$^static int pyxgetexceptionpythreadstate tstate pyobject type pyobject value pyobject tb$^else$^static int pyxgetexceptionpyobject type pyobject value pyobject tb$^endif$^$^ raisetoomanyvaluestounpack.proto $^static cythoninline void pyxraisetoomanyvalueserrorpyssizet expected$^$^ raiseneedmorevaluestounpack.proto $^static cythoninline void pyxraiseneedmorevalueserrorpyssizet index$^$^ iterfinish.proto $^static cythoninline int pyxiterfinishvoid$^$^ unpackitemendcheck.proto $^static int pyxiternextunpackendcheckpyobject retval pyssizet expected$^$^ iternext.proto $^define pyxpyiternextobj pyxpyiternext0obj null$^static cythoninline pyobject pyxpyiternext0pyobject  pyobject $^$^ listcompappend.proto $^if cythonusepylistinternals  cythonassumesafemacros$^static cythoninline int pyxlistcompappendpyobject list pyobject x $^    pylistobject l  pylistobject list$^    pyssizet len  pysizelist$^    if likelylallocated  len $^        pyincrefx$^        pylistsetitemlist len x$^        pysizelist  len0$^        return 0$^    $^    return pylistappendlist x$^$^else$^define pyxlistcompappendlx pylistappendlx$^endif$^$^ setvtable.proto $^static int pyxsetvtablepyobject dict void vtable$^$^ setupreduce.proto $^static int pyxsetupreducepyobject typeobj$^$^ import.proto $^static pyobject pyximportpyobject name pyobject fromlist int level$^$^ calculatemetaclass.proto $^static pyobject pyxcalculatemetaclasspytypeobject metaclass pyobject bases$^$^ py0classcreate.proto $^static pyobject pyxpy0metaclasspreparepyobject metaclass pyobject bases pyobject name pyobject qualname$^                                           pyobject mkw pyobject modname pyobject doc$^static pyobject pyxpy0classcreatepyobject metaclass pyobject name pyobject bases pyobject dict$^                                      pyobject mkw int calculatemetaclass int allowpy0metaclass$^$^ getnameinclass.proto $^static pyobject pyxgetnameinclasspyobject nmspace pyobject name$^$^ classmethod.proto $^include descrobject.h$^static pyobject pyxmethodclassmethodpyobject method$^$^ fetchcommontype.proto $^static pytypeobject pyxfetchcommontypepytypeobject type$^$^ cythonfunction.proto $^define pyxcyfunctionused 0$^include structmember.h$^define pyxcyfunctionstaticmethod  0x00$^define pyxcyfunctionclassmethod   0x00$^define pyxcyfunctioncclass        0x00$^define pyxcyfunctiongetclosuref$^    pyxcyfunctionobject  ffuncclosure$^define pyxcyfunctiongetclassobjf$^    pyxcyfunctionobject  ffuncclassobj$^define pyxcyfunctiondefaultstype f$^    type pyxcyfunctionobject  fdefaults$^define pyxcyfunctionsetdefaultsgetterf g$^    pyxcyfunctionobject  fdefaultsgetter  g$^typedef struct $^    pycfunctionobject func$^if pyversionhex  0x000000a0$^    pyobject funcweakreflist$^endif$^    pyobject funcdict$^    pyobject funcname$^    pyobject funcqualname$^    pyobject funcdoc$^    pyobject funcglobals$^    pyobject funccode$^    pyobject funcclosure$^    pyobject funcclassobj$^    void defaults$^    int defaultspyobjects$^    int flags$^    pyobject defaultstuple$^    pyobject defaultskwdict$^    pyobject defaultsgetterpyobject $^    pyobject funcannotations$^ pyxcyfunctionobject$^static pytypeobject pyxcyfunctiontype  0$^define pyxcyfunctionnewexml flags qualname self module globals code$^    pyxcyfunctionnewpyxcyfunctiontype ml flags qualname self module globals code$^static pyobject pyxcyfunctionnewpytypeobject  pymethoddef ml$^                                      int flags pyobject qualname$^                                      pyobject self$^                                      pyobject module pyobject globals$^                                      pyobject code$^static cythoninline void pyxcyfunctioninitdefaultspyobject m$^                                                         sizet size$^                                                         int pyobjects$^static cythoninline void pyxcyfunctionsetdefaultstuplepyobject m$^                                                            pyobject tuple$^static cythoninline void pyxcyfunctionsetdefaultskwdictpyobject m$^                                                             pyobject dict$^static cythoninline void pyxcyfunctionsetannotationsdictpyobject m$^                                                              pyobject dict$^static int pyxcyfunctioninitvoid$^$^ clineintraceback.proto $^ifdef cythonclineintraceback$^define pyxclinefortracebacktstate cline  cythonclineintraceback  cline  0$^else$^static int pyxclinefortracebackpythreadstate tstate int cline$^endif$^$^ codeobjectcache.proto $^typedef struct $^    pycodeobject codeobject$^    int codeline$^ pyxcodeobjectcacheentry$^struct pyxcodeobjectcache $^    int count$^    int maxcount$^    pyxcodeobjectcacheentry entries$^$^static struct pyxcodeobjectcache pyxcodecache  00null$^static int pyxbisectcodeobjectspyxcodeobjectcacheentry entries int count int codeline$^static pycodeobject pyxfindcodeobjectint codeline$^static void pyxinsertcodeobjectint codeline pycodeobject codeobject$^$^ addtraceback.proto $^static void pyxaddtracebackconst char funcname int cline$^                               int pyline const char filename$^$^ none.proto $^include new$^$^ cinttopy.proto $^static cythoninline pyobject pyxpyintfromintint value$^$^ cinttopy.proto $^static cythoninline pyobject pyxpyintfromuint00tuint00t value$^$^ cinttopy.proto $^static cythoninline pyobject pyxpyintfromuint00tuint00t value$^$^ cinttopy.proto $^static cythoninline pyobject pyxpyintfromint00tint00t value$^$^ cinttopy.proto $^static cythoninline pyobject pyxpyintfromint00tint00t value$^$^ cppexceptionconversion.proto $^ifndef pyxcppexn0pyerr$^include new$^include typeinfo$^include stdexcept$^include ios$^static void pyxcppexn0pyerr $^  try $^    if pyerroccurred$^        let the latest python exn pass through and ignore the current one$^    else$^      throw$^   catch const stdbadalloc exn $^    pyerrsetstringpyexcmemoryerror exn.what$^   catch const stdbadcast exn $^    pyerrsetstringpyexctypeerror exn.what$^   catch const stdbadtypeid exn $^    pyerrsetstringpyexctypeerror exn.what$^   catch const stddomainerror exn $^    pyerrsetstringpyexcvalueerror exn.what$^   catch const stdinvalidargument exn $^    pyerrsetstringpyexcvalueerror exn.what$^   catch const stdiosbasefailure exn $^    pyerrsetstringpyexcioerror exn.what$^   catch const stdoutofrange exn $^    pyerrsetstringpyexcindexerror exn.what$^   catch const stdoverflowerror exn $^    pyerrsetstringpyexcoverflowerror exn.what$^   catch const stdrangeerror exn $^    pyerrsetstringpyexcarithmeticerror exn.what$^   catch const stdunderflowerror exn $^    pyerrsetstringpyexcarithmeticerror exn.what$^   catch const stdexception exn $^    pyerrsetstringpyexcruntimeerror exn.what$^  $^  catch ...$^  $^    pyerrsetstringpyexcruntimeerror unknown exception$^  $^$^endif$^$^ cintfrompy.proto $^static cythoninline sizet pyxpyintassizetpyobject $^$^ cintfrompy.proto $^static cythoninline int00t pyxpyintasint00tpyobject $^$^ cintfrompy.proto $^static cythoninline uint00t pyxpyintasuint00tpyobject $^$^ cintfrompy.proto $^static cythoninline int00t pyxpyintasint00tpyobject $^$^ cintfrompy.proto $^static cythoninline uint00t pyxpyintasuint00tpyobject $^$^ cintfrompy.proto $^static cythoninline timet pyxpyintastimetpyobject $^$^ cinttopy.proto $^static cythoninline pyobject pyxpyintfromlonglong value$^$^ cintfrompy.proto $^static cythoninline long pyxpyintaslongpyobject $^$^ cintfrompy.proto $^static cythoninline int pyxpyintasintpyobject $^$^ fasttypechecks.proto $^if cythoncompilingincpython$^define pyxtypecheckobj type pyxissubtypepytypeobj pytypeobject type$^static cythoninline int pyxissubtypepytypeobject a pytypeobject b$^static cythoninline int pyxpyerrgivenexceptionmatchespyobject err pyobject type$^static cythoninline int pyxpyerrgivenexceptionmatches0pyobject err pyobject type0 pyobject type0$^else$^define pyxtypecheckobj type pyobjecttypecheckobj pytypeobject type$^define pyxpyerrgivenexceptionmatcheserr type pyerrgivenexceptionmatcheserr type$^define pyxpyerrgivenexceptionmatches0err type0 type0 pyerrgivenexceptionmatcheserr type0  pyerrgivenexceptionmatcheserr type0$^endif$^$^ checkbinaryversion.proto $^static int pyxcheckbinaryversionvoid$^$^ functionexport.proto $^static int pyxexportfunctionconst char name void fvoid const char sig$^$^ initstrings.proto $^static int pyxinitstringspyxstringtabentry t$^$^static void pyxf0pywrapfst0weightcheckweightstruct pyxobj0pywrapfstweight pyxvself  proto$^static struct pyxobj0pywrapfstweight pyxf0pywrapfst0weightcopystruct pyxobj0pywrapfstweight pyxvself int pyxskipdispatch  proto$^static stdstring pyxf0pywrapfst0weighttostringstruct pyxobj0pywrapfstweight pyxvself int pyxskipdispatch  proto$^static stdstring pyxf0pywrapfst0weighttypestruct pyxobj0pywrapfstweight pyxvself int pyxskipdispatch  proto$^static pyxt00basictypesint00 pyxf0pywrapfst00symboltableavailablekeystruct pyxobj0pywrapfstsymboltable pyxvself int pyxskipdispatch  proto$^static stdstring pyxf0pywrapfst00symboltablechecksumstruct pyxobj0pywrapfstsymboltable pyxvself int pyxskipdispatch  proto$^static struct pyxobj0pywrapfstsymboltable pyxf0pywrapfst00symboltablecopystruct pyxobj0pywrapfstsymboltable pyxvself int pyxskipdispatch  proto$^static pyxt00basictypesint00 pyxf0pywrapfst00symboltablegetnthkeystruct pyxobj0pywrapfstsymboltable pyxvself pyssizet pyxvpos int pyxskipdispatch  proto$^static stdstring pyxf0pywrapfst00symboltablelabeledchecksumstruct pyxobj0pywrapfstsymboltable pyxvself int pyxskipdispatch  proto$^static bool pyxf0pywrapfst00symboltablememberstruct pyxobj0pywrapfstsymboltable pyxvself pyobject pyxvkey int pyxskipdispatch  proto$^static stdstring pyxf0pywrapfst00symboltablenamestruct pyxobj0pywrapfstsymboltable pyxvself int pyxskipdispatch  proto$^static sizet pyxf0pywrapfst00symboltablenumsymbolsstruct pyxobj0pywrapfstsymboltable pyxvself int pyxskipdispatch  proto$^static void pyxf0pywrapfst00symboltablewritestruct pyxobj0pywrapfstsymboltable pyxvself pyobject pyxvfilename int pyxskipdispatch  proto$^static void pyxf0pywrapfst00symboltablewritetextstruct pyxobj0pywrapfstsymboltable pyxvself pyobject pyxvfilename int pyxskipdispatch  proto$^static pyxt00basictypesint00 pyxf0pywrapfst00mutablesymboltableaddsymbolstruct pyxobj0pywrapfstmutablesymboltable pyxvself pyobject pyxvsymbol int pyxskipdispatch struct pyxoptargs0pywrapfst00mutablesymboltableaddsymbol pyxoptionalargs  proto$^static void pyxf0pywrapfst00mutablesymboltableaddtablestruct pyxobj0pywrapfstmutablesymboltable pyxvself struct pyxobj0pywrapfstsymboltable pyxvsyms int pyxskipdispatch  proto$^static void pyxf0pywrapfst00mutablesymboltablesetnamestruct pyxobj0pywrapfstmutablesymboltable pyxvself pyobject pyxvnewname int pyxskipdispatch  proto$^static bool pyxf0pywrapfst00symboltableiteratordonestruct pyxobj0pywrapfstsymboltableiterator pyxvself int pyxskipdispatch  proto$^static void pyxf0pywrapfst00symboltableiteratornextstruct pyxobj0pywrapfstsymboltableiterator pyxvself int pyxskipdispatch  proto$^static void pyxf0pywrapfst00symboltableiteratorresetstruct pyxobj0pywrapfstsymboltableiterator pyxvself int pyxskipdispatch  proto$^static stdstring pyxf0pywrapfst00symboltableiteratorsymbolstruct pyxobj0pywrapfstsymboltableiterator pyxvself int pyxskipdispatch  proto$^static pyxt00basictypesint00 pyxf0pywrapfst00symboltableiteratorvaluestruct pyxobj0pywrapfstsymboltableiterator pyxvself int pyxskipdispatch  proto$^static stdstring pyxf0pywrapfst00encodemapperarctypestruct pyxobj0pywrapfstencodemapper pyxvself int pyxskipdispatch  proto$^static pyxt00basictypesuint00 pyxf0pywrapfst00encodemapperflagsstruct pyxobj0pywrapfstencodemapper pyxvself int pyxskipdispatch  proto$^static struct pyxobj0pywrapfstencodemappersymboltable pyxf0pywrapfst00encodemapperinputsymbolsstruct pyxobj0pywrapfstencodemapper pyxvself int pyxskipdispatch  proto$^static struct pyxobj0pywrapfstencodemappersymboltable pyxf0pywrapfst00encodemapperoutputsymbolsstruct pyxobj0pywrapfstencodemapper pyxvself int pyxskipdispatch  proto$^static pyxt00basictypesuint00 pyxf0pywrapfst00encodemapperpropertiesstruct pyxobj0pywrapfstencodemapper pyxvself pyxt00basictypesuint00 pyxvmask int pyxskipdispatch  proto$^static void pyxf0pywrapfst00encodemappersetinputsymbolsstruct pyxobj0pywrapfstencodemapper pyxvself struct pyxobj0pywrapfstsymboltable pyxvsyms int pyxskipdispatch  proto$^static void pyxf0pywrapfst00encodemappersetoutputsymbolsstruct pyxobj0pywrapfstencodemapper pyxvself struct pyxobj0pywrapfstsymboltable pyxvsyms int pyxskipdispatch  proto$^static stdstring pyxf0pywrapfst00encodemapperweighttypestruct pyxobj0pywrapfstencodemapper pyxvself int pyxskipdispatch  proto$^static stdstring pyxf0pywrapfst0fstarctypestruct pyxobj0pywrapfstfst pyxvself int pyxskipdispatch  proto$^static struct pyxobj0pywrapfstarciterator pyxf0pywrapfst0fstarcsstruct pyxobj0pywrapfstfst pyxvself pyxt00basictypesint00 pyxvstate int pyxskipdispatch  proto$^static struct pyxobj0pywrapfstfst pyxf0pywrapfst0fstcopystruct pyxobj0pywrapfstfst pyxvself int pyxskipdispatch  proto$^static void pyxf0pywrapfst0fstdrawstruct pyxobj0pywrapfstfst pyxvself pyobject pyxvfilename int pyxskipdispatch struct pyxoptargs0pywrapfst0fstdraw pyxoptionalargs  proto$^static struct pyxobj0pywrapfstweight pyxf0pywrapfst0fstfinalstruct pyxobj0pywrapfstfst pyxvself pyxt00basictypesint00 pyxvstate int pyxskipdispatch  proto$^static stdstring pyxf0pywrapfst0fstfsttypestruct pyxobj0pywrapfstfst pyxvself int pyxskipdispatch  proto$^static struct pyxobj0pywrapfstfstsymboltable pyxf0pywrapfst0fstinputsymbolsstruct pyxobj0pywrapfstfst pyxvself int pyxskipdispatch  proto$^static sizet pyxf0pywrapfst0fstnumarcsstruct pyxobj0pywrapfstfst pyxvself pyxt00basictypesint00 pyxvstate int pyxskipdispatch  proto$^static sizet pyxf0pywrapfst0fstnuminputepsilonsstruct pyxobj0pywrapfstfst pyxvself pyxt00basictypesint00 pyxvstate int pyxskipdispatch  proto$^static sizet pyxf0pywrapfst0fstnumoutputepsilonsstruct pyxobj0pywrapfstfst pyxvself pyxt00basictypesint00 pyxvstate int pyxskipdispatch  proto$^static struct pyxobj0pywrapfstfstsymboltable pyxf0pywrapfst0fstoutputsymbolsstruct pyxobj0pywrapfstfst pyxvself int pyxskipdispatch  proto$^static pyxt00basictypesuint00 pyxf0pywrapfst0fstpropertiesstruct pyxobj0pywrapfstfst pyxvself pyxt00basictypesuint00 pyxvmask bool pyxvtest int pyxskipdispatch  proto$^static pyxt00basictypesint00 pyxf0pywrapfst0fststartstruct pyxobj0pywrapfstfst pyxvself int pyxskipdispatch  proto$^static struct pyxobj0pywrapfststateiterator pyxf0pywrapfst0fststatesstruct pyxobj0pywrapfstfst pyxvself int pyxskipdispatch  proto$^static stdstring pyxf0pywrapfst0fsttextstruct pyxobj0pywrapfstfst pyxvself int pyxskipdispatch struct pyxoptargs0pywrapfst0fsttext pyxoptionalargs  proto$^static bool pyxf0pywrapfst0fstverifystruct pyxobj0pywrapfstfst pyxvself int pyxskipdispatch  proto$^static stdstring pyxf0pywrapfst0fstweighttypestruct pyxobj0pywrapfstfst pyxvself int pyxskipdispatch  proto$^static void pyxf0pywrapfst0fstwritestruct pyxobj0pywrapfstfst pyxvself pyobject pyxvfilename int pyxskipdispatch  proto$^static stdstring pyxf0pywrapfst0fstwritetostringstruct pyxobj0pywrapfstfst pyxvself int pyxskipdispatch  proto$^static void pyxf0pywrapfst00mutablefstcheckmutatingimethodstruct pyxobj0pywrapfstmutablefst pyxvself  proto$^static void pyxf0pywrapfst00mutablefstaddarcstruct pyxobj0pywrapfstmutablefst pyxvself pyxt00basictypesint00 pyxvstate struct pyxobj0pywrapfstarc pyxvarc  proto$^static pyxt00basictypesint00 pyxf0pywrapfst00mutablefstaddstatestruct pyxobj0pywrapfstmutablefst pyxvself int pyxskipdispatch  proto$^static void pyxf0pywrapfst00mutablefstarcsortstruct pyxobj0pywrapfstmutablefst pyxvself struct pyxoptargs0pywrapfst00mutablefstarcsort pyxoptionalargs  proto$^static void pyxf0pywrapfst00mutablefstclosurestruct pyxobj0pywrapfstmutablefst pyxvself struct pyxoptargs0pywrapfst00mutablefstclosure pyxoptionalargs  proto$^static void pyxf0pywrapfst00mutablefstconcatstruct pyxobj0pywrapfstmutablefst pyxvself struct pyxobj0pywrapfstfst pyxvifst  proto$^static void pyxf0pywrapfst00mutablefstconnectstruct pyxobj0pywrapfstmutablefst pyxvself  proto$^static void pyxf0pywrapfst00mutablefstdecodestruct pyxobj0pywrapfstmutablefst pyxvself struct pyxobj0pywrapfstencodemapper pyxvencoder  proto$^static void pyxf0pywrapfst00mutablefstdeletearcsstruct pyxobj0pywrapfstmutablefst pyxvself pyxt00basictypesint00 pyxvstate struct pyxoptargs0pywrapfst00mutablefstdeletearcs pyxoptionalargs  proto$^static void pyxf0pywrapfst00mutablefstdeletestatesstruct pyxobj0pywrapfstmutablefst pyxvself struct pyxoptargs0pywrapfst00mutablefstdeletestates pyxoptionalargs  proto$^static void pyxf0pywrapfst00mutablefstencodestruct pyxobj0pywrapfstmutablefst pyxvself struct pyxobj0pywrapfstencodemapper pyxvencoder  proto$^static void pyxf0pywrapfst00mutablefstinvertstruct pyxobj0pywrapfstmutablefst pyxvself  proto$^static void pyxf0pywrapfst00mutablefstminimizestruct pyxobj0pywrapfstmutablefst pyxvself struct pyxoptargs0pywrapfst00mutablefstminimize pyxoptionalargs  proto$^static struct pyxobj0pywrapfstmutablearciterator pyxf0pywrapfst00mutablefstmutablearcsstruct pyxobj0pywrapfstmutablefst pyxvself pyxt00basictypesint00 pyxvstate int pyxskipdispatch  proto$^static pyxt00basictypesint00 pyxf0pywrapfst00mutablefstnumstatesstruct pyxobj0pywrapfstmutablefst pyxvself int pyxskipdispatch  proto$^static void pyxf0pywrapfst00mutablefstprojectstruct pyxobj0pywrapfstmutablefst pyxvself struct pyxoptargs0pywrapfst00mutablefstproject pyxoptionalargs  proto$^static void pyxf0pywrapfst00mutablefstprunestruct pyxobj0pywrapfstmutablefst pyxvself struct pyxoptargs0pywrapfst00mutablefstprune pyxoptionalargs  proto$^static void pyxf0pywrapfst00mutablefstpushstruct pyxobj0pywrapfstmutablefst pyxvself struct pyxoptargs0pywrapfst00mutablefstpush pyxoptionalargs  proto$^static void pyxf0pywrapfst00mutablefstrelabelpairsstruct pyxobj0pywrapfstmutablefst pyxvself struct pyxoptargs0pywrapfst00mutablefstrelabelpairs pyxoptionalargs  proto$^static void pyxf0pywrapfst00mutablefstrelabeltablesstruct pyxobj0pywrapfstmutablefst pyxvself struct pyxoptargs0pywrapfst00mutablefstrelabeltables pyxoptionalargs  proto$^static void pyxf0pywrapfst00mutablefstreservearcsstruct pyxobj0pywrapfstmutablefst pyxvself pyxt00basictypesint00 pyxvstate sizet pyxvn  proto$^static void pyxf0pywrapfst00mutablefstreservestatesstruct pyxobj0pywrapfstmutablefst pyxvself pyxt00basictypesint00 pyxvn  proto$^static void pyxf0pywrapfst00mutablefstreweightstruct pyxobj0pywrapfstmutablefst pyxvself pyobject pyxvpotentials struct pyxoptargs0pywrapfst00mutablefstreweight pyxoptionalargs  proto$^static void pyxf0pywrapfst00mutablefstrmepsilonstruct pyxobj0pywrapfstmutablefst pyxvself struct pyxoptargs0pywrapfst00mutablefstrmepsilon pyxoptionalargs  proto$^static void pyxf0pywrapfst00mutablefstsetfinalstruct pyxobj0pywrapfstmutablefst pyxvself pyxt00basictypesint00 pyxvstate struct pyxoptargs0pywrapfst00mutablefstsetfinal pyxoptionalargs  proto$^static void pyxf0pywrapfst00mutablefstsetinputsymbolsstruct pyxobj0pywrapfstmutablefst pyxvself struct pyxobj0pywrapfstsymboltable pyxvsyms  proto$^static void pyxf0pywrapfst00mutablefstsetoutputsymbolsstruct pyxobj0pywrapfstmutablefst pyxvself struct pyxobj0pywrapfstsymboltable pyxvsyms  proto$^static void pyxf0pywrapfst00mutablefstsetpropertiesstruct pyxobj0pywrapfstmutablefst pyxvself pyxt00basictypesuint00 pyxvprops pyxt00basictypesuint00 pyxvmask  proto$^static void pyxf0pywrapfst00mutablefstsetstartstruct pyxobj0pywrapfstmutablefst pyxvself pyxt00basictypesint00 pyxvstate  proto$^static void pyxf0pywrapfst00mutablefsttopsortstruct pyxobj0pywrapfstmutablefst pyxvself  proto$^static void pyxf0pywrapfst00mutablefstunionstruct pyxobj0pywrapfstmutablefst pyxvself struct pyxobj0pywrapfstfst pyxvifst  proto$^static struct pyxobj0pywrapfstarc pyxf0pywrapfst0arccopystruct pyxobj0pywrapfstarc pyxvself int pyxskipdispatch  proto$^static bool pyxf0pywrapfst00arciteratordonestruct pyxobj0pywrapfstarciterator pyxvself int pyxskipdispatch  proto$^static pyxt00basictypesuint00 pyxf0pywrapfst00arciteratorflagsstruct pyxobj0pywrapfstarciterator pyxvself int pyxskipdispatch  proto$^static void pyxf0pywrapfst00arciteratornextstruct pyxobj0pywrapfstarciterator pyxvself int pyxskipdispatch  proto$^static sizet pyxf0pywrapfst00arciteratorpositionstruct pyxobj0pywrapfstarciterator pyxvself int pyxskipdispatch  proto$^static void pyxf0pywrapfst00arciteratorresetstruct pyxobj0pywrapfstarciterator pyxvself int pyxskipdispatch  proto$^static void pyxf0pywrapfst00arciteratorseekstruct pyxobj0pywrapfstarciterator pyxvself sizet pyxva int pyxskipdispatch  proto$^static void pyxf0pywrapfst00arciteratorsetflagsstruct pyxobj0pywrapfstarciterator pyxvself pyxt00basictypesuint00 pyxvflags pyxt00basictypesuint00 pyxvmask int pyxskipdispatch  proto$^static pyobject pyxf0pywrapfst00arciteratorvaluestruct pyxobj0pywrapfstarciterator pyxvself int pyxskipdispatch  proto$^static bool pyxf0pywrapfst00mutablearciteratordonestruct pyxobj0pywrapfstmutablearciterator pyxvself int pyxskipdispatch  proto$^static pyxt00basictypesuint00 pyxf0pywrapfst00mutablearciteratorflagsstruct pyxobj0pywrapfstmutablearciterator pyxvself int pyxskipdispatch  proto$^static void pyxf0pywrapfst00mutablearciteratornextstruct pyxobj0pywrapfstmutablearciterator pyxvself int pyxskipdispatch  proto$^static sizet pyxf0pywrapfst00mutablearciteratorpositionstruct pyxobj0pywrapfstmutablearciterator pyxvself int pyxskipdispatch  proto$^static void pyxf0pywrapfst00mutablearciteratorresetstruct pyxobj0pywrapfstmutablearciterator pyxvself int pyxskipdispatch  proto$^static void pyxf0pywrapfst00mutablearciteratorseekstruct pyxobj0pywrapfstmutablearciterator pyxvself sizet pyxva int pyxskipdispatch  proto$^static void pyxf0pywrapfst00mutablearciteratorsetflagsstruct pyxobj0pywrapfstmutablearciterator pyxvself pyxt00basictypesuint00 pyxvflags pyxt00basictypesuint00 pyxvmask int pyxskipdispatch  proto$^static void pyxf0pywrapfst00mutablearciteratorsetvaluestruct pyxobj0pywrapfstmutablearciterator pyxvself struct pyxobj0pywrapfstarc pyxvarc int pyxskipdispatch  proto$^static pyobject pyxf0pywrapfst00mutablearciteratorvaluestruct pyxobj0pywrapfstmutablearciterator pyxvself int pyxskipdispatch  proto$^static bool pyxf0pywrapfst00stateiteratordonestruct pyxobj0pywrapfststateiterator pyxvself int pyxskipdispatch  proto$^static void pyxf0pywrapfst00stateiteratornextstruct pyxobj0pywrapfststateiterator pyxvself int pyxskipdispatch  proto$^static void pyxf0pywrapfst00stateiteratorresetstruct pyxobj0pywrapfststateiterator pyxvself int pyxskipdispatch  proto$^static pyxt00basictypesint00 pyxf0pywrapfst00stateiteratorvaluestruct pyxobj0pywrapfststateiterator pyxvself int pyxskipdispatch  proto$^static struct pyxobj0pywrapfstfst pyxf0pywrapfst0compilercompilestruct pyxobj0pywrapfstcompiler pyxvself int pyxskipdispatch  proto$^static void pyxf0pywrapfst0compilerwritestruct pyxobj0pywrapfstcompiler pyxvself pyobject pyxvexpression int pyxskipdispatch  proto$^static stdstring pyxf0pywrapfst0farreaderarctypestruct pyxobj0pywrapfstfarreader pyxvself int pyxskipdispatch  proto$^static bool pyxf0pywrapfst0farreaderdonestruct pyxobj0pywrapfstfarreader pyxvself int pyxskipdispatch  proto$^static bool pyxf0pywrapfst0farreadererrorstruct pyxobj0pywrapfstfarreader pyxvself int pyxskipdispatch  proto$^static stdstring pyxf0pywrapfst0farreaderfartypestruct pyxobj0pywrapfstfarreader pyxvself int pyxskipdispatch  proto$^static bool pyxf0pywrapfst0farreaderfindstruct pyxobj0pywrapfstfarreader pyxvself pyobject pyxvkey int pyxskipdispatch  proto$^static struct pyxobj0pywrapfstfst pyxf0pywrapfst0farreadergetfststruct pyxobj0pywrapfstfarreader pyxvself int pyxskipdispatch  proto$^static stdstring pyxf0pywrapfst0farreadergetkeystruct pyxobj0pywrapfstfarreader pyxvself int pyxskipdispatch  proto$^static void pyxf0pywrapfst0farreadernextstruct pyxobj0pywrapfstfarreader pyxvself int pyxskipdispatch  proto$^static void pyxf0pywrapfst0farreaderresetstruct pyxobj0pywrapfstfarreader pyxvself int pyxskipdispatch  proto$^static void pyxf0pywrapfst0farwriterclosestruct pyxobj0pywrapfstfarwriter pyxvself  proto$^static void pyxf0pywrapfst0farwriteraddstruct pyxobj0pywrapfstfarwriter pyxvself pyobject pyxvkey struct pyxobj0pywrapfstfst pyxvifst int pyxskipdispatch  proto$^static stdstring pyxf0pywrapfst0farwriterarctypestruct pyxobj0pywrapfstfarwriter pyxvself int pyxskipdispatch  proto$^static bool pyxf0pywrapfst0farwritererrorstruct pyxobj0pywrapfstfarwriter pyxvself int pyxskipdispatch  proto$^static stdstring pyxf0pywrapfst0farwriterfartypestruct pyxobj0pywrapfstfarwriter pyxvself int pyxskipdispatch  proto$^$^ module declarations from libc.stddef $^$^ module declarations from libc.time $^$^ module declarations from libcpp $^$^ module declarations from libcpp.memory $^$^ module declarations from libcpp.utility $^$^ module declarations from libcpp.vector $^$^ module declarations from libc.string $^$^ module declarations from libcpp.string $^$^ module declarations from libc.stdint $^$^ module declarations from basictypes $^$^ module declarations from ios $^$^ module declarations from fst $^$^ module declarations from posix.types $^$^ module declarations from posix.unistd $^$^ module declarations from libcpp.cast $^$^ module declarations from memory $^$^ module declarations from pywrapfst $^static pytypeobject pyxptype0pywrapfstweight  0$^static pytypeobject pyxptype0pywrapfstsymboltable  0$^static pytypeobject pyxptype0pywrapfstencodemappersymboltable  0$^static pytypeobject pyxptype0pywrapfstfstsymboltable  0$^static pytypeobject pyxptype0pywrapfstmutablesymboltable  0$^static pytypeobject pyxptype0pywrapfstmutablefstsymboltable  0$^static pytypeobject pyxptype0pywrapfstsymboltable  0$^static pytypeobject pyxptype0pywrapfstsymboltableiterator  0$^static pytypeobject pyxptype0pywrapfstencodemapper  0$^static pytypeobject pyxptype0pywrapfstfst  0$^static pytypeobject pyxptype0pywrapfstmutablefst  0$^static pytypeobject pyxptype0pywrapfstarc  0$^static pytypeobject pyxptype0pywrapfstarciterator  0$^static pytypeobject pyxptype0pywrapfstmutablearciterator  0$^static pytypeobject pyxptype0pywrapfststateiterator  0$^static pytypeobject pyxptype0pywrapfstcompiler  0$^static pytypeobject pyxptype0pywrapfstfarreader  0$^static pytypeobject pyxptype0pywrapfstfarwriter  0$^static stdstring pyxf0pywrapfsttostringpyobject  struct pyxoptargs0pywrapfsttostring pyxoptionalargs proto$^static stdstring pyxf0pywrapfstweighttostringpyobject  struct pyxoptargs0pywrapfstweighttostring pyxoptionalargs proto$^static enum fstcomposefilter pyxf0pywrapfstgetcomposefilterstdstring const  proto$^static enum fstqueuetype pyxf0pywrapfstgetqueuetypestdstring const  proto$^static enum fstscriptrandarcselection pyxf0pywrapfstgetrandarcselectionstdstring const  proto$^static enum fstreplacelabeltype pyxf0pywrapfstgetreplacelabeltypestdstring const  bool proto$^static fstscriptweightclass pyxf0pywrapfstgetweightclassoronestdstring const  pyobject  proto$^static fstscriptweightclass pyxf0pywrapfstgetweightclassorzerostdstring const  pyobject  proto$^static struct pyxobj0pywrapfstweight pyxf0pywrapfstzeropyobject  proto$^static struct pyxobj0pywrapfstweight pyxf0pywrapfstonepyobject  proto$^static struct pyxobj0pywrapfstweight pyxf0pywrapfstnoweightpyobject  proto$^static struct pyxobj0pywrapfstweight pyxf0pywrapfstplusstruct pyxobj0pywrapfstweight  struct pyxobj0pywrapfstweight  proto$^static struct pyxobj0pywrapfstweight pyxf0pywrapfsttimesstruct pyxobj0pywrapfstweight  struct pyxobj0pywrapfstweight  proto$^static struct pyxobj0pywrapfstweight pyxf0pywrapfstdividestruct pyxobj0pywrapfstweight  struct pyxobj0pywrapfstweight  proto$^static struct pyxobj0pywrapfstweight pyxf0pywrapfstpowerstruct pyxobj0pywrapfstweight  sizet proto$^static struct pyxobj0pywrapfstencodemappersymboltable pyxf0pywrapfstinitencodemappersymboltablefstsymboltable  stdsharedptrfstscriptencodemapperclass  proto$^static struct pyxobj0pywrapfstfstsymboltable pyxf0pywrapfstinitfstsymboltablefstsymboltable  stdsharedptrfstscriptfstclass  proto$^static struct pyxobj0pywrapfstmutablefstsymboltable pyxf0pywrapfstinitmutablefstsymboltablefstsymboltable  stdsharedptrfstscriptmutablefstclass  proto$^static struct pyxobj0pywrapfstsymboltable pyxf0pywrapfstinitsymboltablefstsymboltable  proto$^static struct pyxobj0pywrapfstfst pyxf0pywrapfstinitfstpyxt0pywrapfstfstclassptr proto$^static struct pyxobj0pywrapfstmutablefst pyxf0pywrapfstinitmutablefstpyxt0pywrapfstmutablefstclassptr proto$^static struct pyxobj0pywrapfstfst pyxf0pywrapfstinitxfstpyxt0pywrapfstfstclassptr proto$^static struct pyxobj0pywrapfstmutablefst pyxf0pywrapfstcreatefststruct pyxoptargs0pywrapfstcreatefst pyxoptionalargs proto$^static struct pyxobj0pywrapfstfst pyxf0pywrapfstreadpyobject  int pyxskipdispatch proto$^static struct pyxobj0pywrapfstfst pyxf0pywrapfstreadfromstringpyobject  int pyxskipdispatch proto$^static struct pyxobj0pywrapfstarc pyxf0pywrapfstinitarcfstscriptarcclass const  proto$^static struct pyxobj0pywrapfstfst pyxf0pywrapfstmapstruct pyxobj0pywrapfstfst  struct pyxoptargs0pywrapfstmap pyxoptionalargs proto$^static struct pyxobj0pywrapfstfst pyxf0pywrapfstarcmapstruct pyxobj0pywrapfstfst  int pyxskipdispatch struct pyxoptargs0pywrapfstarcmap pyxoptionalargs proto$^static struct pyxobj0pywrapfstmutablefst pyxf0pywrapfstcomposestruct pyxobj0pywrapfstfst  struct pyxobj0pywrapfstfst  int pyxskipdispatch struct pyxoptargs0pywrapfstcompose pyxoptionalargs proto$^static struct pyxobj0pywrapfstfst pyxf0pywrapfstconvertstruct pyxobj0pywrapfstfst  int pyxskipdispatch struct pyxoptargs0pywrapfstconvert pyxoptionalargs proto$^static struct pyxobj0pywrapfstmutablefst pyxf0pywrapfstdeterminizestruct pyxobj0pywrapfstfst  int pyxskipdispatch struct pyxoptargs0pywrapfstdeterminize pyxoptionalargs proto$^static struct pyxobj0pywrapfstmutablefst pyxf0pywrapfstdifferencestruct pyxobj0pywrapfstfst  struct pyxobj0pywrapfstfst  int pyxskipdispatch struct pyxoptargs0pywrapfstdifference pyxoptionalargs proto$^static struct pyxobj0pywrapfstmutablefst pyxf0pywrapfstdisambiguatestruct pyxobj0pywrapfstfst  int pyxskipdispatch struct pyxoptargs0pywrapfstdisambiguate pyxoptionalargs proto$^static struct pyxobj0pywrapfstmutablefst pyxf0pywrapfstepsnormalizestruct pyxobj0pywrapfstfst  int pyxskipdispatch struct pyxoptargs0pywrapfstepsnormalize pyxoptionalargs proto$^static bool pyxf0pywrapfstequalstruct pyxobj0pywrapfstfst  struct pyxobj0pywrapfstfst  int pyxskipdispatch struct pyxoptargs0pywrapfstequal pyxoptionalargs proto$^static bool pyxf0pywrapfstequivalentstruct pyxobj0pywrapfstfst  struct pyxobj0pywrapfstfst  int pyxskipdispatch struct pyxoptargs0pywrapfstequivalent pyxoptionalargs proto$^static struct pyxobj0pywrapfstmutablefst pyxf0pywrapfstintersectstruct pyxobj0pywrapfstfst  struct pyxobj0pywrapfstfst  int pyxskipdispatch struct pyxoptargs0pywrapfstintersect pyxoptionalargs proto$^static bool pyxf0pywrapfstisomorphicstruct pyxobj0pywrapfstfst  struct pyxobj0pywrapfstfst  int pyxskipdispatch struct pyxoptargs0pywrapfstisomorphic pyxoptionalargs proto$^static struct pyxobj0pywrapfstmutablefst pyxf0pywrapfstprunestruct pyxobj0pywrapfstfst  int pyxskipdispatch struct pyxoptargs0pywrapfstprune pyxoptionalargs proto$^static struct pyxobj0pywrapfstmutablefst pyxf0pywrapfstpushstruct pyxobj0pywrapfstfst  int pyxskipdispatch struct pyxoptargs0pywrapfstpush pyxoptionalargs proto$^static bool pyxf0pywrapfstrandequivalentstruct pyxobj0pywrapfstfst  struct pyxobj0pywrapfstfst  int pyxskipdispatch struct pyxoptargs0pywrapfstrandequivalent pyxoptionalargs proto$^static struct pyxobj0pywrapfstmutablefst pyxf0pywrapfstrandgenstruct pyxobj0pywrapfstfst  int pyxskipdispatch struct pyxoptargs0pywrapfstrandgen pyxoptionalargs proto$^static struct pyxobj0pywrapfstmutablefst pyxf0pywrapfstreplacepyobject  int pyxskipdispatch struct pyxoptargs0pywrapfstreplace pyxoptionalargs proto$^static struct pyxobj0pywrapfstmutablefst pyxf0pywrapfstreversestruct pyxobj0pywrapfstfst  int pyxskipdispatch struct pyxoptargs0pywrapfstreverse pyxoptionalargs proto$^static stdvectorfstscriptweightclass  pyxf0pywrapfstshortestdistancestruct pyxobj0pywrapfstfst  struct pyxoptargs0pywrapfstshortestdistance pyxoptionalargs proto$^static struct pyxobj0pywrapfstmutablefst pyxf0pywrapfstshortestpathstruct pyxobj0pywrapfstfst  int pyxskipdispatch struct pyxoptargs0pywrapfstshortestpath pyxoptionalargs proto$^static struct pyxobj0pywrapfstfst pyxf0pywrapfststatemapstruct pyxobj0pywrapfstfst  pyobject  int pyxskipdispatch proto$^static struct pyxobj0pywrapfstmutablefst pyxf0pywrapfstsynchronizestruct pyxobj0pywrapfstfst  int pyxskipdispatch proto$^static struct pyxobj0pywrapfstsymboltable pyxf0pywrapfstcompactsymboltablestruct pyxobj0pywrapfstsymboltable  int pyxskipdispatch proto$^static struct pyxobj0pywrapfstsymboltable pyxf0pywrapfstmergesymboltablestruct pyxobj0pywrapfstsymboltable  struct pyxobj0pywrapfstsymboltable  int pyxskipdispatch proto$^static stdstring pyxconvertstringfrompystdinstringpyobject  proto$^static cythoninline pyobject pyxconvertpyobjectstringtopystdinstringstdstring const  proto$^static cythoninline pyobject pyxconvertpyunicodestringtopystdinstringstdstring const  proto$^static cythoninline pyobject pyxconvertpystrstringtopystdinstringstdstring const  proto$^static cythoninline pyobject pyxconvertpybytesstringtopystdinstringstdstring const  proto$^static cythoninline pyobject pyxconvertpybytearraystringtopystdinstringstdstring const  proto$^static stdvectorpyxt00basictypesint00  pyxconvertvectorfrompypyxt00basictypesint00pyobject  proto$^static stdvectorstdstring  pyxconvertvectorfrompystd0a0astringpyobject  proto$^define pyxmodulename pywrapfst$^extern int pyxmoduleismainpywrapfst$^int pyxmoduleismainpywrapfst  0$^$^ implementation of pywrapfst $^static pyobject pyxbuiltinvalueerror$^static pyobject pyxbuiltinruntimeerror$^static pyobject pyxbuiltinindexerror$^static pyobject pyxbuiltinioerror$^static pyobject pyxbuiltinobject$^static pyobject pyxbuiltinstaticmethod$^static pyobject pyxbuiltinid$^static pyobject pyxbuiltintypeerror$^static pyobject pyxbuiltinstopiteration$^static pyobject pyxbuiltinkeyerror$^static const char pyxkg  g$^static const char pyxkn  n$^static const char pyxkw  w$^static const char pyxkid  id$^static const char pyxkfst  fst$^static const char pyxkone  one$^static const char pyxk00  $^static const char pyxkadd  add$^static const char pyxkarc  arc$^static const char pyxkcls  cls$^static const char pyxkdoc  doc$^static const char pyxkdot  dot$^static const char pyxkkey  key$^static const char pyxklhs  lhs$^static const char pyxknew  new$^static const char pyxkrhs  rhs$^static const char pyxkpipe  pipe$^static const char pyxktsvg  tsvg$^static const char pyxkzero  zero$^static const char pyxkarcs  arcs$^static const char pyxkauto  auto$^static const char pyxkcopy  copy$^static const char pyxkdone  done$^static const char pyxkdraw  draw$^static const char pyxkfind  find$^static const char pyxkifst  ifst$^static const char pyxkmain  main$^static const char pyxkmask  mask$^static const char pyxkname  name$^static const char pyxknext  next$^static const char pyxkopen  open$^static const char pyxkplus  plus$^static const char pyxkread  read$^static const char pyxkseed  seed$^static const char pyxkseek  seek$^static const char pyxksyms  syms$^static const char pyxktest  test$^static const char pyxktext  text$^static const char pyxktype  type$^static const char pyxkutf0  utf0$^static const char pyxkerror  error$^static const char pyxkpopen  popen$^static const char pyxkclass  class$^static const char pyxkdelta  delta$^static const char pyxkerror  error$^static const char pyxkfinal  final$^static const char pyxkflags  flags$^static const char pyxkifst0  ifst0$^static const char pyxkifst0  ifst0$^static const char pyxkinput  input$^static const char pyxknpath  npath$^static const char pyxkpairs  pairs$^static const char pyxkpower  power$^static const char pyxkprops  props$^static const char pyxkreset  reset$^static const char pyxkstart  start$^static const char pyxkstate  state$^static const char pyxkstdin  stdin$^static const char pyxktimes  times$^static const char pyxktitle  title$^static const char pyxkvalue  value$^static const char pyxkwidth  width$^static const char pyxkwrite  write$^static const char pyxkcyclic  cyclic$^static const char pyxknumber  number$^static const char pyxkstring  string$^static const char pyxkatexit  atexit$^static const char pyxkcreate  create$^static const char pyxkdecode  decode$^static const char pyxkdivide  divide$^static const char pyxkencode  encode$^static const char pyxkformat  format$^static const char pyxkheight  height$^static const char pyxkilabel  ilabel$^static const char pyxkimport  import$^static const char pyxkipairs  ipairs$^static const char pyxkmember  member$^static const char pyxkmodule  module$^static const char pyxkname0  name$^static const char pyxknstate  nstate$^static const char pyxkobject  object$^static const char pyxkolabel  olabel$^static const char pyxkopairs  opairs$^static const char pyxkreduce  reduce$^static const char pyxkresult  result$^static const char pyxkselect  select$^static const char pyxkstates  states$^static const char pyxkstderr  stderr$^static const char pyxkstdout  stdout$^static const char pyxksymbol  symbol$^static const char pyxktest0  test$^static const char pyxkunique  unique$^static const char pyxkvector  vector$^static const char pyxkverify  verify$^static const char pyxkweight  weight$^static const char pyxkacyclic  acyclic$^static const char pyxkioerror  ioerror$^static const char pyxkmutable  mutable$^static const char pyxkcompile  compile$^static const char pyxkconnect  connect$^static const char pyxkdefault  default$^static const char pyxkgetfst  getfst$^static const char pyxkgetkey  getkey$^static const char pyxklogging  logging$^static const char pyxkneither  neither$^static const char pyxknodesep  nodesep$^static const char pyxknumbers  numbers$^static const char pyxkprepare  prepare$^static const char pyxkranksep  ranksep$^static const char pyxkreverse  reverse$^static const char pyxkuniform  uniform$^static const char pyxkwarning  warning$^static const char pyxkacceptor  acceptor$^static const char pyxkdottsvg  dottsvg$^static const char pyxkepsilons  epsilons$^static const char pyxkexpanded  expanded$^static const char pyxkfsterror  fsterror$^static const char pyxkfstread  fst.read$^static const char pyxkkeyerror  keyerror$^static const char pyxknolabel  nolabel$^static const char pyxknoweight  noweight$^static const char pyxkweighted  weighted$^static const char pyxkacceptor  acceptor$^static const char pyxkarctype  arctype$^static const char pyxkchecksum  checksum$^static const char pyxkdettype  dettype$^static const char pyxkdistance  distance$^static const char pyxkfartype  fartype$^static const char pyxkfilename  filename$^static const char pyxkfontsize  fontsize$^static const char pyxkfsttype  fsttype$^static const char pyxkgetstate  getstate$^static const char pyxkidentity  identity$^static const char pyxkisymbols  isymbols$^static const char pyxkmaptype  maptype$^static const char pyxknumarcs  numarcs$^static const char pyxkosymbols  osymbols$^static const char pyxkportrait  portrait$^static const char pyxkposition  position$^static const char pyxkqualname  qualname$^static const char pyxkreadfst  readfst$^static const char pyxkregister  register$^static const char pyxkreprsvg  reprsvg$^static const char pyxksetname  setname$^static const char pyxksetstate  setstate$^static const char pyxkssymbols  ssymbols$^static const char pyxkstandard  standard$^static const char pyxktofinal  tofinal$^static const char pyxktropical  tropical$^static const char pyxkvertical  vertical$^static const char pyxkweighted  weighted$^static const char pyxkarcflags  arcflags$^static const char pyxkfstnew  fst.new$^static const char pyxknosymbol  nosymbol$^static const char pyxktypeerror  typeerror$^static const char pyxkaddstate  addstate$^static const char pyxkaddtable  addtable$^static const char pyxkknosymbol  knosymbol$^static const char pyxkmetaclass  metaclass$^static const char pyxknextstate  nextstate$^static const char pyxknshortest  nshortest$^static const char pyxkprecision  precision$^static const char pyxkpywrapfst  pywrapfst$^static const char pyxkreadtext  readtext$^static const char pyxkreduceex  reduceex$^static const char pyxksetflags  setflags$^static const char pyxksetvalue  setvalue$^static const char pyxksorttype  sorttype$^static const char pyxktostring  tostring$^static const char pyxkaccessible  accessible$^static const char pyxkfstioerror  fstioerror$^static const char pyxkfstoperror  fstoperror$^static const char pyxkiepsilons  iepsilons$^static const char pyxkindexerror  indexerror$^static const char pyxknotstring  notstring$^static const char pyxkoepsilons  oepsilons$^static const char pyxktopsorted  topsorted$^static const char pyxkunweighted  unweighted$^static const char pyxkvalueerror  valueerror$^static const char pyxkaddsymbol  addsymbol$^static const char pyxkfunctional  functional$^static const char pyxkmaxlength  maxlength$^static const char pyxknumstates  numstates$^static const char pyxkpotentials  potentials$^static const char pyxkproperties  properties$^static const char pyxkpyxvtable  pyxvtable$^static const char pyxkqueuetype  queuetype$^static const char pyxkreturncode  returncode$^static const char pyxksubprocess  subprocess$^static const char pyxkwritetext  writetext$^static const char pyxkarcat0xx  arc at 0xx$^static const char pyxkfstargerror  fstargerror$^static const char pyxkfstat0xx   fst at 0xx$^static const char pyxknoepsilons  noepsilons$^static const char pyxknostateid  nostateid$^static const char pyxkcommunicate  communicate$^static const char pyxkgetnthkey  getnthkey$^static const char pyxkinputtable  inputtable$^static const char pyxkmissingsym  missingsym$^static const char pyxknumsymbols  numsymbols$^static const char pyxkpushlabels  pushlabels$^static const char pyxkpywrapfst0  pywrapfst$^static const char pyxkunspecified  unspecified$^static const char pyxkweighttype  weighttype$^static const char pyxkarcnocache  arcnocache$^static const char pyxkcoaccessible  coaccessible$^static const char pyxkencodeflags  encodeflags$^static const char pyxknotacceptor  notacceptor$^static const char pyxkruntimeerror  runtimeerror$^static const char pyxkallownondet  allownondet$^static const char pyxkclosureplus  closureplus$^static const char pyxkfloatformat  floatformat$^static const char pyxkmutablearcs  mutablearcs$^static const char pyxknewisymbols  newisymbols$^static const char pyxknewosymbols  newosymbols$^static const char pyxkoldisymbols  oldisymbols$^static const char pyxkoldosymbols  oldosymbols$^static const char pyxkpushweights  pushweights$^static const char pyxkreturnlabel  returnlabel$^static const char pyxkstaticmethod  staticmethod$^static const char pyxkencodelabels  encodelabels$^static const char pyxkfstindexerror  fstindexerror$^static const char pyxknoiepsilons  noiepsilons$^static const char pyxknooepsilons  nooepsilons$^static const char pyxkopenfailedr  open failed r$^static const char pyxkreadfailedr  read failed r$^static const char pyxkstopiteration  stopiteration$^static const char pyxkavailablekey  availablekey$^static const char pyxkencodelabels  encodelabels$^static const char pyxkinputsymbols  inputsymbols$^static const char pyxkkeepisymbols  keepisymbols$^static const char pyxkkeeposymbols  keeposymbols$^static const char pyxkpywrapfstpyx  pywrapfst.pyx$^static const char pyxkreducecython  reducecython$^static const char pyxkencodeweights  encodeweights$^static const char pyxkfstproperties  fstproperties$^static const char pyxkinitialcyclic  initialcyclic$^static const char pyxkilabelsorted  ilabelsorted$^static const char pyxkinvalidweight  invalid weight$^static const char pyxknotaccessible  notaccessible$^static const char pyxknottopsorted  nottopsorted$^static const char pyxkolabelsorted  olabelsorted$^static const char pyxkweightat0xx   weight  at 0xx$^static const char pyxkwritefailedr  write failed r$^static const char pyxkcomposefilter  composefilter$^static const char pyxkencodeweights  encodeweights$^static const char pyxkoutputsymbols  outputsymbols$^static const char pyxkprojectoutput  projectoutput$^static const char pyxkarcvalueflags  arcvalueflags$^static const char pyxkcopyproperties  copyproperties$^static const char pyxkinitialacyclic  initialacyclic$^static const char pyxkideterministic  ideterministic$^static const char pyxknullproperties  nullproperties$^static const char pyxkodeterministic  odeterministic$^static const char pyxkweightedcycles  weightedcycles$^static const char pyxkepsnormoutput  epsnormoutput$^static const char pyxksetstatecython  setstatecython$^static const char pyxkshowweightone  showweightone$^static const char pyxkunknownisymbol  unknownisymbol$^static const char pyxkunknownosymbol  unknownosymbol$^static const char pyxkwritetostring  writetostring$^static const char pyxkarcweightvalue  arcweightvalue$^static const char pyxkcannotconstruct  cannot construct $^static const char pyxkkeyoutoforder  key out of order$^static const char pyxknotcoaccessible  notcoaccessible$^static const char pyxkoperationfailed  operation failed$^static const char pyxklabeledchecksum  labeledchecksum$^static const char pyxkreadfromstring  readfromstring$^static const char pyxkshortestdistance  shortestdistance$^static const char pyxkarcilabelvalue  arcilabelvalue$^static const char pyxkarcolabelvalue  arcolabelvalue$^static const char pyxkbinaryproperties  binaryproperties$^static const char pyxkfarreaderat0xx   farreader at 0xx$^static const char pyxkfarwriterat0xx   farwriter at 0xx$^static const char pyxkfstbadweighterror  fstbadweighterror$^static const char pyxkunweightedcycles  unweightedcycles$^static const char pyxkcallarclabeling  callarclabeling$^static const char pyxksetinputsymbols  setinputsymbols$^static const char pyxkaddarcproperties  addarcproperties$^static const char pyxkcalledprocesserror  calledprocesserror$^static const char pyxkcompilationfailed  compilation failed$^static const char pyxknotilabelsorted  notilabelsorted$^static const char pyxknotolabelsorted  notolabelsorted$^static const char pyxkreadfailedstring  read failed string$^static const char pyxksetarcproperties  setarcproperties$^static const char pyxktrinaryproperties  trinaryproperties$^static const char pyxkunknownarctyper  unknown arc type r$^static const char pyxkunknownmaptyper  unknown map type r$^static const char pyxkclineintraceback  clineintraceback$^static const char pyxkepsilononreplace  epsilononreplace$^static const char pyxknuminputepsilons  numinputepsilons$^static const char pyxkreadfromstring0  readfromstring$^static const char pyxksetoutputsymbols  setoutputsymbols$^static const char pyxkarcsortproperties  arcsortproperties$^static const char pyxkarciteratorat0xx  arciterator at 0xx$^static const char pyxknonideterministic  nonideterministic$^static const char pyxknonodeterministic  nonodeterministic$^static const char pyxkunknownsorttyper  unknown sort type r$^static const char pyxkattachnewisymbols  attachnewisymbols$^static const char pyxkattachnewosymbols  attachnewosymbols$^static const char pyxkfsterrorfatalold  fsterrorfatalold$^static const char pyxknumoutputepsilons  numoutputepsilons$^static const char pyxkremovecommonaffix  removecommonaffix$^static const char pyxkremovetotalweight  removetotalweight$^static const char pyxkreturnarclabeling  returnarclabeling$^static const char pyxksubsequentiallabel  subsequentiallabel$^static const char pyxkaddstateproperties  addstateproperties$^static const char pyxkarcnextstatevalue  arcnextstatevalue$^static const char pyxkextrinsicproperties  extrinsicproperties$^static const char pyxkencodemapperat0xx  encodemapper at 0xx$^static const char pyxkfstreadfromstring  fst.readfromstring$^static const char pyxkintrinsicproperties  intrinsicproperties$^static const char pyxksetfinalproperties  setfinalproperties$^static const char pyxksetstartproperties  setstartproperties$^static const char pyxkunknownqueuetyper  unknown queue type r$^static const char pyxkkeepstatenumbering  keepstatenumbering$^static const char pyxkrequiresuperinitial  requiresuperinitial$^static const char pyxkdeletearcproperties  deletearcproperties$^static const char pyxkstatesortproperties  statesortproperties$^static const char pyxkstateiteratorat0xx  stateiterator at 0xx$^static const char pyxksymboltablerat0xx  symboltable r at 0xx$^static const char pyxkweighttypenotfound  weight type not found$^static const char pyxkallownegativelabels  allownegativelabels$^static const char pyxkresetfsterrorfatal  resetfsterrorfatal$^static const char pyxkconversiontorfailed  conversion to r failed$^static const char pyxknegtrinaryproperties  negtrinaryproperties$^static const char pyxkpostrinaryproperties  postrinaryproperties$^static const char pyxkwritetostringfailed  write to string failed$^static const char pyxkdeletestateproperties  deletestateproperties$^static const char pyxkrmsuperfinalproperties  rmsuperfinalproperties$^static const char pyxkstateindexoutofrange  state index out of range$^static const char pyxkaddsuperfinalproperties  addsuperfinalproperties$^static const char pyxkcannotencodeasstringr  cannot encode as string r$^static const char pyxkcannottopsortcyclicfst  cannot topsort cyclic fst.$^static const char pyxkfstsymboltablerat0xx  fst symboltable r at 0xx$^static const char pyxkfstdeletedconstructorerror  fstdeletedconstructorerror$^static const char pyxkmutablearciteratorat0xx  mutablearciterator at 0xx$^static const char pyxksymboltableiteratorat0xx  symboltableiterator at 0xx$^static const char pyxkweightinvariantproperties  weightinvariantproperties$^static const char pyxkilabelinvariantproperties  ilabelinvariantproperties$^static const char pyxkolabelinvariantproperties  olabelinvariantproperties$^static const char pyxkunknownreplacelabeltyper  unknown replace label type r$^static const char pyxknonewsymboltablesspecified  no new symboltables specified$^static const char pyxknorelabelingpairsspecified  no relabeling pairs specified.$^static const char pyxkunknowncomposefiltertyper  unknown compose filter type r$^static const char pyxkincrementsubsequentiallabel  incrementsubsequentiallabel$^static const char pyxkincompatibleorinvalidweight  incompatible or invalid weight$^static const char pyxkunknowndeterminizationtyper  unknown determinization type r$^static const char pyxkconstencodemappersymboltable  const encodemapper symboltable r at 0xx$^static const char pyxkfstarctypestandardconstruct  n   fstarctypestandardnn   constructs an empty fst.nn   argsn     arctype a string indicating the arc type.nn   raisesn     fsterror unknown arc type.nn   raisesn     fstoperror operation failed.n   $^static const char pyxkconstfstsymboltablerat0xx  const fst symboltable r at 0xx$^static const char pyxkselfaiterselffstcannotbe  self.aiterself.fst cannot be converted to a python object for pickling$^static const char pyxkselffstselfsitercannotbe  self.fstself.siter cannot be converted to a python object for pickling$^static const char pyxkselffstselftablecannotbe  self.fstself.table cannot be converted to a python object for pickling$^static const char pyxkselftablecannotbeconverted  self.table cannot be converted to a python object for pickling$^static const char pyxkincompatibleorinvalidarctype  incompatible or invalid arc type$^static const char pyxkincompatibleorinvalidweightt  incompatible or invalid weight type$^static const char pyxkpythoninterfacetothefstscri  python interface to the fst scripting api.nnoperations which construct new fsts are implemented as traditional functions asnare twoargument boolean functions like equal and equivalent. destructivenoperationsthose that mutate an fst in placeare instance methods as isnwrite. operator overloading is not used. the following example based onnmohri et al. 0000 shows the construction of an asr system given a pronunciationnlexicon l grammar g a transducer from contextdependent phones toncontextindependent phones c and an hmm set hnn  l  fst.fst.readl.fstn  g  fst.fst.readg.fstn  c  fst.fst.readc.fstn  h  fst.fst.readh.fstn  lg  fst.determinizefst.composel gn  clg  fst.determinizefst.composec lgn  hclg  fst.determinizefst.composeh clgn  hclg.minimize                                       nb works inplace.nnpython variables here use snakecase and constants are in all caps minus thennormal k prefix.n$^static const char pyxkunknownrandomarcselectiontyp  unknown random arc selection type r$^static const char pyxknodefaultreduceduetonon  no default reduce due to nontrivial cinit$^static const char pyxkselfaiterselfmfstcannotbe  self.aiterself.mfst cannot be converted to a python object for pickling$^static const char pyxkselfarccannotbeconvertedto  self.arc cannot be converted to a python object for pickling$^static const char pyxkselfencodercannotbeconverte  self.encoder cannot be converted to a python object for pickling$^static const char pyxkselfencoderselftablecannot  self.encoderself.table cannot be converted to a python object for pickling$^static const char pyxkselfmfstselftablecannotbe  self.mfstself.table cannot be converted to a python object for pickling$^static const char pyxkselfreadercannotbeconverted  self.reader cannot be converted to a python object for pickling$^static const char pyxkselfsiterselftablecannotb  self.siterself.table cannot be converted to a python object for pickling$^static const char pyxkselfsmarttableselftableca  self.smarttableself.table cannot be converted to a python object for pickling$^static const char pyxkselfweightcannotbeconverted  self.weight cannot be converted to a python object for pickling$^static const char pyxkselfwritercannotbeconverted  self.writer cannot be converted to a python object for pickling$^static pyobject pyxnsacceptor$^static pyobject pyxnsaccessible$^static pyobject pyxnsacyclic$^static pyobject pyxnsaddarcproperties$^static pyobject pyxnsaddstateproperties$^static pyobject pyxnsaddsuperfinalproperties$^static pyobject pyxnsarcflags$^static pyobject pyxnsarcilabelvalue$^static pyobject pyxnsarcnextstatevalue$^static pyobject pyxnsarcnocache$^static pyobject pyxnsarcolabelvalue$^static pyobject pyxnsarcsortproperties$^static pyobject pyxnsarcvalueflags$^static pyobject pyxnsarcweightvalue$^static pyobject pyxkpsarciteratorat0xx$^static pyobject pyxkpsarcat0xx$^static pyobject pyxnsbinaryproperties$^static pyobject pyxnscoaccessible$^static pyobject pyxnscopyproperties$^static pyobject pyxnscyclic$^static pyobject pyxnscalledprocesserror$^static pyobject pyxkpscannotconstruct$^static pyobject pyxkpscannotencodeasstringr$^static pyobject pyxkpscannottopsortcyclicfst$^static pyobject pyxkpscompilationfailed$^static pyobject pyxkpsconversiontorfailed$^static pyobject pyxnsdeletearcproperties$^static pyobject pyxnsdeletestateproperties$^static pyobject pyxnsdottsvg$^static pyobject pyxnsencodeflags$^static pyobject pyxnsencodelabels$^static pyobject pyxnsencodeweights$^static pyobject pyxnsepsilons$^static pyobject pyxnserror$^static pyobject pyxnsexpanded$^static pyobject pyxnsextrinsicproperties$^static pyobject pyxkpsencodemapperat0xx$^static pyobject pyxnsfstproperties$^static pyobject pyxkpsfarreaderat0xx$^static pyobject pyxkpsfarwriterat0xx$^static pyobject pyxnsfst$^static pyobject pyxnsfstargerror$^static pyobject pyxnsfstbadweighterror$^static pyobject pyxnsfstdeletedconstructorerror$^static pyobject pyxnsfsterror$^static pyobject pyxnsfstioerror$^static pyobject pyxnsfstindexerror$^static pyobject pyxnsfstoperror$^static pyobject pyxkpsfstsymboltablerat0xx$^static pyobject pyxnsfstnew$^static pyobject pyxkpsfstarctypestandardconstruct$^static pyobject pyxkpsfstat0xx$^static pyobject pyxnsfstread$^static pyobject pyxnsfstreadfromstring$^static pyobject pyxnsinitialacyclic$^static pyobject pyxnsinitialcyclic$^static pyobject pyxnsintrinsicproperties$^static pyobject pyxnsioerror$^static pyobject pyxnsideterministic$^static pyobject pyxnsiepsilons$^static pyobject pyxnsilabelinvariantproperties$^static pyobject pyxnsilabelsorted$^static pyobject pyxkpsincompatibleorinvalidarctype$^static pyobject pyxkpsincompatibleorinvalidweight$^static pyobject pyxkpsincompatibleorinvalidweightt$^static pyobject pyxnsindexerror$^static pyobject pyxkpsinvalidweight$^static pyobject pyxnskeyerror$^static pyobject pyxkpskeyoutoforder$^static pyobject pyxnsmutable$^static pyobject pyxkpsmutablearciteratorat0xx$^static pyobject pyxnsnegtrinaryproperties$^static pyobject pyxnsnonideterministic$^static pyobject pyxnsnonodeterministic$^static pyobject pyxnsnotacceptor$^static pyobject pyxnsnotaccessible$^static pyobject pyxnsnotcoaccessible$^static pyobject pyxnsnotilabelsorted$^static pyobject pyxnsnotolabelsorted$^static pyobject pyxnsnotstring$^static pyobject pyxnsnottopsorted$^static pyobject pyxnsnoepsilons$^static pyobject pyxnsnoiepsilons$^static pyobject pyxnsnolabel$^static pyobject pyxnsnooepsilons$^static pyobject pyxnsnostateid$^static pyobject pyxnsnosymbol$^static pyobject pyxnsnullproperties$^static pyobject pyxnsnoweight$^static pyobject pyxkpsnonewsymboltablesspecified$^static pyobject pyxkpsnorelabelingpairsspecified$^static pyobject pyxnsnumber$^static pyobject pyxnsodeterministic$^static pyobject pyxnsoepsilons$^static pyobject pyxnsolabelinvariantproperties$^static pyobject pyxnsolabelsorted$^static pyobject pyxnsone$^static pyobject pyxkpsopenfailedr$^static pyobject pyxkpsoperationfailed$^static pyobject pyxnspipe$^static pyobject pyxnspostrinaryproperties$^static pyobject pyxnspopen$^static pyobject pyxnsrmsuperfinalproperties$^static pyobject pyxkpsreadfailedr$^static pyobject pyxkpsreadfailedstring$^static pyobject pyxnsruntimeerror$^static pyobject pyxnssetarcproperties$^static pyobject pyxnssetfinalproperties$^static pyobject pyxnssetstartproperties$^static pyobject pyxnsstatesortproperties$^static pyobject pyxnsstring$^static pyobject pyxkpsstateiteratorat0xx$^static pyobject pyxkpsstateindexoutofrange$^static pyobject pyxnsstopiteration$^static pyobject pyxkpssymboltableiteratorat0xx$^static pyobject pyxkpssymboltablerat0xx$^static pyobject pyxnstopsorted$^static pyobject pyxnstrinaryproperties$^static pyobject pyxkpstsvg$^static pyobject pyxnstypeerror$^static pyobject pyxnsunweighted$^static pyobject pyxnsunweightedcycles$^static pyobject pyxkpsunknownarctyper$^static pyobject pyxkpsunknowncomposefiltertyper$^static pyobject pyxkpsunknowndeterminizationtyper$^static pyobject pyxkpsunknownmaptyper$^static pyobject pyxkpsunknownqueuetyper$^static pyobject pyxkpsunknownrandomarcselectiontyp$^static pyobject pyxkpsunknownreplacelabeltyper$^static pyobject pyxkpsunknownsorttyper$^static pyobject pyxnsvalueerror$^static pyobject pyxnsweighted$^static pyobject pyxnsweightedcycles$^static pyobject pyxnsweightinvariantproperties$^static pyobject pyxkpsweightat0xx$^static pyobject pyxkpsweighttypenotfound$^static pyobject pyxkpswritefailedr$^static pyobject pyxkpswritetostringfailed$^static pyobject pyxnszero$^static pyobject pyxkpb00$^static pyobject pyxnsacceptor$^static pyobject pyxnsadd$^static pyobject pyxnsaddstate$^static pyobject pyxnsaddsymbol$^static pyobject pyxnsaddtable$^static pyobject pyxnsallownegativelabels$^static pyobject pyxnsallownondet$^static pyobject pyxnsarc$^static pyobject pyxnsarctype$^static pyobject pyxnsarcs$^static pyobject pyxnsatexit$^static pyobject pyxnsattachnewisymbols$^static pyobject pyxnsattachnewosymbols$^static pyobject pyxnbauto$^static pyobject pyxnsavailablekey$^static pyobject pyxnscallarclabeling$^static pyobject pyxnschecksum$^static pyobject pyxnsclass$^static pyobject pyxnsclineintraceback$^static pyobject pyxnsclosureplus$^static pyobject pyxnscls$^static pyobject pyxnscommunicate$^static pyobject pyxnscompile$^static pyobject pyxnscomposefilter$^static pyobject pyxnsconnect$^static pyobject pyxkpsconstencodemappersymboltable$^static pyobject pyxkpsconstfstsymboltablerat0xx$^static pyobject pyxnscopy$^static pyobject pyxnscreate$^static pyobject pyxnsdecode$^static pyobject pyxnbdefault$^static pyobject pyxnsdelta$^static pyobject pyxnsdettype$^static pyobject pyxnsdistance$^static pyobject pyxnsdivide$^static pyobject pyxnsdoc$^static pyobject pyxnsdone$^static pyobject pyxnsdot$^static pyobject pyxnsdraw$^static pyobject pyxnsencode$^static pyobject pyxnsencodelabels$^static pyobject pyxnsencodeweights$^static pyobject pyxnsepsnormoutput$^static pyobject pyxnsepsilononreplace$^static pyobject pyxnserror$^static pyobject pyxnsfartype$^static pyobject pyxnsfilename$^static pyobject pyxnsfinal$^static pyobject pyxnsfind$^static pyobject pyxnsflags$^static pyobject pyxnsfloatformat$^static pyobject pyxnsfontsize$^static pyobject pyxnsformat$^static pyobject pyxnsfsterrorfatalold$^static pyobject pyxnsfsttype$^static pyobject pyxnbfunctional$^static pyobject pyxnbg$^static pyobject pyxnsgetfst$^static pyobject pyxnsgetkey$^static pyobject pyxnsgetnthkey$^static pyobject pyxnsgetstate$^static pyobject pyxnsheight$^static pyobject pyxnsid$^static pyobject pyxnbidentity$^static pyobject pyxnsifst$^static pyobject pyxnsifst0$^static pyobject pyxnsifst0$^static pyobject pyxnbilabel$^static pyobject pyxnsilabel$^static pyobject pyxnsimport$^static pyobject pyxnsincrementsubsequentiallabel$^static pyobject pyxnbinput$^static pyobject pyxnsinputsymbols$^static pyobject pyxnsinputtable$^static pyobject pyxnsipairs$^static pyobject pyxnsisymbols$^static pyobject pyxnsknosymbol$^static pyobject pyxnskeepisymbols$^static pyobject pyxnskeeposymbols$^static pyobject pyxnskeepstatenumbering$^static pyobject pyxnskey$^static pyobject pyxnslabeledchecksum$^static pyobject pyxnslhs$^static pyobject pyxnslogging$^static pyobject pyxnsmain$^static pyobject pyxnsmaptype$^static pyobject pyxnsmask$^static pyobject pyxnsmaxlength$^static pyobject pyxnsmember$^static pyobject pyxnsmetaclass$^static pyobject pyxnsmissingsym$^static pyobject pyxnsmodule$^static pyobject pyxnsmutablearcs$^static pyobject pyxnsn$^static pyobject pyxnsname$^static pyobject pyxnsname0$^static pyobject pyxnbneither$^static pyobject pyxnsnew$^static pyobject pyxnsnewisymbols$^static pyobject pyxnsnewosymbols$^static pyobject pyxnsnext$^static pyobject pyxnsnextstate$^static pyobject pyxkpsnodefaultreduceduetonon$^static pyobject pyxnsnodesep$^static pyobject pyxnsnpath$^static pyobject pyxnsnshortest$^static pyobject pyxnsnstate$^static pyobject pyxnsnumarcs$^static pyobject pyxnsnuminputepsilons$^static pyobject pyxnsnumoutputepsilons$^static pyobject pyxnsnumstates$^static pyobject pyxnsnumsymbols$^static pyobject pyxnsnumbers$^static pyobject pyxnsobject$^static pyobject pyxnsolabel$^static pyobject pyxnsoldisymbols$^static pyobject pyxnsoldosymbols$^static pyobject pyxnsopairs$^static pyobject pyxnsopen$^static pyobject pyxnsosymbols$^static pyobject pyxnsoutputsymbols$^static pyobject pyxnspairs$^static pyobject pyxnsplus$^static pyobject pyxnsportrait$^static pyobject pyxnsposition$^static pyobject pyxnspotentials$^static pyobject pyxnspower$^static pyobject pyxnsprecision$^static pyobject pyxnsprepare$^static pyobject pyxnsprojectoutput$^static pyobject pyxnsproperties$^static pyobject pyxnsprops$^static pyobject pyxnspushlabels$^static pyobject pyxnspushweights$^static pyobject pyxkpbpywrapfst$^static pyobject pyxnspywrapfst0$^static pyobject pyxkpspywrapfstpyx$^static pyobject pyxnspyxvtable$^static pyobject pyxnsqualname$^static pyobject pyxnsqueuetype$^static pyobject pyxnsranksep$^static pyobject pyxnsread$^static pyobject pyxnsreadfromstring$^static pyobject pyxnsreadfromstring0$^static pyobject pyxnsreadfst$^static pyobject pyxnsreadtext$^static pyobject pyxnsreduce$^static pyobject pyxnsreducecython$^static pyobject pyxnsreduceex$^static pyobject pyxnsregister$^static pyobject pyxnsremovecommonaffix$^static pyobject pyxnsremovetotalweight$^static pyobject pyxnbreprsvg$^static pyobject pyxnsrequiresuperinitial$^static pyobject pyxnsreset$^static pyobject pyxnsresetfsterrorfatal$^static pyobject pyxnsresult$^static pyobject pyxnsreturnarclabeling$^static pyobject pyxnsreturnlabel$^static pyobject pyxnsreturncode$^static pyobject pyxnsreverse$^static pyobject pyxnsrhs$^static pyobject pyxnsseed$^static pyobject pyxnsseek$^static pyobject pyxnsselect$^static pyobject pyxkpsselfaiterselffstcannotbe$^static pyobject pyxkpsselfaiterselfmfstcannotbe$^static pyobject pyxkpsselfarccannotbeconvertedto$^static pyobject pyxkpsselfencodercannotbeconverte$^static pyobject pyxkpsselfencoderselftablecannot$^static pyobject pyxkpsselffstselfsitercannotbe$^static pyobject pyxkpsselffstselftablecannotbe$^static pyobject pyxkpsselfmfstselftablecannotbe$^static pyobject pyxkpsselfreadercannotbeconverted$^static pyobject pyxkpsselfsiterselftablecannotb$^static pyobject pyxkpsselfsmarttableselftableca$^static pyobject pyxkpsselftablecannotbeconverted$^static pyobject pyxkpsselfweightcannotbeconverted$^static pyobject pyxkpsselfwritercannotbeconverted$^static pyobject pyxnssetflags$^static pyobject pyxnssetinputsymbols$^static pyobject pyxnssetname$^static pyobject pyxnssetoutputsymbols$^static pyobject pyxnssetvalue$^static pyobject pyxnssetstate$^static pyobject pyxnssetstatecython$^static pyobject pyxnsshortestdistance$^static pyobject pyxnsshowweightone$^static pyobject pyxnssorttype$^static pyobject pyxnsssymbols$^static pyobject pyxnbstandard$^static pyobject pyxnsstart$^static pyobject pyxnsstate$^static pyobject pyxnsstates$^static pyobject pyxnsstaticmethod$^static pyobject pyxnsstderr$^static pyobject pyxnsstdin$^static pyobject pyxnsstdout$^static pyobject pyxnssubprocess$^static pyobject pyxnssubsequentiallabel$^static pyobject pyxnssymbol$^static pyobject pyxnssyms$^static pyobject pyxnstest$^static pyobject pyxnstest0$^static pyobject pyxnstext$^static pyobject pyxnstimes$^static pyobject pyxnstitle$^static pyobject pyxnstofinal$^static pyobject pyxnstostring$^static pyobject pyxnbtropical$^static pyobject pyxnstype$^static pyobject pyxnbuniform$^static pyobject pyxnsunique$^static pyobject pyxnsunknownisymbol$^static pyobject pyxnsunknownosymbol$^static pyobject pyxkpbunspecified$^static pyobject pyxnsutf0$^static pyobject pyxnsvalue$^static pyobject pyxnbvector$^static pyobject pyxnsverify$^static pyobject pyxnsvertical$^static pyobject pyxnsw$^static pyobject pyxnswarning$^static pyobject pyxnsweight$^static pyobject pyxnsweighttype$^static pyobject pyxnsweighted$^static pyobject pyxnswidth$^static pyobject pyxnswrite$^static pyobject pyxnswritetext$^static pyobject pyxnbwritetostring$^static pyobject pyxnswritetostring$^static pyobject pyxpf0pywrapfst0weightreprstruct pyxobj0pywrapfstweight pyxvself  proto $^static pyobject pyxpf0pywrapfst0weight0strstruct pyxobj0pywrapfstweight pyxvself  proto $^static pyobject pyxpf0pywrapfst0weight0floatstruct pyxobj0pywrapfstweight pyxvself  proto $^static int pyxpf0pywrapfst0weight0initstruct pyxobj0pywrapfstweight pyxvself pyobject pyxvweighttype pyobject pyxvweight  proto $^static pyobject pyxpf0pywrapfst0weight0copystruct pyxobj0pywrapfstweight pyxvself  proto $^static pyobject pyxpf0pywrapfst0weight00zerocythonunused pytypeobject pyxvcls pyobject pyxvweighttype  proto $^static pyobject pyxpf0pywrapfst0weight00onecythonunused pytypeobject pyxvcls pyobject pyxvweighttype  proto $^static pyobject pyxpf0pywrapfst0weight00noweightcythonunused pytypeobject pyxvcls pyobject pyxvweighttype  proto $^static pyobject pyxpf0pywrapfst0weight00eqstruct pyxobj0pywrapfstweight pyxvw0 struct pyxobj0pywrapfstweight pyxvw0  proto $^static pyobject pyxpf0pywrapfst0weight00nestruct pyxobj0pywrapfstweight pyxvw0 struct pyxobj0pywrapfstweight pyxvw0  proto $^static pyobject pyxpf0pywrapfst0weight00tostringstruct pyxobj0pywrapfstweight pyxvself  proto $^static pyobject pyxpf0pywrapfst0weight00typestruct pyxobj0pywrapfstweight pyxvself  proto $^static pyobject pyxpf0pywrapfst0weight00reducecythoncythonunused struct pyxobj0pywrapfstweight pyxvself  proto $^static pyobject pyxpf0pywrapfst0weight00setstatecythoncythonunused struct pyxobj0pywrapfstweight pyxvself cythonunused pyobject pyxvpyxstate  proto $^static pyobject pyxpf0pywrapfstpluscythonunused pyobject pyxself struct pyxobj0pywrapfstweight pyxvlhs struct pyxobj0pywrapfstweight pyxvrhs  proto $^static pyobject pyxpf0pywrapfst0timescythonunused pyobject pyxself struct pyxobj0pywrapfstweight pyxvlhs struct pyxobj0pywrapfstweight pyxvrhs  proto $^static pyobject pyxpf0pywrapfst0dividecythonunused pyobject pyxself struct pyxobj0pywrapfstweight pyxvlhs struct pyxobj0pywrapfstweight pyxvrhs  proto $^static pyobject pyxpf0pywrapfst0powercythonunused pyobject pyxself struct pyxobj0pywrapfstweight pyxvw sizet pyxvn  proto $^static int pyxpf0pywrapfst00symboltableinitstruct pyxobj0pywrapfstsymboltable pyxvself  proto $^static pyobject pyxpf0pywrapfst00symboltable0iterstruct pyxobj0pywrapfstsymboltable pyxvself  proto $^static pyobject pyxpf0pywrapfst00symboltable0availablekeystruct pyxobj0pywrapfstsymboltable pyxvself  proto $^static pyobject pyxpf0pywrapfst00symboltable0checksumstruct pyxobj0pywrapfstsymboltable pyxvself  proto $^static pyobject pyxpf0pywrapfst00symboltable0copystruct pyxobj0pywrapfstsymboltable pyxvself  proto $^static pyobject pyxpf0pywrapfst00symboltable00findstruct pyxobj0pywrapfstsymboltable pyxvself pyobject pyxvkey  proto $^static pyobject pyxpf0pywrapfst00symboltable00getnthkeystruct pyxobj0pywrapfstsymboltable pyxvself pyssizet pyxvpos  proto $^static pyobject pyxpf0pywrapfst00symboltable00labeledchecksumstruct pyxobj0pywrapfstsymboltable pyxvself  proto $^static pyobject pyxpf0pywrapfst00symboltable00memberstruct pyxobj0pywrapfstsymboltable pyxvself pyobject pyxvkey  proto $^static int pyxpf0pywrapfst00symboltable00containsstruct pyxobj0pywrapfstsymboltable pyxvself pyobject pyxvkey  proto $^static pyobject pyxpf0pywrapfst00symboltable00namestruct pyxobj0pywrapfstsymboltable pyxvself  proto $^static pyobject pyxpf0pywrapfst00symboltable00numsymbolsstruct pyxobj0pywrapfstsymboltable pyxvself  proto $^static pyobject pyxpf0pywrapfst00symboltable00writestruct pyxobj0pywrapfstsymboltable pyxvself pyobject pyxvfilename  proto $^static pyobject pyxpf0pywrapfst00symboltable00writetextstruct pyxobj0pywrapfstsymboltable pyxvself pyobject pyxvfilename  proto $^static pyobject pyxpf0pywrapfst00symboltable00reducecythoncythonunused struct pyxobj0pywrapfstsymboltable pyxvself  proto $^static pyobject pyxpf0pywrapfst00symboltable00setstatecythoncythonunused struct pyxobj0pywrapfstsymboltable pyxvself cythonunused pyobject pyxvpyxstate  proto $^static pyobject pyxpf0pywrapfst00encodemappersymboltablereprstruct pyxobj0pywrapfstencodemappersymboltable pyxvself  proto $^static pyobject pyxpf0pywrapfst00encodemappersymboltable0reducecythoncythonunused struct pyxobj0pywrapfstencodemappersymboltable pyxvself  proto $^static pyobject pyxpf0pywrapfst00encodemappersymboltable0setstatecythoncythonunused struct pyxobj0pywrapfstencodemappersymboltable pyxvself cythonunused pyobject pyxvpyxstate  proto $^static pyobject pyxpf0pywrapfst00fstsymboltablereprstruct pyxobj0pywrapfstfstsymboltable pyxvself  proto $^static pyobject pyxpf0pywrapfst00fstsymboltable0reducecythoncythonunused struct pyxobj0pywrapfstfstsymboltable pyxvself  proto $^static pyobject pyxpf0pywrapfst00fstsymboltable0setstatecythoncythonunused struct pyxobj0pywrapfstfstsymboltable pyxvself cythonunused pyobject pyxvpyxstate  proto $^static pyobject pyxpf0pywrapfst00mutablesymboltableaddsymbolstruct pyxobj0pywrapfstmutablesymboltable pyxvself pyobject pyxvsymbol pyxt00basictypesint00 pyxvkey  proto $^static pyobject pyxpf0pywrapfst00mutablesymboltable0addtablestruct pyxobj0pywrapfstmutablesymboltable pyxvself struct pyxobj0pywrapfstsymboltable pyxvsyms  proto $^static pyobject pyxpf0pywrapfst00mutablesymboltable0setnamestruct pyxobj0pywrapfstmutablesymboltable pyxvself pyobject pyxvnewname  proto $^static pyobject pyxpf0pywrapfst00mutablesymboltable0reducecythoncythonunused struct pyxobj0pywrapfstmutablesymboltable pyxvself  proto $^static pyobject pyxpf0pywrapfst00mutablesymboltable0setstatecythoncythonunused struct pyxobj0pywrapfstmutablesymboltable pyxvself cythonunused pyobject pyxvpyxstate  proto $^static pyobject pyxpf0pywrapfst00mutablefstsymboltablereprstruct pyxobj0pywrapfstmutablefstsymboltable pyxvself  proto $^static pyobject pyxpf0pywrapfst00mutablefstsymboltable0reducecythoncythonunused struct pyxobj0pywrapfstmutablefstsymboltable pyxvself  proto $^static pyobject pyxpf0pywrapfst00mutablefstsymboltable0setstatecythoncythonunused struct pyxobj0pywrapfstmutablefstsymboltable pyxvself cythonunused pyobject pyxvpyxstate  proto $^static pyobject pyxpf0pywrapfst00symboltablereprstruct pyxobj0pywrapfstsymboltable pyxvself  proto $^static int pyxpf0pywrapfst00symboltable0initstruct pyxobj0pywrapfstsymboltable pyxvself pyobject pyxvname  proto $^static pyobject pyxpf0pywrapfst00symboltable0readcythonunused pytypeobject pyxvcls pyobject pyxvfilename  proto $^static pyobject pyxpf0pywrapfst00symboltable0readtextcythonunused pytypeobject pyxvcls pyobject pyxvfilename bool pyxvallownegativelabels  proto $^static pyobject pyxpf0pywrapfst00symboltable0readfstcythonunused pytypeobject pyxvcls pyobject pyxvfilename bool pyxvinputtable  proto $^static pyobject pyxpf0pywrapfst00symboltable00reducecythoncythonunused struct pyxobj0pywrapfstsymboltable pyxvself  proto $^static pyobject pyxpf0pywrapfst00symboltable00setstatecythoncythonunused struct pyxobj0pywrapfstsymboltable pyxvself cythonunused pyobject pyxvpyxstate  proto $^static pyobject pyxpf0pywrapfst0compactsymboltablecythonunused pyobject pyxself struct pyxobj0pywrapfstsymboltable pyxvsyms  proto $^static pyobject pyxpf0pywrapfst00mergesymboltablecythonunused pyobject pyxself struct pyxobj0pywrapfstsymboltable pyxvlhs struct pyxobj0pywrapfstsymboltable pyxvrhs  proto $^static pyobject pyxpf0pywrapfst00symboltableiteratorreprstruct pyxobj0pywrapfstsymboltableiterator pyxvself  proto $^static int pyxpf0pywrapfst00symboltableiterator0initstruct pyxobj0pywrapfstsymboltableiterator pyxvself struct pyxobj0pywrapfstsymboltable pyxvsyms  proto $^static pyobject pyxpf0pywrapfst00symboltableiterator0iterstruct pyxobj0pywrapfstsymboltableiterator pyxvself  proto $^static pyobject pyxpf0pywrapfst00symboltableiterator0nextstruct pyxobj0pywrapfstsymboltableiterator pyxvself  proto $^static pyobject pyxpf0pywrapfst00symboltableiterator0donestruct pyxobj0pywrapfstsymboltableiterator pyxvself  proto $^static pyobject pyxpf0pywrapfst00symboltableiterator00nextstruct pyxobj0pywrapfstsymboltableiterator pyxvself  proto $^static pyobject pyxpf0pywrapfst00symboltableiterator00resetstruct pyxobj0pywrapfstsymboltableiterator pyxvself  proto $^static pyobject pyxpf0pywrapfst00symboltableiterator00symbolstruct pyxobj0pywrapfstsymboltableiterator pyxvself  proto $^static pyobject pyxpf0pywrapfst00symboltableiterator00valuestruct pyxobj0pywrapfstsymboltableiterator pyxvself  proto $^static pyobject pyxpf0pywrapfst00symboltableiterator00reducecythoncythonunused struct pyxobj0pywrapfstsymboltableiterator pyxvself  proto $^static pyobject pyxpf0pywrapfst00symboltableiterator00setstatecythoncythonunused struct pyxobj0pywrapfstsymboltableiterator pyxvself cythonunused pyobject pyxvpyxstate  proto $^static pyobject pyxpf0pywrapfst00encodemapperreprstruct pyxobj0pywrapfstencodemapper pyxvself  proto $^static int pyxpf0pywrapfst00encodemapper0initstruct pyxobj0pywrapfstencodemapper pyxvself pyobject pyxvarctype bool pyxvencodelabels bool pyxvencodeweights  proto $^static pyobject pyxpf0pywrapfst00encodemapper0arctypestruct pyxobj0pywrapfstencodemapper pyxvself  proto $^static pyobject pyxpf0pywrapfst00encodemapper0callstruct pyxobj0pywrapfstencodemapper pyxvself struct pyxobj0pywrapfstarc pyxvarc  proto $^static pyobject pyxpf0pywrapfst00encodemapper0flagsstruct pyxobj0pywrapfstencodemapper pyxvself  proto $^static pyobject pyxpf0pywrapfst00encodemapper00inputsymbolsstruct pyxobj0pywrapfstencodemapper pyxvself  proto $^static pyobject pyxpf0pywrapfst00encodemapper00outputsymbolsstruct pyxobj0pywrapfstencodemapper pyxvself  proto $^static pyobject pyxpf0pywrapfst00encodemapper00propertiesstruct pyxobj0pywrapfstencodemapper pyxvself pyxt00basictypesuint00 pyxvmask  proto $^static pyobject pyxpf0pywrapfst00encodemapper00setinputsymbolsstruct pyxobj0pywrapfstencodemapper pyxvself struct pyxobj0pywrapfstsymboltable pyxvsyms  proto $^static pyobject pyxpf0pywrapfst00encodemapper00setoutputsymbolsstruct pyxobj0pywrapfstencodemapper pyxvself struct pyxobj0pywrapfstsymboltable pyxvsyms  proto $^static pyobject pyxpf0pywrapfst00encodemapper00weighttypestruct pyxobj0pywrapfstencodemapper pyxvself  proto $^static pyobject pyxpf0pywrapfst00encodemapper00reducecythoncythonunused struct pyxobj0pywrapfstencodemapper pyxvself  proto $^static pyobject pyxpf0pywrapfst00encodemapper00setstatecythoncythonunused struct pyxobj0pywrapfstencodemapper pyxvself cythonunused pyobject pyxvpyxstate  proto $^static pyobject pyxpf0pywrapfst0fstreprsvgstruct pyxobj0pywrapfstfst pyxvself  proto $^static pyobject pyxpf0pywrapfst0fst0reprstruct pyxobj0pywrapfstfst pyxvself  proto $^static int pyxpf0pywrapfst0fst0initstruct pyxobj0pywrapfstfst pyxvself  proto $^static pyobject pyxpf0pywrapfst0fst0strstruct pyxobj0pywrapfstfst pyxvself  proto $^static pyobject pyxpf0pywrapfst0fst0reducestruct pyxobj0pywrapfstfst pyxvself  proto $^static pyobject pyxpf0pywrapfst0fst00arctypestruct pyxobj0pywrapfstfst pyxvself  proto $^static pyobject pyxpf0pywrapfst0fst00arcsstruct pyxobj0pywrapfstfst pyxvself pyxt00basictypesint00 pyxvstate  proto $^static pyobject pyxpf0pywrapfst0fst00copystruct pyxobj0pywrapfstfst pyxvself  proto $^static pyobject pyxpf0pywrapfst0fst00drawstruct pyxobj0pywrapfstfst pyxvself pyobject pyxvfilename struct pyxobj0pywrapfstsymboltable pyxvisymbols struct pyxobj0pywrapfstsymboltable pyxvosymbols struct pyxobj0pywrapfstsymboltable pyxvssymbols bool pyxvacceptor pyobject pyxvtitle double pyxvwidth double pyxvheight bool pyxvportrait bool pyxvvertical double pyxvranksep double pyxvnodesep pyxt00basictypesint00 pyxvfontsize pyxt00basictypesint00 pyxvprecision pyobject pyxvfloatformat bool pyxvshowweightone  proto $^static pyobject pyxpf0pywrapfst0fst00finalstruct pyxobj0pywrapfstfst pyxvself pyxt00basictypesint00 pyxvstate  proto $^static pyobject pyxpf0pywrapfst0fst00fsttypestruct pyxobj0pywrapfstfst pyxvself  proto $^static pyobject pyxpf0pywrapfst0fst00inputsymbolsstruct pyxobj0pywrapfstfst pyxvself  proto $^static pyobject pyxpf0pywrapfst0fst00numarcsstruct pyxobj0pywrapfstfst pyxvself pyxt00basictypesint00 pyxvstate  proto $^static pyobject pyxpf0pywrapfst0fst00numinputepsilonsstruct pyxobj0pywrapfstfst pyxvself pyxt00basictypesint00 pyxvstate  proto $^static pyobject pyxpf0pywrapfst0fst00numoutputepsilonsstruct pyxobj0pywrapfstfst pyxvself pyxt00basictypesint00 pyxvstate  proto $^static pyobject pyxpf0pywrapfst0fst00outputsymbolsstruct pyxobj0pywrapfstfst pyxvself  proto $^static pyobject pyxpf0pywrapfst0fst00propertiesstruct pyxobj0pywrapfstfst pyxvself pyxt00basictypesuint00 pyxvmask bool pyxvtest  proto $^static pyobject pyxpf0pywrapfst0fst00startstruct pyxobj0pywrapfstfst pyxvself  proto $^static pyobject pyxpf0pywrapfst0fst00statesstruct pyxobj0pywrapfstfst pyxvself  proto $^static pyobject pyxpf0pywrapfst0fst00textstruct pyxobj0pywrapfstfst pyxvself struct pyxobj0pywrapfstsymboltable pyxvisymbols struct pyxobj0pywrapfstsymboltable pyxvosymbols struct pyxobj0pywrapfstsymboltable pyxvssymbols bool pyxvacceptor bool pyxvshowweightone pyobject pyxvmissingsym  proto $^static pyobject pyxpf0pywrapfst0fst00verifystruct pyxobj0pywrapfstfst pyxvself  proto $^static pyobject pyxpf0pywrapfst0fst00weighttypestruct pyxobj0pywrapfstfst pyxvself  proto $^static pyobject pyxpf0pywrapfst0fst00writestruct pyxobj0pywrapfstfst pyxvself pyobject pyxvfilename  proto $^static pyobject pyxpf0pywrapfst0fst00writetostringstruct pyxobj0pywrapfstfst pyxvself  proto $^static pyobject pyxpf0pywrapfst00mutablefstaddarcstruct pyxobj0pywrapfstmutablefst pyxvself pyxt00basictypesint00 pyxvstate struct pyxobj0pywrapfstarc pyxvarc  proto $^static pyobject pyxpf0pywrapfst00mutablefst0addstatestruct pyxobj0pywrapfstmutablefst pyxvself  proto $^static pyobject pyxpf0pywrapfst00mutablefst0arcsortstruct pyxobj0pywrapfstmutablefst pyxvself pyobject pyxvsorttype  proto $^static pyobject pyxpf0pywrapfst00mutablefst0closurestruct pyxobj0pywrapfstmutablefst pyxvself bool pyxvclosureplus  proto $^static pyobject pyxpf0pywrapfst00mutablefst0concatstruct pyxobj0pywrapfstmutablefst pyxvself struct pyxobj0pywrapfstfst pyxvifst  proto $^static pyobject pyxpf0pywrapfst00mutablefst00connectstruct pyxobj0pywrapfstmutablefst pyxvself  proto $^static pyobject pyxpf0pywrapfst00mutablefst00decodestruct pyxobj0pywrapfstmutablefst pyxvself struct pyxobj0pywrapfstencodemapper pyxvencoder  proto $^static pyobject pyxpf0pywrapfst00mutablefst00deletearcsstruct pyxobj0pywrapfstmutablefst pyxvself pyxt00basictypesint00 pyxvstate sizet pyxvn  proto $^static pyobject pyxpf0pywrapfst00mutablefst00deletestatesstruct pyxobj0pywrapfstmutablefst pyxvself pyobject pyxvstates  proto $^static pyobject pyxpf0pywrapfst00mutablefst00encodestruct pyxobj0pywrapfstmutablefst pyxvself struct pyxobj0pywrapfstencodemapper pyxvencoder  proto $^static pyobject pyxpf0pywrapfst00mutablefst00invertstruct pyxobj0pywrapfstmutablefst pyxvself  proto $^static pyobject pyxpf0pywrapfst00mutablefst00minimizestruct pyxobj0pywrapfstmutablefst pyxvself float pyxvdelta bool pyxvallownondet  proto $^static pyobject pyxpf0pywrapfst00mutablefst00mutablearcsstruct pyxobj0pywrapfstmutablefst pyxvself pyxt00basictypesint00 pyxvstate  proto $^static pyobject pyxpf0pywrapfst00mutablefst00mutableinputsymbolsstruct pyxobj0pywrapfstmutablefst pyxvself  proto $^static pyobject pyxpf0pywrapfst00mutablefst00mutableoutputsymbolsstruct pyxobj0pywrapfstmutablefst pyxvself  proto $^static pyobject pyxpf0pywrapfst00mutablefst00numstatesstruct pyxobj0pywrapfstmutablefst pyxvself  proto $^static pyobject pyxpf0pywrapfst00mutablefst00projectstruct pyxobj0pywrapfstmutablefst pyxvself bool pyxvprojectoutput  proto $^static pyobject pyxpf0pywrapfst00mutablefst00prunestruct pyxobj0pywrapfstmutablefst pyxvself float pyxvdelta pyxt00basictypesint00 pyxvnstate pyobject pyxvweight  proto $^static pyobject pyxpf0pywrapfst00mutablefst00pushstruct pyxobj0pywrapfstmutablefst pyxvself float pyxvdelta bool pyxvremovetotalweight bool pyxvtofinal  proto $^static pyobject pyxpf0pywrapfst00mutablefst00relabelpairsstruct pyxobj0pywrapfstmutablefst pyxvself pyobject pyxvipairs pyobject pyxvopairs  proto $^static pyobject pyxpf0pywrapfst00mutablefst00relabeltablesstruct pyxobj0pywrapfstmutablefst pyxvself struct pyxobj0pywrapfstsymboltable pyxvoldisymbols struct pyxobj0pywrapfstsymboltable pyxvnewisymbols pyobject pyxvunknownisymbol bool pyxvattachnewisymbols struct pyxobj0pywrapfstsymboltable pyxvoldosymbols struct pyxobj0pywrapfstsymboltable pyxvnewosymbols pyobject pyxvunknownosymbol bool pyxvattachnewosymbols  proto $^static pyobject pyxpf0pywrapfst00mutablefst00reservearcsstruct pyxobj0pywrapfstmutablefst pyxvself pyxt00basictypesint00 pyxvstate sizet pyxvn  proto $^static pyobject pyxpf0pywrapfst00mutablefst00reservestatesstruct pyxobj0pywrapfstmutablefst pyxvself pyxt00basictypesint00 pyxvn  proto $^static pyobject pyxpf0pywrapfst00mutablefst00reweightstruct pyxobj0pywrapfstmutablefst pyxvself pyobject pyxvpotentials bool pyxvtofinal  proto $^static pyobject pyxpf0pywrapfst00mutablefst00rmepsilonstruct pyxobj0pywrapfstmutablefst pyxvself pyobject pyxvqueuetype bool pyxvconnect pyobject pyxvweight pyxt00basictypesint00 pyxvnstate float pyxvdelta  proto $^static pyobject pyxpf0pywrapfst00mutablefst00setfinalstruct pyxobj0pywrapfstmutablefst pyxvself pyxt00basictypesint00 pyxvstate pyobject pyxvweight  proto $^static pyobject pyxpf0pywrapfst00mutablefst00setinputsymbolsstruct pyxobj0pywrapfstmutablefst pyxvself struct pyxobj0pywrapfstsymboltable pyxvsyms  proto $^static pyobject pyxpf0pywrapfst00mutablefst00setoutputsymbolsstruct pyxobj0pywrapfstmutablefst pyxvself struct pyxobj0pywrapfstsymboltable pyxvsyms  proto $^static pyobject pyxpf0pywrapfst00mutablefst00setpropertiesstruct pyxobj0pywrapfstmutablefst pyxvself pyxt00basictypesuint00 pyxvprops pyxt00basictypesuint00 pyxvmask  proto $^static pyobject pyxpf0pywrapfst00mutablefst00setstartstruct pyxobj0pywrapfstmutablefst pyxvself pyxt00basictypesint00 pyxvstate  proto $^static pyobject pyxpf0pywrapfst00mutablefst00topsortstruct pyxobj0pywrapfstmutablefst pyxvself  proto $^static pyobject pyxpf0pywrapfst00mutablefst00unionstruct pyxobj0pywrapfstmutablefst pyxvself struct pyxobj0pywrapfstfst pyxvifst  proto $^static pyobject pyxpf0pywrapfst00readcythonunused pyobject pyxself pyobject pyxvfilename  proto $^static pyobject pyxpf0pywrapfst00readfromstringcythonunused pyobject pyxself pyobject pyxvstate  proto $^static pyobject pyxpf0pywrapfst0fstnewcythonunused pyobject pyxself cythonunused pyobject pyxvcls pyobject pyxvarctype  proto $^static pyobject pyxpf0pywrapfst0fst0readcythonunused pyobject pyxself pyobject pyxvfilename  proto $^static pyobject pyxpf0pywrapfst0fst0readfromstringcythonunused pyobject pyxself pyobject pyxvstate  proto $^static pyobject pyxpf0pywrapfst0arcreprstruct pyxobj0pywrapfstarc pyxvself  proto $^static int pyxpf0pywrapfst0arc0initstruct pyxobj0pywrapfstarc pyxvself pyxt00basictypesint00 pyxvilabel pyxt00basictypesint00 pyxvolabel pyobject pyxvweight pyxt00basictypesint00 pyxvnextstate  proto $^static pyobject pyxpf0pywrapfst0arc0copystruct pyxobj0pywrapfstarc pyxvself  proto $^static pyobject pyxpf0pywrapfst0arc0ilabelgetstruct pyxobj0pywrapfstarc pyxvself  proto $^static int pyxpf0pywrapfst0arc0ilabel0setstruct pyxobj0pywrapfstarc pyxvself pyxt00basictypesint00 pyxvvalue  proto $^static pyobject pyxpf0pywrapfst0arc0olabelgetstruct pyxobj0pywrapfstarc pyxvself  proto $^static int pyxpf0pywrapfst0arc0olabel0setstruct pyxobj0pywrapfstarc pyxvself pyxt00basictypesint00 pyxvvalue  proto $^static pyobject pyxpf0pywrapfst0arc0weightgetstruct pyxobj0pywrapfstarc pyxvself  proto $^static int pyxpf0pywrapfst0arc0weight0setstruct pyxobj0pywrapfstarc pyxvself pyobject pyxvweight  proto $^static pyobject pyxpf0pywrapfst0arc0nextstategetstruct pyxobj0pywrapfstarc pyxvself  proto $^static int pyxpf0pywrapfst0arc0nextstate0setstruct pyxobj0pywrapfstarc pyxvself pyxt00basictypesint00 pyxvvalue  proto $^static pyobject pyxpf0pywrapfst0arc0reducecythoncythonunused struct pyxobj0pywrapfstarc pyxvself  proto $^static pyobject pyxpf0pywrapfst0arc0setstatecythoncythonunused struct pyxobj0pywrapfstarc pyxvself cythonunused pyobject pyxvpyxstate  proto $^static pyobject pyxpf0pywrapfst00arciteratorreprstruct pyxobj0pywrapfstarciterator pyxvself  proto $^static int pyxpf0pywrapfst00arciterator0initstruct pyxobj0pywrapfstarciterator pyxvself struct pyxobj0pywrapfstfst pyxvifst pyxt00basictypesint00 pyxvstate  proto $^static pyobject pyxpf0pywrapfst00arciterator0iterstruct pyxobj0pywrapfstarciterator pyxvself  proto $^static pyobject pyxpf0pywrapfst00arciterator0nextstruct pyxobj0pywrapfstarciterator pyxvself  proto $^static pyobject pyxpf0pywrapfst00arciterator0donestruct pyxobj0pywrapfstarciterator pyxvself  proto $^static pyobject pyxpf0pywrapfst00arciterator00flagsstruct pyxobj0pywrapfstarciterator pyxvself  proto $^static pyobject pyxpf0pywrapfst00arciterator00nextstruct pyxobj0pywrapfstarciterator pyxvself  proto $^static pyobject pyxpf0pywrapfst00arciterator00positionstruct pyxobj0pywrapfstarciterator pyxvself  proto $^static pyobject pyxpf0pywrapfst00arciterator00resetstruct pyxobj0pywrapfstarciterator pyxvself  proto $^static pyobject pyxpf0pywrapfst00arciterator00seekstruct pyxobj0pywrapfstarciterator pyxvself sizet pyxva  proto $^static pyobject pyxpf0pywrapfst00arciterator00setflagsstruct pyxobj0pywrapfstarciterator pyxvself pyxt00basictypesuint00 pyxvflags pyxt00basictypesuint00 pyxvmask  proto $^static pyobject pyxpf0pywrapfst00arciterator00valuestruct pyxobj0pywrapfstarciterator pyxvself  proto $^static pyobject pyxpf0pywrapfst00arciterator00reducecythoncythonunused struct pyxobj0pywrapfstarciterator pyxvself  proto $^static pyobject pyxpf0pywrapfst00arciterator00setstatecythoncythonunused struct pyxobj0pywrapfstarciterator pyxvself cythonunused pyobject pyxvpyxstate  proto $^static pyobject pyxpf0pywrapfst00mutablearciteratorreprstruct pyxobj0pywrapfstmutablearciterator pyxvself  proto $^static int pyxpf0pywrapfst00mutablearciterator0initstruct pyxobj0pywrapfstmutablearciterator pyxvself struct pyxobj0pywrapfstmutablefst pyxvifst pyxt00basictypesint00 pyxvstate  proto $^static pyobject pyxpf0pywrapfst00mutablearciterator0donestruct pyxobj0pywrapfstmutablearciterator pyxvself  proto $^static pyobject pyxpf0pywrapfst00mutablearciterator0flagsstruct pyxobj0pywrapfstmutablearciterator pyxvself  proto $^static pyobject pyxpf0pywrapfst00mutablearciterator0nextstruct pyxobj0pywrapfstmutablearciterator pyxvself  proto $^static pyobject pyxpf0pywrapfst00mutablearciterator00positionstruct pyxobj0pywrapfstmutablearciterator pyxvself  proto $^static pyobject pyxpf0pywrapfst00mutablearciterator00resetstruct pyxobj0pywrapfstmutablearciterator pyxvself  proto $^static pyobject pyxpf0pywrapfst00mutablearciterator00seekstruct pyxobj0pywrapfstmutablearciterator pyxvself sizet pyxva  proto $^static pyobject pyxpf0pywrapfst00mutablearciterator00setflagsstruct pyxobj0pywrapfstmutablearciterator pyxvself pyxt00basictypesuint00 pyxvflags pyxt00basictypesuint00 pyxvmask  proto $^static pyobject pyxpf0pywrapfst00mutablearciterator00setvaluestruct pyxobj0pywrapfstmutablearciterator pyxvself struct pyxobj0pywrapfstarc pyxvarc  proto $^static pyobject pyxpf0pywrapfst00mutablearciterator00valuestruct pyxobj0pywrapfstmutablearciterator pyxvself  proto $^static pyobject pyxpf0pywrapfst00mutablearciterator00reducecythoncythonunused struct pyxobj0pywrapfstmutablearciterator pyxvself  proto $^static pyobject pyxpf0pywrapfst00mutablearciterator00setstatecythoncythonunused struct pyxobj0pywrapfstmutablearciterator pyxvself cythonunused pyobject pyxvpyxstate  proto $^static pyobject pyxpf0pywrapfst00stateiteratorreprstruct pyxobj0pywrapfststateiterator pyxvself  proto $^static int pyxpf0pywrapfst00stateiterator0initstruct pyxobj0pywrapfststateiterator pyxvself struct pyxobj0pywrapfstfst pyxvifst  proto $^static pyobject pyxpf0pywrapfst00stateiterator0iterstruct pyxobj0pywrapfststateiterator pyxvself  proto $^static pyobject pyxpf0pywrapfst00stateiterator0nextstruct pyxobj0pywrapfststateiterator pyxvself  proto $^static pyobject pyxpf0pywrapfst00stateiterator0donestruct pyxobj0pywrapfststateiterator pyxvself  proto $^static pyobject pyxpf0pywrapfst00stateiterator00nextstruct pyxobj0pywrapfststateiterator pyxvself  proto $^static pyobject pyxpf0pywrapfst00stateiterator00resetstruct pyxobj0pywrapfststateiterator pyxvself  proto $^static pyobject pyxpf0pywrapfst00stateiterator00valuestruct pyxobj0pywrapfststateiterator pyxvself  proto $^static pyobject pyxpf0pywrapfst00stateiterator00reducecythoncythonunused struct pyxobj0pywrapfststateiterator pyxvself  proto $^static pyobject pyxpf0pywrapfst00stateiterator00setstatecythoncythonunused struct pyxobj0pywrapfststateiterator pyxvself cythonunused pyobject pyxvpyxstate  proto $^static pyobject pyxpf0pywrapfst00arcmapcythonunused pyobject pyxself struct pyxobj0pywrapfstfst pyxvifst float pyxvdelta pyobject pyxvmaptype double pyxvpower pyobject pyxvweight  proto $^static pyobject pyxpf0pywrapfst00composecythonunused pyobject pyxself struct pyxobj0pywrapfstfst pyxvifst0 struct pyxobj0pywrapfstfst pyxvifst0 pyobject pyxvcomposefilter bool pyxvconnect  proto $^static pyobject pyxpf0pywrapfst00convertcythonunused pyobject pyxself struct pyxobj0pywrapfstfst pyxvifst pyobject pyxvfsttype  proto $^static pyobject pyxpf0pywrapfst00determinizecythonunused pyobject pyxself struct pyxobj0pywrapfstfst pyxvifst float pyxvdelta pyobject pyxvdettype pyxt00basictypesint00 pyxvnstate pyxt00basictypesint00 pyxvsubsequentiallabel pyobject pyxvweight bool pyxvincrementsubsequentiallabel  proto $^static pyobject pyxpf0pywrapfst00differencecythonunused pyobject pyxself struct pyxobj0pywrapfstfst pyxvifst0 struct pyxobj0pywrapfstfst pyxvifst0 pyobject pyxvcomposefilter bool pyxvconnect  proto $^static pyobject pyxpf0pywrapfst00disambiguatecythonunused pyobject pyxself struct pyxobj0pywrapfstfst pyxvifst float pyxvdelta pyxt00basictypesint00 pyxvnstate pyxt00basictypesint00 pyxvsubsequentiallabel pyobject pyxvweight  proto $^static pyobject pyxpf0pywrapfst00epsnormalizecythonunused pyobject pyxself struct pyxobj0pywrapfstfst pyxvifst bool pyxvepsnormoutput  proto $^static pyobject pyxpf0pywrapfst00equalcythonunused pyobject pyxself struct pyxobj0pywrapfstfst pyxvifst0 struct pyxobj0pywrapfstfst pyxvifst0 float pyxvdelta  proto $^static pyobject pyxpf0pywrapfst00equivalentcythonunused pyobject pyxself struct pyxobj0pywrapfstfst pyxvifst0 struct pyxobj0pywrapfstfst pyxvifst0 float pyxvdelta  proto $^static pyobject pyxpf0pywrapfst00intersectcythonunused pyobject pyxself struct pyxobj0pywrapfstfst pyxvifst0 struct pyxobj0pywrapfstfst pyxvifst0 pyobject pyxvcomposefilter bool pyxvconnect  proto $^static pyobject pyxpf0pywrapfst00isomorphiccythonunused pyobject pyxself struct pyxobj0pywrapfstfst pyxvifst0 struct pyxobj0pywrapfstfst pyxvifst0 float pyxvdelta  proto $^static pyobject pyxpf0pywrapfst00prunecythonunused pyobject pyxself struct pyxobj0pywrapfstfst pyxvifst float pyxvdelta pyxt00basictypesint00 pyxvnstate pyobject pyxvweight  proto $^static pyobject pyxpf0pywrapfst00pushcythonunused pyobject pyxself struct pyxobj0pywrapfstfst pyxvifst float pyxvdelta bool pyxvpushweights bool pyxvpushlabels bool pyxvremovecommonaffix bool pyxvremovetotalweight bool pyxvtofinal  proto $^static pyobject pyxpf0pywrapfst00randequivalentcythonunused pyobject pyxself struct pyxobj0pywrapfstfst pyxvifst0 struct pyxobj0pywrapfstfst pyxvifst0 pyxt00basictypesint00 pyxvnpath float pyxvdelta timet pyxvseed pyobject pyxvselect pyxt00basictypesint00 pyxvmaxlength  proto $^static pyobject pyxpf0pywrapfst00randgencythonunused pyobject pyxself struct pyxobj0pywrapfstfst pyxvifst pyxt00basictypesint00 pyxvnpath timet pyxvseed pyobject pyxvselect pyxt00basictypesint00 pyxvmaxlength bool pyxvweighted bool pyxvremovetotalweight  proto $^static pyobject pyxpf0pywrapfst00replacecythonunused pyobject pyxself pyobject pyxvpairs pyobject pyxvcallarclabeling pyobject pyxvreturnarclabeling bool pyxvepsilononreplace pyxt00basictypesint00 pyxvreturnlabel  proto $^static pyobject pyxpf0pywrapfst00reversecythonunused pyobject pyxself struct pyxobj0pywrapfstfst pyxvifst bool pyxvrequiresuperinitial  proto $^static pyobject pyxpf0pywrapfst00shortestdistancecythonunused pyobject pyxself struct pyxobj0pywrapfstfst pyxvifst float pyxvdelta pyxt00basictypesint00 pyxvnstate pyobject pyxvqueuetype bool pyxvreverse  proto $^static pyobject pyxpf0pywrapfst00shortestpathcythonunused pyobject pyxself struct pyxobj0pywrapfstfst pyxvifst float pyxvdelta pyxt00basictypesint00 pyxvnshortest pyxt00basictypesint00 pyxvnstate pyobject pyxvqueuetype bool pyxvunique pyobject pyxvweight  proto $^static pyobject pyxpf0pywrapfst00statemapcythonunused pyobject pyxself struct pyxobj0pywrapfstfst pyxvifst pyobject pyxvmaptype  proto $^static pyobject pyxpf0pywrapfst00synchronizecythonunused pyobject pyxself struct pyxobj0pywrapfstfst pyxvifst  proto $^static int pyxpf0pywrapfst0compilercinitstruct pyxobj0pywrapfstcompiler pyxvself stdstring pyxvfsttype stdstring pyxvarctype struct pyxobj0pywrapfstsymboltable pyxvisymbols struct pyxobj0pywrapfstsymboltable pyxvosymbols struct pyxobj0pywrapfstsymboltable pyxvssymbols bool pyxvacceptor bool pyxvkeepisymbols bool pyxvkeeposymbols bool pyxvkeepstatenumbering bool pyxvallownegativelabels  proto $^static pyobject pyxpf0pywrapfst0compiler0compilestruct pyxobj0pywrapfstcompiler pyxvself  proto $^static pyobject pyxpf0pywrapfst0compiler0writestruct pyxobj0pywrapfstcompiler pyxvself pyobject pyxvexpression  proto $^static pyobject pyxpf0pywrapfst0compiler0reducecythoncythonunused struct pyxobj0pywrapfstcompiler pyxvself  proto $^static pyobject pyxpf0pywrapfst0compiler0setstatecythoncythonunused struct pyxobj0pywrapfstcompiler pyxvself cythonunused pyobject pyxvpyxstate  proto $^static int pyxpf0pywrapfst0farreaderinitstruct pyxobj0pywrapfstfarreader pyxvself  proto $^static pyobject pyxpf0pywrapfst0farreader0reprstruct pyxobj0pywrapfstfarreader pyxvself  proto $^static pyobject pyxpf0pywrapfst0farreader0opencythonunused pytypeobject pyxvcls pyobject pyxvfilenames  proto $^static pyobject pyxpf0pywrapfst0farreader0arctypestruct pyxobj0pywrapfstfarreader pyxvself  proto $^static pyobject pyxpf0pywrapfst0farreader0donestruct pyxobj0pywrapfstfarreader pyxvself  proto $^static pyobject pyxpf0pywrapfst0farreader00errorstruct pyxobj0pywrapfstfarreader pyxvself  proto $^static pyobject pyxpf0pywrapfst0farreader00fartypestruct pyxobj0pywrapfstfarreader pyxvself  proto $^static pyobject pyxpf0pywrapfst0farreader00findstruct pyxobj0pywrapfstfarreader pyxvself pyobject pyxvkey  proto $^static pyobject pyxpf0pywrapfst0farreader00getfststruct pyxobj0pywrapfstfarreader pyxvself  proto $^static pyobject pyxpf0pywrapfst0farreader00getkeystruct pyxobj0pywrapfstfarreader pyxvself  proto $^static pyobject pyxpf0pywrapfst0farreader00nextstruct pyxobj0pywrapfstfarreader pyxvself  proto $^static pyobject pyxpf0pywrapfst0farreader00resetstruct pyxobj0pywrapfstfarreader pyxvself  proto $^static pyobject pyxpf0pywrapfst0farreader00getitemstruct pyxobj0pywrapfstfarreader pyxvself pyobject pyxvkey  proto $^static pyobject pyxpf0pywrapfst0farreader00reducecythoncythonunused struct pyxobj0pywrapfstfarreader pyxvself  proto $^static pyobject pyxpf0pywrapfst0farreader00setstatecythoncythonunused struct pyxobj0pywrapfstfarreader pyxvself cythonunused pyobject pyxvpyxstate  proto $^static int pyxpf0pywrapfst0farwriterinitstruct pyxobj0pywrapfstfarwriter pyxvself  proto $^static pyobject pyxpf0pywrapfst0farwriter0reprstruct pyxobj0pywrapfstfarwriter pyxvself  proto $^static pyobject pyxpf0pywrapfst0farwriter0createcythonunused pytypeobject pyxvcls pyobject pyxvfilename pyobject pyxvarctype pyobject pyxvfartype  proto $^static pyobject pyxpf0pywrapfst0farwriter0addstruct pyxobj0pywrapfstfarwriter pyxvself pyobject pyxvkey struct pyxobj0pywrapfstfst pyxvifst  proto $^static pyobject pyxpf0pywrapfst0farwriter0arctypestruct pyxobj0pywrapfstfarwriter pyxvself  proto $^static pyobject pyxpf0pywrapfst0farwriter00errorstruct pyxobj0pywrapfstfarwriter pyxvself  proto $^static pyobject pyxpf0pywrapfst0farwriter00fartypestruct pyxobj0pywrapfstfarwriter pyxvself  proto $^static int pyxpf0pywrapfst0farwriter00setitemstruct pyxobj0pywrapfstfarwriter pyxvself pyobject pyxvkey struct pyxobj0pywrapfstfst pyxvfst  proto $^static pyobject pyxpf0pywrapfst0farwriter00reducecythoncythonunused struct pyxobj0pywrapfstfarwriter pyxvself  proto $^static pyobject pyxpf0pywrapfst0farwriter00setstatecythoncythonunused struct pyxobj0pywrapfstfarwriter pyxvself cythonunused pyobject pyxvpyxstate  proto $^static pyobject pyxpf0pywrapfst00resetfsterrorfatalcythonunused pyobject pyxself  proto $^static pyobject pyxtpnew0pywrapfstweightpytypeobject t pyobject a pyobject k proto$^static pyobject pyxtpnew0pywrapfstsymboltablepytypeobject t pyobject a pyobject k proto$^static pyobject pyxtpnew0pywrapfstencodemappersymboltablepytypeobject t pyobject a pyobject k proto$^static pyobject pyxtpnew0pywrapfstfstsymboltablepytypeobject t pyobject a pyobject k proto$^static pyobject pyxtpnew0pywrapfstmutablesymboltablepytypeobject t pyobject a pyobject k proto$^static pyobject pyxtpnew0pywrapfstmutablefstsymboltablepytypeobject t pyobject a pyobject k proto$^static pyobject pyxtpnew0pywrapfstsymboltablepytypeobject t pyobject a pyobject k proto$^static pyobject pyxtpnew0pywrapfstsymboltableiteratorpytypeobject t pyobject a pyobject k proto$^static pyobject pyxtpnew0pywrapfstencodemapperpytypeobject t pyobject a pyobject k proto$^static pyobject pyxtpnew0pywrapfstfstpytypeobject t pyobject a pyobject k proto$^static pyobject pyxtpnew0pywrapfstmutablefstpytypeobject t pyobject a pyobject k proto$^static pyobject pyxtpnew0pywrapfstarcpytypeobject t pyobject a pyobject k proto$^static pyobject pyxtpnew0pywrapfstarciteratorpytypeobject t pyobject a pyobject k proto$^static pyobject pyxtpnew0pywrapfstmutablearciteratorpytypeobject t pyobject a pyobject k proto$^static pyobject pyxtpnew0pywrapfststateiteratorpytypeobject t pyobject a pyobject k proto$^static pyobject pyxtpnew0pywrapfstcompilerpytypeobject t pyobject a pyobject k proto$^static pyobject pyxtpnew0pywrapfstfarreaderpytypeobject t pyobject a pyobject k proto$^static pyobject pyxtpnew0pywrapfstfarwriterpytypeobject t pyobject a pyobject k proto$^static pyobject pyxint0$^static pyobject pyxintneg0$^static pyxt00basictypesint00 pyxk00$^static float pyxk00$^static float pyxk00$^static float pyxk00$^static pyxt00basictypesint00 pyxk00$^static float pyxk00$^static pyxt00basictypesint00 pyxk00$^static float pyxk00$^static float pyxk00$^static pyxt00basictypesint00 pyxk00$^static float pyxk00$^static pyxt00basictypesint00 pyxk00$^static float pyxk00$^static float pyxk00$^static float pyxk00$^static float pyxk00$^static pyxt00basictypesint00 pyxk00$^static float pyxk00$^static pyxt00basictypesint00 pyxk00$^static float pyxk00$^static float pyxk00$^static float pyxk00$^static float pyxk00$^static pyxt00basictypesint00 pyxk00$^static float pyxk00$^static float pyxk00$^static pyxt00basictypesint00 pyxk00$^static pyxt00basictypesint00 pyxk00$^static float pyxk00$^static pyxt00basictypesint00 pyxk00$^static float pyxk00$^static pyxt00basictypesint00 pyxk00$^static float pyxk00$^static pyxt00basictypesint00 pyxk00$^static stdstring pyxk00$^static stdstring pyxk00$^static pyobject pyxtuple$^static pyobject pyxtuple0$^static pyobject pyxtuple0$^static pyobject pyxtuple0$^static pyobject pyxtuple0$^static pyobject pyxtuple0$^static pyobject pyxtuple0$^static pyobject pyxtuple0$^static pyobject pyxtuple0$^static pyobject pyxtuple00$^static pyobject pyxtuple00$^static pyobject pyxtuple00$^static pyobject pyxtuple00$^static pyobject pyxtuple00$^static pyobject pyxtuple00$^static pyobject pyxtuple00$^static pyobject pyxtuple00$^static pyobject pyxtuple00$^static pyobject pyxtuple00$^static pyobject pyxtuple00$^static pyobject pyxtuple00$^static pyobject pyxtuple00$^static pyobject pyxtuple00$^static pyobject pyxtuple00$^static pyobject pyxtuple00$^static pyobject pyxtuple00$^static pyobject pyxtuple00$^static pyobject pyxtuple00$^static pyobject pyxtuple00$^static pyobject pyxtuple00$^static pyobject pyxtuple00$^static pyobject pyxtuple00$^static pyobject pyxtuple00$^static pyobject pyxtuple00$^static pyobject pyxtuple00$^static pyobject pyxtuple00$^static pyobject pyxtuple00$^static pyobject pyxtuple00$^static pyobject pyxtuple00$^static pyobject pyxtuple00$^static pyobject pyxtuple00$^static pyobject pyxtuple00$^static pyobject pyxtuple00$^static pyobject pyxtuple00$^static pyobject pyxtuple00$^static pyobject pyxtuple00$^static pyobject pyxtuple00$^static pyobject pyxtuple00$^static pyobject pyxtuple00$^static pyobject pyxtuple00$^static pyobject pyxtuple00$^static pyobject pyxtuple00$^static pyobject pyxtuple00$^static pyobject pyxtuple00$^static pyobject pyxtuple00$^static pyobject pyxtuple00$^static pyobject pyxtuple00$^static pyobject pyxtuple00$^static pyobject pyxtuple00$^static pyobject pyxtuple00$^static pyobject pyxtuple00$^static pyobject pyxtuple00$^static pyobject pyxtuple000$^static pyobject pyxtuple000$^static pyobject pyxtuple000$^static pyobject pyxtuple000$^static pyobject pyxtuple000$^static pyobject pyxtuple000$^static pyobject pyxtuple000$^static pyobject pyxtuple000$^static pyobject pyxtuple000$^static pyobject pyxcodeobj000$^static pyobject pyxcodeobj000$^static pyobject pyxcodeobj000$^static pyobject pyxcodeobj000$^static pyobject pyxcodeobj000$^static pyobject pyxcodeobj000$^static pyobject pyxcodeobj000$^static pyobject pyxcodeobj000$^static pyobject pyxcodeobj000$^$^ pywrapfst.pyx000$^  $^  $^  cdef string tostringdata encodingutf0 except               $^    converts strings to bytestrings.$^  $^ $^$^static stdstring pyxf0pywrapfsttostringpyobject pyxvdata struct pyxoptargs0pywrapfsttostring pyxoptionalargs $^  pyobject pyxvencoding  pyobject pyxnsutf0$^  stdstring pyxr$^  pyxrefnannydeclarations$^  int pyxt0$^  int pyxt0$^  stdstring pyxt0$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxrefnannysetupcontexttostring 0$^  if pyxoptionalargs $^    if pyxoptionalargspyxn  0 $^      pyxvencoding  pyxoptionalargsencoding$^    $^  $^$^   pywrapfst.pyx000$^    $^     a python bytestring can be implicitly cast to a c string.$^    if isinstancedata bytes              $^      return data$^    elif isinstancedata unicode$^ $^  pyxt0  pybytescheckpyxvdata $^  pyxt0  pyxt0  0$^  if pyxt0 $^$^     pywrapfst.pyx000$^     a python bytestring can be implicitly cast to a c string.$^    if isinstancedata bytes$^      return data              $^    elif isinstancedata unicode$^      return data.encodeencoding$^ $^    pyxt0  pyxconvertstringfrompystdinstringpyxvdata if unlikelypyerroccurred pyxerr0 000 pyxl0error$^    pyxr  pyxt0$^    goto pyxl0$^$^     pywrapfst.pyx000$^    $^     a python bytestring can be implicitly cast to a c string.$^    if isinstancedata bytes              $^      return data$^    elif isinstancedata unicode$^ $^  $^$^   pywrapfst.pyx000$^    if isinstancedata bytes$^      return data$^    elif isinstancedata unicode              $^      return data.encodeencoding$^    raise fstargerrorcannot encode as string r.formatdata$^ $^  pyxt0  pyunicodecheckpyxvdata $^  pyxt0  pyxt0  0$^  if pyxt0 $^$^     pywrapfst.pyx000$^      return data$^    elif isinstancedata unicode$^      return data.encodeencoding              $^    raise fstargerrorcannot encode as string r.formatdata$^  $^ $^    pyxt0  pyxpyobjectgetattrstrpyxvdata pyxnsencode if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  null$^    if cythonunpackmethods  likelypymethodcheckpyxt0 $^      pyxt0  pymethodgetselfpyxt0$^      if likelypyxt0 $^        pyobject function  pymethodgetfunctionpyxt0$^        pyxincrefpyxt0$^        pyxincreffunction$^        pyxdecrefsetpyxt0 function$^      $^    $^    if pyxt0 $^      pyxt0  pyxpyobjectcalloneargpyxt0 pyxvencoding if unlikelypyxt0 pyxerr0 000 pyxl0error$^      pyxgotrefpyxt0$^     else $^      if cythonfastpycall$^      if pyfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxvencoding$^        pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^       else$^      endif$^      if cythonfastpyccall$^      if pyxpyfastcfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxvencoding$^        pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^       else$^      endif$^      $^        pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxgotrefpyxt0$^        pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^        pyxincrefpyxvencoding$^        pyxgiverefpyxvencoding$^        pytuplesetitempyxt0 00 pyxvencoding$^        pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^      $^    $^    pyxdecrefpyxt0 pyxt0  0$^    pyxt0  pyxconvertstringfrompystdinstringpyxt0 if unlikelypyerroccurred pyxerr0 000 pyxl0error$^    pyxdecrefpyxt0 pyxt0  0$^    pyxr  pyxt0$^    goto pyxl0$^$^     pywrapfst.pyx000$^    if isinstancedata bytes$^      return data$^    elif isinstancedata unicode              $^      return data.encodeencoding$^    raise fstargerrorcannot encode as string r.formatdata$^ $^  $^$^   pywrapfst.pyx000$^    elif isinstancedata unicode$^      return data.encodeencoding$^    raise fstargerrorcannot encode as string r.formatdata              $^  $^  $^ $^  pyxt0  pyxgetmoduleglobalnamepyxnsfstargerror if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxt0  pyxpyobjectgetattrstrpyxkpscannotencodeasstringr pyxnsformat if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxt0  null$^  if cythonunpackmethods  likelypymethodcheckpyxt0 $^    pyxt0  pymethodgetselfpyxt0$^    if likelypyxt0 $^      pyobject function  pymethodgetfunctionpyxt0$^      pyxincrefpyxt0$^      pyxincreffunction$^      pyxdecrefsetpyxt0 function$^    $^  $^  if pyxt0 $^    pyxt0  pyxpyobjectcalloneargpyxt0 pyxvdata if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxgotrefpyxt0$^   else $^    if cythonfastpycall$^    if pyfunctioncheckpyxt0 $^      pyobject pyxtemp0  pyxt0 pyxvdata$^      pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^      pyxxdecrefpyxt0 pyxt0  0$^      pyxgotrefpyxt0$^     else$^    endif$^    if cythonfastpyccall$^    if pyxpyfastcfunctioncheckpyxt0 $^      pyobject pyxtemp0  pyxt0 pyxvdata$^      pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^      pyxxdecrefpyxt0 pyxt0  0$^      pyxgotrefpyxt0$^     else$^    endif$^    $^      pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^      pyxgotrefpyxt0$^      pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^      pyxincrefpyxvdata$^      pyxgiverefpyxvdata$^      pytuplesetitempyxt0 00 pyxvdata$^      pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 000 pyxl0error$^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^    $^  $^  pyxdecrefpyxt0 pyxt0  0$^  pyxt0  null$^  if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^    pyxt0  pymethodgetselfpyxt0$^    if likelypyxt0 $^      pyobject function  pymethodgetfunctionpyxt0$^      pyxincrefpyxt0$^      pyxincreffunction$^      pyxdecrefsetpyxt0 function$^    $^  $^  if pyxt0 $^    pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxdecrefpyxt0 pyxt0  0$^    pyxgotrefpyxt0$^   else $^    if cythonfastpycall$^    if pyfunctioncheckpyxt0 $^      pyobject pyxtemp0  pyxt0 pyxt0$^      pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^      pyxxdecrefpyxt0 pyxt0  0$^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^     else$^    endif$^    if cythonfastpyccall$^    if pyxpyfastcfunctioncheckpyxt0 $^      pyobject pyxtemp0  pyxt0 pyxt0$^      pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^      pyxxdecrefpyxt0 pyxt0  0$^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^     else$^    endif$^    $^      pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^      pyxgotrefpyxt0$^      pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^      pyxgiverefpyxt0$^      pytuplesetitempyxt0 00 pyxt0$^      pyxt0  0$^      pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 000 pyxl0error$^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^    $^  $^  pyxdecrefpyxt0 pyxt0  0$^  pyxraisepyxt0 0 0 0$^  pyxdecrefpyxt0 pyxt0  0$^  pyxerr0 000 pyxl0error$^$^   pywrapfst.pyx000$^  $^  $^  cdef string tostringdata encodingutf0 except               $^    converts strings to bytestrings.$^  $^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.tostring pyxclineno pyxlineno pyxfilename$^  pyxpretendtoinitializepyxr$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx000$^  $^  $^  cdef string weighttostringdata encodingutf0 except               $^    converts strings or numerics to bytestrings.$^  $^ $^$^static stdstring pyxf0pywrapfstweighttostringpyobject pyxvdata struct pyxoptargs0pywrapfstweighttostring pyxoptionalargs $^  pyobject pyxvencoding  pyobject pyxnsutf0$^  stdstring pyxr$^  pyxrefnannydeclarations$^  int pyxt0$^  int pyxt0$^  stdstring pyxt0$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextweighttostring 0$^  if pyxoptionalargs $^    if pyxoptionalargspyxn  0 $^      pyxvencoding  pyxoptionalargsencoding$^    $^  $^$^   pywrapfst.pyx000$^    $^     a python bytestring can be implicitly cast to a c string.$^    if isinstancedata bytes              $^      return data$^    elif isinstancedata unicode$^ $^  pyxt0  pybytescheckpyxvdata $^  pyxt0  pyxt0  0$^  if pyxt0 $^$^     pywrapfst.pyx000$^     a python bytestring can be implicitly cast to a c string.$^    if isinstancedata bytes$^      return data              $^    elif isinstancedata unicode$^      return data.encodeencoding$^ $^    pyxt0  pyxconvertstringfrompystdinstringpyxvdata if unlikelypyerroccurred pyxerr0 000 pyxl0error$^    pyxr  pyxt0$^    goto pyxl0$^$^     pywrapfst.pyx000$^    $^     a python bytestring can be implicitly cast to a c string.$^    if isinstancedata bytes              $^      return data$^    elif isinstancedata unicode$^ $^  $^$^   pywrapfst.pyx000$^    if isinstancedata bytes$^      return data$^    elif isinstancedata unicode              $^      return data.encodeencoding$^    elif isinstancedata numbers.number$^ $^  pyxt0  pyunicodecheckpyxvdata $^  pyxt0  pyxt0  0$^  if pyxt0 $^$^     pywrapfst.pyx000$^      return data$^    elif isinstancedata unicode$^      return data.encodeencoding              $^    elif isinstancedata numbers.number$^      return strdata.encodeencoding$^ $^    pyxt0  pyxpyobjectgetattrstrpyxvdata pyxnsencode if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  null$^    if cythonunpackmethods  likelypymethodcheckpyxt0 $^      pyxt0  pymethodgetselfpyxt0$^      if likelypyxt0 $^        pyobject function  pymethodgetfunctionpyxt0$^        pyxincrefpyxt0$^        pyxincreffunction$^        pyxdecrefsetpyxt0 function$^      $^    $^    if pyxt0 $^      pyxt0  pyxpyobjectcalloneargpyxt0 pyxvencoding if unlikelypyxt0 pyxerr0 000 pyxl0error$^      pyxgotrefpyxt0$^     else $^      if cythonfastpycall$^      if pyfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxvencoding$^        pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^       else$^      endif$^      if cythonfastpyccall$^      if pyxpyfastcfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxvencoding$^        pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^       else$^      endif$^      $^        pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxgotrefpyxt0$^        pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^        pyxincrefpyxvencoding$^        pyxgiverefpyxvencoding$^        pytuplesetitempyxt0 00 pyxvencoding$^        pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^      $^    $^    pyxdecrefpyxt0 pyxt0  0$^    pyxt0  pyxconvertstringfrompystdinstringpyxt0 if unlikelypyerroccurred pyxerr0 000 pyxl0error$^    pyxdecrefpyxt0 pyxt0  0$^    pyxr  pyxt0$^    goto pyxl0$^$^     pywrapfst.pyx000$^    if isinstancedata bytes$^      return data$^    elif isinstancedata unicode              $^      return data.encodeencoding$^    elif isinstancedata numbers.number$^ $^  $^$^   pywrapfst.pyx000$^    elif isinstancedata unicode$^      return data.encodeencoding$^    elif isinstancedata numbers.number              $^      return strdata.encodeencoding$^    raise fstargerrorcannot encode as string r.formatdata$^ $^  pyxt0  pyxgetmoduleglobalnamepyxnsnumbers if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxt0  pyxpyobjectgetattrstrpyxt0 pyxnsnumber if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxdecrefpyxt0 pyxt0  0$^  pyxt0  pyobjectisinstancepyxvdata pyxt0 if unlikelypyxt0  int0 pyxerr0 000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^  pyxt0  pyxt0  0$^  if pyxt0 $^$^     pywrapfst.pyx000$^      return data.encodeencoding$^    elif isinstancedata numbers.number$^      return strdata.encodeencoding              $^    raise fstargerrorcannot encode as string r.formatdata$^  $^ $^    pyxt0  pytuplenew0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxgotrefpyxt0$^    pyxincrefpyxvdata$^    pyxgiverefpyxvdata$^    pytuplesetitempyxt0 0 pyxvdata$^    pyxt0  pyxpyobjectcallpyobject pystringtype pyxt0 null if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxgotrefpyxt0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxt0  pyxpyobjectgetattrstrpyxt0 pyxnsencode if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxgotrefpyxt0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxt0  null$^    if cythonunpackmethods  likelypymethodcheckpyxt0 $^      pyxt0  pymethodgetselfpyxt0$^      if likelypyxt0 $^        pyobject function  pymethodgetfunctionpyxt0$^        pyxincrefpyxt0$^        pyxincreffunction$^        pyxdecrefsetpyxt0 function$^      $^    $^    if pyxt0 $^      pyxt0  pyxpyobjectcalloneargpyxt0 pyxvencoding if unlikelypyxt0 pyxerr0 000 pyxl0error$^      pyxgotrefpyxt0$^     else $^      if cythonfastpycall$^      if pyfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxvencoding$^        pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^       else$^      endif$^      if cythonfastpyccall$^      if pyxpyfastcfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxvencoding$^        pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^       else$^      endif$^      $^        pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxgotrefpyxt0$^        pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^        pyxincrefpyxvencoding$^        pyxgiverefpyxvencoding$^        pytuplesetitempyxt0 00 pyxvencoding$^        pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^      $^    $^    pyxdecrefpyxt0 pyxt0  0$^    pyxt0  pyxconvertstringfrompystdinstringpyxt0 if unlikelypyerroccurred pyxerr0 000 pyxl0error$^    pyxdecrefpyxt0 pyxt0  0$^    pyxr  pyxt0$^    goto pyxl0$^$^     pywrapfst.pyx000$^    elif isinstancedata unicode$^      return data.encodeencoding$^    elif isinstancedata numbers.number              $^      return strdata.encodeencoding$^    raise fstargerrorcannot encode as string r.formatdata$^ $^  $^$^   pywrapfst.pyx000$^    elif isinstancedata numbers.number$^      return strdata.encodeencoding$^    raise fstargerrorcannot encode as string r.formatdata              $^  $^  $^ $^  pyxt0  pyxgetmoduleglobalnamepyxnsfstargerror if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxt0  pyxpyobjectgetattrstrpyxkpscannotencodeasstringr pyxnsformat if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxt0  null$^  if cythonunpackmethods  likelypymethodcheckpyxt0 $^    pyxt0  pymethodgetselfpyxt0$^    if likelypyxt0 $^      pyobject function  pymethodgetfunctionpyxt0$^      pyxincrefpyxt0$^      pyxincreffunction$^      pyxdecrefsetpyxt0 function$^    $^  $^  if pyxt0 $^    pyxt0  pyxpyobjectcalloneargpyxt0 pyxvdata if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxgotrefpyxt0$^   else $^    if cythonfastpycall$^    if pyfunctioncheckpyxt0 $^      pyobject pyxtemp0  pyxt0 pyxvdata$^      pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^      pyxxdecrefpyxt0 pyxt0  0$^      pyxgotrefpyxt0$^     else$^    endif$^    if cythonfastpyccall$^    if pyxpyfastcfunctioncheckpyxt0 $^      pyobject pyxtemp0  pyxt0 pyxvdata$^      pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^      pyxxdecrefpyxt0 pyxt0  0$^      pyxgotrefpyxt0$^     else$^    endif$^    $^      pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^      pyxgotrefpyxt0$^      pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^      pyxincrefpyxvdata$^      pyxgiverefpyxvdata$^      pytuplesetitempyxt0 00 pyxvdata$^      pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 000 pyxl0error$^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^    $^  $^  pyxdecrefpyxt0 pyxt0  0$^  pyxt0  null$^  if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^    pyxt0  pymethodgetselfpyxt0$^    if likelypyxt0 $^      pyobject function  pymethodgetfunctionpyxt0$^      pyxincrefpyxt0$^      pyxincreffunction$^      pyxdecrefsetpyxt0 function$^    $^  $^  if pyxt0 $^    pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxdecrefpyxt0 pyxt0  0$^    pyxgotrefpyxt0$^   else $^    if cythonfastpycall$^    if pyfunctioncheckpyxt0 $^      pyobject pyxtemp0  pyxt0 pyxt0$^      pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^      pyxxdecrefpyxt0 pyxt0  0$^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^     else$^    endif$^    if cythonfastpyccall$^    if pyxpyfastcfunctioncheckpyxt0 $^      pyobject pyxtemp0  pyxt0 pyxt0$^      pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^      pyxxdecrefpyxt0 pyxt0  0$^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^     else$^    endif$^    $^      pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^      pyxgotrefpyxt0$^      pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^      pyxgiverefpyxt0$^      pytuplesetitempyxt0 00 pyxt0$^      pyxt0  0$^      pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 000 pyxl0error$^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^    $^  $^  pyxdecrefpyxt0 pyxt0  0$^  pyxraisepyxt0 0 0 0$^  pyxdecrefpyxt0 pyxt0  0$^  pyxerr0 000 pyxl0error$^$^   pywrapfst.pyx000$^  $^  $^  cdef string weighttostringdata encodingutf0 except               $^    converts strings or numerics to bytestrings.$^  $^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.weighttostring pyxclineno pyxlineno pyxfilename$^  pyxpretendtoinitializepyxr$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx000$^  $^  $^  cdef fst.composefilter getcomposefilter              $^      const string composefilter except $^    matches string with the appropriate composefilter enum value.$^ $^$^static enum fstcomposefilter pyxf0pywrapfstgetcomposefilterstdstring const pyxvcomposefilter $^  enum fstcomposefilter pyxvcomposefilterenum$^  enum fstcomposefilter pyxr$^  pyxrefnannydeclarations$^  int pyxt0$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextgetcomposefilter 0$^$^   pywrapfst.pyx000$^    $^    cdef fst.composefilter composefilterenum$^    if not fst.getcomposefiltercomposefilter addrcomposefilterenum              $^      raise fstargerrorunknown compose filter type r.format$^          composefilter$^ $^  pyxt0  fstscriptgetcomposefilterpyxvcomposefilter pyxvcomposefilterenum  0  0$^  if pyxt0 $^$^     pywrapfst.pyx000$^    cdef fst.composefilter composefilterenum$^    if not fst.getcomposefiltercomposefilter addrcomposefilterenum$^      raise fstargerrorunknown compose filter type r.format              $^          composefilter$^    return composefilterenum$^ $^    pyxt0  pyxgetmoduleglobalnamepyxnsfstargerror if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  pyxpyobjectgetattrstrpyxkpsunknowncomposefiltertyper pyxnsformat if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxgotrefpyxt0$^$^     pywrapfst.pyx000$^    if not fst.getcomposefiltercomposefilter addrcomposefilterenum$^      raise fstargerrorunknown compose filter type r.format$^          composefilter              $^    return composefilterenum$^  $^ $^    pyxt0  pyxconvertpybytesstringtopystdinstringpyxvcomposefilter if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  null$^    if cythonunpackmethods  likelypymethodcheckpyxt0 $^      pyxt0  pymethodgetselfpyxt0$^      if likelypyxt0 $^        pyobject function  pymethodgetfunctionpyxt0$^        pyxincrefpyxt0$^        pyxincreffunction$^        pyxdecrefsetpyxt0 function$^      $^    $^    if pyxt0 $^      pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxgotrefpyxt0$^     else $^      if cythonfastpycall$^      if pyfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxt0$^        pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^       else$^      endif$^      if cythonfastpyccall$^      if pyxpyfastcfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxt0$^        pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^       else$^      endif$^      $^        pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxgotrefpyxt0$^        pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^        pyxgiverefpyxt0$^        pytuplesetitempyxt0 00 pyxt0$^        pyxt0  0$^        pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^      $^    $^    pyxdecrefpyxt0 pyxt0  0$^    pyxt0  null$^    if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^      pyxt0  pymethodgetselfpyxt0$^      if likelypyxt0 $^        pyobject function  pymethodgetfunctionpyxt0$^        pyxincrefpyxt0$^        pyxincreffunction$^        pyxdecrefsetpyxt0 function$^      $^    $^    if pyxt0 $^      pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxgotrefpyxt0$^     else $^      if cythonfastpycall$^      if pyfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxt0$^        pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^       else$^      endif$^      if cythonfastpyccall$^      if pyxpyfastcfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxt0$^        pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^       else$^      endif$^      $^        pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxgotrefpyxt0$^        pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^        pyxgiverefpyxt0$^        pytuplesetitempyxt0 00 pyxt0$^        pyxt0  0$^        pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^      $^    $^    pyxdecrefpyxt0 pyxt0  0$^    pyxraisepyxt0 0 0 0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxerr0 000 pyxl0error$^$^     pywrapfst.pyx000$^    $^    cdef fst.composefilter composefilterenum$^    if not fst.getcomposefiltercomposefilter addrcomposefilterenum              $^      raise fstargerrorunknown compose filter type r.format$^          composefilter$^ $^  $^$^   pywrapfst.pyx000$^      raise fstargerrorunknown compose filter type r.format$^          composefilter$^    return composefilterenum              $^  $^  $^ $^  pyxr  pyxvcomposefilterenum$^  goto pyxl0$^$^   pywrapfst.pyx000$^  $^  $^  cdef fst.composefilter getcomposefilter              $^      const string composefilter except $^    matches string with the appropriate composefilter enum value.$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.getcomposefilter pyxclineno pyxlineno pyxfilename$^  pyxr  enum fstcomposefilter 0$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx000$^  $^  $^  cdef fst.determinizetype getdeterminizetypeconst string dettype except               $^    matches string with the appropriate determinizetype enum value.$^  $^ $^$^static enum fstdeterminizetype pyxf0pywrapfstgetdeterminizetypestdstring const pyxvdettype $^  enum fstdeterminizetype pyxvdettypeenum$^  enum fstdeterminizetype pyxr$^  pyxrefnannydeclarations$^  int pyxt0$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextgetdeterminizetype 0$^$^   pywrapfst.pyx000$^    $^    cdef fst.determinizetype dettypeenum$^    if not fst.getdeterminizetypedettype addrdettypeenum              $^      raise fstargerrorunknown determinization type r.formatdettype$^    return dettypeenum$^ $^  pyxt0  fstscriptgetdeterminizetypepyxvdettype pyxvdettypeenum  0  0$^  if pyxt0 $^$^     pywrapfst.pyx000$^    cdef fst.determinizetype dettypeenum$^    if not fst.getdeterminizetypedettype addrdettypeenum$^      raise fstargerrorunknown determinization type r.formatdettype              $^    return dettypeenum$^  $^ $^    pyxt0  pyxgetmoduleglobalnamepyxnsfstargerror if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  pyxpyobjectgetattrstrpyxkpsunknowndeterminizationtyper pyxnsformat if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  pyxconvertpybytesstringtopystdinstringpyxvdettype if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  null$^    if cythonunpackmethods  likelypymethodcheckpyxt0 $^      pyxt0  pymethodgetselfpyxt0$^      if likelypyxt0 $^        pyobject function  pymethodgetfunctionpyxt0$^        pyxincrefpyxt0$^        pyxincreffunction$^        pyxdecrefsetpyxt0 function$^      $^    $^    if pyxt0 $^      pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxgotrefpyxt0$^     else $^      if cythonfastpycall$^      if pyfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxt0$^        pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^       else$^      endif$^      if cythonfastpyccall$^      if pyxpyfastcfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxt0$^        pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^       else$^      endif$^      $^        pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxgotrefpyxt0$^        pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^        pyxgiverefpyxt0$^        pytuplesetitempyxt0 00 pyxt0$^        pyxt0  0$^        pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^      $^    $^    pyxdecrefpyxt0 pyxt0  0$^    pyxt0  null$^    if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^      pyxt0  pymethodgetselfpyxt0$^      if likelypyxt0 $^        pyobject function  pymethodgetfunctionpyxt0$^        pyxincrefpyxt0$^        pyxincreffunction$^        pyxdecrefsetpyxt0 function$^      $^    $^    if pyxt0 $^      pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxgotrefpyxt0$^     else $^      if cythonfastpycall$^      if pyfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxt0$^        pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^       else$^      endif$^      if cythonfastpyccall$^      if pyxpyfastcfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxt0$^        pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^       else$^      endif$^      $^        pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxgotrefpyxt0$^        pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^        pyxgiverefpyxt0$^        pytuplesetitempyxt0 00 pyxt0$^        pyxt0  0$^        pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^      $^    $^    pyxdecrefpyxt0 pyxt0  0$^    pyxraisepyxt0 0 0 0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxerr0 000 pyxl0error$^$^     pywrapfst.pyx000$^    $^    cdef fst.determinizetype dettypeenum$^    if not fst.getdeterminizetypedettype addrdettypeenum              $^      raise fstargerrorunknown determinization type r.formatdettype$^    return dettypeenum$^ $^  $^$^   pywrapfst.pyx000$^    if not fst.getdeterminizetypedettype addrdettypeenum$^      raise fstargerrorunknown determinization type r.formatdettype$^    return dettypeenum              $^  $^  $^ $^  pyxr  pyxvdettypeenum$^  goto pyxl0$^$^   pywrapfst.pyx000$^  $^  $^  cdef fst.determinizetype getdeterminizetypeconst string dettype except               $^    matches string with the appropriate determinizetype enum value.$^  $^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.getdeterminizetype pyxclineno pyxlineno pyxfilename$^  pyxr  enum fstdeterminizetype 0$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx000$^  $^  $^  cdef fst.queuetype getqueuetypeconst string queuetype except               $^    matches string with the appropriate queuetype enum value.$^  $^ $^$^static enum fstqueuetype pyxf0pywrapfstgetqueuetypestdstring const pyxvqueuetype $^  enum fstqueuetype pyxvqueuetypeenum$^  enum fstqueuetype pyxr$^  pyxrefnannydeclarations$^  int pyxt0$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextgetqueuetype 0$^$^   pywrapfst.pyx000$^    $^    cdef fst.queuetype queuetypeenum$^    if not fst.getqueuetypequeuetype addrqueuetypeenum              $^      raise fstargerrorunknown queue type r.formatqueuetype$^    return queuetypeenum$^ $^  pyxt0  fstscriptgetqueuetypepyxvqueuetype pyxvqueuetypeenum  0  0$^  if pyxt0 $^$^     pywrapfst.pyx000$^    cdef fst.queuetype queuetypeenum$^    if not fst.getqueuetypequeuetype addrqueuetypeenum$^      raise fstargerrorunknown queue type r.formatqueuetype              $^    return queuetypeenum$^  $^ $^    pyxt0  pyxgetmoduleglobalnamepyxnsfstargerror if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  pyxpyobjectgetattrstrpyxkpsunknownqueuetyper pyxnsformat if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  pyxconvertpybytesstringtopystdinstringpyxvqueuetype if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  null$^    if cythonunpackmethods  likelypymethodcheckpyxt0 $^      pyxt0  pymethodgetselfpyxt0$^      if likelypyxt0 $^        pyobject function  pymethodgetfunctionpyxt0$^        pyxincrefpyxt0$^        pyxincreffunction$^        pyxdecrefsetpyxt0 function$^      $^    $^    if pyxt0 $^      pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxgotrefpyxt0$^     else $^      if cythonfastpycall$^      if pyfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxt0$^        pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^       else$^      endif$^      if cythonfastpyccall$^      if pyxpyfastcfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxt0$^        pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^       else$^      endif$^      $^        pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxgotrefpyxt0$^        pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^        pyxgiverefpyxt0$^        pytuplesetitempyxt0 00 pyxt0$^        pyxt0  0$^        pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^      $^    $^    pyxdecrefpyxt0 pyxt0  0$^    pyxt0  null$^    if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^      pyxt0  pymethodgetselfpyxt0$^      if likelypyxt0 $^        pyobject function  pymethodgetfunctionpyxt0$^        pyxincrefpyxt0$^        pyxincreffunction$^        pyxdecrefsetpyxt0 function$^      $^    $^    if pyxt0 $^      pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxgotrefpyxt0$^     else $^      if cythonfastpycall$^      if pyfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxt0$^        pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^       else$^      endif$^      if cythonfastpyccall$^      if pyxpyfastcfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxt0$^        pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^       else$^      endif$^      $^        pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxgotrefpyxt0$^        pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^        pyxgiverefpyxt0$^        pytuplesetitempyxt0 00 pyxt0$^        pyxt0  0$^        pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^      $^    $^    pyxdecrefpyxt0 pyxt0  0$^    pyxraisepyxt0 0 0 0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxerr0 000 pyxl0error$^$^     pywrapfst.pyx000$^    $^    cdef fst.queuetype queuetypeenum$^    if not fst.getqueuetypequeuetype addrqueuetypeenum              $^      raise fstargerrorunknown queue type r.formatqueuetype$^    return queuetypeenum$^ $^  $^$^   pywrapfst.pyx000$^    if not fst.getqueuetypequeuetype addrqueuetypeenum$^      raise fstargerrorunknown queue type r.formatqueuetype$^    return queuetypeenum              $^  $^  $^ $^  pyxr  pyxvqueuetypeenum$^  goto pyxl0$^$^   pywrapfst.pyx000$^  $^  $^  cdef fst.queuetype getqueuetypeconst string queuetype except               $^    matches string with the appropriate queuetype enum value.$^  $^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.getqueuetype pyxclineno pyxlineno pyxfilename$^  pyxr  enum fstqueuetype 0$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx000$^  $^  $^  cdef fst.randarcselection getrandarcselection              $^      const string select except $^    matches string with the appropriate randarcselection enum value.$^ $^$^static enum fstscriptrandarcselection pyxf0pywrapfstgetrandarcselectionstdstring const pyxvselect $^  enum fstscriptrandarcselection pyxvselectenum$^  enum fstscriptrandarcselection pyxr$^  pyxrefnannydeclarations$^  int pyxt0$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextgetrandarcselection 0$^$^   pywrapfst.pyx000$^    $^    cdef fst.randarcselection selectenum$^    if not fst.getrandarcselectionselect addrselectenum              $^      raise fstargerrorunknown random arc selection type r.formatselect$^    return selectenum$^ $^  pyxt0  fstscriptgetrandarcselectionpyxvselect pyxvselectenum  0  0$^  if pyxt0 $^$^     pywrapfst.pyx000$^    cdef fst.randarcselection selectenum$^    if not fst.getrandarcselectionselect addrselectenum$^      raise fstargerrorunknown random arc selection type r.formatselect              $^    return selectenum$^  $^ $^    pyxt0  pyxgetmoduleglobalnamepyxnsfstargerror if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  pyxpyobjectgetattrstrpyxkpsunknownrandomarcselectiontyp pyxnsformat if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  pyxconvertpybytesstringtopystdinstringpyxvselect if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  null$^    if cythonunpackmethods  likelypymethodcheckpyxt0 $^      pyxt0  pymethodgetselfpyxt0$^      if likelypyxt0 $^        pyobject function  pymethodgetfunctionpyxt0$^        pyxincrefpyxt0$^        pyxincreffunction$^        pyxdecrefsetpyxt0 function$^      $^    $^    if pyxt0 $^      pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxgotrefpyxt0$^     else $^      if cythonfastpycall$^      if pyfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxt0$^        pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^       else$^      endif$^      if cythonfastpyccall$^      if pyxpyfastcfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxt0$^        pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^       else$^      endif$^      $^        pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxgotrefpyxt0$^        pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^        pyxgiverefpyxt0$^        pytuplesetitempyxt0 00 pyxt0$^        pyxt0  0$^        pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^      $^    $^    pyxdecrefpyxt0 pyxt0  0$^    pyxt0  null$^    if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^      pyxt0  pymethodgetselfpyxt0$^      if likelypyxt0 $^        pyobject function  pymethodgetfunctionpyxt0$^        pyxincrefpyxt0$^        pyxincreffunction$^        pyxdecrefsetpyxt0 function$^      $^    $^    if pyxt0 $^      pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxgotrefpyxt0$^     else $^      if cythonfastpycall$^      if pyfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxt0$^        pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^       else$^      endif$^      if cythonfastpyccall$^      if pyxpyfastcfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxt0$^        pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^       else$^      endif$^      $^        pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxgotrefpyxt0$^        pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^        pyxgiverefpyxt0$^        pytuplesetitempyxt0 00 pyxt0$^        pyxt0  0$^        pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^      $^    $^    pyxdecrefpyxt0 pyxt0  0$^    pyxraisepyxt0 0 0 0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxerr0 000 pyxl0error$^$^     pywrapfst.pyx000$^    $^    cdef fst.randarcselection selectenum$^    if not fst.getrandarcselectionselect addrselectenum              $^      raise fstargerrorunknown random arc selection type r.formatselect$^    return selectenum$^ $^  $^$^   pywrapfst.pyx000$^    if not fst.getrandarcselectionselect addrselectenum$^      raise fstargerrorunknown random arc selection type r.formatselect$^    return selectenum              $^  $^  $^ $^  pyxr  pyxvselectenum$^  goto pyxl0$^$^   pywrapfst.pyx000$^  $^  $^  cdef fst.randarcselection getrandarcselection              $^      const string select except $^    matches string with the appropriate randarcselection enum value.$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.getrandarcselection pyxclineno pyxlineno pyxfilename$^  pyxr  enum fstscriptrandarcselection 0$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx000$^  $^  $^  cdef fst.replacelabeltype getreplacelabeltype              $^      const string replacelabeltype bool epsilononreplace except $^    matches string with the appropriate replacelabeltype enum value.$^ $^$^static enum fstreplacelabeltype pyxf0pywrapfstgetreplacelabeltypestdstring const pyxvreplacelabeltype bool pyxvepsilononreplace $^  enum fstreplacelabeltype pyxvreplacelabeltypeenum$^  enum fstreplacelabeltype pyxr$^  pyxrefnannydeclarations$^  int pyxt0$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextgetreplacelabeltype 0$^$^   pywrapfst.pyx000$^    $^    cdef fst.replacelabeltype replacelabeltypeenum$^    if not fst.getreplacelabeltypereplacelabeltype epsilononreplace              $^                                   addrreplacelabeltypeenum$^      raise fstargerrorunknown replace label type r.format$^ $^  pyxt0  fstscriptgetreplacelabeltypepyxvreplacelabeltype pyxvepsilononreplace pyxvreplacelabeltypeenum  0  0$^  if pyxt0 $^$^     pywrapfst.pyx000$^    if not fst.getreplacelabeltypereplacelabeltype epsilononreplace$^                                   addrreplacelabeltypeenum$^      raise fstargerrorunknown replace label type r.format              $^                        replacelabeltype$^    return replacelabeltypeenum$^ $^    pyxt0  pyxgetmoduleglobalnamepyxnsfstargerror if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  pyxpyobjectgetattrstrpyxkpsunknownreplacelabeltyper pyxnsformat if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxgotrefpyxt0$^$^     pywrapfst.pyx000$^                                   addrreplacelabeltypeenum$^      raise fstargerrorunknown replace label type r.format$^                        replacelabeltype              $^    return replacelabeltypeenum$^  $^ $^    pyxt0  pyxconvertpybytesstringtopystdinstringpyxvreplacelabeltype if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  null$^    if cythonunpackmethods  likelypymethodcheckpyxt0 $^      pyxt0  pymethodgetselfpyxt0$^      if likelypyxt0 $^        pyobject function  pymethodgetfunctionpyxt0$^        pyxincrefpyxt0$^        pyxincreffunction$^        pyxdecrefsetpyxt0 function$^      $^    $^    if pyxt0 $^      pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxgotrefpyxt0$^     else $^      if cythonfastpycall$^      if pyfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxt0$^        pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^       else$^      endif$^      if cythonfastpyccall$^      if pyxpyfastcfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxt0$^        pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^       else$^      endif$^      $^        pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxgotrefpyxt0$^        pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^        pyxgiverefpyxt0$^        pytuplesetitempyxt0 00 pyxt0$^        pyxt0  0$^        pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^      $^    $^    pyxdecrefpyxt0 pyxt0  0$^    pyxt0  null$^    if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^      pyxt0  pymethodgetselfpyxt0$^      if likelypyxt0 $^        pyobject function  pymethodgetfunctionpyxt0$^        pyxincrefpyxt0$^        pyxincreffunction$^        pyxdecrefsetpyxt0 function$^      $^    $^    if pyxt0 $^      pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxgotrefpyxt0$^     else $^      if cythonfastpycall$^      if pyfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxt0$^        pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^       else$^      endif$^      if cythonfastpyccall$^      if pyxpyfastcfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxt0$^        pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^       else$^      endif$^      $^        pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxgotrefpyxt0$^        pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^        pyxgiverefpyxt0$^        pytuplesetitempyxt0 00 pyxt0$^        pyxt0  0$^        pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^      $^    $^    pyxdecrefpyxt0 pyxt0  0$^    pyxraisepyxt0 0 0 0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxerr0 000 pyxl0error$^$^     pywrapfst.pyx000$^    $^    cdef fst.replacelabeltype replacelabeltypeenum$^    if not fst.getreplacelabeltypereplacelabeltype epsilononreplace              $^                                   addrreplacelabeltypeenum$^      raise fstargerrorunknown replace label type r.format$^ $^  $^$^   pywrapfst.pyx000$^      raise fstargerrorunknown replace label type r.format$^                        replacelabeltype$^    return replacelabeltypeenum              $^  $^  $^ $^  pyxr  pyxvreplacelabeltypeenum$^  goto pyxl0$^$^   pywrapfst.pyx000$^  $^  $^  cdef fst.replacelabeltype getreplacelabeltype              $^      const string replacelabeltype bool epsilononreplace except $^    matches string with the appropriate replacelabeltype enum value.$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.getreplacelabeltype pyxclineno pyxlineno pyxfilename$^  pyxr  enum fstreplacelabeltype 0$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx000$^    $^  $^    def reprself              $^      return  weight  at 0xx.formatself.type self.tostring$^                                               idself$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst0weight0reprpyobject pyxvself proto$^static pyobject pyxpw0pywrapfst0weight0reprpyobject pyxvself $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextrepr wrapper 0$^  pyxr  pyxpf0pywrapfst0weightreprstruct pyxobj0pywrapfstweight pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst0weightreprstruct pyxobj0pywrapfstweight pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  int pyxt0$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextrepr 0$^$^   pywrapfst.pyx000$^  $^    def reprself$^      return  weight  at 0xx.formatself.type self.tostring              $^                                               idself$^  $^ $^  pyxxdecrefpyxr$^  pyxt0  pyxpyobjectgetattrstrpyxkpsweightat0xx pyxnsformat if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s type$^    pyxerr0 000 pyxl0error$^  $^  pyxt0  pyxconvertpybytesstringtopystdinstringstruct pyxvtabstruct0pywrapfstweight pyxvselfpyxvtabtypepyxvself 0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s tostring$^    pyxerr0 000 pyxl0error$^  $^  pyxt0  pyxconvertpybytesstringtopystdinstringstruct pyxvtabstruct0pywrapfstweight pyxvselfpyxvtabtostringpyxvself 0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^$^   pywrapfst.pyx000$^    def reprself$^      return  weight  at 0xx.formatself.type self.tostring$^                                               idself              $^  $^    def strself$^ $^  pyxt0  pytuplenew0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxincrefpyobject pyxvself$^  pyxgiverefpyobject pyxvself$^  pytuplesetitempyxt0 0 pyobject pyxvself$^  pyxt0  pyxpyobjectcallpyxbuiltinid pyxt0 null if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxdecrefpyxt0 pyxt0  0$^  pyxt0  null$^  pyxt0  0$^  if cythonunpackmethods  likelypymethodcheckpyxt0 $^    pyxt0  pymethodgetselfpyxt0$^    if likelypyxt0 $^      pyobject function  pymethodgetfunctionpyxt0$^      pyxincrefpyxt0$^      pyxincreffunction$^      pyxdecrefsetpyxt0 function$^      pyxt0  0$^    $^  $^  if cythonfastpycall$^  if pyfunctioncheckpyxt0 $^    pyobject pyxtemp0  pyxt0 pyxt0 pyxt0 pyxt0$^    pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp0pyxt0 0pyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxxdecrefpyxt0 pyxt0  0$^    pyxgotrefpyxt0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxdecrefpyxt0 pyxt0  0$^   else$^  endif$^  if cythonfastpyccall$^  if pyxpyfastcfunctioncheckpyxt0 $^    pyobject pyxtemp0  pyxt0 pyxt0 pyxt0 pyxt0$^    pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp0pyxt0 0pyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxxdecrefpyxt0 pyxt0  0$^    pyxgotrefpyxt0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxdecrefpyxt0 pyxt0  0$^   else$^  endif$^  $^    pyxt0  pytuplenew0pyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxgotrefpyxt0$^    if pyxt0 $^      pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^    $^    pyxgiverefpyxt0$^    pytuplesetitempyxt0 0pyxt0 pyxt0$^    pyxgiverefpyxt0$^    pytuplesetitempyxt0 0pyxt0 pyxt0$^    pyxgiverefpyxt0$^    pytuplesetitempyxt0 0pyxt0 pyxt0$^    pyxt0  0$^    pyxt0  0$^    pyxt0  0$^    pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxgotrefpyxt0$^    pyxdecrefpyxt0 pyxt0  0$^  $^  pyxdecrefpyxt0 pyxt0  0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   pywrapfst.pyx000$^    $^  $^    def reprself              $^      return  weight  at 0xx.formatself.type self.tostring$^                                               idself$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.weight.repr pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx000$^                                               idself$^  $^    def strself              $^      return self.tostring$^  $^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst0weight0strpyobject pyxvself proto$^static pyobject pyxpw0pywrapfst0weight0strpyobject pyxvself $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextstr wrapper 0$^  pyxr  pyxpf0pywrapfst0weight0strstruct pyxobj0pywrapfstweight pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst0weight0strstruct pyxobj0pywrapfstweight pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextstr 0$^$^   pywrapfst.pyx000$^  $^    def strself$^      return self.tostring              $^  $^     this attempts to convert the string form into a float raising$^ $^  pyxxdecrefpyxr$^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s tostring$^    pyxerr0 000 pyxl0error$^  $^  pyxt0  pyxconvertpybytesstringtopystdinstringstruct pyxvtabstruct0pywrapfstweight pyxvselfpyxvtabtostringpyxvself 0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   pywrapfst.pyx000$^                                               idself$^  $^    def strself              $^      return self.tostring$^  $^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.weight.str pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx000$^     valueerror when that is not appropriate.$^  $^    def floatself              $^      return floatself.tostring$^  $^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst0weight0floatpyobject pyxvself proto$^static pyobject pyxpw0pywrapfst0weight0floatpyobject pyxvself $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextfloat wrapper 0$^  pyxr  pyxpf0pywrapfst0weight0floatstruct pyxobj0pywrapfstweight pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst0weight0floatstruct pyxobj0pywrapfstweight pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextfloat 0$^$^   pywrapfst.pyx000$^  $^    def floatself$^      return floatself.tostring              $^  $^    def initself weighttype weight$^ $^  pyxxdecrefpyxr$^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s tostring$^    pyxerr0 000 pyxl0error$^  $^  pyxt0  pyxconvertpybytesstringtopystdinstringstruct pyxvtabstruct0pywrapfstweight pyxvselfpyxvtabtostringpyxvself 0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxt0  pyxpynumberfloatpyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxdecrefpyxt0 pyxt0  0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   pywrapfst.pyx000$^     valueerror when that is not appropriate.$^  $^    def floatself              $^      return floatself.tostring$^  $^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.weight.float pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx000$^      return floatself.tostring$^  $^    def initself weighttype weight              $^      self.weight.resetnew fst.weightclasstostringweighttype$^                                             weighttostringweight$^ $^$^ python wrapper $^static int pyxpw0pywrapfst0weight0initpyobject pyxvself pyobject pyxargs pyobject pyxkwds proto$^static int pyxpw0pywrapfst0weight0initpyobject pyxvself pyobject pyxargs pyobject pyxkwds $^  pyobject pyxvweighttype  0$^  pyobject pyxvweight  0$^  int pyxr$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextinit wrapper 0$^  $^    static pyobject pyxpyargnames  pyxnsweighttypepyxnsweight0$^    pyobject values0  00$^    if unlikelypyxkwds $^      pyssizet kwargs$^      const pyssizet posargs  pytuplegetsizepyxargs$^      switch posargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 break$^        default goto pyxl0argtupleerror$^      $^      kwargs  pydictsizepyxkwds$^      switch posargs $^        case  0$^        if likelyvalues0  pydictgetitempyxkwds pyxnsweighttype  0 kwargs$^        else goto pyxl0argtupleerror$^        cythonfallthrough$^        case  0$^        if likelyvalues0  pydictgetitempyxkwds pyxnsweight  0 kwargs$^        else $^          pyxraiseargtupleinvalidinit 0 0 0 0 pyxerr0 000 pyxl0error$^        $^      $^      if unlikelykwargs  0 $^        if unlikelypyxparseoptionalkeywordspyxkwds pyxpyargnames 0 values posargs init  0 pyxerr0 000 pyxl0error$^      $^     else if pytuplegetsizepyxargs  0 $^      goto pyxl0argtupleerror$^     else $^      values0  pytuplegetitempyxargs 0$^      values0  pytuplegetitempyxargs 0$^    $^    pyxvweighttype  values0$^    pyxvweight  values0$^  $^  goto pyxl0argumentunpackingdone$^  pyxl0argtupleerror$^  pyxraiseargtupleinvalidinit 0 0 0 pytuplegetsizepyxargs pyxerr0 000 pyxl0error$^  pyxl0error$^  pyxaddtracebackpywrapfst.weight.init pyxclineno pyxlineno pyxfilename$^  pyxrefnannyfinishcontext$^  return 0$^  pyxl0argumentunpackingdone$^  pyxr  pyxpf0pywrapfst0weight0initstruct pyxobj0pywrapfstweight pyxvself pyxvweighttype pyxvweight$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static int pyxpf0pywrapfst0weight0initstruct pyxobj0pywrapfstweight pyxvself pyobject pyxvweighttype pyobject pyxvweight $^  int pyxr$^  pyxrefnannydeclarations$^  stdstring pyxt0$^  stdstring pyxt0$^  pyxrefnannysetupcontextinit 0$^$^   pywrapfst.pyx000$^  $^    def initself weighttype weight$^      self.weight.resetnew fst.weightclasstostringweighttype              $^                                             weighttostringweight$^      self.checkweight$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s weight$^    pyxerr0 000 pyxl0error$^  $^  pyxt0  pyxf0pywrapfsttostringpyxvweighttype null if unlikelypyerroccurred pyxerr0 000 pyxl0error$^$^   pywrapfst.pyx000$^    def initself weighttype weight$^      self.weight.resetnew fst.weightclasstostringweighttype$^                                             weighttostringweight              $^      self.checkweight$^  $^ $^  pyxt0  pyxf0pywrapfstweighttostringpyxvweight null if unlikelypyerroccurred pyxerr0 000 pyxl0error$^$^   pywrapfst.pyx000$^  $^    def initself weighttype weight$^      self.weight.resetnew fst.weightclasstostringweighttype              $^                                             weighttostringweight$^      self.checkweight$^ $^  pyxvselfweight.resetnew fstscriptweightclasspyxt0 pyxt0$^$^   pywrapfst.pyx000$^      self.weight.resetnew fst.weightclasstostringweighttype$^                                             weighttostringweight$^      self.checkweight              $^  $^    cdef void checkweightself except $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s checkweight$^    pyxerr0 000 pyxl0error$^  $^  struct pyxvtabstruct0pywrapfstweight pyxvselfpyxvtabcheckweightpyxvself if unlikelypyerroccurred pyxerr0 000 pyxl0error$^$^   pywrapfst.pyx000$^      return floatself.tostring$^  $^    def initself weighttype weight              $^      self.weight.resetnew fst.weightclasstostringweighttype$^                                             weighttostringweight$^ $^$^   function exit code $^  pyxr  0$^  goto pyxl0$^  pyxl0error$^  pyxaddtracebackpywrapfst.weight.init pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx000$^      self.checkweight$^  $^    cdef void checkweightself except               $^      if self.type  bnone$^        raise fstargerrorweight type not found$^ $^$^static void pyxf0pywrapfst0weightcheckweightstruct pyxobj0pywrapfstweight pyxvself $^  pyxrefnannydeclarations$^  int pyxt0$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextcheckweight 0$^$^   pywrapfst.pyx000$^  $^    cdef void checkweightself except $^      if self.type  bnone              $^        raise fstargerrorweight type not found$^      if self.tostring  bbadnumber$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s type$^    pyxerr0 000 pyxl0error$^  $^  pyxt0  struct pyxvtabstruct0pywrapfstweight pyxvselfpyxvtabtypepyxvself 0  char none  0$^  if pyxt0 $^$^     pywrapfst.pyx000$^    cdef void checkweightself except $^      if self.type  bnone$^        raise fstargerrorweight type not found              $^      if self.tostring  bbadnumber$^        raise fstbadweighterrorinvalid weight$^ $^    pyxt0  pyxgetmoduleglobalnamepyxnsfstargerror if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  pyxpyobjectcallpyxt0 pyxtuple null if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxgotrefpyxt0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxraisepyxt0 0 0 0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxerr0 000 pyxl0error$^$^     pywrapfst.pyx000$^  $^    cdef void checkweightself except $^      if self.type  bnone              $^        raise fstargerrorweight type not found$^      if self.tostring  bbadnumber$^ $^  $^$^   pywrapfst.pyx000$^      if self.type  bnone$^        raise fstargerrorweight type not found$^      if self.tostring  bbadnumber              $^        raise fstbadweighterrorinvalid weight$^  $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s tostring$^    pyxerr0 000 pyxl0error$^  $^  pyxt0  struct pyxvtabstruct0pywrapfstweight pyxvselfpyxvtabtostringpyxvself 0  char badnumber  0$^  if pyxt0 $^$^     pywrapfst.pyx000$^        raise fstargerrorweight type not found$^      if self.tostring  bbadnumber$^        raise fstbadweighterrorinvalid weight              $^  $^    cpdef weight copyself$^ $^    pyxt0  pyxgetmoduleglobalnamepyxnsfstbadweighterror if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  pyxpyobjectcallpyxt0 pyxtuple0 null if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxgotrefpyxt0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxraisepyxt0 0 0 0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxerr0 000 pyxl0error$^$^     pywrapfst.pyx000$^      if self.type  bnone$^        raise fstargerrorweight type not found$^      if self.tostring  bbadnumber              $^        raise fstbadweighterrorinvalid weight$^  $^ $^  $^$^   pywrapfst.pyx000$^      self.checkweight$^  $^    cdef void checkweightself except               $^      if self.type  bnone$^        raise fstargerrorweight type not found$^ $^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.weight.checkweight pyxclineno pyxlineno pyxfilename$^  pyxl0$^  pyxrefnannyfinishcontext$^$^$^ pywrapfst.pyx000$^        raise fstbadweighterrorinvalid weight$^  $^    cpdef weight copyself              $^      $^      copyself$^ $^$^static pyobject pyxpw0pywrapfst0weight0copypyobject pyxvself cythonunused pyobject unused proto$^static struct pyxobj0pywrapfstweight pyxf0pywrapfst0weightcopystruct pyxobj0pywrapfstweight pyxvself int pyxskipdispatch $^  struct pyxobj0pywrapfstweight pyxvresult  0$^  struct pyxobj0pywrapfstweight pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextcopy 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnscopy if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst0weight0copy $^      pyxxdecrefpyobject pyxr$^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxdecrefpyxt0 pyxt0  0$^       else $^        pyxt0  pyxpyobjectcallnoargpyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^      $^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      if likelypyxt0  pynone  likelypyxtypetestpyxt0 pyxptype0pywrapfstweight pyxerr0 000 pyxl0error$^      pyxr  struct pyxobj0pywrapfstweight pyxt0$^      pyxt0  0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx000$^      returns a copy of the weight.$^      $^      cdef weight result  weight.newweight              $^      result.weight.resetnew fst.weightclassderefself.weight$^      return result$^ $^  pyxt0  pyxtpnew0pywrapfstweightpytypeobject pyxptype0pywrapfstweight pyxemptytuple null if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  if likelypyxtypetestpyxt0 pyxptype0pywrapfstweight pyxerr0 000 pyxl0error$^  pyxvresult  struct pyxobj0pywrapfstweight pyxt0$^  pyxt0  0$^$^   pywrapfst.pyx000$^      $^      cdef weight result  weight.newweight$^      result.weight.resetnew fst.weightclassderefself.weight              $^      return result$^  $^ $^  if unlikelypyobject pyxvresult  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s weight$^    pyxerr0 000 pyxl0error$^  $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s weight$^    pyxerr0 000 pyxl0error$^  $^  pyxvresultweight.resetnew fstscriptweightclasspyxvselfweight$^$^   pywrapfst.pyx000$^      cdef weight result  weight.newweight$^      result.weight.resetnew fst.weightclassderefself.weight$^      return result              $^  $^     to get around the inability to declare cdef class methods we define the$^ $^  pyxxdecrefpyobject pyxr$^  pyxincrefpyobject pyxvresult$^  pyxr  pyxvresult$^  goto pyxl0$^$^   pywrapfst.pyx000$^        raise fstbadweighterrorinvalid weight$^  $^    cpdef weight copyself              $^      $^      copyself$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.weight.copy pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxl0$^  pyxxdecrefpyobject pyxvresult$^  pyxxgiverefpyobject pyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst0weight0copypyobject pyxvself cythonunused pyobject unused proto$^static char pyxdoc0pywrapfst0weight0copy  n    copyselfnn    returns a copy of the weight.n    $^static pyobject pyxpw0pywrapfst0weight0copypyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextcopy wrapper 0$^  pyxr  pyxpf0pywrapfst0weight0copystruct pyxobj0pywrapfstweight pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst0weight0copystruct pyxobj0pywrapfstweight pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextcopy 0$^  pyxxdecrefpyxr$^  pyxt0  pyobject pyxf0pywrapfst0weightcopypyxvself 0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.weight.copy pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx000$^  $^    classmethod$^    def zerocls weighttype              $^      $^      weight.zeroweighttype$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst0weight00zeropyobject pyxvcls pyobject pyxvweighttype proto$^static char pyxdoc0pywrapfst0weight00zero  n    weight.zeroweighttypenn    constructs semiring zero.n    $^static pyobject pyxpw0pywrapfst0weight00zeropyobject pyxvcls pyobject pyxvweighttype $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextzero wrapper 0$^  pyxr  pyxpf0pywrapfst0weight00zeropytypeobjectpyxvcls pyobject pyxvweighttype$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst0weight00zerocythonunused pytypeobject pyxvcls pyobject pyxvweighttype $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextzero 0$^$^   pywrapfst.pyx000$^      constructs semiring zero.$^      $^      return zeroweighttype              $^  $^    classmethod$^ $^  pyxxdecrefpyxr$^  pyxt0  pyobject pyxf0pywrapfstzeropyxvweighttype if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   pywrapfst.pyx000$^  $^    classmethod$^    def zerocls weighttype              $^      $^      weight.zeroweighttype$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.weight.zero pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx000$^  $^    classmethod$^    def onecls weighttype              $^      $^      weight.oneweighttype$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst0weight00onepyobject pyxvcls pyobject pyxvweighttype proto$^static char pyxdoc0pywrapfst0weight00one  n    weight.oneweighttypenn    constructs semiring one.n    $^static pyobject pyxpw0pywrapfst0weight00onepyobject pyxvcls pyobject pyxvweighttype $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextone wrapper 0$^  pyxr  pyxpf0pywrapfst0weight00onepytypeobjectpyxvcls pyobject pyxvweighttype$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst0weight00onecythonunused pytypeobject pyxvcls pyobject pyxvweighttype $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextone 0$^$^   pywrapfst.pyx000$^      constructs semiring one.$^      $^      return oneweighttype              $^  $^    classmethod$^ $^  pyxxdecrefpyxr$^  pyxt0  pyobject pyxf0pywrapfstonepyxvweighttype if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   pywrapfst.pyx000$^  $^    classmethod$^    def onecls weighttype              $^      $^      weight.oneweighttype$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.weight.one pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx000$^  $^    classmethod$^    def noweightcls weighttype              $^      $^      weight.noweightweighttype$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst0weight00noweightpyobject pyxvcls pyobject pyxvweighttype proto$^static char pyxdoc0pywrapfst0weight00noweight  n    weight.noweightweighttypenn    constructs a nonmember weight in the semiring.n    $^static pyobject pyxpw0pywrapfst0weight00noweightpyobject pyxvcls pyobject pyxvweighttype $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextnoweight wrapper 0$^  pyxr  pyxpf0pywrapfst0weight00noweightpytypeobjectpyxvcls pyobject pyxvweighttype$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst0weight00noweightcythonunused pytypeobject pyxvcls pyobject pyxvweighttype $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextnoweight 0$^$^   pywrapfst.pyx000$^      constructs a nonmember weight in the semiring.$^      $^      return noweightweighttype              $^  $^    def eqweight w0 weight w0$^ $^  pyxxdecrefpyxr$^  pyxt0  pyobject pyxf0pywrapfstnoweightpyxvweighttype if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   pywrapfst.pyx000$^  $^    classmethod$^    def noweightcls weighttype              $^      $^      weight.noweightweighttype$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.weight.noweight pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx000$^      return noweightweighttype$^  $^    def eqweight w0 weight w0              $^      return fst.eqderefw0.weight derefw0.weight$^  $^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst0weight00eqpyobject pyxvw0 pyobject pyxvw0 proto$^static pyobject pyxpw0pywrapfst0weight00eqpyobject pyxvw0 pyobject pyxvw0 $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontexteq wrapper 0$^  if unlikelypyxargtypetestpyobject pyxvw0 pyxptype0pywrapfstweight 0 w0 0 pyxerr0 000 pyxl0error$^  pyxr  pyxpf0pywrapfst0weight00eqstruct pyxobj0pywrapfstweight pyxvw0 struct pyxobj0pywrapfstweight pyxvw0$^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxr  null$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst0weight00eqstruct pyxobj0pywrapfstweight pyxvw0 struct pyxobj0pywrapfstweight pyxvw0 $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontexteq 0$^$^   pywrapfst.pyx000$^  $^    def eqweight w0 weight w0$^      return fst.eqderefw0.weight derefw0.weight              $^  $^    def neweight w0 weight w0$^ $^  pyxxdecrefpyxr$^  if unlikelypyobject pyxvw0  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s weight$^    pyxerr0 000 pyxl0error$^  $^  if unlikelypyobject pyxvw0  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s weight$^    pyxerr0 000 pyxl0error$^  $^  pyxt0  pyxpyboolfromlongoperatorpyxvw0weight pyxvw0weight if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   pywrapfst.pyx000$^      return noweightweighttype$^  $^    def eqweight w0 weight w0              $^      return fst.eqderefw0.weight derefw0.weight$^  $^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.weight.eq pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx000$^      return fst.eqderefw0.weight derefw0.weight$^  $^    def neweight w0 weight w0              $^      return not w0  w0$^  $^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst0weight00nepyobject pyxvw0 pyobject pyxvw0 proto$^static pyobject pyxpw0pywrapfst0weight00nepyobject pyxvw0 pyobject pyxvw0 $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextne wrapper 0$^  if unlikelypyxargtypetestpyobject pyxvw0 pyxptype0pywrapfstweight 0 w0 0 pyxerr0 000 pyxl0error$^  pyxr  pyxpf0pywrapfst0weight00nestruct pyxobj0pywrapfstweight pyxvw0 struct pyxobj0pywrapfstweight pyxvw0$^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxr  null$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst0weight00nestruct pyxobj0pywrapfstweight pyxvw0 struct pyxobj0pywrapfstweight pyxvw0 $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  int pyxt0$^  pyxrefnannysetupcontextne 0$^$^   pywrapfst.pyx000$^  $^    def neweight w0 weight w0$^      return not w0  w0              $^  $^    cpdef string tostringself$^ $^  pyxxdecrefpyxr$^  pyxt0  pyobjectrichcomparepyobject pyxvw0 pyobject pyxvw0 pyeq pyxxgotrefpyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxt0  pyxpyobjectistruepyxt0 if unlikelypyxt0  0 pyxerr0 000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^  pyxt0  pyxpyboolfromlongpyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   pywrapfst.pyx000$^      return fst.eqderefw0.weight derefw0.weight$^  $^    def neweight w0 weight w0              $^      return not w0  w0$^  $^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.weight.ne pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx000$^      return not w0  w0$^  $^    cpdef string tostringself              $^      return self.weight.get.tostring$^  $^ $^$^static pyobject pyxpw0pywrapfst0weight00tostringpyobject pyxvself cythonunused pyobject unused proto$^static stdstring pyxf0pywrapfst0weighttostringstruct pyxobj0pywrapfstweight pyxvself int pyxskipdispatch $^  stdstring pyxr$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  stdstring pyxt0$^  pyxrefnannysetupcontexttostring 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnstostring if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst0weight00tostring $^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxdecrefpyxt0 pyxt0  0$^       else $^        pyxt0  pyxpyobjectcallnoargpyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^      $^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxt0  pyxconvertstringfrompystdinstringpyxt0 if unlikelypyerroccurred pyxerr0 000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxr  pyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx000$^  $^    cpdef string tostringself$^      return self.weight.get.tostring              $^  $^    cpdef string typeself$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s weight$^    pyxerr0 000 pyxl0error$^  $^  pyxr  pyxvselfweight.gettostring$^  goto pyxl0$^$^   pywrapfst.pyx000$^      return not w0  w0$^  $^    cpdef string tostringself              $^      return self.weight.get.tostring$^  $^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxwriteunraisablepywrapfst.weight.tostring pyxclineno pyxlineno pyxfilename 0 0$^  pyxpretendtoinitializepyxr$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst0weight00tostringpyobject pyxvself cythonunused pyobject unused proto$^static pyobject pyxpw0pywrapfst0weight00tostringpyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontexttostring wrapper 0$^  pyxr  pyxpf0pywrapfst0weight00tostringstruct pyxobj0pywrapfstweight pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst0weight00tostringstruct pyxobj0pywrapfstweight pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontexttostring 0$^  pyxxdecrefpyxr$^  pyxt0  pyxconvertpybytesstringtopystdinstringpyxf0pywrapfst0weighttostringpyxvself 0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.weight.tostring pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx000$^      return self.weight.get.tostring$^  $^    cpdef string typeself              $^      typeself$^  $^ $^$^static pyobject pyxpw0pywrapfst0weight00typepyobject pyxvself cythonunused pyobject unused proto$^static stdstring pyxf0pywrapfst0weighttypestruct pyxobj0pywrapfstweight pyxvself int pyxskipdispatch $^  stdstring pyxr$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  stdstring pyxt0$^  pyxrefnannysetupcontexttype 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnstype if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst0weight00type $^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxdecrefpyxt0 pyxt0  0$^       else $^        pyxt0  pyxpyobjectcallnoargpyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^      $^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxt0  pyxconvertstringfrompystdinstringpyxt0 if unlikelypyerroccurred pyxerr0 000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxr  pyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx000$^      returns a string indicating the weight type.$^      $^      return self.weight.get.type              $^  $^  $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s weight$^    pyxerr0 000 pyxl0error$^  $^  pyxr  pyxvselfweight.gettype$^  goto pyxl0$^$^   pywrapfst.pyx000$^      return self.weight.get.tostring$^  $^    cpdef string typeself              $^      typeself$^  $^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxwriteunraisablepywrapfst.weight.type pyxclineno pyxlineno pyxfilename 0 0$^  pyxpretendtoinitializepyxr$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst0weight00typepyobject pyxvself cythonunused pyobject unused proto$^static char pyxdoc0pywrapfst0weight00type  typeselfnn    returns a string indicating the weight type.n    $^static pyobject pyxpw0pywrapfst0weight00typepyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontexttype wrapper 0$^  pyxr  pyxpf0pywrapfst0weight00typestruct pyxobj0pywrapfstweight pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst0weight00typestruct pyxobj0pywrapfstweight pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontexttype 0$^  pyxxdecrefpyxr$^  pyxt0  pyxconvertpybytesstringtopystdinstringpyxf0pywrapfst0weighttypepyxvself 0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.weight.type pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ tree fragment0$^  def reducecythonself              $^      raise typeerrorself.weight cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst0weight00reducecythonpyobject pyxvself cythonunused pyobject unused proto$^static pyobject pyxpw0pywrapfst0weight00reducecythonpyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextreducecython wrapper 0$^  pyxr  pyxpf0pywrapfst0weight00reducecythonstruct pyxobj0pywrapfstweight pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst0weight00reducecythoncythonunused struct pyxobj0pywrapfstweight pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextreducecython 0$^$^   tree fragment0$^  def reducecythonself$^      raise typeerrorself.weight cannot be converted to a python object for pickling              $^  def setstatecythonself pyxstate$^      raise typeerrorself.weight cannot be converted to a python object for pickling$^ $^  pyxt0  pyxpyobjectcallpyxbuiltintypeerror pyxtuple0 null if unlikelypyxt0 pyxerr0 0 pyxl0error$^  pyxgotrefpyxt0$^  pyxraisepyxt0 0 0 0$^  pyxdecrefpyxt0 pyxt0  0$^  pyxerr0 0 pyxl0error$^$^   tree fragment0$^  def reducecythonself              $^      raise typeerrorself.weight cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.weight.reducecython pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ tree fragment0$^  def reducecythonself$^      raise typeerrorself.weight cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate              $^      raise typeerrorself.weight cannot be converted to a python object for pickling$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst0weight00setstatecythonpyobject pyxvself pyobject pyxvpyxstate proto$^static pyobject pyxpw0pywrapfst0weight00setstatecythonpyobject pyxvself pyobject pyxvpyxstate $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextsetstatecython wrapper 0$^  pyxr  pyxpf0pywrapfst0weight00setstatecythonstruct pyxobj0pywrapfstweight pyxvself pyobject pyxvpyxstate$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst0weight00setstatecythoncythonunused struct pyxobj0pywrapfstweight pyxvself cythonunused pyobject pyxvpyxstate $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextsetstatecython 0$^$^   tree fragment0$^      raise typeerrorself.weight cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate$^      raise typeerrorself.weight cannot be converted to a python object for pickling              $^ $^  pyxt0  pyxpyobjectcallpyxbuiltintypeerror pyxtuple0 null if unlikelypyxt0 pyxerr0 0 pyxl0error$^  pyxgotrefpyxt0$^  pyxraisepyxt0 0 0 0$^  pyxdecrefpyxt0 pyxt0  0$^  pyxerr0 0 pyxl0error$^$^   tree fragment0$^  def reducecythonself$^      raise typeerrorself.weight cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate              $^      raise typeerrorself.weight cannot be converted to a python object for pickling$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.weight.setstatecython pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx000$^  $^  $^  cdef weight plusweight lhs weight rhs              $^    cdef weight result  weight.newweight$^    result.weight.resetnew fst.weightclassfst.plusdereflhs.weight$^ $^$^static struct pyxobj0pywrapfstweight pyxf0pywrapfstplusstruct pyxobj0pywrapfstweight pyxvlhs struct pyxobj0pywrapfstweight pyxvrhs $^  struct pyxobj0pywrapfstweight pyxvresult  0$^  struct pyxobj0pywrapfstweight pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextplus 0$^$^   pywrapfst.pyx000$^  $^  cdef weight plusweight lhs weight rhs$^    cdef weight result  weight.newweight              $^    result.weight.resetnew fst.weightclassfst.plusdereflhs.weight$^                                                      derefrhs.weight$^ $^  pyxt0  pyxtpnew0pywrapfstweightpytypeobject pyxptype0pywrapfstweight pyxemptytuple null if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  if likelypyxtypetestpyxt0 pyxptype0pywrapfstweight pyxerr0 000 pyxl0error$^  pyxvresult  struct pyxobj0pywrapfstweight pyxt0$^  pyxt0  0$^$^   pywrapfst.pyx000$^  cdef weight plusweight lhs weight rhs$^    cdef weight result  weight.newweight$^    result.weight.resetnew fst.weightclassfst.plusdereflhs.weight              $^                                                      derefrhs.weight$^    return result$^ $^  if unlikelypyobject pyxvresult  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s weight$^    pyxerr0 000 pyxl0error$^  $^  if unlikelypyobject pyxvlhs  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s weight$^    pyxerr0 000 pyxl0error$^  $^$^   pywrapfst.pyx000$^    cdef weight result  weight.newweight$^    result.weight.resetnew fst.weightclassfst.plusdereflhs.weight$^                                                      derefrhs.weight              $^    return result$^  $^ $^  if unlikelypyobject pyxvrhs  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s weight$^    pyxerr0 000 pyxl0error$^  $^$^   pywrapfst.pyx000$^  cdef weight plusweight lhs weight rhs$^    cdef weight result  weight.newweight$^    result.weight.resetnew fst.weightclassfst.plusdereflhs.weight              $^                                                      derefrhs.weight$^    return result$^ $^  pyxvresultweight.resetnew fstscriptweightclassfstscriptpluspyxvlhsweight pyxvrhsweight$^$^   pywrapfst.pyx000$^    result.weight.resetnew fst.weightclassfst.plusdereflhs.weight$^                                                      derefrhs.weight$^    return result              $^  $^  $^ $^  pyxxdecrefpyobject pyxr$^  pyxincrefpyobject pyxvresult$^  pyxr  pyxvresult$^  goto pyxl0$^$^   pywrapfst.pyx000$^  $^  $^  cdef weight plusweight lhs weight rhs              $^    cdef weight result  weight.newweight$^    result.weight.resetnew fst.weightclassfst.plusdereflhs.weight$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.plus pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxl0$^  pyxxdecrefpyobject pyxvresult$^  pyxxgiverefpyobject pyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx000$^  $^  $^  def plusweight lhs weight rhs              $^    $^    pluslhs rhs$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst0pluspyobject pyxself pyobject pyxargs pyobject pyxkwds proto$^static char pyxdoc0pywrapfstplus  n  pluslhs rhsnn  computes the sum of two weights in the same semiring.nn  this function computes lhs oplus rhs raising an exception if lhs and rhsn  are not in the same semiring.nn  argsn     lhs lefthand side weight.n     rhs righthand side weight.nn  returnsn    a weight object.nn  raisesn    fstargerror weight type not found or not in same semiring.n    fstbadweighterror invalid weight.n  $^static pymethoddef pyxmdef0pywrapfst0plus  plus pycfunctionpyxpw0pywrapfst0plus methvarargsmethkeywords pyxdoc0pywrapfstplus$^static pyobject pyxpw0pywrapfst0pluspyobject pyxself pyobject pyxargs pyobject pyxkwds $^  struct pyxobj0pywrapfstweight pyxvlhs  0$^  struct pyxobj0pywrapfstweight pyxvrhs  0$^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextplus wrapper 0$^  $^    static pyobject pyxpyargnames  pyxnslhspyxnsrhs0$^    pyobject values0  00$^    if unlikelypyxkwds $^      pyssizet kwargs$^      const pyssizet posargs  pytuplegetsizepyxargs$^      switch posargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 break$^        default goto pyxl0argtupleerror$^      $^      kwargs  pydictsizepyxkwds$^      switch posargs $^        case  0$^        if likelyvalues0  pydictgetitempyxkwds pyxnslhs  0 kwargs$^        else goto pyxl0argtupleerror$^        cythonfallthrough$^        case  0$^        if likelyvalues0  pydictgetitempyxkwds pyxnsrhs  0 kwargs$^        else $^          pyxraiseargtupleinvalidplus 0 0 0 0 pyxerr0 000 pyxl0error$^        $^      $^      if unlikelykwargs  0 $^        if unlikelypyxparseoptionalkeywordspyxkwds pyxpyargnames 0 values posargs plus  0 pyxerr0 000 pyxl0error$^      $^     else if pytuplegetsizepyxargs  0 $^      goto pyxl0argtupleerror$^     else $^      values0  pytuplegetitempyxargs 0$^      values0  pytuplegetitempyxargs 0$^    $^    pyxvlhs  struct pyxobj0pywrapfstweight values0$^    pyxvrhs  struct pyxobj0pywrapfstweight values0$^  $^  goto pyxl0argumentunpackingdone$^  pyxl0argtupleerror$^  pyxraiseargtupleinvalidplus 0 0 0 pytuplegetsizepyxargs pyxerr0 000 pyxl0error$^  pyxl0error$^  pyxaddtracebackpywrapfst.plus pyxclineno pyxlineno pyxfilename$^  pyxrefnannyfinishcontext$^  return null$^  pyxl0argumentunpackingdone$^  if unlikelypyxargtypetestpyobject pyxvlhs pyxptype0pywrapfstweight 0 lhs 0 pyxerr0 000 pyxl0error$^  if unlikelypyxargtypetestpyobject pyxvrhs pyxptype0pywrapfstweight 0 rhs 0 pyxerr0 000 pyxl0error$^  pyxr  pyxpf0pywrapfstpluspyxself pyxvlhs pyxvrhs$^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxr  null$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfstpluscythonunused pyobject pyxself struct pyxobj0pywrapfstweight pyxvlhs struct pyxobj0pywrapfstweight pyxvrhs $^  struct pyxobj0pywrapfstweight pyxvresult  0$^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextplus 0$^$^   pywrapfst.pyx000$^      fstbadweighterror invalid weight.$^    $^    cdef weight result  pluslhs rhs              $^    result.checkweight$^    return result$^ $^  pyxt0  pyobject pyxf0pywrapfstpluspyxvlhs pyxvrhs if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxvresult  struct pyxobj0pywrapfstweight pyxt0$^  pyxt0  0$^$^   pywrapfst.pyx000$^    $^    cdef weight result  pluslhs rhs$^    result.checkweight              $^    return result$^  $^ $^  if unlikelypyobject pyxvresult  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s checkweight$^    pyxerr0 000 pyxl0error$^  $^  struct pyxvtabstruct0pywrapfstweight pyxvresultpyxvtabcheckweightpyxvresult if unlikelypyerroccurred pyxerr0 000 pyxl0error$^$^   pywrapfst.pyx000$^    cdef weight result  pluslhs rhs$^    result.checkweight$^    return result              $^  $^  $^ $^  pyxxdecrefpyxr$^  pyxincrefpyobject pyxvresult$^  pyxr  pyobject pyxvresult$^  goto pyxl0$^$^   pywrapfst.pyx000$^  $^  $^  def plusweight lhs weight rhs              $^    $^    pluslhs rhs$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.plus pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxdecrefpyobject pyxvresult$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx000$^  $^  $^  cdef weight timesweight lhs weight rhs              $^    cdef weight result  weight.newweight$^    result.weight.resetnew fst.weightclassfst.timesdereflhs.weight$^ $^$^static struct pyxobj0pywrapfstweight pyxf0pywrapfsttimesstruct pyxobj0pywrapfstweight pyxvlhs struct pyxobj0pywrapfstweight pyxvrhs $^  struct pyxobj0pywrapfstweight pyxvresult  0$^  struct pyxobj0pywrapfstweight pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontexttimes 0$^$^   pywrapfst.pyx000$^  $^  cdef weight timesweight lhs weight rhs$^    cdef weight result  weight.newweight              $^    result.weight.resetnew fst.weightclassfst.timesdereflhs.weight$^                                                       derefrhs.weight$^ $^  pyxt0  pyxtpnew0pywrapfstweightpytypeobject pyxptype0pywrapfstweight pyxemptytuple null if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  if likelypyxtypetestpyxt0 pyxptype0pywrapfstweight pyxerr0 000 pyxl0error$^  pyxvresult  struct pyxobj0pywrapfstweight pyxt0$^  pyxt0  0$^$^   pywrapfst.pyx000$^  cdef weight timesweight lhs weight rhs$^    cdef weight result  weight.newweight$^    result.weight.resetnew fst.weightclassfst.timesdereflhs.weight              $^                                                       derefrhs.weight$^    return result$^ $^  if unlikelypyobject pyxvresult  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s weight$^    pyxerr0 000 pyxl0error$^  $^  if unlikelypyobject pyxvlhs  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s weight$^    pyxerr0 000 pyxl0error$^  $^$^   pywrapfst.pyx000$^    cdef weight result  weight.newweight$^    result.weight.resetnew fst.weightclassfst.timesdereflhs.weight$^                                                       derefrhs.weight              $^    return result$^  $^ $^  if unlikelypyobject pyxvrhs  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s weight$^    pyxerr0 000 pyxl0error$^  $^$^   pywrapfst.pyx000$^  cdef weight timesweight lhs weight rhs$^    cdef weight result  weight.newweight$^    result.weight.resetnew fst.weightclassfst.timesdereflhs.weight              $^                                                       derefrhs.weight$^    return result$^ $^  pyxvresultweight.resetnew fstscriptweightclassfstscripttimespyxvlhsweight pyxvrhsweight$^$^   pywrapfst.pyx000$^    result.weight.resetnew fst.weightclassfst.timesdereflhs.weight$^                                                       derefrhs.weight$^    return result              $^  $^  $^ $^  pyxxdecrefpyobject pyxr$^  pyxincrefpyobject pyxvresult$^  pyxr  pyxvresult$^  goto pyxl0$^$^   pywrapfst.pyx000$^  $^  $^  cdef weight timesweight lhs weight rhs              $^    cdef weight result  weight.newweight$^    result.weight.resetnew fst.weightclassfst.timesdereflhs.weight$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.times pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxl0$^  pyxxdecrefpyobject pyxvresult$^  pyxxgiverefpyobject pyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx000$^  $^  $^  def timesweight lhs weight rhs              $^    $^    timeslhs rhs$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst0timespyobject pyxself pyobject pyxargs pyobject pyxkwds proto$^static char pyxdoc0pywrapfst0times  n  timeslhs rhsnn  computes the product of two weights in the same semiring.nn  this function computes lhs otimes rhs raising an exception if lhs and rhsn  are not in the same semiring.nn  argsn     lhs lefthand side weight.n     rhs righthand side weight.nn  returnsn    a weight object.nn  raisesn    fstargerror weight type not found or not in same semiring.n    fstbadweighterror invalid weight.n  $^static pymethoddef pyxmdef0pywrapfst0times  times pycfunctionpyxpw0pywrapfst0times methvarargsmethkeywords pyxdoc0pywrapfst0times$^static pyobject pyxpw0pywrapfst0timespyobject pyxself pyobject pyxargs pyobject pyxkwds $^  struct pyxobj0pywrapfstweight pyxvlhs  0$^  struct pyxobj0pywrapfstweight pyxvrhs  0$^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontexttimes wrapper 0$^  $^    static pyobject pyxpyargnames  pyxnslhspyxnsrhs0$^    pyobject values0  00$^    if unlikelypyxkwds $^      pyssizet kwargs$^      const pyssizet posargs  pytuplegetsizepyxargs$^      switch posargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 break$^        default goto pyxl0argtupleerror$^      $^      kwargs  pydictsizepyxkwds$^      switch posargs $^        case  0$^        if likelyvalues0  pydictgetitempyxkwds pyxnslhs  0 kwargs$^        else goto pyxl0argtupleerror$^        cythonfallthrough$^        case  0$^        if likelyvalues0  pydictgetitempyxkwds pyxnsrhs  0 kwargs$^        else $^          pyxraiseargtupleinvalidtimes 0 0 0 0 pyxerr0 000 pyxl0error$^        $^      $^      if unlikelykwargs  0 $^        if unlikelypyxparseoptionalkeywordspyxkwds pyxpyargnames 0 values posargs times  0 pyxerr0 000 pyxl0error$^      $^     else if pytuplegetsizepyxargs  0 $^      goto pyxl0argtupleerror$^     else $^      values0  pytuplegetitempyxargs 0$^      values0  pytuplegetitempyxargs 0$^    $^    pyxvlhs  struct pyxobj0pywrapfstweight values0$^    pyxvrhs  struct pyxobj0pywrapfstweight values0$^  $^  goto pyxl0argumentunpackingdone$^  pyxl0argtupleerror$^  pyxraiseargtupleinvalidtimes 0 0 0 pytuplegetsizepyxargs pyxerr0 000 pyxl0error$^  pyxl0error$^  pyxaddtracebackpywrapfst.times pyxclineno pyxlineno pyxfilename$^  pyxrefnannyfinishcontext$^  return null$^  pyxl0argumentunpackingdone$^  if unlikelypyxargtypetestpyobject pyxvlhs pyxptype0pywrapfstweight 0 lhs 0 pyxerr0 000 pyxl0error$^  if unlikelypyxargtypetestpyobject pyxvrhs pyxptype0pywrapfstweight 0 rhs 0 pyxerr0 000 pyxl0error$^  pyxr  pyxpf0pywrapfst0timespyxself pyxvlhs pyxvrhs$^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxr  null$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst0timescythonunused pyobject pyxself struct pyxobj0pywrapfstweight pyxvlhs struct pyxobj0pywrapfstweight pyxvrhs $^  struct pyxobj0pywrapfstweight pyxvresult  0$^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontexttimes 0$^$^   pywrapfst.pyx000$^      fstbadweighterror invalid weight.$^    $^    cdef weight result  timeslhs rhs              $^    result.checkweight$^    return result$^ $^  pyxt0  pyobject pyxf0pywrapfsttimespyxvlhs pyxvrhs if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxvresult  struct pyxobj0pywrapfstweight pyxt0$^  pyxt0  0$^$^   pywrapfst.pyx000$^    $^    cdef weight result  timeslhs rhs$^    result.checkweight              $^    return result$^  $^ $^  if unlikelypyobject pyxvresult  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s checkweight$^    pyxerr0 000 pyxl0error$^  $^  struct pyxvtabstruct0pywrapfstweight pyxvresultpyxvtabcheckweightpyxvresult if unlikelypyerroccurred pyxerr0 000 pyxl0error$^$^   pywrapfst.pyx000$^    cdef weight result  timeslhs rhs$^    result.checkweight$^    return result              $^  $^  $^ $^  pyxxdecrefpyxr$^  pyxincrefpyobject pyxvresult$^  pyxr  pyobject pyxvresult$^  goto pyxl0$^$^   pywrapfst.pyx000$^  $^  $^  def timesweight lhs weight rhs              $^    $^    timeslhs rhs$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.times pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxdecrefpyobject pyxvresult$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx000$^  $^  $^  cdef weight divideweight lhs weight rhs              $^    cdef weight result  weight.newweight$^    result.weight.resetnew fst.weightclassfst.dividedereflhs.weight$^ $^$^static struct pyxobj0pywrapfstweight pyxf0pywrapfstdividestruct pyxobj0pywrapfstweight pyxvlhs struct pyxobj0pywrapfstweight pyxvrhs $^  struct pyxobj0pywrapfstweight pyxvresult  0$^  struct pyxobj0pywrapfstweight pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextdivide 0$^$^   pywrapfst.pyx000$^  $^  cdef weight divideweight lhs weight rhs$^    cdef weight result  weight.newweight              $^    result.weight.resetnew fst.weightclassfst.dividedereflhs.weight$^                                                        derefrhs.weight$^ $^  pyxt0  pyxtpnew0pywrapfstweightpytypeobject pyxptype0pywrapfstweight pyxemptytuple null if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  if likelypyxtypetestpyxt0 pyxptype0pywrapfstweight pyxerr0 000 pyxl0error$^  pyxvresult  struct pyxobj0pywrapfstweight pyxt0$^  pyxt0  0$^$^   pywrapfst.pyx000$^  cdef weight divideweight lhs weight rhs$^    cdef weight result  weight.newweight$^    result.weight.resetnew fst.weightclassfst.dividedereflhs.weight              $^                                                        derefrhs.weight$^    return result$^ $^  if unlikelypyobject pyxvresult  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s weight$^    pyxerr0 000 pyxl0error$^  $^  if unlikelypyobject pyxvlhs  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s weight$^    pyxerr0 000 pyxl0error$^  $^$^   pywrapfst.pyx000$^    cdef weight result  weight.newweight$^    result.weight.resetnew fst.weightclassfst.dividedereflhs.weight$^                                                        derefrhs.weight              $^    return result$^  $^ $^  if unlikelypyobject pyxvrhs  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s weight$^    pyxerr0 000 pyxl0error$^  $^$^   pywrapfst.pyx000$^  cdef weight divideweight lhs weight rhs$^    cdef weight result  weight.newweight$^    result.weight.resetnew fst.weightclassfst.dividedereflhs.weight              $^                                                        derefrhs.weight$^    return result$^ $^  pyxvresultweight.resetnew fstscriptweightclassfstscriptdividepyxvlhsweight pyxvrhsweight$^$^   pywrapfst.pyx000$^    result.weight.resetnew fst.weightclassfst.dividedereflhs.weight$^                                                        derefrhs.weight$^    return result              $^  $^  $^ $^  pyxxdecrefpyobject pyxr$^  pyxincrefpyobject pyxvresult$^  pyxr  pyxvresult$^  goto pyxl0$^$^   pywrapfst.pyx000$^  $^  $^  cdef weight divideweight lhs weight rhs              $^    cdef weight result  weight.newweight$^    result.weight.resetnew fst.weightclassfst.dividedereflhs.weight$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.divide pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxl0$^  pyxxdecrefpyobject pyxvresult$^  pyxxgiverefpyobject pyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx000$^  $^  $^  def divideweight lhs weight rhs              $^    $^    dividelhs rhs$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst0dividepyobject pyxself pyobject pyxargs pyobject pyxkwds proto$^static char pyxdoc0pywrapfst0divide  n  dividelhs rhsnn  computes the quotient of two weights in the same semiring.nn  this function computes lhs oslash rhs raising an exception if lhs and rhsn  are not in the same semiring. as there is no way to specify whether to usen  left vs. right division this assumes a commutative semiring in which thesen  are equivalent operations.nn  argsn     lhs lefthand side weight.n     rhs righthand side weight.nn  returnsn    a weight object.nn  raisesn    fstargerror weight type not found or not in same semiring.n    fstbadweighterror invalid weight.n  $^static pymethoddef pyxmdef0pywrapfst0divide  divide pycfunctionpyxpw0pywrapfst0divide methvarargsmethkeywords pyxdoc0pywrapfst0divide$^static pyobject pyxpw0pywrapfst0dividepyobject pyxself pyobject pyxargs pyobject pyxkwds $^  struct pyxobj0pywrapfstweight pyxvlhs  0$^  struct pyxobj0pywrapfstweight pyxvrhs  0$^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextdivide wrapper 0$^  $^    static pyobject pyxpyargnames  pyxnslhspyxnsrhs0$^    pyobject values0  00$^    if unlikelypyxkwds $^      pyssizet kwargs$^      const pyssizet posargs  pytuplegetsizepyxargs$^      switch posargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 break$^        default goto pyxl0argtupleerror$^      $^      kwargs  pydictsizepyxkwds$^      switch posargs $^        case  0$^        if likelyvalues0  pydictgetitempyxkwds pyxnslhs  0 kwargs$^        else goto pyxl0argtupleerror$^        cythonfallthrough$^        case  0$^        if likelyvalues0  pydictgetitempyxkwds pyxnsrhs  0 kwargs$^        else $^          pyxraiseargtupleinvaliddivide 0 0 0 0 pyxerr0 000 pyxl0error$^        $^      $^      if unlikelykwargs  0 $^        if unlikelypyxparseoptionalkeywordspyxkwds pyxpyargnames 0 values posargs divide  0 pyxerr0 000 pyxl0error$^      $^     else if pytuplegetsizepyxargs  0 $^      goto pyxl0argtupleerror$^     else $^      values0  pytuplegetitempyxargs 0$^      values0  pytuplegetitempyxargs 0$^    $^    pyxvlhs  struct pyxobj0pywrapfstweight values0$^    pyxvrhs  struct pyxobj0pywrapfstweight values0$^  $^  goto pyxl0argumentunpackingdone$^  pyxl0argtupleerror$^  pyxraiseargtupleinvaliddivide 0 0 0 pytuplegetsizepyxargs pyxerr0 000 pyxl0error$^  pyxl0error$^  pyxaddtracebackpywrapfst.divide pyxclineno pyxlineno pyxfilename$^  pyxrefnannyfinishcontext$^  return null$^  pyxl0argumentunpackingdone$^  if unlikelypyxargtypetestpyobject pyxvlhs pyxptype0pywrapfstweight 0 lhs 0 pyxerr0 000 pyxl0error$^  if unlikelypyxargtypetestpyobject pyxvrhs pyxptype0pywrapfstweight 0 rhs 0 pyxerr0 000 pyxl0error$^  pyxr  pyxpf0pywrapfst0dividepyxself pyxvlhs pyxvrhs$^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxr  null$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst0dividecythonunused pyobject pyxself struct pyxobj0pywrapfstweight pyxvlhs struct pyxobj0pywrapfstweight pyxvrhs $^  struct pyxobj0pywrapfstweight pyxvresult  0$^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextdivide 0$^$^   pywrapfst.pyx000$^      fstbadweighterror invalid weight.$^    $^    cdef weight result  dividelhs rhs              $^    result.checkweight$^    return result$^ $^  pyxt0  pyobject pyxf0pywrapfstdividepyxvlhs pyxvrhs if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxvresult  struct pyxobj0pywrapfstweight pyxt0$^  pyxt0  0$^$^   pywrapfst.pyx000$^    $^    cdef weight result  dividelhs rhs$^    result.checkweight              $^    return result$^  $^ $^  if unlikelypyobject pyxvresult  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s checkweight$^    pyxerr0 000 pyxl0error$^  $^  struct pyxvtabstruct0pywrapfstweight pyxvresultpyxvtabcheckweightpyxvresult if unlikelypyerroccurred pyxerr0 000 pyxl0error$^$^   pywrapfst.pyx000$^    cdef weight result  dividelhs rhs$^    result.checkweight$^    return result              $^  $^  $^ $^  pyxxdecrefpyxr$^  pyxincrefpyobject pyxvresult$^  pyxr  pyobject pyxvresult$^  goto pyxl0$^$^   pywrapfst.pyx000$^  $^  $^  def divideweight lhs weight rhs              $^    $^    dividelhs rhs$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.divide pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxdecrefpyobject pyxvresult$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx000$^  $^  $^  cdef weight powerweight w sizet n              $^    cdef weight result  weight.newweight$^    result.weight.resetnew fst.weightclassfst.powerderefw.weight n$^ $^$^static struct pyxobj0pywrapfstweight pyxf0pywrapfstpowerstruct pyxobj0pywrapfstweight pyxvw sizet pyxvn $^  struct pyxobj0pywrapfstweight pyxvresult  0$^  struct pyxobj0pywrapfstweight pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextpower 0$^$^   pywrapfst.pyx000$^  $^  cdef weight powerweight w sizet n$^    cdef weight result  weight.newweight              $^    result.weight.resetnew fst.weightclassfst.powerderefw.weight n$^    return result$^ $^  pyxt0  pyxtpnew0pywrapfstweightpytypeobject pyxptype0pywrapfstweight pyxemptytuple null if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  if likelypyxtypetestpyxt0 pyxptype0pywrapfstweight pyxerr0 000 pyxl0error$^  pyxvresult  struct pyxobj0pywrapfstweight pyxt0$^  pyxt0  0$^$^   pywrapfst.pyx000$^  cdef weight powerweight w sizet n$^    cdef weight result  weight.newweight$^    result.weight.resetnew fst.weightclassfst.powerderefw.weight n              $^    return result$^  $^ $^  if unlikelypyobject pyxvresult  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s weight$^    pyxerr0 000 pyxl0error$^  $^  if unlikelypyobject pyxvw  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s weight$^    pyxerr0 000 pyxl0error$^  $^  pyxvresultweight.resetnew fstscriptweightclassfstscriptpowerpyxvwweight pyxvn$^$^   pywrapfst.pyx000$^    cdef weight result  weight.newweight$^    result.weight.resetnew fst.weightclassfst.powerderefw.weight n$^    return result              $^  $^  $^ $^  pyxxdecrefpyobject pyxr$^  pyxincrefpyobject pyxvresult$^  pyxr  pyxvresult$^  goto pyxl0$^$^   pywrapfst.pyx000$^  $^  $^  cdef weight powerweight w sizet n              $^    cdef weight result  weight.newweight$^    result.weight.resetnew fst.weightclassfst.powerderefw.weight n$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.power pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxl0$^  pyxxdecrefpyobject pyxvresult$^  pyxxgiverefpyobject pyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx000$^  $^  $^  def powerweight w sizet n              $^    $^    powerlhs rhs$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst0powerpyobject pyxself pyobject pyxargs pyobject pyxkwds proto$^static char pyxdoc0pywrapfst0power  n  powerlhs rhsnn  computes the iterated product of a weight.nn  argsn     w the weight.n     n the power.nn  returnsn    a weight object.nn  raisesn    fstargerror weight type not found or not in same semiring.n    fstbadweighterror invalid weight.n  $^static pymethoddef pyxmdef0pywrapfst0power  power pycfunctionpyxpw0pywrapfst0power methvarargsmethkeywords pyxdoc0pywrapfst0power$^static pyobject pyxpw0pywrapfst0powerpyobject pyxself pyobject pyxargs pyobject pyxkwds $^  struct pyxobj0pywrapfstweight pyxvw  0$^  sizet pyxvn$^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextpower wrapper 0$^  $^    static pyobject pyxpyargnames  pyxnswpyxnsn0$^    pyobject values0  00$^    if unlikelypyxkwds $^      pyssizet kwargs$^      const pyssizet posargs  pytuplegetsizepyxargs$^      switch posargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 break$^        default goto pyxl0argtupleerror$^      $^      kwargs  pydictsizepyxkwds$^      switch posargs $^        case  0$^        if likelyvalues0  pydictgetitempyxkwds pyxnsw  0 kwargs$^        else goto pyxl0argtupleerror$^        cythonfallthrough$^        case  0$^        if likelyvalues0  pydictgetitempyxkwds pyxnsn  0 kwargs$^        else $^          pyxraiseargtupleinvalidpower 0 0 0 0 pyxerr0 000 pyxl0error$^        $^      $^      if unlikelykwargs  0 $^        if unlikelypyxparseoptionalkeywordspyxkwds pyxpyargnames 0 values posargs power  0 pyxerr0 000 pyxl0error$^      $^     else if pytuplegetsizepyxargs  0 $^      goto pyxl0argtupleerror$^     else $^      values0  pytuplegetitempyxargs 0$^      values0  pytuplegetitempyxargs 0$^    $^    pyxvw  struct pyxobj0pywrapfstweight values0$^    pyxvn  pyxpyintassizetvalues0 if unlikelypyxvn  sizet0  pyerroccurred pyxerr0 000 pyxl0error$^  $^  goto pyxl0argumentunpackingdone$^  pyxl0argtupleerror$^  pyxraiseargtupleinvalidpower 0 0 0 pytuplegetsizepyxargs pyxerr0 000 pyxl0error$^  pyxl0error$^  pyxaddtracebackpywrapfst.power pyxclineno pyxlineno pyxfilename$^  pyxrefnannyfinishcontext$^  return null$^  pyxl0argumentunpackingdone$^  if unlikelypyxargtypetestpyobject pyxvw pyxptype0pywrapfstweight 0 w 0 pyxerr0 000 pyxl0error$^  pyxr  pyxpf0pywrapfst0powerpyxself pyxvw pyxvn$^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxr  null$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst0powercythonunused pyobject pyxself struct pyxobj0pywrapfstweight pyxvw sizet pyxvn $^  struct pyxobj0pywrapfstweight pyxvresult  0$^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextpower 0$^$^   pywrapfst.pyx000$^      fstbadweighterror invalid weight.$^    $^    cdef weight result  powerw n              $^    result.checkweight$^    return result$^ $^  pyxt0  pyobject pyxf0pywrapfstpowerpyxvw pyxvn if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxvresult  struct pyxobj0pywrapfstweight pyxt0$^  pyxt0  0$^$^   pywrapfst.pyx000$^    $^    cdef weight result  powerw n$^    result.checkweight              $^    return result$^  $^ $^  if unlikelypyobject pyxvresult  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s checkweight$^    pyxerr0 000 pyxl0error$^  $^  struct pyxvtabstruct0pywrapfstweight pyxvresultpyxvtabcheckweightpyxvresult if unlikelypyerroccurred pyxerr0 000 pyxl0error$^$^   pywrapfst.pyx000$^    cdef weight result  powerw n$^    result.checkweight$^    return result              $^  $^  $^ $^  pyxxdecrefpyxr$^  pyxincrefpyobject pyxvresult$^  pyxr  pyobject pyxvresult$^  goto pyxl0$^$^   pywrapfst.pyx000$^  $^  $^  def powerweight w sizet n              $^    $^    powerlhs rhs$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.power pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxdecrefpyobject pyxvresult$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx000$^  $^  $^  cdef fst.weightclass getweightclassorzeroconst string weighttype              $^                                                weight except $^    converts weight string to a weightclass.$^ $^$^static fstscriptweightclass pyxf0pywrapfstgetweightclassorzerostdstring const pyxvweighttype pyobject pyxvweight $^  fstscriptweightclass pyxvresult$^  fstscriptweightclass pyxr$^  pyxrefnannydeclarations$^  int pyxt0$^  int pyxt0$^  stdstring pyxt0$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextgetweightclassorzero 0$^$^   pywrapfst.pyx000$^    $^    cdef fst.weightclass result$^    if weight is none              $^      result  fst.weightclass.zeroweighttype$^    elif isinstanceweight weight$^ $^  pyxt0  pyxvweight  pynone$^  pyxt0  pyxt0  0$^  if pyxt0 $^$^     pywrapfst.pyx000$^    cdef fst.weightclass result$^    if weight is none$^      result  fst.weightclass.zeroweighttype              $^    elif isinstanceweight weight$^      result  dereffst.weightclass  weight weight.weight.get$^ $^    pyxvresult  fstscriptweightclasszeropyxvweighttype$^$^     pywrapfst.pyx000$^    $^    cdef fst.weightclass result$^    if weight is none              $^      result  fst.weightclass.zeroweighttype$^    elif isinstanceweight weight$^ $^    goto pyxl0$^  $^$^   pywrapfst.pyx000$^    if weight is none$^      result  fst.weightclass.zeroweighttype$^    elif isinstanceweight weight              $^      result  dereffst.weightclass  weight weight.weight.get$^    else$^ $^  pyxt0  pyxtypecheckpyxvweight pyxptype0pywrapfstweight $^  pyxt0  pyxt0  0$^  if pyxt0 $^$^     pywrapfst.pyx000$^      result  fst.weightclass.zeroweighttype$^    elif isinstanceweight weight$^      result  dereffst.weightclass  weight weight.weight.get              $^    else$^      result  fst.weightclassweighttype weighttostringweight$^ $^    if unlikelypyxvweight  pynone $^      pyerrformatpyexcattributeerror nonetype object has no attribute .00s weight$^      pyxerr0 000 pyxl0error$^    $^    pyxvresult  fstscriptweightclass struct pyxobj0pywrapfstweight pyxvweightweight.get$^$^     pywrapfst.pyx000$^    if weight is none$^      result  fst.weightclass.zeroweighttype$^    elif isinstanceweight weight              $^      result  dereffst.weightclass  weight weight.weight.get$^    else$^ $^    goto pyxl0$^  $^$^   pywrapfst.pyx000$^      result  dereffst.weightclass  weight weight.weight.get$^    else$^      result  fst.weightclassweighttype weighttostringweight              $^      if result.tostring  bbadnumber$^        raise fstbadweighterrorweighttostringweight$^ $^  else $^    pyxt0  pyxf0pywrapfstweighttostringpyxvweight null if unlikelypyerroccurred pyxerr0 000 pyxl0error$^    pyxvresult  fstscriptweightclasspyxvweighttype pyxt0$^$^     pywrapfst.pyx000$^    else$^      result  fst.weightclassweighttype weighttostringweight$^      if result.tostring  bbadnumber              $^        raise fstbadweighterrorweighttostringweight$^    return result$^ $^    pyxt0  pyxvresult.tostring  char badnumber  0$^    if pyxt0 $^$^       pywrapfst.pyx000$^      result  fst.weightclassweighttype weighttostringweight$^      if result.tostring  bbadnumber$^        raise fstbadweighterrorweighttostringweight              $^    return result$^  $^ $^      pyxt0  pyxgetmoduleglobalnamepyxnsfstbadweighterror if unlikelypyxt0 pyxerr0 000 pyxl0error$^      pyxgotrefpyxt0$^      pyxt0  pyxf0pywrapfstweighttostringpyxvweight null if unlikelypyerroccurred pyxerr0 000 pyxl0error$^      pyxt0  pyxconvertpybytesstringtopystdinstringpyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^      pyxgotrefpyxt0$^      pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^       else $^        if cythonfastpycall$^        if pyfunctioncheckpyxt0 $^          pyobject pyxtemp0  pyxt0 pyxt0$^          pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^          pyxxdecrefpyxt0 pyxt0  0$^          pyxgotrefpyxt0$^          pyxdecrefpyxt0 pyxt0  0$^         else$^        endif$^        if cythonfastpyccall$^        if pyxpyfastcfunctioncheckpyxt0 $^          pyobject pyxtemp0  pyxt0 pyxt0$^          pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^          pyxxdecrefpyxt0 pyxt0  0$^          pyxgotrefpyxt0$^          pyxdecrefpyxt0 pyxt0  0$^         else$^        endif$^        $^          pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^          pyxgotrefpyxt0$^          pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^          pyxgiverefpyxt0$^          pytuplesetitempyxt0 00 pyxt0$^          pyxt0  0$^          pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 000 pyxl0error$^          pyxgotrefpyxt0$^          pyxdecrefpyxt0 pyxt0  0$^        $^      $^      pyxdecrefpyxt0 pyxt0  0$^      pyxraisepyxt0 0 0 0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxerr0 000 pyxl0error$^$^       pywrapfst.pyx000$^    else$^      result  fst.weightclassweighttype weighttostringweight$^      if result.tostring  bbadnumber              $^        raise fstbadweighterrorweighttostringweight$^    return result$^ $^    $^  $^  pyxl0$^$^   pywrapfst.pyx000$^      if result.tostring  bbadnumber$^        raise fstbadweighterrorweighttostringweight$^    return result              $^  $^  $^ $^  pyxr  pyxvresult$^  goto pyxl0$^$^   pywrapfst.pyx000$^  $^  $^  cdef fst.weightclass getweightclassorzeroconst string weighttype              $^                                                weight except $^    converts weight string to a weightclass.$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.getweightclassorzero pyxclineno pyxlineno pyxfilename$^  pyxpretendtoinitializepyxr$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx000$^  $^  $^  cdef fst.weightclass getweightclassoroneconst string weighttype              $^                                               weight except $^    converts weight string to a weightclass.$^ $^$^static fstscriptweightclass pyxf0pywrapfstgetweightclassoronestdstring const pyxvweighttype pyobject pyxvweight $^  fstscriptweightclass pyxvresult$^  fstscriptweightclass pyxr$^  pyxrefnannydeclarations$^  int pyxt0$^  int pyxt0$^  stdstring pyxt0$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextgetweightclassorone 0$^$^   pywrapfst.pyx000$^    $^    cdef fst.weightclass result$^    if weight is none              $^      result  fst.weightclass.oneweighttype$^    elif isinstanceweight weight$^ $^  pyxt0  pyxvweight  pynone$^  pyxt0  pyxt0  0$^  if pyxt0 $^$^     pywrapfst.pyx000$^    cdef fst.weightclass result$^    if weight is none$^      result  fst.weightclass.oneweighttype              $^    elif isinstanceweight weight$^      result  dereffst.weightclass  weight weight.weight.get$^ $^    pyxvresult  fstscriptweightclassonepyxvweighttype$^$^     pywrapfst.pyx000$^    $^    cdef fst.weightclass result$^    if weight is none              $^      result  fst.weightclass.oneweighttype$^    elif isinstanceweight weight$^ $^    goto pyxl0$^  $^$^   pywrapfst.pyx000$^    if weight is none$^      result  fst.weightclass.oneweighttype$^    elif isinstanceweight weight              $^      result  dereffst.weightclass  weight weight.weight.get$^    else$^ $^  pyxt0  pyxtypecheckpyxvweight pyxptype0pywrapfstweight $^  pyxt0  pyxt0  0$^  if pyxt0 $^$^     pywrapfst.pyx000$^      result  fst.weightclass.oneweighttype$^    elif isinstanceweight weight$^      result  dereffst.weightclass  weight weight.weight.get              $^    else$^      result  fst.weightclassweighttype weighttostringweight$^ $^    if unlikelypyxvweight  pynone $^      pyerrformatpyexcattributeerror nonetype object has no attribute .00s weight$^      pyxerr0 000 pyxl0error$^    $^    pyxvresult  fstscriptweightclass struct pyxobj0pywrapfstweight pyxvweightweight.get$^$^     pywrapfst.pyx000$^    if weight is none$^      result  fst.weightclass.oneweighttype$^    elif isinstanceweight weight              $^      result  dereffst.weightclass  weight weight.weight.get$^    else$^ $^    goto pyxl0$^  $^$^   pywrapfst.pyx000$^      result  dereffst.weightclass  weight weight.weight.get$^    else$^      result  fst.weightclassweighttype weighttostringweight              $^      if result.tostring  bbadnumber$^        raise fstbadweighterrorweighttostringweight$^ $^  else $^    pyxt0  pyxf0pywrapfstweighttostringpyxvweight null if unlikelypyerroccurred pyxerr0 000 pyxl0error$^    pyxvresult  fstscriptweightclasspyxvweighttype pyxt0$^$^     pywrapfst.pyx000$^    else$^      result  fst.weightclassweighttype weighttostringweight$^      if result.tostring  bbadnumber              $^        raise fstbadweighterrorweighttostringweight$^    return result$^ $^    pyxt0  pyxvresult.tostring  char badnumber  0$^    if pyxt0 $^$^       pywrapfst.pyx000$^      result  fst.weightclassweighttype weighttostringweight$^      if result.tostring  bbadnumber$^        raise fstbadweighterrorweighttostringweight              $^    return result$^  $^ $^      pyxt0  pyxgetmoduleglobalnamepyxnsfstbadweighterror if unlikelypyxt0 pyxerr0 000 pyxl0error$^      pyxgotrefpyxt0$^      pyxt0  pyxf0pywrapfstweighttostringpyxvweight null if unlikelypyerroccurred pyxerr0 000 pyxl0error$^      pyxt0  pyxconvertpybytesstringtopystdinstringpyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^      pyxgotrefpyxt0$^      pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^       else $^        if cythonfastpycall$^        if pyfunctioncheckpyxt0 $^          pyobject pyxtemp0  pyxt0 pyxt0$^          pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^          pyxxdecrefpyxt0 pyxt0  0$^          pyxgotrefpyxt0$^          pyxdecrefpyxt0 pyxt0  0$^         else$^        endif$^        if cythonfastpyccall$^        if pyxpyfastcfunctioncheckpyxt0 $^          pyobject pyxtemp0  pyxt0 pyxt0$^          pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^          pyxxdecrefpyxt0 pyxt0  0$^          pyxgotrefpyxt0$^          pyxdecrefpyxt0 pyxt0  0$^         else$^        endif$^        $^          pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^          pyxgotrefpyxt0$^          pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^          pyxgiverefpyxt0$^          pytuplesetitempyxt0 00 pyxt0$^          pyxt0  0$^          pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 000 pyxl0error$^          pyxgotrefpyxt0$^          pyxdecrefpyxt0 pyxt0  0$^        $^      $^      pyxdecrefpyxt0 pyxt0  0$^      pyxraisepyxt0 0 0 0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxerr0 000 pyxl0error$^$^       pywrapfst.pyx000$^    else$^      result  fst.weightclassweighttype weighttostringweight$^      if result.tostring  bbadnumber              $^        raise fstbadweighterrorweighttostringweight$^    return result$^ $^    $^  $^  pyxl0$^$^   pywrapfst.pyx000$^      if result.tostring  bbadnumber$^        raise fstbadweighterrorweighttostringweight$^    return result              $^  $^  $^ $^  pyxr  pyxvresult$^  goto pyxl0$^$^   pywrapfst.pyx000$^  $^  $^  cdef fst.weightclass getweightclassoroneconst string weighttype              $^                                               weight except $^    converts weight string to a weightclass.$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.getweightclassorone pyxclineno pyxlineno pyxfilename$^  pyxpretendtoinitializepyxr$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx000$^  $^  $^  cdef weight zeroweighttype              $^    cdef weight result  weight.newweight$^    result.weight.resetnew fst.weightclassfst.weightclass.zero$^ $^$^static struct pyxobj0pywrapfstweight pyxf0pywrapfstzeropyobject pyxvweighttype $^  struct pyxobj0pywrapfstweight pyxvresult  0$^  struct pyxobj0pywrapfstweight pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  stdstring pyxt0$^  int pyxt0$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextzero 0$^$^   pywrapfst.pyx000$^  $^  cdef weight zeroweighttype$^    cdef weight result  weight.newweight              $^    result.weight.resetnew fst.weightclassfst.weightclass.zero$^        tostringweighttype$^ $^  pyxt0  pyxtpnew0pywrapfstweightpytypeobject pyxptype0pywrapfstweight pyxemptytuple null if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  if likelypyxtypetestpyxt0 pyxptype0pywrapfstweight pyxerr0 000 pyxl0error$^  pyxvresult  struct pyxobj0pywrapfstweight pyxt0$^  pyxt0  0$^$^   pywrapfst.pyx000$^  cdef weight zeroweighttype$^    cdef weight result  weight.newweight$^    result.weight.resetnew fst.weightclassfst.weightclass.zero              $^        tostringweighttype$^    if result.weight.get.type  bnone$^ $^  if unlikelypyobject pyxvresult  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s weight$^    pyxerr0 000 pyxl0error$^  $^$^   pywrapfst.pyx000$^    cdef weight result  weight.newweight$^    result.weight.resetnew fst.weightclassfst.weightclass.zero$^        tostringweighttype              $^    if result.weight.get.type  bnone$^      raise fstargerrorweight type not found$^ $^  pyxt0  pyxf0pywrapfsttostringpyxvweighttype null if unlikelypyerroccurred pyxerr0 000 pyxl0error$^$^   pywrapfst.pyx000$^  cdef weight zeroweighttype$^    cdef weight result  weight.newweight$^    result.weight.resetnew fst.weightclassfst.weightclass.zero              $^        tostringweighttype$^    if result.weight.get.type  bnone$^ $^  pyxvresultweight.resetnew fstscriptweightclassfstscriptweightclasszeropyxt0$^$^   pywrapfst.pyx000$^    result.weight.resetnew fst.weightclassfst.weightclass.zero$^        tostringweighttype$^    if result.weight.get.type  bnone              $^      raise fstargerrorweight type not found$^    return result$^ $^  if unlikelypyobject pyxvresult  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s weight$^    pyxerr0 000 pyxl0error$^  $^  pyxt0  pyxvresultweight.gettype  char none  0$^  if pyxt0 $^$^     pywrapfst.pyx000$^        tostringweighttype$^    if result.weight.get.type  bnone$^      raise fstargerrorweight type not found              $^    return result$^  $^ $^    pyxt0  pyxgetmoduleglobalnamepyxnsfstargerror if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  pyxpyobjectcallpyxt0 pyxtuple0 null if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxgotrefpyxt0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxraisepyxt0 0 0 0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxerr0 000 pyxl0error$^$^     pywrapfst.pyx000$^    result.weight.resetnew fst.weightclassfst.weightclass.zero$^        tostringweighttype$^    if result.weight.get.type  bnone              $^      raise fstargerrorweight type not found$^    return result$^ $^  $^$^   pywrapfst.pyx000$^    if result.weight.get.type  bnone$^      raise fstargerrorweight type not found$^    return result              $^  $^  $^ $^  pyxxdecrefpyobject pyxr$^  pyxincrefpyobject pyxvresult$^  pyxr  pyxvresult$^  goto pyxl0$^$^   pywrapfst.pyx000$^  $^  $^  cdef weight zeroweighttype              $^    cdef weight result  weight.newweight$^    result.weight.resetnew fst.weightclassfst.weightclass.zero$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.zero pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxl0$^  pyxxdecrefpyobject pyxvresult$^  pyxxgiverefpyobject pyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx000$^  $^  $^  cdef weight oneweighttype              $^    cdef weight result  weight.newweight$^    result.weight.resetnew fst.weightclass$^ $^$^static struct pyxobj0pywrapfstweight pyxf0pywrapfstonepyobject pyxvweighttype $^  struct pyxobj0pywrapfstweight pyxvresult  0$^  struct pyxobj0pywrapfstweight pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  stdstring pyxt0$^  int pyxt0$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextone 0$^$^   pywrapfst.pyx000$^  $^  cdef weight oneweighttype$^    cdef weight result  weight.newweight              $^    result.weight.resetnew fst.weightclass$^          fst.weightclass.onetostringweighttype$^ $^  pyxt0  pyxtpnew0pywrapfstweightpytypeobject pyxptype0pywrapfstweight pyxemptytuple null if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  if likelypyxtypetestpyxt0 pyxptype0pywrapfstweight pyxerr0 000 pyxl0error$^  pyxvresult  struct pyxobj0pywrapfstweight pyxt0$^  pyxt0  0$^$^   pywrapfst.pyx000$^  cdef weight oneweighttype$^    cdef weight result  weight.newweight$^    result.weight.resetnew fst.weightclass              $^          fst.weightclass.onetostringweighttype$^    if result.weight.get.type  bnone$^ $^  if unlikelypyobject pyxvresult  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s weight$^    pyxerr0 000 pyxl0error$^  $^$^   pywrapfst.pyx000$^    cdef weight result  weight.newweight$^    result.weight.resetnew fst.weightclass$^          fst.weightclass.onetostringweighttype              $^    if result.weight.get.type  bnone$^      raise fstargerrorweight type not found$^ $^  pyxt0  pyxf0pywrapfsttostringpyxvweighttype null if unlikelypyerroccurred pyxerr0 000 pyxl0error$^$^   pywrapfst.pyx000$^  cdef weight oneweighttype$^    cdef weight result  weight.newweight$^    result.weight.resetnew fst.weightclass              $^          fst.weightclass.onetostringweighttype$^    if result.weight.get.type  bnone$^ $^  pyxvresultweight.resetnew fstscriptweightclassfstscriptweightclassonepyxt0$^$^   pywrapfst.pyx000$^    result.weight.resetnew fst.weightclass$^          fst.weightclass.onetostringweighttype$^    if result.weight.get.type  bnone              $^      raise fstargerrorweight type not found$^    return result$^ $^  if unlikelypyobject pyxvresult  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s weight$^    pyxerr0 000 pyxl0error$^  $^  pyxt0  pyxvresultweight.gettype  char none  0$^  if pyxt0 $^$^     pywrapfst.pyx000$^          fst.weightclass.onetostringweighttype$^    if result.weight.get.type  bnone$^      raise fstargerrorweight type not found              $^    return result$^  $^ $^    pyxt0  pyxgetmoduleglobalnamepyxnsfstargerror if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  pyxpyobjectcallpyxt0 pyxtuple0 null if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxgotrefpyxt0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxraisepyxt0 0 0 0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxerr0 000 pyxl0error$^$^     pywrapfst.pyx000$^    result.weight.resetnew fst.weightclass$^          fst.weightclass.onetostringweighttype$^    if result.weight.get.type  bnone              $^      raise fstargerrorweight type not found$^    return result$^ $^  $^$^   pywrapfst.pyx000$^    if result.weight.get.type  bnone$^      raise fstargerrorweight type not found$^    return result              $^  $^  $^ $^  pyxxdecrefpyobject pyxr$^  pyxincrefpyobject pyxvresult$^  pyxr  pyxvresult$^  goto pyxl0$^$^   pywrapfst.pyx000$^  $^  $^  cdef weight oneweighttype              $^    cdef weight result  weight.newweight$^    result.weight.resetnew fst.weightclass$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.one pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxl0$^  pyxxdecrefpyobject pyxvresult$^  pyxxgiverefpyobject pyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx000$^  $^  $^  cdef weight noweightweighttype              $^    cdef weight result  weight.newweight$^    result.weight.resetnew fst.weightclass$^ $^$^static struct pyxobj0pywrapfstweight pyxf0pywrapfstnoweightpyobject pyxvweighttype $^  struct pyxobj0pywrapfstweight pyxvresult  0$^  struct pyxobj0pywrapfstweight pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  stdstring pyxt0$^  pyxrefnannysetupcontextnoweight 0$^$^   pywrapfst.pyx000$^  $^  cdef weight noweightweighttype$^    cdef weight result  weight.newweight              $^    result.weight.resetnew fst.weightclass$^          fst.weightclass.noweighttostringweighttype$^ $^  pyxt0  pyxtpnew0pywrapfstweightpytypeobject pyxptype0pywrapfstweight pyxemptytuple null if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  if likelypyxtypetestpyxt0 pyxptype0pywrapfstweight pyxerr0 000 pyxl0error$^  pyxvresult  struct pyxobj0pywrapfstweight pyxt0$^  pyxt0  0$^$^   pywrapfst.pyx000$^  cdef weight noweightweighttype$^    cdef weight result  weight.newweight$^    result.weight.resetnew fst.weightclass              $^          fst.weightclass.noweighttostringweighttype$^    return result$^ $^  if unlikelypyobject pyxvresult  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s weight$^    pyxerr0 000 pyxl0error$^  $^$^   pywrapfst.pyx000$^    cdef weight result  weight.newweight$^    result.weight.resetnew fst.weightclass$^          fst.weightclass.noweighttostringweighttype              $^    return result$^  $^ $^  pyxt0  pyxf0pywrapfsttostringpyxvweighttype null if unlikelypyerroccurred pyxerr0 000 pyxl0error$^$^   pywrapfst.pyx000$^  cdef weight noweightweighttype$^    cdef weight result  weight.newweight$^    result.weight.resetnew fst.weightclass              $^          fst.weightclass.noweighttostringweighttype$^    return result$^ $^  pyxvresultweight.resetnew fstscriptweightclassfstscriptweightclassnoweightpyxt0$^$^   pywrapfst.pyx000$^    result.weight.resetnew fst.weightclass$^          fst.weightclass.noweighttostringweighttype$^    return result              $^  $^  $^ $^  pyxxdecrefpyobject pyxr$^  pyxincrefpyobject pyxvresult$^  pyxr  pyxvresult$^  goto pyxl0$^$^   pywrapfst.pyx000$^  $^  $^  cdef weight noweightweighttype              $^    cdef weight result  weight.newweight$^    result.weight.resetnew fst.weightclass$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.noweight pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxl0$^  pyxxdecrefpyobject pyxvresult$^  pyxxgiverefpyobject pyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx000$^     doing so will allow undefined behavior.$^  $^    def initself              $^      raise fstdeletedconstructorerror$^          cannot construct .formatself.class.name$^ $^$^ python wrapper $^static int pyxpw0pywrapfst00symboltable0initpyobject pyxvself pyobject pyxargs pyobject pyxkwds proto$^static int pyxpw0pywrapfst00symboltable0initpyobject pyxvself pyobject pyxargs pyobject pyxkwds $^  int pyxr$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextinit wrapper 0$^  if unlikelypytuplegetsizepyxargs  0 $^    pyxraiseargtupleinvalidinit 0 0 0 pytuplegetsizepyxargs return 0$^  if unlikelypyxkwds  unlikelypydictsizepyxkwds  0  unlikelypyxcheckkeywordstringspyxkwds init 0 return 0$^  pyxr  pyxpf0pywrapfst00symboltableinitstruct pyxobj0pywrapfstsymboltable pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static int pyxpf0pywrapfst00symboltableinitstruct pyxobj0pywrapfstsymboltable pyxvself $^  int pyxr$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextinit 0$^$^   pywrapfst.pyx000$^  $^    def initself$^      raise fstdeletedconstructorerror              $^          cannot construct .formatself.class.name$^  $^ $^  pyxt0  pyxgetmoduleglobalnamepyxnsfstdeletedconstructorerror if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^$^   pywrapfst.pyx000$^    def initself$^      raise fstdeletedconstructorerror$^          cannot construct .formatself.class.name              $^  $^    def iterself$^ $^  pyxt0  pyxpyobjectgetattrstrpyxkpscannotconstruct pyxnsformat if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnsclass if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxt0  pyxpyobjectgetattrstrpyxt0 pyxnsname if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxdecrefpyxt0 pyxt0  0$^  pyxt0  null$^  if cythonunpackmethods  likelypymethodcheckpyxt0 $^    pyxt0  pymethodgetselfpyxt0$^    if likelypyxt0 $^      pyobject function  pymethodgetfunctionpyxt0$^      pyxincrefpyxt0$^      pyxincreffunction$^      pyxdecrefsetpyxt0 function$^    $^  $^  if pyxt0 $^    pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxdecrefpyxt0 pyxt0  0$^    pyxgotrefpyxt0$^   else $^    if cythonfastpycall$^    if pyfunctioncheckpyxt0 $^      pyobject pyxtemp0  pyxt0 pyxt0$^      pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^      pyxxdecrefpyxt0 pyxt0  0$^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^     else$^    endif$^    if cythonfastpyccall$^    if pyxpyfastcfunctioncheckpyxt0 $^      pyobject pyxtemp0  pyxt0 pyxt0$^      pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^      pyxxdecrefpyxt0 pyxt0  0$^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^     else$^    endif$^    $^      pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^      pyxgotrefpyxt0$^      pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^      pyxgiverefpyxt0$^      pytuplesetitempyxt0 00 pyxt0$^      pyxt0  0$^      pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 000 pyxl0error$^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^    $^  $^  pyxdecrefpyxt0 pyxt0  0$^  pyxt0  null$^  if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^    pyxt0  pymethodgetselfpyxt0$^    if likelypyxt0 $^      pyobject function  pymethodgetfunctionpyxt0$^      pyxincrefpyxt0$^      pyxincreffunction$^      pyxdecrefsetpyxt0 function$^    $^  $^  if pyxt0 $^    pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxdecrefpyxt0 pyxt0  0$^    pyxgotrefpyxt0$^   else $^    if cythonfastpycall$^    if pyfunctioncheckpyxt0 $^      pyobject pyxtemp0  pyxt0 pyxt0$^      pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^      pyxxdecrefpyxt0 pyxt0  0$^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^     else$^    endif$^    if cythonfastpyccall$^    if pyxpyfastcfunctioncheckpyxt0 $^      pyobject pyxtemp0  pyxt0 pyxt0$^      pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^      pyxxdecrefpyxt0 pyxt0  0$^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^     else$^    endif$^    $^      pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^      pyxgotrefpyxt0$^      pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^      pyxgiverefpyxt0$^      pytuplesetitempyxt0 00 pyxt0$^      pyxt0  0$^      pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 000 pyxl0error$^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^    $^  $^  pyxdecrefpyxt0 pyxt0  0$^  pyxraisepyxt0 0 0 0$^  pyxdecrefpyxt0 pyxt0  0$^  pyxerr0 000 pyxl0error$^$^   pywrapfst.pyx000$^     doing so will allow undefined behavior.$^  $^    def initself              $^      raise fstdeletedconstructorerror$^          cannot construct .formatself.class.name$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.symboltable.init pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx000$^          cannot construct .formatself.class.name$^  $^    def iterself              $^      return symboltableiteratorself$^  $^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00symboltable0iterpyobject pyxvself proto$^static pyobject pyxpw0pywrapfst00symboltable0iterpyobject pyxvself $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextiter wrapper 0$^  pyxr  pyxpf0pywrapfst00symboltable0iterstruct pyxobj0pywrapfstsymboltable pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00symboltable0iterstruct pyxobj0pywrapfstsymboltable pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextiter 0$^$^   pywrapfst.pyx000$^  $^    def iterself$^      return symboltableiteratorself              $^  $^    cpdef int00 availablekeyself$^ $^  pyxxdecrefpyxr$^  pyxt0  pytuplenew0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxincrefpyobject pyxvself$^  pyxgiverefpyobject pyxvself$^  pytuplesetitempyxt0 0 pyobject pyxvself$^  pyxt0  pyxpyobjectcallpyobject pyxptype0pywrapfstsymboltableiterator pyxt0 null if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxdecrefpyxt0 pyxt0  0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   pywrapfst.pyx000$^          cannot construct .formatself.class.name$^  $^    def iterself              $^      return symboltableiteratorself$^  $^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.symboltable.iter pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx000$^      return symboltableiteratorself$^  $^    cpdef int00 availablekeyself              $^      $^      availablekeyself$^ $^$^static pyobject pyxpw0pywrapfst00symboltable0availablekeypyobject pyxvself cythonunused pyobject unused proto$^static pyxt00basictypesint00 pyxf0pywrapfst00symboltableavailablekeystruct pyxobj0pywrapfstsymboltable pyxvself int pyxskipdispatch $^  pyxt00basictypesint00 pyxr$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxt00basictypesint00 pyxt0$^  pyxrefnannysetupcontextavailablekey 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnsavailablekey if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst00symboltable0availablekey $^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxdecrefpyxt0 pyxt0  0$^       else $^        pyxt0  pyxpyobjectcallnoargpyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^      $^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxt0  pyxpyintasint00tpyxt0 if unlikelypyxt0  int00t0  pyerroccurred pyxerr0 000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxr  pyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx000$^      returns an integer indicating the next available key index in the table.$^      $^      return self.table.availablekey              $^  $^    cpdef string checksumself$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s table$^    pyxerr0 000 pyxl0error$^  $^  pyxr  pyxvselftableavailablekey$^  goto pyxl0$^$^   pywrapfst.pyx000$^      return symboltableiteratorself$^  $^    cpdef int00 availablekeyself              $^      $^      availablekeyself$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxwriteunraisablepywrapfst.symboltable.availablekey pyxclineno pyxlineno pyxfilename 0 0$^  pyxr  0$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst00symboltable0availablekeypyobject pyxvself cythonunused pyobject unused proto$^static char pyxdoc0pywrapfst00symboltable0availablekey  n    availablekeyselfnn    returns an integer indicating the next available key index in the table.n    $^static pyobject pyxpw0pywrapfst00symboltable0availablekeypyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextavailablekey wrapper 0$^  pyxr  pyxpf0pywrapfst00symboltable0availablekeystruct pyxobj0pywrapfstsymboltable pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00symboltable0availablekeystruct pyxobj0pywrapfstsymboltable pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextavailablekey 0$^  pyxxdecrefpyxr$^  pyxt0  pyxpyintfromint00tpyxf0pywrapfst00symboltableavailablekeypyxvself 0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.symboltable.availablekey pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx000$^      return self.table.availablekey$^  $^    cpdef string checksumself              $^      $^      checksumself$^ $^$^static pyobject pyxpw0pywrapfst00symboltable0checksumpyobject pyxvself cythonunused pyobject unused proto$^static stdstring pyxf0pywrapfst00symboltablechecksumstruct pyxobj0pywrapfstsymboltable pyxvself int pyxskipdispatch $^  stdstring pyxr$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  stdstring pyxt0$^  pyxrefnannysetupcontextchecksum 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnschecksum if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst00symboltable0checksum $^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxdecrefpyxt0 pyxt0  0$^       else $^        pyxt0  pyxpyobjectcallnoargpyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^      $^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxt0  pyxconvertstringfrompystdinstringpyxt0 if unlikelypyerroccurred pyxerr0 000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxr  pyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx000$^      returns a string indicating the labelagnostic md0 checksum for the table.$^      $^      return self.table.checksum              $^  $^    cpdef symboltable copyself$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s table$^    pyxerr0 000 pyxl0error$^  $^  pyxr  pyxvselftablechecksum$^  goto pyxl0$^$^   pywrapfst.pyx000$^      return self.table.availablekey$^  $^    cpdef string checksumself              $^      $^      checksumself$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxwriteunraisablepywrapfst.symboltable.checksum pyxclineno pyxlineno pyxfilename 0 0$^  pyxpretendtoinitializepyxr$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst00symboltable0checksumpyobject pyxvself cythonunused pyobject unused proto$^static char pyxdoc0pywrapfst00symboltable0checksum  n    checksumselfnn    returns a string indicating the labelagnostic md0 checksum for the table.n    $^static pyobject pyxpw0pywrapfst00symboltable0checksumpyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextchecksum wrapper 0$^  pyxr  pyxpf0pywrapfst00symboltable0checksumstruct pyxobj0pywrapfstsymboltable pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00symboltable0checksumstruct pyxobj0pywrapfstsymboltable pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextchecksum 0$^  pyxxdecrefpyxr$^  pyxt0  pyxconvertpybytesstringtopystdinstringpyxf0pywrapfst00symboltablechecksumpyxvself 0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.symboltable.checksum pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx000$^      return self.table.checksum$^  $^    cpdef symboltable copyself              $^      $^      copyself$^ $^$^static pyobject pyxpw0pywrapfst00symboltable0copypyobject pyxvself cythonunused pyobject unused proto$^static struct pyxobj0pywrapfstsymboltable pyxf0pywrapfst00symboltablecopystruct pyxobj0pywrapfstsymboltable pyxvself int pyxskipdispatch $^  struct pyxobj0pywrapfstsymboltable pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextcopy 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnscopy if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst00symboltable0copy $^      pyxxdecrefpyobject pyxr$^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxdecrefpyxt0 pyxt0  0$^       else $^        pyxt0  pyxpyobjectcallnoargpyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^      $^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      if likelypyxt0  pynone  likelypyxtypetestpyxt0 pyxptype0pywrapfstsymboltable pyxerr0 000 pyxl0error$^      pyxr  struct pyxobj0pywrapfstsymboltable pyxt0$^      pyxt0  0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx000$^      returns a mutable copy of the symboltable.$^      $^      return initsymboltableself.table.copy              $^  $^    def findself key$^ $^  pyxxdecrefpyobject pyxr$^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s table$^    pyxerr0 000 pyxl0error$^  $^  pyxt0  pyobject pyxf0pywrapfstinitsymboltablepyxvselftablecopy if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  struct pyxobj0pywrapfstsymboltable pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   pywrapfst.pyx000$^      return self.table.checksum$^  $^    cpdef symboltable copyself              $^      $^      copyself$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.symboltable.copy pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxl0$^  pyxxgiverefpyobject pyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst00symboltable0copypyobject pyxvself cythonunused pyobject unused proto$^static char pyxdoc0pywrapfst00symboltable0copy  n    copyselfnn    returns a mutable copy of the symboltable.n    $^static pyobject pyxpw0pywrapfst00symboltable0copypyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextcopy wrapper 0$^  pyxr  pyxpf0pywrapfst00symboltable0copystruct pyxobj0pywrapfstsymboltable pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00symboltable0copystruct pyxobj0pywrapfstsymboltable pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextcopy 0$^  pyxxdecrefpyxr$^  pyxt0  pyobject pyxf0pywrapfst00symboltablecopypyxvself 0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.symboltable.copy pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx000$^      return initsymboltableself.table.copy$^  $^    def findself key              $^      $^      findself key$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00symboltable00findpyobject pyxvself pyobject pyxvkey proto$^static char pyxdoc0pywrapfst00symboltable00find  n    findself keynn    given a symbol or index finds the other one.nn    this method returns the index associated with a symbol key or the symboln    associated with a index key.nn    argsn      key either a string or an index.nn    returnsn      if the key is a string the associated index or nolabel if not found ifn          the key is an integer the associated symbol or an empty string ifn          not found.n    $^static pyobject pyxpw0pywrapfst00symboltable00findpyobject pyxvself pyobject pyxvkey $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextfind wrapper 0$^  pyxr  pyxpf0pywrapfst00symboltable00findstruct pyxobj0pywrapfstsymboltable pyxvself pyobject pyxvkey$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00symboltable00findstruct pyxobj0pywrapfstsymboltable pyxvself pyobject pyxvkey $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  stdstring pyxt0$^  pyobject pyxt0  null$^  int pyxt0$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxt00basictypesint00 pyxt0$^  pyobject pyxt00  null$^  pyxrefnannysetupcontextfind 0$^$^   pywrapfst.pyx000$^            not found.$^      $^      try              $^        return self.table.findindextostringkey$^      except fstargerror$^ $^  $^    pyxpythreadstatedeclare$^    pyxpythreadstateassign$^    pyxexceptionsavepyxt0 pyxt0 pyxt0$^    pyxxgotrefpyxt0$^    pyxxgotrefpyxt0$^    pyxxgotrefpyxt0$^    try $^$^       pywrapfst.pyx000$^      $^      try$^        return self.table.findindextostringkey              $^      except fstargerror$^        return self.table.findsymbolkey$^ $^      pyxxdecrefpyxr$^      if unlikelypyobject pyxvself  pynone $^        pyerrformatpyexcattributeerror nonetype object has no attribute .00s table$^        pyxerr0 000 pyxl0error$^      $^      pyxt0  pyxf0pywrapfsttostringpyxvkey null if unlikelypyerroccurred pyxerr0 000 pyxl0error$^      pyxt0  pyxpyintfromint00tpyxvselftablefindpyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^      pyxgotrefpyxt0$^      pyxr  pyxt0$^      pyxt0  0$^      goto pyxl0tryreturn$^$^       pywrapfst.pyx000$^            not found.$^      $^      try              $^        return self.table.findindextostringkey$^      except fstargerror$^ $^    $^    pyxl0error$^    pyxxdecrefpyxt0 pyxt0  0$^$^     pywrapfst.pyx000$^      try$^        return self.table.findindextostringkey$^      except fstargerror              $^        return self.table.findsymbolkey$^  $^ $^    pyxt0  pyxgetmoduleglobalnamepyxnsfstargerror if unlikelypyxt0 pyxerr0 000 pyxl0excepterror$^    pyxgotrefpyxt0$^    pyxt0  pyxpyerrexceptionmatchespyxt0$^    pyxdecrefpyxt0 pyxt0  0$^    if pyxt0 $^      pyxaddtracebackpywrapfst.symboltable.find pyxclineno pyxlineno pyxfilename$^      if pyxgetexceptionpyxt0 pyxt0 pyxt0  0 pyxerr0 000 pyxl0excepterror$^      pyxgotrefpyxt0$^      pyxgotrefpyxt0$^      pyxgotrefpyxt0$^$^       pywrapfst.pyx000$^        return self.table.findindextostringkey$^      except fstargerror$^        return self.table.findsymbolkey              $^  $^    cpdef int00 getnthkeyself ssizet pos except $^ $^      pyxxdecrefpyxr$^      if unlikelypyobject pyxvself  pynone $^        pyerrformatpyexcattributeerror nonetype object has no attribute .00s table$^        pyxerr0 000 pyxl0excepterror$^      $^      pyxt0  pyxpyintasint00tpyxvkey if unlikelypyxt0  int00t0  pyerroccurred pyxerr0 000 pyxl0excepterror$^      pyxt00  pyxconvertpybytesstringtopystdinstringpyxvselftablefindpyxt0 if unlikelypyxt00 pyxerr0 000 pyxl0excepterror$^      pyxgotrefpyxt00$^      pyxr  pyxt00$^      pyxt00  0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0exceptreturn$^    $^    goto pyxl0excepterror$^    pyxl0excepterror$^$^     pywrapfst.pyx000$^            not found.$^      $^      try              $^        return self.table.findindextostringkey$^      except fstargerror$^ $^    pyxxgiverefpyxt0$^    pyxxgiverefpyxt0$^    pyxxgiverefpyxt0$^    pyxexceptionresetpyxt0 pyxt0 pyxt0$^    goto pyxl0error$^    pyxl0tryreturn$^    pyxxgiverefpyxt0$^    pyxxgiverefpyxt0$^    pyxxgiverefpyxt0$^    pyxexceptionresetpyxt0 pyxt0 pyxt0$^    goto pyxl0$^    pyxl0exceptreturn$^    pyxxgiverefpyxt0$^    pyxxgiverefpyxt0$^    pyxxgiverefpyxt0$^    pyxexceptionresetpyxt0 pyxt0 pyxt0$^    goto pyxl0$^  $^$^   pywrapfst.pyx000$^      return initsymboltableself.table.copy$^  $^    def findself key              $^      $^      findself key$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt00$^  pyxaddtracebackpywrapfst.symboltable.find pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx000$^        return self.table.findsymbolkey$^  $^    cpdef int00 getnthkeyself ssizet pos except               $^      $^      getnthkeyself pos$^ $^$^static pyobject pyxpw0pywrapfst00symboltable00getnthkeypyobject pyxvself pyobject pyxargpos proto$^static pyxt00basictypesint00 pyxf0pywrapfst00symboltablegetnthkeystruct pyxobj0pywrapfstsymboltable pyxvself pyssizet pyxvpos int pyxskipdispatch $^  pyxt00basictypesint00 pyxr$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxt00basictypesint00 pyxt0$^  pyxrefnannysetupcontextgetnthkey 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnsgetnthkey if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst00symboltable00getnthkey $^      pyxt0  pyintfromssizetpyxvpos if unlikelypyxt0 pyxerr0 000 pyxl0error$^      pyxgotrefpyxt0$^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^       else $^        if cythonfastpycall$^        if pyfunctioncheckpyxt0 $^          pyobject pyxtemp0  pyxt0 pyxt0$^          pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^          pyxxdecrefpyxt0 pyxt0  0$^          pyxgotrefpyxt0$^          pyxdecrefpyxt0 pyxt0  0$^         else$^        endif$^        if cythonfastpyccall$^        if pyxpyfastcfunctioncheckpyxt0 $^          pyobject pyxtemp0  pyxt0 pyxt0$^          pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^          pyxxdecrefpyxt0 pyxt0  0$^          pyxgotrefpyxt0$^          pyxdecrefpyxt0 pyxt0  0$^         else$^        endif$^        $^          pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^          pyxgotrefpyxt0$^          pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^          pyxgiverefpyxt0$^          pytuplesetitempyxt0 00 pyxt0$^          pyxt0  0$^          pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 000 pyxl0error$^          pyxgotrefpyxt0$^          pyxdecrefpyxt0 pyxt0  0$^        $^      $^      pyxdecrefpyxt0 pyxt0  0$^      pyxt0  pyxpyintasint00tpyxt0 if unlikelypyxt0  int00t0  pyerroccurred pyxerr0 000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxr  pyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx000$^        the integer index of the nth key or nolabel if not found.$^      $^      return self.table.getnthkeypos              $^  $^    cpdef string labeledchecksumself$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s table$^    pyxerr0 000 pyxl0error$^  $^  pyxr  pyxvselftablegetnthkeypyxvpos$^  goto pyxl0$^$^   pywrapfst.pyx000$^        return self.table.findsymbolkey$^  $^    cpdef int00 getnthkeyself ssizet pos except               $^      $^      getnthkeyself pos$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.symboltable.getnthkey pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst00symboltable00getnthkeypyobject pyxvself pyobject pyxargpos proto$^static char pyxdoc0pywrapfst00symboltable00getnthkey  n    getnthkeyself posnn    retrieves the integer index of the nth key in the table.nn    argsn      pos the nth key to retrieve.nn    returnsn      the integer index of the nth key or nolabel if not found.n    $^static pyobject pyxpw0pywrapfst00symboltable00getnthkeypyobject pyxvself pyobject pyxargpos $^  pyssizet pyxvpos$^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextgetnthkey wrapper 0$^  assertpyxargpos $^    pyxvpos  pyintasssizetpyxargpos if unlikelypyxvpos  pyssizet0  pyerroccurred pyxerr0 000 pyxl0error$^  $^  goto pyxl0argumentunpackingdone$^  pyxl0error$^  pyxaddtracebackpywrapfst.symboltable.getnthkey pyxclineno pyxlineno pyxfilename$^  pyxrefnannyfinishcontext$^  return null$^  pyxl0argumentunpackingdone$^  pyxr  pyxpf0pywrapfst00symboltable00getnthkeystruct pyxobj0pywrapfstsymboltable pyxvself pyssizetpyxvpos$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00symboltable00getnthkeystruct pyxobj0pywrapfstsymboltable pyxvself pyssizet pyxvpos $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyxt00basictypesint00 pyxt0$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextgetnthkey 0$^  pyxxdecrefpyxr$^  pyxt0  pyxf0pywrapfst00symboltablegetnthkeypyxvself pyxvpos 0 if unlikelypyerroccurred pyxerr0 000 pyxl0error$^  pyxt0  pyxpyintfromint00tpyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.symboltable.getnthkey pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx000$^      return self.table.getnthkeypos$^  $^    cpdef string labeledchecksumself              $^      $^      labeledchecksumself$^ $^$^static pyobject pyxpw0pywrapfst00symboltable00labeledchecksumpyobject pyxvself cythonunused pyobject unused proto$^static stdstring pyxf0pywrapfst00symboltablelabeledchecksumstruct pyxobj0pywrapfstsymboltable pyxvself int pyxskipdispatch $^  stdstring pyxr$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  stdstring pyxt0$^  pyxrefnannysetupcontextlabeledchecksum 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnslabeledchecksum if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst00symboltable00labeledchecksum $^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxdecrefpyxt0 pyxt0  0$^       else $^        pyxt0  pyxpyobjectcallnoargpyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^      $^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxt0  pyxconvertstringfrompystdinstringpyxt0 if unlikelypyerroccurred pyxerr0 000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxr  pyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx000$^      returns a string indicating the labeldependent md0 checksum for the table.$^      $^      return self.table.labeledchecksum              $^  $^    cpdef bool memberself key$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s table$^    pyxerr0 000 pyxl0error$^  $^  pyxr  pyxvselftablelabeledchecksum$^  goto pyxl0$^$^   pywrapfst.pyx000$^      return self.table.getnthkeypos$^  $^    cpdef string labeledchecksumself              $^      $^      labeledchecksumself$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxwriteunraisablepywrapfst.symboltable.labeledchecksum pyxclineno pyxlineno pyxfilename 0 0$^  pyxpretendtoinitializepyxr$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst00symboltable00labeledchecksumpyobject pyxvself cythonunused pyobject unused proto$^static char pyxdoc0pywrapfst00symboltable00labeledchecksum  n    labeledchecksumselfnn    returns a string indicating the labeldependent md0 checksum for the table.n    $^static pyobject pyxpw0pywrapfst00symboltable00labeledchecksumpyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextlabeledchecksum wrapper 0$^  pyxr  pyxpf0pywrapfst00symboltable00labeledchecksumstruct pyxobj0pywrapfstsymboltable pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00symboltable00labeledchecksumstruct pyxobj0pywrapfstsymboltable pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextlabeledchecksum 0$^  pyxxdecrefpyxr$^  pyxt0  pyxconvertpybytesstringtopystdinstringpyxf0pywrapfst00symboltablelabeledchecksumpyxvself 0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.symboltable.labeledchecksum pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx000$^      return self.table.labeledchecksum$^  $^    cpdef bool memberself key              $^      $^      memberself key$^ $^$^static pyobject pyxpw0pywrapfst00symboltable00memberpyobject pyxvself pyobject pyxvkey proto$^static bool pyxf0pywrapfst00symboltablememberstruct pyxobj0pywrapfstsymboltable pyxvself pyobject pyxvkey int pyxskipdispatch $^  bool pyxr$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  bool pyxt0$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  stdstring pyxt00$^  int pyxt00$^  pyxt00basictypesint00 pyxt00$^  pyxrefnannysetupcontextmember 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnsmember if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst00symboltable00member $^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxvkey if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxgotrefpyxt0$^       else $^        if cythonfastpycall$^        if pyfunctioncheckpyxt0 $^          pyobject pyxtemp0  pyxt0 pyxvkey$^          pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^          pyxxdecrefpyxt0 pyxt0  0$^          pyxgotrefpyxt0$^         else$^        endif$^        if cythonfastpyccall$^        if pyxpyfastcfunctioncheckpyxt0 $^          pyobject pyxtemp0  pyxt0 pyxvkey$^          pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^          pyxxdecrefpyxt0 pyxt0  0$^          pyxgotrefpyxt0$^         else$^        endif$^        $^          pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^          pyxgotrefpyxt0$^          pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^          pyxincrefpyxvkey$^          pyxgiverefpyxvkey$^          pytuplesetitempyxt0 00 pyxvkey$^          pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 000 pyxl0error$^          pyxgotrefpyxt0$^          pyxdecrefpyxt0 pyxt0  0$^        $^      $^      pyxdecrefpyxt0 pyxt0  0$^      pyxt0  pyxpyobjectistruepyxt0 if unlikelypyxt0  bool0  pyerroccurred pyxerr0 000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxr  pyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx000$^        whether or not the key is present as a string or a index in the table.$^      $^      try              $^        return self.table.membersymboltostringkey$^      except fstargerror$^ $^  $^    pyxpythreadstatedeclare$^    pyxpythreadstateassign$^    pyxexceptionsavepyxt0 pyxt0 pyxt0$^    pyxxgotrefpyxt0$^    pyxxgotrefpyxt0$^    pyxxgotrefpyxt0$^    try $^$^       pywrapfst.pyx000$^      $^      try$^        return self.table.membersymboltostringkey              $^      except fstargerror$^        return self.table.memberindexkey$^ $^      if unlikelypyobject pyxvself  pynone $^        pyerrformatpyexcattributeerror nonetype object has no attribute .00s table$^        pyxerr0 000 pyxl0error$^      $^      pyxt00  pyxf0pywrapfsttostringpyxvkey null if unlikelypyerroccurred pyxerr0 000 pyxl0error$^      pyxr  pyxvselftablememberpyxt00$^      goto pyxl0tryreturn$^$^       pywrapfst.pyx000$^        whether or not the key is present as a string or a index in the table.$^      $^      try              $^        return self.table.membersymboltostringkey$^      except fstargerror$^ $^    $^    pyxl0error$^    pyxxdecrefpyxt0 pyxt0  0$^    pyxxdecrefpyxt0 pyxt0  0$^    pyxxdecrefpyxt0 pyxt0  0$^    pyxxdecrefpyxt0 pyxt0  0$^    pyxxdecrefpyxt0 pyxt0  0$^$^     pywrapfst.pyx000$^      try$^        return self.table.membersymboltostringkey$^      except fstargerror              $^        return self.table.memberindexkey$^  $^ $^    pyxt0  pyxgetmoduleglobalnamepyxnsfstargerror if unlikelypyxt0 pyxerr0 000 pyxl0excepterror$^    pyxgotrefpyxt0$^    pyxt00  pyxpyerrexceptionmatchespyxt0$^    pyxdecrefpyxt0 pyxt0  0$^    if pyxt00 $^      pyxaddtracebackpywrapfst.symboltable.member pyxclineno pyxlineno pyxfilename$^      if pyxgetexceptionpyxt0 pyxt0 pyxt0  0 pyxerr0 000 pyxl0excepterror$^      pyxgotrefpyxt0$^      pyxgotrefpyxt0$^      pyxgotrefpyxt0$^$^       pywrapfst.pyx000$^        return self.table.membersymboltostringkey$^      except fstargerror$^        return self.table.memberindexkey              $^  $^    def containsself key$^ $^      if unlikelypyobject pyxvself  pynone $^        pyerrformatpyexcattributeerror nonetype object has no attribute .00s table$^        pyxerr0 000 pyxl0excepterror$^      $^      pyxt00  pyxpyintasint00tpyxvkey if unlikelypyxt00  int00t0  pyerroccurred pyxerr0 000 pyxl0excepterror$^      pyxr  pyxvselftablememberpyxt00$^      pyxdecrefpyxt0 pyxt0  0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0exceptreturn$^    $^    goto pyxl0excepterror$^    pyxl0excepterror$^$^     pywrapfst.pyx000$^        whether or not the key is present as a string or a index in the table.$^      $^      try              $^        return self.table.membersymboltostringkey$^      except fstargerror$^ $^    pyxxgiverefpyxt0$^    pyxxgiverefpyxt0$^    pyxxgiverefpyxt0$^    pyxexceptionresetpyxt0 pyxt0 pyxt0$^    goto pyxl0error$^    pyxl0tryreturn$^    pyxxgiverefpyxt0$^    pyxxgiverefpyxt0$^    pyxxgiverefpyxt0$^    pyxexceptionresetpyxt0 pyxt0 pyxt0$^    goto pyxl0$^    pyxl0exceptreturn$^    pyxxgiverefpyxt0$^    pyxxgiverefpyxt0$^    pyxxgiverefpyxt0$^    pyxexceptionresetpyxt0 pyxt0 pyxt0$^    goto pyxl0$^  $^$^   pywrapfst.pyx000$^      return self.table.labeledchecksum$^  $^    cpdef bool memberself key              $^      $^      memberself key$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxwriteunraisablepywrapfst.symboltable.member pyxclineno pyxlineno pyxfilename 0 0$^  pyxr  0$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst00symboltable00memberpyobject pyxvself pyobject pyxvkey proto$^static char pyxdoc0pywrapfst00symboltable00member  n    memberself keynn    given a symbol or index returns whether it is found in the table.nn    this method returns a boolean indicating whether the given symbol or indexn    is present in the table. if one intends to perform subsequent lookup it isn    better to simply call the find method catching the keyerror.nn    argsn      key either a string or an index.nn    returnsn      whether or not the key is present as a string or a index in the table.n    $^static pyobject pyxpw0pywrapfst00symboltable00memberpyobject pyxvself pyobject pyxvkey $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextmember wrapper 0$^  pyxr  pyxpf0pywrapfst00symboltable00memberstruct pyxobj0pywrapfstsymboltable pyxvself pyobject pyxvkey$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00symboltable00memberstruct pyxobj0pywrapfstsymboltable pyxvself pyobject pyxvkey $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextmember 0$^  pyxxdecrefpyxr$^  pyxt0  pyxpyboolfromlongpyxf0pywrapfst00symboltablememberpyxvself pyxvkey 0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.symboltable.member pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx000$^        return self.table.memberindexkey$^  $^    def containsself key              $^      return self.memberkey$^  $^ $^$^ python wrapper $^static int pyxpw0pywrapfst00symboltable00containspyobject pyxvself pyobject pyxvkey proto$^static int pyxpw0pywrapfst00symboltable00containspyobject pyxvself pyobject pyxvkey $^  int pyxr$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextcontains wrapper 0$^  pyxr  pyxpf0pywrapfst00symboltable00containsstruct pyxobj0pywrapfstsymboltable pyxvself pyobject pyxvkey$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static int pyxpf0pywrapfst00symboltable00containsstruct pyxobj0pywrapfstsymboltable pyxvself pyobject pyxvkey $^  int pyxr$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextcontains 0$^$^   pywrapfst.pyx000$^  $^    def containsself key$^      return self.memberkey              $^  $^    cpdef string nameself$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s member$^    pyxerr0 000 pyxl0error$^  $^  pyxr  struct pyxvtabstruct0pywrapfstsymboltable pyxvselfpyxvtabmemberpyxvself pyxvkey 0$^  goto pyxl0$^$^   pywrapfst.pyx000$^        return self.table.memberindexkey$^  $^    def containsself key              $^      return self.memberkey$^  $^ $^$^   function exit code $^  pyxl0error$^  pyxaddtracebackpywrapfst.symboltable.contains pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx000$^      return self.memberkey$^  $^    cpdef string nameself              $^      $^      nameself$^ $^$^static pyobject pyxpw0pywrapfst00symboltable00namepyobject pyxvself cythonunused pyobject unused proto$^static stdstring pyxf0pywrapfst00symboltablenamestruct pyxobj0pywrapfstsymboltable pyxvself int pyxskipdispatch $^  stdstring pyxr$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  stdstring pyxt0$^  pyxrefnannysetupcontextname 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnsname0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst00symboltable00name $^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxdecrefpyxt0 pyxt0  0$^       else $^        pyxt0  pyxpyobjectcallnoargpyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^      $^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxt0  pyxconvertstringfrompystdinstringpyxt0 if unlikelypyerroccurred pyxerr0 000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxr  pyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx000$^      returns the symbol tables name.$^      $^      return self.table.name              $^  $^    cpdef sizet numsymbolsself$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s table$^    pyxerr0 000 pyxl0error$^  $^  pyxr  pyxvselftablename$^  goto pyxl0$^$^   pywrapfst.pyx000$^      return self.memberkey$^  $^    cpdef string nameself              $^      $^      nameself$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxwriteunraisablepywrapfst.symboltable.name pyxclineno pyxlineno pyxfilename 0 0$^  pyxpretendtoinitializepyxr$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst00symboltable00namepyobject pyxvself cythonunused pyobject unused proto$^static char pyxdoc0pywrapfst00symboltable00name  n    nameselfnn    returns the symbol tables name.n    $^static pyobject pyxpw0pywrapfst00symboltable00namepyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextname wrapper 0$^  pyxr  pyxpf0pywrapfst00symboltable00namestruct pyxobj0pywrapfstsymboltable pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00symboltable00namestruct pyxobj0pywrapfstsymboltable pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextname 0$^  pyxxdecrefpyxr$^  pyxt0  pyxconvertpybytesstringtopystdinstringpyxf0pywrapfst00symboltablenamepyxvself 0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.symboltable.name pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx000$^      return self.table.name$^  $^    cpdef sizet numsymbolsself              $^      $^      numsymbolsself$^ $^$^static pyobject pyxpw0pywrapfst00symboltable00numsymbolspyobject pyxvself cythonunused pyobject unused proto$^static sizet pyxf0pywrapfst00symboltablenumsymbolsstruct pyxobj0pywrapfstsymboltable pyxvself int pyxskipdispatch $^  sizet pyxr$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  sizet pyxt0$^  pyxrefnannysetupcontextnumsymbols 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnsnumsymbols if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst00symboltable00numsymbols $^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxdecrefpyxt0 pyxt0  0$^       else $^        pyxt0  pyxpyobjectcallnoargpyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^      $^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxt0  pyxpyintassizetpyxt0 if unlikelypyxt0  sizet0  pyerroccurred pyxerr0 000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxr  pyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx000$^      returns the number of symbols in the symbol table.$^      $^      return self.table.numsymbols              $^  $^    cpdef void writeself filename except $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s table$^    pyxerr0 000 pyxl0error$^  $^  pyxr  pyxvselftablenumsymbols$^  goto pyxl0$^$^   pywrapfst.pyx000$^      return self.table.name$^  $^    cpdef sizet numsymbolsself              $^      $^      numsymbolsself$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxwriteunraisablepywrapfst.symboltable.numsymbols pyxclineno pyxlineno pyxfilename 0 0$^  pyxr  0$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst00symboltable00numsymbolspyobject pyxvself cythonunused pyobject unused proto$^static char pyxdoc0pywrapfst00symboltable00numsymbols  n    numsymbolsselfnn    returns the number of symbols in the symbol table.n    $^static pyobject pyxpw0pywrapfst00symboltable00numsymbolspyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextnumsymbols wrapper 0$^  pyxr  pyxpf0pywrapfst00symboltable00numsymbolsstruct pyxobj0pywrapfstsymboltable pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00symboltable00numsymbolsstruct pyxobj0pywrapfstsymboltable pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextnumsymbols 0$^  pyxxdecrefpyxr$^  pyxt0  pyxpyintfromsizetpyxf0pywrapfst00symboltablenumsymbolspyxvself 0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.symboltable.numsymbols pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx000$^      return self.table.numsymbols$^  $^    cpdef void writeself filename except               $^      $^      writeself filename$^ $^$^static pyobject pyxpw0pywrapfst00symboltable00writepyobject pyxvself pyobject pyxvfilename proto$^static void pyxf0pywrapfst00symboltablewritestruct pyxobj0pywrapfstsymboltable pyxvself pyobject pyxvfilename int pyxskipdispatch $^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  stdstring pyxt0$^  int pyxt0$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextwrite 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnswrite if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst00symboltable00write $^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxvfilename if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxgotrefpyxt0$^       else $^        if cythonfastpycall$^        if pyfunctioncheckpyxt0 $^          pyobject pyxtemp0  pyxt0 pyxvfilename$^          pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^          pyxxdecrefpyxt0 pyxt0  0$^          pyxgotrefpyxt0$^         else$^        endif$^        if cythonfastpyccall$^        if pyxpyfastcfunctioncheckpyxt0 $^          pyobject pyxtemp0  pyxt0 pyxvfilename$^          pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^          pyxxdecrefpyxt0 pyxt0  0$^          pyxgotrefpyxt0$^         else$^        endif$^        $^          pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^          pyxgotrefpyxt0$^          pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^          pyxincrefpyxvfilename$^          pyxgiverefpyxvfilename$^          pytuplesetitempyxt0 00 pyxvfilename$^          pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 000 pyxl0error$^          pyxgotrefpyxt0$^          pyxdecrefpyxt0 pyxt0  0$^        $^      $^      pyxdecrefpyxt0 pyxt0  0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx000$^        fstioerror write failed.$^      $^      if not self.table.writetostringfilename              $^        raise fstioerrorwrite failed r.formatfilename$^  $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s table$^    pyxerr0 000 pyxl0error$^  $^  pyxt0  pyxf0pywrapfsttostringpyxvfilename null if unlikelypyerroccurred pyxerr0 000 pyxl0error$^  pyxt0  pyxvselftablewritepyxt0  0  0$^  if pyxt0 $^$^     pywrapfst.pyx000$^      $^      if not self.table.writetostringfilename$^        raise fstioerrorwrite failed r.formatfilename              $^  $^    cpdef void writetextself filename except $^ $^    pyxt0  pyxgetmoduleglobalnamepyxnsfstioerror if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  pyxpyobjectgetattrstrpyxkpswritefailedr pyxnsformat if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  null$^    if cythonunpackmethods  likelypymethodcheckpyxt0 $^      pyxt0  pymethodgetselfpyxt0$^      if likelypyxt0 $^        pyobject function  pymethodgetfunctionpyxt0$^        pyxincrefpyxt0$^        pyxincreffunction$^        pyxdecrefsetpyxt0 function$^      $^    $^    if pyxt0 $^      pyxt0  pyxpyobjectcalloneargpyxt0 pyxvfilename if unlikelypyxt0 pyxerr0 000 pyxl0error$^      pyxgotrefpyxt0$^     else $^      if cythonfastpycall$^      if pyfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxvfilename$^        pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^       else$^      endif$^      if cythonfastpyccall$^      if pyxpyfastcfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxvfilename$^        pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^       else$^      endif$^      $^        pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxgotrefpyxt0$^        pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^        pyxincrefpyxvfilename$^        pyxgiverefpyxvfilename$^        pytuplesetitempyxt0 00 pyxvfilename$^        pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^      $^    $^    pyxdecrefpyxt0 pyxt0  0$^    pyxt0  null$^    if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^      pyxt0  pymethodgetselfpyxt0$^      if likelypyxt0 $^        pyobject function  pymethodgetfunctionpyxt0$^        pyxincrefpyxt0$^        pyxincreffunction$^        pyxdecrefsetpyxt0 function$^      $^    $^    if pyxt0 $^      pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxgotrefpyxt0$^     else $^      if cythonfastpycall$^      if pyfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxt0$^        pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^       else$^      endif$^      if cythonfastpyccall$^      if pyxpyfastcfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxt0$^        pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^       else$^      endif$^      $^        pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxgotrefpyxt0$^        pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^        pyxgiverefpyxt0$^        pytuplesetitempyxt0 00 pyxt0$^        pyxt0  0$^        pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^      $^    $^    pyxdecrefpyxt0 pyxt0  0$^    pyxraisepyxt0 0 0 0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxerr0 000 pyxl0error$^$^     pywrapfst.pyx000$^        fstioerror write failed.$^      $^      if not self.table.writetostringfilename              $^        raise fstioerrorwrite failed r.formatfilename$^  $^ $^  $^$^   pywrapfst.pyx000$^      return self.table.numsymbols$^  $^    cpdef void writeself filename except               $^      $^      writeself filename$^ $^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.symboltable.write pyxclineno pyxlineno pyxfilename$^  pyxl0$^  pyxrefnannyfinishcontext$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst00symboltable00writepyobject pyxvself pyobject pyxvfilename proto$^static char pyxdoc0pywrapfst00symboltable00write  n    writeself filenamenn    serializes symbol table to a file.nn    this methods writes the symboltable to a file in binary format.nn    argsn      filename the string location of the output file.nn    raisesn      fstioerror write failed.n    $^static pyobject pyxpw0pywrapfst00symboltable00writepyobject pyxvself pyobject pyxvfilename $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextwrite wrapper 0$^  pyxr  pyxpf0pywrapfst00symboltable00writestruct pyxobj0pywrapfstsymboltable pyxvself pyobject pyxvfilename$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00symboltable00writestruct pyxobj0pywrapfstsymboltable pyxvself pyobject pyxvfilename $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextwrite 0$^  pyxxdecrefpyxr$^  pyxf0pywrapfst00symboltablewritepyxvself pyxvfilename 0 if unlikelypyerroccurred pyxerr0 000 pyxl0error$^  pyxt0  pyxvoidtononenull if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.symboltable.write pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx000$^        raise fstioerrorwrite failed r.formatfilename$^  $^    cpdef void writetextself filename except               $^      $^      writetextself filename$^ $^$^static pyobject pyxpw0pywrapfst00symboltable00writetextpyobject pyxvself pyobject pyxvfilename proto$^static void pyxf0pywrapfst00symboltablewritetextstruct pyxobj0pywrapfstsymboltable pyxvself pyobject pyxvfilename int pyxskipdispatch $^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  stdstring pyxt0$^  int pyxt0$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextwritetext 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnswritetext if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst00symboltable00writetext $^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxvfilename if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxgotrefpyxt0$^       else $^        if cythonfastpycall$^        if pyfunctioncheckpyxt0 $^          pyobject pyxtemp0  pyxt0 pyxvfilename$^          pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^          pyxxdecrefpyxt0 pyxt0  0$^          pyxgotrefpyxt0$^         else$^        endif$^        if cythonfastpyccall$^        if pyxpyfastcfunctioncheckpyxt0 $^          pyobject pyxtemp0  pyxt0 pyxvfilename$^          pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^          pyxxdecrefpyxt0 pyxt0  0$^          pyxgotrefpyxt0$^         else$^        endif$^        $^          pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^          pyxgotrefpyxt0$^          pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^          pyxincrefpyxvfilename$^          pyxgiverefpyxvfilename$^          pytuplesetitempyxt0 00 pyxvfilename$^          pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 000 pyxl0error$^          pyxgotrefpyxt0$^          pyxdecrefpyxt0 pyxt0  0$^        $^      $^      pyxdecrefpyxt0 pyxt0  0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx000$^        fstioerror write failed.$^      $^      if not self.table.writetexttostringfilename              $^        raise fstioerrorwrite failed r.formatfilename$^  $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s table$^    pyxerr0 000 pyxl0error$^  $^  pyxt0  pyxf0pywrapfsttostringpyxvfilename null if unlikelypyerroccurred pyxerr0 000 pyxl0error$^  pyxt0  pyxvselftablewritetextpyxt0  0  0$^  if pyxt0 $^$^     pywrapfst.pyx000$^      $^      if not self.table.writetexttostringfilename$^        raise fstioerrorwrite failed r.formatfilename              $^  $^  $^ $^    pyxt0  pyxgetmoduleglobalnamepyxnsfstioerror if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  pyxpyobjectgetattrstrpyxkpswritefailedr pyxnsformat if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  null$^    if cythonunpackmethods  likelypymethodcheckpyxt0 $^      pyxt0  pymethodgetselfpyxt0$^      if likelypyxt0 $^        pyobject function  pymethodgetfunctionpyxt0$^        pyxincrefpyxt0$^        pyxincreffunction$^        pyxdecrefsetpyxt0 function$^      $^    $^    if pyxt0 $^      pyxt0  pyxpyobjectcalloneargpyxt0 pyxvfilename if unlikelypyxt0 pyxerr0 000 pyxl0error$^      pyxgotrefpyxt0$^     else $^      if cythonfastpycall$^      if pyfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxvfilename$^        pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^       else$^      endif$^      if cythonfastpyccall$^      if pyxpyfastcfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxvfilename$^        pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^       else$^      endif$^      $^        pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxgotrefpyxt0$^        pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^        pyxincrefpyxvfilename$^        pyxgiverefpyxvfilename$^        pytuplesetitempyxt0 00 pyxvfilename$^        pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^      $^    $^    pyxdecrefpyxt0 pyxt0  0$^    pyxt0  null$^    if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^      pyxt0  pymethodgetselfpyxt0$^      if likelypyxt0 $^        pyobject function  pymethodgetfunctionpyxt0$^        pyxincrefpyxt0$^        pyxincreffunction$^        pyxdecrefsetpyxt0 function$^      $^    $^    if pyxt0 $^      pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxgotrefpyxt0$^     else $^      if cythonfastpycall$^      if pyfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxt0$^        pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^       else$^      endif$^      if cythonfastpyccall$^      if pyxpyfastcfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxt0$^        pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^       else$^      endif$^      $^        pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxgotrefpyxt0$^        pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^        pyxgiverefpyxt0$^        pytuplesetitempyxt0 00 pyxt0$^        pyxt0  0$^        pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^      $^    $^    pyxdecrefpyxt0 pyxt0  0$^    pyxraisepyxt0 0 0 0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxerr0 000 pyxl0error$^$^     pywrapfst.pyx000$^        fstioerror write failed.$^      $^      if not self.table.writetexttostringfilename              $^        raise fstioerrorwrite failed r.formatfilename$^  $^ $^  $^$^   pywrapfst.pyx000$^        raise fstioerrorwrite failed r.formatfilename$^  $^    cpdef void writetextself filename except               $^      $^      writetextself filename$^ $^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.symboltable.writetext pyxclineno pyxlineno pyxfilename$^  pyxl0$^  pyxrefnannyfinishcontext$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst00symboltable00writetextpyobject pyxvself pyobject pyxvfilename proto$^static char pyxdoc0pywrapfst00symboltable00writetext  n    writetextself filenamenn    writes symbol table to text file.nn    this method writes the symboltable to a file in humanreadable format.nn    argsn      filename the string location of the output file.nn    raisesn      fstioerror write failed.n    $^static pyobject pyxpw0pywrapfst00symboltable00writetextpyobject pyxvself pyobject pyxvfilename $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextwritetext wrapper 0$^  pyxr  pyxpf0pywrapfst00symboltable00writetextstruct pyxobj0pywrapfstsymboltable pyxvself pyobject pyxvfilename$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00symboltable00writetextstruct pyxobj0pywrapfstsymboltable pyxvself pyobject pyxvfilename $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextwritetext 0$^  pyxxdecrefpyxr$^  pyxf0pywrapfst00symboltablewritetextpyxvself pyxvfilename 0 if unlikelypyerroccurred pyxerr0 000 pyxl0error$^  pyxt0  pyxvoidtononenull if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.symboltable.writetext pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ tree fragment0$^  def reducecythonself              $^      raise typeerrorself.table cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00symboltable00reducecythonpyobject pyxvself cythonunused pyobject unused proto$^static pyobject pyxpw0pywrapfst00symboltable00reducecythonpyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextreducecython wrapper 0$^  pyxr  pyxpf0pywrapfst00symboltable00reducecythonstruct pyxobj0pywrapfstsymboltable pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00symboltable00reducecythoncythonunused struct pyxobj0pywrapfstsymboltable pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextreducecython 0$^$^   tree fragment0$^  def reducecythonself$^      raise typeerrorself.table cannot be converted to a python object for pickling              $^  def setstatecythonself pyxstate$^      raise typeerrorself.table cannot be converted to a python object for pickling$^ $^  pyxt0  pyxpyobjectcallpyxbuiltintypeerror pyxtuple0 null if unlikelypyxt0 pyxerr0 0 pyxl0error$^  pyxgotrefpyxt0$^  pyxraisepyxt0 0 0 0$^  pyxdecrefpyxt0 pyxt0  0$^  pyxerr0 0 pyxl0error$^$^   tree fragment0$^  def reducecythonself              $^      raise typeerrorself.table cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.symboltable.reducecython pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ tree fragment0$^  def reducecythonself$^      raise typeerrorself.table cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate              $^      raise typeerrorself.table cannot be converted to a python object for pickling$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00symboltable00setstatecythonpyobject pyxvself pyobject pyxvpyxstate proto$^static pyobject pyxpw0pywrapfst00symboltable00setstatecythonpyobject pyxvself pyobject pyxvpyxstate $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextsetstatecython wrapper 0$^  pyxr  pyxpf0pywrapfst00symboltable00setstatecythonstruct pyxobj0pywrapfstsymboltable pyxvself pyobject pyxvpyxstate$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00symboltable00setstatecythoncythonunused struct pyxobj0pywrapfstsymboltable pyxvself cythonunused pyobject pyxvpyxstate $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextsetstatecython 0$^$^   tree fragment0$^      raise typeerrorself.table cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate$^      raise typeerrorself.table cannot be converted to a python object for pickling              $^ $^  pyxt0  pyxpyobjectcallpyxbuiltintypeerror pyxtuple0 null if unlikelypyxt0 pyxerr0 0 pyxl0error$^  pyxgotrefpyxt0$^  pyxraisepyxt0 0 0 0$^  pyxdecrefpyxt0 pyxt0  0$^  pyxerr0 0 pyxl0error$^$^   tree fragment0$^  def reducecythonself$^      raise typeerrorself.table cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate              $^      raise typeerrorself.table cannot be converted to a python object for pickling$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.symboltable.setstatecython pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx000$^     doing so will allow undefined behavior.$^  $^    def reprself              $^      return const encodemapper symboltable r at 0xx.formatself.name$^                                                                      idself$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00encodemappersymboltable0reprpyobject pyxvself proto$^static pyobject pyxpw0pywrapfst00encodemappersymboltable0reprpyobject pyxvself $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextrepr wrapper 0$^  pyxr  pyxpf0pywrapfst00encodemappersymboltablereprstruct pyxobj0pywrapfstencodemappersymboltable pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00encodemappersymboltablereprstruct pyxobj0pywrapfstencodemappersymboltable pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  int pyxt0$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextrepr 0$^$^   pywrapfst.pyx000$^  $^    def reprself$^      return const encodemapper symboltable r at 0xx.formatself.name              $^                                                                      idself$^  $^ $^  pyxxdecrefpyxr$^  pyxt0  pyxpyobjectgetattrstrpyxkpsconstencodemappersymboltable pyxnsformat if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s name$^    pyxerr0 000 pyxl0error$^  $^  pyxt0  pyxconvertpybytesstringtopystdinstringstruct pyxvtabstruct0pywrapfstencodemappersymboltable pyxvselfpyxbase.pyxvtabpyxbase.namestruct pyxobj0pywrapfstsymboltable pyxvself 0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^$^   pywrapfst.pyx000$^    def reprself$^      return const encodemapper symboltable r at 0xx.formatself.name$^                                                                      idself              $^  $^  $^ $^  pyxt0  pytuplenew0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxincrefpyobject pyxvself$^  pyxgiverefpyobject pyxvself$^  pytuplesetitempyxt0 0 pyobject pyxvself$^  pyxt0  pyxpyobjectcallpyxbuiltinid pyxt0 null if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxdecrefpyxt0 pyxt0  0$^  pyxt0  null$^  pyxt0  0$^  if cythonunpackmethods  likelypymethodcheckpyxt0 $^    pyxt0  pymethodgetselfpyxt0$^    if likelypyxt0 $^      pyobject function  pymethodgetfunctionpyxt0$^      pyxincrefpyxt0$^      pyxincreffunction$^      pyxdecrefsetpyxt0 function$^      pyxt0  0$^    $^  $^  if cythonfastpycall$^  if pyfunctioncheckpyxt0 $^    pyobject pyxtemp0  pyxt0 pyxt0 pyxt0$^    pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp0pyxt0 0pyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxxdecrefpyxt0 pyxt0  0$^    pyxgotrefpyxt0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxdecrefpyxt0 pyxt0  0$^   else$^  endif$^  if cythonfastpyccall$^  if pyxpyfastcfunctioncheckpyxt0 $^    pyobject pyxtemp0  pyxt0 pyxt0 pyxt0$^    pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp0pyxt0 0pyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxxdecrefpyxt0 pyxt0  0$^    pyxgotrefpyxt0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxdecrefpyxt0 pyxt0  0$^   else$^  endif$^  $^    pyxt0  pytuplenew0pyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxgotrefpyxt0$^    if pyxt0 $^      pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^    $^    pyxgiverefpyxt0$^    pytuplesetitempyxt0 0pyxt0 pyxt0$^    pyxgiverefpyxt0$^    pytuplesetitempyxt0 0pyxt0 pyxt0$^    pyxt0  0$^    pyxt0  0$^    pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxgotrefpyxt0$^    pyxdecrefpyxt0 pyxt0  0$^  $^  pyxdecrefpyxt0 pyxt0  0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   pywrapfst.pyx000$^     doing so will allow undefined behavior.$^  $^    def reprself              $^      return const encodemapper symboltable r at 0xx.formatself.name$^                                                                      idself$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.encodemappersymboltable.repr pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ tree fragment0$^  def reducecythonself              $^      raise typeerrorself.encoderself.table cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00encodemappersymboltable0reducecythonpyobject pyxvself cythonunused pyobject unused proto$^static pyobject pyxpw0pywrapfst00encodemappersymboltable0reducecythonpyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextreducecython wrapper 0$^  pyxr  pyxpf0pywrapfst00encodemappersymboltable0reducecythonstruct pyxobj0pywrapfstencodemappersymboltable pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00encodemappersymboltable0reducecythoncythonunused struct pyxobj0pywrapfstencodemappersymboltable pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextreducecython 0$^$^   tree fragment0$^  def reducecythonself$^      raise typeerrorself.encoderself.table cannot be converted to a python object for pickling              $^  def setstatecythonself pyxstate$^      raise typeerrorself.encoderself.table cannot be converted to a python object for pickling$^ $^  pyxt0  pyxpyobjectcallpyxbuiltintypeerror pyxtuple0 null if unlikelypyxt0 pyxerr0 0 pyxl0error$^  pyxgotrefpyxt0$^  pyxraisepyxt0 0 0 0$^  pyxdecrefpyxt0 pyxt0  0$^  pyxerr0 0 pyxl0error$^$^   tree fragment0$^  def reducecythonself              $^      raise typeerrorself.encoderself.table cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.encodemappersymboltable.reducecython pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ tree fragment0$^  def reducecythonself$^      raise typeerrorself.encoderself.table cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate              $^      raise typeerrorself.encoderself.table cannot be converted to a python object for pickling$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00encodemappersymboltable0setstatecythonpyobject pyxvself pyobject pyxvpyxstate proto$^static pyobject pyxpw0pywrapfst00encodemappersymboltable0setstatecythonpyobject pyxvself pyobject pyxvpyxstate $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextsetstatecython wrapper 0$^  pyxr  pyxpf0pywrapfst00encodemappersymboltable0setstatecythonstruct pyxobj0pywrapfstencodemappersymboltable pyxvself pyobject pyxvpyxstate$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00encodemappersymboltable0setstatecythoncythonunused struct pyxobj0pywrapfstencodemappersymboltable pyxvself cythonunused pyobject pyxvpyxstate $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextsetstatecython 0$^$^   tree fragment0$^      raise typeerrorself.encoderself.table cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate$^      raise typeerrorself.encoderself.table cannot be converted to a python object for pickling              $^ $^  pyxt0  pyxpyobjectcallpyxbuiltintypeerror pyxtuple00 null if unlikelypyxt0 pyxerr0 0 pyxl0error$^  pyxgotrefpyxt0$^  pyxraisepyxt0 0 0 0$^  pyxdecrefpyxt0 pyxt0  0$^  pyxerr0 0 pyxl0error$^$^   tree fragment0$^  def reducecythonself$^      raise typeerrorself.encoderself.table cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate              $^      raise typeerrorself.encoderself.table cannot be converted to a python object for pickling$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.encodemappersymboltable.setstatecython pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx000$^     doing so will allow undefined behavior.$^  $^    def reprself              $^      return const fst symboltable r at 0xx.formatself.name$^                                                             idself$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00fstsymboltable0reprpyobject pyxvself proto$^static pyobject pyxpw0pywrapfst00fstsymboltable0reprpyobject pyxvself $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextrepr wrapper 0$^  pyxr  pyxpf0pywrapfst00fstsymboltablereprstruct pyxobj0pywrapfstfstsymboltable pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00fstsymboltablereprstruct pyxobj0pywrapfstfstsymboltable pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  int pyxt0$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextrepr 0$^$^   pywrapfst.pyx000$^  $^    def reprself$^      return const fst symboltable r at 0xx.formatself.name              $^                                                             idself$^  $^ $^  pyxxdecrefpyxr$^  pyxt0  pyxpyobjectgetattrstrpyxkpsconstfstsymboltablerat0xx pyxnsformat if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s name$^    pyxerr0 000 pyxl0error$^  $^  pyxt0  pyxconvertpybytesstringtopystdinstringstruct pyxvtabstruct0pywrapfstfstsymboltable pyxvselfpyxbase.pyxvtabpyxbase.namestruct pyxobj0pywrapfstsymboltable pyxvself 0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^$^   pywrapfst.pyx000$^    def reprself$^      return const fst symboltable r at 0xx.formatself.name$^                                                             idself              $^  $^  $^ $^  pyxt0  pytuplenew0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxincrefpyobject pyxvself$^  pyxgiverefpyobject pyxvself$^  pytuplesetitempyxt0 0 pyobject pyxvself$^  pyxt0  pyxpyobjectcallpyxbuiltinid pyxt0 null if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxdecrefpyxt0 pyxt0  0$^  pyxt0  null$^  pyxt0  0$^  if cythonunpackmethods  likelypymethodcheckpyxt0 $^    pyxt0  pymethodgetselfpyxt0$^    if likelypyxt0 $^      pyobject function  pymethodgetfunctionpyxt0$^      pyxincrefpyxt0$^      pyxincreffunction$^      pyxdecrefsetpyxt0 function$^      pyxt0  0$^    $^  $^  if cythonfastpycall$^  if pyfunctioncheckpyxt0 $^    pyobject pyxtemp0  pyxt0 pyxt0 pyxt0$^    pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp0pyxt0 0pyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxxdecrefpyxt0 pyxt0  0$^    pyxgotrefpyxt0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxdecrefpyxt0 pyxt0  0$^   else$^  endif$^  if cythonfastpyccall$^  if pyxpyfastcfunctioncheckpyxt0 $^    pyobject pyxtemp0  pyxt0 pyxt0 pyxt0$^    pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp0pyxt0 0pyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxxdecrefpyxt0 pyxt0  0$^    pyxgotrefpyxt0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxdecrefpyxt0 pyxt0  0$^   else$^  endif$^  $^    pyxt0  pytuplenew0pyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxgotrefpyxt0$^    if pyxt0 $^      pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^    $^    pyxgiverefpyxt0$^    pytuplesetitempyxt0 0pyxt0 pyxt0$^    pyxgiverefpyxt0$^    pytuplesetitempyxt0 0pyxt0 pyxt0$^    pyxt0  0$^    pyxt0  0$^    pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxgotrefpyxt0$^    pyxdecrefpyxt0 pyxt0  0$^  $^  pyxdecrefpyxt0 pyxt0  0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   pywrapfst.pyx000$^     doing so will allow undefined behavior.$^  $^    def reprself              $^      return const fst symboltable r at 0xx.formatself.name$^                                                             idself$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.fstsymboltable.repr pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ tree fragment0$^  def reducecythonself              $^      raise typeerrorself.fstself.table cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00fstsymboltable0reducecythonpyobject pyxvself cythonunused pyobject unused proto$^static pyobject pyxpw0pywrapfst00fstsymboltable0reducecythonpyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextreducecython wrapper 0$^  pyxr  pyxpf0pywrapfst00fstsymboltable0reducecythonstruct pyxobj0pywrapfstfstsymboltable pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00fstsymboltable0reducecythoncythonunused struct pyxobj0pywrapfstfstsymboltable pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextreducecython 0$^$^   tree fragment0$^  def reducecythonself$^      raise typeerrorself.fstself.table cannot be converted to a python object for pickling              $^  def setstatecythonself pyxstate$^      raise typeerrorself.fstself.table cannot be converted to a python object for pickling$^ $^  pyxt0  pyxpyobjectcallpyxbuiltintypeerror pyxtuple00 null if unlikelypyxt0 pyxerr0 0 pyxl0error$^  pyxgotrefpyxt0$^  pyxraisepyxt0 0 0 0$^  pyxdecrefpyxt0 pyxt0  0$^  pyxerr0 0 pyxl0error$^$^   tree fragment0$^  def reducecythonself              $^      raise typeerrorself.fstself.table cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.fstsymboltable.reducecython pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ tree fragment0$^  def reducecythonself$^      raise typeerrorself.fstself.table cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate              $^      raise typeerrorself.fstself.table cannot be converted to a python object for pickling$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00fstsymboltable0setstatecythonpyobject pyxvself pyobject pyxvpyxstate proto$^static pyobject pyxpw0pywrapfst00fstsymboltable0setstatecythonpyobject pyxvself pyobject pyxvpyxstate $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextsetstatecython wrapper 0$^  pyxr  pyxpf0pywrapfst00fstsymboltable0setstatecythonstruct pyxobj0pywrapfstfstsymboltable pyxvself pyobject pyxvpyxstate$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00fstsymboltable0setstatecythoncythonunused struct pyxobj0pywrapfstfstsymboltable pyxvself cythonunused pyobject pyxvpyxstate $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextsetstatecython 0$^$^   tree fragment0$^      raise typeerrorself.fstself.table cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate$^      raise typeerrorself.fstself.table cannot be converted to a python object for pickling              $^ $^  pyxt0  pyxpyobjectcallpyxbuiltintypeerror pyxtuple00 null if unlikelypyxt0 pyxerr0 0 pyxl0error$^  pyxgotrefpyxt0$^  pyxraisepyxt0 0 0 0$^  pyxdecrefpyxt0 pyxt0  0$^  pyxerr0 0 pyxl0error$^$^   tree fragment0$^  def reducecythonself$^      raise typeerrorself.fstself.table cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate              $^      raise typeerrorself.fstself.table cannot be converted to a python object for pickling$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.fstsymboltable.setstatecython pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx000$^    $^  $^    cpdef int00 addsymbolself symbol int00 keyknosymbol              $^      $^      addsymbolself symbol keynosymbol$^ $^$^static pyobject pyxpw0pywrapfst00mutablesymboltable0addsymbolpyobject pyxvself pyobject pyxargs pyobject pyxkwds proto$^static pyxt00basictypesint00 pyxf0pywrapfst00mutablesymboltableaddsymbolstruct pyxobj0pywrapfstmutablesymboltable pyxvself pyobject pyxvsymbol int pyxskipdispatch struct pyxoptargs0pywrapfst00mutablesymboltableaddsymbol pyxoptionalargs $^  pyxt00basictypesint00 pyxvkey  pyxk00$^  stdstring pyxvsymbolstring$^  pyxt00basictypesint00 pyxr$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  int pyxt0$^  pyobject pyxt0  null$^  pyxt00basictypesint00 pyxt0$^  stdstring pyxt0$^  int pyxt00$^  pyxrefnannysetupcontextaddsymbol 0$^  if pyxoptionalargs $^    if pyxoptionalargspyxn  0 $^      pyxvkey  pyxoptionalargskey$^    $^  $^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnsaddsymbol if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst00mutablesymboltable0addsymbol $^      pyxt0  pyxpyintfromint00tpyxvkey if unlikelypyxt0 pyxerr0 000 pyxl0error$^      pyxgotrefpyxt0$^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      pyxt0  0$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^          pyxt0  0$^        $^      $^      if cythonfastpycall$^      if pyfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxvsymbol pyxt0$^        pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp0pyxt0 0pyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^       else$^      endif$^      if cythonfastpyccall$^      if pyxpyfastcfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxvsymbol pyxt0$^        pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp0pyxt0 0pyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^       else$^      endif$^      $^        pyxt0  pytuplenew0pyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxgotrefpyxt0$^        if pyxt0 $^          pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^        $^        pyxincrefpyxvsymbol$^        pyxgiverefpyxvsymbol$^        pytuplesetitempyxt0 0pyxt0 pyxvsymbol$^        pyxgiverefpyxt0$^        pytuplesetitempyxt0 0pyxt0 pyxt0$^        pyxt0  0$^        pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^      $^      pyxdecrefpyxt0 pyxt0  0$^      pyxt0  pyxpyintasint00tpyxt0 if unlikelypyxt0  int00t0  pyerroccurred pyxerr0 000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxr  pyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx000$^        the integer key of the new symbol.$^      $^      cdef string symbolstring  tostringsymbol              $^      if key  knosymbol$^        return self.table.addsymbolsymbolstring key$^ $^  pyxt0  pyxf0pywrapfsttostringpyxvsymbol null if unlikelypyerroccurred pyxerr0 000 pyxl0error$^  pyxvsymbolstring  pyxt0$^$^   pywrapfst.pyx000$^      $^      cdef string symbolstring  tostringsymbol$^      if key  knosymbol              $^        return self.table.addsymbolsymbolstring key$^      else$^ $^  pyxt0  pyxpyintfromint00tpyxvkey if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxt0  pyxgetmoduleglobalnamepyxnsknosymbol if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxt0  pyobjectrichcomparepyxt0 pyxt0 pyne pyxxgotrefpyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^  pyxdecrefpyxt0 pyxt0  0$^  pyxt00  pyxpyobjectistruepyxt0 if unlikelypyxt00  0 pyxerr0 000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^  if pyxt00 $^$^     pywrapfst.pyx000$^      cdef string symbolstring  tostringsymbol$^      if key  knosymbol$^        return self.table.addsymbolsymbolstring key              $^      else$^        return self.table.addsymbolsymbolstring$^ $^    if unlikelypyobject pyxvself  pynone $^      pyerrformatpyexcattributeerror nonetype object has no attribute .00s table$^      pyxerr0 000 pyxl0error$^    $^    pyxr  pyxvselfpyxbase.tableaddsymbolpyxvsymbolstring pyxvkey$^    goto pyxl0$^$^     pywrapfst.pyx000$^      $^      cdef string symbolstring  tostringsymbol$^      if key  knosymbol              $^        return self.table.addsymbolsymbolstring key$^      else$^ $^  $^$^   pywrapfst.pyx000$^        return self.table.addsymbolsymbolstring key$^      else$^        return self.table.addsymbolsymbolstring              $^  $^    cpdef void addtableself symboltable syms$^ $^  else $^    if unlikelypyobject pyxvself  pynone $^      pyerrformatpyexcattributeerror nonetype object has no attribute .00s table$^      pyxerr0 000 pyxl0error$^    $^    pyxr  pyxvselfpyxbase.tableaddsymbolpyxvsymbolstring$^    goto pyxl0$^  $^$^   pywrapfst.pyx000$^    $^  $^    cpdef int00 addsymbolself symbol int00 keyknosymbol              $^      $^      addsymbolself symbol keynosymbol$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxwriteunraisablepywrapfst.mutablesymboltable.addsymbol pyxclineno pyxlineno pyxfilename 0 0$^  pyxr  0$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst00mutablesymboltable0addsymbolpyobject pyxvself pyobject pyxargs pyobject pyxkwds proto$^static char pyxdoc0pywrapfst00mutablesymboltableaddsymbol  n    addsymbolself symbol keynosymbolnn    adds a symbol to the table and returns the index.nn    this method adds a symbol to the table. the caller can optionallyn    specify a nonnegative integer index for the key.nn    argsn      symbol a symbol string.n      key an index for the symbol if not specified the next index will ben          used.nn    returnsn      the integer key of the new symbol.n    $^static pyobject pyxpw0pywrapfst00mutablesymboltable0addsymbolpyobject pyxvself pyobject pyxargs pyobject pyxkwds $^  pyobject pyxvsymbol  0$^  pyxt00basictypesint00 pyxvkey$^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextaddsymbol wrapper 0$^  $^    static pyobject pyxpyargnames  pyxnssymbolpyxnskey0$^    pyobject values0  00$^    if unlikelypyxkwds $^      pyssizet kwargs$^      const pyssizet posargs  pytuplegetsizepyxargs$^      switch posargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 break$^        default goto pyxl0argtupleerror$^      $^      kwargs  pydictsizepyxkwds$^      switch posargs $^        case  0$^        if likelyvalues0  pydictgetitempyxkwds pyxnssymbol  0 kwargs$^        else goto pyxl0argtupleerror$^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pydictgetitempyxkwds pyxnskey$^          if value  values0  value kwargs $^        $^      $^      if unlikelykwargs  0 $^        if unlikelypyxparseoptionalkeywordspyxkwds pyxpyargnames 0 values posargs addsymbol  0 pyxerr0 000 pyxl0error$^      $^     else $^      switch pytuplegetsizepyxargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        break$^        default goto pyxl0argtupleerror$^      $^    $^    pyxvsymbol  values0$^    if values0 $^      pyxvkey  pyxpyintasint00tvalues0 if unlikelypyxvkey  int00t0  pyerroccurred pyxerr0 000 pyxl0error$^     else $^      pyxvkey  pyxk00$^    $^  $^  goto pyxl0argumentunpackingdone$^  pyxl0argtupleerror$^  pyxraiseargtupleinvalidaddsymbol 0 0 0 pytuplegetsizepyxargs pyxerr0 000 pyxl0error$^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablesymboltable.addsymbol pyxclineno pyxlineno pyxfilename$^  pyxrefnannyfinishcontext$^  return null$^  pyxl0argumentunpackingdone$^  pyxr  pyxpf0pywrapfst00mutablesymboltableaddsymbolstruct pyxobj0pywrapfstmutablesymboltable pyxvself pyxvsymbol pyxvkey$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00mutablesymboltableaddsymbolstruct pyxobj0pywrapfstmutablesymboltable pyxvself pyobject pyxvsymbol pyxt00basictypesint00 pyxvkey $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyxt00basictypesint00 pyxt0$^  struct pyxoptargs0pywrapfst00mutablesymboltableaddsymbol pyxt0$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextaddsymbol 0$^  pyxxdecrefpyxr$^  pyxt0.pyxn  0$^  pyxt0.key  pyxvkey$^  pyxt0  pyxvtabptr0pywrapfstmutablesymboltableaddsymbolpyxvself pyxvsymbol 0 pyxt0 $^  pyxt0  pyxpyintfromint00tpyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.mutablesymboltable.addsymbol pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx000$^        return self.table.addsymbolsymbolstring$^  $^    cpdef void addtableself symboltable syms              $^      $^      addtableself syms$^ $^$^static pyobject pyxpw0pywrapfst00mutablesymboltable0addtablepyobject pyxvself pyobject pyxvsyms proto$^static void pyxf0pywrapfst00mutablesymboltableaddtablestruct pyxobj0pywrapfstmutablesymboltable pyxvself struct pyxobj0pywrapfstsymboltable pyxvsyms int pyxskipdispatch $^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextaddtable 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnsaddtable if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst00mutablesymboltable0addtable $^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyobject pyxvsyms if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxgotrefpyxt0$^       else $^        if cythonfastpycall$^        if pyfunctioncheckpyxt0 $^          pyobject pyxtemp0  pyxt0 pyobject pyxvsyms$^          pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^          pyxxdecrefpyxt0 pyxt0  0$^          pyxgotrefpyxt0$^         else$^        endif$^        if cythonfastpyccall$^        if pyxpyfastcfunctioncheckpyxt0 $^          pyobject pyxtemp0  pyxt0 pyobject pyxvsyms$^          pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^          pyxxdecrefpyxt0 pyxt0  0$^          pyxgotrefpyxt0$^         else$^        endif$^        $^          pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^          pyxgotrefpyxt0$^          pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^          pyxincrefpyobject pyxvsyms$^          pyxgiverefpyobject pyxvsyms$^          pytuplesetitempyxt0 00 pyobject pyxvsyms$^          pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 000 pyxl0error$^          pyxgotrefpyxt0$^          pyxdecrefpyxt0 pyxt0  0$^        $^      $^      pyxdecrefpyxt0 pyxt0  0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx000$^        syms a symboltable to be merged with the current table.$^      $^      self.table.addtablederefsyms.table              $^  $^    cpdef void setnameself newname except $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s table$^    pyxerr0 000 pyxl0error$^  $^  if unlikelypyobject pyxvsyms  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s table$^    pyxerr0 000 pyxl0error$^  $^  pyxvselfpyxbase.tableaddtablepyxvsymstable$^$^   pywrapfst.pyx000$^        return self.table.addsymbolsymbolstring$^  $^    cpdef void addtableself symboltable syms              $^      $^      addtableself syms$^ $^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxwriteunraisablepywrapfst.mutablesymboltable.addtable pyxclineno pyxlineno pyxfilename 0 0$^  pyxl0$^  pyxrefnannyfinishcontext$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst00mutablesymboltable0addtablepyobject pyxvself pyobject pyxvsyms proto$^static char pyxdoc0pywrapfst00mutablesymboltable0addtable  n    addtableself symsnn    adds another symboltable to this table.nn    this method merges another symbol table into the current table. all keyn    values will be offset by the current available key.nn    argsn      syms a symboltable to be merged with the current table.n    $^static pyobject pyxpw0pywrapfst00mutablesymboltable0addtablepyobject pyxvself pyobject pyxvsyms $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextaddtable wrapper 0$^  if unlikelypyxargtypetestpyobject pyxvsyms pyxptype0pywrapfstsymboltable 0 syms 0 pyxerr0 000 pyxl0error$^  pyxr  pyxpf0pywrapfst00mutablesymboltable0addtablestruct pyxobj0pywrapfstmutablesymboltable pyxvself struct pyxobj0pywrapfstsymboltable pyxvsyms$^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxr  null$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00mutablesymboltable0addtablestruct pyxobj0pywrapfstmutablesymboltable pyxvself struct pyxobj0pywrapfstsymboltable pyxvsyms $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextaddtable 0$^  pyxxdecrefpyxr$^  pyxt0  pyxvoidtononepyxf0pywrapfst00mutablesymboltableaddtablepyxvself pyxvsyms 0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.mutablesymboltable.addtable pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx000$^      self.table.addtablederefsyms.table$^  $^    cpdef void setnameself newname except               $^      self.table.setnametostringnewname$^  $^ $^$^static pyobject pyxpw0pywrapfst00mutablesymboltable0setnamepyobject pyxvself pyobject pyxvnewname proto$^static void pyxf0pywrapfst00mutablesymboltablesetnamestruct pyxobj0pywrapfstmutablesymboltable pyxvself pyobject pyxvnewname int pyxskipdispatch $^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  stdstring pyxt0$^  pyxrefnannysetupcontextsetname 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnssetname if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst00mutablesymboltable0setname $^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxvnewname if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxgotrefpyxt0$^       else $^        if cythonfastpycall$^        if pyfunctioncheckpyxt0 $^          pyobject pyxtemp0  pyxt0 pyxvnewname$^          pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^          pyxxdecrefpyxt0 pyxt0  0$^          pyxgotrefpyxt0$^         else$^        endif$^        if cythonfastpyccall$^        if pyxpyfastcfunctioncheckpyxt0 $^          pyobject pyxtemp0  pyxt0 pyxvnewname$^          pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^          pyxxdecrefpyxt0 pyxt0  0$^          pyxgotrefpyxt0$^         else$^        endif$^        $^          pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^          pyxgotrefpyxt0$^          pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^          pyxincrefpyxvnewname$^          pyxgiverefpyxvnewname$^          pytuplesetitempyxt0 00 pyxvnewname$^          pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 000 pyxl0error$^          pyxgotrefpyxt0$^          pyxdecrefpyxt0 pyxt0  0$^        $^      $^      pyxdecrefpyxt0 pyxt0  0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx000$^  $^    cpdef void setnameself newname except $^      self.table.setnametostringnewname              $^  $^  $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s table$^    pyxerr0 000 pyxl0error$^  $^  pyxt0  pyxf0pywrapfsttostringpyxvnewname null if unlikelypyerroccurred pyxerr0 000 pyxl0error$^  pyxvselfpyxbase.tablesetnamepyxt0$^$^   pywrapfst.pyx000$^      self.table.addtablederefsyms.table$^  $^    cpdef void setnameself newname except               $^      self.table.setnametostringnewname$^  $^ $^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.mutablesymboltable.setname pyxclineno pyxlineno pyxfilename$^  pyxl0$^  pyxrefnannyfinishcontext$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst00mutablesymboltable0setnamepyobject pyxvself pyobject pyxvnewname proto$^static pyobject pyxpw0pywrapfst00mutablesymboltable0setnamepyobject pyxvself pyobject pyxvnewname $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextsetname wrapper 0$^  pyxr  pyxpf0pywrapfst00mutablesymboltable0setnamestruct pyxobj0pywrapfstmutablesymboltable pyxvself pyobject pyxvnewname$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00mutablesymboltable0setnamestruct pyxobj0pywrapfstmutablesymboltable pyxvself pyobject pyxvnewname $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextsetname 0$^  pyxxdecrefpyxr$^  pyxf0pywrapfst00mutablesymboltablesetnamepyxvself pyxvnewname 0 if unlikelypyerroccurred pyxerr0 000 pyxl0error$^  pyxt0  pyxvoidtononenull if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.mutablesymboltable.setname pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ tree fragment0$^  def reducecythonself              $^      raise typeerrorself.table cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00mutablesymboltable0reducecythonpyobject pyxvself cythonunused pyobject unused proto$^static pyobject pyxpw0pywrapfst00mutablesymboltable0reducecythonpyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextreducecython wrapper 0$^  pyxr  pyxpf0pywrapfst00mutablesymboltable0reducecythonstruct pyxobj0pywrapfstmutablesymboltable pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00mutablesymboltable0reducecythoncythonunused struct pyxobj0pywrapfstmutablesymboltable pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextreducecython 0$^$^   tree fragment0$^  def reducecythonself$^      raise typeerrorself.table cannot be converted to a python object for pickling              $^  def setstatecythonself pyxstate$^      raise typeerrorself.table cannot be converted to a python object for pickling$^ $^  pyxt0  pyxpyobjectcallpyxbuiltintypeerror pyxtuple00 null if unlikelypyxt0 pyxerr0 0 pyxl0error$^  pyxgotrefpyxt0$^  pyxraisepyxt0 0 0 0$^  pyxdecrefpyxt0 pyxt0  0$^  pyxerr0 0 pyxl0error$^$^   tree fragment0$^  def reducecythonself              $^      raise typeerrorself.table cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.mutablesymboltable.reducecython pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ tree fragment0$^  def reducecythonself$^      raise typeerrorself.table cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate              $^      raise typeerrorself.table cannot be converted to a python object for pickling$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00mutablesymboltable0setstatecythonpyobject pyxvself pyobject pyxvpyxstate proto$^static pyobject pyxpw0pywrapfst00mutablesymboltable0setstatecythonpyobject pyxvself pyobject pyxvpyxstate $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextsetstatecython wrapper 0$^  pyxr  pyxpf0pywrapfst00mutablesymboltable0setstatecythonstruct pyxobj0pywrapfstmutablesymboltable pyxvself pyobject pyxvpyxstate$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00mutablesymboltable0setstatecythoncythonunused struct pyxobj0pywrapfstmutablesymboltable pyxvself cythonunused pyobject pyxvpyxstate $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextsetstatecython 0$^$^   tree fragment0$^      raise typeerrorself.table cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate$^      raise typeerrorself.table cannot be converted to a python object for pickling              $^ $^  pyxt0  pyxpyobjectcallpyxbuiltintypeerror pyxtuple00 null if unlikelypyxt0 pyxerr0 0 pyxl0error$^  pyxgotrefpyxt0$^  pyxraisepyxt0 0 0 0$^  pyxdecrefpyxt0 pyxt0  0$^  pyxerr0 0 pyxl0error$^$^   tree fragment0$^  def reducecythonself$^      raise typeerrorself.table cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate              $^      raise typeerrorself.table cannot be converted to a python object for pickling$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.mutablesymboltable.setstatecython pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx000$^    $^  $^    def reprself              $^      return fst symboltable r at 0xx.formatself.name idself$^  $^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00mutablefstsymboltable0reprpyobject pyxvself proto$^static pyobject pyxpw0pywrapfst00mutablefstsymboltable0reprpyobject pyxvself $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextrepr wrapper 0$^  pyxr  pyxpf0pywrapfst00mutablefstsymboltablereprstruct pyxobj0pywrapfstmutablefstsymboltable pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00mutablefstsymboltablereprstruct pyxobj0pywrapfstmutablefstsymboltable pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  int pyxt0$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextrepr 0$^$^   pywrapfst.pyx000$^  $^    def reprself$^      return fst symboltable r at 0xx.formatself.name idself              $^  $^  $^ $^  pyxxdecrefpyxr$^  pyxt0  pyxpyobjectgetattrstrpyxkpsfstsymboltablerat0xx pyxnsformat if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s name$^    pyxerr0 000 pyxl0error$^  $^  pyxt0  pyxconvertpybytesstringtopystdinstringstruct pyxvtabstruct0pywrapfstmutablefstsymboltable pyxvselfpyxbase.pyxbase.pyxvtabpyxbase.pyxbase.namestruct pyxobj0pywrapfstsymboltable pyxvself 0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxt0  pytuplenew0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxincrefpyobject pyxvself$^  pyxgiverefpyobject pyxvself$^  pytuplesetitempyxt0 0 pyobject pyxvself$^  pyxt0  pyxpyobjectcallpyxbuiltinid pyxt0 null if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxdecrefpyxt0 pyxt0  0$^  pyxt0  null$^  pyxt0  0$^  if cythonunpackmethods  likelypymethodcheckpyxt0 $^    pyxt0  pymethodgetselfpyxt0$^    if likelypyxt0 $^      pyobject function  pymethodgetfunctionpyxt0$^      pyxincrefpyxt0$^      pyxincreffunction$^      pyxdecrefsetpyxt0 function$^      pyxt0  0$^    $^  $^  if cythonfastpycall$^  if pyfunctioncheckpyxt0 $^    pyobject pyxtemp0  pyxt0 pyxt0 pyxt0$^    pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp0pyxt0 0pyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxxdecrefpyxt0 pyxt0  0$^    pyxgotrefpyxt0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxdecrefpyxt0 pyxt0  0$^   else$^  endif$^  if cythonfastpyccall$^  if pyxpyfastcfunctioncheckpyxt0 $^    pyobject pyxtemp0  pyxt0 pyxt0 pyxt0$^    pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp0pyxt0 0pyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxxdecrefpyxt0 pyxt0  0$^    pyxgotrefpyxt0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxdecrefpyxt0 pyxt0  0$^   else$^  endif$^  $^    pyxt0  pytuplenew0pyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxgotrefpyxt0$^    if pyxt0 $^      pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^    $^    pyxgiverefpyxt0$^    pytuplesetitempyxt0 0pyxt0 pyxt0$^    pyxgiverefpyxt0$^    pytuplesetitempyxt0 0pyxt0 pyxt0$^    pyxt0  0$^    pyxt0  0$^    pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxgotrefpyxt0$^    pyxdecrefpyxt0 pyxt0  0$^  $^  pyxdecrefpyxt0 pyxt0  0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   pywrapfst.pyx000$^    $^  $^    def reprself              $^      return fst symboltable r at 0xx.formatself.name idself$^  $^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.mutablefstsymboltable.repr pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ tree fragment0$^  def reducecythonself              $^      raise typeerrorself.mfstself.table cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00mutablefstsymboltable0reducecythonpyobject pyxvself cythonunused pyobject unused proto$^static pyobject pyxpw0pywrapfst00mutablefstsymboltable0reducecythonpyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextreducecython wrapper 0$^  pyxr  pyxpf0pywrapfst00mutablefstsymboltable0reducecythonstruct pyxobj0pywrapfstmutablefstsymboltable pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00mutablefstsymboltable0reducecythoncythonunused struct pyxobj0pywrapfstmutablefstsymboltable pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextreducecython 0$^$^   tree fragment0$^  def reducecythonself$^      raise typeerrorself.mfstself.table cannot be converted to a python object for pickling              $^  def setstatecythonself pyxstate$^      raise typeerrorself.mfstself.table cannot be converted to a python object for pickling$^ $^  pyxt0  pyxpyobjectcallpyxbuiltintypeerror pyxtuple00 null if unlikelypyxt0 pyxerr0 0 pyxl0error$^  pyxgotrefpyxt0$^  pyxraisepyxt0 0 0 0$^  pyxdecrefpyxt0 pyxt0  0$^  pyxerr0 0 pyxl0error$^$^   tree fragment0$^  def reducecythonself              $^      raise typeerrorself.mfstself.table cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.mutablefstsymboltable.reducecython pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ tree fragment0$^  def reducecythonself$^      raise typeerrorself.mfstself.table cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate              $^      raise typeerrorself.mfstself.table cannot be converted to a python object for pickling$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00mutablefstsymboltable0setstatecythonpyobject pyxvself pyobject pyxvpyxstate proto$^static pyobject pyxpw0pywrapfst00mutablefstsymboltable0setstatecythonpyobject pyxvself pyobject pyxvpyxstate $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextsetstatecython wrapper 0$^  pyxr  pyxpf0pywrapfst00mutablefstsymboltable0setstatecythonstruct pyxobj0pywrapfstmutablefstsymboltable pyxvself pyobject pyxvpyxstate$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00mutablefstsymboltable0setstatecythoncythonunused struct pyxobj0pywrapfstmutablefstsymboltable pyxvself cythonunused pyobject pyxvpyxstate $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextsetstatecython 0$^$^   tree fragment0$^      raise typeerrorself.mfstself.table cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate$^      raise typeerrorself.mfstself.table cannot be converted to a python object for pickling              $^ $^  pyxt0  pyxpyobjectcallpyxbuiltintypeerror pyxtuple00 null if unlikelypyxt0 pyxerr0 0 pyxl0error$^  pyxgotrefpyxt0$^  pyxraisepyxt0 0 0 0$^  pyxdecrefpyxt0 pyxt0  0$^  pyxerr0 0 pyxl0error$^$^   tree fragment0$^  def reducecythonself$^      raise typeerrorself.mfstself.table cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate              $^      raise typeerrorself.mfstself.table cannot be converted to a python object for pickling$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.mutablefstsymboltable.setstatecython pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx000$^    $^  $^    def reprself              $^      return symboltable r at 0xx.formatself.name idself$^  $^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00symboltable0reprpyobject pyxvself proto$^static pyobject pyxpw0pywrapfst00symboltable0reprpyobject pyxvself $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextrepr wrapper 0$^  pyxr  pyxpf0pywrapfst00symboltablereprstruct pyxobj0pywrapfstsymboltable pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00symboltablereprstruct pyxobj0pywrapfstsymboltable pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  int pyxt0$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextrepr 0$^$^   pywrapfst.pyx000$^  $^    def reprself$^      return symboltable r at 0xx.formatself.name idself              $^  $^    def initself namebunspecified$^ $^  pyxxdecrefpyxr$^  pyxt0  pyxpyobjectgetattrstrpyxkpssymboltablerat0xx pyxnsformat if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s name$^    pyxerr0 000 pyxl0error$^  $^  pyxt0  pyxconvertpybytesstringtopystdinstringstruct pyxvtabstruct0pywrapfstsymboltable pyxvselfpyxbase.pyxbase.pyxvtabpyxbase.pyxbase.namestruct pyxobj0pywrapfstsymboltable pyxvself 0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxt0  pytuplenew0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxincrefpyobject pyxvself$^  pyxgiverefpyobject pyxvself$^  pytuplesetitempyxt0 0 pyobject pyxvself$^  pyxt0  pyxpyobjectcallpyxbuiltinid pyxt0 null if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxdecrefpyxt0 pyxt0  0$^  pyxt0  null$^  pyxt0  0$^  if cythonunpackmethods  likelypymethodcheckpyxt0 $^    pyxt0  pymethodgetselfpyxt0$^    if likelypyxt0 $^      pyobject function  pymethodgetfunctionpyxt0$^      pyxincrefpyxt0$^      pyxincreffunction$^      pyxdecrefsetpyxt0 function$^      pyxt0  0$^    $^  $^  if cythonfastpycall$^  if pyfunctioncheckpyxt0 $^    pyobject pyxtemp0  pyxt0 pyxt0 pyxt0$^    pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp0pyxt0 0pyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxxdecrefpyxt0 pyxt0  0$^    pyxgotrefpyxt0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxdecrefpyxt0 pyxt0  0$^   else$^  endif$^  if cythonfastpyccall$^  if pyxpyfastcfunctioncheckpyxt0 $^    pyobject pyxtemp0  pyxt0 pyxt0 pyxt0$^    pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp0pyxt0 0pyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxxdecrefpyxt0 pyxt0  0$^    pyxgotrefpyxt0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxdecrefpyxt0 pyxt0  0$^   else$^  endif$^  $^    pyxt0  pytuplenew0pyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxgotrefpyxt0$^    if pyxt0 $^      pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^    $^    pyxgiverefpyxt0$^    pytuplesetitempyxt0 0pyxt0 pyxt0$^    pyxgiverefpyxt0$^    pytuplesetitempyxt0 0pyxt0 pyxt0$^    pyxt0  0$^    pyxt0  0$^    pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxgotrefpyxt0$^    pyxdecrefpyxt0 pyxt0  0$^  $^  pyxdecrefpyxt0 pyxt0  0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   pywrapfst.pyx000$^    $^  $^    def reprself              $^      return symboltable r at 0xx.formatself.name idself$^  $^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.symboltable.repr pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx000$^      return symboltable r at 0xx.formatself.name idself$^  $^    def initself namebunspecified              $^      self.table  new fst.symboltabletostringname$^      self.smarttable.resetself.table$^ $^$^ python wrapper $^static int pyxpw0pywrapfst00symboltable0initpyobject pyxvself pyobject pyxargs pyobject pyxkwds proto$^static int pyxpw0pywrapfst00symboltable0initpyobject pyxvself pyobject pyxargs pyobject pyxkwds $^  pyobject pyxvname  0$^  int pyxr$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextinit wrapper 0$^  $^    static pyobject pyxpyargnames  pyxnsname00$^    pyobject values0  0$^    values0  pyobject pyxkpbunspecified$^    if unlikelypyxkwds $^      pyssizet kwargs$^      const pyssizet posargs  pytuplegetsizepyxargs$^      switch posargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 break$^        default goto pyxl0argtupleerror$^      $^      kwargs  pydictsizepyxkwds$^      switch posargs $^        case  0$^        if kwargs  0 $^          pyobject value  pydictgetitempyxkwds pyxnsname0$^          if value  values0  value kwargs $^        $^      $^      if unlikelykwargs  0 $^        if unlikelypyxparseoptionalkeywordspyxkwds pyxpyargnames 0 values posargs init  0 pyxerr0 000 pyxl0error$^      $^     else $^      switch pytuplegetsizepyxargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 break$^        default goto pyxl0argtupleerror$^      $^    $^    pyxvname  values0$^  $^  goto pyxl0argumentunpackingdone$^  pyxl0argtupleerror$^  pyxraiseargtupleinvalidinit 0 0 0 pytuplegetsizepyxargs pyxerr0 000 pyxl0error$^  pyxl0error$^  pyxaddtracebackpywrapfst.symboltable.init pyxclineno pyxlineno pyxfilename$^  pyxrefnannyfinishcontext$^  return 0$^  pyxl0argumentunpackingdone$^  pyxr  pyxpf0pywrapfst00symboltable0initstruct pyxobj0pywrapfstsymboltable pyxvself pyxvname$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static int pyxpf0pywrapfst00symboltable0initstruct pyxobj0pywrapfstsymboltable pyxvself pyobject pyxvname $^  int pyxr$^  pyxrefnannydeclarations$^  stdstring pyxt0$^  pyxrefnannysetupcontextinit 0$^$^   pywrapfst.pyx000$^  $^    def initself namebunspecified$^      self.table  new fst.symboltabletostringname              $^      self.smarttable.resetself.table$^  $^ $^  pyxt0  pyxf0pywrapfsttostringpyxvname null if unlikelypyerroccurred pyxerr0 000 pyxl0error$^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s table$^    pyxerr0 000 pyxl0error$^  $^  pyxvselfpyxbase.pyxbase.table  new fstsymboltablepyxt0$^$^   pywrapfst.pyx000$^    def initself namebunspecified$^      self.table  new fst.symboltabletostringname$^      self.smarttable.resetself.table              $^  $^    classmethod$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s smarttable$^    pyxerr0 000 pyxl0error$^  $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s table$^    pyxerr0 000 pyxl0error$^  $^  pyxvselfsmarttable.resetpyxvselfpyxbase.pyxbase.table$^$^   pywrapfst.pyx000$^      return symboltable r at 0xx.formatself.name idself$^  $^    def initself namebunspecified              $^      self.table  new fst.symboltabletostringname$^      self.smarttable.resetself.table$^ $^$^   function exit code $^  pyxr  0$^  goto pyxl0$^  pyxl0error$^  pyxaddtracebackpywrapfst.symboltable.init pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx000$^  $^    classmethod$^    def readcls filename              $^      $^      symboltable.readfilename$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00symboltable0readpyobject pyxvcls pyobject pyxvfilename proto$^static char pyxdoc0pywrapfst00symboltable0read  n    symboltable.readfilenamenn    reads symbol table from binary file.nn    this class method creates a new symboltable from a symbol table binary file.nn    argsn      filename the string location of the input binary file.nn    returnsn      a new symboltable instance.nn    see also symboltable.readfst symboltable.readtext.n    $^static pyobject pyxpw0pywrapfst00symboltable0readpyobject pyxvcls pyobject pyxvfilename $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextread wrapper 0$^  pyxr  pyxpf0pywrapfst00symboltable0readpytypeobjectpyxvcls pyobject pyxvfilename$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00symboltable0readcythonunused pytypeobject pyxvcls pyobject pyxvfilename $^  fstsymboltable pyxvtsyms$^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  stdstring pyxt0$^  int pyxt0$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextread 0$^$^   pywrapfst.pyx000$^      see also symboltable.readfst symboltable.readtext.$^      $^      cdef fst.symboltable tsyms  fst.symboltable.readtostringfilename              $^      if tsyms  null$^        raise fstioerrorread failed r.formatfilename$^ $^  pyxt0  pyxf0pywrapfsttostringpyxvfilename null if unlikelypyerroccurred pyxerr0 000 pyxl0error$^  pyxvtsyms  fstsymboltablereadpyxt0$^$^   pywrapfst.pyx000$^      $^      cdef fst.symboltable tsyms  fst.symboltable.readtostringfilename$^      if tsyms  null              $^        raise fstioerrorread failed r.formatfilename$^      return initsymboltabletsyms$^ $^  pyxt0  pyxvtsyms  null  0$^  if pyxt0 $^$^     pywrapfst.pyx000$^      cdef fst.symboltable tsyms  fst.symboltable.readtostringfilename$^      if tsyms  null$^        raise fstioerrorread failed r.formatfilename              $^      return initsymboltabletsyms$^  $^ $^    pyxt0  pyxgetmoduleglobalnamepyxnsfstioerror if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  pyxpyobjectgetattrstrpyxkpsreadfailedr pyxnsformat if unlikelypyxt0 pyxerr0 000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  null$^    if cythonunpackmethods  likelypymethodcheckpyxt0 $^      pyxt0  pymethodgetselfpyxt0$^      if likelypyxt0 $^        pyobject function  pymethodgetfunctionpyxt0$^        pyxincrefpyxt0$^        pyxincreffunction$^        pyxdecrefsetpyxt0 function$^      $^    $^    if pyxt0 $^      pyxt0  pyxpyobjectcalloneargpyxt0 pyxvfilename if unlikelypyxt0 pyxerr0 000 pyxl0error$^      pyxgotrefpyxt0$^     else $^      if cythonfastpycall$^      if pyfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxvfilename$^        pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^       else$^      endif$^      if cythonfastpyccall$^      if pyxpyfastcfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxvfilename$^        pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^       else$^      endif$^      $^        pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxgotrefpyxt0$^        pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^        pyxincrefpyxvfilename$^        pyxgiverefpyxvfilename$^        pytuplesetitempyxt0 00 pyxvfilename$^        pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^      $^    $^    pyxdecrefpyxt0 pyxt0  0$^    pyxt0  null$^    if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^      pyxt0  pymethodgetselfpyxt0$^      if likelypyxt0 $^        pyobject function  pymethodgetfunctionpyxt0$^        pyxincrefpyxt0$^        pyxincreffunction$^        pyxdecrefsetpyxt0 function$^      $^    $^    if pyxt0 $^      pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxgotrefpyxt0$^     else $^      if cythonfastpycall$^      if pyfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxt0$^        pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^       else$^      endif$^      if cythonfastpyccall$^      if pyxpyfastcfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxt0$^        pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^       else$^      endif$^      $^        pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxgotrefpyxt0$^        pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^        pyxgiverefpyxt0$^        pytuplesetitempyxt0 00 pyxt0$^        pyxt0  0$^        pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 000 pyxl0error$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^      $^    $^    pyxdecrefpyxt0 pyxt0  0$^    pyxraisepyxt0 0 0 0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxerr0 000 pyxl0error$^$^     pywrapfst.pyx000$^      $^      cdef fst.symboltable tsyms  fst.symboltable.readtostringfilename$^      if tsyms  null              $^        raise fstioerrorread failed r.formatfilename$^      return initsymboltabletsyms$^ $^  $^$^   pywrapfst.pyx000$^      if tsyms  null$^        raise fstioerrorread failed r.formatfilename$^      return initsymboltabletsyms              $^  $^    classmethod$^ $^  pyxxdecrefpyxr$^  pyxt0  pyobject pyxf0pywrapfstinitsymboltablepyxvtsyms if unlikelypyxt0 pyxerr0 000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   pywrapfst.pyx000$^  $^    classmethod$^    def readcls filename              $^      $^      symboltable.readfilename$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.symboltable.read pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx000$^  $^    classmethod$^    def readtextcls filename bool allownegativelabelsfalse              $^      $^      symboltable.readtextfilename$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00symboltable0readtextpyobject pyxvcls pyobject pyxargs pyobject pyxkwds proto$^static char pyxdoc0pywrapfst00symboltable0readtext  n    symboltable.readtextfilenamenn    reads symbol table from text file.nn    this class method creates a new symboltable from a symbol table text file.nn    argsn      filename the string location of the input text file.n      allownegativelabels should negative labels be allowed notn          recommended may cause conflicts.nn    returnsn      a new symboltable instance.nn    see also symboltable.read symboltable.readfst.n    $^static pyobject pyxpw0pywrapfst00symboltable0readtextpyobject pyxvcls pyobject pyxargs pyobject pyxkwds $^  pyobject pyxvfilename  0$^  bool pyxvallownegativelabels$^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextreadtext wrapper 0$^  $^    static pyobject pyxpyargnames  pyxnsfilenamepyxnsallownegativelabels0$^    pyobject values0  00$^    if unlikelypyxkwds $^      pyssizet kwargs$^      const pyssizet posargs  pytuplegetsizepyxargs$^      switch posargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 break$^        default goto pyxl0argtupleerror$^      $^      kwargs  pydictsizepyxkwds$^      switch posargs $^        case  0$^        if likelyvalues0  pydictgetitempyxkwds pyxnsfilename  0 kwargs$^        else goto pyxl0argtupleerror$^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pydictgetitempyxkwds pyxnsallownegativelabels$^          if value  values0  value kwargs $^        $^      $^      if unlikelykwargs  0 $^        if unlikelypyxparseoptionalkeywordspyxkwds pyxpyargnames 0 values posargs readtext  0 pyxerr0 000 pyxl0error$^      $^     else $^      switch pytuplegetsizepyxargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        break$^        default goto pyxl0argtupleerror$^      $^    $^    pyxvfilename  values0$^    if values0 $^      pyxvallownegativelabels  pyxpyobjectistruevalues0 if unlikelypyxvallownegativelabels  bool0  pyerroccurred pyxerr0 000 pyxl0error$^     else $^      pyxvallownegativelabels  bool0$^    $^  $^  goto pyxl0argumentunpackingdone$^  pyxl0argtupleerror$^  pyxraiseargtupleinvalidreadtext 0 0 0 pytuplegetsizepyxargs pyxerr0 000 pyxl0error$^  pyxl0error$^  pyxaddtracebackpywrapfst.symboltable.readtext pyxclineno pyxlineno pyxfilename$^  pyxrefnannyfinishcontext$^  return null$^  pyxl0argumentunpackingdone$^  pyxr  pyxpf0pywrapfst00symboltable0readtextpytypeobjectpyxvcls pyxvfilename pyxvallownegativelabels$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00symboltable0readtextcythonunused pytypeobject pyxvcls pyobject pyxvfilename bool pyxvallownegativelabels $^  stduniqueptrfstsymboltabletextoptions  pyxvopts$^  fstsymboltable pyxvtsyms$^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  stdstring pyxt0$^  int pyxt0$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextreadtext 0$^$^   pywrapfst.pyx0000$^      $^      cdef uniqueptrfst.symboltabletextoptions opts$^      opts.resetnew fst.symboltabletextoptionsallownegativelabels              $^      cdef fst.symboltable tsyms  fst.symboltable.readtexttostringfilename$^                                                             derefopts$^ $^  pyxvopts.resetnew fstsymboltabletextoptionspyxvallownegativelabels$^$^   pywrapfst.pyx0000$^      cdef uniqueptrfst.symboltabletextoptions opts$^      opts.resetnew fst.symboltabletextoptionsallownegativelabels$^      cdef fst.symboltable tsyms  fst.symboltable.readtexttostringfilename              $^                                                             derefopts$^      if tsyms  null$^ $^  pyxt0  pyxf0pywrapfsttostringpyxvfilename null if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^      opts.resetnew fst.symboltabletextoptionsallownegativelabels$^      cdef fst.symboltable tsyms  fst.symboltable.readtexttostringfilename$^                                                             derefopts              $^      if tsyms  null$^        raise fstioerrorread failed r.formatfilename$^ $^  pyxvtsyms  fstsymboltablereadtextpyxt0 pyxvopts$^$^   pywrapfst.pyx0000$^      cdef fst.symboltable tsyms  fst.symboltable.readtexttostringfilename$^                                                             derefopts$^      if tsyms  null              $^        raise fstioerrorread failed r.formatfilename$^      return initsymboltabletsyms$^ $^  pyxt0  pyxvtsyms  null  0$^  if pyxt0 $^$^     pywrapfst.pyx0000$^                                                             derefopts$^      if tsyms  null$^        raise fstioerrorread failed r.formatfilename              $^      return initsymboltabletsyms$^  $^ $^    pyxt0  pyxgetmoduleglobalnamepyxnsfstioerror if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  pyxpyobjectgetattrstrpyxkpsreadfailedr pyxnsformat if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  null$^    if cythonunpackmethods  likelypymethodcheckpyxt0 $^      pyxt0  pymethodgetselfpyxt0$^      if likelypyxt0 $^        pyobject function  pymethodgetfunctionpyxt0$^        pyxincrefpyxt0$^        pyxincreffunction$^        pyxdecrefsetpyxt0 function$^      $^    $^    if pyxt0 $^      pyxt0  pyxpyobjectcalloneargpyxt0 pyxvfilename if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxgotrefpyxt0$^     else $^      if cythonfastpycall$^      if pyfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxvfilename$^        pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^       else$^      endif$^      if cythonfastpyccall$^      if pyxpyfastcfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxvfilename$^        pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^       else$^      endif$^      $^        pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxgotrefpyxt0$^        pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^        pyxincrefpyxvfilename$^        pyxgiverefpyxvfilename$^        pytuplesetitempyxt0 00 pyxvfilename$^        pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^      $^    $^    pyxdecrefpyxt0 pyxt0  0$^    pyxt0  null$^    if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^      pyxt0  pymethodgetselfpyxt0$^      if likelypyxt0 $^        pyobject function  pymethodgetfunctionpyxt0$^        pyxincrefpyxt0$^        pyxincreffunction$^        pyxdecrefsetpyxt0 function$^      $^    $^    if pyxt0 $^      pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxgotrefpyxt0$^     else $^      if cythonfastpycall$^      if pyfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxt0$^        pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^       else$^      endif$^      if cythonfastpyccall$^      if pyxpyfastcfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxt0$^        pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^       else$^      endif$^      $^        pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxgotrefpyxt0$^        pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^        pyxgiverefpyxt0$^        pytuplesetitempyxt0 00 pyxt0$^        pyxt0  0$^        pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^      $^    $^    pyxdecrefpyxt0 pyxt0  0$^    pyxraisepyxt0 0 0 0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxerr0 0000 pyxl0error$^$^     pywrapfst.pyx0000$^      cdef fst.symboltable tsyms  fst.symboltable.readtexttostringfilename$^                                                             derefopts$^      if tsyms  null              $^        raise fstioerrorread failed r.formatfilename$^      return initsymboltabletsyms$^ $^  $^$^   pywrapfst.pyx0000$^      if tsyms  null$^        raise fstioerrorread failed r.formatfilename$^      return initsymboltabletsyms              $^  $^    classmethod$^ $^  pyxxdecrefpyxr$^  pyxt0  pyobject pyxf0pywrapfstinitsymboltablepyxvtsyms if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   pywrapfst.pyx000$^  $^    classmethod$^    def readtextcls filename bool allownegativelabelsfalse              $^      $^      symboltable.readtextfilename$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.symboltable.readtext pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^  $^    classmethod$^    def readfstcls filename bool inputtable              $^      $^      symboltable.readfstfilename inputtable$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00symboltable0readfstpyobject pyxvcls pyobject pyxargs pyobject pyxkwds proto$^static char pyxdoc0pywrapfst00symboltable0readfst  n    symboltable.readfstfilename inputtablenn    reads symbol table from an fst file without loading the corresponding fst.nn    this class method creates a new symboltable by reading either the input orn    output symbol table from an fst file without loading the corresponding fst.nn    argsn      filename the string location of the input fst file.n      inputtable should the input table be read true or the output tablen          falsenn    returnsn      a new symboltable instance or none if none can be read.nn    raisesn      fstioerror read failed.nn    see also symboltable.read symboltable.readtext.n    $^static pyobject pyxpw0pywrapfst00symboltable0readfstpyobject pyxvcls pyobject pyxargs pyobject pyxkwds $^  pyobject pyxvfilename  0$^  bool pyxvinputtable$^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextreadfst wrapper 0$^  $^    static pyobject pyxpyargnames  pyxnsfilenamepyxnsinputtable0$^    pyobject values0  00$^    if unlikelypyxkwds $^      pyssizet kwargs$^      const pyssizet posargs  pytuplegetsizepyxargs$^      switch posargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 break$^        default goto pyxl0argtupleerror$^      $^      kwargs  pydictsizepyxkwds$^      switch posargs $^        case  0$^        if likelyvalues0  pydictgetitempyxkwds pyxnsfilename  0 kwargs$^        else goto pyxl0argtupleerror$^        cythonfallthrough$^        case  0$^        if likelyvalues0  pydictgetitempyxkwds pyxnsinputtable  0 kwargs$^        else $^          pyxraiseargtupleinvalidreadfst 0 0 0 0 pyxerr0 0000 pyxl0error$^        $^      $^      if unlikelykwargs  0 $^        if unlikelypyxparseoptionalkeywordspyxkwds pyxpyargnames 0 values posargs readfst  0 pyxerr0 0000 pyxl0error$^      $^     else if pytuplegetsizepyxargs  0 $^      goto pyxl0argtupleerror$^     else $^      values0  pytuplegetitempyxargs 0$^      values0  pytuplegetitempyxargs 0$^    $^    pyxvfilename  values0$^    pyxvinputtable  pyxpyobjectistruevalues0 if unlikelypyxvinputtable  bool0  pyerroccurred pyxerr0 0000 pyxl0error$^  $^  goto pyxl0argumentunpackingdone$^  pyxl0argtupleerror$^  pyxraiseargtupleinvalidreadfst 0 0 0 pytuplegetsizepyxargs pyxerr0 0000 pyxl0error$^  pyxl0error$^  pyxaddtracebackpywrapfst.symboltable.readfst pyxclineno pyxlineno pyxfilename$^  pyxrefnannyfinishcontext$^  return null$^  pyxl0argumentunpackingdone$^  pyxr  pyxpf0pywrapfst00symboltable0readfstpytypeobjectpyxvcls pyxvfilename pyxvinputtable$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00symboltable0readfstcythonunused pytypeobject pyxvcls pyobject pyxvfilename bool pyxvinputtable $^  fstsymboltable pyxvtsyms$^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  stdstring pyxt0$^  int pyxt0$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextreadfst 0$^$^   pywrapfst.pyx0000$^      see also symboltable.read symboltable.readtext.$^      $^      cdef fst.symboltable tsyms  fst.fstreadsymbolsfilename inputtable              $^      if tsyms  null$^        raise fstioerrorread failed r.formatfilename$^ $^  pyxt0  pyxconvertstringfrompystdinstringpyxvfilename if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^  pyxvtsyms  fstfstreadsymbolspyxt0 pyxvinputtable$^$^   pywrapfst.pyx0000$^      $^      cdef fst.symboltable tsyms  fst.fstreadsymbolsfilename inputtable$^      if tsyms  null              $^        raise fstioerrorread failed r.formatfilename$^      return initsymboltabletsyms$^ $^  pyxt0  pyxvtsyms  null  0$^  if pyxt0 $^$^     pywrapfst.pyx0000$^      cdef fst.symboltable tsyms  fst.fstreadsymbolsfilename inputtable$^      if tsyms  null$^        raise fstioerrorread failed r.formatfilename              $^      return initsymboltabletsyms$^  $^ $^    pyxt0  pyxgetmoduleglobalnamepyxnsfstioerror if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  pyxpyobjectgetattrstrpyxkpsreadfailedr pyxnsformat if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  null$^    if cythonunpackmethods  likelypymethodcheckpyxt0 $^      pyxt0  pymethodgetselfpyxt0$^      if likelypyxt0 $^        pyobject function  pymethodgetfunctionpyxt0$^        pyxincrefpyxt0$^        pyxincreffunction$^        pyxdecrefsetpyxt0 function$^      $^    $^    if pyxt0 $^      pyxt0  pyxpyobjectcalloneargpyxt0 pyxvfilename if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxgotrefpyxt0$^     else $^      if cythonfastpycall$^      if pyfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxvfilename$^        pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^       else$^      endif$^      if cythonfastpyccall$^      if pyxpyfastcfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxvfilename$^        pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^       else$^      endif$^      $^        pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxgotrefpyxt0$^        pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^        pyxincrefpyxvfilename$^        pyxgiverefpyxvfilename$^        pytuplesetitempyxt0 00 pyxvfilename$^        pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^      $^    $^    pyxdecrefpyxt0 pyxt0  0$^    pyxt0  null$^    if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^      pyxt0  pymethodgetselfpyxt0$^      if likelypyxt0 $^        pyobject function  pymethodgetfunctionpyxt0$^        pyxincrefpyxt0$^        pyxincreffunction$^        pyxdecrefsetpyxt0 function$^      $^    $^    if pyxt0 $^      pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxgotrefpyxt0$^     else $^      if cythonfastpycall$^      if pyfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxt0$^        pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^       else$^      endif$^      if cythonfastpyccall$^      if pyxpyfastcfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxt0$^        pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^       else$^      endif$^      $^        pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxgotrefpyxt0$^        pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^        pyxgiverefpyxt0$^        pytuplesetitempyxt0 00 pyxt0$^        pyxt0  0$^        pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^      $^    $^    pyxdecrefpyxt0 pyxt0  0$^    pyxraisepyxt0 0 0 0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxerr0 0000 pyxl0error$^$^     pywrapfst.pyx0000$^      $^      cdef fst.symboltable tsyms  fst.fstreadsymbolsfilename inputtable$^      if tsyms  null              $^        raise fstioerrorread failed r.formatfilename$^      return initsymboltabletsyms$^ $^  $^$^   pywrapfst.pyx0000$^      if tsyms  null$^        raise fstioerrorread failed r.formatfilename$^      return initsymboltabletsyms              $^  $^  $^ $^  pyxxdecrefpyxr$^  pyxt0  pyobject pyxf0pywrapfstinitsymboltablepyxvtsyms if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   pywrapfst.pyx0000$^  $^    classmethod$^    def readfstcls filename bool inputtable              $^      $^      symboltable.readfstfilename inputtable$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.symboltable.readfst pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ tree fragment0$^  def reducecythonself              $^      raise typeerrorself.smarttableself.table cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00symboltable00reducecythonpyobject pyxvself cythonunused pyobject unused proto$^static pyobject pyxpw0pywrapfst00symboltable00reducecythonpyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextreducecython wrapper 0$^  pyxr  pyxpf0pywrapfst00symboltable00reducecythonstruct pyxobj0pywrapfstsymboltable pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00symboltable00reducecythoncythonunused struct pyxobj0pywrapfstsymboltable pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextreducecython 0$^$^   tree fragment0$^  def reducecythonself$^      raise typeerrorself.smarttableself.table cannot be converted to a python object for pickling              $^  def setstatecythonself pyxstate$^      raise typeerrorself.smarttableself.table cannot be converted to a python object for pickling$^ $^  pyxt0  pyxpyobjectcallpyxbuiltintypeerror pyxtuple00 null if unlikelypyxt0 pyxerr0 0 pyxl0error$^  pyxgotrefpyxt0$^  pyxraisepyxt0 0 0 0$^  pyxdecrefpyxt0 pyxt0  0$^  pyxerr0 0 pyxl0error$^$^   tree fragment0$^  def reducecythonself              $^      raise typeerrorself.smarttableself.table cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.symboltable.reducecython pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ tree fragment0$^  def reducecythonself$^      raise typeerrorself.smarttableself.table cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate              $^      raise typeerrorself.smarttableself.table cannot be converted to a python object for pickling$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00symboltable00setstatecythonpyobject pyxvself pyobject pyxvpyxstate proto$^static pyobject pyxpw0pywrapfst00symboltable00setstatecythonpyobject pyxvself pyobject pyxvpyxstate $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextsetstatecython wrapper 0$^  pyxr  pyxpf0pywrapfst00symboltable00setstatecythonstruct pyxobj0pywrapfstsymboltable pyxvself pyobject pyxvpyxstate$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00symboltable00setstatecythoncythonunused struct pyxobj0pywrapfstsymboltable pyxvself cythonunused pyobject pyxvpyxstate $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextsetstatecython 0$^$^   tree fragment0$^      raise typeerrorself.smarttableself.table cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate$^      raise typeerrorself.smarttableself.table cannot be converted to a python object for pickling              $^ $^  pyxt0  pyxpyobjectcallpyxbuiltintypeerror pyxtuple00 null if unlikelypyxt0 pyxerr0 0 pyxl0error$^  pyxgotrefpyxt0$^  pyxraisepyxt0 0 0 0$^  pyxdecrefpyxt0 pyxt0  0$^  pyxerr0 0 pyxl0error$^$^   tree fragment0$^  def reducecythonself$^      raise typeerrorself.smarttableself.table cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate              $^      raise typeerrorself.smarttableself.table cannot be converted to a python object for pickling$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.symboltable.setstatecython pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^  $^  $^  cdef encodemappersymboltable initencodemappersymboltable              $^      fst.symboltable table sharedptrfst.encodemapperclass encoder$^    cdef encodemappersymboltable result  $^ $^$^static struct pyxobj0pywrapfstencodemappersymboltable pyxf0pywrapfstinitencodemappersymboltablefstsymboltable pyxvtable stdsharedptrfstscriptencodemapperclass  pyxvencoder $^  struct pyxobj0pywrapfstencodemappersymboltable pyxvresult  0$^  struct pyxobj0pywrapfstencodemappersymboltable pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextinitencodemappersymboltable 0$^$^   pywrapfst.pyx0000$^      fst.symboltable table sharedptrfst.encodemapperclass encoder$^    cdef encodemappersymboltable result  $^        encodemappersymboltable.newencodemappersymboltable              $^    result.table  table$^    result.encoder  encoder$^ $^  pyxt0  pyxtpnew0pywrapfstencodemappersymboltablepytypeobject pyxptype0pywrapfstencodemappersymboltable pyxemptytuple null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  if likelypyxtypetestpyxt0 pyxptype0pywrapfstencodemappersymboltable pyxerr0 0000 pyxl0error$^  pyxvresult  struct pyxobj0pywrapfstencodemappersymboltable pyxt0$^  pyxt0  0$^$^   pywrapfst.pyx0000$^    cdef encodemappersymboltable result  $^        encodemappersymboltable.newencodemappersymboltable$^    result.table  table              $^    result.encoder  encoder$^    return result$^ $^  if unlikelypyobject pyxvresult  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s table$^    pyxerr0 0000 pyxl0error$^  $^  pyxvresultpyxbase.table  pyxvtable$^$^   pywrapfst.pyx0000$^        encodemappersymboltable.newencodemappersymboltable$^    result.table  table$^    result.encoder  encoder              $^    return result$^  $^ $^  if unlikelypyobject pyxvresult  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s encoder$^    pyxerr0 0000 pyxl0error$^  $^  pyxvresultencoder  pyxvencoder$^$^   pywrapfst.pyx0000$^    result.table  table$^    result.encoder  encoder$^    return result              $^  $^  $^ $^  pyxxdecrefpyobject pyxr$^  pyxincrefpyobject pyxvresult$^  pyxr  pyxvresult$^  goto pyxl0$^$^   pywrapfst.pyx0000$^  $^  $^  cdef encodemappersymboltable initencodemappersymboltable              $^      fst.symboltable table sharedptrfst.encodemapperclass encoder$^    cdef encodemappersymboltable result  $^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.initencodemappersymboltable pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxl0$^  pyxxdecrefpyobject pyxvresult$^  pyxxgiverefpyobject pyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^  $^  $^  cdef fstsymboltable initfstsymboltablefst.symboltable table              $^                                            sharedptrfst.fstclass ifst$^    cdef fstsymboltable result  fstsymboltable.newfstsymboltable$^ $^$^static struct pyxobj0pywrapfstfstsymboltable pyxf0pywrapfstinitfstsymboltablefstsymboltable pyxvtable stdsharedptrfstscriptfstclass  pyxvifst $^  struct pyxobj0pywrapfstfstsymboltable pyxvresult  0$^  struct pyxobj0pywrapfstfstsymboltable pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextinitfstsymboltable 0$^$^   pywrapfst.pyx0000$^  cdef fstsymboltable initfstsymboltablefst.symboltable table$^                                            sharedptrfst.fstclass ifst$^    cdef fstsymboltable result  fstsymboltable.newfstsymboltable              $^    result.table  table$^    result.fst  ifst$^ $^  pyxt0  pyxtpnew0pywrapfstfstsymboltablepytypeobject pyxptype0pywrapfstfstsymboltable pyxemptytuple null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  if likelypyxtypetestpyxt0 pyxptype0pywrapfstfstsymboltable pyxerr0 0000 pyxl0error$^  pyxvresult  struct pyxobj0pywrapfstfstsymboltable pyxt0$^  pyxt0  0$^$^   pywrapfst.pyx0000$^                                            sharedptrfst.fstclass ifst$^    cdef fstsymboltable result  fstsymboltable.newfstsymboltable$^    result.table  table              $^    result.fst  ifst$^    return result$^ $^  if unlikelypyobject pyxvresult  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s table$^    pyxerr0 0000 pyxl0error$^  $^  pyxvresultpyxbase.table  pyxvtable$^$^   pywrapfst.pyx0000$^    cdef fstsymboltable result  fstsymboltable.newfstsymboltable$^    result.table  table$^    result.fst  ifst              $^    return result$^  $^ $^  if unlikelypyobject pyxvresult  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s fst$^    pyxerr0 0000 pyxl0error$^  $^  pyxvresultfst  pyxvifst$^$^   pywrapfst.pyx0000$^    result.table  table$^    result.fst  ifst$^    return result              $^  $^  $^ $^  pyxxdecrefpyobject pyxr$^  pyxincrefpyobject pyxvresult$^  pyxr  pyxvresult$^  goto pyxl0$^$^   pywrapfst.pyx0000$^  $^  $^  cdef fstsymboltable initfstsymboltablefst.symboltable table              $^                                            sharedptrfst.fstclass ifst$^    cdef fstsymboltable result  fstsymboltable.newfstsymboltable$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.initfstsymboltable pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxl0$^  pyxxdecrefpyobject pyxvresult$^  pyxxgiverefpyobject pyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^  $^  $^  cdef mutablefstsymboltable initmutablefstsymboltablefst.symboltable table              $^      sharedptrfst.mutablefstclass ifst$^    cdef mutablefstsymboltable result  $^ $^$^static struct pyxobj0pywrapfstmutablefstsymboltable pyxf0pywrapfstinitmutablefstsymboltablefstsymboltable pyxvtable stdsharedptrfstscriptmutablefstclass  pyxvifst $^  struct pyxobj0pywrapfstmutablefstsymboltable pyxvresult  0$^  struct pyxobj0pywrapfstmutablefstsymboltable pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextinitmutablefstsymboltable 0$^$^   pywrapfst.pyx0000$^      sharedptrfst.mutablefstclass ifst$^    cdef mutablefstsymboltable result  $^        mutablefstsymboltable.newmutablefstsymboltable              $^    result.table  table$^    result.mfst  ifst$^ $^  pyxt0  pyxtpnew0pywrapfstmutablefstsymboltablepytypeobject pyxptype0pywrapfstmutablefstsymboltable pyxemptytuple null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  if likelypyxtypetestpyxt0 pyxptype0pywrapfstmutablefstsymboltable pyxerr0 0000 pyxl0error$^  pyxvresult  struct pyxobj0pywrapfstmutablefstsymboltable pyxt0$^  pyxt0  0$^$^   pywrapfst.pyx0000$^    cdef mutablefstsymboltable result  $^        mutablefstsymboltable.newmutablefstsymboltable$^    result.table  table              $^    result.mfst  ifst$^    return result$^ $^  if unlikelypyobject pyxvresult  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s table$^    pyxerr0 0000 pyxl0error$^  $^  pyxvresultpyxbase.pyxbase.table  pyxvtable$^$^   pywrapfst.pyx0000$^        mutablefstsymboltable.newmutablefstsymboltable$^    result.table  table$^    result.mfst  ifst              $^    return result$^  $^ $^  if unlikelypyobject pyxvresult  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s mfst$^    pyxerr0 0000 pyxl0error$^  $^  pyxvresultmfst  pyxvifst$^$^   pywrapfst.pyx0000$^    result.table  table$^    result.mfst  ifst$^    return result              $^  $^  $^ $^  pyxxdecrefpyobject pyxr$^  pyxincrefpyobject pyxvresult$^  pyxr  pyxvresult$^  goto pyxl0$^$^   pywrapfst.pyx0000$^  $^  $^  cdef mutablefstsymboltable initmutablefstsymboltablefst.symboltable table              $^      sharedptrfst.mutablefstclass ifst$^    cdef mutablefstsymboltable result  $^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.initmutablefstsymboltable pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxl0$^  pyxxdecrefpyobject pyxvresult$^  pyxxgiverefpyobject pyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^  $^  $^  cdef symboltable initsymboltablefst.symboltable table              $^    cdef symboltable result  symboltable.newsymboltable$^    result.table  table$^ $^$^static struct pyxobj0pywrapfstsymboltable pyxf0pywrapfstinitsymboltablefstsymboltable pyxvtable $^  struct pyxobj0pywrapfstsymboltable pyxvresult  0$^  struct pyxobj0pywrapfstsymboltable pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextinitsymboltable 0$^$^   pywrapfst.pyx0000$^  $^  cdef symboltable initsymboltablefst.symboltable table$^    cdef symboltable result  symboltable.newsymboltable              $^    result.table  table$^    return result$^ $^  pyxt0  pyxtpnew0pywrapfstsymboltablepytypeobject pyxptype0pywrapfstsymboltable pyxemptytuple null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  if likelypyxtypetestpyxt0 pyxptype0pywrapfstsymboltable pyxerr0 0000 pyxl0error$^  pyxvresult  struct pyxobj0pywrapfstsymboltable pyxt0$^  pyxt0  0$^$^   pywrapfst.pyx0000$^  cdef symboltable initsymboltablefst.symboltable table$^    cdef symboltable result  symboltable.newsymboltable$^    result.table  table              $^    return result$^  $^ $^  if unlikelypyobject pyxvresult  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s table$^    pyxerr0 0000 pyxl0error$^  $^  pyxvresultpyxbase.pyxbase.table  pyxvtable$^$^   pywrapfst.pyx0000$^    cdef symboltable result  symboltable.newsymboltable$^    result.table  table$^    return result              $^  $^  $^ $^  pyxxdecrefpyobject pyxr$^  pyxincrefpyobject pyxvresult$^  pyxr  pyxvresult$^  goto pyxl0$^$^   pywrapfst.pyx0000$^  $^  $^  cdef symboltable initsymboltablefst.symboltable table              $^    cdef symboltable result  symboltable.newsymboltable$^    result.table  table$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.initsymboltable pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxl0$^  pyxxdecrefpyobject pyxvresult$^  pyxxgiverefpyobject pyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^  $^  $^  cpdef symboltable compactsymboltablesymboltable syms              $^    $^    compactsymboltablesyms$^ $^$^static pyobject pyxpw0pywrapfst0compactsymboltablepyobject pyxself pyobject pyxvsyms proto$^static struct pyxobj0pywrapfstsymboltable pyxf0pywrapfstcompactsymboltablestruct pyxobj0pywrapfstsymboltable pyxvsyms cythonunused int pyxskipdispatch $^  struct pyxobj0pywrapfstsymboltable pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextcompactsymboltable 0$^$^   pywrapfst.pyx0000$^      a new compacted symboltable.$^    $^    return initsymboltablefst.compactsymboltablederefsyms.table              $^  $^  $^ $^  pyxxdecrefpyobject pyxr$^  if unlikelypyobject pyxvsyms  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s table$^    pyxerr0 0000 pyxl0error$^  $^  pyxt0  pyobject pyxf0pywrapfstinitsymboltablefstcompactsymboltablepyxvsymstable if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  struct pyxobj0pywrapfstsymboltable pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   pywrapfst.pyx0000$^  $^  $^  cpdef symboltable compactsymboltablesymboltable syms              $^    $^    compactsymboltablesyms$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.compactsymboltable pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxl0$^  pyxxgiverefpyobject pyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst0compactsymboltablepyobject pyxself pyobject pyxvsyms proto$^static char pyxdoc0pywrapfst0compactsymboltable  n  compactsymboltablesymsnn  constructively relabels a symboltable to make it a contiguous mapping.nn  argsn    syms input symboltable.nn  returnsn    a new compacted symboltable.n  $^static pyobject pyxpw0pywrapfst0compactsymboltablepyobject pyxself pyobject pyxvsyms $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextcompactsymboltable wrapper 0$^  if unlikelypyxargtypetestpyobject pyxvsyms pyxptype0pywrapfstsymboltable 0 syms 0 pyxerr0 0000 pyxl0error$^  pyxr  pyxpf0pywrapfst0compactsymboltablepyxself struct pyxobj0pywrapfstsymboltable pyxvsyms$^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxr  null$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst0compactsymboltablecythonunused pyobject pyxself struct pyxobj0pywrapfstsymboltable pyxvsyms $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextcompactsymboltable 0$^  pyxxdecrefpyxr$^  pyxt0  pyobject pyxf0pywrapfstcompactsymboltablepyxvsyms 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.compactsymboltable pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^  $^  $^  cpdef symboltable mergesymboltablesymboltable lhs symboltable rhs              $^    $^    mergesymboltablelhs rhs$^ $^$^static pyobject pyxpw0pywrapfst00mergesymboltablepyobject pyxself pyobject pyxargs pyobject pyxkwds proto$^static struct pyxobj0pywrapfstsymboltable pyxf0pywrapfstmergesymboltablestruct pyxobj0pywrapfstsymboltable pyxvlhs struct pyxobj0pywrapfstsymboltable pyxvrhs cythonunused int pyxskipdispatch $^  struct pyxobj0pywrapfstsymboltable pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextmergesymboltable 0$^$^   pywrapfst.pyx0000$^    see also relabelsymbols.$^    $^    return initsymboltablefst.mergesymboltabledereflhs.table              $^                                                  derefrhs.table null$^  $^ $^  pyxxdecrefpyobject pyxr$^  if unlikelypyobject pyxvlhs  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s table$^    pyxerr0 0000 pyxl0error$^  $^$^   pywrapfst.pyx0000$^    $^    return initsymboltablefst.mergesymboltabledereflhs.table$^                                                  derefrhs.table null              $^  $^  $^ $^  if unlikelypyobject pyxvrhs  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s table$^    pyxerr0 0000 pyxl0error$^  $^$^   pywrapfst.pyx0000$^    see also relabelsymbols.$^    $^    return initsymboltablefst.mergesymboltabledereflhs.table              $^                                                  derefrhs.table null$^  $^ $^  pyxt0  pyobject pyxf0pywrapfstinitsymboltablefstmergesymboltablepyxvlhstable pyxvrhstable null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  struct pyxobj0pywrapfstsymboltable pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   pywrapfst.pyx0000$^  $^  $^  cpdef symboltable mergesymboltablesymboltable lhs symboltable rhs              $^    $^    mergesymboltablelhs rhs$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.mergesymboltable pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxl0$^  pyxxgiverefpyobject pyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst00mergesymboltablepyobject pyxself pyobject pyxargs pyobject pyxkwds proto$^static char pyxdoc0pywrapfst00mergesymboltable  n  mergesymboltablelhs rhsnn  merges all symbols from the left table into the right.nn  this function creates a new symboltable which is the merger of the two inputn  symbol tables. symbols in the righthand table that conflict with those in then  lefthand table will be assigned values from the lefthand table. thus then  returned table will never modify symbol assignments from the lefthand siden  but may do so on the right.nn  if the lefthand table is associated with an fst it may be necessary ton  relabel it using the output table.nn  argsn    lhs lefthand side symboltable.n    rhs lefthand side symboltable.nn  returnsn    a new merged symboltable.nn  see also relabelsymbols.n  $^static pyobject pyxpw0pywrapfst00mergesymboltablepyobject pyxself pyobject pyxargs pyobject pyxkwds $^  struct pyxobj0pywrapfstsymboltable pyxvlhs  0$^  struct pyxobj0pywrapfstsymboltable pyxvrhs  0$^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextmergesymboltable wrapper 0$^  $^    static pyobject pyxpyargnames  pyxnslhspyxnsrhs0$^    pyobject values0  00$^    if unlikelypyxkwds $^      pyssizet kwargs$^      const pyssizet posargs  pytuplegetsizepyxargs$^      switch posargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 break$^        default goto pyxl0argtupleerror$^      $^      kwargs  pydictsizepyxkwds$^      switch posargs $^        case  0$^        if likelyvalues0  pydictgetitempyxkwds pyxnslhs  0 kwargs$^        else goto pyxl0argtupleerror$^        cythonfallthrough$^        case  0$^        if likelyvalues0  pydictgetitempyxkwds pyxnsrhs  0 kwargs$^        else $^          pyxraiseargtupleinvalidmergesymboltable 0 0 0 0 pyxerr0 0000 pyxl0error$^        $^      $^      if unlikelykwargs  0 $^        if unlikelypyxparseoptionalkeywordspyxkwds pyxpyargnames 0 values posargs mergesymboltable  0 pyxerr0 0000 pyxl0error$^      $^     else if pytuplegetsizepyxargs  0 $^      goto pyxl0argtupleerror$^     else $^      values0  pytuplegetitempyxargs 0$^      values0  pytuplegetitempyxargs 0$^    $^    pyxvlhs  struct pyxobj0pywrapfstsymboltable values0$^    pyxvrhs  struct pyxobj0pywrapfstsymboltable values0$^  $^  goto pyxl0argumentunpackingdone$^  pyxl0argtupleerror$^  pyxraiseargtupleinvalidmergesymboltable 0 0 0 pytuplegetsizepyxargs pyxerr0 0000 pyxl0error$^  pyxl0error$^  pyxaddtracebackpywrapfst.mergesymboltable pyxclineno pyxlineno pyxfilename$^  pyxrefnannyfinishcontext$^  return null$^  pyxl0argumentunpackingdone$^  if unlikelypyxargtypetestpyobject pyxvlhs pyxptype0pywrapfstsymboltable 0 lhs 0 pyxerr0 0000 pyxl0error$^  if unlikelypyxargtypetestpyobject pyxvrhs pyxptype0pywrapfstsymboltable 0 rhs 0 pyxerr0 0000 pyxl0error$^  pyxr  pyxpf0pywrapfst00mergesymboltablepyxself pyxvlhs pyxvrhs$^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxr  null$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00mergesymboltablecythonunused pyobject pyxself struct pyxobj0pywrapfstsymboltable pyxvlhs struct pyxobj0pywrapfstsymboltable pyxvrhs $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextmergesymboltable 0$^  pyxxdecrefpyxr$^  pyxt0  pyobject pyxf0pywrapfstmergesymboltablepyxvlhs pyxvrhs 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.mergesymboltable pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^    $^  $^    def reprself              $^      return symboltableiterator at 0xx.formatidself$^  $^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00symboltableiterator0reprpyobject pyxvself proto$^static pyobject pyxpw0pywrapfst00symboltableiterator0reprpyobject pyxvself $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextrepr wrapper 0$^  pyxr  pyxpf0pywrapfst00symboltableiteratorreprstruct pyxobj0pywrapfstsymboltableiterator pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00symboltableiteratorreprstruct pyxobj0pywrapfstsymboltableiterator pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextrepr 0$^$^   pywrapfst.pyx0000$^  $^    def reprself$^      return symboltableiterator at 0xx.formatidself              $^  $^    def initself symboltable syms$^ $^  pyxxdecrefpyxr$^  pyxt0  pyxpyobjectgetattrstrpyxkpssymboltableiteratorat0xx pyxnsformat if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxt0  pytuplenew0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxincrefpyobject pyxvself$^  pyxgiverefpyobject pyxvself$^  pytuplesetitempyxt0 0 pyobject pyxvself$^  pyxt0  pyxpyobjectcallpyxbuiltinid pyxt0 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxdecrefpyxt0 pyxt0  0$^  pyxt0  null$^  if cythonunpackmethods  likelypymethodcheckpyxt0 $^    pyxt0  pymethodgetselfpyxt0$^    if likelypyxt0 $^      pyobject function  pymethodgetfunctionpyxt0$^      pyxincrefpyxt0$^      pyxincreffunction$^      pyxdecrefsetpyxt0 function$^    $^  $^  if pyxt0 $^    pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxdecrefpyxt0 pyxt0  0$^    pyxgotrefpyxt0$^   else $^    if cythonfastpycall$^    if pyfunctioncheckpyxt0 $^      pyobject pyxtemp0  pyxt0 pyxt0$^      pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxxdecrefpyxt0 pyxt0  0$^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^     else$^    endif$^    if cythonfastpyccall$^    if pyxpyfastcfunctioncheckpyxt0 $^      pyobject pyxtemp0  pyxt0 pyxt0$^      pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxxdecrefpyxt0 pyxt0  0$^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^     else$^    endif$^    $^      pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxgotrefpyxt0$^      pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^      pyxgiverefpyxt0$^      pytuplesetitempyxt0 00 pyxt0$^      pyxt0  0$^      pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^    $^  $^  pyxdecrefpyxt0 pyxt0  0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   pywrapfst.pyx0000$^    $^  $^    def reprself              $^      return symboltableiterator at 0xx.formatidself$^  $^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.symboltableiterator.repr pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return symboltableiterator at 0xx.formatidself$^  $^    def initself symboltable syms              $^      self.siter.resetnew fst.symboltableiteratorderefsyms.table$^  $^ $^$^ python wrapper $^static int pyxpw0pywrapfst00symboltableiterator0initpyobject pyxvself pyobject pyxargs pyobject pyxkwds proto$^static int pyxpw0pywrapfst00symboltableiterator0initpyobject pyxvself pyobject pyxargs pyobject pyxkwds $^  struct pyxobj0pywrapfstsymboltable pyxvsyms  0$^  int pyxr$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextinit wrapper 0$^  $^    static pyobject pyxpyargnames  pyxnssyms0$^    pyobject values0  0$^    if unlikelypyxkwds $^      pyssizet kwargs$^      const pyssizet posargs  pytuplegetsizepyxargs$^      switch posargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 break$^        default goto pyxl0argtupleerror$^      $^      kwargs  pydictsizepyxkwds$^      switch posargs $^        case  0$^        if likelyvalues0  pydictgetitempyxkwds pyxnssyms  0 kwargs$^        else goto pyxl0argtupleerror$^      $^      if unlikelykwargs  0 $^        if unlikelypyxparseoptionalkeywordspyxkwds pyxpyargnames 0 values posargs init  0 pyxerr0 0000 pyxl0error$^      $^     else if pytuplegetsizepyxargs  0 $^      goto pyxl0argtupleerror$^     else $^      values0  pytuplegetitempyxargs 0$^    $^    pyxvsyms  struct pyxobj0pywrapfstsymboltable values0$^  $^  goto pyxl0argumentunpackingdone$^  pyxl0argtupleerror$^  pyxraiseargtupleinvalidinit 0 0 0 pytuplegetsizepyxargs pyxerr0 0000 pyxl0error$^  pyxl0error$^  pyxaddtracebackpywrapfst.symboltableiterator.init pyxclineno pyxlineno pyxfilename$^  pyxrefnannyfinishcontext$^  return 0$^  pyxl0argumentunpackingdone$^  if unlikelypyxargtypetestpyobject pyxvsyms pyxptype0pywrapfstsymboltable 0 syms 0 pyxerr0 0000 pyxl0error$^  pyxr  pyxpf0pywrapfst00symboltableiterator0initstruct pyxobj0pywrapfstsymboltableiterator pyxvself pyxvsyms$^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxr  0$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static int pyxpf0pywrapfst00symboltableiterator0initstruct pyxobj0pywrapfstsymboltableiterator pyxvself struct pyxobj0pywrapfstsymboltable pyxvsyms $^  int pyxr$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextinit 0$^$^   pywrapfst.pyx0000$^  $^    def initself symboltable syms$^      self.siter.resetnew fst.symboltableiteratorderefsyms.table              $^  $^     this just registers this class as a possible iterator.$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s siter$^    pyxerr0 0000 pyxl0error$^  $^  if unlikelypyobject pyxvsyms  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s table$^    pyxerr0 0000 pyxl0error$^  $^  pyxvselfsiter.resetnew fstsymboltableiteratorpyxvsymstable$^$^   pywrapfst.pyx0000$^      return symboltableiterator at 0xx.formatidself$^  $^    def initself symboltable syms              $^      self.siter.resetnew fst.symboltableiteratorderefsyms.table$^  $^ $^$^   function exit code $^  pyxr  0$^  goto pyxl0$^  pyxl0error$^  pyxaddtracebackpywrapfst.symboltableiterator.init pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^  $^     this just registers this class as a possible iterator.$^    def iterself              $^      return self$^  $^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00symboltableiterator0iterpyobject pyxvself proto$^static pyobject pyxpw0pywrapfst00symboltableiterator0iterpyobject pyxvself $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextiter wrapper 0$^  pyxr  pyxpf0pywrapfst00symboltableiterator0iterstruct pyxobj0pywrapfstsymboltableiterator pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00symboltableiterator0iterstruct pyxobj0pywrapfstsymboltableiterator pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextiter 0$^$^   pywrapfst.pyx0000$^     this just registers this class as a possible iterator.$^    def iterself$^      return self              $^  $^     magic method used to get a pythonic api out of the c api.$^ $^  pyxxdecrefpyxr$^  pyxincrefpyobject pyxvself$^  pyxr  pyobject pyxvself$^  goto pyxl0$^$^   pywrapfst.pyx0000$^  $^     this just registers this class as a possible iterator.$^    def iterself              $^      return self$^  $^ $^$^   function exit code $^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^  $^     magic method used to get a pythonic api out of the c api.$^    def nextself              $^      if self.done$^        raise stopiteration$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00symboltableiterator0nextpyobject pyxvself proto$^static pyobject pyxpw0pywrapfst00symboltableiterator0nextpyobject pyxvself $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextnext wrapper 0$^  pyxr  pyxpf0pywrapfst00symboltableiterator0nextstruct pyxobj0pywrapfstsymboltableiterator pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00symboltableiterator0nextstruct pyxobj0pywrapfstsymboltableiterator pyxvself $^  pyxt00basictypesint00 pyxvvalue$^  stdstring pyxvsymbol$^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  int pyxt0$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextnext 0$^$^   pywrapfst.pyx0000$^     magic method used to get a pythonic api out of the c api.$^    def nextself$^      if self.done              $^        raise stopiteration$^      cdef int00 value  self.value$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s done$^    pyxerr0 0000 pyxl0error$^  $^  pyxt0  struct pyxvtabstruct0pywrapfstsymboltableiterator pyxvselfpyxvtabdonepyxvself 0  0$^  if pyxt0 $^$^     pywrapfst.pyx0000$^    def nextself$^      if self.done$^        raise stopiteration              $^      cdef int00 value  self.value$^      cdef string symbol  self.symbol$^ $^    pyxraisepyxbuiltinstopiteration 0 0 0$^    pyxerr0 0000 pyxl0error$^$^     pywrapfst.pyx0000$^     magic method used to get a pythonic api out of the c api.$^    def nextself$^      if self.done              $^        raise stopiteration$^      cdef int00 value  self.value$^ $^  $^$^   pywrapfst.pyx0000$^      if self.done$^        raise stopiteration$^      cdef int00 value  self.value              $^      cdef string symbol  self.symbol$^      self.next$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s value$^    pyxerr0 0000 pyxl0error$^  $^  pyxvvalue  struct pyxvtabstruct0pywrapfstsymboltableiterator pyxvselfpyxvtabvaluepyxvself 0$^$^   pywrapfst.pyx0000$^        raise stopiteration$^      cdef int00 value  self.value$^      cdef string symbol  self.symbol              $^      self.next$^      return value symbol$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s symbol$^    pyxerr0 0000 pyxl0error$^  $^  pyxvsymbol  struct pyxvtabstruct0pywrapfstsymboltableiterator pyxvselfpyxvtabsymbolpyxvself 0$^$^   pywrapfst.pyx0000$^      cdef int00 value  self.value$^      cdef string symbol  self.symbol$^      self.next              $^      return value symbol$^  $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s next$^    pyxerr0 0000 pyxl0error$^  $^  struct pyxvtabstruct0pywrapfstsymboltableiterator pyxvselfpyxvtabnextpyxvself 0$^$^   pywrapfst.pyx0000$^      cdef string symbol  self.symbol$^      self.next$^      return value symbol              $^  $^    cpdef bool doneself$^ $^  pyxxdecrefpyxr$^  pyxt0  pyxpyintfromint00tpyxvvalue if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxt0  pyxconvertpybytesstringtopystdinstringpyxvsymbol if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxt0  pytuplenew0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxgiverefpyxt0$^  pytuplesetitempyxt0 0 pyxt0$^  pyxgiverefpyxt0$^  pytuplesetitempyxt0 0 pyxt0$^  pyxt0  0$^  pyxt0  0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   pywrapfst.pyx0000$^  $^     magic method used to get a pythonic api out of the c api.$^    def nextself              $^      if self.done$^        raise stopiteration$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.symboltableiterator.next pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return value symbol$^  $^    cpdef bool doneself              $^      $^      doneself$^ $^$^static pyobject pyxpw0pywrapfst00symboltableiterator0donepyobject pyxvself cythonunused pyobject unused proto$^static bool pyxf0pywrapfst00symboltableiteratordonestruct pyxobj0pywrapfstsymboltableiterator pyxvself int pyxskipdispatch $^  bool pyxr$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  bool pyxt0$^  pyxrefnannysetupcontextdone 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnsdone if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst00symboltableiterator0done $^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxdecrefpyxt0 pyxt0  0$^       else $^        pyxt0  pyxpyobjectcallnoargpyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      $^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxt0  pyxpyobjectistruepyxt0 if unlikelypyxt0  bool0  pyerroccurred pyxerr0 0000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxr  pyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx0000$^        true if the iterator is exhausted false otherwise.$^      $^      return self.siter.get.done              $^  $^    cpdef void nextself$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s siter$^    pyxerr0 0000 pyxl0error$^  $^  pyxr  pyxvselfsiter.getdone$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      return value symbol$^  $^    cpdef bool doneself              $^      $^      doneself$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxwriteunraisablepywrapfst.symboltableiterator.done pyxclineno pyxlineno pyxfilename 0 0$^  pyxr  0$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst00symboltableiterator0donepyobject pyxvself cythonunused pyobject unused proto$^static char pyxdoc0pywrapfst00symboltableiterator0done  n    doneselfnn    indicates whether the iterator is exhausted or not.nn    returnsn      true if the iterator is exhausted false otherwise.n    $^static pyobject pyxpw0pywrapfst00symboltableiterator0donepyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextdone wrapper 0$^  pyxr  pyxpf0pywrapfst00symboltableiterator0donestruct pyxobj0pywrapfstsymboltableiterator pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00symboltableiterator0donestruct pyxobj0pywrapfstsymboltableiterator pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextdone 0$^  pyxxdecrefpyxr$^  pyxt0  pyxpyboolfromlongpyxf0pywrapfst00symboltableiteratordonepyxvself 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.symboltableiterator.done pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return self.siter.get.done$^  $^    cpdef void nextself              $^      $^      nextself$^ $^$^static pyobject pyxpw0pywrapfst00symboltableiterator00nextpyobject pyxvself cythonunused pyobject unused proto$^static void pyxf0pywrapfst00symboltableiteratornextstruct pyxobj0pywrapfstsymboltableiterator pyxvself int pyxskipdispatch $^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextnext 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnsnext if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst00symboltableiterator00next $^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxdecrefpyxt0 pyxt0  0$^       else $^        pyxt0  pyxpyobjectcallnoargpyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      $^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx0000$^      advances the iterator.$^      $^      self.siter.get.next              $^  $^    cpdef void resetself$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s siter$^    pyxerr0 0000 pyxl0error$^  $^  pyxvselfsiter.getnext$^$^   pywrapfst.pyx0000$^      return self.siter.get.done$^  $^    cpdef void nextself              $^      $^      nextself$^ $^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxwriteunraisablepywrapfst.symboltableiterator.next pyxclineno pyxlineno pyxfilename 0 0$^  pyxl0$^  pyxrefnannyfinishcontext$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst00symboltableiterator00nextpyobject pyxvself cythonunused pyobject unused proto$^static char pyxdoc0pywrapfst00symboltableiterator00next  n    nextselfnn    advances the iterator.n    $^static pyobject pyxpw0pywrapfst00symboltableiterator00nextpyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextnext wrapper 0$^  pyxr  pyxpf0pywrapfst00symboltableiterator00nextstruct pyxobj0pywrapfstsymboltableiterator pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00symboltableiterator00nextstruct pyxobj0pywrapfstsymboltableiterator pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextnext 0$^  pyxxdecrefpyxr$^  pyxt0  pyxvoidtononepyxf0pywrapfst00symboltableiteratornextpyxvself 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.symboltableiterator.next pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      self.siter.get.next$^  $^    cpdef void resetself              $^      $^      resetself$^ $^$^static pyobject pyxpw0pywrapfst00symboltableiterator00resetpyobject pyxvself cythonunused pyobject unused proto$^static void pyxf0pywrapfst00symboltableiteratorresetstruct pyxobj0pywrapfstsymboltableiterator pyxvself int pyxskipdispatch $^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextreset 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnsreset if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst00symboltableiterator00reset $^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxdecrefpyxt0 pyxt0  0$^       else $^        pyxt0  pyxpyobjectcallnoargpyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      $^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx0000$^      resets the iterator to the initial position.$^      $^      self.siter.get.reset              $^  $^    cpdef string symbolself$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s siter$^    pyxerr0 0000 pyxl0error$^  $^  pyxvselfsiter.getreset$^$^   pywrapfst.pyx0000$^      self.siter.get.next$^  $^    cpdef void resetself              $^      $^      resetself$^ $^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxwriteunraisablepywrapfst.symboltableiterator.reset pyxclineno pyxlineno pyxfilename 0 0$^  pyxl0$^  pyxrefnannyfinishcontext$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst00symboltableiterator00resetpyobject pyxvself cythonunused pyobject unused proto$^static char pyxdoc0pywrapfst00symboltableiterator00reset  n    resetselfnn    resets the iterator to the initial position.n    $^static pyobject pyxpw0pywrapfst00symboltableiterator00resetpyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextreset wrapper 0$^  pyxr  pyxpf0pywrapfst00symboltableiterator00resetstruct pyxobj0pywrapfstsymboltableiterator pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00symboltableiterator00resetstruct pyxobj0pywrapfstsymboltableiterator pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextreset 0$^  pyxxdecrefpyxr$^  pyxt0  pyxvoidtononepyxf0pywrapfst00symboltableiteratorresetpyxvself 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.symboltableiterator.reset pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      self.siter.get.reset$^  $^    cpdef string symbolself              $^      $^      symbolself$^ $^$^static pyobject pyxpw0pywrapfst00symboltableiterator00symbolpyobject pyxvself cythonunused pyobject unused proto$^static stdstring pyxf0pywrapfst00symboltableiteratorsymbolstruct pyxobj0pywrapfstsymboltableiterator pyxvself int pyxskipdispatch $^  stdstring pyxr$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  stdstring pyxt0$^  pyxrefnannysetupcontextsymbol 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnssymbol if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst00symboltableiterator00symbol $^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxdecrefpyxt0 pyxt0  0$^       else $^        pyxt0  pyxpyobjectcallnoargpyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      $^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxt0  pyxconvertstringfrompystdinstringpyxt0 if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxr  pyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx0000$^        a symbol string.$^      $^      return self.siter.get.symbol              $^  $^    cpdef int00 valueself$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s siter$^    pyxerr0 0000 pyxl0error$^  $^  pyxr  pyxvselfsiter.getsymbol$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      self.siter.get.reset$^  $^    cpdef string symbolself              $^      $^      symbolself$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxwriteunraisablepywrapfst.symboltableiterator.symbol pyxclineno pyxlineno pyxfilename 0 0$^  pyxpretendtoinitializepyxr$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst00symboltableiterator00symbolpyobject pyxvself cythonunused pyobject unused proto$^static char pyxdoc0pywrapfst00symboltableiterator00symbol  n    symbolselfnn    returns the current symbol string.nn    this method returns the current symbol string at this point in the table.nn    returnsn      a symbol string.n    $^static pyobject pyxpw0pywrapfst00symboltableiterator00symbolpyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextsymbol wrapper 0$^  pyxr  pyxpf0pywrapfst00symboltableiterator00symbolstruct pyxobj0pywrapfstsymboltableiterator pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00symboltableiterator00symbolstruct pyxobj0pywrapfstsymboltableiterator pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextsymbol 0$^  pyxxdecrefpyxr$^  pyxt0  pyxconvertpybytesstringtopystdinstringpyxf0pywrapfst00symboltableiteratorsymbolpyxvself 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.symboltableiterator.symbol pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return self.siter.get.symbol$^  $^    cpdef int00 valueself              $^      $^      valueself$^ $^$^static pyobject pyxpw0pywrapfst00symboltableiterator00valuepyobject pyxvself cythonunused pyobject unused proto$^static pyxt00basictypesint00 pyxf0pywrapfst00symboltableiteratorvaluestruct pyxobj0pywrapfstsymboltableiterator pyxvself int pyxskipdispatch $^  pyxt00basictypesint00 pyxr$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxt00basictypesint00 pyxt0$^  pyxrefnannysetupcontextvalue 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnsvalue if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst00symboltableiterator00value $^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxdecrefpyxt0 pyxt0  0$^       else $^        pyxt0  pyxpyobjectcallnoargpyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      $^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxt0  pyxpyintasint00tpyxt0 if unlikelypyxt0  int00t0  pyerroccurred pyxerr0 0000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxr  pyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx0000$^        an integer index.$^      $^      return self.siter.get.value              $^  $^  $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s siter$^    pyxerr0 0000 pyxl0error$^  $^  pyxr  pyxvselfsiter.getvalue$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      return self.siter.get.symbol$^  $^    cpdef int00 valueself              $^      $^      valueself$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxwriteunraisablepywrapfst.symboltableiterator.value pyxclineno pyxlineno pyxfilename 0 0$^  pyxr  0$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst00symboltableiterator00valuepyobject pyxvself cythonunused pyobject unused proto$^static char pyxdoc0pywrapfst00symboltableiterator00value  n    valueselfnn    returns the current integer index of the symbol.nn    returnsn      an integer index.n    $^static pyobject pyxpw0pywrapfst00symboltableiterator00valuepyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextvalue wrapper 0$^  pyxr  pyxpf0pywrapfst00symboltableiterator00valuestruct pyxobj0pywrapfstsymboltableiterator pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00symboltableiterator00valuestruct pyxobj0pywrapfstsymboltableiterator pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextvalue 0$^  pyxxdecrefpyxr$^  pyxt0  pyxpyintfromint00tpyxf0pywrapfst00symboltableiteratorvaluepyxvself 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.symboltableiterator.value pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ tree fragment0$^  def reducecythonself              $^      raise typeerrorself.siterself.table cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00symboltableiterator00reducecythonpyobject pyxvself cythonunused pyobject unused proto$^static pyobject pyxpw0pywrapfst00symboltableiterator00reducecythonpyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextreducecython wrapper 0$^  pyxr  pyxpf0pywrapfst00symboltableiterator00reducecythonstruct pyxobj0pywrapfstsymboltableiterator pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00symboltableiterator00reducecythoncythonunused struct pyxobj0pywrapfstsymboltableiterator pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextreducecython 0$^$^   tree fragment0$^  def reducecythonself$^      raise typeerrorself.siterself.table cannot be converted to a python object for pickling              $^  def setstatecythonself pyxstate$^      raise typeerrorself.siterself.table cannot be converted to a python object for pickling$^ $^  pyxt0  pyxpyobjectcallpyxbuiltintypeerror pyxtuple00 null if unlikelypyxt0 pyxerr0 0 pyxl0error$^  pyxgotrefpyxt0$^  pyxraisepyxt0 0 0 0$^  pyxdecrefpyxt0 pyxt0  0$^  pyxerr0 0 pyxl0error$^$^   tree fragment0$^  def reducecythonself              $^      raise typeerrorself.siterself.table cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.symboltableiterator.reducecython pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ tree fragment0$^  def reducecythonself$^      raise typeerrorself.siterself.table cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate              $^      raise typeerrorself.siterself.table cannot be converted to a python object for pickling$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00symboltableiterator00setstatecythonpyobject pyxvself pyobject pyxvpyxstate proto$^static pyobject pyxpw0pywrapfst00symboltableiterator00setstatecythonpyobject pyxvself pyobject pyxvpyxstate $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextsetstatecython wrapper 0$^  pyxr  pyxpf0pywrapfst00symboltableiterator00setstatecythonstruct pyxobj0pywrapfstsymboltableiterator pyxvself pyobject pyxvpyxstate$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00symboltableiterator00setstatecythoncythonunused struct pyxobj0pywrapfstsymboltableiterator pyxvself cythonunused pyobject pyxvpyxstate $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextsetstatecython 0$^$^   tree fragment0$^      raise typeerrorself.siterself.table cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate$^      raise typeerrorself.siterself.table cannot be converted to a python object for pickling              $^ $^  pyxt0  pyxpyobjectcallpyxbuiltintypeerror pyxtuple00 null if unlikelypyxt0 pyxerr0 0 pyxl0error$^  pyxgotrefpyxt0$^  pyxraisepyxt0 0 0 0$^  pyxdecrefpyxt0 pyxt0  0$^  pyxerr0 0 pyxl0error$^$^   tree fragment0$^  def reducecythonself$^      raise typeerrorself.siterself.table cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate              $^      raise typeerrorself.siterself.table cannot be converted to a python object for pickling$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.symboltableiterator.setstatecython pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^    $^  $^    def reprself              $^      return encodemapper at 0xx.formatidself$^  $^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00encodemapper0reprpyobject pyxvself proto$^static pyobject pyxpw0pywrapfst00encodemapper0reprpyobject pyxvself $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextrepr wrapper 0$^  pyxr  pyxpf0pywrapfst00encodemapperreprstruct pyxobj0pywrapfstencodemapper pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00encodemapperreprstruct pyxobj0pywrapfstencodemapper pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextrepr 0$^$^   pywrapfst.pyx0000$^  $^    def reprself$^      return encodemapper at 0xx.formatidself              $^  $^    def initself$^ $^  pyxxdecrefpyxr$^  pyxt0  pyxpyobjectgetattrstrpyxkpsencodemapperat0xx pyxnsformat if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxt0  pytuplenew0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxincrefpyobject pyxvself$^  pyxgiverefpyobject pyxvself$^  pytuplesetitempyxt0 0 pyobject pyxvself$^  pyxt0  pyxpyobjectcallpyxbuiltinid pyxt0 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxdecrefpyxt0 pyxt0  0$^  pyxt0  null$^  if cythonunpackmethods  likelypymethodcheckpyxt0 $^    pyxt0  pymethodgetselfpyxt0$^    if likelypyxt0 $^      pyobject function  pymethodgetfunctionpyxt0$^      pyxincrefpyxt0$^      pyxincreffunction$^      pyxdecrefsetpyxt0 function$^    $^  $^  if pyxt0 $^    pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxdecrefpyxt0 pyxt0  0$^    pyxgotrefpyxt0$^   else $^    if cythonfastpycall$^    if pyfunctioncheckpyxt0 $^      pyobject pyxtemp0  pyxt0 pyxt0$^      pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxxdecrefpyxt0 pyxt0  0$^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^     else$^    endif$^    if cythonfastpyccall$^    if pyxpyfastcfunctioncheckpyxt0 $^      pyobject pyxtemp0  pyxt0 pyxt0$^      pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxxdecrefpyxt0 pyxt0  0$^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^     else$^    endif$^    $^      pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxgotrefpyxt0$^      pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^      pyxgiverefpyxt0$^      pytuplesetitempyxt0 00 pyxt0$^      pyxt0  0$^      pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^    $^  $^  pyxdecrefpyxt0 pyxt0  0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   pywrapfst.pyx0000$^    $^  $^    def reprself              $^      return encodemapper at 0xx.formatidself$^  $^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.encodemapper.repr pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return encodemapper at 0xx.formatidself$^  $^    def initself              $^                 arctypebstandard$^                 bool encodelabelsfalse$^ $^$^ python wrapper $^static int pyxpw0pywrapfst00encodemapper0initpyobject pyxvself pyobject pyxargs pyobject pyxkwds proto$^static int pyxpw0pywrapfst00encodemapper0initpyobject pyxvself pyobject pyxargs pyobject pyxkwds $^  pyobject pyxvarctype  0$^  bool pyxvencodelabels$^  bool pyxvencodeweights$^  int pyxr$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextinit wrapper 0$^  $^    static pyobject pyxpyargnames  pyxnsarctypepyxnsencodelabelspyxnsencodeweights0$^    pyobject values0  000$^    values0  pyobject pyxnbstandard$^    if unlikelypyxkwds $^      pyssizet kwargs$^      const pyssizet posargs  pytuplegetsizepyxargs$^      switch posargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 break$^        default goto pyxl0argtupleerror$^      $^      kwargs  pydictsizepyxkwds$^      switch posargs $^        case  0$^        if kwargs  0 $^          pyobject value  pydictgetitempyxkwds pyxnsarctype$^          if value  values0  value kwargs $^        $^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pydictgetitempyxkwds pyxnsencodelabels$^          if value  values0  value kwargs $^        $^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pydictgetitempyxkwds pyxnsencodeweights$^          if value  values0  value kwargs $^        $^      $^      if unlikelykwargs  0 $^        if unlikelypyxparseoptionalkeywordspyxkwds pyxpyargnames 0 values posargs init  0 pyxerr0 0000 pyxl0error$^      $^     else $^      switch pytuplegetsizepyxargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 break$^        default goto pyxl0argtupleerror$^      $^    $^    pyxvarctype  values0$^    if values0 $^      pyxvencodelabels  pyxpyobjectistruevalues0 if unlikelypyxvencodelabels  bool0  pyerroccurred pyxerr0 0000 pyxl0error$^     else $^$^       pywrapfst.pyx0000$^    def initself$^                 arctypebstandard$^                 bool encodelabelsfalse              $^                 bool encodeweightsfalse$^      cdef uint00 flags  fst.getencodeflagsencodelabels encodeweights$^ $^      pyxvencodelabels  bool0$^    $^    if values0 $^      pyxvencodeweights  pyxpyobjectistruevalues0 if unlikelypyxvencodeweights  bool0  pyerroccurred pyxerr0 0000 pyxl0error$^     else $^$^       pywrapfst.pyx0000$^                 arctypebstandard$^                 bool encodelabelsfalse$^                 bool encodeweightsfalse              $^      cdef uint00 flags  fst.getencodeflagsencodelabels encodeweights$^      self.encoder.resetnew fst.encodemapperclasstostringarctype flags$^ $^      pyxvencodeweights  bool0$^    $^  $^  goto pyxl0argumentunpackingdone$^  pyxl0argtupleerror$^  pyxraiseargtupleinvalidinit 0 0 0 pytuplegetsizepyxargs pyxerr0 0000 pyxl0error$^  pyxl0error$^  pyxaddtracebackpywrapfst.encodemapper.init pyxclineno pyxlineno pyxfilename$^  pyxrefnannyfinishcontext$^  return 0$^  pyxl0argumentunpackingdone$^  pyxr  pyxpf0pywrapfst00encodemapper0initstruct pyxobj0pywrapfstencodemapper pyxvself pyxvarctype pyxvencodelabels pyxvencodeweights$^$^   pywrapfst.pyx0000$^      return encodemapper at 0xx.formatidself$^  $^    def initself              $^                 arctypebstandard$^                 bool encodelabelsfalse$^ $^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static int pyxpf0pywrapfst00encodemapper0initstruct pyxobj0pywrapfstencodemapper pyxvself pyobject pyxvarctype bool pyxvencodelabels bool pyxvencodeweights $^  pyxt00basictypesuint00 pyxvflags$^  int pyxr$^  pyxrefnannydeclarations$^  stdstring pyxt0$^  int pyxt0$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextinit 0$^$^   pywrapfst.pyx0000$^                 bool encodelabelsfalse$^                 bool encodeweightsfalse$^      cdef uint00 flags  fst.getencodeflagsencodelabels encodeweights              $^      self.encoder.resetnew fst.encodemapperclasstostringarctype flags$^                                                    fst.encode$^ $^  pyxvflags  fstscriptgetencodeflagspyxvencodelabels pyxvencodeweights$^$^   pywrapfst.pyx0000$^                 bool encodeweightsfalse$^      cdef uint00 flags  fst.getencodeflagsencodelabels encodeweights$^      self.encoder.resetnew fst.encodemapperclasstostringarctype flags              $^                                                    fst.encode$^      if not self.encoder$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s encoder$^    pyxerr0 0000 pyxl0error$^  $^  pyxt0  pyxf0pywrapfsttostringpyxvarctype null if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^      cdef uint00 flags  fst.getencodeflagsencodelabels encodeweights$^      self.encoder.resetnew fst.encodemapperclasstostringarctype flags$^                                                    fst.encode              $^      if not self.encoder$^        raise fstoperrorunknown arc type r.formatarctype$^ $^  pyxvselfencoder.resetnew fstscriptencodemapperclasspyxt0 pyxvflags fstencode$^$^   pywrapfst.pyx0000$^      self.encoder.resetnew fst.encodemapperclasstostringarctype flags$^                                                    fst.encode$^      if not self.encoder              $^        raise fstoperrorunknown arc type r.formatarctype$^  $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s encoder$^    pyxerr0 0000 pyxl0error$^  $^  pyxt0  pyxvselfencoder  0$^  if pyxt0 $^$^     pywrapfst.pyx0000$^                                                    fst.encode$^      if not self.encoder$^        raise fstoperrorunknown arc type r.formatarctype              $^  $^    cpdef string arctypeself$^ $^    pyxt0  pyxgetmoduleglobalnamepyxnsfstoperror if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  pyxpyobjectgetattrstrpyxkpsunknownarctyper pyxnsformat if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  null$^    if cythonunpackmethods  likelypymethodcheckpyxt0 $^      pyxt0  pymethodgetselfpyxt0$^      if likelypyxt0 $^        pyobject function  pymethodgetfunctionpyxt0$^        pyxincrefpyxt0$^        pyxincreffunction$^        pyxdecrefsetpyxt0 function$^      $^    $^    if pyxt0 $^      pyxt0  pyxpyobjectcalloneargpyxt0 pyxvarctype if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxgotrefpyxt0$^     else $^      if cythonfastpycall$^      if pyfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxvarctype$^        pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^       else$^      endif$^      if cythonfastpyccall$^      if pyxpyfastcfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxvarctype$^        pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^       else$^      endif$^      $^        pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxgotrefpyxt0$^        pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^        pyxincrefpyxvarctype$^        pyxgiverefpyxvarctype$^        pytuplesetitempyxt0 00 pyxvarctype$^        pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^      $^    $^    pyxdecrefpyxt0 pyxt0  0$^    pyxt0  null$^    if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^      pyxt0  pymethodgetselfpyxt0$^      if likelypyxt0 $^        pyobject function  pymethodgetfunctionpyxt0$^        pyxincrefpyxt0$^        pyxincreffunction$^        pyxdecrefsetpyxt0 function$^      $^    $^    if pyxt0 $^      pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxgotrefpyxt0$^     else $^      if cythonfastpycall$^      if pyfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxt0$^        pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^       else$^      endif$^      if cythonfastpyccall$^      if pyxpyfastcfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxt0$^        pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^       else$^      endif$^      $^        pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxgotrefpyxt0$^        pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^        pyxgiverefpyxt0$^        pytuplesetitempyxt0 00 pyxt0$^        pyxt0  0$^        pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^      $^    $^    pyxdecrefpyxt0 pyxt0  0$^    pyxraisepyxt0 0 0 0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxerr0 0000 pyxl0error$^$^     pywrapfst.pyx0000$^      self.encoder.resetnew fst.encodemapperclasstostringarctype flags$^                                                    fst.encode$^      if not self.encoder              $^        raise fstoperrorunknown arc type r.formatarctype$^  $^ $^  $^$^   pywrapfst.pyx0000$^      return encodemapper at 0xx.formatidself$^  $^    def initself              $^                 arctypebstandard$^                 bool encodelabelsfalse$^ $^$^   function exit code $^  pyxr  0$^  goto pyxl0$^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.encodemapper.init pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^        raise fstoperrorunknown arc type r.formatarctype$^  $^    cpdef string arctypeself              $^      $^      arctypeself$^ $^$^static pyobject pyxpw0pywrapfst00encodemapper0arctypepyobject pyxvself cythonunused pyobject unused proto$^static stdstring pyxf0pywrapfst00encodemapperarctypestruct pyxobj0pywrapfstencodemapper pyxvself int pyxskipdispatch $^  stdstring pyxr$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  stdstring pyxt0$^  pyxrefnannysetupcontextarctype 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnsarctype if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst00encodemapper0arctype $^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxdecrefpyxt0 pyxt0  0$^       else $^        pyxt0  pyxpyobjectcallnoargpyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      $^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxt0  pyxconvertstringfrompystdinstringpyxt0 if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxr  pyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx0000$^      returns a string indicating the arc type.$^      $^      return self.encoder.get.arctype              $^  $^     pythons equivalent to operator.$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s encoder$^    pyxerr0 0000 pyxl0error$^  $^  pyxr  pyxvselfencoder.getarctype$^  goto pyxl0$^$^   pywrapfst.pyx0000$^        raise fstoperrorunknown arc type r.formatarctype$^  $^    cpdef string arctypeself              $^      $^      arctypeself$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxwriteunraisablepywrapfst.encodemapper.arctype pyxclineno pyxlineno pyxfilename 0 0$^  pyxpretendtoinitializepyxr$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst00encodemapper0arctypepyobject pyxvself cythonunused pyobject unused proto$^static char pyxdoc0pywrapfst00encodemapper0arctype  n    arctypeselfnn    returns a string indicating the arc type.n    $^static pyobject pyxpw0pywrapfst00encodemapper0arctypepyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextarctype wrapper 0$^  pyxr  pyxpf0pywrapfst00encodemapper0arctypestruct pyxobj0pywrapfstencodemapper pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00encodemapper0arctypestruct pyxobj0pywrapfstencodemapper pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextarctype 0$^  pyxxdecrefpyxr$^  pyxt0  pyxconvertpybytesstringtopystdinstringpyxf0pywrapfst00encodemapperarctypepyxvself 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.encodemapper.arctype pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^     pythons equivalent to operator.$^  $^    def callself arc arc              $^      $^      selfstate ilabel olabel weight nextstate$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00encodemapper0callpyobject pyxvself pyobject pyxargs pyobject pyxkwds proto$^static char pyxdoc0pywrapfst00encodemapper0call  n    selfstate ilabel olabel weight nextstatenn    uses the encoder to encode an arc.nn    argsn      ilabel the integer index of the input label.n      olabel the integer index of the output label.n      weight a weight or weight string indicating the desired final weight ifn        null it is set to semiring one.n      nextstate the integer index of the destination state.nn    raisesn      fstoperror incompatible or invalid weight.n    $^if cythoncompilingincpython$^struct wrapperbase pyxwrapperbase0pywrapfst00encodemapper0call$^endif$^static pyobject pyxpw0pywrapfst00encodemapper0callpyobject pyxvself pyobject pyxargs pyobject pyxkwds $^  struct pyxobj0pywrapfstarc pyxvarc  0$^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextcall wrapper 0$^  $^    static pyobject pyxpyargnames  pyxnsarc0$^    pyobject values0  0$^    if unlikelypyxkwds $^      pyssizet kwargs$^      const pyssizet posargs  pytuplegetsizepyxargs$^      switch posargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 break$^        default goto pyxl0argtupleerror$^      $^      kwargs  pydictsizepyxkwds$^      switch posargs $^        case  0$^        if likelyvalues0  pydictgetitempyxkwds pyxnsarc  0 kwargs$^        else goto pyxl0argtupleerror$^      $^      if unlikelykwargs  0 $^        if unlikelypyxparseoptionalkeywordspyxkwds pyxpyargnames 0 values posargs call  0 pyxerr0 0000 pyxl0error$^      $^     else if pytuplegetsizepyxargs  0 $^      goto pyxl0argtupleerror$^     else $^      values0  pytuplegetitempyxargs 0$^    $^    pyxvarc  struct pyxobj0pywrapfstarc values0$^  $^  goto pyxl0argumentunpackingdone$^  pyxl0argtupleerror$^  pyxraiseargtupleinvalidcall 0 0 0 pytuplegetsizepyxargs pyxerr0 0000 pyxl0error$^  pyxl0error$^  pyxaddtracebackpywrapfst.encodemapper.call pyxclineno pyxlineno pyxfilename$^  pyxrefnannyfinishcontext$^  return null$^  pyxl0argumentunpackingdone$^  if unlikelypyxargtypetestpyobject pyxvarc pyxptype0pywrapfstarc 0 arc 0 pyxerr0 0000 pyxl0error$^  pyxr  pyxpf0pywrapfst00encodemapper0callstruct pyxobj0pywrapfstencodemapper pyxvself pyxvarc$^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxr  null$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00encodemapper0callstruct pyxobj0pywrapfstencodemapper pyxvself struct pyxobj0pywrapfstarc pyxvarc $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextcall 0$^$^   pywrapfst.pyx0000$^        fstoperror incompatible or invalid weight.$^      $^      return initarcself.encoder.get.callderefarc.arc              $^  $^    cpdef uint00 flagsself$^ $^  pyxxdecrefpyxr$^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s encoder$^    pyxerr0 0000 pyxl0error$^  $^  if unlikelypyobject pyxvarc  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s arc$^    pyxerr0 0000 pyxl0error$^  $^  pyxt0  pyobject pyxf0pywrapfstinitarcpyxvselfencoder.getoperatorpyxvarcarc if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   pywrapfst.pyx0000$^     pythons equivalent to operator.$^  $^    def callself arc arc              $^      $^      selfstate ilabel olabel weight nextstate$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.encodemapper.call pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return initarcself.encoder.get.callderefarc.arc$^  $^    cpdef uint00 flagsself              $^      $^      flagsself$^ $^$^static pyobject pyxpw0pywrapfst00encodemapper0flagspyobject pyxvself cythonunused pyobject unused proto$^static pyxt00basictypesuint00 pyxf0pywrapfst00encodemapperflagsstruct pyxobj0pywrapfstencodemapper pyxvself int pyxskipdispatch $^  pyxt00basictypesuint00 pyxr$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxt00basictypesuint00 pyxt0$^  pyxrefnannysetupcontextflags 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnsflags if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst00encodemapper0flags $^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxdecrefpyxt0 pyxt0  0$^       else $^        pyxt0  pyxpyobjectcallnoargpyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      $^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxt0  pyxpyintasuint00tpyxt0 if unlikelypyxt0  uint00t0  pyerroccurred pyxerr0 0000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxr  pyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx0000$^      returns the encoders flags.$^      $^      return self.encoder.get.flags              $^  $^    cpdef encodemappersymboltable inputsymbolsself$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s encoder$^    pyxerr0 0000 pyxl0error$^  $^  pyxr  pyxvselfencoder.getflags$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      return initarcself.encoder.get.callderefarc.arc$^  $^    cpdef uint00 flagsself              $^      $^      flagsself$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxwriteunraisablepywrapfst.encodemapper.flags pyxclineno pyxlineno pyxfilename 0 0$^  pyxr  0$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst00encodemapper0flagspyobject pyxvself cythonunused pyobject unused proto$^static char pyxdoc0pywrapfst00encodemapper0flags  n    flagsselfnn    returns the encoders flags.n    $^static pyobject pyxpw0pywrapfst00encodemapper0flagspyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextflags wrapper 0$^  pyxr  pyxpf0pywrapfst00encodemapper0flagsstruct pyxobj0pywrapfstencodemapper pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00encodemapper0flagsstruct pyxobj0pywrapfstencodemapper pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextflags 0$^  pyxxdecrefpyxr$^  pyxt0  pyxpyintfromuint00tpyxf0pywrapfst00encodemapperflagspyxvself 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.encodemapper.flags pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return self.encoder.get.flags$^  $^    cpdef encodemappersymboltable inputsymbolsself              $^      $^      inputsymbolsself$^ $^$^static pyobject pyxpw0pywrapfst00encodemapper00inputsymbolspyobject pyxvself cythonunused pyobject unused proto$^static struct pyxobj0pywrapfstencodemappersymboltable pyxf0pywrapfst00encodemapperinputsymbolsstruct pyxobj0pywrapfstencodemapper pyxvself int pyxskipdispatch $^  fstsymboltable pyxvsyms$^  struct pyxobj0pywrapfstencodemappersymboltable pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  int pyxt0$^  pyxrefnannysetupcontextinputsymbols 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnsinputsymbols if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst00encodemapper00inputsymbols $^      pyxxdecrefpyobject pyxr$^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxdecrefpyxt0 pyxt0  0$^       else $^        pyxt0  pyxpyobjectcallnoargpyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      $^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      if likelypyxt0  pynone  likelypyxtypetestpyxt0 pyxptype0pywrapfstencodemappersymboltable pyxerr0 0000 pyxl0error$^      pyxr  struct pyxobj0pywrapfstencodemappersymboltable pyxt0$^      pyxt0  0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx0000$^      $^      cdef fst.symboltable syms  constcastsymboltableptr$^          self.encoder.get.inputsymbols              $^      if syms  null$^        return$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s encoder$^    pyxerr0 0000 pyxl0error$^  $^$^   pywrapfst.pyx0000$^      returns the encoders input symbol table or none if none is present.$^      $^      cdef fst.symboltable syms  constcastsymboltableptr              $^          self.encoder.get.inputsymbols$^      if syms  null$^ $^  pyxvsyms  constcastpyxt0pywrapfstsymboltableptrpyxvselfencoder.getinputsymbols$^$^   pywrapfst.pyx0000$^      cdef fst.symboltable syms  constcastsymboltableptr$^          self.encoder.get.inputsymbols$^      if syms  null              $^        return$^      return initencodemappersymboltablesyms self.encoder$^ $^  pyxt0  pyxvsyms  null  0$^  if pyxt0 $^$^     pywrapfst.pyx0000$^          self.encoder.get.inputsymbols$^      if syms  null$^        return              $^      return initencodemappersymboltablesyms self.encoder$^  $^ $^    pyxxdecrefpyobject pyxr$^    pyxr  struct pyxobj0pywrapfstencodemappersymboltable pynone pyxincrefpynone$^    goto pyxl0$^$^     pywrapfst.pyx0000$^      cdef fst.symboltable syms  constcastsymboltableptr$^          self.encoder.get.inputsymbols$^      if syms  null              $^        return$^      return initencodemappersymboltablesyms self.encoder$^ $^  $^$^   pywrapfst.pyx0000$^      if syms  null$^        return$^      return initencodemappersymboltablesyms self.encoder              $^  $^    cpdef encodemappersymboltable outputsymbolsself$^ $^  pyxxdecrefpyobject pyxr$^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s encoder$^    pyxerr0 0000 pyxl0error$^  $^  pyxt0  pyobject pyxf0pywrapfstinitencodemappersymboltablepyxvsyms pyxvselfencoder if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  struct pyxobj0pywrapfstencodemappersymboltable pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      return self.encoder.get.flags$^  $^    cpdef encodemappersymboltable inputsymbolsself              $^      $^      inputsymbolsself$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.encodemapper.inputsymbols pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxl0$^  pyxxgiverefpyobject pyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst00encodemapper00inputsymbolspyobject pyxvself cythonunused pyobject unused proto$^static char pyxdoc0pywrapfst00encodemapper00inputsymbols  n    inputsymbolsselfnn    returns the encoders input symbol table or none if none is present.n    $^static pyobject pyxpw0pywrapfst00encodemapper00inputsymbolspyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextinputsymbols wrapper 0$^  pyxr  pyxpf0pywrapfst00encodemapper00inputsymbolsstruct pyxobj0pywrapfstencodemapper pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00encodemapper00inputsymbolsstruct pyxobj0pywrapfstencodemapper pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextinputsymbols 0$^  pyxxdecrefpyxr$^  pyxt0  pyobject pyxf0pywrapfst00encodemapperinputsymbolspyxvself 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.encodemapper.inputsymbols pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return initencodemappersymboltablesyms self.encoder$^  $^    cpdef encodemappersymboltable outputsymbolsself              $^      $^      outputsymbolsself$^ $^$^static pyobject pyxpw0pywrapfst00encodemapper00outputsymbolspyobject pyxvself cythonunused pyobject unused proto$^static struct pyxobj0pywrapfstencodemappersymboltable pyxf0pywrapfst00encodemapperoutputsymbolsstruct pyxobj0pywrapfstencodemapper pyxvself int pyxskipdispatch $^  fstsymboltable pyxvsyms$^  struct pyxobj0pywrapfstencodemappersymboltable pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  int pyxt0$^  pyxrefnannysetupcontextoutputsymbols 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnsoutputsymbols if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst00encodemapper00outputsymbols $^      pyxxdecrefpyobject pyxr$^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxdecrefpyxt0 pyxt0  0$^       else $^        pyxt0  pyxpyobjectcallnoargpyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      $^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      if likelypyxt0  pynone  likelypyxtypetestpyxt0 pyxptype0pywrapfstencodemappersymboltable pyxerr0 0000 pyxl0error$^      pyxr  struct pyxobj0pywrapfstencodemappersymboltable pyxt0$^      pyxt0  0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx0000$^      $^      cdef fst.symboltable syms  constcastsymboltableptr$^          self.encoder.get.outputsymbols              $^      if syms  null$^        return$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s encoder$^    pyxerr0 0000 pyxl0error$^  $^$^   pywrapfst.pyx0000$^      returns the encoders output symbol table or none if none is present.$^      $^      cdef fst.symboltable syms  constcastsymboltableptr              $^          self.encoder.get.outputsymbols$^      if syms  null$^ $^  pyxvsyms  constcastpyxt0pywrapfstsymboltableptrpyxvselfencoder.getoutputsymbols$^$^   pywrapfst.pyx0000$^      cdef fst.symboltable syms  constcastsymboltableptr$^          self.encoder.get.outputsymbols$^      if syms  null              $^        return$^      return initencodemappersymboltablesyms self.encoder$^ $^  pyxt0  pyxvsyms  null  0$^  if pyxt0 $^$^     pywrapfst.pyx0000$^          self.encoder.get.outputsymbols$^      if syms  null$^        return              $^      return initencodemappersymboltablesyms self.encoder$^  $^ $^    pyxxdecrefpyobject pyxr$^    pyxr  struct pyxobj0pywrapfstencodemappersymboltable pynone pyxincrefpynone$^    goto pyxl0$^$^     pywrapfst.pyx0000$^      cdef fst.symboltable syms  constcastsymboltableptr$^          self.encoder.get.outputsymbols$^      if syms  null              $^        return$^      return initencodemappersymboltablesyms self.encoder$^ $^  $^$^   pywrapfst.pyx0000$^      if syms  null$^        return$^      return initencodemappersymboltablesyms self.encoder              $^  $^    cpdef uint00 propertiesself uint00 mask$^ $^  pyxxdecrefpyobject pyxr$^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s encoder$^    pyxerr0 0000 pyxl0error$^  $^  pyxt0  pyobject pyxf0pywrapfstinitencodemappersymboltablepyxvsyms pyxvselfencoder if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  struct pyxobj0pywrapfstencodemappersymboltable pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      return initencodemappersymboltablesyms self.encoder$^  $^    cpdef encodemappersymboltable outputsymbolsself              $^      $^      outputsymbolsself$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.encodemapper.outputsymbols pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxl0$^  pyxxgiverefpyobject pyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst00encodemapper00outputsymbolspyobject pyxvself cythonunused pyobject unused proto$^static char pyxdoc0pywrapfst00encodemapper00outputsymbols  n    outputsymbolsselfnn    returns the encoders output symbol table or none if none is present.n    $^static pyobject pyxpw0pywrapfst00encodemapper00outputsymbolspyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextoutputsymbols wrapper 0$^  pyxr  pyxpf0pywrapfst00encodemapper00outputsymbolsstruct pyxobj0pywrapfstencodemapper pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00encodemapper00outputsymbolsstruct pyxobj0pywrapfstencodemapper pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextoutputsymbols 0$^  pyxxdecrefpyxr$^  pyxt0  pyobject pyxf0pywrapfst00encodemapperoutputsymbolspyxvself 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.encodemapper.outputsymbols pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return initencodemappersymboltablesyms self.encoder$^  $^    cpdef uint00 propertiesself uint00 mask              $^      $^      propertiesself mask$^ $^$^static pyobject pyxpw0pywrapfst00encodemapper00propertiespyobject pyxvself pyobject pyxargmask proto$^static pyxt00basictypesuint00 pyxf0pywrapfst00encodemapperpropertiesstruct pyxobj0pywrapfstencodemapper pyxvself pyxt00basictypesuint00 pyxvmask int pyxskipdispatch $^  pyxt00basictypesuint00 pyxr$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxt00basictypesuint00 pyxt0$^  pyxrefnannysetupcontextproperties 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnsproperties if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst00encodemapper00properties $^      pyxt0  pyxpyintfromuint00tpyxvmask if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxgotrefpyxt0$^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^       else $^        if cythonfastpycall$^        if pyfunctioncheckpyxt0 $^          pyobject pyxtemp0  pyxt0 pyxt0$^          pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^          pyxxdecrefpyxt0 pyxt0  0$^          pyxgotrefpyxt0$^          pyxdecrefpyxt0 pyxt0  0$^         else$^        endif$^        if cythonfastpyccall$^        if pyxpyfastcfunctioncheckpyxt0 $^          pyobject pyxtemp0  pyxt0 pyxt0$^          pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^          pyxxdecrefpyxt0 pyxt0  0$^          pyxgotrefpyxt0$^          pyxdecrefpyxt0 pyxt0  0$^         else$^        endif$^        $^          pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^          pyxgotrefpyxt0$^          pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^          pyxgiverefpyxt0$^          pytuplesetitempyxt0 00 pyxt0$^          pyxt0  0$^          pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^          pyxgotrefpyxt0$^          pyxdecrefpyxt0 pyxt0  0$^        $^      $^      pyxdecrefpyxt0 pyxt0  0$^      pyxt0  pyxpyintasuint00tpyxt0 if unlikelypyxt0  uint00t0  pyerroccurred pyxerr0 0000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxr  pyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx0000$^        a 00bit bitmask representing the requested properties.$^      $^      return self.encoder.get.propertiesmask              $^  $^    cpdef void setinputsymbolsself symboltable syms except $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s encoder$^    pyxerr0 0000 pyxl0error$^  $^  pyxr  pyxvselfencoder.getpropertiespyxvmask$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      return initencodemappersymboltablesyms self.encoder$^  $^    cpdef uint00 propertiesself uint00 mask              $^      $^      propertiesself mask$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxwriteunraisablepywrapfst.encodemapper.properties pyxclineno pyxlineno pyxfilename 0 0$^  pyxr  0$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst00encodemapper00propertiespyobject pyxvself pyobject pyxargmask proto$^static char pyxdoc0pywrapfst00encodemapper00properties  n    propertiesself masknn    provides property bits.nn    this method provides user access to the properties of the encoder.nn    argsn      mask the property mask to be compared to the encoders properties.nn    returnsn      a 00bit bitmask representing the requested properties.n    $^static pyobject pyxpw0pywrapfst00encodemapper00propertiespyobject pyxvself pyobject pyxargmask $^  pyxt00basictypesuint00 pyxvmask$^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextproperties wrapper 0$^  assertpyxargmask $^    pyxvmask  pyxpyintasuint00tpyxargmask if unlikelypyxvmask  uint00t0  pyerroccurred pyxerr0 0000 pyxl0error$^  $^  goto pyxl0argumentunpackingdone$^  pyxl0error$^  pyxaddtracebackpywrapfst.encodemapper.properties pyxclineno pyxlineno pyxfilename$^  pyxrefnannyfinishcontext$^  return null$^  pyxl0argumentunpackingdone$^  pyxr  pyxpf0pywrapfst00encodemapper00propertiesstruct pyxobj0pywrapfstencodemapper pyxvself pyxt00basictypesuint00pyxvmask$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00encodemapper00propertiesstruct pyxobj0pywrapfstencodemapper pyxvself pyxt00basictypesuint00 pyxvmask $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextproperties 0$^  pyxxdecrefpyxr$^  pyxt0  pyxpyintfromuint00tpyxf0pywrapfst00encodemapperpropertiespyxvself pyxvmask 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.encodemapper.properties pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return self.encoder.get.propertiesmask$^  $^    cpdef void setinputsymbolsself symboltable syms except               $^      $^      setinputsymbolsself syms$^ $^$^static pyobject pyxpw0pywrapfst00encodemapper00setinputsymbolspyobject pyxvself pyobject pyxvsyms proto$^static void pyxf0pywrapfst00encodemappersetinputsymbolsstruct pyxobj0pywrapfstencodemapper pyxvself struct pyxobj0pywrapfstsymboltable pyxvsyms int pyxskipdispatch $^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextsetinputsymbols 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnssetinputsymbols if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst00encodemapper00setinputsymbols $^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyobject pyxvsyms if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxgotrefpyxt0$^       else $^        if cythonfastpycall$^        if pyfunctioncheckpyxt0 $^          pyobject pyxtemp0  pyxt0 pyobject pyxvsyms$^          pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^          pyxxdecrefpyxt0 pyxt0  0$^          pyxgotrefpyxt0$^         else$^        endif$^        if cythonfastpyccall$^        if pyxpyfastcfunctioncheckpyxt0 $^          pyobject pyxtemp0  pyxt0 pyobject pyxvsyms$^          pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^          pyxxdecrefpyxt0 pyxt0  0$^          pyxgotrefpyxt0$^         else$^        endif$^        $^          pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^          pyxgotrefpyxt0$^          pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^          pyxincrefpyobject pyxvsyms$^          pyxgiverefpyobject pyxvsyms$^          pytuplesetitempyxt0 00 pyobject pyxvsyms$^          pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^          pyxgotrefpyxt0$^          pyxdecrefpyxt0 pyxt0  0$^        $^      $^      pyxdecrefpyxt0 pyxt0  0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx0000$^      see also setoutputsymbols.$^      $^      self.encoder.get.setinputsymbolssyms.table              $^  $^    cpdef void setoutputsymbolsself symboltable syms except $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s encoder$^    pyxerr0 0000 pyxl0error$^  $^  if unlikelypyobject pyxvsyms  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s table$^    pyxerr0 0000 pyxl0error$^  $^  pyxvselfencoder.getsetinputsymbolspyxvsymstable$^$^   pywrapfst.pyx0000$^      return self.encoder.get.propertiesmask$^  $^    cpdef void setinputsymbolsself symboltable syms except               $^      $^      setinputsymbolsself syms$^ $^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.encodemapper.setinputsymbols pyxclineno pyxlineno pyxfilename$^  pyxl0$^  pyxrefnannyfinishcontext$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst00encodemapper00setinputsymbolspyobject pyxvself pyobject pyxvsyms proto$^static char pyxdoc0pywrapfst00encodemapper00setinputsymbols  n    setinputsymbolsself symsnn    sets the encoders input symbol table.nn    argsn      syms a symboltable.nn    see also setoutputsymbols.n    $^static pyobject pyxpw0pywrapfst00encodemapper00setinputsymbolspyobject pyxvself pyobject pyxvsyms $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextsetinputsymbols wrapper 0$^  if unlikelypyxargtypetestpyobject pyxvsyms pyxptype0pywrapfstsymboltable 0 syms 0 pyxerr0 0000 pyxl0error$^  pyxr  pyxpf0pywrapfst00encodemapper00setinputsymbolsstruct pyxobj0pywrapfstencodemapper pyxvself struct pyxobj0pywrapfstsymboltable pyxvsyms$^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxr  null$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00encodemapper00setinputsymbolsstruct pyxobj0pywrapfstencodemapper pyxvself struct pyxobj0pywrapfstsymboltable pyxvsyms $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextsetinputsymbols 0$^  pyxxdecrefpyxr$^  pyxf0pywrapfst00encodemappersetinputsymbolspyxvself pyxvsyms 0 if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^  pyxt0  pyxvoidtononenull if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.encodemapper.setinputsymbols pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      self.encoder.get.setinputsymbolssyms.table$^  $^    cpdef void setoutputsymbolsself symboltable syms except               $^      $^      setoutputsymbolsself syms$^ $^$^static pyobject pyxpw0pywrapfst00encodemapper00setoutputsymbolspyobject pyxvself pyobject pyxvsyms proto$^static void pyxf0pywrapfst00encodemappersetoutputsymbolsstruct pyxobj0pywrapfstencodemapper pyxvself struct pyxobj0pywrapfstsymboltable pyxvsyms int pyxskipdispatch $^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextsetoutputsymbols 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnssetoutputsymbols if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst00encodemapper00setoutputsymbols $^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyobject pyxvsyms if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxgotrefpyxt0$^       else $^        if cythonfastpycall$^        if pyfunctioncheckpyxt0 $^          pyobject pyxtemp0  pyxt0 pyobject pyxvsyms$^          pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^          pyxxdecrefpyxt0 pyxt0  0$^          pyxgotrefpyxt0$^         else$^        endif$^        if cythonfastpyccall$^        if pyxpyfastcfunctioncheckpyxt0 $^          pyobject pyxtemp0  pyxt0 pyobject pyxvsyms$^          pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^          pyxxdecrefpyxt0 pyxt0  0$^          pyxgotrefpyxt0$^         else$^        endif$^        $^          pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^          pyxgotrefpyxt0$^          pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^          pyxincrefpyobject pyxvsyms$^          pyxgiverefpyobject pyxvsyms$^          pytuplesetitempyxt0 00 pyobject pyxvsyms$^          pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^          pyxgotrefpyxt0$^          pyxdecrefpyxt0 pyxt0  0$^        $^      $^      pyxdecrefpyxt0 pyxt0  0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx0000$^      see also setinputsymbols.$^      $^      self.encoder.get.setoutputsymbolssyms.table              $^  $^    cpdef string weighttypeself$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s encoder$^    pyxerr0 0000 pyxl0error$^  $^  if unlikelypyobject pyxvsyms  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s table$^    pyxerr0 0000 pyxl0error$^  $^  pyxvselfencoder.getsetoutputsymbolspyxvsymstable$^$^   pywrapfst.pyx0000$^      self.encoder.get.setinputsymbolssyms.table$^  $^    cpdef void setoutputsymbolsself symboltable syms except               $^      $^      setoutputsymbolsself syms$^ $^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.encodemapper.setoutputsymbols pyxclineno pyxlineno pyxfilename$^  pyxl0$^  pyxrefnannyfinishcontext$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst00encodemapper00setoutputsymbolspyobject pyxvself pyobject pyxvsyms proto$^static char pyxdoc0pywrapfst00encodemapper00setoutputsymbols  n    setoutputsymbolsself symsnn    sets the encoders output symbol table.nn    argsn      syms a symboltable.nn    see also setinputsymbols.n    $^static pyobject pyxpw0pywrapfst00encodemapper00setoutputsymbolspyobject pyxvself pyobject pyxvsyms $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextsetoutputsymbols wrapper 0$^  if unlikelypyxargtypetestpyobject pyxvsyms pyxptype0pywrapfstsymboltable 0 syms 0 pyxerr0 0000 pyxl0error$^  pyxr  pyxpf0pywrapfst00encodemapper00setoutputsymbolsstruct pyxobj0pywrapfstencodemapper pyxvself struct pyxobj0pywrapfstsymboltable pyxvsyms$^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxr  null$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00encodemapper00setoutputsymbolsstruct pyxobj0pywrapfstencodemapper pyxvself struct pyxobj0pywrapfstsymboltable pyxvsyms $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextsetoutputsymbols 0$^  pyxxdecrefpyxr$^  pyxf0pywrapfst00encodemappersetoutputsymbolspyxvself pyxvsyms 0 if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^  pyxt0  pyxvoidtononenull if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.encodemapper.setoutputsymbols pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      self.encoder.get.setoutputsymbolssyms.table$^  $^    cpdef string weighttypeself              $^      $^      weighttypeself$^ $^$^static pyobject pyxpw0pywrapfst00encodemapper00weighttypepyobject pyxvself cythonunused pyobject unused proto$^static stdstring pyxf0pywrapfst00encodemapperweighttypestruct pyxobj0pywrapfstencodemapper pyxvself int pyxskipdispatch $^  stdstring pyxr$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  stdstring pyxt0$^  pyxrefnannysetupcontextweighttype 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnsweighttype if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst00encodemapper00weighttype $^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxdecrefpyxt0 pyxt0  0$^       else $^        pyxt0  pyxpyobjectcallnoargpyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      $^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxt0  pyxconvertstringfrompystdinstringpyxt0 if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxr  pyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx0000$^      returns a string indicating the weight type.$^      $^      return self.encoder.get.weighttype              $^  $^  $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s encoder$^    pyxerr0 0000 pyxl0error$^  $^  pyxr  pyxvselfencoder.getweighttype$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      self.encoder.get.setoutputsymbolssyms.table$^  $^    cpdef string weighttypeself              $^      $^      weighttypeself$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxwriteunraisablepywrapfst.encodemapper.weighttype pyxclineno pyxlineno pyxfilename 0 0$^  pyxpretendtoinitializepyxr$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst00encodemapper00weighttypepyobject pyxvself cythonunused pyobject unused proto$^static char pyxdoc0pywrapfst00encodemapper00weighttype  n    weighttypeselfnn    returns a string indicating the weight type.n    $^static pyobject pyxpw0pywrapfst00encodemapper00weighttypepyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextweighttype wrapper 0$^  pyxr  pyxpf0pywrapfst00encodemapper00weighttypestruct pyxobj0pywrapfstencodemapper pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00encodemapper00weighttypestruct pyxobj0pywrapfstencodemapper pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextweighttype 0$^  pyxxdecrefpyxr$^  pyxt0  pyxconvertpybytesstringtopystdinstringpyxf0pywrapfst00encodemapperweighttypepyxvself 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.encodemapper.weighttype pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ tree fragment0$^  def reducecythonself              $^      raise typeerrorself.encoder cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00encodemapper00reducecythonpyobject pyxvself cythonunused pyobject unused proto$^static pyobject pyxpw0pywrapfst00encodemapper00reducecythonpyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextreducecython wrapper 0$^  pyxr  pyxpf0pywrapfst00encodemapper00reducecythonstruct pyxobj0pywrapfstencodemapper pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00encodemapper00reducecythoncythonunused struct pyxobj0pywrapfstencodemapper pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextreducecython 0$^$^   tree fragment0$^  def reducecythonself$^      raise typeerrorself.encoder cannot be converted to a python object for pickling              $^  def setstatecythonself pyxstate$^      raise typeerrorself.encoder cannot be converted to a python object for pickling$^ $^  pyxt0  pyxpyobjectcallpyxbuiltintypeerror pyxtuple00 null if unlikelypyxt0 pyxerr0 0 pyxl0error$^  pyxgotrefpyxt0$^  pyxraisepyxt0 0 0 0$^  pyxdecrefpyxt0 pyxt0  0$^  pyxerr0 0 pyxl0error$^$^   tree fragment0$^  def reducecythonself              $^      raise typeerrorself.encoder cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.encodemapper.reducecython pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ tree fragment0$^  def reducecythonself$^      raise typeerrorself.encoder cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate              $^      raise typeerrorself.encoder cannot be converted to a python object for pickling$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00encodemapper00setstatecythonpyobject pyxvself pyobject pyxvpyxstate proto$^static pyobject pyxpw0pywrapfst00encodemapper00setstatecythonpyobject pyxvself pyobject pyxvpyxstate $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextsetstatecython wrapper 0$^  pyxr  pyxpf0pywrapfst00encodemapper00setstatecythonstruct pyxobj0pywrapfstencodemapper pyxvself pyobject pyxvpyxstate$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00encodemapper00setstatecythoncythonunused struct pyxobj0pywrapfstencodemapper pyxvself cythonunused pyobject pyxvpyxstate $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextsetstatecython 0$^$^   tree fragment0$^      raise typeerrorself.encoder cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate$^      raise typeerrorself.encoder cannot be converted to a python object for pickling              $^ $^  pyxt0  pyxpyobjectcallpyxbuiltintypeerror pyxtuple00 null if unlikelypyxt0 pyxerr0 0 pyxl0error$^  pyxgotrefpyxt0$^  pyxraisepyxt0 0 0 0$^  pyxdecrefpyxt0 pyxt0  0$^  pyxerr0 0 pyxl0error$^$^   tree fragment0$^  def reducecythonself$^      raise typeerrorself.encoder cannot be converted to a python object for pickling$^  def setstatecythonself pyxstate              $^      raise typeerrorself.encoder cannot be converted to a python object for pickling$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.encodemapper.setstatecython pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^  $^     ipython notebook magic to produce an svg of the fst.$^    def reprsvgself              $^      ipython notebook magic to produce an svg of the fst using graphviz.$^  $^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst0fst0reprsvgpyobject pyxvself cythonunused pyobject unused proto$^static char pyxdoc0pywrapfst0fstreprsvg  ipython notebook magic to produce an svg of the fst using graphviz.nn    this method produces an svg of the internal graph. users wishing to createn    publicationquality graphs should instead use the method draw whichn    exposes additional parameters.nn    raisesn      oserror cannot locate the dot executable.n      subprocess.calledprocesserror dot returned nonzero exit code.nn    see also draw text.n    $^static pyobject pyxpw0pywrapfst0fst0reprsvgpyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextreprsvg wrapper 0$^  pyxr  pyxpf0pywrapfst0fstreprsvgstruct pyxobj0pywrapfstfst pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst0fstreprsvgstruct pyxobj0pywrapfstfst pyxvself $^  pyobject pyxvproc  null$^  stdstringstream pyxvsstrm$^  pyobject pyxvsout  null$^  cythonunused pyobject pyxvserr  null$^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  stdstring pyxt0$^  stdstring pyxt0$^  stdstring pyxt0$^  pyobject pyxt0pyobject $^  int pyxt00$^  int pyxt00$^  pyobject pyxt00  null$^  pyxrefnannysetupcontextreprsvg 0$^$^   pywrapfst.pyx0000$^      $^       throws oserror if the dot executable is not found.$^      proc  subprocess.popendot tsvg stdinsubprocess.pipe              $^                              stdoutsubprocess.pipe stderrsubprocess.pipe$^      cdef stringstream sstrm$^ $^  pyxt0  pyxgetmoduleglobalnamepyxnssubprocess if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxt0  pyxpyobjectgetattrstrpyxt0 pyxnspopen if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxdecrefpyxt0 pyxt0  0$^  pyxt0  pylistnew0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxincrefpyxnsdot$^  pyxgiverefpyxnsdot$^  pylistsetitempyxt0 0 pyxnsdot$^  pyxincrefpyxkpstsvg$^  pyxgiverefpyxkpstsvg$^  pylistsetitempyxt0 0 pyxkpstsvg$^  pyxt0  pytuplenew0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxgiverefpyxt0$^  pytuplesetitempyxt0 0 pyxt0$^  pyxt0  0$^  pyxt0  pyxpydictnewpresized0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxt0  pyxgetmoduleglobalnamepyxnssubprocess if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxt0  pyxpyobjectgetattrstrpyxt0 pyxnspipe if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxdecrefpyxt0 pyxt0  0$^  if pydictsetitempyxt0 pyxnsstdin pyxt0  0 pyxerr0 0000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^$^   pywrapfst.pyx0000$^       throws oserror if the dot executable is not found.$^      proc  subprocess.popendot tsvg stdinsubprocess.pipe$^                              stdoutsubprocess.pipe stderrsubprocess.pipe              $^      cdef stringstream sstrm$^      fst.drawfstderefself.fst self.fst.get.inputsymbols$^ $^  pyxt0  pyxgetmoduleglobalnamepyxnssubprocess if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxt0  pyxpyobjectgetattrstrpyxt0 pyxnspipe if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxdecrefpyxt0 pyxt0  0$^  if pydictsetitempyxt0 pyxnsstdout pyxt0  0 pyxerr0 0000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^  pyxt0  pyxgetmoduleglobalnamepyxnssubprocess if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxt0  pyxpyobjectgetattrstrpyxt0 pyxnspipe if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxdecrefpyxt0 pyxt0  0$^  if pydictsetitempyxt0 pyxnsstderr pyxt0  0 pyxerr0 0000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^$^   pywrapfst.pyx0000$^      $^       throws oserror if the dot executable is not found.$^      proc  subprocess.popendot tsvg stdinsubprocess.pipe              $^                              stdoutsubprocess.pipe stderrsubprocess.pipe$^      cdef stringstream sstrm$^ $^  pyxt0  pyxpyobjectcallpyxt0 pyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxdecrefpyxt0 pyxt0  0$^  pyxdecrefpyxt0 pyxt0  0$^  pyxdecrefpyxt0 pyxt0  0$^  pyxvproc  pyxt0$^  pyxt0  0$^$^   pywrapfst.pyx0000$^                              stdoutsubprocess.pipe stderrsubprocess.pipe$^      cdef stringstream sstrm$^      fst.drawfstderefself.fst self.fst.get.inputsymbols              $^                  self.fst.get.outputsymbols null$^                  self.fst.get.propertiesfst.kacceptor true $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s fst$^    pyxerr0 0000 pyxl0error$^  $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s fst$^    pyxerr0 0000 pyxl0error$^  $^$^   pywrapfst.pyx0000$^      cdef stringstream sstrm$^      fst.drawfstderefself.fst self.fst.get.inputsymbols$^                  self.fst.get.outputsymbols null              $^                  self.fst.get.propertiesfst.kacceptor true $^                  fst.kacceptor$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s fst$^    pyxerr0 0000 pyxl0error$^  $^$^   pywrapfst.pyx0000$^      fst.drawfstderefself.fst self.fst.get.inputsymbols$^                  self.fst.get.outputsymbols null$^                  self.fst.get.propertiesfst.kacceptor true               $^                  fst.kacceptor$^                  b 0.0 00 true false 0.0 0.00 00 0 bg false$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s fst$^    pyxerr0 0000 pyxl0error$^  $^$^   pywrapfst.pyx0000$^                  self.fst.get.propertiesfst.kacceptor true $^                  fst.kacceptor$^                  b 0.0 00 true false 0.0 0.00 00 0 bg false              $^                  addrsstrm breprsvg$^      sout serr  proc.communicatesstrm.str$^ $^  pyxt0  pyxconvertstringfrompystdinstringpyxkpb00 if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^  pyxt0  pyxconvertstringfrompystdinstringpyxnbg if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^                  fst.kacceptor$^                  b 0.0 00 true false 0.0 0.00 00 0 bg false$^                  addrsstrm breprsvg              $^      sout serr  proc.communicatesstrm.str$^      if proc.returncode  0   just to be explicit.$^ $^  pyxt0  pyxconvertstringfrompystdinstringpyxnbreprsvg if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^                              stdoutsubprocess.pipe stderrsubprocess.pipe$^      cdef stringstream sstrm$^      fst.drawfstderefself.fst self.fst.get.inputsymbols              $^                  self.fst.get.outputsymbols null$^                  self.fst.get.propertiesfst.kacceptor true $^ $^  fstscriptdrawfstpyxvselffst pyxvselffst.getinputsymbols pyxvselffst.getoutputsymbols null pyxvselffst.getpropertiesfstkacceptor 0  fstkacceptor pyxt0 0.0 00.0 0 0 0.0 0.00 00 0 pyxt0 0 pyxvsstrm pyxt0$^$^   pywrapfst.pyx0000$^                  b 0.0 00 true false 0.0 0.00 00 0 bg false$^                  addrsstrm breprsvg$^      sout serr  proc.communicatesstrm.str              $^      if proc.returncode  0   just to be explicit.$^        raise subprocess.calledprocesserrorproc.returncode self.dottsvg$^ $^  pyxt0  pyxpyobjectgetattrstrpyxvproc pyxnscommunicate if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxt0  pyxconvertpybytesstringtopystdinstringpyxvsstrm.str if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxt0  null$^  if cythonunpackmethods  likelypymethodcheckpyxt0 $^    pyxt0  pymethodgetselfpyxt0$^    if likelypyxt0 $^      pyobject function  pymethodgetfunctionpyxt0$^      pyxincrefpyxt0$^      pyxincreffunction$^      pyxdecrefsetpyxt0 function$^    $^  $^  if pyxt0 $^    pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxdecrefpyxt0 pyxt0  0$^    pyxgotrefpyxt0$^   else $^    if cythonfastpycall$^    if pyfunctioncheckpyxt0 $^      pyobject pyxtemp0  pyxt0 pyxt0$^      pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxxdecrefpyxt0 pyxt0  0$^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^     else$^    endif$^    if cythonfastpyccall$^    if pyxpyfastcfunctioncheckpyxt0 $^      pyobject pyxtemp0  pyxt0 pyxt0$^      pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxxdecrefpyxt0 pyxt0  0$^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^     else$^    endif$^    $^      pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxgotrefpyxt0$^      pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^      pyxgiverefpyxt0$^      pytuplesetitempyxt0 00 pyxt0$^      pyxt0  0$^      pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^    $^  $^  pyxdecrefpyxt0 pyxt0  0$^  if likelypytuplecheckexactpyxt0  pylistcheckexactpyxt0 $^    pyobject sequence  pyxt0$^    if cythoncompilinginpypy$^    pyssizet size  pysizesequence$^    else$^    pyssizet size  pysequencesizesequence$^    endif$^    if unlikelysize  0 $^      if size  0 pyxraisetoomanyvalueserror0$^      else if size  0 pyxraiseneedmorevalueserrorsize$^      pyxerr0 0000 pyxl0error$^    $^    if cythonassumesafemacros  cythonavoidborrowedrefs$^    if likelypytuplecheckexactsequence $^      pyxt0  pytuplegetitemsequence 0 $^      pyxt0  pytuplegetitemsequence 0 $^     else $^      pyxt0  pylistgetitemsequence 0 $^      pyxt0  pylistgetitemsequence 0 $^    $^    pyxincrefpyxt0$^    pyxincrefpyxt0$^    else$^    pyxt0  pysequenceitemsequence 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  pysequenceitemsequence 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    endif$^    pyxdecrefpyxt0 pyxt0  0$^   else $^    pyssizet index  0$^    pyxt0  pyobjectgetiterpyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxt0  pytypepyxt0tpiternext$^    index  0 pyxt0  pyxt0pyxt0 if unlikelypyxt0 goto pyxl0unpackingfailed$^    pyxgotrefpyxt0$^    index  0 pyxt0  pyxt0pyxt0 if unlikelypyxt0 goto pyxl0unpackingfailed$^    pyxgotrefpyxt0$^    if pyxiternextunpackendcheckpyxt0pyxt0 0  0 pyxerr0 0000 pyxl0error$^    pyxt0  null$^    pyxdecrefpyxt0 pyxt0  0$^    goto pyxl0unpackingdone$^    pyxl0unpackingfailed$^    pyxdecrefpyxt0 pyxt0  0$^    pyxt0  null$^    if pyxiterfinish  0 pyxraiseneedmorevalueserrorindex$^    pyxerr0 0000 pyxl0error$^    pyxl0unpackingdone$^  $^  pyxvsout  pyxt0$^  pyxt0  0$^  pyxvserr  pyxt0$^  pyxt0  0$^$^   pywrapfst.pyx0000$^                  addrsstrm breprsvg$^      sout serr  proc.communicatesstrm.str$^      if proc.returncode  0   just to be explicit.              $^        raise subprocess.calledprocesserrorproc.returncode self.dottsvg$^      return sout.decodeutf0$^ $^  pyxt0  pyxpyobjectgetattrstrpyxvproc pyxnsreturncode if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxt0  pyobjectrichcomparepyxt0 pyxint0 pyne pyxxgotrefpyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^  pyxt00  pyxpyobjectistruepyxt0 if unlikelypyxt00  0 pyxerr0 0000 pyxl0error$^  pyxdecrefpyxt0 pyxt0  0$^  if pyxt00 $^$^     pywrapfst.pyx0000$^      sout serr  proc.communicatesstrm.str$^      if proc.returncode  0   just to be explicit.$^        raise subprocess.calledprocesserrorproc.returncode self.dottsvg              $^      return sout.decodeutf0$^  $^ $^    pyxt0  pyxgetmoduleglobalnamepyxnssubprocess if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  pyxpyobjectgetattrstrpyxt0 pyxnscalledprocesserror if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxt0  pyxpyobjectgetattrstrpyxvproc pyxnsreturncode if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnsdottsvg if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  null$^    pyxt00  0$^    if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^      pyxt0  pymethodgetselfpyxt0$^      if likelypyxt0 $^        pyobject function  pymethodgetfunctionpyxt0$^        pyxincrefpyxt0$^        pyxincreffunction$^        pyxdecrefsetpyxt0 function$^        pyxt00  0$^      $^    $^    if cythonfastpycall$^    if pyfunctioncheckpyxt0 $^      pyobject pyxtemp0  pyxt0 pyxt0 pyxt0$^      pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp0pyxt00 0pyxt00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxxdecrefpyxt0 pyxt0  0$^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxdecrefpyxt0 pyxt0  0$^     else$^    endif$^    if cythonfastpyccall$^    if pyxpyfastcfunctioncheckpyxt0 $^      pyobject pyxtemp0  pyxt0 pyxt0 pyxt0$^      pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp0pyxt00 0pyxt00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxxdecrefpyxt0 pyxt0  0$^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxdecrefpyxt0 pyxt0  0$^     else$^    endif$^    $^      pyxt00  pytuplenew0pyxt00 if unlikelypyxt00 pyxerr0 0000 pyxl0error$^      pyxgotrefpyxt00$^      if pyxt0 $^        pyxgiverefpyxt0 pytuplesetitempyxt00 0 pyxt0 pyxt0  null$^      $^      pyxgiverefpyxt0$^      pytuplesetitempyxt00 0pyxt00 pyxt0$^      pyxgiverefpyxt0$^      pytuplesetitempyxt00 0pyxt00 pyxt0$^      pyxt0  0$^      pyxt0  0$^      pyxt0  pyxpyobjectcallpyxt0 pyxt00 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxgotrefpyxt0$^      pyxdecrefpyxt00 pyxt00  0$^    $^    pyxdecrefpyxt0 pyxt0  0$^    pyxraisepyxt0 0 0 0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxerr0 0000 pyxl0error$^$^     pywrapfst.pyx0000$^                  addrsstrm breprsvg$^      sout serr  proc.communicatesstrm.str$^      if proc.returncode  0   just to be explicit.              $^        raise subprocess.calledprocesserrorproc.returncode self.dottsvg$^      return sout.decodeutf0$^ $^  $^$^   pywrapfst.pyx0000$^      if proc.returncode  0   just to be explicit.$^        raise subprocess.calledprocesserrorproc.returncode self.dottsvg$^      return sout.decodeutf0              $^  $^    def reprself$^ $^  pyxxdecrefpyxr$^  pyxt0  pyxpyobjectgetattrstrpyxvsout pyxnsdecode if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxt0  pyxpyobjectcallpyxt0 pyxtuple00 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxdecrefpyxt0 pyxt0  0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   pywrapfst.pyx0000$^  $^     ipython notebook magic to produce an svg of the fst.$^    def reprsvgself              $^      ipython notebook magic to produce an svg of the fst using graphviz.$^  $^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt00$^  pyxaddtracebackpywrapfst.fst.reprsvg pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxdecrefpyxvproc$^  pyxxdecrefpyxvsout$^  pyxxdecrefpyxvserr$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return sout.decodeutf0$^  $^    def reprself              $^      return  fst at 0xx.formatself.fsttype idself$^  $^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst0fst0reprpyobject pyxvself proto$^static pyobject pyxpw0pywrapfst0fst0reprpyobject pyxvself $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextrepr wrapper 0$^  pyxr  pyxpf0pywrapfst0fst0reprstruct pyxobj0pywrapfstfst pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst0fst0reprstruct pyxobj0pywrapfstfst pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  int pyxt0$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextrepr 0$^$^   pywrapfst.pyx0000$^  $^    def reprself$^      return  fst at 0xx.formatself.fsttype idself              $^  $^    def initself$^ $^  pyxxdecrefpyxr$^  pyxt0  pyxpyobjectgetattrstrpyxkpsfstat0xx pyxnsformat if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s fsttype$^    pyxerr0 0000 pyxl0error$^  $^  pyxt0  pyxconvertpybytesstringtopystdinstringstruct pyxvtabstruct0pywrapfstfst pyxvselfpyxvtabfsttypepyxvself 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxt0  pytuplenew0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxincrefpyobject pyxvself$^  pyxgiverefpyobject pyxvself$^  pytuplesetitempyxt0 0 pyobject pyxvself$^  pyxt0  pyxpyobjectcallpyxbuiltinid pyxt0 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxdecrefpyxt0 pyxt0  0$^  pyxt0  null$^  pyxt0  0$^  if cythonunpackmethods  likelypymethodcheckpyxt0 $^    pyxt0  pymethodgetselfpyxt0$^    if likelypyxt0 $^      pyobject function  pymethodgetfunctionpyxt0$^      pyxincrefpyxt0$^      pyxincreffunction$^      pyxdecrefsetpyxt0 function$^      pyxt0  0$^    $^  $^  if cythonfastpycall$^  if pyfunctioncheckpyxt0 $^    pyobject pyxtemp0  pyxt0 pyxt0 pyxt0$^    pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp0pyxt0 0pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxxdecrefpyxt0 pyxt0  0$^    pyxgotrefpyxt0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxdecrefpyxt0 pyxt0  0$^   else$^  endif$^  if cythonfastpyccall$^  if pyxpyfastcfunctioncheckpyxt0 $^    pyobject pyxtemp0  pyxt0 pyxt0 pyxt0$^    pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp0pyxt0 0pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxxdecrefpyxt0 pyxt0  0$^    pyxgotrefpyxt0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxdecrefpyxt0 pyxt0  0$^   else$^  endif$^  $^    pyxt0  pytuplenew0pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    if pyxt0 $^      pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^    $^    pyxgiverefpyxt0$^    pytuplesetitempyxt0 0pyxt0 pyxt0$^    pyxgiverefpyxt0$^    pytuplesetitempyxt0 0pyxt0 pyxt0$^    pyxt0  0$^    pyxt0  0$^    pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxdecrefpyxt0 pyxt0  0$^  $^  pyxdecrefpyxt0 pyxt0  0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      return sout.decodeutf0$^  $^    def reprself              $^      return  fst at 0xx.formatself.fsttype idself$^  $^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.fst.repr pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return  fst at 0xx.formatself.fsttype idself$^  $^    def initself              $^      raise fstdeletedconstructorerror$^          cannot construct .formatself.class.name$^ $^$^ python wrapper $^static int pyxpw0pywrapfst0fst0initpyobject pyxvself pyobject pyxargs pyobject pyxkwds proto$^static int pyxpw0pywrapfst0fst0initpyobject pyxvself pyobject pyxargs pyobject pyxkwds $^  int pyxr$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextinit wrapper 0$^  if unlikelypytuplegetsizepyxargs  0 $^    pyxraiseargtupleinvalidinit 0 0 0 pytuplegetsizepyxargs return 0$^  if unlikelypyxkwds  unlikelypydictsizepyxkwds  0  unlikelypyxcheckkeywordstringspyxkwds init 0 return 0$^  pyxr  pyxpf0pywrapfst0fst0initstruct pyxobj0pywrapfstfst pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static int pyxpf0pywrapfst0fst0initstruct pyxobj0pywrapfstfst pyxvself $^  int pyxr$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextinit 0$^$^   pywrapfst.pyx0000$^  $^    def initself$^      raise fstdeletedconstructorerror              $^          cannot construct .formatself.class.name$^  $^ $^  pyxt0  pyxgetmoduleglobalnamepyxnsfstdeletedconstructorerror if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^$^   pywrapfst.pyx0000$^    def initself$^      raise fstdeletedconstructorerror$^          cannot construct .formatself.class.name              $^  $^    def strself$^ $^  pyxt0  pyxpyobjectgetattrstrpyxkpscannotconstruct pyxnsformat if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnsclass if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxt0  pyxpyobjectgetattrstrpyxt0 pyxnsname if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxdecrefpyxt0 pyxt0  0$^  pyxt0  null$^  if cythonunpackmethods  likelypymethodcheckpyxt0 $^    pyxt0  pymethodgetselfpyxt0$^    if likelypyxt0 $^      pyobject function  pymethodgetfunctionpyxt0$^      pyxincrefpyxt0$^      pyxincreffunction$^      pyxdecrefsetpyxt0 function$^    $^  $^  if pyxt0 $^    pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxdecrefpyxt0 pyxt0  0$^    pyxgotrefpyxt0$^   else $^    if cythonfastpycall$^    if pyfunctioncheckpyxt0 $^      pyobject pyxtemp0  pyxt0 pyxt0$^      pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxxdecrefpyxt0 pyxt0  0$^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^     else$^    endif$^    if cythonfastpyccall$^    if pyxpyfastcfunctioncheckpyxt0 $^      pyobject pyxtemp0  pyxt0 pyxt0$^      pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxxdecrefpyxt0 pyxt0  0$^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^     else$^    endif$^    $^      pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxgotrefpyxt0$^      pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^      pyxgiverefpyxt0$^      pytuplesetitempyxt0 00 pyxt0$^      pyxt0  0$^      pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^    $^  $^  pyxdecrefpyxt0 pyxt0  0$^  pyxt0  null$^  if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^    pyxt0  pymethodgetselfpyxt0$^    if likelypyxt0 $^      pyobject function  pymethodgetfunctionpyxt0$^      pyxincrefpyxt0$^      pyxincreffunction$^      pyxdecrefsetpyxt0 function$^    $^  $^  if pyxt0 $^    pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxdecrefpyxt0 pyxt0  0$^    pyxgotrefpyxt0$^   else $^    if cythonfastpycall$^    if pyfunctioncheckpyxt0 $^      pyobject pyxtemp0  pyxt0 pyxt0$^      pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxxdecrefpyxt0 pyxt0  0$^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^     else$^    endif$^    if cythonfastpyccall$^    if pyxpyfastcfunctioncheckpyxt0 $^      pyobject pyxtemp0  pyxt0 pyxt0$^      pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxxdecrefpyxt0 pyxt0  0$^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^     else$^    endif$^    $^      pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxgotrefpyxt0$^      pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^      pyxgiverefpyxt0$^      pytuplesetitempyxt0 00 pyxt0$^      pyxt0  0$^      pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^    $^  $^  pyxdecrefpyxt0 pyxt0  0$^  pyxraisepyxt0 0 0 0$^  pyxdecrefpyxt0 pyxt0  0$^  pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^      return  fst at 0xx.formatself.fsttype idself$^  $^    def initself              $^      raise fstdeletedconstructorerror$^          cannot construct .formatself.class.name$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.fst.init pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^          cannot construct .formatself.class.name$^  $^    def strself              $^      return self.text$^  $^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst0fst0strpyobject pyxvself proto$^static pyobject pyxpw0pywrapfst0fst0strpyobject pyxvself $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextstr wrapper 0$^  pyxr  pyxpf0pywrapfst0fst0strstruct pyxobj0pywrapfstfst pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst0fst0strstruct pyxobj0pywrapfstfst pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextstr 0$^$^   pywrapfst.pyx0000$^  $^    def strself$^      return self.text              $^  $^     registers the class for pickling must be repeated in any subclass which$^ $^  pyxxdecrefpyxr$^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s text$^    pyxerr0 0000 pyxl0error$^  $^  pyxt0  pyxconvertpybytesstringtopystdinstringstruct pyxvtabstruct0pywrapfstfst pyxvselfpyxvtabtextpyxvself 0 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   pywrapfst.pyx0000$^          cannot construct .formatself.class.name$^  $^    def strself              $^      return self.text$^  $^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.fst.str pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^     cant be derived by initxfst.$^  $^    def reduceself              $^      return readfromstring self.writetostring$^  $^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst0fst0reducepyobject pyxvself cythonunused pyobject unused proto$^static pyobject pyxpw0pywrapfst0fst0reducepyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextreduce wrapper 0$^  pyxr  pyxpf0pywrapfst0fst0reducestruct pyxobj0pywrapfstfst pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst0fst0reducestruct pyxobj0pywrapfstfst pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextreduce 0$^$^   pywrapfst.pyx0000$^  $^    def reduceself$^      return readfromstring self.writetostring              $^  $^    cpdef string arctypeself$^ $^  pyxxdecrefpyxr$^  pyxt0  pyxgetmoduleglobalnamepyxnsreadfromstring if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s writetostring$^    pyxerr0 0000 pyxl0error$^  $^  pyxt0  pyxconvertpybytesstringtopystdinstringstruct pyxvtabstruct0pywrapfstfst pyxvselfpyxvtabwritetostringpyxvself 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxt0  pytuplenew0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxgiverefpyxt0$^  pytuplesetitempyxt0 0 pyxt0$^  pyxt0  0$^  pyxt0  pytuplenew0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxgiverefpyxt0$^  pytuplesetitempyxt0 0 pyxt0$^  pyxgiverefpyxt0$^  pytuplesetitempyxt0 0 pyxt0$^  pyxt0  0$^  pyxt0  0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   pywrapfst.pyx0000$^     cant be derived by initxfst.$^  $^    def reduceself              $^      return readfromstring self.writetostring$^  $^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.fst.reduce pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return readfromstring self.writetostring$^  $^    cpdef string arctypeself              $^      $^      arctypeself$^ $^$^static pyobject pyxpw0pywrapfst0fst00arctypepyobject pyxvself cythonunused pyobject unused proto$^static stdstring pyxf0pywrapfst0fstarctypestruct pyxobj0pywrapfstfst pyxvself int pyxskipdispatch $^  stdstring pyxr$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  stdstring pyxt0$^  pyxrefnannysetupcontextarctype 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnsarctype if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst0fst00arctype $^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxdecrefpyxt0 pyxt0  0$^       else $^        pyxt0  pyxpyobjectcallnoargpyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      $^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxt0  pyxconvertstringfrompystdinstringpyxt0 if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxr  pyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx0000$^      returns a string indicating the arc type.$^      $^      return self.fst.get.arctype              $^  $^    cpdef arciterator arcsself int00 state$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s fst$^    pyxerr0 0000 pyxl0error$^  $^  pyxr  pyxvselffst.getarctype$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      return readfromstring self.writetostring$^  $^    cpdef string arctypeself              $^      $^      arctypeself$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxwriteunraisablepywrapfst.fst.arctype pyxclineno pyxlineno pyxfilename 0 0$^  pyxpretendtoinitializepyxr$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst0fst00arctypepyobject pyxvself cythonunused pyobject unused proto$^static char pyxdoc0pywrapfst0fst00arctype  n    arctypeselfnn    returns a string indicating the arc type.n    $^static pyobject pyxpw0pywrapfst0fst00arctypepyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextarctype wrapper 0$^  pyxr  pyxpf0pywrapfst0fst00arctypestruct pyxobj0pywrapfstfst pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst0fst00arctypestruct pyxobj0pywrapfstfst pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextarctype 0$^  pyxxdecrefpyxr$^  pyxt0  pyxconvertpybytesstringtopystdinstringpyxf0pywrapfst0fstarctypepyxvself 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.fst.arctype pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return self.fst.get.arctype$^  $^    cpdef arciterator arcsself int00 state              $^      $^      arcsself state$^ $^$^static pyobject pyxpw0pywrapfst0fst00arcspyobject pyxvself pyobject pyxargstate proto$^static struct pyxobj0pywrapfstarciterator pyxf0pywrapfst0fstarcsstruct pyxobj0pywrapfstfst pyxvself pyxt00basictypesint00 pyxvstate int pyxskipdispatch $^  struct pyxobj0pywrapfstarciterator pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextarcs 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnsarcs if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst0fst00arcs $^      pyxxdecrefpyobject pyxr$^      pyxt0  pyxpyintfromint00tpyxvstate if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxgotrefpyxt0$^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^       else $^        if cythonfastpycall$^        if pyfunctioncheckpyxt0 $^          pyobject pyxtemp0  pyxt0 pyxt0$^          pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^          pyxxdecrefpyxt0 pyxt0  0$^          pyxgotrefpyxt0$^          pyxdecrefpyxt0 pyxt0  0$^         else$^        endif$^        if cythonfastpyccall$^        if pyxpyfastcfunctioncheckpyxt0 $^          pyobject pyxtemp0  pyxt0 pyxt0$^          pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^          pyxxdecrefpyxt0 pyxt0  0$^          pyxgotrefpyxt0$^          pyxdecrefpyxt0 pyxt0  0$^         else$^        endif$^        $^          pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^          pyxgotrefpyxt0$^          pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^          pyxgiverefpyxt0$^          pytuplesetitempyxt0 00 pyxt0$^          pyxt0  0$^          pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^          pyxgotrefpyxt0$^          pyxdecrefpyxt0 pyxt0  0$^        $^      $^      pyxdecrefpyxt0 pyxt0  0$^      if likelypyxt0  pynone  likelypyxtypetestpyxt0 pyxptype0pywrapfstarciterator pyxerr0 0000 pyxl0error$^      pyxr  struct pyxobj0pywrapfstarciterator pyxt0$^      pyxt0  0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx0000$^      see also mutablearcs states.$^      $^      return arciteratorself state              $^  $^    cpdef fst copyself$^ $^  pyxxdecrefpyobject pyxr$^  pyxt0  pyxpyintfromint00tpyxvstate if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxt0  pytuplenew0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxincrefpyobject pyxvself$^  pyxgiverefpyobject pyxvself$^  pytuplesetitempyxt0 0 pyobject pyxvself$^  pyxgiverefpyxt0$^  pytuplesetitempyxt0 0 pyxt0$^  pyxt0  0$^  pyxt0  pyxpyobjectcallpyobject pyxptype0pywrapfstarciterator pyxt0 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxdecrefpyxt0 pyxt0  0$^  pyxr  struct pyxobj0pywrapfstarciterator pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      return self.fst.get.arctype$^  $^    cpdef arciterator arcsself int00 state              $^      $^      arcsself state$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.fst.arcs pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxl0$^  pyxxgiverefpyobject pyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst0fst00arcspyobject pyxvself pyobject pyxargstate proto$^static char pyxdoc0pywrapfst0fst00arcs  n    arcsself statenn    returns an iterator over arcs leaving the specified state.nn    argsn      state the source state id.nn    returnsn      an arciterator.nn    see also mutablearcs states.n    $^static pyobject pyxpw0pywrapfst0fst00arcspyobject pyxvself pyobject pyxargstate $^  pyxt00basictypesint00 pyxvstate$^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextarcs wrapper 0$^  assertpyxargstate $^    pyxvstate  pyxpyintasint00tpyxargstate if unlikelypyxvstate  int00t0  pyerroccurred pyxerr0 0000 pyxl0error$^  $^  goto pyxl0argumentunpackingdone$^  pyxl0error$^  pyxaddtracebackpywrapfst.fst.arcs pyxclineno pyxlineno pyxfilename$^  pyxrefnannyfinishcontext$^  return null$^  pyxl0argumentunpackingdone$^  pyxr  pyxpf0pywrapfst0fst00arcsstruct pyxobj0pywrapfstfst pyxvself pyxt00basictypesint00pyxvstate$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst0fst00arcsstruct pyxobj0pywrapfstfst pyxvself pyxt00basictypesint00 pyxvstate $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextarcs 0$^  pyxxdecrefpyxr$^  pyxt0  pyobject pyxf0pywrapfst0fstarcspyxvself pyxvstate 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.fst.arcs pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return arciteratorself state$^  $^    cpdef fst copyself              $^      $^      copyself$^ $^$^static pyobject pyxpw0pywrapfst0fst00copypyobject pyxvself cythonunused pyobject unused proto$^static struct pyxobj0pywrapfstfst pyxf0pywrapfst0fstcopystruct pyxobj0pywrapfstfst pyxvself int pyxskipdispatch $^  struct pyxobj0pywrapfstfst pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextcopy 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnscopy if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst0fst00copy $^      pyxxdecrefpyobject pyxr$^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxdecrefpyxt0 pyxt0  0$^       else $^        pyxt0  pyxpyobjectcallnoargpyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      $^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      if likelypyxt0  pynone  likelypyxtypetestpyxt0 pyxptype0pywrapfstfst pyxerr0 0000 pyxl0error$^      pyxr  struct pyxobj0pywrapfstfst pyxt0$^      pyxt0  0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx0000$^      makes a copy of the fst.$^      $^      return initxfstnew fst.fstclassderefself.fst              $^  $^    cpdef void drawself$^ $^  pyxxdecrefpyobject pyxr$^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s fst$^    pyxerr0 0000 pyxl0error$^  $^  pyxt0  pyobject pyxf0pywrapfstinitxfstnew fstscriptfstclasspyxvselffst if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  struct pyxobj0pywrapfstfst pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      return arciteratorself state$^  $^    cpdef fst copyself              $^      $^      copyself$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.fst.copy pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxl0$^  pyxxgiverefpyobject pyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst0fst00copypyobject pyxvself cythonunused pyobject unused proto$^static char pyxdoc0pywrapfst0fst00copy  n    copyselfnn    makes a copy of the fst.n    $^static pyobject pyxpw0pywrapfst0fst00copypyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextcopy wrapper 0$^  pyxr  pyxpf0pywrapfst0fst00copystruct pyxobj0pywrapfstfst pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst0fst00copystruct pyxobj0pywrapfstfst pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextcopy 0$^  pyxxdecrefpyxr$^  pyxt0  pyobject pyxf0pywrapfst0fstcopypyxvself 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.fst.copy pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return initxfstnew fst.fstclassderefself.fst$^  $^    cpdef void drawself              $^                    filename$^                    symboltable isymbolsnone$^ $^$^static pyobject pyxpw0pywrapfst0fst00drawpyobject pyxvself pyobject pyxargs pyobject pyxkwds proto$^static void pyxf0pywrapfst0fstdrawstruct pyxobj0pywrapfstfst pyxvself pyobject pyxvfilename int pyxskipdispatch struct pyxoptargs0pywrapfst0fstdraw pyxoptionalargs $^$^   pywrapfst.pyx0000$^    cpdef void drawself$^                    filename$^                    symboltable isymbolsnone              $^                    symboltable osymbolsnone$^                    symboltable ssymbolsnone$^ $^  struct pyxobj0pywrapfstsymboltable pyxvisymbols  struct pyxobj0pywrapfstsymboltable pynone$^$^   pywrapfst.pyx0000$^                    filename$^                    symboltable isymbolsnone$^                    symboltable osymbolsnone              $^                    symboltable ssymbolsnone$^                    bool acceptorfalse$^ $^  struct pyxobj0pywrapfstsymboltable pyxvosymbols  struct pyxobj0pywrapfstsymboltable pynone$^$^   pywrapfst.pyx0000$^                    symboltable isymbolsnone$^                    symboltable osymbolsnone$^                    symboltable ssymbolsnone              $^                    bool acceptorfalse$^                    titleb$^ $^  struct pyxobj0pywrapfstsymboltable pyxvssymbols  struct pyxobj0pywrapfstsymboltable pynone$^$^   pywrapfst.pyx0000$^                    symboltable osymbolsnone$^                    symboltable ssymbolsnone$^                    bool acceptorfalse              $^                    titleb$^                    double width0.0$^ $^  bool pyxvacceptor  bool0$^  pyobject pyxvtitle  pyobject pyxkpb00$^  double pyxvwidth  double0.0$^  double pyxvheight  double00.0$^$^   pywrapfst.pyx0000$^                    double width0.0$^                    double height00$^                    bool portraitfalse              $^                    bool verticalfalse$^                    double ranksep0.0$^ $^  bool pyxvportrait  bool0$^$^   pywrapfst.pyx0000$^                    double height00$^                    bool portraitfalse$^                    bool verticalfalse              $^                    double ranksep0.0$^                    double nodesep0.00$^ $^  bool pyxvvertical  bool0$^  double pyxvranksep  double0.0$^  double pyxvnodesep  double0.00$^  pyxt00basictypesint00 pyxvfontsize  pyxt00basictypesint0000$^  pyxt00basictypesint00 pyxvprecision  pyxt00basictypesint000$^  pyobject pyxvfloatformat  pyobject pyxnbg$^$^   pywrapfst.pyx0000$^                    int00 precision0$^                    floatformatbg$^                    bool showweightonefalse              $^      $^      drawself filename isymbolsnone osymbolsnone ssymbolsnone$^ $^  bool pyxvshowweightone  bool0$^  stdstring pyxvfilenamestring$^  stduniqueptrstdofstream  pyxvostrm$^  fstsymboltable pyxvssymbolsptr$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt00  null$^  pyobject pyxt00  null$^  pyobject pyxt00  null$^  pyobject pyxt00  null$^  pyobject pyxt00  null$^  int pyxt00$^  pyobject pyxt00  null$^  stdstring pyxt00$^  int pyxt00$^  int pyxt00$^  fstsymboltable pyxt00$^  fstsymboltable const pyxt00$^  fstsymboltable const pyxt00$^  stdstring pyxt00$^  pyxrefnannysetupcontextdraw 0$^  if pyxoptionalargs $^    if pyxoptionalargspyxn  0 $^      pyxvisymbols  pyxoptionalargsisymbols$^      if pyxoptionalargspyxn  0 $^        pyxvosymbols  pyxoptionalargsosymbols$^        if pyxoptionalargspyxn  0 $^          pyxvssymbols  pyxoptionalargsssymbols$^          if pyxoptionalargspyxn  0 $^            pyxvacceptor  pyxoptionalargsacceptor$^            if pyxoptionalargspyxn  0 $^              pyxvtitle  pyxoptionalargstitle$^              if pyxoptionalargspyxn  0 $^                pyxvwidth  pyxoptionalargswidth$^                if pyxoptionalargspyxn  0 $^                  pyxvheight  pyxoptionalargsheight$^                  if pyxoptionalargspyxn  0 $^                    pyxvportrait  pyxoptionalargsportrait$^                    if pyxoptionalargspyxn  0 $^                      pyxvvertical  pyxoptionalargsvertical$^                      if pyxoptionalargspyxn  0 $^                        pyxvranksep  pyxoptionalargsranksep$^                        if pyxoptionalargspyxn  00 $^                          pyxvnodesep  pyxoptionalargsnodesep$^                          if pyxoptionalargspyxn  00 $^                            pyxvfontsize  pyxoptionalargsfontsize$^                            if pyxoptionalargspyxn  00 $^                              pyxvprecision  pyxoptionalargsprecision$^                              if pyxoptionalargspyxn  00 $^                                pyxvfloatformat  pyxoptionalargsfloatformat$^                                if pyxoptionalargspyxn  00 $^                                  pyxvshowweightone  pyxoptionalargsshowweightone$^                                $^                              $^                            $^                          $^                        $^                      $^                    $^                  $^                $^              $^            $^          $^        $^      $^    $^  $^$^   pywrapfst.pyx0000$^      return initxfstnew fst.fstclassderefself.fst$^  $^    cpdef void drawself              $^                    filename$^                    symboltable isymbolsnone$^ $^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnsdraw if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst0fst00draw $^      pyxt0  pyxpyboolfromlongpyxvacceptor if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxgotrefpyxt0$^      pyxt0  pyfloatfromdoublepyxvwidth if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxgotrefpyxt0$^      pyxt0  pyfloatfromdoublepyxvheight if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxgotrefpyxt0$^      pyxt0  pyxpyboolfromlongpyxvportrait if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxgotrefpyxt0$^      pyxt0  pyxpyboolfromlongpyxvvertical if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxgotrefpyxt0$^      pyxt0  pyfloatfromdoublepyxvranksep if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxgotrefpyxt0$^      pyxt0  pyfloatfromdoublepyxvnodesep if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxgotrefpyxt0$^      pyxt00  pyxpyintfromint00tpyxvfontsize if unlikelypyxt00 pyxerr0 0000 pyxl0error$^      pyxgotrefpyxt00$^      pyxt00  pyxpyintfromint00tpyxvprecision if unlikelypyxt00 pyxerr0 0000 pyxl0error$^      pyxgotrefpyxt00$^      pyxt00  pyxpyboolfromlongpyxvshowweightone if unlikelypyxt00 pyxerr0 0000 pyxl0error$^      pyxgotrefpyxt00$^      pyxincrefpyxt0$^      pyxt00  pyxt0 pyxt00  null$^      pyxt00  0$^      if cythonunpackmethods  unlikelypymethodcheckpyxt00 $^        pyxt00  pymethodgetselfpyxt00$^        if likelypyxt00 $^          pyobject function  pymethodgetfunctionpyxt00$^          pyxincrefpyxt00$^          pyxincreffunction$^          pyxdecrefsetpyxt00 function$^          pyxt00  0$^        $^      $^      if cythonfastpycall$^      if pyfunctioncheckpyxt00 $^        pyobject pyxtemp00  pyxt00 pyxvfilename pyobject pyxvisymbols pyobject pyxvosymbols pyobject pyxvssymbols pyxt0 pyxvtitle pyxt0 pyxt0 pyxt0 pyxt0 pyxt0 pyxt0 pyxt00 pyxt00 pyxvfloatformat pyxt00$^        pyxt0  pyxpyfunctionfastcallpyxt00 pyxtemp0pyxt00 00pyxt00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxxdecrefpyxt00 pyxt00  0$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^        pyxdecrefpyxt0 pyxt0  0$^        pyxdecrefpyxt0 pyxt0  0$^        pyxdecrefpyxt0 pyxt0  0$^        pyxdecrefpyxt0 pyxt0  0$^        pyxdecrefpyxt0 pyxt0  0$^        pyxdecrefpyxt0 pyxt0  0$^        pyxdecrefpyxt00 pyxt00  0$^        pyxdecrefpyxt00 pyxt00  0$^        pyxdecrefpyxt00 pyxt00  0$^       else$^      endif$^      if cythonfastpyccall$^      if pyxpyfastcfunctioncheckpyxt00 $^        pyobject pyxtemp00  pyxt00 pyxvfilename pyobject pyxvisymbols pyobject pyxvosymbols pyobject pyxvssymbols pyxt0 pyxvtitle pyxt0 pyxt0 pyxt0 pyxt0 pyxt0 pyxt0 pyxt00 pyxt00 pyxvfloatformat pyxt00$^        pyxt0  pyxpycfunctionfastcallpyxt00 pyxtemp0pyxt00 00pyxt00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxxdecrefpyxt00 pyxt00  0$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^        pyxdecrefpyxt0 pyxt0  0$^        pyxdecrefpyxt0 pyxt0  0$^        pyxdecrefpyxt0 pyxt0  0$^        pyxdecrefpyxt0 pyxt0  0$^        pyxdecrefpyxt0 pyxt0  0$^        pyxdecrefpyxt0 pyxt0  0$^        pyxdecrefpyxt00 pyxt00  0$^        pyxdecrefpyxt00 pyxt00  0$^        pyxdecrefpyxt00 pyxt00  0$^       else$^      endif$^      $^        pyxt00  pytuplenew00pyxt00 if unlikelypyxt00 pyxerr0 0000 pyxl0error$^        pyxgotrefpyxt00$^        if pyxt00 $^          pyxgiverefpyxt00 pytuplesetitempyxt00 0 pyxt00 pyxt00  null$^        $^        pyxincrefpyxvfilename$^        pyxgiverefpyxvfilename$^        pytuplesetitempyxt00 0pyxt00 pyxvfilename$^        pyxincrefpyobject pyxvisymbols$^        pyxgiverefpyobject pyxvisymbols$^        pytuplesetitempyxt00 0pyxt00 pyobject pyxvisymbols$^        pyxincrefpyobject pyxvosymbols$^        pyxgiverefpyobject pyxvosymbols$^        pytuplesetitempyxt00 0pyxt00 pyobject pyxvosymbols$^        pyxincrefpyobject pyxvssymbols$^        pyxgiverefpyobject pyxvssymbols$^        pytuplesetitempyxt00 0pyxt00 pyobject pyxvssymbols$^        pyxgiverefpyxt0$^        pytuplesetitempyxt00 0pyxt00 pyxt0$^        pyxincrefpyxvtitle$^        pyxgiverefpyxvtitle$^        pytuplesetitempyxt00 0pyxt00 pyxvtitle$^        pyxgiverefpyxt0$^        pytuplesetitempyxt00 0pyxt00 pyxt0$^        pyxgiverefpyxt0$^        pytuplesetitempyxt00 0pyxt00 pyxt0$^        pyxgiverefpyxt0$^        pytuplesetitempyxt00 0pyxt00 pyxt0$^        pyxgiverefpyxt0$^        pytuplesetitempyxt00 0pyxt00 pyxt0$^        pyxgiverefpyxt0$^        pytuplesetitempyxt00 00pyxt00 pyxt0$^        pyxgiverefpyxt0$^        pytuplesetitempyxt00 00pyxt00 pyxt0$^        pyxgiverefpyxt00$^        pytuplesetitempyxt00 00pyxt00 pyxt00$^        pyxgiverefpyxt00$^        pytuplesetitempyxt00 00pyxt00 pyxt00$^        pyxincrefpyxvfloatformat$^        pyxgiverefpyxvfloatformat$^        pytuplesetitempyxt00 00pyxt00 pyxvfloatformat$^        pyxgiverefpyxt00$^        pytuplesetitempyxt00 00pyxt00 pyxt00$^        pyxt0  0$^        pyxt0  0$^        pyxt0  0$^        pyxt0  0$^        pyxt0  0$^        pyxt0  0$^        pyxt0  0$^        pyxt00  0$^        pyxt00  0$^        pyxt00  0$^        pyxt0  pyxpyobjectcallpyxt00 pyxt00 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxgotrefpyxt0$^        pyxdecrefpyxt00 pyxt00  0$^      $^      pyxdecrefpyxt00 pyxt00  0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx0000$^      see also text.$^      $^      cdef string filenamestring  tostringfilename              $^      cdef uniqueptrofstream ostrm$^      ostrm.resetnew ofstreamfilenamestring$^ $^  pyxt00  pyxf0pywrapfsttostringpyxvfilename null if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^  pyxvfilenamestring  pyxt00$^$^   pywrapfst.pyx0000$^      cdef string filenamestring  tostringfilename$^      cdef uniqueptrofstream ostrm$^      ostrm.resetnew ofstreamfilenamestring              $^      cdef fst.symboltable ssymbolsptr  null$^      if ssymbols is not none$^ $^  pyxvostrm.resetnew stdofstreampyxvfilenamestring$^$^   pywrapfst.pyx0000$^      cdef uniqueptrofstream ostrm$^      ostrm.resetnew ofstreamfilenamestring$^      cdef fst.symboltable ssymbolsptr  null              $^      if ssymbols is not none$^        ssymbolsptr  ssymbols.table$^ $^  pyxvssymbolsptr  null$^$^   pywrapfst.pyx0000$^      ostrm.resetnew ofstreamfilenamestring$^      cdef fst.symboltable ssymbolsptr  null$^      if ssymbols is not none              $^        ssymbolsptr  ssymbols.table$^      fst.drawfstderefself.fst$^ $^  pyxt00  pyobject pyxvssymbols  pynone$^  pyxt00  pyxt00  0$^  if pyxt00 $^$^     pywrapfst.pyx0000$^      cdef fst.symboltable ssymbolsptr  null$^      if ssymbols is not none$^        ssymbolsptr  ssymbols.table              $^      fst.drawfstderefself.fst$^          self.fst.get.inputsymbols if isymbols is none$^ $^    if unlikelypyobject pyxvssymbols  pynone $^      pyerrformatpyexcattributeerror nonetype object has no attribute .00s table$^      pyxerr0 0000 pyxl0error$^    $^    pyxt00  pyxvssymbolspyxbase.pyxbase.table$^    pyxvssymbolsptr  pyxt00$^$^     pywrapfst.pyx0000$^      ostrm.resetnew ofstreamfilenamestring$^      cdef fst.symboltable ssymbolsptr  null$^      if ssymbols is not none              $^        ssymbolsptr  ssymbols.table$^      fst.drawfstderefself.fst$^ $^  $^$^   pywrapfst.pyx0000$^      if ssymbols is not none$^        ssymbolsptr  ssymbols.table$^      fst.drawfstderefself.fst              $^          self.fst.get.inputsymbols if isymbols is none$^          else isymbols.table$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s fst$^    pyxerr0 0000 pyxl0error$^  $^$^   pywrapfst.pyx0000$^        ssymbolsptr  ssymbols.table$^      fst.drawfstderefself.fst$^          self.fst.get.inputsymbols if isymbols is none              $^          else isymbols.table$^          self.fst.get.outputsymbols if osymbols is none$^ $^  pyxt00  pyobject pyxvisymbols  pynone$^  if pyxt00  0 $^    if unlikelypyobject pyxvself  pynone $^      pyerrformatpyexcattributeerror nonetype object has no attribute .00s fst$^      pyxerr0 0000 pyxl0error$^    $^    pyxt00  pyxvselffst.getinputsymbols$^   else $^$^     pywrapfst.pyx0000$^      fst.drawfstderefself.fst$^          self.fst.get.inputsymbols if isymbols is none$^          else isymbols.table              $^          self.fst.get.outputsymbols if osymbols is none$^          else osymbols.table$^ $^    if unlikelypyobject pyxvisymbols  pynone $^      pyerrformatpyexcattributeerror nonetype object has no attribute .00s table$^      pyxerr0 0000 pyxl0error$^    $^    pyxt00  pyxvisymbolstable$^  $^$^   pywrapfst.pyx0000$^          self.fst.get.inputsymbols if isymbols is none$^          else isymbols.table$^          self.fst.get.outputsymbols if osymbols is none              $^          else osymbols.table$^          ssymbolsptr acceptor tostringtitle width height portrait$^ $^  pyxt00  pyobject pyxvosymbols  pynone$^  if pyxt00  0 $^    if unlikelypyobject pyxvself  pynone $^      pyerrformatpyexcattributeerror nonetype object has no attribute .00s fst$^      pyxerr0 0000 pyxl0error$^    $^    pyxt00  pyxvselffst.getoutputsymbols$^   else $^$^     pywrapfst.pyx0000$^          else isymbols.table$^          self.fst.get.outputsymbols if osymbols is none$^          else osymbols.table              $^          ssymbolsptr acceptor tostringtitle width height portrait$^          vertical ranksep nodesep fontsize precision$^ $^    if unlikelypyobject pyxvosymbols  pynone $^      pyerrformatpyexcattributeerror nonetype object has no attribute .00s table$^      pyxerr0 0000 pyxl0error$^    $^    pyxt00  pyxvosymbolstable$^  $^$^   pywrapfst.pyx0000$^          self.fst.get.outputsymbols if osymbols is none$^          else osymbols.table$^          ssymbolsptr acceptor tostringtitle width height portrait              $^          vertical ranksep nodesep fontsize precision$^          tostringfloatformat showweightone ostrm.get$^ $^  pyxt00  pyxf0pywrapfsttostringpyxvtitle null if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^          ssymbolsptr acceptor tostringtitle width height portrait$^          vertical ranksep nodesep fontsize precision$^          tostringfloatformat showweightone ostrm.get              $^          filenamestring$^  $^ $^  pyxt00  pyxf0pywrapfsttostringpyxvfloatformat null if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^      if ssymbols is not none$^        ssymbolsptr  ssymbols.table$^      fst.drawfstderefself.fst              $^          self.fst.get.inputsymbols if isymbols is none$^          else isymbols.table$^ $^  fstscriptdrawfstpyxvselffst pyxt00 pyxt00 pyxvssymbolsptr pyxvacceptor pyxt00 pyxvwidth pyxvheight pyxvportrait pyxvvertical pyxvranksep pyxvnodesep pyxvfontsize pyxvprecision pyxt00 pyxvshowweightone pyxvostrm.get pyxvfilenamestring$^$^   pywrapfst.pyx0000$^      return initxfstnew fst.fstclassderefself.fst$^  $^    cpdef void drawself              $^                    filename$^                    symboltable isymbolsnone$^ $^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt00$^  pyxxdecrefpyxt00$^  pyxxdecrefpyxt00$^  pyxxdecrefpyxt00$^  pyxxdecrefpyxt00$^  pyxxdecrefpyxt00$^  pyxwriteunraisablepywrapfst.fst.draw pyxclineno pyxlineno pyxfilename 0 0$^  pyxl0$^  pyxrefnannyfinishcontext$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst0fst00drawpyobject pyxvself pyobject pyxargs pyobject pyxkwds proto$^static char pyxdoc0pywrapfst0fst00draw  n    drawself filename isymbolsnone osymbolsnone ssymbolsnonen         acceptorfalse title width0.0 height00 portraitfalsen         verticalfalse ranksep0.0 nodesep0.00 fontsize00n         precision0 floatformatg showweightonefalsenn    writes out the fst in graphviz text format.nn    this method writes out the fst in the dot graph description language. then    graph can be rendered using the dot executable provided by graphviz.nn    argsn      filename the string location of the output dotgraphviz file.n      isymbols an optional symbol table used to label input symbols.n      osymbols an optional symbol table used to label output symbols.n      ssymbols an optional symbol table used to label states.n      acceptor should the figure be rendered in acceptor format if possiblen      title an optional string indicating the figure title.n      width the figure width in inches.n      height the figure height in inches.n      portrait should the figure be rendered in portrait rather thann          landscapen      vertical should the figure be rendered bottomtotop rather thann          lefttorightn      ranksep the minimum separation separation between ranks in inches.n      nodesep the minimum separation between nodes in inches.n      fontsize font size in points.n      precision numeric precision for floats in number of chars.n      floatformat one of e f or g.n      showweightone should weights equivalent to semiring one be printednn    see also text.n    $^static pyobject pyxpw0pywrapfst0fst00drawpyobject pyxvself pyobject pyxargs pyobject pyxkwds $^  pyobject pyxvfilename  0$^  struct pyxobj0pywrapfstsymboltable pyxvisymbols  0$^  struct pyxobj0pywrapfstsymboltable pyxvosymbols  0$^  struct pyxobj0pywrapfstsymboltable pyxvssymbols  0$^  bool pyxvacceptor$^  pyobject pyxvtitle  0$^  double pyxvwidth$^  double pyxvheight$^  bool pyxvportrait$^  bool pyxvvertical$^  double pyxvranksep$^  double pyxvnodesep$^  pyxt00basictypesint00 pyxvfontsize$^  pyxt00basictypesint00 pyxvprecision$^  pyobject pyxvfloatformat  0$^  bool pyxvshowweightone$^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextdraw wrapper 0$^  $^    static pyobject pyxpyargnames  pyxnsfilenamepyxnsisymbolspyxnsosymbolspyxnsssymbolspyxnsacceptorpyxnstitlepyxnswidthpyxnsheightpyxnsportraitpyxnsverticalpyxnsrankseppyxnsnodeseppyxnsfontsizepyxnsprecisionpyxnsfloatformatpyxnsshowweightone0$^    pyobject values00  0000000000000000$^$^     pywrapfst.pyx0000$^    cpdef void drawself$^                    filename$^                    symboltable isymbolsnone              $^                    symboltable osymbolsnone$^                    symboltable ssymbolsnone$^ $^    values0  pyobject struct pyxobj0pywrapfstsymboltable pynone$^$^     pywrapfst.pyx0000$^                    filename$^                    symboltable isymbolsnone$^                    symboltable osymbolsnone              $^                    symboltable ssymbolsnone$^                    bool acceptorfalse$^ $^    values0  pyobject struct pyxobj0pywrapfstsymboltable pynone$^$^     pywrapfst.pyx0000$^                    symboltable isymbolsnone$^                    symboltable osymbolsnone$^                    symboltable ssymbolsnone              $^                    bool acceptorfalse$^                    titleb$^ $^    values0  pyobject struct pyxobj0pywrapfstsymboltable pynone$^    values0  pyobject pyxkpb00$^    values00  pyobject pyxnbg$^    if unlikelypyxkwds $^      pyssizet kwargs$^      const pyssizet posargs  pytuplegetsizepyxargs$^      switch posargs $^        case 00 values00  pytuplegetitempyxargs 00$^        cythonfallthrough$^        case 00 values00  pytuplegetitempyxargs 00$^        cythonfallthrough$^        case 00 values00  pytuplegetitempyxargs 00$^        cythonfallthrough$^        case 00 values00  pytuplegetitempyxargs 00$^        cythonfallthrough$^        case 00 values00  pytuplegetitempyxargs 00$^        cythonfallthrough$^        case 00 values00  pytuplegetitempyxargs 00$^        cythonfallthrough$^        case 00 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 break$^        default goto pyxl0argtupleerror$^      $^      kwargs  pydictsizepyxkwds$^      switch posargs $^        case  0$^        if likelyvalues0  pydictgetitempyxkwds pyxnsfilename  0 kwargs$^        else goto pyxl0argtupleerror$^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pydictgetitempyxkwds pyxnsisymbols$^          if value  values0  value kwargs $^        $^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pydictgetitempyxkwds pyxnsosymbols$^          if value  values0  value kwargs $^        $^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pydictgetitempyxkwds pyxnsssymbols$^          if value  values0  value kwargs $^        $^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pydictgetitempyxkwds pyxnsacceptor$^          if value  values0  value kwargs $^        $^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pydictgetitempyxkwds pyxnstitle$^          if value  values0  value kwargs $^        $^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pydictgetitempyxkwds pyxnswidth$^          if value  values0  value kwargs $^        $^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pydictgetitempyxkwds pyxnsheight$^          if value  values0  value kwargs $^        $^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pydictgetitempyxkwds pyxnsportrait$^          if value  values0  value kwargs $^        $^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pydictgetitempyxkwds pyxnsvertical$^          if value  values0  value kwargs $^        $^        cythonfallthrough$^        case 00$^        if kwargs  0 $^          pyobject value  pydictgetitempyxkwds pyxnsranksep$^          if value  values00  value kwargs $^        $^        cythonfallthrough$^        case 00$^        if kwargs  0 $^          pyobject value  pydictgetitempyxkwds pyxnsnodesep$^          if value  values00  value kwargs $^        $^        cythonfallthrough$^        case 00$^        if kwargs  0 $^          pyobject value  pydictgetitempyxkwds pyxnsfontsize$^          if value  values00  value kwargs $^        $^        cythonfallthrough$^        case 00$^        if kwargs  0 $^          pyobject value  pydictgetitempyxkwds pyxnsprecision$^          if value  values00  value kwargs $^        $^        cythonfallthrough$^        case 00$^        if kwargs  0 $^          pyobject value  pydictgetitempyxkwds pyxnsfloatformat$^          if value  values00  value kwargs $^        $^        cythonfallthrough$^        case 00$^        if kwargs  0 $^          pyobject value  pydictgetitempyxkwds pyxnsshowweightone$^          if value  values00  value kwargs $^        $^      $^      if unlikelykwargs  0 $^        if unlikelypyxparseoptionalkeywordspyxkwds pyxpyargnames 0 values posargs draw  0 pyxerr0 0000 pyxl0error$^      $^     else $^      switch pytuplegetsizepyxargs $^        case 00 values00  pytuplegetitempyxargs 00$^        cythonfallthrough$^        case 00 values00  pytuplegetitempyxargs 00$^        cythonfallthrough$^        case 00 values00  pytuplegetitempyxargs 00$^        cythonfallthrough$^        case 00 values00  pytuplegetitempyxargs 00$^        cythonfallthrough$^        case 00 values00  pytuplegetitempyxargs 00$^        cythonfallthrough$^        case 00 values00  pytuplegetitempyxargs 00$^        cythonfallthrough$^        case 00 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        break$^        default goto pyxl0argtupleerror$^      $^    $^    pyxvfilename  values0$^    pyxvisymbols  struct pyxobj0pywrapfstsymboltable values0$^    pyxvosymbols  struct pyxobj0pywrapfstsymboltable values0$^    pyxvssymbols  struct pyxobj0pywrapfstsymboltable values0$^    if values0 $^      pyxvacceptor  pyxpyobjectistruevalues0 if unlikelypyxvacceptor  bool0  pyerroccurred pyxerr0 0000 pyxl0error$^     else $^$^       pywrapfst.pyx0000$^                    symboltable osymbolsnone$^                    symboltable ssymbolsnone$^                    bool acceptorfalse              $^                    titleb$^                    double width0.0$^ $^      pyxvacceptor  bool0$^    $^    pyxvtitle  values0$^    if values0 $^      pyxvwidth  pyxpyfloatasdoublevalues0 if unlikelypyxvwidth  double0  pyerroccurred pyxerr0 0000 pyxl0error$^     else $^      pyxvwidth  double0.0$^    $^    if values0 $^      pyxvheight  pyxpyfloatasdoublevalues0 if unlikelypyxvheight  double0  pyerroccurred pyxerr0 0000 pyxl0error$^     else $^      pyxvheight  double00.0$^    $^    if values0 $^      pyxvportrait  pyxpyobjectistruevalues0 if unlikelypyxvportrait  bool0  pyerroccurred pyxerr0 0000 pyxl0error$^     else $^$^       pywrapfst.pyx0000$^                    double width0.0$^                    double height00$^                    bool portraitfalse              $^                    bool verticalfalse$^                    double ranksep0.0$^ $^      pyxvportrait  bool0$^    $^    if values0 $^      pyxvvertical  pyxpyobjectistruevalues0 if unlikelypyxvvertical  bool0  pyerroccurred pyxerr0 0000 pyxl0error$^     else $^$^       pywrapfst.pyx0000$^                    double height00$^                    bool portraitfalse$^                    bool verticalfalse              $^                    double ranksep0.0$^                    double nodesep0.00$^ $^      pyxvvertical  bool0$^    $^    if values00 $^      pyxvranksep  pyxpyfloatasdoublevalues00 if unlikelypyxvranksep  double0  pyerroccurred pyxerr0 0000 pyxl0error$^     else $^      pyxvranksep  double0.0$^    $^    if values00 $^      pyxvnodesep  pyxpyfloatasdoublevalues00 if unlikelypyxvnodesep  double0  pyerroccurred pyxerr0 0000 pyxl0error$^     else $^      pyxvnodesep  double0.00$^    $^    if values00 $^      pyxvfontsize  pyxpyintasint00tvalues00 if unlikelypyxvfontsize  int00t0  pyerroccurred pyxerr0 0000 pyxl0error$^     else $^      pyxvfontsize  pyxt00basictypesint0000$^    $^    if values00 $^      pyxvprecision  pyxpyintasint00tvalues00 if unlikelypyxvprecision  int00t0  pyerroccurred pyxerr0 0000 pyxl0error$^     else $^      pyxvprecision  pyxt00basictypesint000$^    $^    pyxvfloatformat  values00$^    if values00 $^      pyxvshowweightone  pyxpyobjectistruevalues00 if unlikelypyxvshowweightone  bool0  pyerroccurred pyxerr0 0000 pyxl0error$^     else $^$^       pywrapfst.pyx0000$^                    int00 precision0$^                    floatformatbg$^                    bool showweightonefalse              $^      $^      drawself filename isymbolsnone osymbolsnone ssymbolsnone$^ $^      pyxvshowweightone  bool0$^    $^  $^  goto pyxl0argumentunpackingdone$^  pyxl0argtupleerror$^  pyxraiseargtupleinvaliddraw 0 0 00 pytuplegetsizepyxargs pyxerr0 0000 pyxl0error$^  pyxl0error$^  pyxaddtracebackpywrapfst.fst.draw pyxclineno pyxlineno pyxfilename$^  pyxrefnannyfinishcontext$^  return null$^  pyxl0argumentunpackingdone$^  if unlikelypyxargtypetestpyobject pyxvisymbols pyxptype0pywrapfstsymboltable 0 isymbols 0 pyxerr0 0000 pyxl0error$^  if unlikelypyxargtypetestpyobject pyxvosymbols pyxptype0pywrapfstsymboltable 0 osymbols 0 pyxerr0 0000 pyxl0error$^  if unlikelypyxargtypetestpyobject pyxvssymbols pyxptype0pywrapfstsymboltable 0 ssymbols 0 pyxerr0 0000 pyxl0error$^  pyxr  pyxpf0pywrapfst0fst00drawstruct pyxobj0pywrapfstfst pyxvself pyxvfilename pyxvisymbols pyxvosymbols pyxvssymbols pyxvacceptor pyxvtitle pyxvwidth pyxvheight pyxvportrait pyxvvertical pyxvranksep pyxvnodesep pyxvfontsize pyxvprecision pyxvfloatformat pyxvshowweightone$^$^   pywrapfst.pyx0000$^      return initxfstnew fst.fstclassderefself.fst$^  $^    cpdef void drawself              $^                    filename$^                    symboltable isymbolsnone$^ $^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxr  null$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst0fst00drawstruct pyxobj0pywrapfstfst pyxvself pyobject pyxvfilename struct pyxobj0pywrapfstsymboltable pyxvisymbols struct pyxobj0pywrapfstsymboltable pyxvosymbols struct pyxobj0pywrapfstsymboltable pyxvssymbols bool pyxvacceptor pyobject pyxvtitle double pyxvwidth double pyxvheight bool pyxvportrait bool pyxvvertical double pyxvranksep double pyxvnodesep pyxt00basictypesint00 pyxvfontsize pyxt00basictypesint00 pyxvprecision pyobject pyxvfloatformat bool pyxvshowweightone $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  struct pyxoptargs0pywrapfst0fstdraw pyxt0$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextdraw 0$^  pyxxdecrefpyxr$^  pyxt0.pyxn  00$^  pyxt0.isymbols  pyxvisymbols$^  pyxt0.osymbols  pyxvosymbols$^  pyxt0.ssymbols  pyxvssymbols$^  pyxt0.acceptor  pyxvacceptor$^  pyxt0.title  pyxvtitle$^  pyxt0.width  pyxvwidth$^  pyxt0.height  pyxvheight$^  pyxt0.portrait  pyxvportrait$^  pyxt0.vertical  pyxvvertical$^  pyxt0.ranksep  pyxvranksep$^  pyxt0.nodesep  pyxvnodesep$^  pyxt0.fontsize  pyxvfontsize$^  pyxt0.precision  pyxvprecision$^  pyxt0.floatformat  pyxvfloatformat$^  pyxt0.showweightone  pyxvshowweightone$^  pyxvtabptr0pywrapfstfstdrawpyxvself pyxvfilename 0 pyxt0 $^  pyxt0  pyxvoidtononenull if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.fst.draw pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^          filenamestring$^  $^    cpdef weight finalself int00 state              $^      $^      finalself state$^ $^$^static pyobject pyxpw0pywrapfst0fst00finalpyobject pyxvself pyobject pyxargstate proto$^static struct pyxobj0pywrapfstweight pyxf0pywrapfst0fstfinalstruct pyxobj0pywrapfstfst pyxvself pyxt00basictypesint00 pyxvstate int pyxskipdispatch $^  struct pyxobj0pywrapfstweight pyxvweight  0$^  struct pyxobj0pywrapfstweight pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextfinal 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnsfinal if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst0fst00final $^      pyxxdecrefpyobject pyxr$^      pyxt0  pyxpyintfromint00tpyxvstate if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxgotrefpyxt0$^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^       else $^        if cythonfastpycall$^        if pyfunctioncheckpyxt0 $^          pyobject pyxtemp0  pyxt0 pyxt0$^          pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^          pyxxdecrefpyxt0 pyxt0  0$^          pyxgotrefpyxt0$^          pyxdecrefpyxt0 pyxt0  0$^         else$^        endif$^        if cythonfastpyccall$^        if pyxpyfastcfunctioncheckpyxt0 $^          pyobject pyxtemp0  pyxt0 pyxt0$^          pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^          pyxxdecrefpyxt0 pyxt0  0$^          pyxgotrefpyxt0$^          pyxdecrefpyxt0 pyxt0  0$^         else$^        endif$^        $^          pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^          pyxgotrefpyxt0$^          pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^          pyxgiverefpyxt0$^          pytuplesetitempyxt0 00 pyxt0$^          pyxt0  0$^          pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^          pyxgotrefpyxt0$^          pyxdecrefpyxt0 pyxt0  0$^        $^      $^      pyxdecrefpyxt0 pyxt0  0$^      if likelypyxt0  pynone  likelypyxtypetestpyxt0 pyxptype0pywrapfstweight pyxerr0 0000 pyxl0error$^      pyxr  struct pyxobj0pywrapfstweight pyxt0$^      pyxt0  0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx0000$^        fstindexerror state index out of range.$^      $^      cdef weight weight  weight.newweight              $^      weight.weight.resetnew fst.weightclassself.fst.get.finalstate$^      return weight$^ $^  pyxt0  pyxtpnew0pywrapfstweightpytypeobject pyxptype0pywrapfstweight pyxemptytuple null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  if likelypyxtypetestpyxt0 pyxptype0pywrapfstweight pyxerr0 0000 pyxl0error$^  pyxvweight  struct pyxobj0pywrapfstweight pyxt0$^  pyxt0  0$^$^   pywrapfst.pyx0000$^      $^      cdef weight weight  weight.newweight$^      weight.weight.resetnew fst.weightclassself.fst.get.finalstate              $^      return weight$^  $^ $^  if unlikelypyobject pyxvweight  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s weight$^    pyxerr0 0000 pyxl0error$^  $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s fst$^    pyxerr0 0000 pyxl0error$^  $^  pyxvweightweight.resetnew fstscriptweightclasspyxvselffst.getfinalpyxvstate$^$^   pywrapfst.pyx0000$^      cdef weight weight  weight.newweight$^      weight.weight.resetnew fst.weightclassself.fst.get.finalstate$^      return weight              $^  $^    cpdef string fsttypeself$^ $^  pyxxdecrefpyobject pyxr$^  pyxincrefpyobject pyxvweight$^  pyxr  pyxvweight$^  goto pyxl0$^$^   pywrapfst.pyx0000$^          filenamestring$^  $^    cpdef weight finalself int00 state              $^      $^      finalself state$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.fst.final pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxl0$^  pyxxdecrefpyobject pyxvweight$^  pyxxgiverefpyobject pyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst0fst00finalpyobject pyxvself pyobject pyxargstate proto$^static char pyxdoc0pywrapfst0fst00final  n    finalself statenn    returns the final weight of a state.nn    argsn      state the integer index of a state.nn    returnsn      the final weight of that state.nn    raisesn      fstindexerror state index out of range.n    $^static pyobject pyxpw0pywrapfst0fst00finalpyobject pyxvself pyobject pyxargstate $^  pyxt00basictypesint00 pyxvstate$^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextfinal wrapper 0$^  assertpyxargstate $^    pyxvstate  pyxpyintasint00tpyxargstate if unlikelypyxvstate  int00t0  pyerroccurred pyxerr0 0000 pyxl0error$^  $^  goto pyxl0argumentunpackingdone$^  pyxl0error$^  pyxaddtracebackpywrapfst.fst.final pyxclineno pyxlineno pyxfilename$^  pyxrefnannyfinishcontext$^  return null$^  pyxl0argumentunpackingdone$^  pyxr  pyxpf0pywrapfst0fst00finalstruct pyxobj0pywrapfstfst pyxvself pyxt00basictypesint00pyxvstate$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst0fst00finalstruct pyxobj0pywrapfstfst pyxvself pyxt00basictypesint00 pyxvstate $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextfinal 0$^  pyxxdecrefpyxr$^  pyxt0  pyobject pyxf0pywrapfst0fstfinalpyxvself pyxvstate 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.fst.final pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return weight$^  $^    cpdef string fsttypeself              $^      $^      fsttypeself$^ $^$^static pyobject pyxpw0pywrapfst0fst00fsttypepyobject pyxvself cythonunused pyobject unused proto$^static stdstring pyxf0pywrapfst0fstfsttypestruct pyxobj0pywrapfstfst pyxvself int pyxskipdispatch $^  stdstring pyxr$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  stdstring pyxt0$^  pyxrefnannysetupcontextfsttype 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnsfsttype if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst0fst00fsttype $^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxdecrefpyxt0 pyxt0  0$^       else $^        pyxt0  pyxpyobjectcallnoargpyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      $^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxt0  pyxconvertstringfrompystdinstringpyxt0 if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxr  pyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx0000$^      returns a string indicating the fst type.$^      $^      return self.fst.get.fsttype              $^  $^    cpdef fstsymboltable inputsymbolsself$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s fst$^    pyxerr0 0000 pyxl0error$^  $^  pyxr  pyxvselffst.getfsttype$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      return weight$^  $^    cpdef string fsttypeself              $^      $^      fsttypeself$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxwriteunraisablepywrapfst.fst.fsttype pyxclineno pyxlineno pyxfilename 0 0$^  pyxpretendtoinitializepyxr$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst0fst00fsttypepyobject pyxvself cythonunused pyobject unused proto$^static char pyxdoc0pywrapfst0fst00fsttype  n    fsttypeselfnn    returns a string indicating the fst type.n    $^static pyobject pyxpw0pywrapfst0fst00fsttypepyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextfsttype wrapper 0$^  pyxr  pyxpf0pywrapfst0fst00fsttypestruct pyxobj0pywrapfstfst pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst0fst00fsttypestruct pyxobj0pywrapfstfst pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextfsttype 0$^  pyxxdecrefpyxr$^  pyxt0  pyxconvertpybytesstringtopystdinstringpyxf0pywrapfst0fstfsttypepyxvself 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.fst.fsttype pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return self.fst.get.fsttype$^  $^    cpdef fstsymboltable inputsymbolsself              $^      $^      inputsymbolsself$^ $^$^static pyobject pyxpw0pywrapfst0fst00inputsymbolspyobject pyxvself cythonunused pyobject unused proto$^static struct pyxobj0pywrapfstfstsymboltable pyxf0pywrapfst0fstinputsymbolsstruct pyxobj0pywrapfstfst pyxvself int pyxskipdispatch $^  fstsymboltable pyxvsyms$^  struct pyxobj0pywrapfstfstsymboltable pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  int pyxt0$^  pyxrefnannysetupcontextinputsymbols 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnsinputsymbols if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst0fst00inputsymbols $^      pyxxdecrefpyobject pyxr$^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxdecrefpyxt0 pyxt0  0$^       else $^        pyxt0  pyxpyobjectcallnoargpyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      $^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      if likelypyxt0  pynone  likelypyxtypetestpyxt0 pyxptype0pywrapfstfstsymboltable pyxerr0 0000 pyxl0error$^      pyxr  struct pyxobj0pywrapfstfstsymboltable pyxt0$^      pyxt0  0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx0000$^      $^      cdef fst.symboltable syms  constcastsymboltableptr$^        self.fst.get.inputsymbols              $^      if syms  null$^        return$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s fst$^    pyxerr0 0000 pyxl0error$^  $^$^   pywrapfst.pyx0000$^      see also inputsymbols.$^      $^      cdef fst.symboltable syms  constcastsymboltableptr              $^        self.fst.get.inputsymbols$^      if syms  null$^ $^  pyxvsyms  constcastpyxt0pywrapfstsymboltableptrpyxvselffst.getinputsymbols$^$^   pywrapfst.pyx0000$^      cdef fst.symboltable syms  constcastsymboltableptr$^        self.fst.get.inputsymbols$^      if syms  null              $^        return$^      return initfstsymboltablesyms self.fst$^ $^  pyxt0  pyxvsyms  null  0$^  if pyxt0 $^$^     pywrapfst.pyx0000$^        self.fst.get.inputsymbols$^      if syms  null$^        return              $^      return initfstsymboltablesyms self.fst$^  $^ $^    pyxxdecrefpyobject pyxr$^    pyxr  struct pyxobj0pywrapfstfstsymboltable pynone pyxincrefpynone$^    goto pyxl0$^$^     pywrapfst.pyx0000$^      cdef fst.symboltable syms  constcastsymboltableptr$^        self.fst.get.inputsymbols$^      if syms  null              $^        return$^      return initfstsymboltablesyms self.fst$^ $^  $^$^   pywrapfst.pyx0000$^      if syms  null$^        return$^      return initfstsymboltablesyms self.fst              $^  $^    cpdef sizet numarcsself int00 state except $^ $^  pyxxdecrefpyobject pyxr$^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s fst$^    pyxerr0 0000 pyxl0error$^  $^  pyxt0  pyobject pyxf0pywrapfstinitfstsymboltablepyxvsyms pyxvselffst if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  struct pyxobj0pywrapfstfstsymboltable pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      return self.fst.get.fsttype$^  $^    cpdef fstsymboltable inputsymbolsself              $^      $^      inputsymbolsself$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.fst.inputsymbols pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxl0$^  pyxxgiverefpyobject pyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst0fst00inputsymbolspyobject pyxvself cythonunused pyobject unused proto$^static char pyxdoc0pywrapfst0fst00inputsymbols  n    inputsymbolsselfnn    returns the fsts input symbol table or none if none is present.nn    see also inputsymbols.n    $^static pyobject pyxpw0pywrapfst0fst00inputsymbolspyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextinputsymbols wrapper 0$^  pyxr  pyxpf0pywrapfst0fst00inputsymbolsstruct pyxobj0pywrapfstfst pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst0fst00inputsymbolsstruct pyxobj0pywrapfstfst pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextinputsymbols 0$^  pyxxdecrefpyxr$^  pyxt0  pyobject pyxf0pywrapfst0fstinputsymbolspyxvself 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.fst.inputsymbols pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return initfstsymboltablesyms self.fst$^  $^    cpdef sizet numarcsself int00 state except               $^      $^      numarcsself state$^ $^$^static pyobject pyxpw0pywrapfst0fst00numarcspyobject pyxvself pyobject pyxargstate proto$^static sizet pyxf0pywrapfst0fstnumarcsstruct pyxobj0pywrapfstfst pyxvself pyxt00basictypesint00 pyxvstate int pyxskipdispatch $^  sizet pyxvresult$^  sizet pyxr$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  sizet pyxt0$^  int pyxt0$^  pyxrefnannysetupcontextnumarcs 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnsnumarcs if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst0fst00numarcs $^      pyxt0  pyxpyintfromint00tpyxvstate if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxgotrefpyxt0$^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^       else $^        if cythonfastpycall$^        if pyfunctioncheckpyxt0 $^          pyobject pyxtemp0  pyxt0 pyxt0$^          pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^          pyxxdecrefpyxt0 pyxt0  0$^          pyxgotrefpyxt0$^          pyxdecrefpyxt0 pyxt0  0$^         else$^        endif$^        if cythonfastpyccall$^        if pyxpyfastcfunctioncheckpyxt0 $^          pyobject pyxtemp0  pyxt0 pyxt0$^          pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^          pyxxdecrefpyxt0 pyxt0  0$^          pyxgotrefpyxt0$^          pyxdecrefpyxt0 pyxt0  0$^         else$^        endif$^        $^          pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^          pyxgotrefpyxt0$^          pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^          pyxgiverefpyxt0$^          pytuplesetitempyxt0 00 pyxt0$^          pyxt0  0$^          pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^          pyxgotrefpyxt0$^          pyxdecrefpyxt0 pyxt0  0$^        $^      $^      pyxdecrefpyxt0 pyxt0  0$^      pyxt0  pyxpyintassizetpyxt0 if unlikelypyxt0  sizet0  pyerroccurred pyxerr0 0000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxr  pyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx0000$^      see also numstates.$^      $^      cdef sizet result  self.fst.get.numarcsstate              $^      if result  sizemax$^        raise fstindexerrorstate index out of range$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s fst$^    pyxerr0 0000 pyxl0error$^  $^  pyxvresult  pyxvselffst.getnumarcspyxvstate$^$^   pywrapfst.pyx0000$^      $^      cdef sizet result  self.fst.get.numarcsstate$^      if result  sizemax              $^        raise fstindexerrorstate index out of range$^      return result$^ $^  pyxt0  pyxvresult  sizemax  0$^  if pyxt0 $^$^     pywrapfst.pyx0000$^      cdef sizet result  self.fst.get.numarcsstate$^      if result  sizemax$^        raise fstindexerrorstate index out of range              $^      return result$^  $^ $^    pyxt0  pyxgetmoduleglobalnamepyxnsfstindexerror if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  pyxpyobjectcallpyxt0 pyxtuple00 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxraisepyxt0 0 0 0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxerr0 0000 pyxl0error$^$^     pywrapfst.pyx0000$^      $^      cdef sizet result  self.fst.get.numarcsstate$^      if result  sizemax              $^        raise fstindexerrorstate index out of range$^      return result$^ $^  $^$^   pywrapfst.pyx0000$^      if result  sizemax$^        raise fstindexerrorstate index out of range$^      return result              $^  $^    cpdef sizet numinputepsilonsself int00 state except $^ $^  pyxr  pyxvresult$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      return initfstsymboltablesyms self.fst$^  $^    cpdef sizet numarcsself int00 state except               $^      $^      numarcsself state$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.fst.numarcs pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst0fst00numarcspyobject pyxvself pyobject pyxargstate proto$^static char pyxdoc0pywrapfst0fst00numarcs  n    numarcsself statenn    returns the number of arcs leaving a state.nn    argsn      state the integer index of a state.nn    returnsn      the number of arcs leaving that state.nn    raisesn      fstindexerror state index out of range.nn    see also numstates.n    $^static pyobject pyxpw0pywrapfst0fst00numarcspyobject pyxvself pyobject pyxargstate $^  pyxt00basictypesint00 pyxvstate$^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextnumarcs wrapper 0$^  assertpyxargstate $^    pyxvstate  pyxpyintasint00tpyxargstate if unlikelypyxvstate  int00t0  pyerroccurred pyxerr0 0000 pyxl0error$^  $^  goto pyxl0argumentunpackingdone$^  pyxl0error$^  pyxaddtracebackpywrapfst.fst.numarcs pyxclineno pyxlineno pyxfilename$^  pyxrefnannyfinishcontext$^  return null$^  pyxl0argumentunpackingdone$^  pyxr  pyxpf0pywrapfst0fst00numarcsstruct pyxobj0pywrapfstfst pyxvself pyxt00basictypesint00pyxvstate$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst0fst00numarcsstruct pyxobj0pywrapfstfst pyxvself pyxt00basictypesint00 pyxvstate $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  sizet pyxt0$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextnumarcs 0$^  pyxxdecrefpyxr$^  pyxt0  pyxf0pywrapfst0fstnumarcspyxvself pyxvstate 0 if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^  pyxt0  pyxpyintfromsizetpyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.fst.numarcs pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return result$^  $^    cpdef sizet numinputepsilonsself int00 state except               $^      $^      numinputepsilonsself state$^ $^$^static pyobject pyxpw0pywrapfst0fst00numinputepsilonspyobject pyxvself pyobject pyxargstate proto$^static sizet pyxf0pywrapfst0fstnuminputepsilonsstruct pyxobj0pywrapfstfst pyxvself pyxt00basictypesint00 pyxvstate int pyxskipdispatch $^  sizet pyxvresult$^  sizet pyxr$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  sizet pyxt0$^  int pyxt0$^  pyxrefnannysetupcontextnuminputepsilons 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnsnuminputepsilons if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst0fst00numinputepsilons $^      pyxt0  pyxpyintfromint00tpyxvstate if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxgotrefpyxt0$^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^       else $^        if cythonfastpycall$^        if pyfunctioncheckpyxt0 $^          pyobject pyxtemp0  pyxt0 pyxt0$^          pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^          pyxxdecrefpyxt0 pyxt0  0$^          pyxgotrefpyxt0$^          pyxdecrefpyxt0 pyxt0  0$^         else$^        endif$^        if cythonfastpyccall$^        if pyxpyfastcfunctioncheckpyxt0 $^          pyobject pyxtemp0  pyxt0 pyxt0$^          pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^          pyxxdecrefpyxt0 pyxt0  0$^          pyxgotrefpyxt0$^          pyxdecrefpyxt0 pyxt0  0$^         else$^        endif$^        $^          pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^          pyxgotrefpyxt0$^          pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^          pyxgiverefpyxt0$^          pytuplesetitempyxt0 00 pyxt0$^          pyxt0  0$^          pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^          pyxgotrefpyxt0$^          pyxdecrefpyxt0 pyxt0  0$^        $^      $^      pyxdecrefpyxt0 pyxt0  0$^      pyxt0  pyxpyintassizetpyxt0 if unlikelypyxt0  sizet0  pyerroccurred pyxerr0 0000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxr  pyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx0000$^      see also numoutputepsilons.$^      $^      cdef sizet result  self.fst.get.numinputepsilonsstate              $^      if result  sizemax$^        raise fstindexerrorstate index out of range$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s fst$^    pyxerr0 0000 pyxl0error$^  $^  pyxvresult  pyxvselffst.getnuminputepsilonspyxvstate$^$^   pywrapfst.pyx0000$^      $^      cdef sizet result  self.fst.get.numinputepsilonsstate$^      if result  sizemax              $^        raise fstindexerrorstate index out of range$^      return result$^ $^  pyxt0  pyxvresult  sizemax  0$^  if pyxt0 $^$^     pywrapfst.pyx0000$^      cdef sizet result  self.fst.get.numinputepsilonsstate$^      if result  sizemax$^        raise fstindexerrorstate index out of range              $^      return result$^  $^ $^    pyxt0  pyxgetmoduleglobalnamepyxnsfstindexerror if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  pyxpyobjectcallpyxt0 pyxtuple00 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxraisepyxt0 0 0 0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxerr0 0000 pyxl0error$^$^     pywrapfst.pyx0000$^      $^      cdef sizet result  self.fst.get.numinputepsilonsstate$^      if result  sizemax              $^        raise fstindexerrorstate index out of range$^      return result$^ $^  $^$^   pywrapfst.pyx0000$^      if result  sizemax$^        raise fstindexerrorstate index out of range$^      return result              $^  $^    cpdef sizet numoutputepsilonsself int00 state except $^ $^  pyxr  pyxvresult$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      return result$^  $^    cpdef sizet numinputepsilonsself int00 state except               $^      $^      numinputepsilonsself state$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.fst.numinputepsilons pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst0fst00numinputepsilonspyobject pyxvself pyobject pyxargstate proto$^static char pyxdoc0pywrapfst0fst00numinputepsilons  n    numinputepsilonsself statenn    returns the number of arcs with epsilon input labels leaving a state.nn    argsn      state the integer index of a state.nn    returnsn      the number of epsiloninputlabeled arcs leaving that state.nn    raisesn      fstindexerror state index out of range.nn    see also numoutputepsilons.n    $^static pyobject pyxpw0pywrapfst0fst00numinputepsilonspyobject pyxvself pyobject pyxargstate $^  pyxt00basictypesint00 pyxvstate$^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextnuminputepsilons wrapper 0$^  assertpyxargstate $^    pyxvstate  pyxpyintasint00tpyxargstate if unlikelypyxvstate  int00t0  pyerroccurred pyxerr0 0000 pyxl0error$^  $^  goto pyxl0argumentunpackingdone$^  pyxl0error$^  pyxaddtracebackpywrapfst.fst.numinputepsilons pyxclineno pyxlineno pyxfilename$^  pyxrefnannyfinishcontext$^  return null$^  pyxl0argumentunpackingdone$^  pyxr  pyxpf0pywrapfst0fst00numinputepsilonsstruct pyxobj0pywrapfstfst pyxvself pyxt00basictypesint00pyxvstate$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst0fst00numinputepsilonsstruct pyxobj0pywrapfstfst pyxvself pyxt00basictypesint00 pyxvstate $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  sizet pyxt0$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextnuminputepsilons 0$^  pyxxdecrefpyxr$^  pyxt0  pyxf0pywrapfst0fstnuminputepsilonspyxvself pyxvstate 0 if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^  pyxt0  pyxpyintfromsizetpyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.fst.numinputepsilons pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return result$^  $^    cpdef sizet numoutputepsilonsself int00 state except               $^      $^      numoutputepsilonsself state$^ $^$^static pyobject pyxpw0pywrapfst0fst00numoutputepsilonspyobject pyxvself pyobject pyxargstate proto$^static sizet pyxf0pywrapfst0fstnumoutputepsilonsstruct pyxobj0pywrapfstfst pyxvself pyxt00basictypesint00 pyxvstate int pyxskipdispatch $^  sizet pyxvresult$^  sizet pyxr$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  sizet pyxt0$^  int pyxt0$^  pyxrefnannysetupcontextnumoutputepsilons 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnsnumoutputepsilons if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst0fst00numoutputepsilons $^      pyxt0  pyxpyintfromint00tpyxvstate if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxgotrefpyxt0$^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^       else $^        if cythonfastpycall$^        if pyfunctioncheckpyxt0 $^          pyobject pyxtemp0  pyxt0 pyxt0$^          pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^          pyxxdecrefpyxt0 pyxt0  0$^          pyxgotrefpyxt0$^          pyxdecrefpyxt0 pyxt0  0$^         else$^        endif$^        if cythonfastpyccall$^        if pyxpyfastcfunctioncheckpyxt0 $^          pyobject pyxtemp0  pyxt0 pyxt0$^          pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^          pyxxdecrefpyxt0 pyxt0  0$^          pyxgotrefpyxt0$^          pyxdecrefpyxt0 pyxt0  0$^         else$^        endif$^        $^          pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^          pyxgotrefpyxt0$^          pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^          pyxgiverefpyxt0$^          pytuplesetitempyxt0 00 pyxt0$^          pyxt0  0$^          pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^          pyxgotrefpyxt0$^          pyxdecrefpyxt0 pyxt0  0$^        $^      $^      pyxdecrefpyxt0 pyxt0  0$^      pyxt0  pyxpyintassizetpyxt0 if unlikelypyxt0  sizet0  pyerroccurred pyxerr0 0000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxr  pyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx0000$^      see also numinputepsilons.$^      $^      cdef sizet result  self.fst.get.numoutputepsilonsstate              $^      if result  sizemax$^        raise fstindexerrorstate index out of range$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s fst$^    pyxerr0 0000 pyxl0error$^  $^  pyxvresult  pyxvselffst.getnumoutputepsilonspyxvstate$^$^   pywrapfst.pyx0000$^      $^      cdef sizet result  self.fst.get.numoutputepsilonsstate$^      if result  sizemax              $^        raise fstindexerrorstate index out of range$^      return result$^ $^  pyxt0  pyxvresult  sizemax  0$^  if pyxt0 $^$^     pywrapfst.pyx0000$^      cdef sizet result  self.fst.get.numoutputepsilonsstate$^      if result  sizemax$^        raise fstindexerrorstate index out of range              $^      return result$^  $^ $^    pyxt0  pyxgetmoduleglobalnamepyxnsfstindexerror if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  pyxpyobjectcallpyxt0 pyxtuple00 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxraisepyxt0 0 0 0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxerr0 0000 pyxl0error$^$^     pywrapfst.pyx0000$^      $^      cdef sizet result  self.fst.get.numoutputepsilonsstate$^      if result  sizemax              $^        raise fstindexerrorstate index out of range$^      return result$^ $^  $^$^   pywrapfst.pyx0000$^      if result  sizemax$^        raise fstindexerrorstate index out of range$^      return result              $^  $^    cpdef fstsymboltable outputsymbolsself$^ $^  pyxr  pyxvresult$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      return result$^  $^    cpdef sizet numoutputepsilonsself int00 state except               $^      $^      numoutputepsilonsself state$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.fst.numoutputepsilons pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst0fst00numoutputepsilonspyobject pyxvself pyobject pyxargstate proto$^static char pyxdoc0pywrapfst0fst00numoutputepsilons  n    numoutputepsilonsself statenn    returns the number of arcs with epsilon output labels leaving a state.nn    argsn      state the integer index of a state.nn    returnsn      the number of epsilonoutputlabeled arcs leaving that state.nn    raisesn      fstindexerror state index out of range.nn    see also numinputepsilons.n    $^static pyobject pyxpw0pywrapfst0fst00numoutputepsilonspyobject pyxvself pyobject pyxargstate $^  pyxt00basictypesint00 pyxvstate$^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextnumoutputepsilons wrapper 0$^  assertpyxargstate $^    pyxvstate  pyxpyintasint00tpyxargstate if unlikelypyxvstate  int00t0  pyerroccurred pyxerr0 0000 pyxl0error$^  $^  goto pyxl0argumentunpackingdone$^  pyxl0error$^  pyxaddtracebackpywrapfst.fst.numoutputepsilons pyxclineno pyxlineno pyxfilename$^  pyxrefnannyfinishcontext$^  return null$^  pyxl0argumentunpackingdone$^  pyxr  pyxpf0pywrapfst0fst00numoutputepsilonsstruct pyxobj0pywrapfstfst pyxvself pyxt00basictypesint00pyxvstate$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst0fst00numoutputepsilonsstruct pyxobj0pywrapfstfst pyxvself pyxt00basictypesint00 pyxvstate $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  sizet pyxt0$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextnumoutputepsilons 0$^  pyxxdecrefpyxr$^  pyxt0  pyxf0pywrapfst0fstnumoutputepsilonspyxvself pyxvstate 0 if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^  pyxt0  pyxpyintfromsizetpyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.fst.numoutputepsilons pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return result$^  $^    cpdef fstsymboltable outputsymbolsself              $^      $^      outputsymbolsself$^ $^$^static pyobject pyxpw0pywrapfst0fst00outputsymbolspyobject pyxvself cythonunused pyobject unused proto$^static struct pyxobj0pywrapfstfstsymboltable pyxf0pywrapfst0fstoutputsymbolsstruct pyxobj0pywrapfstfst pyxvself int pyxskipdispatch $^  fstsymboltable pyxvsyms$^  struct pyxobj0pywrapfstfstsymboltable pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  int pyxt0$^  pyxrefnannysetupcontextoutputsymbols 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnsoutputsymbols if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst0fst00outputsymbols $^      pyxxdecrefpyobject pyxr$^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxdecrefpyxt0 pyxt0  0$^       else $^        pyxt0  pyxpyobjectcallnoargpyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      $^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      if likelypyxt0  pynone  likelypyxtypetestpyxt0 pyxptype0pywrapfstfstsymboltable pyxerr0 0000 pyxl0error$^      pyxr  struct pyxobj0pywrapfstfstsymboltable pyxt0$^      pyxt0  0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx0000$^      $^      cdef fst.symboltable syms  constcastsymboltableptr$^        self.fst.get.outputsymbols              $^      if syms  null$^        return$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s fst$^    pyxerr0 0000 pyxl0error$^  $^$^   pywrapfst.pyx0000$^      see also inputsymbols.$^      $^      cdef fst.symboltable syms  constcastsymboltableptr              $^        self.fst.get.outputsymbols$^      if syms  null$^ $^  pyxvsyms  constcastpyxt0pywrapfstsymboltableptrpyxvselffst.getoutputsymbols$^$^   pywrapfst.pyx0000$^      cdef fst.symboltable syms  constcastsymboltableptr$^        self.fst.get.outputsymbols$^      if syms  null              $^        return$^      return initfstsymboltablesyms self.fst$^ $^  pyxt0  pyxvsyms  null  0$^  if pyxt0 $^$^     pywrapfst.pyx0000$^        self.fst.get.outputsymbols$^      if syms  null$^        return              $^      return initfstsymboltablesyms self.fst$^  $^ $^    pyxxdecrefpyobject pyxr$^    pyxr  struct pyxobj0pywrapfstfstsymboltable pynone pyxincrefpynone$^    goto pyxl0$^$^     pywrapfst.pyx0000$^      cdef fst.symboltable syms  constcastsymboltableptr$^        self.fst.get.outputsymbols$^      if syms  null              $^        return$^      return initfstsymboltablesyms self.fst$^ $^  $^$^   pywrapfst.pyx0000$^      if syms  null$^        return$^      return initfstsymboltablesyms self.fst              $^  $^    cpdef uint00 propertiesself uint00 mask bool test$^ $^  pyxxdecrefpyobject pyxr$^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s fst$^    pyxerr0 0000 pyxl0error$^  $^  pyxt0  pyobject pyxf0pywrapfstinitfstsymboltablepyxvsyms pyxvselffst if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  struct pyxobj0pywrapfstfstsymboltable pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      return result$^  $^    cpdef fstsymboltable outputsymbolsself              $^      $^      outputsymbolsself$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.fst.outputsymbols pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxl0$^  pyxxgiverefpyobject pyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst0fst00outputsymbolspyobject pyxvself cythonunused pyobject unused proto$^static char pyxdoc0pywrapfst0fst00outputsymbols  n    outputsymbolsselfnn    returns the fsts output symbol table or none if none is present.nn    see also inputsymbols.n    $^static pyobject pyxpw0pywrapfst0fst00outputsymbolspyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextoutputsymbols wrapper 0$^  pyxr  pyxpf0pywrapfst0fst00outputsymbolsstruct pyxobj0pywrapfstfst pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst0fst00outputsymbolsstruct pyxobj0pywrapfstfst pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextoutputsymbols 0$^  pyxxdecrefpyxr$^  pyxt0  pyobject pyxf0pywrapfst0fstoutputsymbolspyxvself 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.fst.outputsymbols pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return initfstsymboltablesyms self.fst$^  $^    cpdef uint00 propertiesself uint00 mask bool test              $^      $^      propertiesself mask test$^ $^$^static pyobject pyxpw0pywrapfst0fst00propertiespyobject pyxvself pyobject pyxargs pyobject pyxkwds proto$^static pyxt00basictypesuint00 pyxf0pywrapfst0fstpropertiesstruct pyxobj0pywrapfstfst pyxvself pyxt00basictypesuint00 pyxvmask bool pyxvtest int pyxskipdispatch $^  pyxt00basictypesuint00 pyxr$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  int pyxt0$^  pyobject pyxt0  null$^  pyxt00basictypesuint00 pyxt0$^  pyxrefnannysetupcontextproperties 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnsproperties if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst0fst00properties $^      pyxt0  pyxpyintfromuint00tpyxvmask if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxgotrefpyxt0$^      pyxt0  pyxpyboolfromlongpyxvtest if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxgotrefpyxt0$^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      pyxt0  0$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^          pyxt0  0$^        $^      $^      if cythonfastpycall$^      if pyfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxt0 pyxt0$^        pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp0pyxt0 0pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^        pyxdecrefpyxt0 pyxt0  0$^       else$^      endif$^      if cythonfastpyccall$^      if pyxpyfastcfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxt0 pyxt0$^        pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp0pyxt0 0pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^        pyxdecrefpyxt0 pyxt0  0$^       else$^      endif$^      $^        pyxt0  pytuplenew0pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxgotrefpyxt0$^        if pyxt0 $^          pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^        $^        pyxgiverefpyxt0$^        pytuplesetitempyxt0 0pyxt0 pyxt0$^        pyxgiverefpyxt0$^        pytuplesetitempyxt0 0pyxt0 pyxt0$^        pyxt0  0$^        pyxt0  0$^        pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^      $^      pyxdecrefpyxt0 pyxt0  0$^      pyxt0  pyxpyintasuint00tpyxt0 if unlikelypyxt0  uint00t0  pyerroccurred pyxerr0 0000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxr  pyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx0000$^        a 00bit bitmask representing the requested properties.$^      $^      return self.fst.get.propertiesmask test              $^  $^    cpdef int00 startself$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s fst$^    pyxerr0 0000 pyxl0error$^  $^  pyxr  pyxvselffst.getpropertiespyxvmask pyxvtest$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      return initfstsymboltablesyms self.fst$^  $^    cpdef uint00 propertiesself uint00 mask bool test              $^      $^      propertiesself mask test$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxwriteunraisablepywrapfst.fst.properties pyxclineno pyxlineno pyxfilename 0 0$^  pyxr  0$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst0fst00propertiespyobject pyxvself pyobject pyxargs pyobject pyxkwds proto$^static char pyxdoc0pywrapfst0fst00properties  n    propertiesself mask testnn    provides property bits.nn    this method provides user access to the properties attributes for the fst.n    the resulting value is a long integer but when it is cast to a booleann    it represents whether or not the fst has the mask property.nn    argsn      mask the property mask to be compared to the fsts properties.n      test should any unknown values be computed before comparing againstn          the masknn    returnsn      a 00bit bitmask representing the requested properties.n    $^static pyobject pyxpw0pywrapfst0fst00propertiespyobject pyxvself pyobject pyxargs pyobject pyxkwds $^  pyxt00basictypesuint00 pyxvmask$^  bool pyxvtest$^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextproperties wrapper 0$^  $^    static pyobject pyxpyargnames  pyxnsmaskpyxnstest0$^    pyobject values0  00$^    if unlikelypyxkwds $^      pyssizet kwargs$^      const pyssizet posargs  pytuplegetsizepyxargs$^      switch posargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 break$^        default goto pyxl0argtupleerror$^      $^      kwargs  pydictsizepyxkwds$^      switch posargs $^        case  0$^        if likelyvalues0  pydictgetitempyxkwds pyxnsmask  0 kwargs$^        else goto pyxl0argtupleerror$^        cythonfallthrough$^        case  0$^        if likelyvalues0  pydictgetitempyxkwds pyxnstest  0 kwargs$^        else $^          pyxraiseargtupleinvalidproperties 0 0 0 0 pyxerr0 0000 pyxl0error$^        $^      $^      if unlikelykwargs  0 $^        if unlikelypyxparseoptionalkeywordspyxkwds pyxpyargnames 0 values posargs properties  0 pyxerr0 0000 pyxl0error$^      $^     else if pytuplegetsizepyxargs  0 $^      goto pyxl0argtupleerror$^     else $^      values0  pytuplegetitempyxargs 0$^      values0  pytuplegetitempyxargs 0$^    $^    pyxvmask  pyxpyintasuint00tvalues0 if unlikelypyxvmask  uint00t0  pyerroccurred pyxerr0 0000 pyxl0error$^    pyxvtest  pyxpyobjectistruevalues0 if unlikelypyxvtest  bool0  pyerroccurred pyxerr0 0000 pyxl0error$^  $^  goto pyxl0argumentunpackingdone$^  pyxl0argtupleerror$^  pyxraiseargtupleinvalidproperties 0 0 0 pytuplegetsizepyxargs pyxerr0 0000 pyxl0error$^  pyxl0error$^  pyxaddtracebackpywrapfst.fst.properties pyxclineno pyxlineno pyxfilename$^  pyxrefnannyfinishcontext$^  return null$^  pyxl0argumentunpackingdone$^  pyxr  pyxpf0pywrapfst0fst00propertiesstruct pyxobj0pywrapfstfst pyxvself pyxvmask pyxvtest$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst0fst00propertiesstruct pyxobj0pywrapfstfst pyxvself pyxt00basictypesuint00 pyxvmask bool pyxvtest $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextproperties 0$^  pyxxdecrefpyxr$^  pyxt0  pyxpyintfromuint00tpyxf0pywrapfst0fstpropertiespyxvself pyxvmask pyxvtest 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.fst.properties pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return self.fst.get.propertiesmask test$^  $^    cpdef int00 startself              $^      $^      startself$^ $^$^static pyobject pyxpw0pywrapfst0fst00startpyobject pyxvself cythonunused pyobject unused proto$^static pyxt00basictypesint00 pyxf0pywrapfst0fststartstruct pyxobj0pywrapfstfst pyxvself int pyxskipdispatch $^  pyxt00basictypesint00 pyxr$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxt00basictypesint00 pyxt0$^  pyxrefnannysetupcontextstart 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnsstart if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst0fst00start $^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxdecrefpyxt0 pyxt0  0$^       else $^        pyxt0  pyxpyobjectcallnoargpyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      $^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxt0  pyxpyintasint00tpyxt0 if unlikelypyxt0  int00t0  pyerroccurred pyxerr0 0000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxr  pyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx0000$^      returns the start state.$^      $^      return self.fst.get.start              $^  $^    cpdef stateiterator statesself$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s fst$^    pyxerr0 0000 pyxl0error$^  $^  pyxr  pyxvselffst.getstart$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      return self.fst.get.propertiesmask test$^  $^    cpdef int00 startself              $^      $^      startself$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxwriteunraisablepywrapfst.fst.start pyxclineno pyxlineno pyxfilename 0 0$^  pyxr  0$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst0fst00startpyobject pyxvself cythonunused pyobject unused proto$^static char pyxdoc0pywrapfst0fst00start  n    startselfnn    returns the start state.n    $^static pyobject pyxpw0pywrapfst0fst00startpyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextstart wrapper 0$^  pyxr  pyxpf0pywrapfst0fst00startstruct pyxobj0pywrapfstfst pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst0fst00startstruct pyxobj0pywrapfstfst pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextstart 0$^  pyxxdecrefpyxr$^  pyxt0  pyxpyintfromint00tpyxf0pywrapfst0fststartpyxvself 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.fst.start pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return self.fst.get.start$^  $^    cpdef stateiterator statesself              $^      $^      statesself$^ $^$^static pyobject pyxpw0pywrapfst0fst00statespyobject pyxvself cythonunused pyobject unused proto$^static struct pyxobj0pywrapfststateiterator pyxf0pywrapfst0fststatesstruct pyxobj0pywrapfstfst pyxvself int pyxskipdispatch $^  struct pyxobj0pywrapfststateiterator pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextstates 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnsstates if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst0fst00states $^      pyxxdecrefpyobject pyxr$^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxdecrefpyxt0 pyxt0  0$^       else $^        pyxt0  pyxpyobjectcallnoargpyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      $^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      if likelypyxt0  pynone  likelypyxtypetestpyxt0 pyxptype0pywrapfststateiterator pyxerr0 0000 pyxl0error$^      pyxr  struct pyxobj0pywrapfststateiterator pyxt0$^      pyxt0  0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx0000$^      see also arcs mutablearcs.$^      $^      return stateiteratorself              $^  $^    cpdef string textself symboltable isymbolsnone$^ $^  pyxxdecrefpyobject pyxr$^  pyxt0  pytuplenew0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxincrefpyobject pyxvself$^  pyxgiverefpyobject pyxvself$^  pytuplesetitempyxt0 0 pyobject pyxvself$^  pyxt0  pyxpyobjectcallpyobject pyxptype0pywrapfststateiterator pyxt0 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxdecrefpyxt0 pyxt0  0$^  pyxr  struct pyxobj0pywrapfststateiterator pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      return self.fst.get.start$^  $^    cpdef stateiterator statesself              $^      $^      statesself$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.fst.states pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxl0$^  pyxxgiverefpyobject pyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst0fst00statespyobject pyxvself cythonunused pyobject unused proto$^static char pyxdoc0pywrapfst0fst00states  n    statesselfnn    returns an iterator over all states in the fst.nn    returnsn      a stateiterator object for the fst.nn    see also arcs mutablearcs.n    $^static pyobject pyxpw0pywrapfst0fst00statespyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextstates wrapper 0$^  pyxr  pyxpf0pywrapfst0fst00statesstruct pyxobj0pywrapfstfst pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst0fst00statesstruct pyxobj0pywrapfstfst pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextstates 0$^  pyxxdecrefpyxr$^  pyxt0  pyobject pyxf0pywrapfst0fststatespyxvself 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.fst.states pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return stateiteratorself$^  $^    cpdef string textself symboltable isymbolsnone              $^        symboltable osymbolsnone symboltable ssymbolsnone$^        bool acceptorfalse bool showweightonefalse missingsymb$^ $^$^static pyobject pyxpw0pywrapfst0fst00textpyobject pyxvself pyobject pyxargs pyobject pyxkwds proto$^static stdstring pyxf0pywrapfst0fsttextstruct pyxobj0pywrapfstfst pyxvself int pyxskipdispatch struct pyxoptargs0pywrapfst0fsttext pyxoptionalargs $^  struct pyxobj0pywrapfstsymboltable pyxvisymbols  struct pyxobj0pywrapfstsymboltable pynone$^$^   pywrapfst.pyx0000$^  $^    cpdef string textself symboltable isymbolsnone$^        symboltable osymbolsnone symboltable ssymbolsnone              $^        bool acceptorfalse bool showweightonefalse missingsymb$^      $^ $^  struct pyxobj0pywrapfstsymboltable pyxvosymbols  struct pyxobj0pywrapfstsymboltable pynone$^  struct pyxobj0pywrapfstsymboltable pyxvssymbols  struct pyxobj0pywrapfstsymboltable pynone$^$^   pywrapfst.pyx0000$^    cpdef string textself symboltable isymbolsnone$^        symboltable osymbolsnone symboltable ssymbolsnone$^        bool acceptorfalse bool showweightonefalse missingsymb              $^      $^      textself isymbolsnone osymbolsnone ssymbolsnone acceptorfalse$^ $^  bool pyxvacceptor  bool0$^  bool pyxvshowweightone  bool0$^  pyobject pyxvmissingsym  pyobject pyxkpb00$^  fstsymboltable pyxvssymbolsptr$^  stdstringstream pyxvsstrm$^  stdstring pyxr$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  int pyxt0$^  pyobject pyxt0  null$^  stdstring pyxt0$^  int pyxt00$^  int pyxt00$^  fstsymboltable pyxt00$^  fstsymboltable const pyxt00$^  fstsymboltable const pyxt00$^  stdstring pyxt00$^  pyxrefnannysetupcontexttext 0$^  if pyxoptionalargs $^    if pyxoptionalargspyxn  0 $^      pyxvisymbols  pyxoptionalargsisymbols$^      if pyxoptionalargspyxn  0 $^        pyxvosymbols  pyxoptionalargsosymbols$^        if pyxoptionalargspyxn  0 $^          pyxvssymbols  pyxoptionalargsssymbols$^          if pyxoptionalargspyxn  0 $^            pyxvacceptor  pyxoptionalargsacceptor$^            if pyxoptionalargspyxn  0 $^              pyxvshowweightone  pyxoptionalargsshowweightone$^              if pyxoptionalargspyxn  0 $^                pyxvmissingsym  pyxoptionalargsmissingsym$^              $^            $^          $^        $^      $^    $^  $^$^   pywrapfst.pyx0000$^      return stateiteratorself$^  $^    cpdef string textself symboltable isymbolsnone              $^        symboltable osymbolsnone symboltable ssymbolsnone$^        bool acceptorfalse bool showweightonefalse missingsymb$^ $^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnstext if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst0fst00text $^      pyxt0  pyxpyboolfromlongpyxvacceptor if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxgotrefpyxt0$^      pyxt0  pyxpyboolfromlongpyxvshowweightone if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxgotrefpyxt0$^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      pyxt0  0$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^          pyxt0  0$^        $^      $^      if cythonfastpycall$^      if pyfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyobject pyxvisymbols pyobject pyxvosymbols pyobject pyxvssymbols pyxt0 pyxt0 pyxvmissingsym$^        pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp0pyxt0 0pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^        pyxdecrefpyxt0 pyxt0  0$^       else$^      endif$^      if cythonfastpyccall$^      if pyxpyfastcfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyobject pyxvisymbols pyobject pyxvosymbols pyobject pyxvssymbols pyxt0 pyxt0 pyxvmissingsym$^        pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp0pyxt0 0pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^        pyxdecrefpyxt0 pyxt0  0$^       else$^      endif$^      $^        pyxt0  pytuplenew0pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxgotrefpyxt0$^        if pyxt0 $^          pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^        $^        pyxincrefpyobject pyxvisymbols$^        pyxgiverefpyobject pyxvisymbols$^        pytuplesetitempyxt0 0pyxt0 pyobject pyxvisymbols$^        pyxincrefpyobject pyxvosymbols$^        pyxgiverefpyobject pyxvosymbols$^        pytuplesetitempyxt0 0pyxt0 pyobject pyxvosymbols$^        pyxincrefpyobject pyxvssymbols$^        pyxgiverefpyobject pyxvssymbols$^        pytuplesetitempyxt0 0pyxt0 pyobject pyxvssymbols$^        pyxgiverefpyxt0$^        pytuplesetitempyxt0 0pyxt0 pyxt0$^        pyxgiverefpyxt0$^        pytuplesetitempyxt0 0pyxt0 pyxt0$^        pyxincrefpyxvmissingsym$^        pyxgiverefpyxvmissingsym$^        pytuplesetitempyxt0 0pyxt0 pyxvmissingsym$^        pyxt0  0$^        pyxt0  0$^        pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^      $^      pyxdecrefpyxt0 pyxt0  0$^      pyxt0  pyxconvertstringfrompystdinstringpyxt0 if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxr  pyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx0000$^      $^       prints fst to stringstream then returns resulting string.$^      cdef fst.symboltable ssymbolsptr  null              $^      if ssymbols is not none$^        ssymbolsptr  ssymbols.table$^ $^  pyxvssymbolsptr  null$^$^   pywrapfst.pyx0000$^       prints fst to stringstream then returns resulting string.$^      cdef fst.symboltable ssymbolsptr  null$^      if ssymbols is not none              $^        ssymbolsptr  ssymbols.table$^      cdef stringstream sstrm$^ $^  pyxt00  pyobject pyxvssymbols  pynone$^  pyxt00  pyxt00  0$^  if pyxt00 $^$^     pywrapfst.pyx0000$^      cdef fst.symboltable ssymbolsptr  null$^      if ssymbols is not none$^        ssymbolsptr  ssymbols.table              $^      cdef stringstream sstrm$^      fst.printfstderefself.fst sstrm bpywrapfst$^ $^    if unlikelypyobject pyxvssymbols  pynone $^      pyerrformatpyexcattributeerror nonetype object has no attribute .00s table$^      pyxerr0 0000 pyxl0error$^    $^    pyxt00  pyxvssymbolstable$^    pyxvssymbolsptr  pyxt00$^$^     pywrapfst.pyx0000$^       prints fst to stringstream then returns resulting string.$^      cdef fst.symboltable ssymbolsptr  null$^      if ssymbols is not none              $^        ssymbolsptr  ssymbols.table$^      cdef stringstream sstrm$^ $^  $^$^   pywrapfst.pyx0000$^        ssymbolsptr  ssymbols.table$^      cdef stringstream sstrm$^      fst.printfstderefself.fst sstrm bpywrapfst              $^          self.fst.get.inputsymbols if isymbols is none$^          else isymbols.table$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s fst$^    pyxerr0 0000 pyxl0error$^  $^  pyxt0  pyxconvertstringfrompystdinstringpyxkpbpywrapfst if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^      cdef stringstream sstrm$^      fst.printfstderefself.fst sstrm bpywrapfst$^          self.fst.get.inputsymbols if isymbols is none              $^          else isymbols.table$^          self.fst.get.outputsymbols if osymbols is none$^ $^  pyxt00  pyobject pyxvisymbols  pynone$^  if pyxt00  0 $^    if unlikelypyobject pyxvself  pynone $^      pyerrformatpyexcattributeerror nonetype object has no attribute .00s fst$^      pyxerr0 0000 pyxl0error$^    $^    pyxt00  pyxvselffst.getinputsymbols$^   else $^$^     pywrapfst.pyx0000$^      fst.printfstderefself.fst sstrm bpywrapfst$^          self.fst.get.inputsymbols if isymbols is none$^          else isymbols.table              $^          self.fst.get.outputsymbols if osymbols is none$^          else osymbols.table$^ $^    if unlikelypyobject pyxvisymbols  pynone $^      pyerrformatpyexcattributeerror nonetype object has no attribute .00s table$^      pyxerr0 0000 pyxl0error$^    $^    pyxt00  pyxvisymbolstable$^  $^$^   pywrapfst.pyx0000$^          self.fst.get.inputsymbols if isymbols is none$^          else isymbols.table$^          self.fst.get.outputsymbols if osymbols is none              $^          else osymbols.table$^          ssymbolsptr acceptor showweightone tostringmissingsym$^ $^  pyxt00  pyobject pyxvosymbols  pynone$^  if pyxt00  0 $^    if unlikelypyobject pyxvself  pynone $^      pyerrformatpyexcattributeerror nonetype object has no attribute .00s fst$^      pyxerr0 0000 pyxl0error$^    $^    pyxt00  pyxvselffst.getoutputsymbols$^   else $^$^     pywrapfst.pyx0000$^          else isymbols.table$^          self.fst.get.outputsymbols if osymbols is none$^          else osymbols.table              $^          ssymbolsptr acceptor showweightone tostringmissingsym$^      return sstrm.str$^ $^    if unlikelypyobject pyxvosymbols  pynone $^      pyerrformatpyexcattributeerror nonetype object has no attribute .00s table$^      pyxerr0 0000 pyxl0error$^    $^    pyxt00  pyxvosymbolstable$^  $^$^   pywrapfst.pyx0000$^          self.fst.get.outputsymbols if osymbols is none$^          else osymbols.table$^          ssymbolsptr acceptor showweightone tostringmissingsym              $^      return sstrm.str$^  $^ $^  pyxt00  pyxf0pywrapfsttostringpyxvmissingsym null if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^        ssymbolsptr  ssymbols.table$^      cdef stringstream sstrm$^      fst.printfstderefself.fst sstrm bpywrapfst              $^          self.fst.get.inputsymbols if isymbols is none$^          else isymbols.table$^ $^  fstscriptprintfstpyxvselffst pyxvsstrm pyxt0 pyxt00 pyxt00 pyxvssymbolsptr pyxvacceptor pyxvshowweightone pyxt00$^$^   pywrapfst.pyx0000$^          else osymbols.table$^          ssymbolsptr acceptor showweightone tostringmissingsym$^      return sstrm.str              $^  $^    cpdef bool verifyself$^ $^  pyxr  pyxvsstrm.str$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      return stateiteratorself$^  $^    cpdef string textself symboltable isymbolsnone              $^        symboltable osymbolsnone symboltable ssymbolsnone$^        bool acceptorfalse bool showweightonefalse missingsymb$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxwriteunraisablepywrapfst.fst.text pyxclineno pyxlineno pyxfilename 0 0$^  pyxpretendtoinitializepyxr$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst0fst00textpyobject pyxvself pyobject pyxargs pyobject pyxkwds proto$^static char pyxdoc0pywrapfst0fst00text  n    textself isymbolsnone osymbolsnone ssymbolsnone acceptorfalsen         showweightonefalse missingsymnn    produces a humanreadable string representation of the fst.nn    this method generates a humanreadable string representation of the fst.n    the caller may optionally specify symboltables used to label input labelsn    output labels or state labels respectively.nn    argsn      isymbols an optional symbol table used to label input symbols.n      osymbols an optional symbol table used to label output symbols.n      ssymbols an optional symbol table used to label states.n      acceptor should the fst be rendered in acceptor format if possiblen      showweightone should weights equivalent to semiring one be printedn      missingsymbol the string to be printed when symbol table lookup fails.nn    returnsn      a formatted string representing the machine.n    $^static pyobject pyxpw0pywrapfst0fst00textpyobject pyxvself pyobject pyxargs pyobject pyxkwds $^  struct pyxobj0pywrapfstsymboltable pyxvisymbols  0$^  struct pyxobj0pywrapfstsymboltable pyxvosymbols  0$^  struct pyxobj0pywrapfstsymboltable pyxvssymbols  0$^  bool pyxvacceptor$^  bool pyxvshowweightone$^  pyobject pyxvmissingsym  0$^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontexttext wrapper 0$^  $^    static pyobject pyxpyargnames  pyxnsisymbolspyxnsosymbolspyxnsssymbolspyxnsacceptorpyxnsshowweightonepyxnsmissingsym0$^    pyobject values0  000000$^    values0  pyobject struct pyxobj0pywrapfstsymboltable pynone$^$^     pywrapfst.pyx0000$^  $^    cpdef string textself symboltable isymbolsnone$^        symboltable osymbolsnone symboltable ssymbolsnone              $^        bool acceptorfalse bool showweightonefalse missingsymb$^      $^ $^    values0  pyobject struct pyxobj0pywrapfstsymboltable pynone$^    values0  pyobject struct pyxobj0pywrapfstsymboltable pynone$^    values0  pyobject pyxkpb00$^    if unlikelypyxkwds $^      pyssizet kwargs$^      const pyssizet posargs  pytuplegetsizepyxargs$^      switch posargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 break$^        default goto pyxl0argtupleerror$^      $^      kwargs  pydictsizepyxkwds$^      switch posargs $^        case  0$^        if kwargs  0 $^          pyobject value  pydictgetitempyxkwds pyxnsisymbols$^          if value  values0  value kwargs $^        $^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pydictgetitempyxkwds pyxnsosymbols$^          if value  values0  value kwargs $^        $^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pydictgetitempyxkwds pyxnsssymbols$^          if value  values0  value kwargs $^        $^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pydictgetitempyxkwds pyxnsacceptor$^          if value  values0  value kwargs $^        $^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pydictgetitempyxkwds pyxnsshowweightone$^          if value  values0  value kwargs $^        $^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pydictgetitempyxkwds pyxnsmissingsym$^          if value  values0  value kwargs $^        $^      $^      if unlikelykwargs  0 $^        if unlikelypyxparseoptionalkeywordspyxkwds pyxpyargnames 0 values posargs text  0 pyxerr0 0000 pyxl0error$^      $^     else $^      switch pytuplegetsizepyxargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 break$^        default goto pyxl0argtupleerror$^      $^    $^    pyxvisymbols  struct pyxobj0pywrapfstsymboltable values0$^    pyxvosymbols  struct pyxobj0pywrapfstsymboltable values0$^    pyxvssymbols  struct pyxobj0pywrapfstsymboltable values0$^    if values0 $^      pyxvacceptor  pyxpyobjectistruevalues0 if unlikelypyxvacceptor  bool0  pyerroccurred pyxerr0 0000 pyxl0error$^     else $^$^       pywrapfst.pyx0000$^    cpdef string textself symboltable isymbolsnone$^        symboltable osymbolsnone symboltable ssymbolsnone$^        bool acceptorfalse bool showweightonefalse missingsymb              $^      $^      textself isymbolsnone osymbolsnone ssymbolsnone acceptorfalse$^ $^      pyxvacceptor  bool0$^    $^    if values0 $^      pyxvshowweightone  pyxpyobjectistruevalues0 if unlikelypyxvshowweightone  bool0  pyerroccurred pyxerr0 0000 pyxl0error$^     else $^      pyxvshowweightone  bool0$^    $^    pyxvmissingsym  values0$^  $^  goto pyxl0argumentunpackingdone$^  pyxl0argtupleerror$^  pyxraiseargtupleinvalidtext 0 0 0 pytuplegetsizepyxargs pyxerr0 0000 pyxl0error$^  pyxl0error$^  pyxaddtracebackpywrapfst.fst.text pyxclineno pyxlineno pyxfilename$^  pyxrefnannyfinishcontext$^  return null$^  pyxl0argumentunpackingdone$^  if unlikelypyxargtypetestpyobject pyxvisymbols pyxptype0pywrapfstsymboltable 0 isymbols 0 pyxerr0 0000 pyxl0error$^  if unlikelypyxargtypetestpyobject pyxvosymbols pyxptype0pywrapfstsymboltable 0 osymbols 0 pyxerr0 0000 pyxl0error$^  if unlikelypyxargtypetestpyobject pyxvssymbols pyxptype0pywrapfstsymboltable 0 ssymbols 0 pyxerr0 0000 pyxl0error$^  pyxr  pyxpf0pywrapfst0fst00textstruct pyxobj0pywrapfstfst pyxvself pyxvisymbols pyxvosymbols pyxvssymbols pyxvacceptor pyxvshowweightone pyxvmissingsym$^$^   pywrapfst.pyx0000$^      return stateiteratorself$^  $^    cpdef string textself symboltable isymbolsnone              $^        symboltable osymbolsnone symboltable ssymbolsnone$^        bool acceptorfalse bool showweightonefalse missingsymb$^ $^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxr  null$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst0fst00textstruct pyxobj0pywrapfstfst pyxvself struct pyxobj0pywrapfstsymboltable pyxvisymbols struct pyxobj0pywrapfstsymboltable pyxvosymbols struct pyxobj0pywrapfstsymboltable pyxvssymbols bool pyxvacceptor bool pyxvshowweightone pyobject pyxvmissingsym $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  stdstring pyxt0$^  struct pyxoptargs0pywrapfst0fsttext pyxt0$^  pyobject pyxt0  null$^  pyxrefnannysetupcontexttext 0$^  pyxxdecrefpyxr$^  pyxt0.pyxn  0$^  pyxt0.isymbols  pyxvisymbols$^  pyxt0.osymbols  pyxvosymbols$^  pyxt0.ssymbols  pyxvssymbols$^  pyxt0.acceptor  pyxvacceptor$^  pyxt0.showweightone  pyxvshowweightone$^  pyxt0.missingsym  pyxvmissingsym$^  pyxt0  pyxvtabptr0pywrapfstfsttextpyxvself 0 pyxt0 $^  pyxt0  pyxconvertpybytesstringtopystdinstringpyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.fst.text pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return sstrm.str$^  $^    cpdef bool verifyself              $^      $^      verifyself$^ $^$^static pyobject pyxpw0pywrapfst0fst00verifypyobject pyxvself cythonunused pyobject unused proto$^static bool pyxf0pywrapfst0fstverifystruct pyxobj0pywrapfstfst pyxvself int pyxskipdispatch $^  bool pyxr$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  bool pyxt0$^  pyxrefnannysetupcontextverify 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnsverify if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst0fst00verify $^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxdecrefpyxt0 pyxt0  0$^       else $^        pyxt0  pyxpyobjectcallnoargpyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      $^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxt0  pyxpyobjectistruepyxt0 if unlikelypyxt0  bool0  pyerroccurred pyxerr0 0000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxr  pyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx0000$^        true if the contents are sane false otherwise.$^      $^      return fst.verifyderefself.fst              $^  $^    cpdef string weighttypeself$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s fst$^    pyxerr0 0000 pyxl0error$^  $^  pyxr  fstscriptverifypyxvselffst$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      return sstrm.str$^  $^    cpdef bool verifyself              $^      $^      verifyself$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxwriteunraisablepywrapfst.fst.verify pyxclineno pyxlineno pyxfilename 0 0$^  pyxr  0$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst0fst00verifypyobject pyxvself cythonunused pyobject unused proto$^static char pyxdoc0pywrapfst0fst00verify  n    verifyselfnn    verifies that an fsts contents are sane.nn    returnsn      true if the contents are sane false otherwise.n    $^static pyobject pyxpw0pywrapfst0fst00verifypyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextverify wrapper 0$^  pyxr  pyxpf0pywrapfst0fst00verifystruct pyxobj0pywrapfstfst pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst0fst00verifystruct pyxobj0pywrapfstfst pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextverify 0$^  pyxxdecrefpyxr$^  pyxt0  pyxpyboolfromlongpyxf0pywrapfst0fstverifypyxvself 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.fst.verify pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return fst.verifyderefself.fst$^  $^    cpdef string weighttypeself              $^      $^      weighttypeself$^ $^$^static pyobject pyxpw0pywrapfst0fst00weighttypepyobject pyxvself cythonunused pyobject unused proto$^static stdstring pyxf0pywrapfst0fstweighttypestruct pyxobj0pywrapfstfst pyxvself int pyxskipdispatch $^  stdstring pyxr$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  stdstring pyxt0$^  pyxrefnannysetupcontextweighttype 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnsweighttype if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst0fst00weighttype $^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxdecrefpyxt0 pyxt0  0$^       else $^        pyxt0  pyxpyobjectcallnoargpyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      $^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxt0  pyxconvertstringfrompystdinstringpyxt0 if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxr  pyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx0000$^        a string representing the weight type.$^      $^      return self.fst.get.weighttype              $^  $^    cpdef void writeself filename except $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s fst$^    pyxerr0 0000 pyxl0error$^  $^  pyxr  pyxvselffst.getweighttype$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      return fst.verifyderefself.fst$^  $^    cpdef string weighttypeself              $^      $^      weighttypeself$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxwriteunraisablepywrapfst.fst.weighttype pyxclineno pyxlineno pyxfilename 0 0$^  pyxpretendtoinitializepyxr$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst0fst00weighttypepyobject pyxvself cythonunused pyobject unused proto$^static char pyxdoc0pywrapfst0fst00weighttype  n    weighttypeselfnn    provides the fsts weight type.nn    returnsn      a string representing the weight type.n    $^static pyobject pyxpw0pywrapfst0fst00weighttypepyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextweighttype wrapper 0$^  pyxr  pyxpf0pywrapfst0fst00weighttypestruct pyxobj0pywrapfstfst pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst0fst00weighttypestruct pyxobj0pywrapfstfst pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextweighttype 0$^  pyxxdecrefpyxr$^  pyxt0  pyxconvertpybytesstringtopystdinstringpyxf0pywrapfst0fstweighttypepyxvself 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.fst.weighttype pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return self.fst.get.weighttype$^  $^    cpdef void writeself filename except               $^      $^      writeself filename$^ $^$^static pyobject pyxpw0pywrapfst0fst00writepyobject pyxvself pyobject pyxvfilename proto$^static void pyxf0pywrapfst0fstwritestruct pyxobj0pywrapfstfst pyxvself pyobject pyxvfilename int pyxskipdispatch $^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  stdstring pyxt0$^  int pyxt0$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextwrite 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnswrite if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst0fst00write $^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxvfilename if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxgotrefpyxt0$^       else $^        if cythonfastpycall$^        if pyfunctioncheckpyxt0 $^          pyobject pyxtemp0  pyxt0 pyxvfilename$^          pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^          pyxxdecrefpyxt0 pyxt0  0$^          pyxgotrefpyxt0$^         else$^        endif$^        if cythonfastpyccall$^        if pyxpyfastcfunctioncheckpyxt0 $^          pyobject pyxtemp0  pyxt0 pyxvfilename$^          pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^          pyxxdecrefpyxt0 pyxt0  0$^          pyxgotrefpyxt0$^         else$^        endif$^        $^          pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^          pyxgotrefpyxt0$^          pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^          pyxincrefpyxvfilename$^          pyxgiverefpyxvfilename$^          pytuplesetitempyxt0 00 pyxvfilename$^          pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^          pyxgotrefpyxt0$^          pyxdecrefpyxt0 pyxt0  0$^        $^      $^      pyxdecrefpyxt0 pyxt0  0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx0000$^        fstioerror write failed.$^      $^      if not self.fst.get.writetostringfilename              $^        raise fstioerrorwrite failed r.formatfilename$^  $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s fst$^    pyxerr0 0000 pyxl0error$^  $^  pyxt0  pyxf0pywrapfsttostringpyxvfilename null if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^  pyxt0  pyxvselffst.getwritepyxt0  0  0$^  if pyxt0 $^$^     pywrapfst.pyx0000$^      $^      if not self.fst.get.writetostringfilename$^        raise fstioerrorwrite failed r.formatfilename              $^  $^    cpdef string writetostringself$^ $^    pyxt0  pyxgetmoduleglobalnamepyxnsfstioerror if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  pyxpyobjectgetattrstrpyxkpswritefailedr pyxnsformat if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  null$^    if cythonunpackmethods  likelypymethodcheckpyxt0 $^      pyxt0  pymethodgetselfpyxt0$^      if likelypyxt0 $^        pyobject function  pymethodgetfunctionpyxt0$^        pyxincrefpyxt0$^        pyxincreffunction$^        pyxdecrefsetpyxt0 function$^      $^    $^    if pyxt0 $^      pyxt0  pyxpyobjectcalloneargpyxt0 pyxvfilename if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxgotrefpyxt0$^     else $^      if cythonfastpycall$^      if pyfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxvfilename$^        pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^       else$^      endif$^      if cythonfastpyccall$^      if pyxpyfastcfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxvfilename$^        pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^       else$^      endif$^      $^        pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxgotrefpyxt0$^        pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^        pyxincrefpyxvfilename$^        pyxgiverefpyxvfilename$^        pytuplesetitempyxt0 00 pyxvfilename$^        pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^      $^    $^    pyxdecrefpyxt0 pyxt0  0$^    pyxt0  null$^    if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^      pyxt0  pymethodgetselfpyxt0$^      if likelypyxt0 $^        pyobject function  pymethodgetfunctionpyxt0$^        pyxincrefpyxt0$^        pyxincreffunction$^        pyxdecrefsetpyxt0 function$^      $^    $^    if pyxt0 $^      pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxgotrefpyxt0$^     else $^      if cythonfastpycall$^      if pyfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxt0$^        pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^       else$^      endif$^      if cythonfastpyccall$^      if pyxpyfastcfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxt0$^        pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^       else$^      endif$^      $^        pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxgotrefpyxt0$^        pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^        pyxgiverefpyxt0$^        pytuplesetitempyxt0 00 pyxt0$^        pyxt0  0$^        pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^      $^    $^    pyxdecrefpyxt0 pyxt0  0$^    pyxraisepyxt0 0 0 0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxerr0 0000 pyxl0error$^$^     pywrapfst.pyx0000$^        fstioerror write failed.$^      $^      if not self.fst.get.writetostringfilename              $^        raise fstioerrorwrite failed r.formatfilename$^  $^ $^  $^$^   pywrapfst.pyx0000$^      return self.fst.get.weighttype$^  $^    cpdef void writeself filename except               $^      $^      writeself filename$^ $^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.fst.write pyxclineno pyxlineno pyxfilename$^  pyxl0$^  pyxrefnannyfinishcontext$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst0fst00writepyobject pyxvself pyobject pyxvfilename proto$^static char pyxdoc0pywrapfst0fst00write  n    writeself filenamenn    serializes fst to a file.nn    this method writes the fst to a file in a binary format.nn    argsn      filename the string location of the output file.nn    raisesn      fstioerror write failed.n    $^static pyobject pyxpw0pywrapfst0fst00writepyobject pyxvself pyobject pyxvfilename $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextwrite wrapper 0$^  pyxr  pyxpf0pywrapfst0fst00writestruct pyxobj0pywrapfstfst pyxvself pyobject pyxvfilename$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst0fst00writestruct pyxobj0pywrapfstfst pyxvself pyobject pyxvfilename $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextwrite 0$^  pyxxdecrefpyxr$^  pyxf0pywrapfst0fstwritepyxvself pyxvfilename 0 if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^  pyxt0  pyxvoidtononenull if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.fst.write pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^        raise fstioerrorwrite failed r.formatfilename$^  $^    cpdef string writetostringself              $^      $^      writetostringself$^ $^$^static pyobject pyxpw0pywrapfst0fst00writetostringpyobject pyxvself cythonunused pyobject unused proto$^static stdstring pyxf0pywrapfst0fstwritetostringstruct pyxobj0pywrapfstfst pyxvself int pyxskipdispatch $^  stdstringstream pyxvsstrm$^  stdstring pyxr$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  stdstring pyxt0$^  int pyxt0$^  pyxrefnannysetupcontextwritetostring 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnswritetostring if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst0fst00writetostring $^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxdecrefpyxt0 pyxt0  0$^       else $^        pyxt0  pyxpyobjectcallnoargpyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      $^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxt0  pyxconvertstringfrompystdinstringpyxt0 if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxr  pyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx0000$^      $^      cdef stringstream sstrm$^      if not self.fst.get.writesstrm writetostring              $^        raise fstioerrorwrite to string failed$^      return sstrm.str$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s fst$^    pyxerr0 0000 pyxl0error$^  $^  pyxt0  pyxconvertstringfrompystdinstringpyxnbwritetostring if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^  pyxt0  pyxvselffst.getwritepyxvsstrm pyxt0  0  0$^  if pyxt0 $^$^     pywrapfst.pyx0000$^      cdef stringstream sstrm$^      if not self.fst.get.writesstrm writetostring$^        raise fstioerrorwrite to string failed              $^      return sstrm.str$^  $^ $^    pyxt0  pyxgetmoduleglobalnamepyxnsfstioerror if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  pyxpyobjectcallpyxt0 pyxtuple00 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxraisepyxt0 0 0 0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxerr0 0000 pyxl0error$^$^     pywrapfst.pyx0000$^      $^      cdef stringstream sstrm$^      if not self.fst.get.writesstrm writetostring              $^        raise fstioerrorwrite to string failed$^      return sstrm.str$^ $^  $^$^   pywrapfst.pyx0000$^      if not self.fst.get.writesstrm writetostring$^        raise fstioerrorwrite to string failed$^      return sstrm.str              $^  $^  $^ $^  pyxr  pyxvsstrm.str$^  goto pyxl0$^$^   pywrapfst.pyx0000$^        raise fstioerrorwrite failed r.formatfilename$^  $^    cpdef string writetostringself              $^      $^      writetostringself$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxwriteunraisablepywrapfst.fst.writetostring pyxclineno pyxlineno pyxfilename 0 0$^  pyxpretendtoinitializepyxr$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst0fst00writetostringpyobject pyxvself cythonunused pyobject unused proto$^static char pyxdoc0pywrapfst0fst00writetostring  n    writetostringselfnn    serializes fst to a string.nn    returnsn      a string.nn    raisesn      fstioerror write to string failed.nn    see also readfromstring.n    $^static pyobject pyxpw0pywrapfst0fst00writetostringpyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextwritetostring wrapper 0$^  pyxr  pyxpf0pywrapfst0fst00writetostringstruct pyxobj0pywrapfstfst pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst0fst00writetostringstruct pyxobj0pywrapfstfst pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextwritetostring 0$^  pyxxdecrefpyxr$^  pyxt0  pyxconvertpybytesstringtopystdinstringpyxf0pywrapfst0fstwritetostringpyxvself 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.fst.writetostring pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^    $^  $^    cdef void checkmutatingimethodself except               $^      checks whether an operation mutating the fst has produced an error.$^  $^ $^$^static void pyxf0pywrapfst00mutablefstcheckmutatingimethodstruct pyxobj0pywrapfstmutablefst pyxvself $^  pyxrefnannydeclarations$^  int pyxt0$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextcheckmutatingimethod 0$^$^   pywrapfst.pyx0000$^      this function is not visible to python users.$^      $^      if self.fst.get.propertiesfst.kerror true  fst.kerror              $^        raise fstoperroroperation failed$^  $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s fst$^    pyxerr0 0000 pyxl0error$^  $^  pyxt0  pyxvselfpyxbase.fst.getpropertiesfstkerror 0  fstkerror  0$^  if pyxt0 $^$^     pywrapfst.pyx0000$^      $^      if self.fst.get.propertiesfst.kerror true  fst.kerror$^        raise fstoperroroperation failed              $^  $^    cdef void addarcself int00 state arc arc except $^ $^    pyxt0  pyxgetmoduleglobalnamepyxnsfstoperror if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  pyxpyobjectcallpyxt0 pyxtuple00 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxraisepyxt0 0 0 0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxerr0 0000 pyxl0error$^$^     pywrapfst.pyx0000$^      this function is not visible to python users.$^      $^      if self.fst.get.propertiesfst.kerror true  fst.kerror              $^        raise fstoperroroperation failed$^  $^ $^  $^$^   pywrapfst.pyx0000$^    $^  $^    cdef void checkmutatingimethodself except               $^      checks whether an operation mutating the fst has produced an error.$^  $^ $^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.mutablefst.checkmutatingimethod pyxclineno pyxlineno pyxfilename$^  pyxl0$^  pyxrefnannyfinishcontext$^$^$^ pywrapfst.pyx0000$^        raise fstoperroroperation failed$^  $^    cdef void addarcself int00 state arc arc except               $^      if not self.fst.get.validstateidstate$^        raise fstindexerrorstate index out of range$^ $^$^static void pyxf0pywrapfst00mutablefstaddarcstruct pyxobj0pywrapfstmutablefst pyxvself pyxt00basictypesint00 pyxvstate struct pyxobj0pywrapfstarc pyxvarc $^  pyxrefnannydeclarations$^  int pyxt0$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextaddarc 0$^$^   pywrapfst.pyx0000$^  $^    cdef void addarcself int00 state arc arc except $^      if not self.fst.get.validstateidstate              $^        raise fstindexerrorstate index out of range$^      if not self.mfst.get.addarcstate derefarc.arc$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s fst$^    pyxerr0 0000 pyxl0error$^  $^  pyxt0  pyxvselfpyxbase.fst.getvalidstateidpyxvstate  0  0$^  if pyxt0 $^$^     pywrapfst.pyx0000$^    cdef void addarcself int00 state arc arc except $^      if not self.fst.get.validstateidstate$^        raise fstindexerrorstate index out of range              $^      if not self.mfst.get.addarcstate derefarc.arc$^        raise fstoperrorincompatible or invalid weight type$^ $^    pyxt0  pyxgetmoduleglobalnamepyxnsfstindexerror if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  pyxpyobjectcallpyxt0 pyxtuple00 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxraisepyxt0 0 0 0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxerr0 0000 pyxl0error$^$^     pywrapfst.pyx0000$^  $^    cdef void addarcself int00 state arc arc except $^      if not self.fst.get.validstateidstate              $^        raise fstindexerrorstate index out of range$^      if not self.mfst.get.addarcstate derefarc.arc$^ $^  $^$^   pywrapfst.pyx0000$^      if not self.fst.get.validstateidstate$^        raise fstindexerrorstate index out of range$^      if not self.mfst.get.addarcstate derefarc.arc              $^        raise fstoperrorincompatible or invalid weight type$^      self.checkmutatingimethod$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s mfst$^    pyxerr0 0000 pyxl0error$^  $^  if unlikelypyobject pyxvarc  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s arc$^    pyxerr0 0000 pyxl0error$^  $^  pyxt0  pyxvselfmfst.getaddarcpyxvstate pyxvarcarc  0  0$^  if pyxt0 $^$^     pywrapfst.pyx0000$^        raise fstindexerrorstate index out of range$^      if not self.mfst.get.addarcstate derefarc.arc$^        raise fstoperrorincompatible or invalid weight type              $^      self.checkmutatingimethod$^  $^ $^    pyxt0  pyxgetmoduleglobalnamepyxnsfstoperror if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  pyxpyobjectcallpyxt0 pyxtuple00 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxraisepyxt0 0 0 0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxerr0 0000 pyxl0error$^$^     pywrapfst.pyx0000$^      if not self.fst.get.validstateidstate$^        raise fstindexerrorstate index out of range$^      if not self.mfst.get.addarcstate derefarc.arc              $^        raise fstoperrorincompatible or invalid weight type$^      self.checkmutatingimethod$^ $^  $^$^   pywrapfst.pyx0000$^      if not self.mfst.get.addarcstate derefarc.arc$^        raise fstoperrorincompatible or invalid weight type$^      self.checkmutatingimethod              $^  $^    def addarcself int00 state arc arc$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s checkmutatingimethod$^    pyxerr0 0000 pyxl0error$^  $^  struct pyxvtabstruct0pywrapfstmutablefst pyxvselfpyxbase.pyxvtabcheckmutatingimethodpyxvself if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^        raise fstoperroroperation failed$^  $^    cdef void addarcself int00 state arc arc except               $^      if not self.fst.get.validstateidstate$^        raise fstindexerrorstate index out of range$^ $^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.mutablefst.addarc pyxclineno pyxlineno pyxfilename$^  pyxl0$^  pyxrefnannyfinishcontext$^$^$^ pywrapfst.pyx0000$^      self.checkmutatingimethod$^  $^    def addarcself int00 state arc arc              $^      $^      addarcself state arc$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00mutablefst0addarcpyobject pyxvself pyobject pyxargs pyobject pyxkwds proto$^static char pyxdoc0pywrapfst00mutablefstaddarc  n    addarcself state arcnn    adds a new arc to the fst and return self.nn    argsn      state the integer index of the source state.n      arc the arc to add.nn    returnsn      self.nn    raisesn      fstindexerror state index out of range.n      fstopdexerror incompatible or invalid weight type.nn    see also addstate.n    $^static pyobject pyxpw0pywrapfst00mutablefst0addarcpyobject pyxvself pyobject pyxargs pyobject pyxkwds $^  pyxt00basictypesint00 pyxvstate$^  struct pyxobj0pywrapfstarc pyxvarc  0$^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextaddarc wrapper 0$^  $^    static pyobject pyxpyargnames  pyxnsstatepyxnsarc0$^    pyobject values0  00$^    if unlikelypyxkwds $^      pyssizet kwargs$^      const pyssizet posargs  pytuplegetsizepyxargs$^      switch posargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 break$^        default goto pyxl0argtupleerror$^      $^      kwargs  pydictsizepyxkwds$^      switch posargs $^        case  0$^        if likelyvalues0  pydictgetitempyxkwds pyxnsstate  0 kwargs$^        else goto pyxl0argtupleerror$^        cythonfallthrough$^        case  0$^        if likelyvalues0  pydictgetitempyxkwds pyxnsarc  0 kwargs$^        else $^          pyxraiseargtupleinvalidaddarc 0 0 0 0 pyxerr0 0000 pyxl0error$^        $^      $^      if unlikelykwargs  0 $^        if unlikelypyxparseoptionalkeywordspyxkwds pyxpyargnames 0 values posargs addarc  0 pyxerr0 0000 pyxl0error$^      $^     else if pytuplegetsizepyxargs  0 $^      goto pyxl0argtupleerror$^     else $^      values0  pytuplegetitempyxargs 0$^      values0  pytuplegetitempyxargs 0$^    $^    pyxvstate  pyxpyintasint00tvalues0 if unlikelypyxvstate  int00t0  pyerroccurred pyxerr0 0000 pyxl0error$^    pyxvarc  struct pyxobj0pywrapfstarc values0$^  $^  goto pyxl0argumentunpackingdone$^  pyxl0argtupleerror$^  pyxraiseargtupleinvalidaddarc 0 0 0 pytuplegetsizepyxargs pyxerr0 0000 pyxl0error$^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablefst.addarc pyxclineno pyxlineno pyxfilename$^  pyxrefnannyfinishcontext$^  return null$^  pyxl0argumentunpackingdone$^  if unlikelypyxargtypetestpyobject pyxvarc pyxptype0pywrapfstarc 0 arc 0 pyxerr0 0000 pyxl0error$^  pyxr  pyxpf0pywrapfst00mutablefstaddarcstruct pyxobj0pywrapfstmutablefst pyxvself pyxvstate pyxvarc$^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxr  null$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00mutablefstaddarcstruct pyxobj0pywrapfstmutablefst pyxvself pyxt00basictypesint00 pyxvstate struct pyxobj0pywrapfstarc pyxvarc $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextaddarc 0$^$^   pywrapfst.pyx0000$^      see also addstate.$^      $^      self.addarcstate arc              $^      return self$^  $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s addarc$^    pyxerr0 0000 pyxl0error$^  $^  struct pyxvtabstruct0pywrapfstmutablefst pyxvselfpyxbase.pyxvtabaddarcpyxvself pyxvstate pyxvarc if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^      $^      self.addarcstate arc$^      return self              $^  $^    cpdef int00 addstateself except $^ $^  pyxxdecrefpyxr$^  pyxincrefpyobject pyxvself$^  pyxr  pyobject pyxvself$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      self.checkmutatingimethod$^  $^    def addarcself int00 state arc arc              $^      $^      addarcself state arc$^ $^$^   function exit code $^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablefst.addarc pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return self$^  $^    cpdef int00 addstateself except               $^      $^      addstateself$^ $^$^static pyobject pyxpw0pywrapfst00mutablefst0addstatepyobject pyxvself cythonunused pyobject unused proto$^static pyxt00basictypesint00 pyxf0pywrapfst00mutablefstaddstatestruct pyxobj0pywrapfstmutablefst pyxvself int pyxskipdispatch $^  pyxt00basictypesint00 pyxvresult$^  pyxt00basictypesint00 pyxr$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxt00basictypesint00 pyxt0$^  pyxrefnannysetupcontextaddstate 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnsaddstate if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst00mutablefst0addstate $^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxdecrefpyxt0 pyxt0  0$^       else $^        pyxt0  pyxpyobjectcallnoargpyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      $^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxt0  pyxpyintasint00tpyxt0 if unlikelypyxt0  int00t0  pyerroccurred pyxerr0 0000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxr  pyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx0000$^      see also addarc setstart setfinal.$^      $^      cdef int00 result  self.mfst.get.addstate              $^      self.checkmutatingimethod$^      return result$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s mfst$^    pyxerr0 0000 pyxl0error$^  $^  pyxvresult  pyxvselfmfst.getaddstate$^$^   pywrapfst.pyx0000$^      $^      cdef int00 result  self.mfst.get.addstate$^      self.checkmutatingimethod              $^      return result$^  $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s checkmutatingimethod$^    pyxerr0 0000 pyxl0error$^  $^  struct pyxvtabstruct0pywrapfstmutablefst pyxvselfpyxbase.pyxvtabcheckmutatingimethodpyxvself if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^      cdef int00 result  self.mfst.get.addstate$^      self.checkmutatingimethod$^      return result              $^  $^    cdef void arcsortself sorttypebilabel except $^ $^  pyxr  pyxvresult$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      return self$^  $^    cpdef int00 addstateself except               $^      $^      addstateself$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.mutablefst.addstate pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst00mutablefst0addstatepyobject pyxvself cythonunused pyobject unused proto$^static char pyxdoc0pywrapfst00mutablefst0addstate  n    addstateselfnn    adds a new state to the fst and returns the state id.nn    returnsn      the integer index of the new state.nn    see also addarc setstart setfinal.n    $^static pyobject pyxpw0pywrapfst00mutablefst0addstatepyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextaddstate wrapper 0$^  pyxr  pyxpf0pywrapfst00mutablefst0addstatestruct pyxobj0pywrapfstmutablefst pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00mutablefst0addstatestruct pyxobj0pywrapfstmutablefst pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyxt00basictypesint00 pyxt0$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextaddstate 0$^  pyxxdecrefpyxr$^  pyxt0  pyxf0pywrapfst00mutablefstaddstatepyxvself 0 if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^  pyxt0  pyxpyintfromint00tpyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.mutablefst.addstate pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return result$^  $^    cdef void arcsortself sorttypebilabel except               $^      cdef fst.arcsorttype sorttypeenum$^      if not fst.getarcsorttypetostringsorttype addrsorttypeenum$^ $^$^static void pyxf0pywrapfst00mutablefstarcsortstruct pyxobj0pywrapfstmutablefst pyxvself struct pyxoptargs0pywrapfst00mutablefstarcsort pyxoptionalargs $^  pyobject pyxvsorttype  pyobject pyxnbilabel$^  enum fstscriptarcsorttype pyxvsorttypeenum$^  pyxrefnannydeclarations$^  stdstring pyxt0$^  int pyxt0$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextarcsort 0$^  if pyxoptionalargs $^    if pyxoptionalargspyxn  0 $^      pyxvsorttype  pyxoptionalargssorttype$^    $^  $^$^   pywrapfst.pyx0000$^    cdef void arcsortself sorttypebilabel except $^      cdef fst.arcsorttype sorttypeenum$^      if not fst.getarcsorttypetostringsorttype addrsorttypeenum              $^        raise fstargerrorunknown sort type r.formatsorttype$^      fst.arcsortself.mfst.get sorttypeenum$^ $^  pyxt0  pyxf0pywrapfsttostringpyxvsorttype null if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^  pyxt0  fstscriptgetarcsorttypepyxt0 pyxvsorttypeenum  0  0$^  if pyxt0 $^$^     pywrapfst.pyx0000$^      cdef fst.arcsorttype sorttypeenum$^      if not fst.getarcsorttypetostringsorttype addrsorttypeenum$^        raise fstargerrorunknown sort type r.formatsorttype              $^      fst.arcsortself.mfst.get sorttypeenum$^      self.checkmutatingimethod$^ $^    pyxt0  pyxgetmoduleglobalnamepyxnsfstargerror if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  pyxpyobjectgetattrstrpyxkpsunknownsorttyper pyxnsformat if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  null$^    if cythonunpackmethods  likelypymethodcheckpyxt0 $^      pyxt0  pymethodgetselfpyxt0$^      if likelypyxt0 $^        pyobject function  pymethodgetfunctionpyxt0$^        pyxincrefpyxt0$^        pyxincreffunction$^        pyxdecrefsetpyxt0 function$^      $^    $^    if pyxt0 $^      pyxt0  pyxpyobjectcalloneargpyxt0 pyxvsorttype if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxgotrefpyxt0$^     else $^      if cythonfastpycall$^      if pyfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxvsorttype$^        pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^       else$^      endif$^      if cythonfastpyccall$^      if pyxpyfastcfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxvsorttype$^        pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^       else$^      endif$^      $^        pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxgotrefpyxt0$^        pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^        pyxincrefpyxvsorttype$^        pyxgiverefpyxvsorttype$^        pytuplesetitempyxt0 00 pyxvsorttype$^        pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^      $^    $^    pyxdecrefpyxt0 pyxt0  0$^    pyxt0  null$^    if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^      pyxt0  pymethodgetselfpyxt0$^      if likelypyxt0 $^        pyobject function  pymethodgetfunctionpyxt0$^        pyxincrefpyxt0$^        pyxincreffunction$^        pyxdecrefsetpyxt0 function$^      $^    $^    if pyxt0 $^      pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxgotrefpyxt0$^     else $^      if cythonfastpycall$^      if pyfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxt0$^        pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^       else$^      endif$^      if cythonfastpyccall$^      if pyxpyfastcfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxt0$^        pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^       else$^      endif$^      $^        pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxgotrefpyxt0$^        pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^        pyxgiverefpyxt0$^        pytuplesetitempyxt0 00 pyxt0$^        pyxt0  0$^        pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^      $^    $^    pyxdecrefpyxt0 pyxt0  0$^    pyxraisepyxt0 0 0 0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxerr0 0000 pyxl0error$^$^     pywrapfst.pyx0000$^    cdef void arcsortself sorttypebilabel except $^      cdef fst.arcsorttype sorttypeenum$^      if not fst.getarcsorttypetostringsorttype addrsorttypeenum              $^        raise fstargerrorunknown sort type r.formatsorttype$^      fst.arcsortself.mfst.get sorttypeenum$^ $^  $^$^   pywrapfst.pyx0000$^      if not fst.getarcsorttypetostringsorttype addrsorttypeenum$^        raise fstargerrorunknown sort type r.formatsorttype$^      fst.arcsortself.mfst.get sorttypeenum              $^      self.checkmutatingimethod$^  $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s mfst$^    pyxerr0 0000 pyxl0error$^  $^  fstscriptarcsortpyxvselfmfst.get pyxvsorttypeenum$^$^   pywrapfst.pyx0000$^        raise fstargerrorunknown sort type r.formatsorttype$^      fst.arcsortself.mfst.get sorttypeenum$^      self.checkmutatingimethod              $^  $^    def arcsortself sorttypebilabel$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s checkmutatingimethod$^    pyxerr0 0000 pyxl0error$^  $^  struct pyxvtabstruct0pywrapfstmutablefst pyxvselfpyxbase.pyxvtabcheckmutatingimethodpyxvself if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^      return result$^  $^    cdef void arcsortself sorttypebilabel except               $^      cdef fst.arcsorttype sorttypeenum$^      if not fst.getarcsorttypetostringsorttype addrsorttypeenum$^ $^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.mutablefst.arcsort pyxclineno pyxlineno pyxfilename$^  pyxl0$^  pyxrefnannyfinishcontext$^$^$^ pywrapfst.pyx0000$^      self.checkmutatingimethod$^  $^    def arcsortself sorttypebilabel              $^      $^      arcsortself sorttypeilabel$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00mutablefst0arcsortpyobject pyxvself pyobject pyxargs pyobject pyxkwds proto$^static char pyxdoc0pywrapfst00mutablefst0arcsort  n    arcsortself sorttypeilabelnn    sorts arcs leaving each state of the fst.nn    this operation destructively sorts arcs leaving each state using eithern    input or output labels.nn    argsn      sorttype either ilabel sort arcs according to input labels orn          olabel sort arcs according to output labels.nn    returnsn      self.nn    raisesn      fstargerror unknown sort type.nn    see also topsort.n    $^static pyobject pyxpw0pywrapfst00mutablefst0arcsortpyobject pyxvself pyobject pyxargs pyobject pyxkwds $^  pyobject pyxvsorttype  0$^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextarcsort wrapper 0$^  $^    static pyobject pyxpyargnames  pyxnssorttype0$^    pyobject values0  0$^    values0  pyobject pyxnbilabel$^    if unlikelypyxkwds $^      pyssizet kwargs$^      const pyssizet posargs  pytuplegetsizepyxargs$^      switch posargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 break$^        default goto pyxl0argtupleerror$^      $^      kwargs  pydictsizepyxkwds$^      switch posargs $^        case  0$^        if kwargs  0 $^          pyobject value  pydictgetitempyxkwds pyxnssorttype$^          if value  values0  value kwargs $^        $^      $^      if unlikelykwargs  0 $^        if unlikelypyxparseoptionalkeywordspyxkwds pyxpyargnames 0 values posargs arcsort  0 pyxerr0 0000 pyxl0error$^      $^     else $^      switch pytuplegetsizepyxargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 break$^        default goto pyxl0argtupleerror$^      $^    $^    pyxvsorttype  values0$^  $^  goto pyxl0argumentunpackingdone$^  pyxl0argtupleerror$^  pyxraiseargtupleinvalidarcsort 0 0 0 pytuplegetsizepyxargs pyxerr0 0000 pyxl0error$^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablefst.arcsort pyxclineno pyxlineno pyxfilename$^  pyxrefnannyfinishcontext$^  return null$^  pyxl0argumentunpackingdone$^  pyxr  pyxpf0pywrapfst00mutablefst0arcsortstruct pyxobj0pywrapfstmutablefst pyxvself pyxvsorttype$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00mutablefst0arcsortstruct pyxobj0pywrapfstmutablefst pyxvself pyobject pyxvsorttype $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  struct pyxoptargs0pywrapfst00mutablefstarcsort pyxt0$^  pyxrefnannysetupcontextarcsort 0$^$^   pywrapfst.pyx0000$^      see also topsort.$^      $^      self.arcsortsorttype              $^      return self$^  $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s arcsort$^    pyxerr0 0000 pyxl0error$^  $^  pyxt0.pyxn  0$^  pyxt0.sorttype  pyxvsorttype$^  struct pyxvtabstruct0pywrapfstmutablefst pyxvselfpyxbase.pyxvtabarcsortpyxvself pyxt0 if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^      $^      self.arcsortsorttype$^      return self              $^  $^    cdef void closureself bool closureplusfalse except $^ $^  pyxxdecrefpyxr$^  pyxincrefpyobject pyxvself$^  pyxr  pyobject pyxvself$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      self.checkmutatingimethod$^  $^    def arcsortself sorttypebilabel              $^      $^      arcsortself sorttypeilabel$^ $^$^   function exit code $^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablefst.arcsort pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return self$^  $^    cdef void closureself bool closureplusfalse except               $^      fst.closureself.mfst.get fst.getclosuretypeclosureplus$^      self.checkmutatingimethod$^ $^$^static void pyxf0pywrapfst00mutablefstclosurestruct pyxobj0pywrapfstmutablefst pyxvself struct pyxoptargs0pywrapfst00mutablefstclosure pyxoptionalargs $^  bool pyxvclosureplus  bool0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextclosure 0$^  if pyxoptionalargs $^    if pyxoptionalargspyxn  0 $^      pyxvclosureplus  pyxoptionalargsclosureplus$^    $^  $^$^   pywrapfst.pyx0000$^  $^    cdef void closureself bool closureplusfalse except $^      fst.closureself.mfst.get fst.getclosuretypeclosureplus              $^      self.checkmutatingimethod$^  $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s mfst$^    pyxerr0 0000 pyxl0error$^  $^  fstscriptclosurepyxvselfmfst.get fstscriptgetclosuretypepyxvclosureplus$^$^   pywrapfst.pyx0000$^    cdef void closureself bool closureplusfalse except $^      fst.closureself.mfst.get fst.getclosuretypeclosureplus$^      self.checkmutatingimethod              $^  $^    def closureself bool closureplusfalse$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s checkmutatingimethod$^    pyxerr0 0000 pyxl0error$^  $^  struct pyxvtabstruct0pywrapfstmutablefst pyxvselfpyxbase.pyxvtabcheckmutatingimethodpyxvself if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^      return self$^  $^    cdef void closureself bool closureplusfalse except               $^      fst.closureself.mfst.get fst.getclosuretypeclosureplus$^      self.checkmutatingimethod$^ $^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablefst.closure pyxclineno pyxlineno pyxfilename$^  pyxl0$^  pyxrefnannyfinishcontext$^$^$^ pywrapfst.pyx0000$^      self.checkmutatingimethod$^  $^    def closureself bool closureplusfalse              $^      $^      closureself closureplusfalse$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00mutablefst0closurepyobject pyxvself pyobject pyxargs pyobject pyxkwds proto$^static char pyxdoc0pywrapfst00mutablefst0closure  n    closureself closureplusfalsenn    computes concatenative closure.nn    this operation destructively converts the fst to its concatenative closure.n    if a transduces string x to y with weight a then the closure transduces xn    to y with weight a xx to yy with weight a otimes a xxx to yyy with weightn    a otimes a otimes a and so on. the empty string is also transduced ton    itself with semiring one if closureplus is false.nn    argsn      closureplus if false do not accept the empty string.nn    returnsn      self.n    $^static pyobject pyxpw0pywrapfst00mutablefst0closurepyobject pyxvself pyobject pyxargs pyobject pyxkwds $^  bool pyxvclosureplus$^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextclosure wrapper 0$^  $^    static pyobject pyxpyargnames  pyxnsclosureplus0$^    pyobject values0  0$^    if unlikelypyxkwds $^      pyssizet kwargs$^      const pyssizet posargs  pytuplegetsizepyxargs$^      switch posargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 break$^        default goto pyxl0argtupleerror$^      $^      kwargs  pydictsizepyxkwds$^      switch posargs $^        case  0$^        if kwargs  0 $^          pyobject value  pydictgetitempyxkwds pyxnsclosureplus$^          if value  values0  value kwargs $^        $^      $^      if unlikelykwargs  0 $^        if unlikelypyxparseoptionalkeywordspyxkwds pyxpyargnames 0 values posargs closure  0 pyxerr0 0000 pyxl0error$^      $^     else $^      switch pytuplegetsizepyxargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 break$^        default goto pyxl0argtupleerror$^      $^    $^    if values0 $^      pyxvclosureplus  pyxpyobjectistruevalues0 if unlikelypyxvclosureplus  bool0  pyerroccurred pyxerr0 0000 pyxl0error$^     else $^      pyxvclosureplus  bool0$^    $^  $^  goto pyxl0argumentunpackingdone$^  pyxl0argtupleerror$^  pyxraiseargtupleinvalidclosure 0 0 0 pytuplegetsizepyxargs pyxerr0 0000 pyxl0error$^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablefst.closure pyxclineno pyxlineno pyxfilename$^  pyxrefnannyfinishcontext$^  return null$^  pyxl0argumentunpackingdone$^  pyxr  pyxpf0pywrapfst00mutablefst0closurestruct pyxobj0pywrapfstmutablefst pyxvself pyxvclosureplus$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00mutablefst0closurestruct pyxobj0pywrapfstmutablefst pyxvself bool pyxvclosureplus $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  struct pyxoptargs0pywrapfst00mutablefstclosure pyxt0$^  pyxrefnannysetupcontextclosure 0$^$^   pywrapfst.pyx0000$^        self.$^      $^      self.closureclosureplus              $^      return self$^  $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s closure$^    pyxerr0 0000 pyxl0error$^  $^  pyxt0.pyxn  0$^  pyxt0.closureplus  pyxvclosureplus$^  struct pyxvtabstruct0pywrapfstmutablefst pyxvselfpyxbase.pyxvtabclosurepyxvself pyxt0 if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^      $^      self.closureclosureplus$^      return self              $^  $^    cdef void concatself fst ifst except $^ $^  pyxxdecrefpyxr$^  pyxincrefpyobject pyxvself$^  pyxr  pyobject pyxvself$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      self.checkmutatingimethod$^  $^    def closureself bool closureplusfalse              $^      $^      closureself closureplusfalse$^ $^$^   function exit code $^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablefst.closure pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return self$^  $^    cdef void concatself fst ifst except               $^      fst.concatself.mfst.get derefifst.fst$^      self.checkmutatingimethod$^ $^$^static void pyxf0pywrapfst00mutablefstconcatstruct pyxobj0pywrapfstmutablefst pyxvself struct pyxobj0pywrapfstfst pyxvifst $^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextconcat 0$^$^   pywrapfst.pyx0000$^  $^    cdef void concatself fst ifst except $^      fst.concatself.mfst.get derefifst.fst              $^      self.checkmutatingimethod$^  $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s mfst$^    pyxerr0 0000 pyxl0error$^  $^  if unlikelypyobject pyxvifst  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s fst$^    pyxerr0 0000 pyxl0error$^  $^  fstscriptconcatpyxvselfmfst.get pyxvifstfst$^$^   pywrapfst.pyx0000$^    cdef void concatself fst ifst except $^      fst.concatself.mfst.get derefifst.fst$^      self.checkmutatingimethod              $^  $^    def concatself fst ifst$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s checkmutatingimethod$^    pyxerr0 0000 pyxl0error$^  $^  struct pyxvtabstruct0pywrapfstmutablefst pyxvselfpyxbase.pyxvtabcheckmutatingimethodpyxvself if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^      return self$^  $^    cdef void concatself fst ifst except               $^      fst.concatself.mfst.get derefifst.fst$^      self.checkmutatingimethod$^ $^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablefst.concat pyxclineno pyxlineno pyxfilename$^  pyxl0$^  pyxrefnannyfinishcontext$^$^$^ pywrapfst.pyx0000$^      self.checkmutatingimethod$^  $^    def concatself fst ifst              $^      $^      concatself ifst$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00mutablefst0concatpyobject pyxvself pyobject pyxvifst proto$^static char pyxdoc0pywrapfst00mutablefst0concat  n    concatself ifstnn    computes the concatenation product of two fsts.nn    this operation destructively concatenates the fst with a second fst. if an    transduces string x to y with weight a and b transduces string w to v withn    weight b then their concatenation transduces string xw to yv with weight an    otimes b.nn    argsn      ifst the second input fst.nn    returnsn      self.n    $^static pyobject pyxpw0pywrapfst00mutablefst0concatpyobject pyxvself pyobject pyxvifst $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextconcat wrapper 0$^  if unlikelypyxargtypetestpyobject pyxvifst pyxptype0pywrapfstfst 0 ifst 0 pyxerr0 0000 pyxl0error$^  pyxr  pyxpf0pywrapfst00mutablefst0concatstruct pyxobj0pywrapfstmutablefst pyxvself struct pyxobj0pywrapfstfst pyxvifst$^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxr  null$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00mutablefst0concatstruct pyxobj0pywrapfstmutablefst pyxvself struct pyxobj0pywrapfstfst pyxvifst $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextconcat 0$^$^   pywrapfst.pyx0000$^        self.$^      $^      self.concatifst              $^      return self$^  $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s concat$^    pyxerr0 0000 pyxl0error$^  $^  struct pyxvtabstruct0pywrapfstmutablefst pyxvselfpyxbase.pyxvtabconcatpyxvself pyxvifst if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^      $^      self.concatifst$^      return self              $^  $^    cdef void connectself except $^ $^  pyxxdecrefpyxr$^  pyxincrefpyobject pyxvself$^  pyxr  pyobject pyxvself$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      self.checkmutatingimethod$^  $^    def concatself fst ifst              $^      $^      concatself ifst$^ $^$^   function exit code $^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablefst.concat pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return self$^  $^    cdef void connectself except               $^      fst.connectself.mfst.get$^      self.checkmutatingimethod$^ $^$^static void pyxf0pywrapfst00mutablefstconnectstruct pyxobj0pywrapfstmutablefst pyxvself $^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextconnect 0$^$^   pywrapfst.pyx0000$^  $^    cdef void connectself except $^      fst.connectself.mfst.get              $^      self.checkmutatingimethod$^  $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s mfst$^    pyxerr0 0000 pyxl0error$^  $^  fstscriptconnectpyxvselfmfst.get$^$^   pywrapfst.pyx0000$^    cdef void connectself except $^      fst.connectself.mfst.get$^      self.checkmutatingimethod              $^  $^    def connectself$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s checkmutatingimethod$^    pyxerr0 0000 pyxl0error$^  $^  struct pyxvtabstruct0pywrapfstmutablefst pyxvselfpyxbase.pyxvtabcheckmutatingimethodpyxvself if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^      return self$^  $^    cdef void connectself except               $^      fst.connectself.mfst.get$^      self.checkmutatingimethod$^ $^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablefst.connect pyxclineno pyxlineno pyxfilename$^  pyxl0$^  pyxrefnannyfinishcontext$^$^$^ pywrapfst.pyx0000$^      self.checkmutatingimethod$^  $^    def connectself              $^      $^      connectself$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00mutablefst00connectpyobject pyxvself cythonunused pyobject unused proto$^static char pyxdoc0pywrapfst00mutablefst00connect  n    connectselfnn    removes unsuccessful paths.nn    this operation destructively trims the fst removing states and arcs thatn    are not part of any successful path.nn    returnsn      self.n    $^static pyobject pyxpw0pywrapfst00mutablefst00connectpyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextconnect wrapper 0$^  pyxr  pyxpf0pywrapfst00mutablefst00connectstruct pyxobj0pywrapfstmutablefst pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00mutablefst00connectstruct pyxobj0pywrapfstmutablefst pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextconnect 0$^$^   pywrapfst.pyx0000$^        self.$^      $^      self.connect              $^      return self$^  $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s connect$^    pyxerr0 0000 pyxl0error$^  $^  struct pyxvtabstruct0pywrapfstmutablefst pyxvselfpyxbase.pyxvtabconnectpyxvself if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^      $^      self.connect$^      return self              $^  $^    cdef void decodeself encodemapper encoder except $^ $^  pyxxdecrefpyxr$^  pyxincrefpyobject pyxvself$^  pyxr  pyobject pyxvself$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      self.checkmutatingimethod$^  $^    def connectself              $^      $^      connectself$^ $^$^   function exit code $^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablefst.connect pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return self$^  $^    cdef void decodeself encodemapper encoder except               $^      fst.decodeself.mfst.get derefencoder.encoder$^      self.checkmutatingimethod$^ $^$^static void pyxf0pywrapfst00mutablefstdecodestruct pyxobj0pywrapfstmutablefst pyxvself struct pyxobj0pywrapfstencodemapper pyxvencoder $^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextdecode 0$^$^   pywrapfst.pyx0000$^  $^    cdef void decodeself encodemapper encoder except $^      fst.decodeself.mfst.get derefencoder.encoder              $^      self.checkmutatingimethod$^  $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s mfst$^    pyxerr0 0000 pyxl0error$^  $^  if unlikelypyobject pyxvencoder  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s encoder$^    pyxerr0 0000 pyxl0error$^  $^  fstscriptdecodepyxvselfmfst.get pyxvencoderencoder$^$^   pywrapfst.pyx0000$^    cdef void decodeself encodemapper encoder except $^      fst.decodeself.mfst.get derefencoder.encoder$^      self.checkmutatingimethod              $^  $^    def decodeself encodemapper encoder$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s checkmutatingimethod$^    pyxerr0 0000 pyxl0error$^  $^  struct pyxvtabstruct0pywrapfstmutablefst pyxvselfpyxbase.pyxvtabcheckmutatingimethodpyxvself if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^      return self$^  $^    cdef void decodeself encodemapper encoder except               $^      fst.decodeself.mfst.get derefencoder.encoder$^      self.checkmutatingimethod$^ $^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablefst.decode pyxclineno pyxlineno pyxfilename$^  pyxl0$^  pyxrefnannyfinishcontext$^$^$^ pywrapfst.pyx0000$^      self.checkmutatingimethod$^  $^    def decodeself encodemapper encoder              $^      $^      decodeself encoder$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00mutablefst00decodepyobject pyxvself pyobject pyxvencoder proto$^static char pyxdoc0pywrapfst00mutablefst00decode  n    decodeself encodernn    decodes encoded labels andor weights.nn    this operation reverses the encoding performed by encode.nn    argsn      encoder an encodemapper object used to encode the fst.nn    returnsn      self.nn    see also encode.n    $^static pyobject pyxpw0pywrapfst00mutablefst00decodepyobject pyxvself pyobject pyxvencoder $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextdecode wrapper 0$^  if unlikelypyxargtypetestpyobject pyxvencoder pyxptype0pywrapfstencodemapper 0 encoder 0 pyxerr0 0000 pyxl0error$^  pyxr  pyxpf0pywrapfst00mutablefst00decodestruct pyxobj0pywrapfstmutablefst pyxvself struct pyxobj0pywrapfstencodemapper pyxvencoder$^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxr  null$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00mutablefst00decodestruct pyxobj0pywrapfstmutablefst pyxvself struct pyxobj0pywrapfstencodemapper pyxvencoder $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextdecode 0$^$^   pywrapfst.pyx0000$^      see also encode.$^      $^      self.decodeencoder              $^      return self$^  $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s decode$^    pyxerr0 0000 pyxl0error$^  $^  struct pyxvtabstruct0pywrapfstmutablefst pyxvselfpyxbase.pyxvtabdecodepyxvself pyxvencoder if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^      $^      self.decodeencoder$^      return self              $^  $^    cdef void deletearcsself int00 state sizet n0 except $^ $^  pyxxdecrefpyxr$^  pyxincrefpyobject pyxvself$^  pyxr  pyobject pyxvself$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      self.checkmutatingimethod$^  $^    def decodeself encodemapper encoder              $^      $^      decodeself encoder$^ $^$^   function exit code $^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablefst.decode pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return self$^  $^    cdef void deletearcsself int00 state sizet n0 except               $^      if not self.mfst.get.deletearcsstate n if n else$^              self.mfst.get.deletearcsstate$^ $^$^static void pyxf0pywrapfst00mutablefstdeletearcsstruct pyxobj0pywrapfstmutablefst pyxvself pyxt00basictypesint00 pyxvstate struct pyxoptargs0pywrapfst00mutablefstdeletearcs pyxoptionalargs $^  sizet pyxvn  sizet0$^  pyxrefnannydeclarations$^  bool pyxt0$^  int pyxt0$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextdeletearcs 0$^  if pyxoptionalargs $^    if pyxoptionalargspyxn  0 $^      pyxvn  pyxoptionalargsn$^    $^  $^$^   pywrapfst.pyx0000$^  $^    cdef void deletearcsself int00 state sizet n0 except $^      if not self.mfst.get.deletearcsstate n if n else              $^              self.mfst.get.deletearcsstate$^        raise fstindexerrorstate index out of range$^ $^  if pyxvn  0 $^    if unlikelypyobject pyxvself  pynone $^      pyerrformatpyexcattributeerror nonetype object has no attribute .00s mfst$^      pyxerr0 0000 pyxl0error$^    $^    pyxt0  pyxvselfmfst.getdeletearcspyxvstate pyxvn$^   else $^$^     pywrapfst.pyx0000$^    cdef void deletearcsself int00 state sizet n0 except $^      if not self.mfst.get.deletearcsstate n if n else$^              self.mfst.get.deletearcsstate              $^        raise fstindexerrorstate index out of range$^      self.checkmutatingimethod$^ $^    if unlikelypyobject pyxvself  pynone $^      pyerrformatpyexcattributeerror nonetype object has no attribute .00s mfst$^      pyxerr0 0000 pyxl0error$^    $^    pyxt0  pyxvselfmfst.getdeletearcspyxvstate$^  $^$^   pywrapfst.pyx0000$^  $^    cdef void deletearcsself int00 state sizet n0 except $^      if not self.mfst.get.deletearcsstate n if n else              $^              self.mfst.get.deletearcsstate$^        raise fstindexerrorstate index out of range$^ $^  pyxt0  pyxt0  0  0$^  if pyxt0 $^$^     pywrapfst.pyx0000$^      if not self.mfst.get.deletearcsstate n if n else$^              self.mfst.get.deletearcsstate$^        raise fstindexerrorstate index out of range              $^      self.checkmutatingimethod$^  $^ $^    pyxt0  pyxgetmoduleglobalnamepyxnsfstindexerror if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  pyxpyobjectcallpyxt0 pyxtuple00 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxraisepyxt0 0 0 0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxerr0 0000 pyxl0error$^$^     pywrapfst.pyx0000$^  $^    cdef void deletearcsself int00 state sizet n0 except $^      if not self.mfst.get.deletearcsstate n if n else              $^              self.mfst.get.deletearcsstate$^        raise fstindexerrorstate index out of range$^ $^  $^$^   pywrapfst.pyx0000$^              self.mfst.get.deletearcsstate$^        raise fstindexerrorstate index out of range$^      self.checkmutatingimethod              $^  $^    def deletearcsself int00 state sizet n0$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s checkmutatingimethod$^    pyxerr0 0000 pyxl0error$^  $^  struct pyxvtabstruct0pywrapfstmutablefst pyxvselfpyxbase.pyxvtabcheckmutatingimethodpyxvself if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^      return self$^  $^    cdef void deletearcsself int00 state sizet n0 except               $^      if not self.mfst.get.deletearcsstate n if n else$^              self.mfst.get.deletearcsstate$^ $^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.mutablefst.deletearcs pyxclineno pyxlineno pyxfilename$^  pyxl0$^  pyxrefnannyfinishcontext$^$^$^ pywrapfst.pyx0000$^      self.checkmutatingimethod$^  $^    def deletearcsself int00 state sizet n0              $^      $^      deletearcsself state n0$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00mutablefst00deletearcspyobject pyxvself pyobject pyxargs pyobject pyxkwds proto$^static char pyxdoc0pywrapfst00mutablefst00deletearcs  n    deletearcsself state n0nn    deletes arcs leaving a particular state.nn    argsn      state the integer index of a state.n      n an optional argument indicating how many arcs to be deleted. if thisn          argument is omitted or passed as zero all arcs from this state aren          deleted.nn    returnsn      self.nn    raisesn      fstindexerror state index out of range.nn    see also deletestates.n    $^static pyobject pyxpw0pywrapfst00mutablefst00deletearcspyobject pyxvself pyobject pyxargs pyobject pyxkwds $^  pyxt00basictypesint00 pyxvstate$^  sizet pyxvn$^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextdeletearcs wrapper 0$^  $^    static pyobject pyxpyargnames  pyxnsstatepyxnsn0$^    pyobject values0  00$^    if unlikelypyxkwds $^      pyssizet kwargs$^      const pyssizet posargs  pytuplegetsizepyxargs$^      switch posargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 break$^        default goto pyxl0argtupleerror$^      $^      kwargs  pydictsizepyxkwds$^      switch posargs $^        case  0$^        if likelyvalues0  pydictgetitempyxkwds pyxnsstate  0 kwargs$^        else goto pyxl0argtupleerror$^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pydictgetitempyxkwds pyxnsn$^          if value  values0  value kwargs $^        $^      $^      if unlikelykwargs  0 $^        if unlikelypyxparseoptionalkeywordspyxkwds pyxpyargnames 0 values posargs deletearcs  0 pyxerr0 0000 pyxl0error$^      $^     else $^      switch pytuplegetsizepyxargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        break$^        default goto pyxl0argtupleerror$^      $^    $^    pyxvstate  pyxpyintasint00tvalues0 if unlikelypyxvstate  int00t0  pyerroccurred pyxerr0 0000 pyxl0error$^    if values0 $^      pyxvn  pyxpyintassizetvalues0 if unlikelypyxvn  sizet0  pyerroccurred pyxerr0 0000 pyxl0error$^     else $^      pyxvn  sizet0$^    $^  $^  goto pyxl0argumentunpackingdone$^  pyxl0argtupleerror$^  pyxraiseargtupleinvaliddeletearcs 0 0 0 pytuplegetsizepyxargs pyxerr0 0000 pyxl0error$^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablefst.deletearcs pyxclineno pyxlineno pyxfilename$^  pyxrefnannyfinishcontext$^  return null$^  pyxl0argumentunpackingdone$^  pyxr  pyxpf0pywrapfst00mutablefst00deletearcsstruct pyxobj0pywrapfstmutablefst pyxvself pyxvstate pyxvn$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00mutablefst00deletearcsstruct pyxobj0pywrapfstmutablefst pyxvself pyxt00basictypesint00 pyxvstate sizet pyxvn $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  struct pyxoptargs0pywrapfst00mutablefstdeletearcs pyxt0$^  pyxrefnannysetupcontextdeletearcs 0$^$^   pywrapfst.pyx0000$^      see also deletestates.$^      $^      self.deletearcsstate n              $^      return self$^  $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s deletearcs$^    pyxerr0 0000 pyxl0error$^  $^  pyxt0.pyxn  0$^  pyxt0.n  pyxvn$^  struct pyxvtabstruct0pywrapfstmutablefst pyxvselfpyxbase.pyxvtabdeletearcspyxvself pyxvstate pyxt0 if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^      $^      self.deletearcsstate n$^      return self              $^  $^    cdef void deletestatesself statesnone except $^ $^  pyxxdecrefpyxr$^  pyxincrefpyobject pyxvself$^  pyxr  pyobject pyxvself$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      self.checkmutatingimethod$^  $^    def deletearcsself int00 state sizet n0              $^      $^      deletearcsself state n0$^ $^$^   function exit code $^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablefst.deletearcs pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return self$^  $^    cdef void deletestatesself statesnone except               $^       only the former signature has a possible indexing failure.$^      if states$^ $^$^static void pyxf0pywrapfst00mutablefstdeletestatesstruct pyxobj0pywrapfstmutablefst pyxvself struct pyxoptargs0pywrapfst00mutablefstdeletestates pyxoptionalargs $^  pyobject pyxvstates  pyobject pynone$^  pyxrefnannydeclarations$^  int pyxt0$^  stdvectorpyxt00basictypesint00  pyxt0$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextdeletestates 0$^  if pyxoptionalargs $^    if pyxoptionalargspyxn  0 $^      pyxvstates  pyxoptionalargsstates$^    $^  $^$^   pywrapfst.pyx0000$^    cdef void deletestatesself statesnone except $^       only the former signature has a possible indexing failure.$^      if states              $^        if not self.mfst.get.deletestatesconst vectorint00 states$^          raise fstindexerrorstate index out of range$^ $^  pyxt0  pyxpyobjectistruepyxvstates if unlikelypyxt0  0 pyxerr0 0000 pyxl0error$^  if pyxt0 $^$^     pywrapfst.pyx0000$^       only the former signature has a possible indexing failure.$^      if states$^        if not self.mfst.get.deletestatesconst vectorint00 states              $^          raise fstindexerrorstate index out of range$^      else$^ $^    if unlikelypyobject pyxvself  pynone $^      pyerrformatpyexcattributeerror nonetype object has no attribute .00s mfst$^      pyxerr0 0000 pyxl0error$^    $^    pyxt0  pyxconvertvectorfrompypyxt00basictypesint00pyxvstates if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^    pyxt0  pyxvselfmfst.getdeletestatesstdvectorpyxt00basictypesint00  const pyxt0  0  0$^    if pyxt0 $^$^       pywrapfst.pyx0000$^      if states$^        if not self.mfst.get.deletestatesconst vectorint00 states$^          raise fstindexerrorstate index out of range              $^      else$^        self.mfst.get.deletestates$^ $^      pyxt0  pyxgetmoduleglobalnamepyxnsfstindexerror if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxgotrefpyxt0$^      pyxt0  pyxpyobjectcallpyxt0 pyxtuple00 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxraisepyxt0 0 0 0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxerr0 0000 pyxl0error$^$^       pywrapfst.pyx0000$^       only the former signature has a possible indexing failure.$^      if states$^        if not self.mfst.get.deletestatesconst vectorint00 states              $^          raise fstindexerrorstate index out of range$^      else$^ $^    $^$^     pywrapfst.pyx0000$^    cdef void deletestatesself statesnone except $^       only the former signature has a possible indexing failure.$^      if states              $^        if not self.mfst.get.deletestatesconst vectorint00 states$^          raise fstindexerrorstate index out of range$^ $^    goto pyxl0$^  $^$^   pywrapfst.pyx0000$^          raise fstindexerrorstate index out of range$^      else$^        self.mfst.get.deletestates              $^      self.checkmutatingimethod$^  $^ $^  else $^    if unlikelypyobject pyxvself  pynone $^      pyerrformatpyexcattributeerror nonetype object has no attribute .00s mfst$^      pyxerr0 0000 pyxl0error$^    $^    pyxvselfmfst.getdeletestates$^  $^  pyxl0$^$^   pywrapfst.pyx0000$^      else$^        self.mfst.get.deletestates$^      self.checkmutatingimethod              $^  $^    def deletestatesself statesnone$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s checkmutatingimethod$^    pyxerr0 0000 pyxl0error$^  $^  struct pyxvtabstruct0pywrapfstmutablefst pyxvselfpyxbase.pyxvtabcheckmutatingimethodpyxvself if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^      return self$^  $^    cdef void deletestatesself statesnone except               $^       only the former signature has a possible indexing failure.$^      if states$^ $^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.mutablefst.deletestates pyxclineno pyxlineno pyxfilename$^  pyxl0$^  pyxrefnannyfinishcontext$^$^$^ pywrapfst.pyx0000$^      self.checkmutatingimethod$^  $^    def deletestatesself statesnone              $^      $^      deletestatesself statesnone$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00mutablefst00deletestatespyobject pyxvself pyobject pyxargs pyobject pyxkwds proto$^static char pyxdoc0pywrapfst00mutablefst00deletestates  n    deletestatesself statesnonenn    deletes states.nn    argsn      states an optional iterable of integer indices of the states to ben          deleted. if this argument is omitted all states are deleted.nn    returnsn      self.nn    raisesn      fstindexerror state index out of range.nn    see also deletearcs.n    $^static pyobject pyxpw0pywrapfst00mutablefst00deletestatespyobject pyxvself pyobject pyxargs pyobject pyxkwds $^  pyobject pyxvstates  0$^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextdeletestates wrapper 0$^  $^    static pyobject pyxpyargnames  pyxnsstates0$^    pyobject values0  0$^    values0  pyobject pynone$^    if unlikelypyxkwds $^      pyssizet kwargs$^      const pyssizet posargs  pytuplegetsizepyxargs$^      switch posargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 break$^        default goto pyxl0argtupleerror$^      $^      kwargs  pydictsizepyxkwds$^      switch posargs $^        case  0$^        if kwargs  0 $^          pyobject value  pydictgetitempyxkwds pyxnsstates$^          if value  values0  value kwargs $^        $^      $^      if unlikelykwargs  0 $^        if unlikelypyxparseoptionalkeywordspyxkwds pyxpyargnames 0 values posargs deletestates  0 pyxerr0 0000 pyxl0error$^      $^     else $^      switch pytuplegetsizepyxargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 break$^        default goto pyxl0argtupleerror$^      $^    $^    pyxvstates  values0$^  $^  goto pyxl0argumentunpackingdone$^  pyxl0argtupleerror$^  pyxraiseargtupleinvaliddeletestates 0 0 0 pytuplegetsizepyxargs pyxerr0 0000 pyxl0error$^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablefst.deletestates pyxclineno pyxlineno pyxfilename$^  pyxrefnannyfinishcontext$^  return null$^  pyxl0argumentunpackingdone$^  pyxr  pyxpf0pywrapfst00mutablefst00deletestatesstruct pyxobj0pywrapfstmutablefst pyxvself pyxvstates$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00mutablefst00deletestatesstruct pyxobj0pywrapfstmutablefst pyxvself pyobject pyxvstates $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  struct pyxoptargs0pywrapfst00mutablefstdeletestates pyxt0$^  pyxrefnannysetupcontextdeletestates 0$^$^   pywrapfst.pyx0000$^      see also deletearcs.$^      $^      self.deletestatesstates              $^      return self$^  $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s deletestates$^    pyxerr0 0000 pyxl0error$^  $^  pyxt0.pyxn  0$^  pyxt0.states  pyxvstates$^  struct pyxvtabstruct0pywrapfstmutablefst pyxvselfpyxbase.pyxvtabdeletestatespyxvself pyxt0 if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^      $^      self.deletestatesstates$^      return self              $^  $^    cdef void encodeself encodemapper encoder except $^ $^  pyxxdecrefpyxr$^  pyxincrefpyobject pyxvself$^  pyxr  pyobject pyxvself$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      self.checkmutatingimethod$^  $^    def deletestatesself statesnone              $^      $^      deletestatesself statesnone$^ $^$^   function exit code $^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablefst.deletestates pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return self$^  $^    cdef void encodeself encodemapper encoder except               $^      fst.encodeself.mfst.get encoder.encoder.get$^      self.checkmutatingimethod$^ $^$^static void pyxf0pywrapfst00mutablefstencodestruct pyxobj0pywrapfstmutablefst pyxvself struct pyxobj0pywrapfstencodemapper pyxvencoder $^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextencode 0$^$^   pywrapfst.pyx0000$^  $^    cdef void encodeself encodemapper encoder except $^      fst.encodeself.mfst.get encoder.encoder.get              $^      self.checkmutatingimethod$^  $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s mfst$^    pyxerr0 0000 pyxl0error$^  $^  if unlikelypyobject pyxvencoder  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s encoder$^    pyxerr0 0000 pyxl0error$^  $^  fstscriptencodepyxvselfmfst.get pyxvencoderencoder.get$^$^   pywrapfst.pyx0000$^    cdef void encodeself encodemapper encoder except $^      fst.encodeself.mfst.get encoder.encoder.get$^      self.checkmutatingimethod              $^  $^    def encodeself encodemapper encoder$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s checkmutatingimethod$^    pyxerr0 0000 pyxl0error$^  $^  struct pyxvtabstruct0pywrapfstmutablefst pyxvselfpyxbase.pyxvtabcheckmutatingimethodpyxvself if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^      return self$^  $^    cdef void encodeself encodemapper encoder except               $^      fst.encodeself.mfst.get encoder.encoder.get$^      self.checkmutatingimethod$^ $^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablefst.encode pyxclineno pyxlineno pyxfilename$^  pyxl0$^  pyxrefnannyfinishcontext$^$^$^ pywrapfst.pyx0000$^      self.checkmutatingimethod$^  $^    def encodeself encodemapper encoder              $^      $^      encodeself encoder$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00mutablefst00encodepyobject pyxvself pyobject pyxvencoder proto$^static char pyxdoc0pywrapfst00mutablefst00encode  n    encodeself encodernn    encodes labels andor weights.nn    this operation allows for the representation of a weighted transducer as an    weighted acceptor an unweighted transducer or an unweighted acceptor byn    considering the pair input label output label the pair input labeln    weight or the triple input label output label weight as a singlen    label. applying this operation mutates the encodemapper argument whichn    can then be used to decode.nn    argsn      encoder an encodemapper object to be used as the encoder.nn    returnsn      self.nn    see also decode.n    $^static pyobject pyxpw0pywrapfst00mutablefst00encodepyobject pyxvself pyobject pyxvencoder $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextencode wrapper 0$^  if unlikelypyxargtypetestpyobject pyxvencoder pyxptype0pywrapfstencodemapper 0 encoder 0 pyxerr0 0000 pyxl0error$^  pyxr  pyxpf0pywrapfst00mutablefst00encodestruct pyxobj0pywrapfstmutablefst pyxvself struct pyxobj0pywrapfstencodemapper pyxvencoder$^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxr  null$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00mutablefst00encodestruct pyxobj0pywrapfstmutablefst pyxvself struct pyxobj0pywrapfstencodemapper pyxvencoder $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextencode 0$^$^   pywrapfst.pyx0000$^      see also decode.$^      $^      self.encodeencoder              $^      return self$^  $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s encode$^    pyxerr0 0000 pyxl0error$^  $^  struct pyxvtabstruct0pywrapfstmutablefst pyxvselfpyxbase.pyxvtabencodepyxvself pyxvencoder if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^      $^      self.encodeencoder$^      return self              $^  $^    cdef void invertself except $^ $^  pyxxdecrefpyxr$^  pyxincrefpyobject pyxvself$^  pyxr  pyobject pyxvself$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      self.checkmutatingimethod$^  $^    def encodeself encodemapper encoder              $^      $^      encodeself encoder$^ $^$^   function exit code $^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablefst.encode pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return self$^  $^    cdef void invertself except               $^      fst.invertself.mfst.get$^      self.checkmutatingimethod$^ $^$^static void pyxf0pywrapfst00mutablefstinvertstruct pyxobj0pywrapfstmutablefst pyxvself $^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextinvert 0$^$^   pywrapfst.pyx0000$^  $^    cdef void invertself except $^      fst.invertself.mfst.get              $^      self.checkmutatingimethod$^  $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s mfst$^    pyxerr0 0000 pyxl0error$^  $^  fstscriptinvertpyxvselfmfst.get$^$^   pywrapfst.pyx0000$^    cdef void invertself except $^      fst.invertself.mfst.get$^      self.checkmutatingimethod              $^  $^    def invertself$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s checkmutatingimethod$^    pyxerr0 0000 pyxl0error$^  $^  struct pyxvtabstruct0pywrapfstmutablefst pyxvselfpyxbase.pyxvtabcheckmutatingimethodpyxvself if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^      return self$^  $^    cdef void invertself except               $^      fst.invertself.mfst.get$^      self.checkmutatingimethod$^ $^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablefst.invert pyxclineno pyxlineno pyxfilename$^  pyxl0$^  pyxrefnannyfinishcontext$^$^$^ pywrapfst.pyx0000$^      self.checkmutatingimethod$^  $^    def invertself              $^      $^      invertself$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00mutablefst00invertpyobject pyxvself cythonunused pyobject unused proto$^static char pyxdoc0pywrapfst00mutablefst00invert  n    invertselfnn    inverts the fsts transduction.nn    this operation destructively inverts the fsts transduction by exchangingn    input and output labels.nn    returnsn      self.n    $^static pyobject pyxpw0pywrapfst00mutablefst00invertpyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextinvert wrapper 0$^  pyxr  pyxpf0pywrapfst00mutablefst00invertstruct pyxobj0pywrapfstmutablefst pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00mutablefst00invertstruct pyxobj0pywrapfstmutablefst pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextinvert 0$^$^   pywrapfst.pyx0000$^        self.$^      $^      self.invert              $^      return self$^  $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s invert$^    pyxerr0 0000 pyxl0error$^  $^  struct pyxvtabstruct0pywrapfstmutablefst pyxvselfpyxbase.pyxvtabinvertpyxvself if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^      $^      self.invert$^      return self              $^  $^    cdef void minimizeself float deltafst.kshortestdelta$^ $^  pyxxdecrefpyxr$^  pyxincrefpyobject pyxvself$^  pyxr  pyobject pyxvself$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      self.checkmutatingimethod$^  $^    def invertself              $^      $^      invertself$^ $^$^   function exit code $^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablefst.invert pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return self$^  $^    cdef void minimizeself float deltafst.kshortestdelta              $^                        bool allownondetfalse except $^       this runs inplace when the second argument is null.$^ $^$^static void pyxf0pywrapfst00mutablefstminimizestruct pyxobj0pywrapfstmutablefst pyxvself struct pyxoptargs0pywrapfst00mutablefstminimize pyxoptionalargs $^  float pyxvdelta  pyxk00$^$^   pywrapfst.pyx0000$^  $^    cdef void minimizeself float deltafst.kshortestdelta$^                        bool allownondetfalse except               $^       this runs inplace when the second argument is null.$^      fst.minimizeself.mfst.get null delta allownondet$^ $^  bool pyxvallownondet  bool0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextminimize 0$^  if pyxoptionalargs $^    if pyxoptionalargspyxn  0 $^      pyxvdelta  pyxoptionalargsdelta$^      if pyxoptionalargspyxn  0 $^        pyxvallownondet  pyxoptionalargsallownondet$^      $^    $^  $^$^   pywrapfst.pyx0000$^                        bool allownondetfalse except $^       this runs inplace when the second argument is null.$^      fst.minimizeself.mfst.get null delta allownondet              $^      self.checkmutatingimethod$^  $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s mfst$^    pyxerr0 0000 pyxl0error$^  $^  fstscriptminimizepyxvselfmfst.get null pyxvdelta pyxvallownondet$^$^   pywrapfst.pyx0000$^       this runs inplace when the second argument is null.$^      fst.minimizeself.mfst.get null delta allownondet$^      self.checkmutatingimethod              $^  $^    def minimizeself float deltafst.kshortestdelta bool allownondetfalse$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s checkmutatingimethod$^    pyxerr0 0000 pyxl0error$^  $^  struct pyxvtabstruct0pywrapfstmutablefst pyxvselfpyxbase.pyxvtabcheckmutatingimethodpyxvself if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^      return self$^  $^    cdef void minimizeself float deltafst.kshortestdelta              $^                        bool allownondetfalse except $^       this runs inplace when the second argument is null.$^ $^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablefst.minimize pyxclineno pyxlineno pyxfilename$^  pyxl0$^  pyxrefnannyfinishcontext$^$^$^ pywrapfst.pyx0000$^      self.checkmutatingimethod$^  $^    def minimizeself float deltafst.kshortestdelta bool allownondetfalse              $^      $^      minimizeself delta0e0 allownondetfalse$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00mutablefst00minimizepyobject pyxvself pyobject pyxargs pyobject pyxkwds proto$^static char pyxdoc0pywrapfst00mutablefst00minimize  n    minimizeself delta0e0 allownondetfalsenn    minimizes the fst.nn    this operation destructively performs the minimization of deterministicn    weighted automata and transducers. if the input fst a is an acceptor thisn    operation produces the minimal acceptor b equivalent to a i.e. then    acceptor with a minimal number of states that is equivalent to a. if then    input fst a is a transducer this operation internally builds an equivalentn    transducer with a minimal number of states. however this minimality isn    obtained by allowing transition having strings of symbols as output labelsn    this known in the litterature as a realtime transducer. such transducersn    are not directly supported by the library. this function will convert suchn    transducer by expanding each stringlabeled transition into a sequence ofn    transitions. this will results in the creation of new states hence losingn    the minimality property.nn    argsn      delta comparisonquantization delta.n      allownondet attempt minimization of nondeterministic fstnn    returnsn      self.n    $^static pyobject pyxpw0pywrapfst00mutablefst00minimizepyobject pyxvself pyobject pyxargs pyobject pyxkwds $^  float pyxvdelta$^  bool pyxvallownondet$^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextminimize wrapper 0$^  $^    static pyobject pyxpyargnames  pyxnsdeltapyxnsallownondet0$^    pyobject values0  00$^    if unlikelypyxkwds $^      pyssizet kwargs$^      const pyssizet posargs  pytuplegetsizepyxargs$^      switch posargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 break$^        default goto pyxl0argtupleerror$^      $^      kwargs  pydictsizepyxkwds$^      switch posargs $^        case  0$^        if kwargs  0 $^          pyobject value  pydictgetitempyxkwds pyxnsdelta$^          if value  values0  value kwargs $^        $^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pydictgetitempyxkwds pyxnsallownondet$^          if value  values0  value kwargs $^        $^      $^      if unlikelykwargs  0 $^        if unlikelypyxparseoptionalkeywordspyxkwds pyxpyargnames 0 values posargs minimize  0 pyxerr0 0000 pyxl0error$^      $^     else $^      switch pytuplegetsizepyxargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 break$^        default goto pyxl0argtupleerror$^      $^    $^    if values0 $^      pyxvdelta  pyxpyfloatasfloatvalues0 if unlikelypyxvdelta  float0  pyerroccurred pyxerr0 0000 pyxl0error$^     else $^      pyxvdelta  pyxk00$^    $^    if values0 $^      pyxvallownondet  pyxpyobjectistruevalues0 if unlikelypyxvallownondet  bool0  pyerroccurred pyxerr0 0000 pyxl0error$^     else $^      pyxvallownondet  bool0$^    $^  $^  goto pyxl0argumentunpackingdone$^  pyxl0argtupleerror$^  pyxraiseargtupleinvalidminimize 0 0 0 pytuplegetsizepyxargs pyxerr0 0000 pyxl0error$^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablefst.minimize pyxclineno pyxlineno pyxfilename$^  pyxrefnannyfinishcontext$^  return null$^  pyxl0argumentunpackingdone$^  pyxr  pyxpf0pywrapfst00mutablefst00minimizestruct pyxobj0pywrapfstmutablefst pyxvself pyxvdelta pyxvallownondet$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00mutablefst00minimizestruct pyxobj0pywrapfstmutablefst pyxvself float pyxvdelta bool pyxvallownondet $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  struct pyxoptargs0pywrapfst00mutablefstminimize pyxt0$^  pyxrefnannysetupcontextminimize 0$^$^   pywrapfst.pyx0000$^        self.$^      $^      self.minimizedelta allownondet              $^      return self$^  $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s minimize$^    pyxerr0 0000 pyxl0error$^  $^  pyxt0.pyxn  0$^  pyxt0.delta  pyxvdelta$^  pyxt0.allownondet  pyxvallownondet$^  struct pyxvtabstruct0pywrapfstmutablefst pyxvselfpyxbase.pyxvtabminimizepyxvself pyxt0 if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^      $^      self.minimizedelta allownondet$^      return self              $^  $^    cpdef mutablearciterator mutablearcsself int00 state$^ $^  pyxxdecrefpyxr$^  pyxincrefpyobject pyxvself$^  pyxr  pyobject pyxvself$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      self.checkmutatingimethod$^  $^    def minimizeself float deltafst.kshortestdelta bool allownondetfalse              $^      $^      minimizeself delta0e0 allownondetfalse$^ $^$^   function exit code $^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablefst.minimize pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return self$^  $^    cpdef mutablearciterator mutablearcsself int00 state              $^      $^      mutablearcsself state$^ $^$^static pyobject pyxpw0pywrapfst00mutablefst00mutablearcspyobject pyxvself pyobject pyxargstate proto$^static struct pyxobj0pywrapfstmutablearciterator pyxf0pywrapfst00mutablefstmutablearcsstruct pyxobj0pywrapfstmutablefst pyxvself pyxt00basictypesint00 pyxvstate int pyxskipdispatch $^  struct pyxobj0pywrapfstmutablearciterator pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextmutablearcs 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnsmutablearcs if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst00mutablefst00mutablearcs $^      pyxxdecrefpyobject pyxr$^      pyxt0  pyxpyintfromint00tpyxvstate if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxgotrefpyxt0$^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^       else $^        if cythonfastpycall$^        if pyfunctioncheckpyxt0 $^          pyobject pyxtemp0  pyxt0 pyxt0$^          pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^          pyxxdecrefpyxt0 pyxt0  0$^          pyxgotrefpyxt0$^          pyxdecrefpyxt0 pyxt0  0$^         else$^        endif$^        if cythonfastpyccall$^        if pyxpyfastcfunctioncheckpyxt0 $^          pyobject pyxtemp0  pyxt0 pyxt0$^          pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^          pyxxdecrefpyxt0 pyxt0  0$^          pyxgotrefpyxt0$^          pyxdecrefpyxt0 pyxt0  0$^         else$^        endif$^        $^          pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^          pyxgotrefpyxt0$^          pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^          pyxgiverefpyxt0$^          pytuplesetitempyxt0 00 pyxt0$^          pyxt0  0$^          pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^          pyxgotrefpyxt0$^          pyxdecrefpyxt0 pyxt0  0$^        $^      $^      pyxdecrefpyxt0 pyxt0  0$^      if likelypyxt0  pynone  likelypyxtypetestpyxt0 pyxptype0pywrapfstmutablearciterator pyxerr0 0000 pyxl0error$^      pyxr  struct pyxobj0pywrapfstmutablearciterator pyxt0$^      pyxt0  0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx0000$^      see also arcs states.$^      $^      return mutablearciteratorself state              $^  $^    def mutableinputsymbolsself$^ $^  pyxxdecrefpyobject pyxr$^  pyxt0  pyxpyintfromint00tpyxvstate if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxt0  pytuplenew0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxincrefpyobject pyxvself$^  pyxgiverefpyobject pyxvself$^  pytuplesetitempyxt0 0 pyobject pyxvself$^  pyxgiverefpyxt0$^  pytuplesetitempyxt0 0 pyxt0$^  pyxt0  0$^  pyxt0  pyxpyobjectcallpyobject pyxptype0pywrapfstmutablearciterator pyxt0 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxdecrefpyxt0 pyxt0  0$^  pyxr  struct pyxobj0pywrapfstmutablearciterator pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      return self$^  $^    cpdef mutablearciterator mutablearcsself int00 state              $^      $^      mutablearcsself state$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.mutablefst.mutablearcs pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxl0$^  pyxxgiverefpyobject pyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst00mutablefst00mutablearcspyobject pyxvself pyobject pyxargstate proto$^static char pyxdoc0pywrapfst00mutablefst00mutablearcs  n    mutablearcsself statenn    returns a mutable iterator over arcs leaving the specified state.nn    argsn      state the source state id.nn    returnsn      a mutablearciterator.nn    see also arcs states.n    $^static pyobject pyxpw0pywrapfst00mutablefst00mutablearcspyobject pyxvself pyobject pyxargstate $^  pyxt00basictypesint00 pyxvstate$^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextmutablearcs wrapper 0$^  assertpyxargstate $^    pyxvstate  pyxpyintasint00tpyxargstate if unlikelypyxvstate  int00t0  pyerroccurred pyxerr0 0000 pyxl0error$^  $^  goto pyxl0argumentunpackingdone$^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablefst.mutablearcs pyxclineno pyxlineno pyxfilename$^  pyxrefnannyfinishcontext$^  return null$^  pyxl0argumentunpackingdone$^  pyxr  pyxpf0pywrapfst00mutablefst00mutablearcsstruct pyxobj0pywrapfstmutablefst pyxvself pyxt00basictypesint00pyxvstate$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00mutablefst00mutablearcsstruct pyxobj0pywrapfstmutablefst pyxvself pyxt00basictypesint00 pyxvstate $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextmutablearcs 0$^  pyxxdecrefpyxr$^  pyxt0  pyobject pyxf0pywrapfst00mutablefstmutablearcspyxvself pyxvstate 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.mutablefst.mutablearcs pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return mutablearciteratorself state$^  $^    def mutableinputsymbolsself              $^      $^      mutableinputsymbolsself$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00mutablefst00mutableinputsymbolspyobject pyxvself cythonunused pyobject unused proto$^static char pyxdoc0pywrapfst00mutablefst00mutableinputsymbols  n    mutableinputsymbolsselfnn    returns the fsts mutable input symbol table or none if none is present.n    $^static pyobject pyxpw0pywrapfst00mutablefst00mutableinputsymbolspyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextmutableinputsymbols wrapper 0$^  pyxr  pyxpf0pywrapfst00mutablefst00mutableinputsymbolsstruct pyxobj0pywrapfstmutablefst pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00mutablefst00mutableinputsymbolsstruct pyxobj0pywrapfstmutablefst pyxvself $^  fstsymboltable pyxvtst$^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  int pyxt0$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextmutableinputsymbols 0$^$^   pywrapfst.pyx0000$^      returns the fsts mutable input symbol table or none if none is present.$^      $^      cdef fst.symboltable tst  self.mfst.get.mutableinputsymbols              $^      if tst  null$^        return$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s mfst$^    pyxerr0 0000 pyxl0error$^  $^  pyxvtst  pyxvselfmfst.getmutableinputsymbols$^$^   pywrapfst.pyx0000$^      $^      cdef fst.symboltable tst  self.mfst.get.mutableinputsymbols$^      if tst  null              $^        return$^      return initmutablefstsymboltabletst self.mfst$^ $^  pyxt0  pyxvtst  null  0$^  if pyxt0 $^$^     pywrapfst.pyx0000$^      cdef fst.symboltable tst  self.mfst.get.mutableinputsymbols$^      if tst  null$^        return              $^      return initmutablefstsymboltabletst self.mfst$^  $^ $^    pyxxdecrefpyxr$^    pyxr  pynone pyxincrefpynone$^    goto pyxl0$^$^     pywrapfst.pyx0000$^      $^      cdef fst.symboltable tst  self.mfst.get.mutableinputsymbols$^      if tst  null              $^        return$^      return initmutablefstsymboltabletst self.mfst$^ $^  $^$^   pywrapfst.pyx0000$^      if tst  null$^        return$^      return initmutablefstsymboltabletst self.mfst              $^  $^    def mutableoutputsymbolsself$^ $^  pyxxdecrefpyxr$^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s mfst$^    pyxerr0 0000 pyxl0error$^  $^  pyxt0  pyobject pyxf0pywrapfstinitmutablefstsymboltablepyxvtst pyxvselfmfst if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      return mutablearciteratorself state$^  $^    def mutableinputsymbolsself              $^      $^      mutableinputsymbolsself$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.mutablefst.mutableinputsymbols pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return initmutablefstsymboltabletst self.mfst$^  $^    def mutableoutputsymbolsself              $^      $^      mutableoutputsymbolsself$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00mutablefst00mutableoutputsymbolspyobject pyxvself cythonunused pyobject unused proto$^static char pyxdoc0pywrapfst00mutablefst00mutableoutputsymbols  n    mutableoutputsymbolsselfnn    returns the fsts mutable output symbol table or none if none is present.n    $^static pyobject pyxpw0pywrapfst00mutablefst00mutableoutputsymbolspyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextmutableoutputsymbols wrapper 0$^  pyxr  pyxpf0pywrapfst00mutablefst00mutableoutputsymbolsstruct pyxobj0pywrapfstmutablefst pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00mutablefst00mutableoutputsymbolsstruct pyxobj0pywrapfstmutablefst pyxvself $^  fstsymboltable pyxvtst$^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  int pyxt0$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextmutableoutputsymbols 0$^$^   pywrapfst.pyx0000$^      returns the fsts mutable output symbol table or none if none is present.$^      $^      cdef fst.symboltable tst  self.mfst.get.mutableoutputsymbols              $^      if tst  null$^        return$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s mfst$^    pyxerr0 0000 pyxl0error$^  $^  pyxvtst  pyxvselfmfst.getmutableoutputsymbols$^$^   pywrapfst.pyx0000$^      $^      cdef fst.symboltable tst  self.mfst.get.mutableoutputsymbols$^      if tst  null              $^        return$^      return initmutablefstsymboltabletst self.mfst$^ $^  pyxt0  pyxvtst  null  0$^  if pyxt0 $^$^     pywrapfst.pyx0000$^      cdef fst.symboltable tst  self.mfst.get.mutableoutputsymbols$^      if tst  null$^        return              $^      return initmutablefstsymboltabletst self.mfst$^  $^ $^    pyxxdecrefpyxr$^    pyxr  pynone pyxincrefpynone$^    goto pyxl0$^$^     pywrapfst.pyx0000$^      $^      cdef fst.symboltable tst  self.mfst.get.mutableoutputsymbols$^      if tst  null              $^        return$^      return initmutablefstsymboltabletst self.mfst$^ $^  $^$^   pywrapfst.pyx0000$^      if tst  null$^        return$^      return initmutablefstsymboltabletst self.mfst              $^  $^    cpdef int00 numstatesself$^ $^  pyxxdecrefpyxr$^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s mfst$^    pyxerr0 0000 pyxl0error$^  $^  pyxt0  pyobject pyxf0pywrapfstinitmutablefstsymboltablepyxvtst pyxvselfmfst if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      return initmutablefstsymboltabletst self.mfst$^  $^    def mutableoutputsymbolsself              $^      $^      mutableoutputsymbolsself$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.mutablefst.mutableoutputsymbols pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return initmutablefstsymboltabletst self.mfst$^  $^    cpdef int00 numstatesself              $^      $^      numstatesself$^ $^$^static pyobject pyxpw0pywrapfst00mutablefst00numstatespyobject pyxvself cythonunused pyobject unused proto$^static pyxt00basictypesint00 pyxf0pywrapfst00mutablefstnumstatesstruct pyxobj0pywrapfstmutablefst pyxvself int pyxskipdispatch $^  pyxt00basictypesint00 pyxr$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxt00basictypesint00 pyxt0$^  pyxrefnannysetupcontextnumstates 0$^   check if called by wrapper $^  if unlikelypyxskipdispatch $^   check if overridden in python $^  else if unlikelypytypepyobject pyxvselftpdictoffset  0 $^    pyxt0  pyxpyobjectgetattrstrpyobject pyxvself pyxnsnumstates if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    if pycfunctioncheckpyxt0  pycfunctiongetfunctionpyxt0  pycfunctionpyxpw0pywrapfst00mutablefst00numstates $^      pyxincrefpyxt0$^      pyxt0  pyxt0 pyxt0  null$^      if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^        pyxt0  pymethodgetselfpyxt0$^        if likelypyxt0 $^          pyobject function  pymethodgetfunctionpyxt0$^          pyxincrefpyxt0$^          pyxincreffunction$^          pyxdecrefsetpyxt0 function$^        $^      $^      if pyxt0 $^        pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxdecrefpyxt0 pyxt0  0$^       else $^        pyxt0  pyxpyobjectcallnoargpyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      $^      pyxgotrefpyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      pyxt0  pyxpyintasint00tpyxt0 if unlikelypyxt0  int00t0  pyerroccurred pyxerr0 0000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxr  pyxt0$^      pyxdecrefpyxt0 pyxt0  0$^      goto pyxl0$^    $^    pyxdecrefpyxt0 pyxt0  0$^  $^$^   pywrapfst.pyx0000$^      returns the number of states.$^      $^      return self.mfst.get.numstates              $^  $^    cdef void projectself bool projectoutputfalse except $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s mfst$^    pyxerr0 0000 pyxl0error$^  $^  pyxr  pyxvselfmfst.getnumstates$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      return initmutablefstsymboltabletst self.mfst$^  $^    cpdef int00 numstatesself              $^      $^      numstatesself$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxwriteunraisablepywrapfst.mutablefst.numstates pyxclineno pyxlineno pyxfilename 0 0$^  pyxr  0$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst00mutablefst00numstatespyobject pyxvself cythonunused pyobject unused proto$^static char pyxdoc0pywrapfst00mutablefst00numstates  n    numstatesselfnn    returns the number of states.n    $^static pyobject pyxpw0pywrapfst00mutablefst00numstatespyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextnumstates wrapper 0$^  pyxr  pyxpf0pywrapfst00mutablefst00numstatesstruct pyxobj0pywrapfstmutablefst pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00mutablefst00numstatesstruct pyxobj0pywrapfstmutablefst pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextnumstates 0$^  pyxxdecrefpyxr$^  pyxt0  pyxpyintfromint00tpyxf0pywrapfst00mutablefstnumstatespyxvself 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.mutablefst.numstates pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return self.mfst.get.numstates$^  $^    cdef void projectself bool projectoutputfalse except               $^      fst.projectself.mfst.get fst.getprojecttypeprojectoutput$^      self.checkmutatingimethod$^ $^$^static void pyxf0pywrapfst00mutablefstprojectstruct pyxobj0pywrapfstmutablefst pyxvself struct pyxoptargs0pywrapfst00mutablefstproject pyxoptionalargs $^  bool pyxvprojectoutput  bool0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextproject 0$^  if pyxoptionalargs $^    if pyxoptionalargspyxn  0 $^      pyxvprojectoutput  pyxoptionalargsprojectoutput$^    $^  $^$^   pywrapfst.pyx0000$^  $^    cdef void projectself bool projectoutputfalse except $^      fst.projectself.mfst.get fst.getprojecttypeprojectoutput              $^      self.checkmutatingimethod$^  $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s mfst$^    pyxerr0 0000 pyxl0error$^  $^  fstscriptprojectpyxvselfmfst.get fstscriptgetprojecttypepyxvprojectoutput$^$^   pywrapfst.pyx0000$^    cdef void projectself bool projectoutputfalse except $^      fst.projectself.mfst.get fst.getprojecttypeprojectoutput$^      self.checkmutatingimethod              $^  $^    def projectself bool projectoutputfalse$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s checkmutatingimethod$^    pyxerr0 0000 pyxl0error$^  $^  struct pyxvtabstruct0pywrapfstmutablefst pyxvselfpyxbase.pyxvtabcheckmutatingimethodpyxvself if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^      return self.mfst.get.numstates$^  $^    cdef void projectself bool projectoutputfalse except               $^      fst.projectself.mfst.get fst.getprojecttypeprojectoutput$^      self.checkmutatingimethod$^ $^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablefst.project pyxclineno pyxlineno pyxfilename$^  pyxl0$^  pyxrefnannyfinishcontext$^$^$^ pywrapfst.pyx0000$^      self.checkmutatingimethod$^  $^    def projectself bool projectoutputfalse              $^      $^      projectself projectoutputfalse$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00mutablefst00projectpyobject pyxvself pyobject pyxargs pyobject pyxkwds proto$^static char pyxdoc0pywrapfst00mutablefst00project  n    projectself projectoutputfalsenn    converts the fst to an acceptor using input or output labels.nn    this operation destructively projects an fst onto its domain or range byn    either copying each arcs input label to its output label the default orn    vice versa.nn    argsn      projectoutput should the output labels be projectednn    returnsn      self.nn    see also decode encode relabelpairs relabelsymbols.n    $^static pyobject pyxpw0pywrapfst00mutablefst00projectpyobject pyxvself pyobject pyxargs pyobject pyxkwds $^  bool pyxvprojectoutput$^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextproject wrapper 0$^  $^    static pyobject pyxpyargnames  pyxnsprojectoutput0$^    pyobject values0  0$^    if unlikelypyxkwds $^      pyssizet kwargs$^      const pyssizet posargs  pytuplegetsizepyxargs$^      switch posargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 break$^        default goto pyxl0argtupleerror$^      $^      kwargs  pydictsizepyxkwds$^      switch posargs $^        case  0$^        if kwargs  0 $^          pyobject value  pydictgetitempyxkwds pyxnsprojectoutput$^          if value  values0  value kwargs $^        $^      $^      if unlikelykwargs  0 $^        if unlikelypyxparseoptionalkeywordspyxkwds pyxpyargnames 0 values posargs project  0 pyxerr0 0000 pyxl0error$^      $^     else $^      switch pytuplegetsizepyxargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 break$^        default goto pyxl0argtupleerror$^      $^    $^    if values0 $^      pyxvprojectoutput  pyxpyobjectistruevalues0 if unlikelypyxvprojectoutput  bool0  pyerroccurred pyxerr0 0000 pyxl0error$^     else $^      pyxvprojectoutput  bool0$^    $^  $^  goto pyxl0argumentunpackingdone$^  pyxl0argtupleerror$^  pyxraiseargtupleinvalidproject 0 0 0 pytuplegetsizepyxargs pyxerr0 0000 pyxl0error$^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablefst.project pyxclineno pyxlineno pyxfilename$^  pyxrefnannyfinishcontext$^  return null$^  pyxl0argumentunpackingdone$^  pyxr  pyxpf0pywrapfst00mutablefst00projectstruct pyxobj0pywrapfstmutablefst pyxvself pyxvprojectoutput$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00mutablefst00projectstruct pyxobj0pywrapfstmutablefst pyxvself bool pyxvprojectoutput $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  struct pyxoptargs0pywrapfst00mutablefstproject pyxt0$^  pyxrefnannysetupcontextproject 0$^$^   pywrapfst.pyx0000$^      see also decode encode relabelpairs relabelsymbols.$^      $^      self.projectprojectoutput              $^      return self$^  $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s project$^    pyxerr0 0000 pyxl0error$^  $^  pyxt0.pyxn  0$^  pyxt0.projectoutput  pyxvprojectoutput$^  struct pyxvtabstruct0pywrapfstmutablefst pyxvselfpyxbase.pyxvtabprojectpyxvself pyxt0 if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^      $^      self.projectprojectoutput$^      return self              $^  $^    cdef void pruneself float deltafst.kdelta int00 nstatefst.knostateid$^ $^  pyxxdecrefpyxr$^  pyxincrefpyobject pyxvself$^  pyxr  pyobject pyxvself$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      self.checkmutatingimethod$^  $^    def projectself bool projectoutputfalse              $^      $^      projectself projectoutputfalse$^ $^$^   function exit code $^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablefst.project pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return self$^  $^    cdef void pruneself float deltafst.kdelta int00 nstatefst.knostateid              $^                     weightnone except $^       threshold is set to semiring zero no pruning if no weight is specified.$^ $^$^static void pyxf0pywrapfst00mutablefstprunestruct pyxobj0pywrapfstmutablefst pyxvself struct pyxoptargs0pywrapfst00mutablefstprune pyxoptionalargs $^  float pyxvdelta  pyxk00$^  pyxt00basictypesint00 pyxvnstate  pyxk00$^$^   pywrapfst.pyx0000$^  $^    cdef void pruneself float deltafst.kdelta int00 nstatefst.knostateid$^                     weightnone except               $^       threshold is set to semiring zero no pruning if no weight is specified.$^      cdef fst.weightclass wc  getweightclassorzeroself.weighttype$^ $^  pyobject pyxvweight  pyobject pynone$^  fstscriptweightclass pyxvwc$^  pyxrefnannydeclarations$^  fstscriptweightclass pyxt0$^  pyxrefnannysetupcontextprune 0$^  if pyxoptionalargs $^    if pyxoptionalargspyxn  0 $^      pyxvdelta  pyxoptionalargsdelta$^      if pyxoptionalargspyxn  0 $^        pyxvnstate  pyxoptionalargsnstate$^        if pyxoptionalargspyxn  0 $^          pyxvweight  pyxoptionalargsweight$^        $^      $^    $^  $^$^   pywrapfst.pyx0000$^                     weightnone except $^       threshold is set to semiring zero no pruning if no weight is specified.$^      cdef fst.weightclass wc  getweightclassorzeroself.weighttype              $^                                                         weight$^      fst.pruneself.mfst.get wc nstate delta$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s weighttype$^    pyxerr0 0000 pyxl0error$^  $^$^   pywrapfst.pyx0000$^       threshold is set to semiring zero no pruning if no weight is specified.$^      cdef fst.weightclass wc  getweightclassorzeroself.weighttype$^                                                         weight              $^      fst.pruneself.mfst.get wc nstate delta$^      self.checkmutatingimethod$^ $^  pyxt0  pyxf0pywrapfstgetweightclassorzerostruct pyxvtabstruct0pywrapfstmutablefst pyxvselfpyxbase.pyxvtabpyxbase.weighttypestruct pyxobj0pywrapfstfst pyxvself 0 pyxvweight if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^  pyxvwc  pyxt0$^$^   pywrapfst.pyx0000$^      cdef fst.weightclass wc  getweightclassorzeroself.weighttype$^                                                         weight$^      fst.pruneself.mfst.get wc nstate delta              $^      self.checkmutatingimethod$^  $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s mfst$^    pyxerr0 0000 pyxl0error$^  $^  fstscriptprunepyxvselfmfst.get pyxvwc pyxvnstate pyxvdelta$^$^   pywrapfst.pyx0000$^                                                         weight$^      fst.pruneself.mfst.get wc nstate delta$^      self.checkmutatingimethod              $^  $^    def pruneself$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s checkmutatingimethod$^    pyxerr0 0000 pyxl0error$^  $^  struct pyxvtabstruct0pywrapfstmutablefst pyxvselfpyxbase.pyxvtabcheckmutatingimethodpyxvself if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^      return self$^  $^    cdef void pruneself float deltafst.kdelta int00 nstatefst.knostateid              $^                     weightnone except $^       threshold is set to semiring zero no pruning if no weight is specified.$^ $^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablefst.prune pyxclineno pyxlineno pyxfilename$^  pyxl0$^  pyxrefnannyfinishcontext$^$^$^ pywrapfst.pyx0000$^      self.checkmutatingimethod$^  $^    def pruneself              $^              float deltafst.kdelta$^              int00 nstatefst.knostateid$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00mutablefst00prunepyobject pyxvself pyobject pyxargs pyobject pyxkwds proto$^static char pyxdoc0pywrapfst00mutablefst00prune  n    pruneself delta0.0000000000 nstatenostateid weightnonenn    removes paths with weights below a certain threshold.nn    this operation deletes states and arcs in the input fst that do not belongn    to a successful path whose weight is no more w.r.t the natural semiringn    order than the threshold t otimestimes the weight of the shortest path inn    the input fst. weights must be commutative and have the path property.nn    argsn      delta comparisonquantization delta.n      nstate state number threshold.n      weight a weight or weight string indicating the desired weight thresholdn          below which paths are pruned if omitted no paths are pruned.nn    returnsn      self.nn    see also the constructive variant.n    $^static pyobject pyxpw0pywrapfst00mutablefst00prunepyobject pyxvself pyobject pyxargs pyobject pyxkwds $^  float pyxvdelta$^  pyxt00basictypesint00 pyxvnstate$^  pyobject pyxvweight  0$^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextprune wrapper 0$^  $^    static pyobject pyxpyargnames  pyxnsdeltapyxnsnstatepyxnsweight0$^    pyobject values0  000$^$^     pywrapfst.pyx0000$^              float deltafst.kdelta$^              int00 nstatefst.knostateid$^              weightnone              $^      $^      pruneself delta0.0000000000 nstatenostateid weightnone$^ $^    values0  pyobject pynone$^    if unlikelypyxkwds $^      pyssizet kwargs$^      const pyssizet posargs  pytuplegetsizepyxargs$^      switch posargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 break$^        default goto pyxl0argtupleerror$^      $^      kwargs  pydictsizepyxkwds$^      switch posargs $^        case  0$^        if kwargs  0 $^          pyobject value  pydictgetitempyxkwds pyxnsdelta$^          if value  values0  value kwargs $^        $^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pydictgetitempyxkwds pyxnsnstate$^          if value  values0  value kwargs $^        $^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pydictgetitempyxkwds pyxnsweight$^          if value  values0  value kwargs $^        $^      $^      if unlikelykwargs  0 $^        if unlikelypyxparseoptionalkeywordspyxkwds pyxpyargnames 0 values posargs prune  0 pyxerr0 0000 pyxl0error$^      $^     else $^      switch pytuplegetsizepyxargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 break$^        default goto pyxl0argtupleerror$^      $^    $^    if values0 $^      pyxvdelta  pyxpyfloatasfloatvalues0 if unlikelypyxvdelta  float0  pyerroccurred pyxerr0 0000 pyxl0error$^     else $^      pyxvdelta  pyxk00$^    $^    if values0 $^      pyxvnstate  pyxpyintasint00tvalues0 if unlikelypyxvnstate  int00t0  pyerroccurred pyxerr0 0000 pyxl0error$^     else $^      pyxvnstate  pyxk00$^    $^    pyxvweight  values0$^  $^  goto pyxl0argumentunpackingdone$^  pyxl0argtupleerror$^  pyxraiseargtupleinvalidprune 0 0 0 pytuplegetsizepyxargs pyxerr0 0000 pyxl0error$^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablefst.prune pyxclineno pyxlineno pyxfilename$^  pyxrefnannyfinishcontext$^  return null$^  pyxl0argumentunpackingdone$^  pyxr  pyxpf0pywrapfst00mutablefst00prunestruct pyxobj0pywrapfstmutablefst pyxvself pyxvdelta pyxvnstate pyxvweight$^$^   pywrapfst.pyx0000$^      self.checkmutatingimethod$^  $^    def pruneself              $^              float deltafst.kdelta$^              int00 nstatefst.knostateid$^ $^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00mutablefst00prunestruct pyxobj0pywrapfstmutablefst pyxvself float pyxvdelta pyxt00basictypesint00 pyxvnstate pyobject pyxvweight $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  struct pyxoptargs0pywrapfst00mutablefstprune pyxt0$^  pyxrefnannysetupcontextprune 0$^$^   pywrapfst.pyx0000$^      see also the constructive variant.$^      $^      self.prunedelta nstate weight              $^      return self$^  $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s prune$^    pyxerr0 0000 pyxl0error$^  $^  pyxt0.pyxn  0$^  pyxt0.delta  pyxvdelta$^  pyxt0.nstate  pyxvnstate$^  pyxt0.weight  pyxvweight$^  struct pyxvtabstruct0pywrapfstmutablefst pyxvselfpyxbase.pyxvtabprunepyxvself pyxt0 if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^      $^      self.prunedelta nstate weight$^      return self              $^  $^    cdef void pushself$^ $^  pyxxdecrefpyxr$^  pyxincrefpyobject pyxvself$^  pyxr  pyobject pyxvself$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      self.checkmutatingimethod$^  $^    def pruneself              $^              float deltafst.kdelta$^              int00 nstatefst.knostateid$^ $^$^   function exit code $^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablefst.prune pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return self$^  $^    cdef void pushself              $^                    float deltafst.kdelta$^                    bool removetotalweightfalse$^ $^$^static void pyxf0pywrapfst00mutablefstpushstruct pyxobj0pywrapfstmutablefst pyxvself struct pyxoptargs0pywrapfst00mutablefstpush pyxoptionalargs $^  float pyxvdelta  pyxk00$^$^   pywrapfst.pyx0000$^    cdef void pushself$^                    float deltafst.kdelta$^                    bool removetotalweightfalse              $^                    bool tofinalfalse except $^      fst.pushself.mfst.get fst.getreweighttypetofinal delta$^ $^  bool pyxvremovetotalweight  bool0$^$^   pywrapfst.pyx0000$^                    float deltafst.kdelta$^                    bool removetotalweightfalse$^                    bool tofinalfalse except               $^      fst.pushself.mfst.get fst.getreweighttypetofinal delta$^               removetotalweight$^ $^  bool pyxvtofinal  bool0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextpush 0$^  if pyxoptionalargs $^    if pyxoptionalargspyxn  0 $^      pyxvdelta  pyxoptionalargsdelta$^      if pyxoptionalargspyxn  0 $^        pyxvremovetotalweight  pyxoptionalargsremovetotalweight$^        if pyxoptionalargspyxn  0 $^          pyxvtofinal  pyxoptionalargstofinal$^        $^      $^    $^  $^$^   pywrapfst.pyx0000$^                    bool removetotalweightfalse$^                    bool tofinalfalse except $^      fst.pushself.mfst.get fst.getreweighttypetofinal delta              $^               removetotalweight$^      self.checkmutatingimethod$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s mfst$^    pyxerr0 0000 pyxl0error$^  $^$^   pywrapfst.pyx0000$^                    bool tofinalfalse except $^      fst.pushself.mfst.get fst.getreweighttypetofinal delta$^               removetotalweight              $^      self.checkmutatingimethod$^  $^ $^  fstscriptpushpyxvselfmfst.get fstscriptgetreweighttypepyxvtofinal pyxvdelta pyxvremovetotalweight$^$^   pywrapfst.pyx0000$^      fst.pushself.mfst.get fst.getreweighttypetofinal delta$^               removetotalweight$^      self.checkmutatingimethod              $^  $^    def pushself$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s checkmutatingimethod$^    pyxerr0 0000 pyxl0error$^  $^  struct pyxvtabstruct0pywrapfstmutablefst pyxvselfpyxbase.pyxvtabcheckmutatingimethodpyxvself if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^      return self$^  $^    cdef void pushself              $^                    float deltafst.kdelta$^                    bool removetotalweightfalse$^ $^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablefst.push pyxclineno pyxlineno pyxfilename$^  pyxl0$^  pyxrefnannyfinishcontext$^$^$^ pywrapfst.pyx0000$^      self.checkmutatingimethod$^  $^    def pushself              $^             float deltafst.kdelta$^             bool removetotalweightfalse$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00mutablefst00pushpyobject pyxvself pyobject pyxargs pyobject pyxkwds proto$^static char pyxdoc0pywrapfst00mutablefst00push  n    pushself delta0.0000000000 removetotalweightfalse tofinalfalsenn    pushes weights towards the initial or final states.nn    this operation destructively produces an equivalent transducer by pushingn    the weights towards the initial state or toward the final states. whenn    pushing weights towards the initial state the sum of the weight of then    outgoing transitions and final weight at any noninitial state is equal ton    one in the resulting machine. when pushing weights towards the final statesn    the sum of the weight of the incoming transitions at any state is equal ton    one. weights need to be left distributive when pushing towards the initialn    state and right distributive when pushing towards the final states.nn    argsn      delta comparisonquantization delta.n      removetotalweight if pushing weights should the total weight ben          removedn      tofinal push towards final statesnn    returnsn      self.nn    see also the constructive variant which also supports label pushing.n    $^static pyobject pyxpw0pywrapfst00mutablefst00pushpyobject pyxvself pyobject pyxargs pyobject pyxkwds $^  float pyxvdelta$^  bool pyxvremovetotalweight$^  bool pyxvtofinal$^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextpush wrapper 0$^  $^    static pyobject pyxpyargnames  pyxnsdeltapyxnsremovetotalweightpyxnstofinal0$^    pyobject values0  000$^    if unlikelypyxkwds $^      pyssizet kwargs$^      const pyssizet posargs  pytuplegetsizepyxargs$^      switch posargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 break$^        default goto pyxl0argtupleerror$^      $^      kwargs  pydictsizepyxkwds$^      switch posargs $^        case  0$^        if kwargs  0 $^          pyobject value  pydictgetitempyxkwds pyxnsdelta$^          if value  values0  value kwargs $^        $^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pydictgetitempyxkwds pyxnsremovetotalweight$^          if value  values0  value kwargs $^        $^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pydictgetitempyxkwds pyxnstofinal$^          if value  values0  value kwargs $^        $^      $^      if unlikelykwargs  0 $^        if unlikelypyxparseoptionalkeywordspyxkwds pyxpyargnames 0 values posargs push  0 pyxerr0 0000 pyxl0error$^      $^     else $^      switch pytuplegetsizepyxargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 break$^        default goto pyxl0argtupleerror$^      $^    $^    if values0 $^      pyxvdelta  pyxpyfloatasfloatvalues0 if unlikelypyxvdelta  float0  pyerroccurred pyxerr0 0000 pyxl0error$^     else $^      pyxvdelta  pyxk00$^    $^    if values0 $^      pyxvremovetotalweight  pyxpyobjectistruevalues0 if unlikelypyxvremovetotalweight  bool0  pyerroccurred pyxerr0 0000 pyxl0error$^     else $^$^       pywrapfst.pyx0000$^    def pushself$^             float deltafst.kdelta$^             bool removetotalweightfalse              $^             bool tofinalfalse$^      $^ $^      pyxvremovetotalweight  bool0$^    $^    if values0 $^      pyxvtofinal  pyxpyobjectistruevalues0 if unlikelypyxvtofinal  bool0  pyerroccurred pyxerr0 0000 pyxl0error$^     else $^$^       pywrapfst.pyx0000$^             float deltafst.kdelta$^             bool removetotalweightfalse$^             bool tofinalfalse              $^      $^      pushself delta0.0000000000 removetotalweightfalse tofinalfalse$^ $^      pyxvtofinal  bool0$^    $^  $^  goto pyxl0argumentunpackingdone$^  pyxl0argtupleerror$^  pyxraiseargtupleinvalidpush 0 0 0 pytuplegetsizepyxargs pyxerr0 0000 pyxl0error$^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablefst.push pyxclineno pyxlineno pyxfilename$^  pyxrefnannyfinishcontext$^  return null$^  pyxl0argumentunpackingdone$^  pyxr  pyxpf0pywrapfst00mutablefst00pushstruct pyxobj0pywrapfstmutablefst pyxvself pyxvdelta pyxvremovetotalweight pyxvtofinal$^$^   pywrapfst.pyx0000$^      self.checkmutatingimethod$^  $^    def pushself              $^             float deltafst.kdelta$^             bool removetotalweightfalse$^ $^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00mutablefst00pushstruct pyxobj0pywrapfstmutablefst pyxvself float pyxvdelta bool pyxvremovetotalweight bool pyxvtofinal $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  struct pyxoptargs0pywrapfst00mutablefstpush pyxt0$^  pyxrefnannysetupcontextpush 0$^$^   pywrapfst.pyx0000$^      see also the constructive variant which also supports label pushing.$^      $^      self.pushdelta removetotalweight tofinal              $^      return self$^  $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s push$^    pyxerr0 0000 pyxl0error$^  $^  pyxt0.pyxn  0$^  pyxt0.delta  pyxvdelta$^  pyxt0.removetotalweight  pyxvremovetotalweight$^  pyxt0.tofinal  pyxvtofinal$^  struct pyxvtabstruct0pywrapfstmutablefst pyxvselfpyxbase.pyxvtabpushpyxvself pyxt0 if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^      $^      self.pushdelta removetotalweight tofinal$^      return self              $^  $^    cdef void relabelpairsself ipairsnone opairsnone except $^ $^  pyxxdecrefpyxr$^  pyxincrefpyobject pyxvself$^  pyxr  pyobject pyxvself$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      self.checkmutatingimethod$^  $^    def pushself              $^             float deltafst.kdelta$^             bool removetotalweightfalse$^ $^$^   function exit code $^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablefst.push pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return self$^  $^    cdef void relabelpairsself ipairsnone opairsnone except               $^      cdef uniqueptrvectorfst.labelpair ipairs$^      ipairs.resetnew vectorfst.labelpair$^ $^$^static void pyxf0pywrapfst00mutablefstrelabelpairsstruct pyxobj0pywrapfstmutablefst pyxvself struct pyxoptargs0pywrapfst00mutablefstrelabelpairs pyxoptionalargs $^  pyobject pyxvipairs  pyobject pynone$^  pyobject pyxvopairs  pyobject pynone$^  stduniqueptrstdvectorpyxt0fstlabelpair   pyxvipairs$^  stduniqueptrstdvectorpyxt0fstlabelpair   pyxvopairs$^  pyxt00basictypesint00 pyxvbefore$^  pyxt00basictypesint00 pyxvafter$^  pyxrefnannydeclarations$^  stdvectorpyxt0fstlabelpair  pyxt0$^  int pyxt0$^  pyobject pyxt0  null$^  pyssizet pyxt0$^  pyobject pyxt0pyobject $^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt00pyobject $^  pyxt00basictypesint00 pyxt00$^  pyxt00basictypesint00 pyxt00$^  pyxt0fstlabelpair pyxt00$^  int pyxt00$^  pyxrefnannysetupcontextrelabelpairs 0$^  if pyxoptionalargs $^    if pyxoptionalargspyxn  0 $^      pyxvipairs  pyxoptionalargsipairs$^      if pyxoptionalargspyxn  0 $^        pyxvopairs  pyxoptionalargsopairs$^      $^    $^  $^$^   pywrapfst.pyx0000$^    cdef void relabelpairsself ipairsnone opairsnone except $^      cdef uniqueptrvectorfst.labelpair ipairs$^      ipairs.resetnew vectorfst.labelpair              $^      cdef uniqueptrvectorfst.labelpair opairs$^      opairs.resetnew vectorfst.labelpair$^ $^  try $^    pyxt0  new stdvectorpyxt0fstlabelpair $^   catch... $^    pyxcppexn0pyerr$^    pyxerr0 0000 pyxl0error$^  $^  pyxvipairs.resetpyxt0$^$^   pywrapfst.pyx0000$^      ipairs.resetnew vectorfst.labelpair$^      cdef uniqueptrvectorfst.labelpair opairs$^      opairs.resetnew vectorfst.labelpair              $^      cdef int00 before$^      cdef int00 after$^ $^  try $^    pyxt0  new stdvectorpyxt0fstlabelpair $^   catch... $^    pyxcppexn0pyerr$^    pyxerr0 0000 pyxl0error$^  $^  pyxvopairs.resetpyxt0$^$^   pywrapfst.pyx0000$^      cdef int00 before$^      cdef int00 after$^      if ipairs              $^        for before after in ipairs$^          ipairs.get.pushbackfst.labelpairbefore after$^ $^  pyxt0  pyxpyobjectistruepyxvipairs if unlikelypyxt0  0 pyxerr0 0000 pyxl0error$^  if pyxt0 $^$^     pywrapfst.pyx0000$^      cdef int00 after$^      if ipairs$^        for before after in ipairs              $^          ipairs.get.pushbackfst.labelpairbefore after$^      if opairs$^ $^    if likelypylistcheckexactpyxvipairs  pytuplecheckexactpyxvipairs $^      pyxt0  pyxvipairs pyxincrefpyxt0 pyxt0  0$^      pyxt0  null$^     else $^      pyxt0  0 pyxt0  pyobjectgetiterpyxvipairs if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxgotrefpyxt0$^      pyxt0  pytypepyxt0tpiternext if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    $^    for  $^      if likelypyxt0 $^        if likelypylistcheckexactpyxt0 $^          if pyxt0  pylistgetsizepyxt0 break$^          if cythonassumesafemacros  cythonavoidborrowedrefs$^          pyxt0  pylistgetitempyxt0 pyxt0 pyxincrefpyxt0 pyxt0 if unlikely0  0 pyxerr0 0000 pyxl0error$^          else$^          pyxt0  pysequenceitempyxt0 pyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^          pyxgotrefpyxt0$^          endif$^         else $^          if pyxt0  pytuplegetsizepyxt0 break$^          if cythonassumesafemacros  cythonavoidborrowedrefs$^          pyxt0  pytuplegetitempyxt0 pyxt0 pyxincrefpyxt0 pyxt0 if unlikely0  0 pyxerr0 0000 pyxl0error$^          else$^          pyxt0  pysequenceitempyxt0 pyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^          pyxgotrefpyxt0$^          endif$^        $^       else $^        pyxt0  pyxt0pyxt0$^        if unlikelypyxt0 $^          pyobject exctype  pyerroccurred$^          if exctype $^            if likelypyxpyerrgivenexceptionmatchesexctype pyexcstopiteration pyerrclear$^            else pyxerr0 0000 pyxl0error$^          $^          break$^        $^        pyxgotrefpyxt0$^      $^      if likelypytuplecheckexactpyxt0  pylistcheckexactpyxt0 $^        pyobject sequence  pyxt0$^        if cythoncompilinginpypy$^        pyssizet size  pysizesequence$^        else$^        pyssizet size  pysequencesizesequence$^        endif$^        if unlikelysize  0 $^          if size  0 pyxraisetoomanyvalueserror0$^          else if size  0 pyxraiseneedmorevalueserrorsize$^          pyxerr0 0000 pyxl0error$^        $^        if cythonassumesafemacros  cythonavoidborrowedrefs$^        if likelypytuplecheckexactsequence $^          pyxt0  pytuplegetitemsequence 0 $^          pyxt0  pytuplegetitemsequence 0 $^         else $^          pyxt0  pylistgetitemsequence 0 $^          pyxt0  pylistgetitemsequence 0 $^        $^        pyxincrefpyxt0$^        pyxincrefpyxt0$^        else$^        pyxt0  pysequenceitemsequence 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxgotrefpyxt0$^        pyxt0  pysequenceitemsequence 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxgotrefpyxt0$^        endif$^        pyxdecrefpyxt0 pyxt0  0$^       else $^        pyssizet index  0$^        pyxt0  pyobjectgetiterpyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^        pyxt00  pytypepyxt0tpiternext$^        index  0 pyxt0  pyxt00pyxt0 if unlikelypyxt0 goto pyxl0unpackingfailed$^        pyxgotrefpyxt0$^        index  0 pyxt0  pyxt00pyxt0 if unlikelypyxt0 goto pyxl0unpackingfailed$^        pyxgotrefpyxt0$^        if pyxiternextunpackendcheckpyxt00pyxt0 0  0 pyxerr0 0000 pyxl0error$^        pyxt00  null$^        pyxdecrefpyxt0 pyxt0  0$^        goto pyxl0unpackingdone$^        pyxl0unpackingfailed$^        pyxdecrefpyxt0 pyxt0  0$^        pyxt00  null$^        if pyxiterfinish  0 pyxraiseneedmorevalueserrorindex$^        pyxerr0 0000 pyxl0error$^        pyxl0unpackingdone$^      $^      pyxt00  pyxpyintasint00tpyxt0 if unlikelypyxt00  int00t0  pyerroccurred pyxerr0 0000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxt00  pyxpyintasint00tpyxt0 if unlikelypyxt00  int00t0  pyerroccurred pyxerr0 0000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxvbefore  pyxt00$^      pyxvafter  pyxt00$^$^       pywrapfst.pyx0000$^      if ipairs$^        for before after in ipairs$^          ipairs.get.pushbackfst.labelpairbefore after              $^      if opairs$^        for before after in opairs$^ $^      try $^        pyxt00  pyxt0fstlabelpairpyxvbefore pyxvafter$^       catch... $^        pyxcppexn0pyerr$^        pyxerr0 0000 pyxl0error$^      $^      try $^        pyxvipairs.getpushbackpyxt00$^       catch... $^        pyxcppexn0pyerr$^        pyxerr0 0000 pyxl0error$^      $^$^       pywrapfst.pyx0000$^      cdef int00 after$^      if ipairs$^        for before after in ipairs              $^          ipairs.get.pushbackfst.labelpairbefore after$^      if opairs$^ $^    $^    pyxdecrefpyxt0 pyxt0  0$^$^     pywrapfst.pyx0000$^      cdef int00 before$^      cdef int00 after$^      if ipairs              $^        for before after in ipairs$^          ipairs.get.pushbackfst.labelpairbefore after$^ $^  $^$^   pywrapfst.pyx0000$^        for before after in ipairs$^          ipairs.get.pushbackfst.labelpairbefore after$^      if opairs              $^        for before after in opairs$^          opairs.get.pushbackfst.labelpairbefore after$^ $^  pyxt0  pyxpyobjectistruepyxvopairs if unlikelypyxt0  0 pyxerr0 0000 pyxl0error$^  if pyxt0 $^$^     pywrapfst.pyx0000$^          ipairs.get.pushbackfst.labelpairbefore after$^      if opairs$^        for before after in opairs              $^          opairs.get.pushbackfst.labelpairbefore after$^      if ipairs.get.empty and opairs.get.empty$^ $^    if likelypylistcheckexactpyxvopairs  pytuplecheckexactpyxvopairs $^      pyxt0  pyxvopairs pyxincrefpyxt0 pyxt0  0$^      pyxt0  null$^     else $^      pyxt0  0 pyxt0  pyobjectgetiterpyxvopairs if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxgotrefpyxt0$^      pyxt0  pytypepyxt0tpiternext if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    $^    for  $^      if likelypyxt0 $^        if likelypylistcheckexactpyxt0 $^          if pyxt0  pylistgetsizepyxt0 break$^          if cythonassumesafemacros  cythonavoidborrowedrefs$^          pyxt0  pylistgetitempyxt0 pyxt0 pyxincrefpyxt0 pyxt0 if unlikely0  0 pyxerr0 0000 pyxl0error$^          else$^          pyxt0  pysequenceitempyxt0 pyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^          pyxgotrefpyxt0$^          endif$^         else $^          if pyxt0  pytuplegetsizepyxt0 break$^          if cythonassumesafemacros  cythonavoidborrowedrefs$^          pyxt0  pytuplegetitempyxt0 pyxt0 pyxincrefpyxt0 pyxt0 if unlikely0  0 pyxerr0 0000 pyxl0error$^          else$^          pyxt0  pysequenceitempyxt0 pyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^          pyxgotrefpyxt0$^          endif$^        $^       else $^        pyxt0  pyxt0pyxt0$^        if unlikelypyxt0 $^          pyobject exctype  pyerroccurred$^          if exctype $^            if likelypyxpyerrgivenexceptionmatchesexctype pyexcstopiteration pyerrclear$^            else pyxerr0 0000 pyxl0error$^          $^          break$^        $^        pyxgotrefpyxt0$^      $^      if likelypytuplecheckexactpyxt0  pylistcheckexactpyxt0 $^        pyobject sequence  pyxt0$^        if cythoncompilinginpypy$^        pyssizet size  pysizesequence$^        else$^        pyssizet size  pysequencesizesequence$^        endif$^        if unlikelysize  0 $^          if size  0 pyxraisetoomanyvalueserror0$^          else if size  0 pyxraiseneedmorevalueserrorsize$^          pyxerr0 0000 pyxl0error$^        $^        if cythonassumesafemacros  cythonavoidborrowedrefs$^        if likelypytuplecheckexactsequence $^          pyxt0  pytuplegetitemsequence 0 $^          pyxt0  pytuplegetitemsequence 0 $^         else $^          pyxt0  pylistgetitemsequence 0 $^          pyxt0  pylistgetitemsequence 0 $^        $^        pyxincrefpyxt0$^        pyxincrefpyxt0$^        else$^        pyxt0  pysequenceitemsequence 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxgotrefpyxt0$^        pyxt0  pysequenceitemsequence 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxgotrefpyxt0$^        endif$^        pyxdecrefpyxt0 pyxt0  0$^       else $^        pyssizet index  0$^        pyxt0  pyobjectgetiterpyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^        pyxt00  pytypepyxt0tpiternext$^        index  0 pyxt0  pyxt00pyxt0 if unlikelypyxt0 goto pyxl00unpackingfailed$^        pyxgotrefpyxt0$^        index  0 pyxt0  pyxt00pyxt0 if unlikelypyxt0 goto pyxl00unpackingfailed$^        pyxgotrefpyxt0$^        if pyxiternextunpackendcheckpyxt00pyxt0 0  0 pyxerr0 0000 pyxl0error$^        pyxt00  null$^        pyxdecrefpyxt0 pyxt0  0$^        goto pyxl00unpackingdone$^        pyxl00unpackingfailed$^        pyxdecrefpyxt0 pyxt0  0$^        pyxt00  null$^        if pyxiterfinish  0 pyxraiseneedmorevalueserrorindex$^        pyxerr0 0000 pyxl0error$^        pyxl00unpackingdone$^      $^      pyxt00  pyxpyintasint00tpyxt0 if unlikelypyxt00  int00t0  pyerroccurred pyxerr0 0000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxt00  pyxpyintasint00tpyxt0 if unlikelypyxt00  int00t0  pyerroccurred pyxerr0 0000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxvbefore  pyxt00$^      pyxvafter  pyxt00$^$^       pywrapfst.pyx0000$^      if opairs$^        for before after in opairs$^          opairs.get.pushbackfst.labelpairbefore after              $^      if ipairs.get.empty and opairs.get.empty$^        raise fstargerrorno relabeling pairs specified.$^ $^      try $^        pyxt00  pyxt0fstlabelpairpyxvbefore pyxvafter$^       catch... $^        pyxcppexn0pyerr$^        pyxerr0 0000 pyxl0error$^      $^      try $^        pyxvopairs.getpushbackpyxt00$^       catch... $^        pyxcppexn0pyerr$^        pyxerr0 0000 pyxl0error$^      $^$^       pywrapfst.pyx0000$^          ipairs.get.pushbackfst.labelpairbefore after$^      if opairs$^        for before after in opairs              $^          opairs.get.pushbackfst.labelpairbefore after$^      if ipairs.get.empty and opairs.get.empty$^ $^    $^    pyxdecrefpyxt0 pyxt0  0$^$^     pywrapfst.pyx0000$^        for before after in ipairs$^          ipairs.get.pushbackfst.labelpairbefore after$^      if opairs              $^        for before after in opairs$^          opairs.get.pushbackfst.labelpairbefore after$^ $^  $^$^   pywrapfst.pyx0000$^        for before after in opairs$^          opairs.get.pushbackfst.labelpairbefore after$^      if ipairs.get.empty and opairs.get.empty              $^        raise fstargerrorno relabeling pairs specified.$^      fst.relabelself.mfst.get derefipairs derefopairs$^ $^  pyxt00  pyxvipairs.getempty  0$^  if pyxt00 $^   else $^    pyxt0  pyxt00$^    goto pyxl00boolbinopdone$^  $^  pyxt00  pyxvopairs.getempty  0$^  pyxt0  pyxt00$^  pyxl00boolbinopdone$^  if pyxt0 $^$^     pywrapfst.pyx0000$^          opairs.get.pushbackfst.labelpairbefore after$^      if ipairs.get.empty and opairs.get.empty$^        raise fstargerrorno relabeling pairs specified.              $^      fst.relabelself.mfst.get derefipairs derefopairs$^      self.checkmutatingimethod$^ $^    pyxt0  pyxgetmoduleglobalnamepyxnsfstargerror if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  pyxpyobjectcallpyxt0 pyxtuple00 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxraisepyxt0 0 0 0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxerr0 0000 pyxl0error$^$^     pywrapfst.pyx0000$^        for before after in opairs$^          opairs.get.pushbackfst.labelpairbefore after$^      if ipairs.get.empty and opairs.get.empty              $^        raise fstargerrorno relabeling pairs specified.$^      fst.relabelself.mfst.get derefipairs derefopairs$^ $^  $^$^   pywrapfst.pyx0000$^      if ipairs.get.empty and opairs.get.empty$^        raise fstargerrorno relabeling pairs specified.$^      fst.relabelself.mfst.get derefipairs derefopairs              $^      self.checkmutatingimethod$^  $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s mfst$^    pyxerr0 0000 pyxl0error$^  $^  fstscriptrelabelpyxvselfmfst.get pyxvipairs pyxvopairs$^$^   pywrapfst.pyx0000$^        raise fstargerrorno relabeling pairs specified.$^      fst.relabelself.mfst.get derefipairs derefopairs$^      self.checkmutatingimethod              $^  $^    def relabelpairsself ipairsnone opairsnone$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s checkmutatingimethod$^    pyxerr0 0000 pyxl0error$^  $^  struct pyxvtabstruct0pywrapfstmutablefst pyxvselfpyxbase.pyxvtabcheckmutatingimethodpyxvself if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^      return self$^  $^    cdef void relabelpairsself ipairsnone opairsnone except               $^      cdef uniqueptrvectorfst.labelpair ipairs$^      ipairs.resetnew vectorfst.labelpair$^ $^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.mutablefst.relabelpairs pyxclineno pyxlineno pyxfilename$^  pyxl0$^  pyxrefnannyfinishcontext$^$^$^ pywrapfst.pyx0000$^      self.checkmutatingimethod$^  $^    def relabelpairsself ipairsnone opairsnone              $^      $^      relabelpairsself ipairsnone opairsnone$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00mutablefst00relabelpairspyobject pyxvself pyobject pyxargs pyobject pyxkwds proto$^static char pyxdoc0pywrapfst00mutablefst00relabelpairs  n    relabelpairsself ipairsnone opairsnonenn    replaces input andor output labels using pairs of labels.nn    this operation destructively relabels the input andor output labels of then    fst using pairs of the form oldid newid omitted indices aren    identitymapped.nn    argsn      ipairs an iterable containing older index newer index integer pairs.n      opairs an iterable containing older index newer index integer pairs.nn    returnsn      self.nn    raisesn      fstargerror no relabeling pairs specified.nn    see also decode encode project relabeltables.n    $^static pyobject pyxpw0pywrapfst00mutablefst00relabelpairspyobject pyxvself pyobject pyxargs pyobject pyxkwds $^  pyobject pyxvipairs  0$^  pyobject pyxvopairs  0$^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextrelabelpairs wrapper 0$^  $^    static pyobject pyxpyargnames  pyxnsipairspyxnsopairs0$^    pyobject values0  00$^    values0  pyobject pynone$^    values0  pyobject pynone$^    if unlikelypyxkwds $^      pyssizet kwargs$^      const pyssizet posargs  pytuplegetsizepyxargs$^      switch posargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 break$^        default goto pyxl0argtupleerror$^      $^      kwargs  pydictsizepyxkwds$^      switch posargs $^        case  0$^        if kwargs  0 $^          pyobject value  pydictgetitempyxkwds pyxnsipairs$^          if value  values0  value kwargs $^        $^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pydictgetitempyxkwds pyxnsopairs$^          if value  values0  value kwargs $^        $^      $^      if unlikelykwargs  0 $^        if unlikelypyxparseoptionalkeywordspyxkwds pyxpyargnames 0 values posargs relabelpairs  0 pyxerr0 0000 pyxl0error$^      $^     else $^      switch pytuplegetsizepyxargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 break$^        default goto pyxl0argtupleerror$^      $^    $^    pyxvipairs  values0$^    pyxvopairs  values0$^  $^  goto pyxl0argumentunpackingdone$^  pyxl0argtupleerror$^  pyxraiseargtupleinvalidrelabelpairs 0 0 0 pytuplegetsizepyxargs pyxerr0 0000 pyxl0error$^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablefst.relabelpairs pyxclineno pyxlineno pyxfilename$^  pyxrefnannyfinishcontext$^  return null$^  pyxl0argumentunpackingdone$^  pyxr  pyxpf0pywrapfst00mutablefst00relabelpairsstruct pyxobj0pywrapfstmutablefst pyxvself pyxvipairs pyxvopairs$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00mutablefst00relabelpairsstruct pyxobj0pywrapfstmutablefst pyxvself pyobject pyxvipairs pyobject pyxvopairs $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  struct pyxoptargs0pywrapfst00mutablefstrelabelpairs pyxt0$^  pyxrefnannysetupcontextrelabelpairs 0$^$^   pywrapfst.pyx0000$^      see also decode encode project relabeltables.$^      $^      self.relabelpairsipairs opairs              $^      return self$^  $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s relabelpairs$^    pyxerr0 0000 pyxl0error$^  $^  pyxt0.pyxn  0$^  pyxt0.ipairs  pyxvipairs$^  pyxt0.opairs  pyxvopairs$^  struct pyxvtabstruct0pywrapfstmutablefst pyxvselfpyxbase.pyxvtabrelabelpairspyxvself pyxt0 if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^      $^      self.relabelpairsipairs opairs$^      return self              $^  $^    cdef void relabeltablesself$^ $^  pyxxdecrefpyxr$^  pyxincrefpyobject pyxvself$^  pyxr  pyobject pyxvself$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      self.checkmutatingimethod$^  $^    def relabelpairsself ipairsnone opairsnone              $^      $^      relabelpairsself ipairsnone opairsnone$^ $^$^   function exit code $^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablefst.relabelpairs pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return self$^  $^    cdef void relabeltablesself              $^                              symboltable oldisymbolsnone$^                              symboltable newisymbolsnone$^ $^$^static void pyxf0pywrapfst00mutablefstrelabeltablesstruct pyxobj0pywrapfstmutablefst pyxvself struct pyxoptargs0pywrapfst00mutablefstrelabeltables pyxoptionalargs $^$^   pywrapfst.pyx0000$^  $^    cdef void relabeltablesself$^                              symboltable oldisymbolsnone              $^                              symboltable newisymbolsnone$^                              unknownisymbolb$^ $^  struct pyxobj0pywrapfstsymboltable pyxvoldisymbols  struct pyxobj0pywrapfstsymboltable pynone$^$^   pywrapfst.pyx0000$^    cdef void relabeltablesself$^                              symboltable oldisymbolsnone$^                              symboltable newisymbolsnone              $^                              unknownisymbolb$^                              bool attachnewisymbolstrue$^ $^  struct pyxobj0pywrapfstsymboltable pyxvnewisymbols  struct pyxobj0pywrapfstsymboltable pynone$^  pyobject pyxvunknownisymbol  pyobject pyxkpb00$^$^   pywrapfst.pyx0000$^                              symboltable newisymbolsnone$^                              unknownisymbolb$^                              bool attachnewisymbolstrue              $^                              symboltable oldosymbolsnone$^                              symboltable newosymbolsnone$^ $^  bool pyxvattachnewisymbols  bool0$^$^   pywrapfst.pyx0000$^                              unknownisymbolb$^                              bool attachnewisymbolstrue$^                              symboltable oldosymbolsnone              $^                              symboltable newosymbolsnone$^                              unknownosymbolb$^ $^  struct pyxobj0pywrapfstsymboltable pyxvoldosymbols  struct pyxobj0pywrapfstsymboltable pynone$^$^   pywrapfst.pyx0000$^                              bool attachnewisymbolstrue$^                              symboltable oldosymbolsnone$^                              symboltable newosymbolsnone              $^                              unknownosymbolb$^                              bool attachnewosymbolstrue except $^ $^  struct pyxobj0pywrapfstsymboltable pyxvnewosymbols  struct pyxobj0pywrapfstsymboltable pynone$^  pyobject pyxvunknownosymbol  pyobject pyxkpb00$^$^   pywrapfst.pyx0000$^                              symboltable newosymbolsnone$^                              unknownosymbolb$^                              bool attachnewosymbolstrue except               $^      if newisymbols is none and newosymbols is none$^        raise fstargerrorno new symboltables specified$^ $^  bool pyxvattachnewosymbols  bool0$^  fstsymboltable pyxvnewisymbolsptr$^  fstsymboltable pyxvnewosymbolsptr$^  pyxrefnannydeclarations$^  int pyxt0$^  int pyxt0$^  int pyxt0$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  fstsymboltable pyxt0$^  fstsymboltable const pyxt0$^  stdstring pyxt0$^  fstsymboltable const pyxt0$^  stdstring pyxt00$^  pyxrefnannysetupcontextrelabeltables 0$^  if pyxoptionalargs $^    if pyxoptionalargspyxn  0 $^      pyxvoldisymbols  pyxoptionalargsoldisymbols$^      if pyxoptionalargspyxn  0 $^        pyxvnewisymbols  pyxoptionalargsnewisymbols$^        if pyxoptionalargspyxn  0 $^          pyxvunknownisymbol  pyxoptionalargsunknownisymbol$^          if pyxoptionalargspyxn  0 $^            pyxvattachnewisymbols  pyxoptionalargsattachnewisymbols$^            if pyxoptionalargspyxn  0 $^              pyxvoldosymbols  pyxoptionalargsoldosymbols$^              if pyxoptionalargspyxn  0 $^                pyxvnewosymbols  pyxoptionalargsnewosymbols$^                if pyxoptionalargspyxn  0 $^                  pyxvunknownosymbol  pyxoptionalargsunknownosymbol$^                  if pyxoptionalargspyxn  0 $^                    pyxvattachnewosymbols  pyxoptionalargsattachnewosymbols$^                  $^                $^              $^            $^          $^        $^      $^    $^  $^$^   pywrapfst.pyx0000$^                              unknownosymbolb$^                              bool attachnewosymbolstrue except $^      if newisymbols is none and newosymbols is none              $^        raise fstargerrorno new symboltables specified$^      cdef fst.symboltable newisymbolsptr  null$^ $^  pyxt0  pyobject pyxvnewisymbols  pynone$^  pyxt0  pyxt0  0$^  if pyxt0 $^   else $^    pyxt0  pyxt0$^    goto pyxl0boolbinopdone$^  $^  pyxt0  pyobject pyxvnewosymbols  pynone$^  pyxt0  pyxt0  0$^  pyxt0  pyxt0$^  pyxl0boolbinopdone$^  if pyxt0 $^$^     pywrapfst.pyx0000$^                              bool attachnewosymbolstrue except $^      if newisymbols is none and newosymbols is none$^        raise fstargerrorno new symboltables specified              $^      cdef fst.symboltable newisymbolsptr  null$^      if newisymbols is not none$^ $^    pyxt0  pyxgetmoduleglobalnamepyxnsfstargerror if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  pyxpyobjectcallpyxt0 pyxtuple00 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxraisepyxt0 0 0 0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxerr0 0000 pyxl0error$^$^     pywrapfst.pyx0000$^                              unknownosymbolb$^                              bool attachnewosymbolstrue except $^      if newisymbols is none and newosymbols is none              $^        raise fstargerrorno new symboltables specified$^      cdef fst.symboltable newisymbolsptr  null$^ $^  $^$^   pywrapfst.pyx0000$^      if newisymbols is none and newosymbols is none$^        raise fstargerrorno new symboltables specified$^      cdef fst.symboltable newisymbolsptr  null              $^      if newisymbols is not none$^        newisymbolsptr  newisymbols.table$^ $^  pyxvnewisymbolsptr  null$^$^   pywrapfst.pyx0000$^        raise fstargerrorno new symboltables specified$^      cdef fst.symboltable newisymbolsptr  null$^      if newisymbols is not none              $^        newisymbolsptr  newisymbols.table$^      cdef fst.symboltable newosymbolsptr  null$^ $^  pyxt0  pyobject pyxvnewisymbols  pynone$^  pyxt0  pyxt0  0$^  if pyxt0 $^$^     pywrapfst.pyx0000$^      cdef fst.symboltable newisymbolsptr  null$^      if newisymbols is not none$^        newisymbolsptr  newisymbols.table              $^      cdef fst.symboltable newosymbolsptr  null$^      if newosymbols is not none$^ $^    if unlikelypyobject pyxvnewisymbols  pynone $^      pyerrformatpyexcattributeerror nonetype object has no attribute .00s table$^      pyxerr0 0000 pyxl0error$^    $^    pyxt0  pyxvnewisymbolstable$^    pyxvnewisymbolsptr  pyxt0$^$^     pywrapfst.pyx0000$^        raise fstargerrorno new symboltables specified$^      cdef fst.symboltable newisymbolsptr  null$^      if newisymbols is not none              $^        newisymbolsptr  newisymbols.table$^      cdef fst.symboltable newosymbolsptr  null$^ $^  $^$^   pywrapfst.pyx0000$^      if newisymbols is not none$^        newisymbolsptr  newisymbols.table$^      cdef fst.symboltable newosymbolsptr  null              $^      if newosymbols is not none$^        newosymbolsptr  newosymbols.table$^ $^  pyxvnewosymbolsptr  null$^$^   pywrapfst.pyx0000$^        newisymbolsptr  newisymbols.table$^      cdef fst.symboltable newosymbolsptr  null$^      if newosymbols is not none              $^        newosymbolsptr  newosymbols.table$^      fst.relabelself.mfst.get$^ $^  pyxt0  pyobject pyxvnewosymbols  pynone$^  pyxt0  pyxt0  0$^  if pyxt0 $^$^     pywrapfst.pyx0000$^      cdef fst.symboltable newosymbolsptr  null$^      if newosymbols is not none$^        newosymbolsptr  newosymbols.table              $^      fst.relabelself.mfst.get$^          self.fst.get.inputsymbols if oldisymbols is none else$^ $^    if unlikelypyobject pyxvnewosymbols  pynone $^      pyerrformatpyexcattributeerror nonetype object has no attribute .00s table$^      pyxerr0 0000 pyxl0error$^    $^    pyxt0  pyxvnewosymbolstable$^    pyxvnewosymbolsptr  pyxt0$^$^     pywrapfst.pyx0000$^        newisymbolsptr  newisymbols.table$^      cdef fst.symboltable newosymbolsptr  null$^      if newosymbols is not none              $^        newosymbolsptr  newosymbols.table$^      fst.relabelself.mfst.get$^ $^  $^$^   pywrapfst.pyx0000$^      if newosymbols is not none$^        newosymbolsptr  newosymbols.table$^      fst.relabelself.mfst.get              $^          self.fst.get.inputsymbols if oldisymbols is none else$^          oldisymbols.table newisymbolsptr tostringunknownisymbol$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s mfst$^    pyxerr0 0000 pyxl0error$^  $^$^   pywrapfst.pyx0000$^        newosymbolsptr  newosymbols.table$^      fst.relabelself.mfst.get$^          self.fst.get.inputsymbols if oldisymbols is none else              $^          oldisymbols.table newisymbolsptr tostringunknownisymbol$^          attachnewisymbols$^ $^  pyxt0  pyobject pyxvoldisymbols  pynone$^  if pyxt0  0 $^    if unlikelypyobject pyxvself  pynone $^      pyerrformatpyexcattributeerror nonetype object has no attribute .00s fst$^      pyxerr0 0000 pyxl0error$^    $^    pyxt0  pyxvselfpyxbase.fst.getinputsymbols$^   else $^$^     pywrapfst.pyx0000$^      fst.relabelself.mfst.get$^          self.fst.get.inputsymbols if oldisymbols is none else$^          oldisymbols.table newisymbolsptr tostringunknownisymbol              $^          attachnewisymbols$^          self.fst.get.outputsymbols if oldosymbols is none else$^ $^    if unlikelypyobject pyxvoldisymbols  pynone $^      pyerrformatpyexcattributeerror nonetype object has no attribute .00s table$^      pyxerr0 0000 pyxl0error$^    $^    pyxt0  pyxvoldisymbolstable$^  $^  pyxt0  pyxf0pywrapfsttostringpyxvunknownisymbol null if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^          oldisymbols.table newisymbolsptr tostringunknownisymbol$^          attachnewisymbols$^          self.fst.get.outputsymbols if oldosymbols is none else              $^          oldosymbols.table newosymbolsptr tostringunknownosymbol$^          attachnewosymbols$^ $^  pyxt0  pyobject pyxvoldosymbols  pynone$^  if pyxt0  0 $^    if unlikelypyobject pyxvself  pynone $^      pyerrformatpyexcattributeerror nonetype object has no attribute .00s fst$^      pyxerr0 0000 pyxl0error$^    $^    pyxt0  pyxvselfpyxbase.fst.getoutputsymbols$^   else $^$^     pywrapfst.pyx0000$^          attachnewisymbols$^          self.fst.get.outputsymbols if oldosymbols is none else$^          oldosymbols.table newosymbolsptr tostringunknownosymbol              $^          attachnewosymbols$^      self.checkmutatingimethod$^ $^    if unlikelypyobject pyxvoldosymbols  pynone $^      pyerrformatpyexcattributeerror nonetype object has no attribute .00s table$^      pyxerr0 0000 pyxl0error$^    $^    pyxt0  pyxvoldosymbolstable$^  $^  pyxt00  pyxf0pywrapfsttostringpyxvunknownosymbol null if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^      if newosymbols is not none$^        newosymbolsptr  newosymbols.table$^      fst.relabelself.mfst.get              $^          self.fst.get.inputsymbols if oldisymbols is none else$^          oldisymbols.table newisymbolsptr tostringunknownisymbol$^ $^  fstscriptrelabelpyxvselfmfst.get pyxt0 pyxvnewisymbolsptr pyxt0 pyxvattachnewisymbols pyxt0 pyxvnewosymbolsptr pyxt00 pyxvattachnewosymbols$^$^   pywrapfst.pyx0000$^          oldosymbols.table newosymbolsptr tostringunknownosymbol$^          attachnewosymbols$^      self.checkmutatingimethod              $^  $^    def relabeltablesself$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s checkmutatingimethod$^    pyxerr0 0000 pyxl0error$^  $^  struct pyxvtabstruct0pywrapfstmutablefst pyxvselfpyxbase.pyxvtabcheckmutatingimethodpyxvself if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^      return self$^  $^    cdef void relabeltablesself              $^                              symboltable oldisymbolsnone$^                              symboltable newisymbolsnone$^ $^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.mutablefst.relabeltables pyxclineno pyxlineno pyxfilename$^  pyxl0$^  pyxrefnannyfinishcontext$^$^$^ pywrapfst.pyx0000$^      self.checkmutatingimethod$^  $^    def relabeltablesself              $^                       symboltable oldisymbolsnone$^                       symboltable newisymbolsnone$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00mutablefst00relabeltablespyobject pyxvself pyobject pyxargs pyobject pyxkwds proto$^static char pyxdoc0pywrapfst00mutablefst00relabeltables  n    relabeltablesself oldisymbolsnone newisymbolsnonen                   unknownisymbol attachnewisymbolstruen                   oldosymbolsnone newosymbolsnonen                   unknownosymbol attachnewosymbolstruenn    replaces input andor output labels using symboltables.nn    this operation destructively relabels the input andor output labels of then    fst using userspecified symbol tables omitted symbols are identitymapped.nn    argsn       oldisymbols the old symboltable for input labels defaulting to then          fsts input symbol table.n       newisymbols a symboltable used to relabel the input labelsn       unknownisymbol input symbol to use to relabel oovs if emptyn          oovs raise an exceptionn       attachnewisymbols should newisymbols be made the fsts input symboln          tablen       oldosymbols the old symboltable for output labels defaulting to then          fsts output symbol table.n       newosymbols a symboltable used to relabel the output labels.n       unknownosymbol outnput symbol to use to relabel oovs if emptyn          oovs raise an exceptionn       attachnewisymbols should newosymbols be made the fsts output symboln          tablenn    returnsn      self.nn    raisesn      fstargerror no symboltable specified.nn    see also decode encode project relabelpairs.n    $^static pyobject pyxpw0pywrapfst00mutablefst00relabeltablespyobject pyxvself pyobject pyxargs pyobject pyxkwds $^  struct pyxobj0pywrapfstsymboltable pyxvoldisymbols  0$^  struct pyxobj0pywrapfstsymboltable pyxvnewisymbols  0$^  pyobject pyxvunknownisymbol  0$^  bool pyxvattachnewisymbols$^  struct pyxobj0pywrapfstsymboltable pyxvoldosymbols  0$^  struct pyxobj0pywrapfstsymboltable pyxvnewosymbols  0$^  pyobject pyxvunknownosymbol  0$^  bool pyxvattachnewosymbols$^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextrelabeltables wrapper 0$^  $^    static pyobject pyxpyargnames  pyxnsoldisymbolspyxnsnewisymbolspyxnsunknownisymbolpyxnsattachnewisymbolspyxnsoldosymbolspyxnsnewosymbolspyxnsunknownosymbolpyxnsattachnewosymbols0$^    pyobject values0  00000000$^$^     pywrapfst.pyx0000$^  $^    def relabeltablesself$^                       symboltable oldisymbolsnone              $^                       symboltable newisymbolsnone$^                       unknownisymbolb$^ $^    values0  pyobject struct pyxobj0pywrapfstsymboltable pynone$^$^     pywrapfst.pyx0000$^    def relabeltablesself$^                       symboltable oldisymbolsnone$^                       symboltable newisymbolsnone              $^                       unknownisymbolb$^                       bool attachnewisymbolstrue$^ $^    values0  pyobject struct pyxobj0pywrapfstsymboltable pynone$^    values0  pyobject pyxkpb00$^$^     pywrapfst.pyx0000$^                       unknownisymbolb$^                       bool attachnewisymbolstrue$^                       symboltable oldosymbolsnone              $^                       symboltable newosymbolsnone$^                       unknownosymbolb$^ $^    values0  pyobject struct pyxobj0pywrapfstsymboltable pynone$^$^     pywrapfst.pyx0000$^                       bool attachnewisymbolstrue$^                       symboltable oldosymbolsnone$^                       symboltable newosymbolsnone              $^                       unknownosymbolb$^                       bool attachnewosymbolstrue$^ $^    values0  pyobject struct pyxobj0pywrapfstsymboltable pynone$^    values0  pyobject pyxkpb00$^    if unlikelypyxkwds $^      pyssizet kwargs$^      const pyssizet posargs  pytuplegetsizepyxargs$^      switch posargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 break$^        default goto pyxl0argtupleerror$^      $^      kwargs  pydictsizepyxkwds$^      switch posargs $^        case  0$^        if kwargs  0 $^          pyobject value  pydictgetitempyxkwds pyxnsoldisymbols$^          if value  values0  value kwargs $^        $^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pydictgetitempyxkwds pyxnsnewisymbols$^          if value  values0  value kwargs $^        $^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pydictgetitempyxkwds pyxnsunknownisymbol$^          if value  values0  value kwargs $^        $^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pydictgetitempyxkwds pyxnsattachnewisymbols$^          if value  values0  value kwargs $^        $^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pydictgetitempyxkwds pyxnsoldosymbols$^          if value  values0  value kwargs $^        $^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pydictgetitempyxkwds pyxnsnewosymbols$^          if value  values0  value kwargs $^        $^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pydictgetitempyxkwds pyxnsunknownosymbol$^          if value  values0  value kwargs $^        $^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pydictgetitempyxkwds pyxnsattachnewosymbols$^          if value  values0  value kwargs $^        $^      $^      if unlikelykwargs  0 $^        if unlikelypyxparseoptionalkeywordspyxkwds pyxpyargnames 0 values posargs relabeltables  0 pyxerr0 0000 pyxl0error$^      $^     else $^      switch pytuplegetsizepyxargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 break$^        default goto pyxl0argtupleerror$^      $^    $^    pyxvoldisymbols  struct pyxobj0pywrapfstsymboltable values0$^    pyxvnewisymbols  struct pyxobj0pywrapfstsymboltable values0$^    pyxvunknownisymbol  values0$^    if values0 $^      pyxvattachnewisymbols  pyxpyobjectistruevalues0 if unlikelypyxvattachnewisymbols  bool0  pyerroccurred pyxerr0 0000 pyxl0error$^     else $^$^       pywrapfst.pyx0000$^                       symboltable newisymbolsnone$^                       unknownisymbolb$^                       bool attachnewisymbolstrue              $^                       symboltable oldosymbolsnone$^                       symboltable newosymbolsnone$^ $^      pyxvattachnewisymbols  bool0$^    $^    pyxvoldosymbols  struct pyxobj0pywrapfstsymboltable values0$^    pyxvnewosymbols  struct pyxobj0pywrapfstsymboltable values0$^    pyxvunknownosymbol  values0$^    if values0 $^      pyxvattachnewosymbols  pyxpyobjectistruevalues0 if unlikelypyxvattachnewosymbols  bool0  pyerroccurred pyxerr0 0000 pyxl0error$^     else $^$^       pywrapfst.pyx0000$^                       symboltable newosymbolsnone$^                       unknownosymbolb$^                       bool attachnewosymbolstrue              $^      $^      relabeltablesself oldisymbolsnone newisymbolsnone$^ $^      pyxvattachnewosymbols  bool0$^    $^  $^  goto pyxl0argumentunpackingdone$^  pyxl0argtupleerror$^  pyxraiseargtupleinvalidrelabeltables 0 0 0 pytuplegetsizepyxargs pyxerr0 0000 pyxl0error$^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablefst.relabeltables pyxclineno pyxlineno pyxfilename$^  pyxrefnannyfinishcontext$^  return null$^  pyxl0argumentunpackingdone$^  if unlikelypyxargtypetestpyobject pyxvoldisymbols pyxptype0pywrapfstsymboltable 0 oldisymbols 0 pyxerr0 0000 pyxl0error$^  if unlikelypyxargtypetestpyobject pyxvnewisymbols pyxptype0pywrapfstsymboltable 0 newisymbols 0 pyxerr0 0000 pyxl0error$^  if unlikelypyxargtypetestpyobject pyxvoldosymbols pyxptype0pywrapfstsymboltable 0 oldosymbols 0 pyxerr0 0000 pyxl0error$^  if unlikelypyxargtypetestpyobject pyxvnewosymbols pyxptype0pywrapfstsymboltable 0 newosymbols 0 pyxerr0 0000 pyxl0error$^  pyxr  pyxpf0pywrapfst00mutablefst00relabeltablesstruct pyxobj0pywrapfstmutablefst pyxvself pyxvoldisymbols pyxvnewisymbols pyxvunknownisymbol pyxvattachnewisymbols pyxvoldosymbols pyxvnewosymbols pyxvunknownosymbol pyxvattachnewosymbols$^$^   pywrapfst.pyx0000$^      self.checkmutatingimethod$^  $^    def relabeltablesself              $^                       symboltable oldisymbolsnone$^                       symboltable newisymbolsnone$^ $^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxr  null$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00mutablefst00relabeltablesstruct pyxobj0pywrapfstmutablefst pyxvself struct pyxobj0pywrapfstsymboltable pyxvoldisymbols struct pyxobj0pywrapfstsymboltable pyxvnewisymbols pyobject pyxvunknownisymbol bool pyxvattachnewisymbols struct pyxobj0pywrapfstsymboltable pyxvoldosymbols struct pyxobj0pywrapfstsymboltable pyxvnewosymbols pyobject pyxvunknownosymbol bool pyxvattachnewosymbols $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  struct pyxoptargs0pywrapfst00mutablefstrelabeltables pyxt0$^  pyxrefnannysetupcontextrelabeltables 0$^$^   pywrapfst.pyx0000$^      see also decode encode project relabelpairs.$^      $^      self.relabeltablesoldisymbols newisymbols              $^                           unknownisymbol attachnewisymbols$^                           oldosymbols newosymbols$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s relabeltables$^    pyxerr0 0000 pyxl0error$^  $^$^   pywrapfst.pyx0000$^                           unknownisymbol attachnewisymbols$^                           oldosymbols newosymbols$^                           unknownosymbol attachnewosymbols              $^      return self$^  $^ $^  pyxt0.pyxn  0$^  pyxt0.oldisymbols  pyxvoldisymbols$^  pyxt0.newisymbols  pyxvnewisymbols$^  pyxt0.unknownisymbol  pyxvunknownisymbol$^  pyxt0.attachnewisymbols  pyxvattachnewisymbols$^  pyxt0.oldosymbols  pyxvoldosymbols$^  pyxt0.newosymbols  pyxvnewosymbols$^  pyxt0.unknownosymbol  pyxvunknownosymbol$^  pyxt0.attachnewosymbols  pyxvattachnewosymbols$^  struct pyxvtabstruct0pywrapfstmutablefst pyxvselfpyxbase.pyxvtabrelabeltablespyxvself pyxt0 if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^                           oldosymbols newosymbols$^                           unknownosymbol attachnewosymbols$^      return self              $^  $^    cdef void reservearcsself int00 state sizet n except $^ $^  pyxxdecrefpyxr$^  pyxincrefpyobject pyxvself$^  pyxr  pyobject pyxvself$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      self.checkmutatingimethod$^  $^    def relabeltablesself              $^                       symboltable oldisymbolsnone$^                       symboltable newisymbolsnone$^ $^$^   function exit code $^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablefst.relabeltables pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return self$^  $^    cdef void reservearcsself int00 state sizet n except               $^      if not self.mfst.get.reservearcsstate n$^        raise fstindexerrorstate index out of range$^ $^$^static void pyxf0pywrapfst00mutablefstreservearcsstruct pyxobj0pywrapfstmutablefst pyxvself pyxt00basictypesint00 pyxvstate sizet pyxvn $^  pyxrefnannydeclarations$^  int pyxt0$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextreservearcs 0$^$^   pywrapfst.pyx0000$^  $^    cdef void reservearcsself int00 state sizet n except $^      if not self.mfst.get.reservearcsstate n              $^        raise fstindexerrorstate index out of range$^      self.checkmutatingimethod$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s mfst$^    pyxerr0 0000 pyxl0error$^  $^  pyxt0  pyxvselfmfst.getreservearcspyxvstate pyxvn  0  0$^  if pyxt0 $^$^     pywrapfst.pyx0000$^    cdef void reservearcsself int00 state sizet n except $^      if not self.mfst.get.reservearcsstate n$^        raise fstindexerrorstate index out of range              $^      self.checkmutatingimethod$^  $^ $^    pyxt0  pyxgetmoduleglobalnamepyxnsfstindexerror if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  pyxpyobjectcallpyxt0 pyxtuple00 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxraisepyxt0 0 0 0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxerr0 0000 pyxl0error$^$^     pywrapfst.pyx0000$^  $^    cdef void reservearcsself int00 state sizet n except $^      if not self.mfst.get.reservearcsstate n              $^        raise fstindexerrorstate index out of range$^      self.checkmutatingimethod$^ $^  $^$^   pywrapfst.pyx0000$^      if not self.mfst.get.reservearcsstate n$^        raise fstindexerrorstate index out of range$^      self.checkmutatingimethod              $^  $^    def reservearcsself int00 state sizet n$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s checkmutatingimethod$^    pyxerr0 0000 pyxl0error$^  $^  struct pyxvtabstruct0pywrapfstmutablefst pyxvselfpyxbase.pyxvtabcheckmutatingimethodpyxvself if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^      return self$^  $^    cdef void reservearcsself int00 state sizet n except               $^      if not self.mfst.get.reservearcsstate n$^        raise fstindexerrorstate index out of range$^ $^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.mutablefst.reservearcs pyxclineno pyxlineno pyxfilename$^  pyxl0$^  pyxrefnannyfinishcontext$^$^$^ pywrapfst.pyx0000$^      self.checkmutatingimethod$^  $^    def reservearcsself int00 state sizet n              $^      $^      reservearcsself state n$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00mutablefst00reservearcspyobject pyxvself pyobject pyxargs pyobject pyxkwds proto$^static char pyxdoc0pywrapfst00mutablefst00reservearcs  n    reservearcsself state nnn    reserve n arcs at a particular state best effort.nn    argsn      state the integer index of a state.n      n the number of arcs to reserve.nn    returnsn      self.nn    raisesn      fstindexerror state index out of range.nn    see also reservestates.n    $^static pyobject pyxpw0pywrapfst00mutablefst00reservearcspyobject pyxvself pyobject pyxargs pyobject pyxkwds $^  pyxt00basictypesint00 pyxvstate$^  sizet pyxvn$^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextreservearcs wrapper 0$^  $^    static pyobject pyxpyargnames  pyxnsstatepyxnsn0$^    pyobject values0  00$^    if unlikelypyxkwds $^      pyssizet kwargs$^      const pyssizet posargs  pytuplegetsizepyxargs$^      switch posargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 break$^        default goto pyxl0argtupleerror$^      $^      kwargs  pydictsizepyxkwds$^      switch posargs $^        case  0$^        if likelyvalues0  pydictgetitempyxkwds pyxnsstate  0 kwargs$^        else goto pyxl0argtupleerror$^        cythonfallthrough$^        case  0$^        if likelyvalues0  pydictgetitempyxkwds pyxnsn  0 kwargs$^        else $^          pyxraiseargtupleinvalidreservearcs 0 0 0 0 pyxerr0 0000 pyxl0error$^        $^      $^      if unlikelykwargs  0 $^        if unlikelypyxparseoptionalkeywordspyxkwds pyxpyargnames 0 values posargs reservearcs  0 pyxerr0 0000 pyxl0error$^      $^     else if pytuplegetsizepyxargs  0 $^      goto pyxl0argtupleerror$^     else $^      values0  pytuplegetitempyxargs 0$^      values0  pytuplegetitempyxargs 0$^    $^    pyxvstate  pyxpyintasint00tvalues0 if unlikelypyxvstate  int00t0  pyerroccurred pyxerr0 0000 pyxl0error$^    pyxvn  pyxpyintassizetvalues0 if unlikelypyxvn  sizet0  pyerroccurred pyxerr0 0000 pyxl0error$^  $^  goto pyxl0argumentunpackingdone$^  pyxl0argtupleerror$^  pyxraiseargtupleinvalidreservearcs 0 0 0 pytuplegetsizepyxargs pyxerr0 0000 pyxl0error$^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablefst.reservearcs pyxclineno pyxlineno pyxfilename$^  pyxrefnannyfinishcontext$^  return null$^  pyxl0argumentunpackingdone$^  pyxr  pyxpf0pywrapfst00mutablefst00reservearcsstruct pyxobj0pywrapfstmutablefst pyxvself pyxvstate pyxvn$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00mutablefst00reservearcsstruct pyxobj0pywrapfstmutablefst pyxvself pyxt00basictypesint00 pyxvstate sizet pyxvn $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextreservearcs 0$^$^   pywrapfst.pyx0000$^      see also reservestates.$^      $^      self.reservearcsstate n              $^      return self$^  $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s reservearcs$^    pyxerr0 0000 pyxl0error$^  $^  struct pyxvtabstruct0pywrapfstmutablefst pyxvselfpyxbase.pyxvtabreservearcspyxvself pyxvstate pyxvn if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^      $^      self.reservearcsstate n$^      return self              $^  $^    cdef void reservestatesself int00 n except $^ $^  pyxxdecrefpyxr$^  pyxincrefpyobject pyxvself$^  pyxr  pyobject pyxvself$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      self.checkmutatingimethod$^  $^    def reservearcsself int00 state sizet n              $^      $^      reservearcsself state n$^ $^$^   function exit code $^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablefst.reservearcs pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return self$^  $^    cdef void reservestatesself int00 n except               $^      self.mfst.get.reservestatesn$^      self.checkmutatingimethod$^ $^$^static void pyxf0pywrapfst00mutablefstreservestatesstruct pyxobj0pywrapfstmutablefst pyxvself pyxt00basictypesint00 pyxvn $^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextreservestates 0$^$^   pywrapfst.pyx0000$^  $^    cdef void reservestatesself int00 n except $^      self.mfst.get.reservestatesn              $^      self.checkmutatingimethod$^  $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s mfst$^    pyxerr0 0000 pyxl0error$^  $^  pyxvselfmfst.getreservestatespyxvn$^$^   pywrapfst.pyx0000$^    cdef void reservestatesself int00 n except $^      self.mfst.get.reservestatesn$^      self.checkmutatingimethod              $^  $^    def reservestatesself int00 n$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s checkmutatingimethod$^    pyxerr0 0000 pyxl0error$^  $^  struct pyxvtabstruct0pywrapfstmutablefst pyxvselfpyxbase.pyxvtabcheckmutatingimethodpyxvself if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^      return self$^  $^    cdef void reservestatesself int00 n except               $^      self.mfst.get.reservestatesn$^      self.checkmutatingimethod$^ $^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablefst.reservestates pyxclineno pyxlineno pyxfilename$^  pyxl0$^  pyxrefnannyfinishcontext$^$^$^ pywrapfst.pyx0000$^      self.checkmutatingimethod$^  $^    def reservestatesself int00 n              $^      $^      reservestatesself n$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00mutablefst00reservestatespyobject pyxvself pyobject pyxargn proto$^static char pyxdoc0pywrapfst00mutablefst00reservestates  n    reservestatesself nnn    reserve n states best effort.nn    argsn      n the number of states to reserve.nn    returnsn      self.nn    see also reservearcs.n    $^static pyobject pyxpw0pywrapfst00mutablefst00reservestatespyobject pyxvself pyobject pyxargn $^  pyxt00basictypesint00 pyxvn$^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextreservestates wrapper 0$^  assertpyxargn $^    pyxvn  pyxpyintasint00tpyxargn if unlikelypyxvn  int00t0  pyerroccurred pyxerr0 0000 pyxl0error$^  $^  goto pyxl0argumentunpackingdone$^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablefst.reservestates pyxclineno pyxlineno pyxfilename$^  pyxrefnannyfinishcontext$^  return null$^  pyxl0argumentunpackingdone$^  pyxr  pyxpf0pywrapfst00mutablefst00reservestatesstruct pyxobj0pywrapfstmutablefst pyxvself pyxt00basictypesint00pyxvn$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00mutablefst00reservestatesstruct pyxobj0pywrapfstmutablefst pyxvself pyxt00basictypesint00 pyxvn $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextreservestates 0$^$^   pywrapfst.pyx0000$^      see also reservearcs.$^      $^      self.reservestatesn              $^      return self$^  $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s reservestates$^    pyxerr0 0000 pyxl0error$^  $^  struct pyxvtabstruct0pywrapfstmutablefst pyxvselfpyxbase.pyxvtabreservestatespyxvself pyxvn if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^      $^      self.reservestatesn$^      return self              $^  $^    cdef void reweightself potentials bool tofinalfalse except $^ $^  pyxxdecrefpyxr$^  pyxincrefpyobject pyxvself$^  pyxr  pyobject pyxvself$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      self.checkmutatingimethod$^  $^    def reservestatesself int00 n              $^      $^      reservestatesself n$^ $^$^   function exit code $^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablefst.reservestates pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return self$^  $^    cdef void reweightself potentials bool tofinalfalse except               $^      cdef uniqueptrvectorfst.weightclass potentials$^      potentials.resetnew vectorfst.weightclass$^ $^$^static void pyxf0pywrapfst00mutablefstreweightstruct pyxobj0pywrapfstmutablefst pyxvself pyobject pyxvpotentials struct pyxoptargs0pywrapfst00mutablefstreweight pyxoptionalargs $^  bool pyxvtofinal  bool0$^  stduniqueptrstdvectorfstscriptweightclass   pyxvpotentials$^  cythonunused stdstring pyxvweighttype$^  pyobject pyxvweight  null$^  pyxrefnannydeclarations$^  stdvectorfstscriptweightclass  pyxt0$^  pyobject pyxt0  null$^  pyssizet pyxt0$^  pyobject pyxt0pyobject $^  pyobject pyxt0  null$^  fstscriptweightclass pyxt0$^  pyxrefnannysetupcontextreweight 0$^  if pyxoptionalargs $^    if pyxoptionalargspyxn  0 $^      pyxvtofinal  pyxoptionalargstofinal$^    $^  $^$^   pywrapfst.pyx0000$^    cdef void reweightself potentials bool tofinalfalse except $^      cdef uniqueptrvectorfst.weightclass potentials$^      potentials.resetnew vectorfst.weightclass              $^      cdef string weighttype  self.weighttype$^      for weight in potentials$^ $^  try $^    pyxt0  new stdvectorfstscriptweightclass $^   catch... $^    pyxcppexn0pyerr$^    pyxerr0 0000 pyxl0error$^  $^  pyxvpotentials.resetpyxt0$^$^   pywrapfst.pyx0000$^      cdef uniqueptrvectorfst.weightclass potentials$^      potentials.resetnew vectorfst.weightclass$^      cdef string weighttype  self.weighttype              $^      for weight in potentials$^          potentials.get.pushbackgetweightclassoroneself.weighttype$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s weighttype$^    pyxerr0 0000 pyxl0error$^  $^  pyxvweighttype  struct pyxvtabstruct0pywrapfstmutablefst pyxvselfpyxbase.pyxvtabpyxbase.weighttypestruct pyxobj0pywrapfstfst pyxvself 0$^$^   pywrapfst.pyx0000$^      potentials.resetnew vectorfst.weightclass$^      cdef string weighttype  self.weighttype$^      for weight in potentials              $^          potentials.get.pushbackgetweightclassoroneself.weighttype$^                                                              weight$^ $^  if likelypylistcheckexactpyxvpotentials  pytuplecheckexactpyxvpotentials $^    pyxt0  pyxvpotentials pyxincrefpyxt0 pyxt0  0$^    pyxt0  null$^   else $^    pyxt0  0 pyxt0  pyobjectgetiterpyxvpotentials if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  pytypepyxt0tpiternext if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  $^  for  $^    if likelypyxt0 $^      if likelypylistcheckexactpyxt0 $^        if pyxt0  pylistgetsizepyxt0 break$^        if cythonassumesafemacros  cythonavoidborrowedrefs$^        pyxt0  pylistgetitempyxt0 pyxt0 pyxincrefpyxt0 pyxt0 if unlikely0  0 pyxerr0 0000 pyxl0error$^        else$^        pyxt0  pysequenceitempyxt0 pyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxgotrefpyxt0$^        endif$^       else $^        if pyxt0  pytuplegetsizepyxt0 break$^        if cythonassumesafemacros  cythonavoidborrowedrefs$^        pyxt0  pytuplegetitempyxt0 pyxt0 pyxincrefpyxt0 pyxt0 if unlikely0  0 pyxerr0 0000 pyxl0error$^        else$^        pyxt0  pysequenceitempyxt0 pyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxgotrefpyxt0$^        endif$^      $^     else $^      pyxt0  pyxt0pyxt0$^      if unlikelypyxt0 $^        pyobject exctype  pyerroccurred$^        if exctype $^          if likelypyxpyerrgivenexceptionmatchesexctype pyexcstopiteration pyerrclear$^          else pyxerr0 0000 pyxl0error$^        $^        break$^      $^      pyxgotrefpyxt0$^    $^    pyxxdecrefsetpyxvweight pyxt0$^    pyxt0  0$^$^     pywrapfst.pyx0000$^      cdef string weighttype  self.weighttype$^      for weight in potentials$^          potentials.get.pushbackgetweightclassoroneself.weighttype              $^                                                              weight$^      fst.reweightself.mfst.get derefpotentials$^ $^    if unlikelypyobject pyxvself  pynone $^      pyerrformatpyexcattributeerror nonetype object has no attribute .00s weighttype$^      pyxerr0 0000 pyxl0error$^    $^$^     pywrapfst.pyx0000$^      for weight in potentials$^          potentials.get.pushbackgetweightclassoroneself.weighttype$^                                                              weight              $^      fst.reweightself.mfst.get derefpotentials$^                   fst.getreweighttypetofinal$^ $^    pyxt0  pyxf0pywrapfstgetweightclassoronestruct pyxvtabstruct0pywrapfstmutablefst pyxvselfpyxbase.pyxvtabpyxbase.weighttypestruct pyxobj0pywrapfstfst pyxvself 0 pyxvweight if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^     pywrapfst.pyx0000$^      cdef string weighttype  self.weighttype$^      for weight in potentials$^          potentials.get.pushbackgetweightclassoroneself.weighttype              $^                                                              weight$^      fst.reweightself.mfst.get derefpotentials$^ $^    try $^      pyxvpotentials.getpushbackpyxt0$^     catch... $^      pyxcppexn0pyerr$^      pyxerr0 0000 pyxl0error$^    $^$^     pywrapfst.pyx0000$^      potentials.resetnew vectorfst.weightclass$^      cdef string weighttype  self.weighttype$^      for weight in potentials              $^          potentials.get.pushbackgetweightclassoroneself.weighttype$^                                                              weight$^ $^  $^  pyxdecrefpyxt0 pyxt0  0$^$^   pywrapfst.pyx0000$^          potentials.get.pushbackgetweightclassoroneself.weighttype$^                                                              weight$^      fst.reweightself.mfst.get derefpotentials              $^                   fst.getreweighttypetofinal$^      self.checkmutatingimethod$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s mfst$^    pyxerr0 0000 pyxl0error$^  $^$^   pywrapfst.pyx0000$^                                                              weight$^      fst.reweightself.mfst.get derefpotentials$^                   fst.getreweighttypetofinal              $^      self.checkmutatingimethod$^  $^ $^  fstscriptreweightpyxvselfmfst.get pyxvpotentials fstscriptgetreweighttypepyxvtofinal$^$^   pywrapfst.pyx0000$^      fst.reweightself.mfst.get derefpotentials$^                   fst.getreweighttypetofinal$^      self.checkmutatingimethod              $^  $^    def reweightself potentials bool tofinalfalse$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s checkmutatingimethod$^    pyxerr0 0000 pyxl0error$^  $^  struct pyxvtabstruct0pywrapfstmutablefst pyxvselfpyxbase.pyxvtabcheckmutatingimethodpyxvself if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^      return self$^  $^    cdef void reweightself potentials bool tofinalfalse except               $^      cdef uniqueptrvectorfst.weightclass potentials$^      potentials.resetnew vectorfst.weightclass$^ $^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.mutablefst.reweight pyxclineno pyxlineno pyxfilename$^  pyxl0$^  pyxxdecrefpyxvweight$^  pyxrefnannyfinishcontext$^$^$^ pywrapfst.pyx0000$^      self.checkmutatingimethod$^  $^    def reweightself potentials bool tofinalfalse              $^      $^      reweightself potentials tofinalfalse$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00mutablefst00reweightpyobject pyxvself pyobject pyxargs pyobject pyxkwds proto$^static char pyxdoc0pywrapfst00mutablefst00reweight  n    reweightself potentials tofinalfalsenn    reweights an fst using an iterable of potentials.nn    this operation destructively reweights an fst according to the potentialsn    and in the direction specified by the user. an arc of weight w with ann    origin state of potential p and destination state of potential q isn    reweighted by p0 otimes w otimes q when reweighting towards then    initial state and by p otimes w otimes q0 when reweighting towardsn    the final states. the weights must be left distributive when reweightingn    towards the initial state and right distributive when reweighting towardsn    the final states e.g. tropicalweight and logweight.nn    argsn      potentials an iterable of weight or weight strings.n      tofinal push towards final statesnn    returnsn      self.n    $^static pyobject pyxpw0pywrapfst00mutablefst00reweightpyobject pyxvself pyobject pyxargs pyobject pyxkwds $^  pyobject pyxvpotentials  0$^  bool pyxvtofinal$^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextreweight wrapper 0$^  $^    static pyobject pyxpyargnames  pyxnspotentialspyxnstofinal0$^    pyobject values0  00$^    if unlikelypyxkwds $^      pyssizet kwargs$^      const pyssizet posargs  pytuplegetsizepyxargs$^      switch posargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 break$^        default goto pyxl0argtupleerror$^      $^      kwargs  pydictsizepyxkwds$^      switch posargs $^        case  0$^        if likelyvalues0  pydictgetitempyxkwds pyxnspotentials  0 kwargs$^        else goto pyxl0argtupleerror$^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pydictgetitempyxkwds pyxnstofinal$^          if value  values0  value kwargs $^        $^      $^      if unlikelykwargs  0 $^        if unlikelypyxparseoptionalkeywordspyxkwds pyxpyargnames 0 values posargs reweight  0 pyxerr0 0000 pyxl0error$^      $^     else $^      switch pytuplegetsizepyxargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        break$^        default goto pyxl0argtupleerror$^      $^    $^    pyxvpotentials  values0$^    if values0 $^      pyxvtofinal  pyxpyobjectistruevalues0 if unlikelypyxvtofinal  bool0  pyerroccurred pyxerr0 0000 pyxl0error$^     else $^      pyxvtofinal  bool0$^    $^  $^  goto pyxl0argumentunpackingdone$^  pyxl0argtupleerror$^  pyxraiseargtupleinvalidreweight 0 0 0 pytuplegetsizepyxargs pyxerr0 0000 pyxl0error$^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablefst.reweight pyxclineno pyxlineno pyxfilename$^  pyxrefnannyfinishcontext$^  return null$^  pyxl0argumentunpackingdone$^  pyxr  pyxpf0pywrapfst00mutablefst00reweightstruct pyxobj0pywrapfstmutablefst pyxvself pyxvpotentials pyxvtofinal$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00mutablefst00reweightstruct pyxobj0pywrapfstmutablefst pyxvself pyobject pyxvpotentials bool pyxvtofinal $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  struct pyxoptargs0pywrapfst00mutablefstreweight pyxt0$^  pyxrefnannysetupcontextreweight 0$^$^   pywrapfst.pyx0000$^        self.$^      $^      self.reweightpotentials tofinal              $^      return self$^  $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s reweight$^    pyxerr0 0000 pyxl0error$^  $^  pyxt0.pyxn  0$^  pyxt0.tofinal  pyxvtofinal$^  struct pyxvtabstruct0pywrapfstmutablefst pyxvselfpyxbase.pyxvtabreweightpyxvself pyxvpotentials pyxt0 if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^      $^      self.reweightpotentials tofinal$^      return self              $^  $^    cdef void rmepsilonself$^ $^  pyxxdecrefpyxr$^  pyxincrefpyobject pyxvself$^  pyxr  pyobject pyxvself$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      self.checkmutatingimethod$^  $^    def reweightself potentials bool tofinalfalse              $^      $^      reweightself potentials tofinalfalse$^ $^$^   function exit code $^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablefst.reweight pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return self$^  $^    cdef void rmepsilonself              $^                         queuetypebauto$^                         bool connecttrue$^ $^$^static void pyxf0pywrapfst00mutablefstrmepsilonstruct pyxobj0pywrapfstmutablefst pyxvself struct pyxoptargs0pywrapfst00mutablefstrmepsilon pyxoptionalargs $^  pyobject pyxvqueuetype  pyobject pyxnbauto$^$^   pywrapfst.pyx0000$^    cdef void rmepsilonself$^                         queuetypebauto$^                         bool connecttrue              $^                         weightnone$^                         int00 nstatefst.knostateid$^ $^  bool pyxvconnect  bool0$^$^   pywrapfst.pyx0000$^                         queuetypebauto$^                         bool connecttrue$^                         weightnone              $^                         int00 nstatefst.knostateid$^                         float deltafst.kshortestdelta except $^ $^  pyobject pyxvweight  pyobject pynone$^  pyxt00basictypesint00 pyxvnstate  pyxk00$^  float pyxvdelta  pyxk00$^  fstscriptweightclass pyxvwc$^  stduniqueptrfstscriptrmepsilonoptions  pyxvopts$^  pyxrefnannydeclarations$^  fstscriptweightclass pyxt0$^  stdstring pyxt0$^  enum fstqueuetype pyxt0$^  pyxrefnannysetupcontextrmepsilon 0$^  if pyxoptionalargs $^    if pyxoptionalargspyxn  0 $^      pyxvqueuetype  pyxoptionalargsqueuetype$^      if pyxoptionalargspyxn  0 $^        pyxvconnect  pyxoptionalargsconnect$^        if pyxoptionalargspyxn  0 $^          pyxvweight  pyxoptionalargsweight$^          if pyxoptionalargspyxn  0 $^            pyxvnstate  pyxoptionalargsnstate$^            if pyxoptionalargspyxn  0 $^              pyxvdelta  pyxoptionalargsdelta$^            $^          $^        $^      $^    $^  $^$^   pywrapfst.pyx0000$^                         int00 nstatefst.knostateid$^                         float deltafst.kshortestdelta except $^      cdef fst.weightclass wc  getweightclassorzeroself.weighttype              $^                                                         weight$^      cdef uniqueptrfst.rmepsilonoptions opts$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s weighttype$^    pyxerr0 0000 pyxl0error$^  $^$^   pywrapfst.pyx0000$^                         float deltafst.kshortestdelta except $^      cdef fst.weightclass wc  getweightclassorzeroself.weighttype$^                                                         weight              $^      cdef uniqueptrfst.rmepsilonoptions opts$^      opts.resetnew fst.rmepsilonoptionsgetqueuetypetostringqueuetype$^ $^  pyxt0  pyxf0pywrapfstgetweightclassorzerostruct pyxvtabstruct0pywrapfstmutablefst pyxvselfpyxbase.pyxvtabpyxbase.weighttypestruct pyxobj0pywrapfstfst pyxvself 0 pyxvweight if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^  pyxvwc  pyxt0$^$^   pywrapfst.pyx0000$^                                                         weight$^      cdef uniqueptrfst.rmepsilonoptions opts$^      opts.resetnew fst.rmepsilonoptionsgetqueuetypetostringqueuetype              $^                                          connect wc nstate delta$^      fst.rmepsilonself.mfst.get derefopts$^ $^  pyxt0  pyxf0pywrapfsttostringpyxvqueuetype null if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^  pyxt0  pyxf0pywrapfstgetqueuetypepyxt0 if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^      cdef uniqueptrfst.rmepsilonoptions opts$^      opts.resetnew fst.rmepsilonoptionsgetqueuetypetostringqueuetype$^                                          connect wc nstate delta              $^      fst.rmepsilonself.mfst.get derefopts$^      self.checkmutatingimethod$^ $^  pyxvopts.resetnew fstscriptrmepsilonoptionspyxt0 pyxvconnect pyxvwc pyxvnstate pyxvdelta$^$^   pywrapfst.pyx0000$^      opts.resetnew fst.rmepsilonoptionsgetqueuetypetostringqueuetype$^                                          connect wc nstate delta$^      fst.rmepsilonself.mfst.get derefopts              $^      self.checkmutatingimethod$^  $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s mfst$^    pyxerr0 0000 pyxl0error$^  $^  fstscriptrmepsilonpyxvselfmfst.get pyxvopts$^$^   pywrapfst.pyx0000$^                                          connect wc nstate delta$^      fst.rmepsilonself.mfst.get derefopts$^      self.checkmutatingimethod              $^  $^    def rmepsilonself$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s checkmutatingimethod$^    pyxerr0 0000 pyxl0error$^  $^  struct pyxvtabstruct0pywrapfstmutablefst pyxvselfpyxbase.pyxvtabcheckmutatingimethodpyxvself if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^      return self$^  $^    cdef void rmepsilonself              $^                         queuetypebauto$^                         bool connecttrue$^ $^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablefst.rmepsilon pyxclineno pyxlineno pyxfilename$^  pyxl0$^  pyxrefnannyfinishcontext$^$^$^ pywrapfst.pyx0000$^      self.checkmutatingimethod$^  $^    def rmepsilonself              $^                  queuetypebauto$^                  bool connecttrue$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00mutablefst00rmepsilonpyobject pyxvself pyobject pyxargs pyobject pyxkwds proto$^static char pyxdoc0pywrapfst00mutablefst00rmepsilon  n    rmepsilonself queuetypeauto connecttrue weightnonen              nstatenostateid delta0e0nn    removes epsilon transitions.nn    this operation destructively removes epsilon transitions i.e. those wheren    both input and output labels are epsilon from an fst.nn    argsn      queuetype a string matching a known queue type one of auto fifon          lifo shortest state top.n      connect should output be trimmedn      weight a weight or weight string indicating the desired weight thresholdn          below which paths are pruned if omitted no paths are pruned.n      nstate state number threshold.n      delta comparisonquantization delta.nn    returnsn      self.n    $^static pyobject pyxpw0pywrapfst00mutablefst00rmepsilonpyobject pyxvself pyobject pyxargs pyobject pyxkwds $^  pyobject pyxvqueuetype  0$^  bool pyxvconnect$^  pyobject pyxvweight  0$^  pyxt00basictypesint00 pyxvnstate$^  float pyxvdelta$^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextrmepsilon wrapper 0$^  $^    static pyobject pyxpyargnames  pyxnsqueuetypepyxnsconnectpyxnsweightpyxnsnstatepyxnsdelta0$^    pyobject values0  00000$^    values0  pyobject pyxnbauto$^$^     pywrapfst.pyx0000$^                  queuetypebauto$^                  bool connecttrue$^                  weightnone              $^                  int00 nstatefst.knostateid$^                  float deltafst.kshortestdelta$^ $^    values0  pyobject pynone$^    if unlikelypyxkwds $^      pyssizet kwargs$^      const pyssizet posargs  pytuplegetsizepyxargs$^      switch posargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 break$^        default goto pyxl0argtupleerror$^      $^      kwargs  pydictsizepyxkwds$^      switch posargs $^        case  0$^        if kwargs  0 $^          pyobject value  pydictgetitempyxkwds pyxnsqueuetype$^          if value  values0  value kwargs $^        $^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pydictgetitempyxkwds pyxnsconnect$^          if value  values0  value kwargs $^        $^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pydictgetitempyxkwds pyxnsweight$^          if value  values0  value kwargs $^        $^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pydictgetitempyxkwds pyxnsnstate$^          if value  values0  value kwargs $^        $^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pydictgetitempyxkwds pyxnsdelta$^          if value  values0  value kwargs $^        $^      $^      if unlikelykwargs  0 $^        if unlikelypyxparseoptionalkeywordspyxkwds pyxpyargnames 0 values posargs rmepsilon  0 pyxerr0 0000 pyxl0error$^      $^     else $^      switch pytuplegetsizepyxargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 break$^        default goto pyxl0argtupleerror$^      $^    $^    pyxvqueuetype  values0$^    if values0 $^      pyxvconnect  pyxpyobjectistruevalues0 if unlikelypyxvconnect  bool0  pyerroccurred pyxerr0 0000 pyxl0error$^     else $^$^       pywrapfst.pyx0000$^    def rmepsilonself$^                  queuetypebauto$^                  bool connecttrue              $^                  weightnone$^                  int00 nstatefst.knostateid$^ $^      pyxvconnect  bool0$^    $^    pyxvweight  values0$^    if values0 $^      pyxvnstate  pyxpyintasint00tvalues0 if unlikelypyxvnstate  int00t0  pyerroccurred pyxerr0 0000 pyxl0error$^     else $^      pyxvnstate  pyxk00$^    $^    if values0 $^      pyxvdelta  pyxpyfloatasfloatvalues0 if unlikelypyxvdelta  float0  pyerroccurred pyxerr0 0000 pyxl0error$^     else $^      pyxvdelta  pyxk00$^    $^  $^  goto pyxl0argumentunpackingdone$^  pyxl0argtupleerror$^  pyxraiseargtupleinvalidrmepsilon 0 0 0 pytuplegetsizepyxargs pyxerr0 0000 pyxl0error$^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablefst.rmepsilon pyxclineno pyxlineno pyxfilename$^  pyxrefnannyfinishcontext$^  return null$^  pyxl0argumentunpackingdone$^  pyxr  pyxpf0pywrapfst00mutablefst00rmepsilonstruct pyxobj0pywrapfstmutablefst pyxvself pyxvqueuetype pyxvconnect pyxvweight pyxvnstate pyxvdelta$^$^   pywrapfst.pyx0000$^      self.checkmutatingimethod$^  $^    def rmepsilonself              $^                  queuetypebauto$^                  bool connecttrue$^ $^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00mutablefst00rmepsilonstruct pyxobj0pywrapfstmutablefst pyxvself pyobject pyxvqueuetype bool pyxvconnect pyobject pyxvweight pyxt00basictypesint00 pyxvnstate float pyxvdelta $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  struct pyxoptargs0pywrapfst00mutablefstrmepsilon pyxt0$^  pyxrefnannysetupcontextrmepsilon 0$^$^   pywrapfst.pyx0000$^        self.$^      $^      self.rmepsilonqueuetype connect weight nstate delta              $^      return self$^  $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s rmepsilon$^    pyxerr0 0000 pyxl0error$^  $^  pyxt0.pyxn  0$^  pyxt0.queuetype  pyxvqueuetype$^  pyxt0.connect  pyxvconnect$^  pyxt0.weight  pyxvweight$^  pyxt0.nstate  pyxvnstate$^  pyxt0.delta  pyxvdelta$^  struct pyxvtabstruct0pywrapfstmutablefst pyxvselfpyxbase.pyxvtabrmepsilonpyxvself pyxt0 if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^      $^      self.rmepsilonqueuetype connect weight nstate delta$^      return self              $^  $^    cdef void setfinalself int00 state weightnone except $^ $^  pyxxdecrefpyxr$^  pyxincrefpyobject pyxvself$^  pyxr  pyobject pyxvself$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      self.checkmutatingimethod$^  $^    def rmepsilonself              $^                  queuetypebauto$^                  bool connecttrue$^ $^$^   function exit code $^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablefst.rmepsilon pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return self$^  $^    cdef void setfinalself int00 state weightnone except               $^      if not self.mfst.get.validstateidstate$^        raise fstindexerrorstate index out of range$^ $^$^static void pyxf0pywrapfst00mutablefstsetfinalstruct pyxobj0pywrapfstmutablefst pyxvself pyxt00basictypesint00 pyxvstate struct pyxoptargs0pywrapfst00mutablefstsetfinal pyxoptionalargs $^  pyobject pyxvweight  pyobject pynone$^  fstscriptweightclass pyxvwc$^  pyxrefnannydeclarations$^  int pyxt0$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  fstscriptweightclass pyxt0$^  pyxrefnannysetupcontextsetfinal 0$^  if pyxoptionalargs $^    if pyxoptionalargspyxn  0 $^      pyxvweight  pyxoptionalargsweight$^    $^  $^$^   pywrapfst.pyx0000$^  $^    cdef void setfinalself int00 state weightnone except $^      if not self.mfst.get.validstateidstate              $^        raise fstindexerrorstate index out of range$^      cdef fst.weightclass wc  getweightclassoroneself.weighttype$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s mfst$^    pyxerr0 0000 pyxl0error$^  $^  pyxt0  pyxvselfmfst.getvalidstateidpyxvstate  0  0$^  if pyxt0 $^$^     pywrapfst.pyx0000$^    cdef void setfinalself int00 state weightnone except $^      if not self.mfst.get.validstateidstate$^        raise fstindexerrorstate index out of range              $^      cdef fst.weightclass wc  getweightclassoroneself.weighttype$^                                                        weight$^ $^    pyxt0  pyxgetmoduleglobalnamepyxnsfstindexerror if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  pyxpyobjectcallpyxt0 pyxtuple00 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxraisepyxt0 0 0 0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxerr0 0000 pyxl0error$^$^     pywrapfst.pyx0000$^  $^    cdef void setfinalself int00 state weightnone except $^      if not self.mfst.get.validstateidstate              $^        raise fstindexerrorstate index out of range$^      cdef fst.weightclass wc  getweightclassoroneself.weighttype$^ $^  $^$^   pywrapfst.pyx0000$^      if not self.mfst.get.validstateidstate$^        raise fstindexerrorstate index out of range$^      cdef fst.weightclass wc  getweightclassoroneself.weighttype              $^                                                        weight$^      if not self.mfst.get.setfinalstate wc$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s weighttype$^    pyxerr0 0000 pyxl0error$^  $^$^   pywrapfst.pyx0000$^        raise fstindexerrorstate index out of range$^      cdef fst.weightclass wc  getweightclassoroneself.weighttype$^                                                        weight              $^      if not self.mfst.get.setfinalstate wc$^        raise fstoperrorincompatible or invalid weight$^ $^  pyxt0  pyxf0pywrapfstgetweightclassoronestruct pyxvtabstruct0pywrapfstmutablefst pyxvselfpyxbase.pyxvtabpyxbase.weighttypestruct pyxobj0pywrapfstfst pyxvself 0 pyxvweight if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^  pyxvwc  pyxt0$^$^   pywrapfst.pyx0000$^      cdef fst.weightclass wc  getweightclassoroneself.weighttype$^                                                        weight$^      if not self.mfst.get.setfinalstate wc              $^        raise fstoperrorincompatible or invalid weight$^      self.checkmutatingimethod$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s mfst$^    pyxerr0 0000 pyxl0error$^  $^  pyxt0  pyxvselfmfst.getsetfinalpyxvstate pyxvwc  0  0$^  if pyxt0 $^$^     pywrapfst.pyx0000$^                                                        weight$^      if not self.mfst.get.setfinalstate wc$^        raise fstoperrorincompatible or invalid weight              $^      self.checkmutatingimethod$^  $^ $^    pyxt0  pyxgetmoduleglobalnamepyxnsfstoperror if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  pyxpyobjectcallpyxt0 pyxtuple00 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxraisepyxt0 0 0 0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxerr0 0000 pyxl0error$^$^     pywrapfst.pyx0000$^      cdef fst.weightclass wc  getweightclassoroneself.weighttype$^                                                        weight$^      if not self.mfst.get.setfinalstate wc              $^        raise fstoperrorincompatible or invalid weight$^      self.checkmutatingimethod$^ $^  $^$^   pywrapfst.pyx0000$^      if not self.mfst.get.setfinalstate wc$^        raise fstoperrorincompatible or invalid weight$^      self.checkmutatingimethod              $^  $^    def setfinalself int00 state weightnone$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s checkmutatingimethod$^    pyxerr0 0000 pyxl0error$^  $^  struct pyxvtabstruct0pywrapfstmutablefst pyxvselfpyxbase.pyxvtabcheckmutatingimethodpyxvself if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^      return self$^  $^    cdef void setfinalself int00 state weightnone except               $^      if not self.mfst.get.validstateidstate$^        raise fstindexerrorstate index out of range$^ $^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.mutablefst.setfinal pyxclineno pyxlineno pyxfilename$^  pyxl0$^  pyxrefnannyfinishcontext$^$^$^ pywrapfst.pyx0000$^      self.checkmutatingimethod$^  $^    def setfinalself int00 state weightnone              $^      $^      setfinalself state weight$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00mutablefst00setfinalpyobject pyxvself pyobject pyxargs pyobject pyxkwds proto$^static char pyxdoc0pywrapfst00mutablefst00setfinal  n    setfinalself state weightnn    sets the final weight for a state.nn    argsn      state the integer index of a state.n      weight a weight or weight string indicating the desired final weight ifn          omitted it is set to semiring one.nn    returnsn      self.nn    raisesn      fstindexerror state index out of range.n      fstoperror incompatible or invalid weight.nn    see also setstart.n    $^static pyobject pyxpw0pywrapfst00mutablefst00setfinalpyobject pyxvself pyobject pyxargs pyobject pyxkwds $^  pyxt00basictypesint00 pyxvstate$^  pyobject pyxvweight  0$^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextsetfinal wrapper 0$^  $^    static pyobject pyxpyargnames  pyxnsstatepyxnsweight0$^    pyobject values0  00$^    values0  pyobject pynone$^    if unlikelypyxkwds $^      pyssizet kwargs$^      const pyssizet posargs  pytuplegetsizepyxargs$^      switch posargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 break$^        default goto pyxl0argtupleerror$^      $^      kwargs  pydictsizepyxkwds$^      switch posargs $^        case  0$^        if likelyvalues0  pydictgetitempyxkwds pyxnsstate  0 kwargs$^        else goto pyxl0argtupleerror$^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pydictgetitempyxkwds pyxnsweight$^          if value  values0  value kwargs $^        $^      $^      if unlikelykwargs  0 $^        if unlikelypyxparseoptionalkeywordspyxkwds pyxpyargnames 0 values posargs setfinal  0 pyxerr0 0000 pyxl0error$^      $^     else $^      switch pytuplegetsizepyxargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        break$^        default goto pyxl0argtupleerror$^      $^    $^    pyxvstate  pyxpyintasint00tvalues0 if unlikelypyxvstate  int00t0  pyerroccurred pyxerr0 0000 pyxl0error$^    pyxvweight  values0$^  $^  goto pyxl0argumentunpackingdone$^  pyxl0argtupleerror$^  pyxraiseargtupleinvalidsetfinal 0 0 0 pytuplegetsizepyxargs pyxerr0 0000 pyxl0error$^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablefst.setfinal pyxclineno pyxlineno pyxfilename$^  pyxrefnannyfinishcontext$^  return null$^  pyxl0argumentunpackingdone$^  pyxr  pyxpf0pywrapfst00mutablefst00setfinalstruct pyxobj0pywrapfstmutablefst pyxvself pyxvstate pyxvweight$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00mutablefst00setfinalstruct pyxobj0pywrapfstmutablefst pyxvself pyxt00basictypesint00 pyxvstate pyobject pyxvweight $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  struct pyxoptargs0pywrapfst00mutablefstsetfinal pyxt0$^  pyxrefnannysetupcontextsetfinal 0$^$^   pywrapfst.pyx0000$^      see also setstart.$^      $^      self.setfinalstate weight              $^      return self$^  $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s setfinal$^    pyxerr0 0000 pyxl0error$^  $^  pyxt0.pyxn  0$^  pyxt0.weight  pyxvweight$^  struct pyxvtabstruct0pywrapfstmutablefst pyxvselfpyxbase.pyxvtabsetfinalpyxvself pyxvstate pyxt0 if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^      $^      self.setfinalstate weight$^      return self              $^  $^    cdef void setinputsymbolsself symboltable syms except $^ $^  pyxxdecrefpyxr$^  pyxincrefpyobject pyxvself$^  pyxr  pyobject pyxvself$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      self.checkmutatingimethod$^  $^    def setfinalself int00 state weightnone              $^      $^      setfinalself state weight$^ $^$^   function exit code $^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablefst.setfinal pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return self$^  $^    cdef void setinputsymbolsself symboltable syms except               $^      if syms is none$^        self.mfst.get.setinputsymbolsnull$^ $^$^static void pyxf0pywrapfst00mutablefstsetinputsymbolsstruct pyxobj0pywrapfstmutablefst pyxvself struct pyxobj0pywrapfstsymboltable pyxvsyms $^  pyxrefnannydeclarations$^  int pyxt0$^  int pyxt0$^  pyxrefnannysetupcontextsetinputsymbols 0$^$^   pywrapfst.pyx0000$^  $^    cdef void setinputsymbolsself symboltable syms except $^      if syms is none              $^        self.mfst.get.setinputsymbolsnull$^        return$^ $^  pyxt0  pyobject pyxvsyms  pynone$^  pyxt0  pyxt0  0$^  if pyxt0 $^$^     pywrapfst.pyx0000$^    cdef void setinputsymbolsself symboltable syms except $^      if syms is none$^        self.mfst.get.setinputsymbolsnull              $^        return$^      self.mfst.get.setinputsymbolssyms.table$^ $^    if unlikelypyobject pyxvself  pynone $^      pyerrformatpyexcattributeerror nonetype object has no attribute .00s mfst$^      pyxerr0 0000 pyxl0error$^    $^    pyxvselfmfst.getsetinputsymbolsnull$^$^     pywrapfst.pyx0000$^      if syms is none$^        self.mfst.get.setinputsymbolsnull$^        return              $^      self.mfst.get.setinputsymbolssyms.table$^      self.checkmutatingimethod$^ $^    goto pyxl0$^$^     pywrapfst.pyx0000$^  $^    cdef void setinputsymbolsself symboltable syms except $^      if syms is none              $^        self.mfst.get.setinputsymbolsnull$^        return$^ $^  $^$^   pywrapfst.pyx0000$^        self.mfst.get.setinputsymbolsnull$^        return$^      self.mfst.get.setinputsymbolssyms.table              $^      self.checkmutatingimethod$^  $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s mfst$^    pyxerr0 0000 pyxl0error$^  $^  if unlikelypyobject pyxvsyms  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s table$^    pyxerr0 0000 pyxl0error$^  $^  pyxvselfmfst.getsetinputsymbolspyxvsymstable$^$^   pywrapfst.pyx0000$^        return$^      self.mfst.get.setinputsymbolssyms.table$^      self.checkmutatingimethod              $^  $^    def setinputsymbolsself symboltable syms$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s checkmutatingimethod$^    pyxerr0 0000 pyxl0error$^  $^  struct pyxvtabstruct0pywrapfstmutablefst pyxvselfpyxbase.pyxvtabcheckmutatingimethodpyxvself if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^      return self$^  $^    cdef void setinputsymbolsself symboltable syms except               $^      if syms is none$^        self.mfst.get.setinputsymbolsnull$^ $^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablefst.setinputsymbols pyxclineno pyxlineno pyxfilename$^  pyxl0$^  pyxrefnannyfinishcontext$^$^$^ pywrapfst.pyx0000$^      self.checkmutatingimethod$^  $^    def setinputsymbolsself symboltable syms              $^      $^      setinputsymbolsself syms$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00mutablefst00setinputsymbolspyobject pyxvself pyobject pyxvsyms proto$^static char pyxdoc0pywrapfst00mutablefst00setinputsymbols  n    setinputsymbolsself symsnn    sets the input symbol table.nn    passing none as a value will delete the input symbol table.nn    argsn      syms a symboltable.nn    returnsn      self.nn    see also setoutputsymbols.n    $^static pyobject pyxpw0pywrapfst00mutablefst00setinputsymbolspyobject pyxvself pyobject pyxvsyms $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextsetinputsymbols wrapper 0$^  if unlikelypyxargtypetestpyobject pyxvsyms pyxptype0pywrapfstsymboltable 0 syms 0 pyxerr0 0000 pyxl0error$^  pyxr  pyxpf0pywrapfst00mutablefst00setinputsymbolsstruct pyxobj0pywrapfstmutablefst pyxvself struct pyxobj0pywrapfstsymboltable pyxvsyms$^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxr  null$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00mutablefst00setinputsymbolsstruct pyxobj0pywrapfstmutablefst pyxvself struct pyxobj0pywrapfstsymboltable pyxvsyms $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextsetinputsymbols 0$^$^   pywrapfst.pyx0000$^      see also setoutputsymbols.$^      $^      self.setinputsymbolssyms              $^      return self$^  $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s setinputsymbols$^    pyxerr0 0000 pyxl0error$^  $^  struct pyxvtabstruct0pywrapfstmutablefst pyxvselfpyxbase.pyxvtabsetinputsymbolspyxvself pyxvsyms if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^      $^      self.setinputsymbolssyms$^      return self              $^  $^    cdef void setoutputsymbolsself symboltable syms except $^ $^  pyxxdecrefpyxr$^  pyxincrefpyobject pyxvself$^  pyxr  pyobject pyxvself$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      self.checkmutatingimethod$^  $^    def setinputsymbolsself symboltable syms              $^      $^      setinputsymbolsself syms$^ $^$^   function exit code $^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablefst.setinputsymbols pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return self$^  $^    cdef void setoutputsymbolsself symboltable syms except               $^      if syms is none$^        self.mfst.get.setoutputsymbolsnull$^ $^$^static void pyxf0pywrapfst00mutablefstsetoutputsymbolsstruct pyxobj0pywrapfstmutablefst pyxvself struct pyxobj0pywrapfstsymboltable pyxvsyms $^  pyxrefnannydeclarations$^  int pyxt0$^  int pyxt0$^  pyxrefnannysetupcontextsetoutputsymbols 0$^$^   pywrapfst.pyx0000$^  $^    cdef void setoutputsymbolsself symboltable syms except $^      if syms is none              $^        self.mfst.get.setoutputsymbolsnull$^        return$^ $^  pyxt0  pyobject pyxvsyms  pynone$^  pyxt0  pyxt0  0$^  if pyxt0 $^$^     pywrapfst.pyx0000$^    cdef void setoutputsymbolsself symboltable syms except $^      if syms is none$^        self.mfst.get.setoutputsymbolsnull              $^        return$^      self.mfst.get.setoutputsymbolssyms.table$^ $^    if unlikelypyobject pyxvself  pynone $^      pyerrformatpyexcattributeerror nonetype object has no attribute .00s mfst$^      pyxerr0 0000 pyxl0error$^    $^    pyxvselfmfst.getsetoutputsymbolsnull$^$^     pywrapfst.pyx0000$^      if syms is none$^        self.mfst.get.setoutputsymbolsnull$^        return              $^      self.mfst.get.setoutputsymbolssyms.table$^      self.checkmutatingimethod$^ $^    goto pyxl0$^$^     pywrapfst.pyx0000$^  $^    cdef void setoutputsymbolsself symboltable syms except $^      if syms is none              $^        self.mfst.get.setoutputsymbolsnull$^        return$^ $^  $^$^   pywrapfst.pyx0000$^        self.mfst.get.setoutputsymbolsnull$^        return$^      self.mfst.get.setoutputsymbolssyms.table              $^      self.checkmutatingimethod$^  $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s mfst$^    pyxerr0 0000 pyxl0error$^  $^  if unlikelypyobject pyxvsyms  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s table$^    pyxerr0 0000 pyxl0error$^  $^  pyxvselfmfst.getsetoutputsymbolspyxvsymstable$^$^   pywrapfst.pyx0000$^        return$^      self.mfst.get.setoutputsymbolssyms.table$^      self.checkmutatingimethod              $^  $^    def setoutputsymbolsself symboltable syms$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s checkmutatingimethod$^    pyxerr0 0000 pyxl0error$^  $^  struct pyxvtabstruct0pywrapfstmutablefst pyxvselfpyxbase.pyxvtabcheckmutatingimethodpyxvself if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^      return self$^  $^    cdef void setoutputsymbolsself symboltable syms except               $^      if syms is none$^        self.mfst.get.setoutputsymbolsnull$^ $^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablefst.setoutputsymbols pyxclineno pyxlineno pyxfilename$^  pyxl0$^  pyxrefnannyfinishcontext$^$^$^ pywrapfst.pyx0000$^      self.checkmutatingimethod$^  $^    def setoutputsymbolsself symboltable syms              $^      $^      setoutputsymbolsself syms$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00mutablefst00setoutputsymbolspyobject pyxvself pyobject pyxvsyms proto$^static char pyxdoc0pywrapfst00mutablefst00setoutputsymbols  n    setoutputsymbolsself symsnn    sets the output symbol table.nn    passing none as a value will delete the output symbol table.nn    argsn      syms a symboltable.nn    returnsn      self.nn    see also setinputsymbols.n    $^static pyobject pyxpw0pywrapfst00mutablefst00setoutputsymbolspyobject pyxvself pyobject pyxvsyms $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextsetoutputsymbols wrapper 0$^  if unlikelypyxargtypetestpyobject pyxvsyms pyxptype0pywrapfstsymboltable 0 syms 0 pyxerr0 0000 pyxl0error$^  pyxr  pyxpf0pywrapfst00mutablefst00setoutputsymbolsstruct pyxobj0pywrapfstmutablefst pyxvself struct pyxobj0pywrapfstsymboltable pyxvsyms$^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxr  null$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00mutablefst00setoutputsymbolsstruct pyxobj0pywrapfstmutablefst pyxvself struct pyxobj0pywrapfstsymboltable pyxvsyms $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextsetoutputsymbols 0$^$^   pywrapfst.pyx0000$^      see also setinputsymbols.$^      $^      self.setoutputsymbolssyms              $^      return self$^  $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s setoutputsymbols$^    pyxerr0 0000 pyxl0error$^  $^  struct pyxvtabstruct0pywrapfstmutablefst pyxvselfpyxbase.pyxvtabsetoutputsymbolspyxvself pyxvsyms if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^      $^      self.setoutputsymbolssyms$^      return self              $^  $^    cdef void setpropertiesself uint00 props uint00 mask$^ $^  pyxxdecrefpyxr$^  pyxincrefpyobject pyxvself$^  pyxr  pyobject pyxvself$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      self.checkmutatingimethod$^  $^    def setoutputsymbolsself symboltable syms              $^      $^      setoutputsymbolsself syms$^ $^$^   function exit code $^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablefst.setoutputsymbols pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return self$^  $^    cdef void setpropertiesself uint00 props uint00 mask              $^      self.mfst.get.setpropertiesprops mask$^  $^ $^$^static void pyxf0pywrapfst00mutablefstsetpropertiesstruct pyxobj0pywrapfstmutablefst pyxvself pyxt00basictypesuint00 pyxvprops pyxt00basictypesuint00 pyxvmask $^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextsetproperties 0$^$^   pywrapfst.pyx0000$^  $^    cdef void setpropertiesself uint00 props uint00 mask$^      self.mfst.get.setpropertiesprops mask              $^  $^    def setpropertiesself uint00 props uint00 mask$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s mfst$^    pyxerr0 0000 pyxl0error$^  $^  pyxvselfmfst.getsetpropertiespyxvprops pyxvmask$^$^   pywrapfst.pyx0000$^      return self$^  $^    cdef void setpropertiesself uint00 props uint00 mask              $^      self.mfst.get.setpropertiesprops mask$^  $^ $^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxwriteunraisablepywrapfst.mutablefst.setproperties pyxclineno pyxlineno pyxfilename 0 0$^  pyxl0$^  pyxrefnannyfinishcontext$^$^$^ pywrapfst.pyx0000$^      self.mfst.get.setpropertiesprops mask$^  $^    def setpropertiesself uint00 props uint00 mask              $^      $^      setpropertiesself props mask$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00mutablefst00setpropertiespyobject pyxvself pyobject pyxargs pyobject pyxkwds proto$^static char pyxdoc0pywrapfst00mutablefst00setproperties  n    setpropertiesself props masknn    sets the properties bits.nn    argsn      props the properties to be set.n      mask a mask to be applied to the props argument before setting then          fsts properties.nn    returnsn      self.n    $^static pyobject pyxpw0pywrapfst00mutablefst00setpropertiespyobject pyxvself pyobject pyxargs pyobject pyxkwds $^  pyxt00basictypesuint00 pyxvprops$^  pyxt00basictypesuint00 pyxvmask$^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextsetproperties wrapper 0$^  $^    static pyobject pyxpyargnames  pyxnspropspyxnsmask0$^    pyobject values0  00$^    if unlikelypyxkwds $^      pyssizet kwargs$^      const pyssizet posargs  pytuplegetsizepyxargs$^      switch posargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 break$^        default goto pyxl0argtupleerror$^      $^      kwargs  pydictsizepyxkwds$^      switch posargs $^        case  0$^        if likelyvalues0  pydictgetitempyxkwds pyxnsprops  0 kwargs$^        else goto pyxl0argtupleerror$^        cythonfallthrough$^        case  0$^        if likelyvalues0  pydictgetitempyxkwds pyxnsmask  0 kwargs$^        else $^          pyxraiseargtupleinvalidsetproperties 0 0 0 0 pyxerr0 0000 pyxl0error$^        $^      $^      if unlikelykwargs  0 $^        if unlikelypyxparseoptionalkeywordspyxkwds pyxpyargnames 0 values posargs setproperties  0 pyxerr0 0000 pyxl0error$^      $^     else if pytuplegetsizepyxargs  0 $^      goto pyxl0argtupleerror$^     else $^      values0  pytuplegetitempyxargs 0$^      values0  pytuplegetitempyxargs 0$^    $^    pyxvprops  pyxpyintasuint00tvalues0 if unlikelypyxvprops  uint00t0  pyerroccurred pyxerr0 0000 pyxl0error$^    pyxvmask  pyxpyintasuint00tvalues0 if unlikelypyxvmask  uint00t0  pyerroccurred pyxerr0 0000 pyxl0error$^  $^  goto pyxl0argumentunpackingdone$^  pyxl0argtupleerror$^  pyxraiseargtupleinvalidsetproperties 0 0 0 pytuplegetsizepyxargs pyxerr0 0000 pyxl0error$^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablefst.setproperties pyxclineno pyxlineno pyxfilename$^  pyxrefnannyfinishcontext$^  return null$^  pyxl0argumentunpackingdone$^  pyxr  pyxpf0pywrapfst00mutablefst00setpropertiesstruct pyxobj0pywrapfstmutablefst pyxvself pyxvprops pyxvmask$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00mutablefst00setpropertiesstruct pyxobj0pywrapfstmutablefst pyxvself pyxt00basictypesuint00 pyxvprops pyxt00basictypesuint00 pyxvmask $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextsetproperties 0$^$^   pywrapfst.pyx0000$^        self.$^      $^      self.setpropertiesprops mask              $^      return self$^  $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s setproperties$^    pyxerr0 0000 pyxl0error$^  $^  struct pyxvtabstruct0pywrapfstmutablefst pyxvselfpyxbase.pyxvtabsetpropertiespyxvself pyxvprops pyxvmask$^$^   pywrapfst.pyx0000$^      $^      self.setpropertiesprops mask$^      return self              $^  $^    cdef void setstartself int00 state except $^ $^  pyxxdecrefpyxr$^  pyxincrefpyobject pyxvself$^  pyxr  pyobject pyxvself$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      self.mfst.get.setpropertiesprops mask$^  $^    def setpropertiesself uint00 props uint00 mask              $^      $^      setpropertiesself props mask$^ $^$^   function exit code $^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablefst.setproperties pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return self$^  $^    cdef void setstartself int00 state except               $^      if not self.mfst.get.setstartstate$^        raise fstindexerrorstate index out of range$^ $^$^static void pyxf0pywrapfst00mutablefstsetstartstruct pyxobj0pywrapfstmutablefst pyxvself pyxt00basictypesint00 pyxvstate $^  pyxrefnannydeclarations$^  int pyxt0$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextsetstart 0$^$^   pywrapfst.pyx0000$^  $^    cdef void setstartself int00 state except $^      if not self.mfst.get.setstartstate              $^        raise fstindexerrorstate index out of range$^      self.checkmutatingimethod$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s mfst$^    pyxerr0 0000 pyxl0error$^  $^  pyxt0  pyxvselfmfst.getsetstartpyxvstate  0  0$^  if pyxt0 $^$^     pywrapfst.pyx0000$^    cdef void setstartself int00 state except $^      if not self.mfst.get.setstartstate$^        raise fstindexerrorstate index out of range              $^      self.checkmutatingimethod$^  $^ $^    pyxt0  pyxgetmoduleglobalnamepyxnsfstindexerror if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  pyxpyobjectcallpyxt0 pyxtuple00 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxraisepyxt0 0 0 0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxerr0 0000 pyxl0error$^$^     pywrapfst.pyx0000$^  $^    cdef void setstartself int00 state except $^      if not self.mfst.get.setstartstate              $^        raise fstindexerrorstate index out of range$^      self.checkmutatingimethod$^ $^  $^$^   pywrapfst.pyx0000$^      if not self.mfst.get.setstartstate$^        raise fstindexerrorstate index out of range$^      self.checkmutatingimethod              $^  $^    def setstartself int00 state$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s checkmutatingimethod$^    pyxerr0 0000 pyxl0error$^  $^  struct pyxvtabstruct0pywrapfstmutablefst pyxvselfpyxbase.pyxvtabcheckmutatingimethodpyxvself if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^      return self$^  $^    cdef void setstartself int00 state except               $^      if not self.mfst.get.setstartstate$^        raise fstindexerrorstate index out of range$^ $^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.mutablefst.setstart pyxclineno pyxlineno pyxfilename$^  pyxl0$^  pyxrefnannyfinishcontext$^$^$^ pywrapfst.pyx0000$^      self.checkmutatingimethod$^  $^    def setstartself int00 state              $^      $^      setstartself state$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00mutablefst00setstartpyobject pyxvself pyobject pyxargstate proto$^static char pyxdoc0pywrapfst00mutablefst00setstart  n    setstartself statenn    sets a state to be the initial state state.nn    argsn      state the integer index of a state.nn    returnsn      self.nn    raisesn      fstindexerror state index out of range.nn    see also setfinal.n    $^static pyobject pyxpw0pywrapfst00mutablefst00setstartpyobject pyxvself pyobject pyxargstate $^  pyxt00basictypesint00 pyxvstate$^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextsetstart wrapper 0$^  assertpyxargstate $^    pyxvstate  pyxpyintasint00tpyxargstate if unlikelypyxvstate  int00t0  pyerroccurred pyxerr0 0000 pyxl0error$^  $^  goto pyxl0argumentunpackingdone$^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablefst.setstart pyxclineno pyxlineno pyxfilename$^  pyxrefnannyfinishcontext$^  return null$^  pyxl0argumentunpackingdone$^  pyxr  pyxpf0pywrapfst00mutablefst00setstartstruct pyxobj0pywrapfstmutablefst pyxvself pyxt00basictypesint00pyxvstate$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00mutablefst00setstartstruct pyxobj0pywrapfstmutablefst pyxvself pyxt00basictypesint00 pyxvstate $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextsetstart 0$^$^   pywrapfst.pyx0000$^      see also setfinal.$^      $^      self.setstartstate              $^      return self$^  $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s setstart$^    pyxerr0 0000 pyxl0error$^  $^  struct pyxvtabstruct0pywrapfstmutablefst pyxvselfpyxbase.pyxvtabsetstartpyxvself pyxvstate if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^      $^      self.setstartstate$^      return self              $^  $^    cdef void topsortself except $^ $^  pyxxdecrefpyxr$^  pyxincrefpyobject pyxvself$^  pyxr  pyobject pyxvself$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      self.checkmutatingimethod$^  $^    def setstartself int00 state              $^      $^      setstartself state$^ $^$^   function exit code $^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablefst.setstart pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return self$^  $^    cdef void topsortself except               $^       topsort returns false if the fst is cyclic and thus cant be topsorted.$^      if not fst.topsortself.mfst.get$^ $^$^static void pyxf0pywrapfst00mutablefsttopsortstruct pyxobj0pywrapfstmutablefst pyxvself $^  pyxrefnannydeclarations$^  int pyxt0$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxrefnannysetupcontexttopsort 0$^$^   pywrapfst.pyx0000$^    cdef void topsortself except $^       topsort returns false if the fst is cyclic and thus cant be topsorted.$^      if not fst.topsortself.mfst.get              $^        logging.warningcannot topsort cyclic fst.$^      self.checkmutatingimethod$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s mfst$^    pyxerr0 0000 pyxl0error$^  $^  pyxt0  fstscripttopsortpyxvselfmfst.get  0  0$^  if pyxt0 $^$^     pywrapfst.pyx0000$^       topsort returns false if the fst is cyclic and thus cant be topsorted.$^      if not fst.topsortself.mfst.get$^        logging.warningcannot topsort cyclic fst.              $^      self.checkmutatingimethod$^  $^ $^    pyxt0  pyxgetmoduleglobalnamepyxnslogging if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  pyxpyobjectgetattrstrpyxt0 pyxnswarning if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxt0  pyxpyobjectcallpyxt0 pyxtuple00 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxdecrefpyxt0 pyxt0  0$^$^     pywrapfst.pyx0000$^    cdef void topsortself except $^       topsort returns false if the fst is cyclic and thus cant be topsorted.$^      if not fst.topsortself.mfst.get              $^        logging.warningcannot topsort cyclic fst.$^      self.checkmutatingimethod$^ $^  $^$^   pywrapfst.pyx0000$^      if not fst.topsortself.mfst.get$^        logging.warningcannot topsort cyclic fst.$^      self.checkmutatingimethod              $^  $^    def topsortself$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s checkmutatingimethod$^    pyxerr0 0000 pyxl0error$^  $^  struct pyxvtabstruct0pywrapfstmutablefst pyxvselfpyxbase.pyxvtabcheckmutatingimethodpyxvself if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^      return self$^  $^    cdef void topsortself except               $^       topsort returns false if the fst is cyclic and thus cant be topsorted.$^      if not fst.topsortself.mfst.get$^ $^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.mutablefst.topsort pyxclineno pyxlineno pyxfilename$^  pyxl0$^  pyxrefnannyfinishcontext$^$^$^ pywrapfst.pyx0000$^      self.checkmutatingimethod$^  $^    def topsortself              $^      $^      topsortself$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00mutablefst00topsortpyobject pyxvself cythonunused pyobject unused proto$^static char pyxdoc0pywrapfst00mutablefst00topsort  n    topsortselfnn    sorts transitions by state ids.nn    this operation destructively topologically sorts the fst if it is acyclicn    otherwise it remains unchanged. once sorted all transitions are from lowern    state ids to higher state idsnn    returnsn       self.nn    see also arcsort.n    $^static pyobject pyxpw0pywrapfst00mutablefst00topsortpyobject pyxvself cythonunused pyobject unused $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontexttopsort wrapper 0$^  pyxr  pyxpf0pywrapfst00mutablefst00topsortstruct pyxobj0pywrapfstmutablefst pyxvself$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00mutablefst00topsortstruct pyxobj0pywrapfstmutablefst pyxvself $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontexttopsort 0$^$^   pywrapfst.pyx0000$^      see also arcsort.$^      $^      self.topsort              $^      return self$^  $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s topsort$^    pyxerr0 0000 pyxl0error$^  $^  struct pyxvtabstruct0pywrapfstmutablefst pyxvselfpyxbase.pyxvtabtopsortpyxvself if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^      $^      self.topsort$^      return self              $^  $^    cdef void unionself fst ifst except $^ $^  pyxxdecrefpyxr$^  pyxincrefpyobject pyxvself$^  pyxr  pyobject pyxvself$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      self.checkmutatingimethod$^  $^    def topsortself              $^      $^      topsortself$^ $^$^   function exit code $^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablefst.topsort pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^      return self$^  $^    cdef void unionself fst ifst except               $^      fst.unionself.mfst.get derefifst.fst$^      self.checkmutatingimethod$^ $^$^static void pyxf0pywrapfst00mutablefstunionstruct pyxobj0pywrapfstmutablefst pyxvself struct pyxobj0pywrapfstfst pyxvifst $^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextunion 0$^$^   pywrapfst.pyx0000$^  $^    cdef void unionself fst ifst except $^      fst.unionself.mfst.get derefifst.fst              $^      self.checkmutatingimethod$^  $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s mfst$^    pyxerr0 0000 pyxl0error$^  $^  if unlikelypyobject pyxvifst  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s fst$^    pyxerr0 0000 pyxl0error$^  $^  fstscriptunionpyxvselfmfst.get pyxvifstfst$^$^   pywrapfst.pyx0000$^    cdef void unionself fst ifst except $^      fst.unionself.mfst.get derefifst.fst$^      self.checkmutatingimethod              $^  $^    def unionself fst ifst$^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s checkmutatingimethod$^    pyxerr0 0000 pyxl0error$^  $^  struct pyxvtabstruct0pywrapfstmutablefst pyxvselfpyxbase.pyxvtabcheckmutatingimethodpyxvself if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^      return self$^  $^    cdef void unionself fst ifst except               $^      fst.unionself.mfst.get derefifst.fst$^      self.checkmutatingimethod$^ $^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablefst.union pyxclineno pyxlineno pyxfilename$^  pyxl0$^  pyxrefnannyfinishcontext$^$^$^ pywrapfst.pyx0000$^      self.checkmutatingimethod$^  $^    def unionself fst ifst              $^      $^      unionself ifst$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst00mutablefst00unionpyobject pyxvself pyobject pyxvifst proto$^static char pyxdoc0pywrapfst00mutablefst00union  n    unionself ifstnn    computes the union sum of two fsts.nn    this operation computes the union sum of two fsts. if a transduces stringn    x to y with weight a and b transduces string w to v with weight b thenn    their union transduces x to y with weight a and w to v with weight b.nn    argsn      ifst the second input fst.nn    returnsn      self.n    $^static pyobject pyxpw0pywrapfst00mutablefst00unionpyobject pyxvself pyobject pyxvifst $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextunion wrapper 0$^  if unlikelypyxargtypetestpyobject pyxvifst pyxptype0pywrapfstfst 0 ifst 0 pyxerr0 0000 pyxl0error$^  pyxr  pyxpf0pywrapfst00mutablefst00unionstruct pyxobj0pywrapfstmutablefst pyxvself struct pyxobj0pywrapfstfst pyxvifst$^$^   function exit code $^  goto pyxl0$^  pyxl0error$^  pyxr  null$^  pyxl0$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00mutablefst00unionstruct pyxobj0pywrapfstmutablefst pyxvself struct pyxobj0pywrapfstfst pyxvifst $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextunion 0$^$^   pywrapfst.pyx0000$^        self.$^      $^      self.unionifst              $^      return self$^  $^ $^  if unlikelypyobject pyxvself  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s union$^    pyxerr0 0000 pyxl0error$^  $^  struct pyxvtabstruct0pywrapfstmutablefst pyxvselfpyxbase.pyxvtabunionpyxvself pyxvifst if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^$^   pywrapfst.pyx0000$^      $^      self.unionifst$^      return self              $^  $^  $^ $^  pyxxdecrefpyxr$^  pyxincrefpyobject pyxvself$^  pyxr  pyobject pyxvself$^  goto pyxl0$^$^   pywrapfst.pyx0000$^      self.checkmutatingimethod$^  $^    def unionself fst ifst              $^      $^      unionself ifst$^ $^$^   function exit code $^  pyxl0error$^  pyxaddtracebackpywrapfst.mutablefst.union pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^  $^  $^  cdef fst initfstfstclassptr tfst              $^    if tfst.propertiesfst.kerror true$^      raise fstoperroroperation failed$^ $^$^static struct pyxobj0pywrapfstfst pyxf0pywrapfstinitfstpyxt0pywrapfstfstclassptr pyxvtfst $^  struct pyxobj0pywrapfstfst pyxvofst  0$^  struct pyxobj0pywrapfstfst pyxr  null$^  pyxrefnannydeclarations$^  int pyxt0$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextinitfst 0$^$^   pywrapfst.pyx0000$^  $^  cdef fst initfstfstclassptr tfst$^    if tfst.propertiesfst.kerror true              $^      raise fstoperroroperation failed$^    cdef fst ofst  fst.newfst$^ $^  pyxt0  pyxvtfstpropertiesfstkerror 0  0$^  if pyxt0 $^$^     pywrapfst.pyx0000$^  cdef fst initfstfstclassptr tfst$^    if tfst.propertiesfst.kerror true$^      raise fstoperroroperation failed              $^    cdef fst ofst  fst.newfst$^    ofst.fst.resettfst$^ $^    pyxt0  pyxgetmoduleglobalnamepyxnsfstoperror if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  pyxpyobjectcallpyxt0 pyxtuple00 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxraisepyxt0 0 0 0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxerr0 0000 pyxl0error$^$^     pywrapfst.pyx0000$^  $^  cdef fst initfstfstclassptr tfst$^    if tfst.propertiesfst.kerror true              $^      raise fstoperroroperation failed$^    cdef fst ofst  fst.newfst$^ $^  $^$^   pywrapfst.pyx0000$^    if tfst.propertiesfst.kerror true$^      raise fstoperroroperation failed$^    cdef fst ofst  fst.newfst              $^    ofst.fst.resettfst$^    return ofst$^ $^  pyxt0  pyxtpnew0pywrapfstfstpytypeobject pyxptype0pywrapfstfst pyxemptytuple null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  if likelypyxtypetestpyxt0 pyxptype0pywrapfstfst pyxerr0 0000 pyxl0error$^  pyxvofst  struct pyxobj0pywrapfstfst pyxt0$^  pyxt0  0$^$^   pywrapfst.pyx0000$^      raise fstoperroroperation failed$^    cdef fst ofst  fst.newfst$^    ofst.fst.resettfst              $^    return ofst$^  $^ $^  if unlikelypyobject pyxvofst  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s fst$^    pyxerr0 0000 pyxl0error$^  $^  pyxvofstfst.resetpyxvtfst$^$^   pywrapfst.pyx0000$^    cdef fst ofst  fst.newfst$^    ofst.fst.resettfst$^    return ofst              $^  $^  $^ $^  pyxxdecrefpyobject pyxr$^  pyxincrefpyobject pyxvofst$^  pyxr  pyxvofst$^  goto pyxl0$^$^   pywrapfst.pyx0000$^  $^  $^  cdef fst initfstfstclassptr tfst              $^    if tfst.propertiesfst.kerror true$^      raise fstoperroroperation failed$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.initfst pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxl0$^  pyxxdecrefpyobject pyxvofst$^  pyxxgiverefpyobject pyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^  $^  $^  cdef mutablefst initmutablefstmutablefstclassptr tfst              $^    if tfst.propertiesfst.kerror true$^      raise fstoperroroperation failed$^ $^$^static struct pyxobj0pywrapfstmutablefst pyxf0pywrapfstinitmutablefstpyxt0pywrapfstmutablefstclassptr pyxvtfst $^  struct pyxobj0pywrapfstmutablefst pyxvofst  0$^  struct pyxobj0pywrapfstmutablefst pyxr  null$^  pyxrefnannydeclarations$^  int pyxt0$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextinitmutablefst 0$^$^   pywrapfst.pyx0000$^  $^  cdef mutablefst initmutablefstmutablefstclassptr tfst$^    if tfst.propertiesfst.kerror true              $^      raise fstoperroroperation failed$^    cdef mutablefst ofst  mutablefst.newmutablefst$^ $^  pyxt0  pyxvtfstpropertiesfstkerror 0  0$^  if pyxt0 $^$^     pywrapfst.pyx0000$^  cdef mutablefst initmutablefstmutablefstclassptr tfst$^    if tfst.propertiesfst.kerror true$^      raise fstoperroroperation failed              $^    cdef mutablefst ofst  mutablefst.newmutablefst$^    ofst.fst.resettfst$^ $^    pyxt0  pyxgetmoduleglobalnamepyxnsfstoperror if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  pyxpyobjectcallpyxt0 pyxtuple00 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxraisepyxt0 0 0 0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxerr0 0000 pyxl0error$^$^     pywrapfst.pyx0000$^  $^  cdef mutablefst initmutablefstmutablefstclassptr tfst$^    if tfst.propertiesfst.kerror true              $^      raise fstoperroroperation failed$^    cdef mutablefst ofst  mutablefst.newmutablefst$^ $^  $^$^   pywrapfst.pyx0000$^    if tfst.propertiesfst.kerror true$^      raise fstoperroroperation failed$^    cdef mutablefst ofst  mutablefst.newmutablefst              $^    ofst.fst.resettfst$^     makes a copy of it as the derived type cool.$^ $^  pyxt0  pyxtpnew0pywrapfstmutablefstpytypeobject pyxptype0pywrapfstmutablefst pyxemptytuple null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  if likelypyxtypetestpyxt0 pyxptype0pywrapfstmutablefst pyxerr0 0000 pyxl0error$^  pyxvofst  struct pyxobj0pywrapfstmutablefst pyxt0$^  pyxt0  0$^$^   pywrapfst.pyx0000$^      raise fstoperroroperation failed$^    cdef mutablefst ofst  mutablefst.newmutablefst$^    ofst.fst.resettfst              $^     makes a copy of it as the derived type cool.$^    ofst.mfst  staticpointercastfst.mutablefstclass fst.fstclassofst.fst$^ $^  if unlikelypyobject pyxvofst  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s fst$^    pyxerr0 0000 pyxl0error$^  $^  pyxvofstpyxbase.fst.resetpyxvtfst$^$^   pywrapfst.pyx0000$^    ofst.fst.resettfst$^     makes a copy of it as the derived type cool.$^    ofst.mfst  staticpointercastfst.mutablefstclass fst.fstclassofst.fst              $^    return ofst$^  $^ $^  if unlikelypyobject pyxvofst  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s fst$^    pyxerr0 0000 pyxl0error$^  $^  if unlikelypyobject pyxvofst  pynone $^    pyerrformatpyexcattributeerror nonetype object has no attribute .00s mfst$^    pyxerr0 0000 pyxl0error$^  $^  pyxvofstmfst  stdstaticpointercastfstscriptmutablefstclassfstscriptfstclasspyxvofstpyxbase.fst$^$^   pywrapfst.pyx0000$^     makes a copy of it as the derived type cool.$^    ofst.mfst  staticpointercastfst.mutablefstclass fst.fstclassofst.fst$^    return ofst              $^  $^  $^ $^  pyxxdecrefpyobject pyxr$^  pyxincrefpyobject pyxvofst$^  pyxr  pyxvofst$^  goto pyxl0$^$^   pywrapfst.pyx0000$^  $^  $^  cdef mutablefst initmutablefstmutablefstclassptr tfst              $^    if tfst.propertiesfst.kerror true$^      raise fstoperroroperation failed$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.initmutablefst pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxl0$^  pyxxdecrefpyobject pyxvofst$^  pyxxgiverefpyobject pyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^  $^  $^  cdef fst initxfstfstclassptr tfst              $^    if tfst.propertiesfst.kmutable true$^      return initmutablefststaticcastmutablefstclassptrtfst$^ $^$^static struct pyxobj0pywrapfstfst pyxf0pywrapfstinitxfstpyxt0pywrapfstfstclassptr pyxvtfst $^  struct pyxobj0pywrapfstfst pyxr  null$^  pyxrefnannydeclarations$^  int pyxt0$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextinitxfst 0$^$^   pywrapfst.pyx0000$^  $^  cdef fst initxfstfstclassptr tfst$^    if tfst.propertiesfst.kmutable true              $^      return initmutablefststaticcastmutablefstclassptrtfst$^    else$^ $^  pyxt0  pyxvtfstpropertiesfstkmutable 0  0$^  if pyxt0 $^$^     pywrapfst.pyx0000$^  cdef fst initxfstfstclassptr tfst$^    if tfst.propertiesfst.kmutable true$^      return initmutablefststaticcastmutablefstclassptrtfst              $^    else$^      return initfsttfst$^ $^    pyxxdecrefpyobject pyxr$^    pyxt0  pyobject pyxf0pywrapfstinitmutablefststaticcastpyxt0pywrapfstmutablefstclassptrpyxvtfst if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxr  struct pyxobj0pywrapfstfst pyxt0$^    pyxt0  0$^    goto pyxl0$^$^     pywrapfst.pyx0000$^  $^  cdef fst initxfstfstclassptr tfst$^    if tfst.propertiesfst.kmutable true              $^      return initmutablefststaticcastmutablefstclassptrtfst$^    else$^ $^  $^$^   pywrapfst.pyx0000$^      return initmutablefststaticcastmutablefstclassptrtfst$^    else$^      return initfsttfst              $^  $^  $^ $^  else $^    pyxxdecrefpyobject pyxr$^    pyxt0  pyobject pyxf0pywrapfstinitfstpyxvtfst if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxr  struct pyxobj0pywrapfstfst pyxt0$^    pyxt0  0$^    goto pyxl0$^  $^$^   pywrapfst.pyx0000$^  $^  $^  cdef fst initxfstfstclassptr tfst              $^    if tfst.propertiesfst.kmutable true$^      return initmutablefststaticcastmutablefstclassptrtfst$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.initxfst pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxl0$^  pyxxgiverefpyobject pyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^  $^  $^  cdef mutablefst createfstarctypebstandard              $^    cdef uniqueptrfst.vectorfstclass tfst$^    tfst.resetnew fst.vectorfstclasstostringarctype$^ $^$^static struct pyxobj0pywrapfstmutablefst pyxf0pywrapfstcreatefststruct pyxoptargs0pywrapfstcreatefst pyxoptionalargs $^  pyobject pyxvarctype  pyobject pyxnbstandard$^  stduniqueptrfstscriptvectorfstclass  pyxvtfst$^  struct pyxobj0pywrapfstmutablefst pyxr  null$^  pyxrefnannydeclarations$^  stdstring pyxt0$^  int pyxt0$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextcreatefst 0$^  if pyxoptionalargs $^    if pyxoptionalargspyxn  0 $^      pyxvarctype  pyxoptionalargsarctype$^    $^  $^$^   pywrapfst.pyx0000$^  cdef mutablefst createfstarctypebstandard$^    cdef uniqueptrfst.vectorfstclass tfst$^    tfst.resetnew fst.vectorfstclasstostringarctype              $^    if tfst.get  null$^      raise fstoperrorunknown arc type r.formatarctype$^ $^  pyxt0  pyxf0pywrapfsttostringpyxvarctype null if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^  pyxvtfst.resetnew fstscriptvectorfstclasspyxt0$^$^   pywrapfst.pyx0000$^    cdef uniqueptrfst.vectorfstclass tfst$^    tfst.resetnew fst.vectorfstclasstostringarctype$^    if tfst.get  null              $^      raise fstoperrorunknown arc type r.formatarctype$^    return initmutablefsttfst.release$^ $^  pyxt0  pyxvtfst.get  null  0$^  if pyxt0 $^$^     pywrapfst.pyx0000$^    tfst.resetnew fst.vectorfstclasstostringarctype$^    if tfst.get  null$^      raise fstoperrorunknown arc type r.formatarctype              $^    return initmutablefsttfst.release$^  $^ $^    pyxt0  pyxgetmoduleglobalnamepyxnsfstoperror if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  pyxpyobjectgetattrstrpyxkpsunknownarctyper pyxnsformat if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  null$^    if cythonunpackmethods  likelypymethodcheckpyxt0 $^      pyxt0  pymethodgetselfpyxt0$^      if likelypyxt0 $^        pyobject function  pymethodgetfunctionpyxt0$^        pyxincrefpyxt0$^        pyxincreffunction$^        pyxdecrefsetpyxt0 function$^      $^    $^    if pyxt0 $^      pyxt0  pyxpyobjectcalloneargpyxt0 pyxvarctype if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxgotrefpyxt0$^     else $^      if cythonfastpycall$^      if pyfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxvarctype$^        pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^       else$^      endif$^      if cythonfastpyccall$^      if pyxpyfastcfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxvarctype$^        pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^       else$^      endif$^      $^        pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxgotrefpyxt0$^        pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^        pyxincrefpyxvarctype$^        pyxgiverefpyxvarctype$^        pytuplesetitempyxt0 00 pyxvarctype$^        pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^      $^    $^    pyxdecrefpyxt0 pyxt0  0$^    pyxt0  null$^    if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^      pyxt0  pymethodgetselfpyxt0$^      if likelypyxt0 $^        pyobject function  pymethodgetfunctionpyxt0$^        pyxincrefpyxt0$^        pyxincreffunction$^        pyxdecrefsetpyxt0 function$^      $^    $^    if pyxt0 $^      pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxgotrefpyxt0$^     else $^      if cythonfastpycall$^      if pyfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxt0$^        pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^       else$^      endif$^      if cythonfastpyccall$^      if pyxpyfastcfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxt0$^        pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^       else$^      endif$^      $^        pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxgotrefpyxt0$^        pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^        pyxgiverefpyxt0$^        pytuplesetitempyxt0 00 pyxt0$^        pyxt0  0$^        pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^      $^    $^    pyxdecrefpyxt0 pyxt0  0$^    pyxraisepyxt0 0 0 0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxerr0 0000 pyxl0error$^$^     pywrapfst.pyx0000$^    cdef uniqueptrfst.vectorfstclass tfst$^    tfst.resetnew fst.vectorfstclasstostringarctype$^    if tfst.get  null              $^      raise fstoperrorunknown arc type r.formatarctype$^    return initmutablefsttfst.release$^ $^  $^$^   pywrapfst.pyx0000$^    if tfst.get  null$^      raise fstoperrorunknown arc type r.formatarctype$^    return initmutablefsttfst.release              $^  $^  $^ $^  pyxxdecrefpyobject pyxr$^  pyxt0  pyobject pyxf0pywrapfstinitmutablefstpyxvtfst.release if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  struct pyxobj0pywrapfstmutablefst pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   pywrapfst.pyx0000$^  $^  $^  cdef mutablefst createfstarctypebstandard              $^    cdef uniqueptrfst.vectorfstclass tfst$^    tfst.resetnew fst.vectorfstclasstostringarctype$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.createfst pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxl0$^  pyxxgiverefpyobject pyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^  $^  $^  cpdef fst readfilename              $^    cdef uniqueptrfst.fstclass tfst$^    tfst.resetfst.fstclass.readtostringfilename$^ $^$^static pyobject pyxpw0pywrapfst00readpyobject pyxself pyobject pyxvfilename proto$^static struct pyxobj0pywrapfstfst pyxf0pywrapfstreadpyobject pyxvfilename cythonunused int pyxskipdispatch $^  stduniqueptrfstscriptfstclass  pyxvtfst$^  struct pyxobj0pywrapfstfst pyxr  null$^  pyxrefnannydeclarations$^  stdstring pyxt0$^  int pyxt0$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextread 0$^$^   pywrapfst.pyx0000$^  cpdef fst readfilename$^    cdef uniqueptrfst.fstclass tfst$^    tfst.resetfst.fstclass.readtostringfilename              $^    if tfst.get  null$^      raise fstioerrorread failed r.formatfilename$^ $^  pyxt0  pyxf0pywrapfsttostringpyxvfilename null if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^  pyxvtfst.resetfstscriptfstclassreadpyxt0$^$^   pywrapfst.pyx0000$^    cdef uniqueptrfst.fstclass tfst$^    tfst.resetfst.fstclass.readtostringfilename$^    if tfst.get  null              $^      raise fstioerrorread failed r.formatfilename$^    return initxfsttfst.release$^ $^  pyxt0  pyxvtfst.get  null  0$^  if pyxt0 $^$^     pywrapfst.pyx0000$^    tfst.resetfst.fstclass.readtostringfilename$^    if tfst.get  null$^      raise fstioerrorread failed r.formatfilename              $^    return initxfsttfst.release$^  $^ $^    pyxt0  pyxgetmoduleglobalnamepyxnsfstioerror if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  pyxpyobjectgetattrstrpyxkpsreadfailedr pyxnsformat if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  null$^    if cythonunpackmethods  likelypymethodcheckpyxt0 $^      pyxt0  pymethodgetselfpyxt0$^      if likelypyxt0 $^        pyobject function  pymethodgetfunctionpyxt0$^        pyxincrefpyxt0$^        pyxincreffunction$^        pyxdecrefsetpyxt0 function$^      $^    $^    if pyxt0 $^      pyxt0  pyxpyobjectcalloneargpyxt0 pyxvfilename if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxgotrefpyxt0$^     else $^      if cythonfastpycall$^      if pyfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxvfilename$^        pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^       else$^      endif$^      if cythonfastpyccall$^      if pyxpyfastcfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxvfilename$^        pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^       else$^      endif$^      $^        pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxgotrefpyxt0$^        pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^        pyxincrefpyxvfilename$^        pyxgiverefpyxvfilename$^        pytuplesetitempyxt0 00 pyxvfilename$^        pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^      $^    $^    pyxdecrefpyxt0 pyxt0  0$^    pyxt0  null$^    if cythonunpackmethods  unlikelypymethodcheckpyxt0 $^      pyxt0  pymethodgetselfpyxt0$^      if likelypyxt0 $^        pyobject function  pymethodgetfunctionpyxt0$^        pyxincrefpyxt0$^        pyxincreffunction$^        pyxdecrefsetpyxt0 function$^      $^    $^    if pyxt0 $^      pyxt0  pyxpyobjectcalloneargpyxt0 pyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^      pyxdecrefpyxt0 pyxt0  0$^      pyxgotrefpyxt0$^     else $^      if cythonfastpycall$^      if pyfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxt0$^        pyxt0  pyxpyfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^       else$^      endif$^      if cythonfastpyccall$^      if pyxpyfastcfunctioncheckpyxt0 $^        pyobject pyxtemp0  pyxt0 pyxt0$^        pyxt0  pyxpycfunctionfastcallpyxt0 pyxtemp00 00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxxdecrefpyxt0 pyxt0  0$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^       else$^      endif$^      $^        pyxt0  pytuplenew00 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxgotrefpyxt0$^        pyxgiverefpyxt0 pytuplesetitempyxt0 0 pyxt0 pyxt0  null$^        pyxgiverefpyxt0$^        pytuplesetitempyxt0 00 pyxt0$^        pyxt0  0$^        pyxt0  pyxpyobjectcallpyxt0 pyxt0 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^        pyxgotrefpyxt0$^        pyxdecrefpyxt0 pyxt0  0$^      $^    $^    pyxdecrefpyxt0 pyxt0  0$^    pyxraisepyxt0 0 0 0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxerr0 0000 pyxl0error$^$^     pywrapfst.pyx0000$^    cdef uniqueptrfst.fstclass tfst$^    tfst.resetfst.fstclass.readtostringfilename$^    if tfst.get  null              $^      raise fstioerrorread failed r.formatfilename$^    return initxfsttfst.release$^ $^  $^$^   pywrapfst.pyx0000$^    if tfst.get  null$^      raise fstioerrorread failed r.formatfilename$^    return initxfsttfst.release              $^  $^  $^ $^  pyxxdecrefpyobject pyxr$^  pyxt0  pyobject pyxf0pywrapfstinitxfstpyxvtfst.release if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  struct pyxobj0pywrapfstfst pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   pywrapfst.pyx0000$^  $^  $^  cpdef fst readfilename              $^    cdef uniqueptrfst.fstclass tfst$^    tfst.resetfst.fstclass.readtostringfilename$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.read pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxl0$^  pyxxgiverefpyobject pyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst00readpyobject pyxself pyobject pyxvfilename proto$^static pyobject pyxpw0pywrapfst00readpyobject pyxself pyobject pyxvfilename $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextread wrapper 0$^  pyxr  pyxpf0pywrapfst00readpyxself pyobject pyxvfilename$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00readcythonunused pyobject pyxself pyobject pyxvfilename $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextread 0$^  pyxxdecrefpyxr$^  pyxt0  pyobject pyxf0pywrapfstreadpyxvfilename 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.read pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^  $^  $^  cpdef fst readfromstringstate              $^    cdef stringstream sstrm$^    sstrm  tostringstate$^ $^$^static pyobject pyxpw0pywrapfst00readfromstringpyobject pyxself pyobject pyxvstate proto$^static struct pyxobj0pywrapfstfst pyxf0pywrapfstreadfromstringpyobject pyxvstate cythonunused int pyxskipdispatch $^  stdstringstream pyxvsstrm$^  stduniqueptrfstscriptfstclass  pyxvtfst$^  struct pyxobj0pywrapfstfst pyxr  null$^  pyxrefnannydeclarations$^  stdstring pyxt0$^  int pyxt0$^  pyobject pyxt0  null$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextreadfromstring 0$^$^   pywrapfst.pyx0000$^  cpdef fst readfromstringstate$^    cdef stringstream sstrm$^    sstrm  tostringstate              $^    cdef uniqueptrfst.fstclass tfst$^    tfst.resetfst.fstclass.readfromstreamsstrm bpywrapfst$^ $^  pyxt0  pyxf0pywrapfsttostringpyxvstate null if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^  pyxvsstrm  pyxt0$^$^   pywrapfst.pyx0000$^    sstrm  tostringstate$^    cdef uniqueptrfst.fstclass tfst$^    tfst.resetfst.fstclass.readfromstreamsstrm bpywrapfst              $^    if tfst.get  null$^      raise fstioerrorread failed string$^ $^  pyxt0  pyxconvertstringfrompystdinstringpyxkpbpywrapfst if unlikelypyerroccurred pyxerr0 0000 pyxl0error$^  pyxvtfst.resetfstscriptfstclassreadpyxvsstrm pyxt0$^$^   pywrapfst.pyx0000$^    cdef uniqueptrfst.fstclass tfst$^    tfst.resetfst.fstclass.readfromstreamsstrm bpywrapfst$^    if tfst.get  null              $^      raise fstioerrorread failed string$^    return initxfsttfst.release$^ $^  pyxt0  pyxvtfst.get  null  0$^  if pyxt0 $^$^     pywrapfst.pyx0000$^    tfst.resetfst.fstclass.readfromstreamsstrm bpywrapfst$^    if tfst.get  null$^      raise fstioerrorread failed string              $^    return initxfsttfst.release$^  $^ $^    pyxt0  pyxgetmoduleglobalnamepyxnsfstioerror if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxt0  pyxpyobjectcallpyxt0 pyxtuple00 null if unlikelypyxt0 pyxerr0 0000 pyxl0error$^    pyxgotrefpyxt0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxraisepyxt0 0 0 0$^    pyxdecrefpyxt0 pyxt0  0$^    pyxerr0 0000 pyxl0error$^$^     pywrapfst.pyx0000$^    cdef uniqueptrfst.fstclass tfst$^    tfst.resetfst.fstclass.readfromstreamsstrm bpywrapfst$^    if tfst.get  null              $^      raise fstioerrorread failed string$^    return initxfsttfst.release$^ $^  $^$^   pywrapfst.pyx0000$^    if tfst.get  null$^      raise fstioerrorread failed string$^    return initxfsttfst.release              $^  $^  $^ $^  pyxxdecrefpyobject pyxr$^  pyxt0  pyobject pyxf0pywrapfstinitxfstpyxvtfst.release if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  struct pyxobj0pywrapfstfst pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   pywrapfst.pyx0000$^  $^  $^  cpdef fst readfromstringstate              $^    cdef stringstream sstrm$^    sstrm  tostringstate$^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.readfromstring pyxclineno pyxlineno pyxfilename$^  pyxr  0$^  pyxl0$^  pyxxgiverefpyobject pyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ python wrapper $^static pyobject pyxpw0pywrapfst00readfromstringpyobject pyxself pyobject pyxvstate proto$^static pyobject pyxpw0pywrapfst00readfromstringpyobject pyxself pyobject pyxvstate $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextreadfromstring wrapper 0$^  pyxr  pyxpf0pywrapfst00readfromstringpyxself pyobject pyxvstate$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst00readfromstringcythonunused pyobject pyxself pyobject pyxvstate $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  pyxrefnannysetupcontextreadfromstring 0$^  pyxxdecrefpyxr$^  pyxt0  pyobject pyxf0pywrapfstreadfromstringpyxvstate 0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.readfromstring pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^     $^  $^     def newcls arctypebstandard              $^      return createfstarctype$^  $^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst0fst0newpyobject pyxself pyobject pyxargs pyobject pyxkwds proto$^static pymethoddef pyxmdef0pywrapfst0fst0new  new pycfunctionpyxpw0pywrapfst0fst0new methvarargsmethkeywords 0$^static pyobject pyxpw0pywrapfst0fst0newpyobject pyxself pyobject pyxargs pyobject pyxkwds $^  cythonunused pyobject pyxvcls  0$^  pyobject pyxvarctype  0$^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextnew wrapper 0$^  $^    static pyobject pyxpyargnames  pyxnsclspyxnsarctype0$^    pyobject values0  00$^    values0  pyobject pyobjectpyxnbstandard$^    if unlikelypyxkwds $^      pyssizet kwargs$^      const pyssizet posargs  pytuplegetsizepyxargs$^      switch posargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 break$^        default goto pyxl0argtupleerror$^      $^      kwargs  pydictsizepyxkwds$^      switch posargs $^        case  0$^        if likelyvalues0  pydictgetitempyxkwds pyxnscls  0 kwargs$^        else goto pyxl0argtupleerror$^        cythonfallthrough$^        case  0$^        if kwargs  0 $^          pyobject value  pydictgetitempyxkwds pyxnsarctype$^          if value  values0  value kwargs $^        $^      $^      if unlikelykwargs  0 $^        if unlikelypyxparseoptionalkeywordspyxkwds pyxpyargnames 0 values posargs new  0 pyxerr0 0000 pyxl0error$^      $^     else $^      switch pytuplegetsizepyxargs $^        case  0 values0  pytuplegetitempyxargs 0$^        cythonfallthrough$^        case  0 values0  pytuplegetitempyxargs 0$^        break$^        default goto pyxl0argtupleerror$^      $^    $^    pyxvcls  values0$^    pyxvarctype  values0$^  $^  goto pyxl0argumentunpackingdone$^  pyxl0argtupleerror$^  pyxraiseargtupleinvalidnew 0 0 0 pytuplegetsizepyxargs pyxerr0 0000 pyxl0error$^  pyxl0error$^  pyxaddtracebackpywrapfst.fst.new pyxclineno pyxlineno pyxfilename$^  pyxrefnannyfinishcontext$^  return null$^  pyxl0argumentunpackingdone$^  pyxr  pyxpf0pywrapfst0fstnewpyxself pyxvcls pyxvarctype$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst0fstnewcythonunused pyobject pyxself cythonunused pyobject pyxvcls pyobject pyxvarctype $^  pyobject pyxr  null$^  pyxrefnannydeclarations$^  pyobject pyxt0  null$^  struct pyxoptargs0pywrapfstcreatefst pyxt0$^  pyxrefnannysetupcontextnew 0$^$^   pywrapfst.pyx0000$^  $^     def newcls arctypebstandard$^      return createfstarctype              $^  $^     staticmethod$^ $^  pyxxdecrefpyxr$^  pyxt0.pyxn  0$^  pyxt0.arctype  pyxvarctype$^  pyxt0  pyobject pyxf0pywrapfstcreatefstpyxt0 if unlikelypyxt0 pyxerr0 0000 pyxl0error$^  pyxgotrefpyxt0$^  pyxr  pyxt0$^  pyxt0  0$^  goto pyxl0$^$^   pywrapfst.pyx0000$^     $^  $^     def newcls arctypebstandard              $^      return createfstarctype$^  $^ $^$^   function exit code $^  pyxl0error$^  pyxxdecrefpyxt0$^  pyxaddtracebackpywrapfst.fst.new pyxclineno pyxlineno pyxfilename$^  pyxr  null$^  pyxl0$^  pyxxgiverefpyxr$^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^ pywrapfst.pyx0000$^  $^     staticmethod$^     def readfilename              $^       $^       readfilename$^ $^$^ python wrapper $^static pyobject pyxpw0pywrapfst0fst0readpyobject pyxself pyobject pyxvfilename proto$^static char pyxdoc0pywrapfst0fst0read  n     readfilenamenn     reads an fst from a file.nn     argsn       filename the string location of the input file.nn     returnsn       an fst object.nn     raisesn       fstioerror read failed.n     $^static pymethoddef pyxmdef0pywrapfst0fst0read  read pycfunctionpyxpw0pywrapfst0fst0read metho pyxdoc0pywrapfst0fst0read$^static pyobject pyxpw0pywrapfst0fst0readpyobject pyxself pyobject pyxvfilename $^  pyobject pyxr  0$^  pyxrefnannydeclarations$^  pyxrefnannysetupcontextread wrapper 0$^  pyxr  pyxpf0pywrapfst0fst0readpyxself pyobject pyxvfilename$^$^   function exit code $^  pyxrefnannyfinishcontext$^  return pyxr$^$^$^static pyobject pyxpf0pywrapfst0fst0readcythonunused pyobject pyxself pyobject pyxvfilename $