 *         tostring(filename), tostring(arc_type), ft)
 *     if tfar == NULL:
 *       raise FstIOError("Open failed: {!r}".format(filename))             # <<<<<<<<<<<<<<
 *     cdef FarWriter result = FarWriter.__new__(FarWriter)
 *     result._writer.reset(tfar)
 */
    __pyx_t_5 = __Pyx_GetModuleGlobalName(__pyx_n_s_FstIOError); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 4413, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_kp_s_Open_failed_r, __pyx_n_s_format); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 4413, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_7);
    __pyx_t_8 = NULL;
    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_7))) {
      __pyx_t_8 = PyMethod_GET_SELF(__pyx_t_7);
      if (likely(__pyx_t_8)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_7);
        __Pyx_INCREF(__pyx_t_8);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_7, function);
      }
    }
    if (!__pyx_t_8) {
      __pyx_t_6 = __Pyx_PyObject_CallOneArg(__pyx_t_7, __pyx_v_filename); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 4413, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_6);
    } else {
      #if CYTHON_FAST_PYCALL
      if (PyFunction_Check(__pyx_t_7)) {
        PyObject *__pyx_temp[2] = {__pyx_t_8, __pyx_v_filename};
        __pyx_t_6 = __Pyx_PyFunction_FastCall(__pyx_t_7, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 4413, __pyx_L1_error)
        __Pyx_XDECREF(__pyx_t_8); __pyx_t_8 = 0;
        __Pyx_GOTREF(__pyx_t_6);
      } else
      #endif
      #if CYTHON_FAST_PYCCALL
      if (__Pyx_PyFastCFunction_Check(__pyx_t_7)) {
        PyObject *__pyx_temp[2] = {__pyx_t_8, __pyx_v_filename};
        __pyx_t_6 = __Pyx_PyCFunction_FastCall(__pyx_t_7, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 4413, __pyx_L1_error)
        __Pyx_XDECREF(__pyx_t_8); __pyx_t_8 = 0;
        __Pyx_GOTREF(__pyx_t_6);
      } else
      #endif
      {
        __pyx_t_9 = PyTuple_New(1+1); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 4413, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_9);
        __Pyx_GIVEREF(__pyx_t_8); PyTuple_SET_ITEM(__pyx_t_9, 0, __pyx_t_8); __pyx_t_8 = NULL;
        __Pyx_INCREF(__pyx_v_filename);
        __Pyx_GIVEREF(__pyx_v_filename);
        PyTuple_SET_ITEM(__pyx_t_9, 0+1, __pyx_v_filename);
        __pyx_t_6 = __Pyx_PyObject_Call(__pyx_t_7, __pyx_t_9, NULL); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 4413, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_6);
        __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
      }
    }
    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
    __pyx_t_7 = NULL;
    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_5))) {
      __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_5);
      if (likely(__pyx_t_7)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
        __Pyx_INCREF(__pyx_t_7);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_5, function);
      }
    }
    if (!__pyx_t_7) {
      __pyx_t_4 = __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_t_6); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 4413, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
      __Pyx_GOTREF(__pyx_t_4);
    } else {
      #if CYTHON_FAST_PYCALL
      if (PyFunction_Check(__pyx_t_5)) {
        PyObject *__pyx_temp[2] = {__pyx_t_7, __pyx_t_6};
        __pyx_t_4 = __Pyx_PyFunction_FastCall(__pyx_t_5, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 4413, __pyx_L1_error)
        __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
        __Pyx_GOTREF(__pyx_t_4);
        __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
      } else
      #endif
      #if CYTHON_FAST_PYCCALL
      if (__Pyx_PyFastCFunction_Check(__pyx_t_5)) {
        PyObject *__pyx_temp[2] = {__pyx_t_7, __pyx_t_6};
        __pyx_t_4 = __Pyx_PyCFunction_FastCall(__pyx_t_5, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 4413, __pyx_L1_error)
        __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
        __Pyx_GOTREF(__pyx_t_4);
        __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
      } else
      #endif
      {
        __pyx_t_9 = PyTuple_New(1+1); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 4413, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_9);
        __Pyx_GIVEREF(__pyx_t_7); PyTuple_SET_ITEM(__pyx_t_9, 0, __pyx_t_7); __pyx_t_7 = NULL;
        __Pyx_GIVEREF(__pyx_t_6);
        PyTuple_SET_ITEM(__pyx_t_9, 0+1, __pyx_t_6);
        __pyx_t_6 = 0;
        __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_5, __pyx_t_9, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 4413, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_4);
        __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
      }
    }
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __Pyx_Raise(__pyx_t_4, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __PYX_ERR(0, 4413, __pyx_L1_error)

    /* "pywrapfst.pyx":4412
 *     cdef fst.FarWriterClass *tfar = fst.FarWriterClass.Create(
 *         tostring(filename), tostring(arc_type), ft)
 *     if tfar == NULL:             # <<<<<<<<<<<<<<
 *       raise FstIOError("Open failed: {!r}".format(filename))
 *     cdef FarWriter result = FarWriter.__new__(FarWriter)
 */
  }

  /* "pywrapfst.pyx":4414
 *     if tfar == NULL:
 *       raise FstIOError("Open failed: {!r}".format(filename))
 *     cdef FarWriter result = FarWriter.__new__(FarWriter)             # <<<<<<<<<<<<<<
 *     result._writer.reset(tfar)
 *     return result
 */
  __pyx_t_4 = __pyx_tp_new_9pywrapfst_FarWriter(((PyTypeObject *)__pyx_ptype_9pywrapfst_FarWriter), __pyx_empty_tuple, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 4414, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  if (!(likely(__Pyx_TypeTest(__pyx_t_4, __pyx_ptype_9pywrapfst_FarWriter)))) __PYX_ERR(0, 4414, __pyx_L1_error)
  __pyx_v_result = ((struct __pyx_obj_9pywrapfst_FarWriter *)__pyx_t_4);
  __pyx_t_4 = 0;

  /* "pywrapfst.pyx":4415
 *       raise FstIOError("Open failed: {!r}".format(filename))
 *     cdef FarWriter result = FarWriter.__new__(FarWriter)
 *     result._writer.reset(tfar)             # <<<<<<<<<<<<<<
 *     return result
 * 
 */
  if (unlikely(((PyObject *)__pyx_v_result) == Py_None)) {
    PyErr_Format(PyExc_AttributeError, "'NoneType' object has no attribute '%.30s'", "_writer");
    __PYX_ERR(0, 4415, __pyx_L1_error)
  }
  __pyx_v_result->_writer.reset(__pyx_v_tfar);

  /* "pywrapfst.pyx":4416
 *     cdef FarWriter result = FarWriter.__new__(FarWriter)
 *     result._writer.reset(tfar)
 *     return result             # <<<<<<<<<<<<<<
 * 
 *   # NB: Invoking this method may be dangerous: calling any other method on the
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_result));
  __pyx_r = ((PyObject *)__pyx_v_result);
  goto __pyx_L0;

  /* "pywrapfst.pyx":4388
 * 
 *   @classmethod
 *   def create(cls, filename, arc_type=b"standard", far_type=b"default"):             # <<<<<<<<<<<<<<
 *     """
 *     FarWriter.
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_XDECREF(__pyx_t_7);
  __Pyx_XDECREF(__pyx_t_8);
  __Pyx_XDECREF(__pyx_t_9);
  __Pyx_AddTraceback("pywrapfst.FarWriter.create", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_result);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pywrapfst.pyx":4420
 *   # NB: Invoking this method may be dangerous: calling any other method on the
 *   # instance after this is invoked may result in a null dereference.
 *   cdef void close(self):             # <<<<<<<<<<<<<<
 *     self._writer.reset()
 * 
 */

static void __pyx_f_9pywrapfst_9FarWriter_close(struct __pyx_obj_9pywrapfst_FarWriter *__pyx_v_self) {
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("close", 0);

  /* "pywrapfst.pyx":4421
 *   # instance after this is invoked may result in a null dereference.
 *   cdef void close(self):
 *     self._writer.reset()             # <<<<<<<<<<<<<<
 * 
 *   cpdef void add(self, key, _Fst ifst) except *:
 */
  if (unlikely(((PyObject *)__pyx_v_self) == Py_None)) {
    PyErr_Format(PyExc_AttributeError, "'NoneType' object has no attribute '%.30s'", "_writer");
    __PYX_ERR(0, 4421, __pyx_L1_error)
  }
  __pyx_v_self->_writer.reset();

  /* "pywrapfst.pyx":4420
 *   # NB: Invoking this method may be dangerous: calling any other method on the
 *   # instance after this is invoked may result in a null dereference.
 *   cdef void close(self):             # <<<<<<<<<<<<<<
 *     self._writer.reset()
 * 
 */

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_WriteUnraisable("pywrapfst.FarWriter.close", __pyx_clineno, __pyx_lineno, __pyx_filename, 1, 0);
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
}

/* "pywrapfst.pyx":4423
 *     self._writer.reset()
 * 
 *   cpdef void add(self, key, _Fst ifst) except *:             # <<<<<<<<<<<<<<
 *     """
 *     add(self, key, ifst)
 */

static PyObject *__pyx_pw_9pywrapfst_9FarWriter_7add(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static void __pyx_f_9pywrapfst_9FarWriter_add(struct __pyx_obj_9pywrapfst_FarWriter *__pyx_v_self, PyObject *__pyx_v_key, struct __pyx_obj_9pywrapfst__Fst *__pyx_v_ifst, int __pyx_skip_dispatch) {
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  int __pyx_t_5;
  PyObject *__pyx_t_6 = NULL;
  std::string __pyx_t_7;
  int __pyx_t_8;
  __Pyx_RefNannySetupContext("add", 0);
  /* Check if called by wrapper */
  if (unlikely(__pyx_skip_dispatch)) ;
  /* Check if overridden in Python */
  else if (unlikely(Py_TYPE(((PyObject *)__pyx_v_self))->tp_dictoffset != 0)) {
    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_add); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4423, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    if (!PyCFunction_Check(__pyx_t_1) || (PyCFunction_GET_FUNCTION(__pyx_t_1) != (PyCFunction)__pyx_pw_9pywrapfst_9FarWriter_7add)) {
      __Pyx_INCREF(__pyx_t_1);
      __pyx_t_3 = __pyx_t_1; __pyx_t_4 = NULL;
      __pyx_t_5 = 0;
      if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
        __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
        if (likely(__pyx_t_4)) {
          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
          __Pyx_INCREF(__pyx_t_4);
          __Pyx_INCREF(function);
          __Pyx_DECREF_SET(__pyx_t_3, function);
          __pyx_t_5 = 1;
        }
      }
      #if CYTHON_FAST_PYCALL
      if (PyFunction_Check(__pyx_t_3)) {
        PyObject *__pyx_temp[3] = {__pyx_t_4, __pyx_v_key, ((PyObject *)__pyx_v_ifst)};
        __pyx_t_2 = __Pyx_PyFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_5, 2+__pyx_t_5); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 4423, __pyx_L1_error)
        __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
        __Pyx_GOTREF(__pyx_t_2);
      } else
      #endif
      #if CYTHON_FAST_PYCCALL
      if (__Pyx_PyFastCFunction_Check(__pyx_t_3)) {
        PyObject *__pyx_temp[3] = {__pyx_t_4, __pyx_v_key, ((PyObject *)__pyx_v_ifst)};
        __pyx_t_2 = __Pyx_PyCFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_5, 2+__pyx_t_5); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 4423, __pyx_L1_error)
        __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
        __Pyx_GOTREF(__pyx_t_2);
      } else
      #endif
      {
        __pyx_t_6 = PyTuple_New(2+__pyx_t_5); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 4423, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_6);
        if (__pyx_t_4) {
          __Pyx_GIVEREF(__pyx_t_4); PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_t_4); __pyx_t_4 = NULL;
        }
        __Pyx_INCREF(__pyx_v_key);
        __Pyx_GIVEREF(__pyx_v_key);
        PyTuple_SET_ITEM(__pyx_t_6, 0+__pyx_t_5, __pyx_v_key);
        __Pyx_INCREF(((PyObject *)__pyx_v_ifst));
        __Pyx_GIVEREF(((PyObject *)__pyx_v_ifst));
        PyTuple_SET_ITEM(__pyx_t_6, 1+__pyx_t_5, ((PyObject *)__pyx_v_ifst));
        __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_6, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 4423, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_2);
        __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
      }
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      goto __pyx_L0;
    }
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  }

  /* "pywrapfst.pyx":4442
 *     # Failure here results from passing an FST with a different arc type than
 *     # used by the FAR was initialized to use.
 *     if not self._writer.get().Add(tostring(key), deref(ifst._fst)):             # <<<<<<<<<<<<<<
 *       raise FstOpError("Incompatible or invalid arc type")
 *     # An error here usually indicates a key out of order.
 */
  if (unlikely(((PyObject *)__pyx_v_self) == Py_None)) {
    PyErr_Format(PyExc_AttributeError, "'NoneType' object has no attribute '%.30s'", "_writer");
    __PYX_ERR(0, 4442, __pyx_L1_error)
  }
  __pyx_t_7 = __pyx_f_9pywrapfst_tostring(__pyx_v_key, NULL); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 4442, __pyx_L1_error)
  if (unlikely(((PyObject *)__pyx_v_ifst) == Py_None)) {
    PyErr_Format(PyExc_AttributeError, "'NoneType' object has no attribute '%.30s'", "_fst");
    __PYX_ERR(0, 4442, __pyx_L1_error)
  }
  __pyx_t_8 = ((!(__pyx_v_self->_writer.get()->Add(__pyx_t_7, (*__pyx_v_ifst->_fst)) != 0)) != 0);
  if (__pyx_t_8) {

    /* "pywrapfst.pyx":4443
 *     # used by the FAR was initialized to use.
 *     if not self._writer.get().Add(tostring(key), deref(ifst._fst)):
 *       raise FstOpError("Incompatible or invalid arc type")             # <<<<<<<<<<<<<<
 *     # An error here usually indicates a key out of order.
 *     if self._writer.get().Error():
 */
    __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_FstOpError); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4443, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__95, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 4443, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __PYX_ERR(0, 4443, __pyx_L1_error)

    /* "pywrapfst.pyx":4442
 *     # Failure here results from passing an FST with a different arc type than
 *     # used by the FAR was initialized to use.
 *     if not self._writer.get().Add(tostring(key), deref(ifst._fst)):             # <<<<<<<<<<<<<<
 *       raise FstOpError("Incompatible or invalid arc type")
 *     # An error here usually indicates a key out of order.
 */
  }

  /* "pywrapfst.pyx":4445
 *       raise FstOpError("Incompatible or invalid arc type")
 *     # An error here usually indicates a key out of order.
 *     if self._writer.get().Error():             # <<<<<<<<<<<<<<
 *       raise FstArgError("Key out of order")
 * 
 */
  if (unlikely(((PyObject *)__pyx_v_self) == Py_None)) {
    PyErr_Format(PyExc_AttributeError, "'NoneType' object has no attribute '%.30s'", "_writer");
    __PYX_ERR(0, 4445, __pyx_L1_error)
  }
  __pyx_t_8 = (__pyx_v_self->_writer.get()->Error() != 0);
  if (__pyx_t_8) {

    /* "pywrapfst.pyx":4446
 *     # An error here usually indicates a key out of order.
 *     if self._writer.get().Error():
 *       raise FstArgError("Key out of order")             # <<<<<<<<<<<<<<
 * 
 *   cpdef string arc_type(self):
 */
    __pyx_t_2 = __Pyx_GetModuleGlobalName(__pyx_n_s_FstArgError); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 4446, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_tuple__96, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4446, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __Pyx_Raise(__pyx_t_1, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __PYX_ERR(0, 4446, __pyx_L1_error)

    /* "pywrapfst.pyx":4445
 *       raise FstOpError("Incompatible or invalid arc type")
 *     # An error here usually indicates a key out of order.
 *     if self._writer.get().Error():             # <<<<<<<<<<<<<<
 *       raise FstArgError("Key out of order")
 * 
 */
  }

  /* "pywrapfst.pyx":4423
 *     self._writer.reset()
 * 
 *   cpdef void add(self, key, _Fst ifst) except *:             # <<<<<<<<<<<<<<
 *     """
 *     add(self, key, ifst)
 */

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_AddTraceback("pywrapfst.FarWriter.add", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
}

/* Python wrapper */
static PyObject *__pyx_pw_9pywrapfst_9FarWriter_7add(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_9pywrapfst_9FarWriter_6add[] = "\n    add(self, key, ifst)\n\n    Adds an FST to the FAR.\n\n    This method adds an FST to the FAR which can be retrieved with the\n    specified string key.\n\n    Args:\n      key: The string used to key the input FST.\n      ifst: The FST to write to the FAR.\n\n    Raises:\n      FstArgError: Key out of order.\n      FstOpError: Incompatible or invalid arc type.\n    ";
static PyObject *__pyx_pw_9pywrapfst_9FarWriter_7add(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_key = 0;
  struct __pyx_obj_9pywrapfst__Fst *__pyx_v_ifst = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("add (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_key,&__pyx_n_s_ifst,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_key)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_ifst)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("add", 1, 2, 2, 1); __PYX_ERR(0, 4423, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "add") < 0)) __PYX_ERR(0, 4423, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_key = values[0];
    __pyx_v_ifst = ((struct __pyx_obj_9pywrapfst__Fst *)values[1]);
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("add", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 4423, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("pywrapfst.FarWriter.add", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_ifst), __pyx_ptype_9pywrapfst__Fst, 1, "ifst", 0))) __PYX_ERR(0, 4423, __pyx_L1_error)
  __pyx_r = __pyx_pf_9pywrapfst_9FarWriter_6add(((struct __pyx_obj_9pywrapfst_FarWriter *)__pyx_v_self), __pyx_v_key, __pyx_v_ifst);

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9pywrapfst_9FarWriter_6add(struct __pyx_obj_9pywrapfst_FarWriter *__pyx_v_self, PyObject *__pyx_v_key, struct __pyx_obj_9pywrapfst__Fst *__pyx_v_ifst) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("add", 0);
  __Pyx_XDECREF(__pyx_r);
  __pyx_f_9pywrapfst_9FarWriter_add(__pyx_v_self, __pyx_v_key, __pyx_v_ifst, 1); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 4423, __pyx_L1_error)
  __pyx_t_1 = __Pyx_void_to_None(NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4423, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("pywrapfst.FarWriter.add", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pywrapfst.pyx":4448
 *       raise FstArgError("Key out of order")
 * 
 *   cpdef string arc_type(self):             # <<<<<<<<<<<<<<
 *     """
 *     arc_type(self)
 */

static PyObject *__pyx_pw_9pywrapfst_9FarWriter_9arc_type(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static std::string __pyx_f_9pywrapfst_9FarWriter_arc_type(struct __pyx_obj_9pywrapfst_FarWriter *__pyx_v_self, int __pyx_skip_dispatch) {
  std::string __pyx_r;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  std::string __pyx_t_5;
  __Pyx_RefNannySetupContext("arc_type", 0);
  /* Check if called by wrapper */
  if (unlikely(__pyx_skip_dispatch)) ;
  /* Check if overridden in Python */
  else if (unlikely(Py_TYPE(((PyObject *)__pyx_v_self))->tp_dictoffset != 0)) {
    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_arc_type); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4448, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    if (!PyCFunction_Check(__pyx_t_1) || (PyCFunction_GET_FUNCTION(__pyx_t_1) != (PyCFunction)__pyx_pw_9pywrapfst_9FarWriter_9arc_type)) {
      __Pyx_INCREF(__pyx_t_1);
      __pyx_t_3 = __pyx_t_1; __pyx_t_4 = NULL;
      if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
        __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
        if (likely(__pyx_t_4)) {
          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
          __Pyx_INCREF(__pyx_t_4);
          __Pyx_INCREF(function);
          __Pyx_DECREF_SET(__pyx_t_3, function);
        }
      }
      if (__pyx_t_4) {
        __pyx_t_2 = __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 4448, __pyx_L1_error)
        __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      } else {
        __pyx_t_2 = __Pyx_PyObject_CallNoArg(__pyx_t_3); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 4448, __pyx_L1_error)
      }
      __Pyx_GOTREF(__pyx_t_2);
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __pyx_t_5 = __pyx_convert_string_from_py_std__in_string(__pyx_t_2); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 4448, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
      __pyx_r = __pyx_t_5;
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      goto __pyx_L0;
    }
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  }

  /* "pywrapfst.pyx":4454
 *     Returns a string indicating the arc type.
 *     """
 *     return self._writer.get().ArcType()             # <<<<<<<<<<<<<<
 * 
 *   cpdef bool error(self):
 */
  if (unlikely(((PyObject *)__pyx_v_self) == Py_None)) {
    PyErr_Format(PyExc_AttributeError, "'NoneType' object has no attribute '%.30s'", "_writer");
    __PYX_ERR(0, 4454, __pyx_L1_error)
  }
  __pyx_r = __pyx_v_self->_writer.get()->ArcType();
  goto __pyx_L0;

  /* "pywrapfst.pyx":4448
 *       raise FstArgError("Key out of order")
 * 
 *   cpdef string arc_type(self):             # <<<<<<<<<<<<<<
 *     """
 *     arc_type(self)
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_WriteUnraisable("pywrapfst.FarWriter.arc_type", __pyx_clineno, __pyx_lineno, __pyx_filename, 1, 0);
  __Pyx_pretend_to_initialize(&__pyx_r);
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_9pywrapfst_9FarWriter_9arc_type(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_9pywrapfst_9FarWriter_8arc_type[] = "\n    arc_type(self)\n\n    Returns a string indicating the arc type.\n    ";
static PyObject *__pyx_pw_9pywrapfst_9FarWriter_9arc_type(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("arc_type (wrapper)", 0);
  __pyx_r = __pyx_pf_9pywrapfst_9FarWriter_8arc_type(((struct __pyx_obj_9pywrapfst_FarWriter *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9pywrapfst_9FarWriter_8arc_type(struct __pyx_obj_9pywrapfst_FarWriter *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("arc_type", 0);
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __pyx_convert_PyBytes_string_to_py_std__in_string(__pyx_f_9pywrapfst_9FarWriter_arc_type(__pyx_v_self, 1)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4448, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("pywrapfst.FarWriter.arc_type", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pywrapfst.pyx":4456
 *     return self._writer.get().ArcType()
 * 
 *   cpdef bool error(self):             # <<<<<<<<<<<<<<
 *     """
 *     error(self)
 */

static PyObject *__pyx_pw_9pywrapfst_9FarWriter_11error(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static bool __pyx_f_9pywrapfst_9FarWriter_error(struct __pyx_obj_9pywrapfst_FarWriter *__pyx_v_self, int __pyx_skip_dispatch) {
  bool __pyx_r;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  bool __pyx_t_5;
  __Pyx_RefNannySetupContext("error", 0);
  /* Check if called by wrapper */
  if (unlikely(__pyx_skip_dispatch)) ;
  /* Check if overridden in Python */
  else if (unlikely(Py_TYPE(((PyObject *)__pyx_v_self))->tp_dictoffset != 0)) {
    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_error); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4456, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    if (!PyCFunction_Check(__pyx_t_1) || (PyCFunction_GET_FUNCTION(__pyx_t_1) != (PyCFunction)__pyx_pw_9pywrapfst_9FarWriter_11error)) {
      __Pyx_INCREF(__pyx_t_1);
      __pyx_t_3 = __pyx_t_1; __pyx_t_4 = NULL;
      if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
        __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
        if (likely(__pyx_t_4)) {
          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
          __Pyx_INCREF(__pyx_t_4);
          __Pyx_INCREF(function);
          __Pyx_DECREF_SET(__pyx_t_3, function);
        }
      }
      if (__pyx_t_4) {
        __pyx_t_2 = __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 4456, __pyx_L1_error)
        __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      } else {
        __pyx_t_2 = __Pyx_PyObject_CallNoArg(__pyx_t_3); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 4456, __pyx_L1_error)
      }
      __Pyx_GOTREF(__pyx_t_2);
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_2); if (unlikely((__pyx_t_5 == ((bool)-1)) && PyErr_Occurred())) __PYX_ERR(0, 4456, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
      __pyx_r = __pyx_t_5;
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      goto __pyx_L0;
    }
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  }

  /* "pywrapfst.pyx":4465
 *       True if the FarWriter is in an errorful state, False otherwise.
 *     """
 *     return self._writer.get().Error()             # <<<<<<<<<<<<<<
 * 
 *   cpdef string far_type(self):
 */
  if (unlikely(((PyObject *)__pyx_v_self) == Py_None)) {
    PyErr_Format(PyExc_AttributeError, "'NoneType' object has no attribute '%.30s'", "_writer");
    __PYX_ERR(0, 4465, __pyx_L1_error)
  }
  __pyx_r = __pyx_v_self->_writer.get()->Error();
  goto __pyx_L0;

  /* "pywrapfst.pyx":4456
 *     return self._writer.get().ArcType()
 * 
 *   cpdef bool error(self):             # <<<<<<<<<<<<<<
 *     """
 *     error(self)
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_WriteUnraisable("pywrapfst.FarWriter.error", __pyx_clineno, __pyx_lineno, __pyx_filename, 1, 0);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_9pywrapfst_9FarWriter_11error(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_9pywrapfst_9FarWriter_10error[] = "\n    error(self)\n\n    Indicates whether the FarWriter has encountered an error.\n\n    Returns:\n      True if the FarWriter is in an errorful state, False otherwise.\n    ";
static PyObject *__pyx_pw_9pywrapfst_9FarWriter_11error(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("error (wrapper)", 0);
  __pyx_r = __pyx_pf_9pywrapfst_9FarWriter_10error(((struct __pyx_obj_9pywrapfst_FarWriter *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9pywrapfst_9FarWriter_10error(struct __pyx_obj_9pywrapfst_FarWriter *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("error", 0);
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyBool_FromLong(__pyx_f_9pywrapfst_9FarWriter_error(__pyx_v_self, 1)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4456, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("pywrapfst.FarWriter.error", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pywrapfst.pyx":4467
 *     return self._writer.get().Error()
 * 
 *   cpdef string far_type(self):             # <<<<<<<<<<<<<<
 *     """
 *     far_type(self)
 */

static PyObject *__pyx_pw_9pywrapfst_9FarWriter_13far_type(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static std::string __pyx_f_9pywrapfst_9FarWriter_far_type(struct __pyx_obj_9pywrapfst_FarWriter *__pyx_v_self, int __pyx_skip_dispatch) {
  std::string __pyx_r;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  std::string __pyx_t_5;
  __Pyx_RefNannySetupContext("far_type", 0);
  /* Check if called by wrapper */
  if (unlikely(__pyx_skip_dispatch)) ;
  /* Check if overridden in Python */
  else if (unlikely(Py_TYPE(((PyObject *)__pyx_v_self))->tp_dictoffset != 0)) {
    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_far_type); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4467, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    if (!PyCFunction_Check(__pyx_t_1) || (PyCFunction_GET_FUNCTION(__pyx_t_1) != (PyCFunction)__pyx_pw_9pywrapfst_9FarWriter_13far_type)) {
      __Pyx_INCREF(__pyx_t_1);
      __pyx_t_3 = __pyx_t_1; __pyx_t_4 = NULL;
      if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
        __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
        if (likely(__pyx_t_4)) {
          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
          __Pyx_INCREF(__pyx_t_4);
          __Pyx_INCREF(function);
          __Pyx_DECREF_SET(__pyx_t_3, function);
        }
      }
      if (__pyx_t_4) {
        __pyx_t_2 = __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 4467, __pyx_L1_error)
        __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      } else {
        __pyx_t_2 = __Pyx_PyObject_CallNoArg(__pyx_t_3); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 4467, __pyx_L1_error)
      }
      __Pyx_GOTREF(__pyx_t_2);
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __pyx_t_5 = __pyx_convert_string_from_py_std__in_string(__pyx_t_2); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 4467, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
      __pyx_r = __pyx_t_5;
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      goto __pyx_L0;
    }
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  }

  /* "pywrapfst.pyx":4473
 *     Returns a string indicating the FAR type.
 *     """
 *     return fst.GetFarTypeString(self._writer.get().Type())             # <<<<<<<<<<<<<<
 * 
 *   # Dictionary-like assignment.
 */
  if (unlikely(((PyObject *)__pyx_v_self) == Py_None)) {
    PyErr_Format(PyExc_AttributeError, "'NoneType' object has no attribute '%.30s'", "_writer");
    __PYX_ERR(0, 4473, __pyx_L1_error)
  }
  __pyx_r = fst::GetFarTypeString(__pyx_v_self->_writer.get()->Type());
  goto __pyx_L0;

  /* "pywrapfst.pyx":4467
 *     return self._writer.get().Error()
 * 
 *   cpdef string far_type(self):             # <<<<<<<<<<<<<<
 *     """
 *     far_type(self)
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_WriteUnraisable("pywrapfst.FarWriter.far_type", __pyx_clineno, __pyx_lineno, __pyx_filename, 1, 0);
  __Pyx_pretend_to_initialize(&__pyx_r);
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_9pywrapfst_9FarWriter_13far_type(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_9pywrapfst_9FarWriter_12far_type[] = "\n    far_type(self)\n\n    Returns a string indicating the FAR type.\n    ";
static PyObject *__pyx_pw_9pywrapfst_9FarWriter_13far_type(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("far_type (wrapper)", 0);
  __pyx_r = __pyx_pf_9pywrapfst_9FarWriter_12far_type(((struct __pyx_obj_9pywrapfst_FarWriter *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9pywrapfst_9FarWriter_12far_type(struct __pyx_obj_9pywrapfst_FarWriter *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("far_type", 0);
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __pyx_convert_PyBytes_string_to_py_std__in_string(__pyx_f_9pywrapfst_9FarWriter_far_type(__pyx_v_self, 1)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4467, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("pywrapfst.FarWriter.far_type", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pywrapfst.pyx":4476
 * 
 *   # Dictionary-like assignment.
 *   def __setitem__(self, key, _Fst fst):             # <<<<<<<<<<<<<<
 *     self.add(key, fst)
 * 
 */

/* Python wrapper */
static int __pyx_pw_9pywrapfst_9FarWriter_15__setitem__(PyObject *__pyx_v_self, PyObject *__pyx_v_key, PyObject *__pyx_v_fst); /*proto*/
static int __pyx_pw_9pywrapfst_9FarWriter_15__setitem__(PyObject *__pyx_v_self, PyObject *__pyx_v_key, PyObject *__pyx_v_fst) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__setitem__ (wrapper)", 0);
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_fst), __pyx_ptype_9pywrapfst__Fst, 1, "fst", 0))) __PYX_ERR(0, 4476, __pyx_L1_error)
  __pyx_r = __pyx_pf_9pywrapfst_9FarWriter_14__setitem__(((struct __pyx_obj_9pywrapfst_FarWriter *)__pyx_v_self), ((PyObject *)__pyx_v_key), ((struct __pyx_obj_9pywrapfst__Fst *)__pyx_v_fst));

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static int __pyx_pf_9pywrapfst_9FarWriter_14__setitem__(struct __pyx_obj_9pywrapfst_FarWriter *__pyx_v_self, PyObject *__pyx_v_key, struct __pyx_obj_9pywrapfst__Fst *__pyx_v_fst) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__setitem__", 0);

  /* "pywrapfst.pyx":4477
 *   # Dictionary-like assignment.
 *   def __setitem__(self, key, _Fst fst):
 *     self.add(key, fst)             # <<<<<<<<<<<<<<
 * 
 * 
 */
  if (unlikely(((PyObject *)__pyx_v_self) == Py_None)) {
    PyErr_Format(PyExc_AttributeError, "'NoneType' object has no attribute '%.30s'", "add");
    __PYX_ERR(0, 4477, __pyx_L1_error)
  }
  ((struct __pyx_vtabstruct_9pywrapfst_FarWriter *)__pyx_v_self->__pyx_vtab)->add(__pyx_v_self, __pyx_v_key, __pyx_v_fst, 0); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 4477, __pyx_L1_error)

  /* "pywrapfst.pyx":4476
 * 
 *   # Dictionary-like assignment.
 *   def __setitem__(self, key, _Fst fst):             # <<<<<<<<<<<<<<
 *     self.add(key, fst)
 * 
 */

  /* function exit code */
  __pyx_r = 0;
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("pywrapfst.FarWriter.__setitem__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "(tree fragment)":1
 * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
 *     raise TypeError("self._writer cannot be converted to a Python object for pickling")
 * def __setstate_cython__(self, __pyx_state):
 */

/* Python wrapper */
static PyObject *__pyx_pw_9pywrapfst_9FarWriter_17__reduce_cython__(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static PyObject *__pyx_pw_9pywrapfst_9FarWriter_17__reduce_cython__(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__reduce_cython__ (wrapper)", 0);
  __pyx_r = __pyx_pf_9pywrapfst_9FarWriter_16__reduce_cython__(((struct __pyx_obj_9pywrapfst_FarWriter *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9pywrapfst_9FarWriter_16__reduce_cython__(CYTHON_UNUSED struct __pyx_obj_9pywrapfst_FarWriter *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("__reduce_cython__", 0);

  /* "(tree fragment)":2
 * def __reduce_cython__(self):
 *     raise TypeError("self._writer cannot be converted to a Python object for pickling")             # <<<<<<<<<<<<<<
 * def __setstate_cython__(self, __pyx_state):
 *     raise TypeError("self._writer cannot be converted to a Python object for pickling")
 */
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__97, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 2, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_Raise(__pyx_t_1, 0, 0, 0);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __PYX_ERR(1, 2, __pyx_L1_error)

  /* "(tree fragment)":1
 * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
 *     raise TypeError("self._writer cannot be converted to a Python object for pickling")
 * def __setstate_cython__(self, __pyx_state):
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("pywrapfst.FarWriter.__reduce_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "(tree fragment)":3
 * def __reduce_cython__(self):
 *     raise TypeError("self._writer cannot be converted to a Python object for pickling")
 * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<
 *     raise TypeError("self._writer cannot be converted to a Python object for pickling")
 */

/* Python wrapper */
static PyObject *__pyx_pw_9pywrapfst_9FarWriter_19__setstate_cython__(PyObject *__pyx_v_self, PyObject *__pyx_v___pyx_state); /*proto*/
static PyObject *__pyx_pw_9pywrapfst_9FarWriter_19__setstate_cython__(PyObject *__pyx_v_self, PyObject *__pyx_v___pyx_state) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__setstate_cython__ (wrapper)", 0);
  __pyx_r = __pyx_pf_9pywrapfst_9FarWriter_18__setstate_cython__(((struct __pyx_obj_9pywrapfst_FarWriter *)__pyx_v_self), ((PyObject *)__pyx_v___pyx_state));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9pywrapfst_9FarWriter_18__setstate_cython__(CYTHON_UNUSED struct __pyx_obj_9pywrapfst_FarWriter *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v___pyx_state) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("__setstate_cython__", 0);

  /* "(tree fragment)":4
 *     raise TypeError("self._writer cannot be converted to a Python object for pickling")
 * def __setstate_cython__(self, __pyx_state):
 *     raise TypeError("self._writer cannot be converted to a Python object for pickling")             # <<<<<<<<<<<<<<
 */
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__98, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 4, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_Raise(__pyx_t_1, 0, 0, 0);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __PYX_ERR(1, 4, __pyx_L1_error)

  /* "(tree fragment)":3
 * def __reduce_cython__(self):
 *     raise TypeError("self._writer cannot be converted to a Python object for pickling")
 * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<
 *     raise TypeError("self._writer cannot be converted to a Python object for pickling")
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("pywrapfst.FarWriter.__setstate_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pywrapfst.pyx":4492
 * 
 * @atexit.register
 * def _reset_fst_error_fatal():             # <<<<<<<<<<<<<<
 *   fst.FLAGS_fst_error_fatal = _fst_error_fatal_old
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_9pywrapfst_59_reset_fst_error_fatal(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static PyMethodDef __pyx_mdef_9pywrapfst_59_reset_fst_error_fatal = {"_reset_fst_error_fatal", (PyCFunction)__pyx_pw_9pywrapfst_59_reset_fst_error_fatal, METH_NOARGS, 0};
static PyObject *__pyx_pw_9pywrapfst_59_reset_fst_error_fatal(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("_reset_fst_error_fatal (wrapper)", 0);
  __pyx_r = __pyx_pf_9pywrapfst_58_reset_fst_error_fatal(__pyx_self);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9pywrapfst_58_reset_fst_error_fatal(CYTHON_UNUSED PyObject *__pyx_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  bool __pyx_t_2;
  __Pyx_RefNannySetupContext("_reset_fst_error_fatal", 0);

  /* "pywrapfst.pyx":4493
 * @atexit.register
 * def _reset_fst_error_fatal():
 *   fst.FLAGS_fst_error_fatal = _fst_error_fatal_old             # <<<<<<<<<<<<<<
 * 
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_fst_error_fatal_old); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4493, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely((__pyx_t_2 == ((bool)-1)) && PyErr_Occurred())) __PYX_ERR(0, 4493, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  FLAGS_fst_error_fatal = __pyx_t_2;

  /* "pywrapfst.pyx":4492
 * 
 * @atexit.register
 * def _reset_fst_error_fatal():             # <<<<<<<<<<<<<<
 *   fst.FLAGS_fst_error_fatal = _fst_error_fatal_old
 * 
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("pywrapfst._reset_fst_error_fatal", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "string.from_py":13
 * 
 * @cname("__pyx_convert_string_from_py_std__in_string")
 * cdef string __pyx_convert_string_from_py_std__in_string(object o) except *:             # <<<<<<<<<<<<<<
 *     cdef Py_ssize_t length
 *     cdef const char* data = __Pyx_PyObject_AsStringAndSize(o, &length)
 */

static std::string __pyx_convert_string_from_py_std__in_string(PyObject *__pyx_v_o) {
  Py_ssize_t __pyx_v_length;
  char const *__pyx_v_data;
  std::string __pyx_r;
  __Pyx_RefNannyDeclarations
  char const *__pyx_t_1;
  __Pyx_RefNannySetupContext("__pyx_convert_string_from_py_std__in_string", 0);

  /* "string.from_py":15
 * cdef string __pyx_convert_string_from_py_std__in_string(object o) except *:
 *     cdef Py_ssize_t length
 *     cdef const char* data = __Pyx_PyObject_AsStringAndSize(o, &length)             # <<<<<<<<<<<<<<
 *     return string(data, length)
 * 
 */
  __pyx_t_1 = __Pyx_PyObject_AsStringAndSize(__pyx_v_o, (&__pyx_v_length)); if (unlikely(__pyx_t_1 == ((char const *)NULL))) __PYX_ERR(1, 15, __pyx_L1_error)
  __pyx_v_data = __pyx_t_1;

  /* "string.from_py":16
 *     cdef Py_ssize_t length
 *     cdef const char* data = __Pyx_PyObject_AsStringAndSize(o, &length)
 *     return string(data, length)             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __pyx_r = std::string(__pyx_v_data, __pyx_v_length);
  goto __pyx_L0;

  /* "string.from_py":13
 * 
 * @cname("__pyx_convert_string_from_py_std__in_string")
 * cdef string __pyx_convert_string_from_py_std__in_string(object o) except *:             # <<<<<<<<<<<<<<
 *     cdef Py_ssize_t length
 *     cdef const char* data = __Pyx_PyObject_AsStringAndSize(o, &length)
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("string.from_py.__pyx_convert_string_from_py_std__in_string", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_pretend_to_initialize(&__pyx_r);
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "string.to_py":31
 * 
 * @cname("__pyx_convert_PyObject_string_to_py_std__in_string")
 * cdef inline object __pyx_convert_PyObject_string_to_py_std__in_string(const string& s):             # <<<<<<<<<<<<<<
 *     return __Pyx_PyObject_FromStringAndSize(s.data(), s.size())
 * cdef extern from *:
 */

static CYTHON_INLINE PyObject *__pyx_convert_PyObject_string_to_py_std__in_string(std::string const &__pyx_v_s) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("__pyx_convert_PyObject_string_to_py_std__in_string", 0);

  /* "string.to_py":32
 * @cname("__pyx_convert_PyObject_string_to_py_std__in_string")
 * cdef inline object __pyx_convert_PyObject_string_to_py_std__in_string(const string& s):
 *     return __Pyx_PyObject_FromStringAndSize(s.data(), s.size())             # <<<<<<<<<<<<<<
 * cdef extern from *:
 *     cdef object __Pyx_PyUnicode_FromStringAndSize(const char*, size_t)
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyObject_FromStringAndSize(__pyx_v_s.data(), __pyx_v_s.size()); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 32, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "string.to_py":31
 * 
 * @cname("__pyx_convert_PyObject_string_to_py_std__in_string")
 * cdef inline object __pyx_convert_PyObject_string_to_py_std__in_string(const string& s):             # <<<<<<<<<<<<<<
 *     return __Pyx_PyObject_FromStringAndSize(s.data(), s.size())
 * cdef extern from *:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("string.to_py.__pyx_convert_PyObject_string_to_py_std__in_string", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "string.to_py":37
 * 
 * @cname("__pyx_convert_PyUnicode_string_to_py_std__in_string")
 * cdef inline object __pyx_convert_PyUnicode_string_to_py_std__in_string(const string& s):             # <<<<<<<<<<<<<<
 *     return __Pyx_PyUnicode_FromStringAndSize(s.data(), s.size())
 * cdef extern from *:
 */

static CYTHON_INLINE PyObject *__pyx_convert_PyUnicode_string_to_py_std__in_string(std::string const &__pyx_v_s) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("__pyx_convert_PyUnicode_string_to_py_std__in_string", 0);

  /* "string.to_py":38
 * @cname("__pyx_convert_PyUnicode_string_to_py_std__in_string")
 * cdef inline object __pyx_convert_PyUnicode_string_to_py_std__in_string(const string& s):
 *     return __Pyx_PyUnicode_FromStringAndSize(s.data(), s.size())             # <<<<<<<<<<<<<<
 * cdef extern from *:
 *     cdef object __Pyx_PyStr_FromStringAndSize(const char*, size_t)
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyUnicode_FromStringAndSize(__pyx_v_s.data(), __pyx_v_s.size()); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 38, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "string.to_py":37
 * 
 * @cname("__pyx_convert_PyUnicode_string_to_py_std__in_string")
 * cdef inline object __pyx_convert_PyUnicode_string_to_py_std__in_string(const string& s):             # <<<<<<<<<<<<<<
 *     return __Pyx_PyUnicode_FromStringAndSize(s.data(), s.size())
 * cdef extern from *:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("string.to_py.__pyx_convert_PyUnicode_string_to_py_std__in_string", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "string.to_py":43
 * 
 * @cname("__pyx_convert_PyStr_string_to_py_std__in_string")
 * cdef inline object __pyx_convert_PyStr_string_to_py_std__in_string(const string& s):             # <<<<<<<<<<<<<<
 *     return __Pyx_PyStr_FromStringAndSize(s.data(), s.size())
 * cdef extern from *:
 */

static CYTHON_INLINE PyObject *__pyx_convert_PyStr_string_to_py_std__in_string(std::string const &__pyx_v_s) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("__pyx_convert_PyStr_string_to_py_std__in_string", 0);

  /* "string.to_py":44
 * @cname("__pyx_convert_PyStr_string_to_py_std__in_string")
 * cdef inline object __pyx_convert_PyStr_string_to_py_std__in_string(const string& s):
 *     return __Pyx_PyStr_FromStringAndSize(s.data(), s.size())             # <<<<<<<<<<<<<<
 * cdef extern from *:
 *     cdef object __Pyx_PyBytes_FromStringAndSize(const char*, size_t)
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyStr_FromStringAndSize(__pyx_v_s.data(), __pyx_v_s.size()); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 44, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "string.to_py":43
 * 
 * @cname("__pyx_convert_PyStr_string_to_py_std__in_string")
 * cdef inline object __pyx_convert_PyStr_string_to_py_std__in_string(const string& s):             # <<<<<<<<<<<<<<
 *     return __Pyx_PyStr_FromStringAndSize(s.data(), s.size())
 * cdef extern from *:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("string.to_py.__pyx_convert_PyStr_string_to_py_std__in_string", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "string.to_py":49
 * 
 * @cname("__pyx_convert_PyBytes_string_to_py_std__in_string")
 * cdef inline object __pyx_convert_PyBytes_string_to_py_std__in_string(const string& s):             # <<<<<<<<<<<<<<
 *     return __Pyx_PyBytes_FromStringAndSize(s.data(), s.size())
 * cdef extern from *:
 */

static CYTHON_INLINE PyObject *__pyx_convert_PyBytes_string_to_py_std__in_string(std::string const &__pyx_v_s) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("__pyx_convert_PyBytes_string_to_py_std__in_string", 0);

  /* "string.to_py":50
 * @cname("__pyx_convert_PyBytes_string_to_py_std__in_string")
 * cdef inline object __pyx_convert_PyBytes_string_to_py_std__in_string(const string& s):
 *     return __Pyx_PyBytes_FromStringAndSize(s.data(), s.size())             # <<<<<<<<<<<<<<
 * cdef extern from *:
 *     cdef object __Pyx_PyByteArray_FromStringAndSize(const char*, size_t)
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyBytes_FromStringAndSize(__pyx_v_s.data(), __pyx_v_s.size()); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 50, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "string.to_py":49
 * 
 * @cname("__pyx_convert_PyBytes_string_to_py_std__in_string")
 * cdef inline object __pyx_convert_PyBytes_string_to_py_std__in_string(const string& s):             # <<<<<<<<<<<<<<
 *     return __Pyx_PyBytes_FromStringAndSize(s.data(), s.size())
 * cdef extern from *:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("string.to_py.__pyx_convert_PyBytes_string_to_py_std__in_string", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "string.to_py":55
 * 
 * @cname("__pyx_convert_PyByteArray_string_to_py_std__in_string")
 * cdef inline object __pyx_convert_PyByteArray_string_to_py_std__in_string(const string& s):             # <<<<<<<<<<<<<<
 *     return __Pyx_PyByteArray_FromStringAndSize(s.data(), s.size())
 * 
 */

static CYTHON_INLINE PyObject *__pyx_convert_PyByteArray_string_to_py_std__in_string(std::string const &__pyx_v_s) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("__pyx_convert_PyByteArray_string_to_py_std__in_string", 0);

  /* "string.to_py":56
 * @cname("__pyx_convert_PyByteArray_string_to_py_std__in_string")
 * cdef inline object __pyx_convert_PyByteArray_string_to_py_std__in_string(const string& s):
 *     return __Pyx_PyByteArray_FromStringAndSize(s.data(), s.size())             # <<<<<<<<<<<<<<
 * 
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyByteArray_FromStringAndSize(__pyx_v_s.data(), __pyx_v_s.size()); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 56, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "string.to_py":55
 * 
 * @cname("__pyx_convert_PyByteArray_string_to_py_std__in_string")
 * cdef inline object __pyx_convert_PyByteArray_string_to_py_std__in_string(const string& s):             # <<<<<<<<<<<<<<
 *     return __Pyx_PyByteArray_FromStringAndSize(s.data(), s.size())
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("string.to_py.__pyx_convert_PyByteArray_string_to_py_std__in_string", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "vector.from_py":45
 * 
 * @cname("__pyx_convert_vector_from_py___pyx_t_10basictypes_int64")
 * cdef vector[X] __pyx_convert_vector_from_py___pyx_t_10basictypes_int64(object o) except *:             # <<<<<<<<<<<<<<
 *     cdef vector[X] v
 *     for item in o:
 */

static std::vector<__pyx_t_10basictypes_int64>  __pyx_convert_vector_from_py___pyx_t_10basictypes_int64(PyObject *__pyx_v_o) {
  std::vector<__pyx_t_10basictypes_int64>  __pyx_v_v;
  PyObject *__pyx_v_item = NULL;
  std::vector<__pyx_t_10basictypes_int64>  __pyx_r;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  Py_ssize_t __pyx_t_2;
  PyObject *(*__pyx_t_3)(PyObject *);
  PyObject *__pyx_t_4 = NULL;
  __pyx_t_10basictypes_int64 __pyx_t_5;
  __Pyx_RefNannySetupContext("__pyx_convert_vector_from_py___pyx_t_10basictypes_int64", 0);

  /* "vector.from_py":47
 * cdef vector[X] __pyx_convert_vector_from_py___pyx_t_10basictypes_int64(object o) except *:
 *     cdef vector[X] v
 *     for item in o:             # <<<<<<<<<<<<<<
 *         v.push_back(<X>item)
 *     return v
 */
  if (likely(PyList_CheckExact(__pyx_v_o)) || PyTuple_CheckExact(__pyx_v_o)) {
    __pyx_t_1 = __pyx_v_o; __Pyx_INCREF(__pyx_t_1); __pyx_t_2 = 0;
    __pyx_t_3 = NULL;
  } else {
    __pyx_t_2 = -1; __pyx_t_1 = PyObject_GetIter(__pyx_v_o); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 47, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_3 = Py_TYPE(__pyx_t_1)->tp_iternext; if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 47, __pyx_L1_error)
  }
  for (;;) {
    if (likely(!__pyx_t_3)) {
      if (likely(PyList_CheckExact(__pyx_t_1))) {
        if (__pyx_t_2 >= PyList_GET_SIZE(__pyx_t_1)) break;
        #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
        __pyx_t_4 = PyList_GET_ITEM(__pyx_t_1, __pyx_t_2); __Pyx_INCREF(__pyx_t_4); __pyx_t_2++; if (unlikely(0 < 0)) __PYX_ERR(1, 47, __pyx_L1_error)
        #else
        __pyx_t_4 = PySequence_ITEM(__pyx_t_1, __pyx_t_2); __pyx_t_2++; if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 47, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_4);
        #endif
      } else {
        if (__pyx_t_2 >= PyTuple_GET_SIZE(__pyx_t_1)) break;
        #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
        __pyx_t_4 = PyTuple_GET_ITEM(__pyx_t_1, __pyx_t_2); __Pyx_INCREF(__pyx_t_4); __pyx_t_2++; if (unlikely(0 < 0)) __PYX_ERR(1, 47, __pyx_L1_error)
        #else
        __pyx_t_4 = PySequence_ITEM(__pyx_t_1, __pyx_t_2); __pyx_t_2++; if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 47, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_4);
        #endif
      }
    } else {
      __pyx_t_4 = __pyx_t_3(__pyx_t_1);
      if (unlikely(!__pyx_t_4)) {
        PyObject* exc_type = PyErr_Occurred();
        if (exc_type) {
          if (likely(__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
          else __PYX_ERR(1, 47, __pyx_L1_error)
        }
        break;
      }
      __Pyx_GOTREF(__pyx_t_4);
    }
    __Pyx_XDECREF_SET(__pyx_v_item, __pyx_t_4);
    __pyx_t_4 = 0;

    /* "vector.from_py":48
 *     cdef vector[X] v
 *     for item in o:
 *         v.push_back(<X>item)             # <<<<<<<<<<<<<<
 *     return v
 * 
 */
    __pyx_t_5 = __Pyx_PyInt_As_int64_t(__pyx_v_item); if (unlikely((__pyx_t_5 == ((int64_t)-1)) && PyErr_Occurred())) __PYX_ERR(1, 48, __pyx_L1_error)
    __pyx_v_v.push_back(((__pyx_t_10basictypes_int64)__pyx_t_5));

    /* "vector.from_py":47
 * cdef vector[X] __pyx_convert_vector_from_py___pyx_t_10basictypes_int64(object o) except *:
 *     cdef vector[X] v
 *     for item in o:             # <<<<<<<<<<<<<<
 *         v.push_back(<X>item)
 *     return v
 */
  }
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "vector.from_py":49
 *     for item in o:
 *         v.push_back(<X>item)
 *     return v             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __pyx_r = __pyx_v_v;
  goto __pyx_L0;

  /* "vector.from_py":45
 * 
 * @cname("__pyx_convert_vector_from_py___pyx_t_10basictypes_int64")
 * cdef vector[X] __pyx_convert_vector_from_py___pyx_t_10basictypes_int64(object o) except *:             # <<<<<<<<<<<<<<
 *     cdef vector[X] v
 *     for item in o:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("vector.from_py.__pyx_convert_vector_from_py___pyx_t_10basictypes_int64", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_pretend_to_initialize(&__pyx_r);
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_item);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static std::vector<std::string>  __pyx_convert_vector_from_py_std_3a__3a_string(PyObject *__pyx_v_o) {
  std::vector<std::string>  __pyx_v_v;
  PyObject *__pyx_v_item = NULL;
  std::vector<std::string>  __pyx_r;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  Py_ssize_t __pyx_t_2;
  PyObject *(*__pyx_t_3)(PyObject *);
  PyObject *__pyx_t_4 = NULL;
  std::string __pyx_t_5;
  __Pyx_RefNannySetupContext("__pyx_convert_vector_from_py_std_3a__3a_string", 0);

  /* "vector.from_py":47
 * cdef vector[X] __pyx_convert_vector_from_py_std_3a__3a_string(object o) except *:
 *     cdef vector[X] v
 *     for item in o:             # <<<<<<<<<<<<<<
 *         v.push_back(<X>item)
 *     return v
 */
  if (likely(PyList_CheckExact(__pyx_v_o)) || PyTuple_CheckExact(__pyx_v_o)) {
    __pyx_t_1 = __pyx_v_o; __Pyx_INCREF(__pyx_t_1); __pyx_t_2 = 0;
    __pyx_t_3 = NULL;
  } else {
    __pyx_t_2 = -1; __pyx_t_1 = PyObject_GetIter(__pyx_v_o); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 47, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_3 = Py_TYPE(__pyx_t_1)->tp_iternext; if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 47, __pyx_L1_error)
  }
  for (;;) {
    if (likely(!__pyx_t_3)) {
      if (likely(PyList_CheckExact(__pyx_t_1))) {
        if (__pyx_t_2 >= PyList_GET_SIZE(__pyx_t_1)) break;
        #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
        __pyx_t_4 = PyList_GET_ITEM(__pyx_t_1, __pyx_t_2); __Pyx_INCREF(__pyx_t_4); __pyx_t_2++; if (unlikely(0 < 0)) __PYX_ERR(1, 47, __pyx_L1_error)
        #else
        __pyx_t_4 = PySequence_ITEM(__pyx_t_1, __pyx_t_2); __pyx_t_2++; if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 47, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_4);
        #endif
      } else {
        if (__pyx_t_2 >= PyTuple_GET_SIZE(__pyx_t_1)) break;
        #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
        __pyx_t_4 = PyTuple_GET_ITEM(__pyx_t_1, __pyx_t_2); __Pyx_INCREF(__pyx_t_4); __pyx_t_2++; if (unlikely(0 < 0)) __PYX_ERR(1, 47, __pyx_L1_error)
        #else
        __pyx_t_4 = PySequence_ITEM(__pyx_t_1, __pyx_t_2); __pyx_t_2++; if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 47, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_4);
        #endif
      }
    } else {
      __pyx_t_4 = __pyx_t_3(__pyx_t_1);
      if (unlikely(!__pyx_t_4)) {
        PyObject* exc_type = PyErr_Occurred();
        if (exc_type) {
          if (likely(__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
          else __PYX_ERR(1, 47, __pyx_L1_error)
        }
        break;
      }
      __Pyx_GOTREF(__pyx_t_4);
    }
    __Pyx_XDECREF_SET(__pyx_v_item, __pyx_t_4);
    __pyx_t_4 = 0;

    /* "vector.from_py":48
 *     cdef vector[X] v
 *     for item in o:
 *         v.push_back(<X>item)             # <<<<<<<<<<<<<<
 *     return v
 * 
 */
    __pyx_t_5 = __pyx_convert_string_from_py_std__in_string(__pyx_v_item); if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 48, __pyx_L1_error)
    __pyx_v_v.push_back(((std::string)__pyx_t_5));

    /* "vector.from_py":47
 * cdef vector[X] __pyx_convert_vector_from_py_std_3a__3a_string(object o) except *:
 *     cdef vector[X] v
 *     for item in o:             # <<<<<<<<<<<<<<
 *         v.push_back(<X>item)
 *     return v
 */
  }
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "vector.from_py":49
 *     for item in o:
 *         v.push_back(<X>item)
 *     return v             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __pyx_r = __pyx_v_v;
  goto __pyx_L0;

  /* "vector.from_py":45
 * 
 * @cname("__pyx_convert_vector_from_py_std_3a__3a_string")
 * cdef vector[X] __pyx_convert_vector_from_py_std_3a__3a_string(object o) except *:             # <<<<<<<<<<<<<<
 *     cdef vector[X] v
 *     for item in o:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("vector.from_py.__pyx_convert_vector_from_py_std_3a__3a_string", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_pretend_to_initialize(&__pyx_r);
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_item);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}
static struct __pyx_vtabstruct_9pywrapfst_Weight __pyx_vtable_9pywrapfst_Weight;

static PyObject *__pyx_tp_new_9pywrapfst_Weight(PyTypeObject *t, CYTHON_UNUSED PyObject *a, CYTHON_UNUSED PyObject *k) {
  struct __pyx_obj_9pywrapfst_Weight *p;
  PyObject *o;
  if (likely((t->tp_flags & Py_TPFLAGS_IS_ABSTRACT) == 0)) {
    o = (*t->tp_alloc)(t, 0);
  } else {
    o = (PyObject *) PyBaseObject_Type.tp_new(t, __pyx_empty_tuple, 0);
  }
  if (unlikely(!o)) return 0;
  p = ((struct __pyx_obj_9pywrapfst_Weight *)o);
  p->__pyx_vtab = __pyx_vtabptr_9pywrapfst_Weight;
  new((void*)&(p->_weight)) std::unique_ptr<fst::script::WeightClass> ();
  return o;
}

static void __pyx_tp_dealloc_9pywrapfst_Weight(PyObject *o) {
  struct __pyx_obj_9pywrapfst_Weight *p = (struct __pyx_obj_9pywrapfst_Weight *)o;
  #if CYTHON_USE_TP_FINALIZE
  if (unlikely(PyType_HasFeature(Py_TYPE(o), Py_TPFLAGS_HAVE_FINALIZE) && Py_TYPE(o)->tp_finalize) && (!PyType_IS_GC(Py_TYPE(o)) || !_PyGC_FINALIZED(o))) {
    if (PyObject_CallFinalizerFromDealloc(o)) return;
  }
  #endif
  __Pyx_call_destructor(p->_weight);
  (*Py_TYPE(o)->tp_free)(o);
}

static PyObject *__pyx_tp_richcompare_9pywrapfst_Weight(PyObject *o1, PyObject *o2, int op) {
  switch (op) {
    case Py_EQ: {
      return __pyx_pw_9pywrapfst_6Weight_17__eq__(o1, o2);
    }
    case Py_NE: {
      return __pyx_pw_9pywrapfst_6Weight_19__ne__(o1, o2);
    }
    default: {
      return __Pyx_NewRef(Py_NotImplemented);
    }
  }
}

static PyMethodDef __pyx_methods_9pywrapfst_Weight[] = {
  {"copy", (PyCFunction)__pyx_pw_9pywrapfst_6Weight_9copy, METH_NOARGS, __pyx_doc_9pywrapfst_6Weight_8copy},
  {"Zero", (PyCFunction)__pyx_pw_9pywrapfst_6Weight_11Zero, METH_O, __pyx_doc_9pywrapfst_6Weight_10Zero},
  {"One", (PyCFunction)__pyx_pw_9pywrapfst_6Weight_13One, METH_O, __pyx_doc_9pywrapfst_6Weight_12One},
  {"NoWeight", (PyCFunction)__pyx_pw_9pywrapfst_6Weight_15NoWeight, METH_O, __pyx_doc_9pywrapfst_6Weight_14NoWeight},
  {"to_string", (PyCFunction)__pyx_pw_9pywrapfst_6Weight_21to_string, METH_NOARGS, 0},
  {"type", (PyCFunction)__pyx_pw_9pywrapfst_6Weight_23type, METH_NOARGS, __pyx_doc_9pywrapfst_6Weight_22type},
  {"__reduce_cython__", (PyCFunction)__pyx_pw_9pywrapfst_6Weight_25__reduce_cython__, METH_NOARGS, 0},
  {"__setstate_cython__", (PyCFunction)__pyx_pw_9pywrapfst_6Weight_27__setstate_cython__, METH_O, 0},
  {0, 0, 0, 0}
};

static PyNumberMethods __pyx_tp_as_number_Weight = {
  0, /*nb_add*/
  0, /*nb_subtract*/
  0, /*nb_multiply*/
  #if PY_MAJOR_VERSION < 3 || (CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX < 0x03050000)
  0, /*nb_divide*/
  #endif
  0, /*nb_remainder*/
  0, /*nb_divmod*/
  0, /*nb_power*/
  0, /*nb_negative*/
  0, /*nb_positive*/
  0, /*nb_absolute*/
  0, /*nb_nonzero*/
  0, /*nb_invert*/
  0, /*nb_lshift*/
  0, /*nb_rshift*/
  0, /*nb_and*/
  0, /*nb_xor*/
  0, /*nb_or*/
  #if PY_MAJOR_VERSION < 3 || (CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX < 0x03050000)
  0, /*nb_coerce*/
  #endif
  0, /*nb_int*/
  #if PY_MAJOR_VERSION < 3
  0, /*nb_long*/
  #else
  0, /*reserved*/
  #endif
  __pyx_pw_9pywrapfst_6Weight_5__float__, /*nb_float*/
  #if PY_MAJOR_VERSION < 3 || (CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX < 0x03050000)
  0, /*nb_oct*/
  #endif
  #if PY_MAJOR_VERSION < 3 || (CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX < 0x03050000)
  0, /*nb_hex*/
  #endif
  0, /*nb_inplace_add*/
  0, /*nb_inplace_subtract*/
  0, /*nb_inplace_multiply*/
  #if PY_MAJOR_VERSION < 3 || (CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX < 0x03050000)
  0, /*nb_inplace_divide*/
  #endif
  0, /*nb_inplace_remainder*/
  0, /*nb_inplace_power*/
  0, /*nb_inplace_lshift*/
  0, /*nb_inplace_rshift*/
  0, /*nb_inplace_and*/
  0, /*nb_inplace_xor*/
  0, /*nb_inplace_or*/
  0, /*nb_floor_divide*/
  0, /*nb_true_divide*/
  0, /*nb_inplace_floor_divide*/
  0, /*nb_inplace_true_divide*/
  0, /*nb_index*/
  #if PY_VERSION_HEX >= 0x03050000
  0, /*nb_matrix_multiply*/
  #endif
  #if PY_VERSION_HEX >= 0x03050000
  0, /*nb_inplace_matrix_multiply*/
  #endif
};

static PyTypeObject __pyx_type_9pywrapfst_Weight = {
  PyVarObject_HEAD_INIT(0, 0)
  "pywrapfst.Weight", /*tp_name*/
  sizeof(struct __pyx_obj_9pywrapfst_Weight), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_9pywrapfst_Weight, /*tp_dealloc*/
  0, /*tp_print*/
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  __pyx_pw_9pywrapfst_6Weight_1__repr__, /*tp_repr*/
  &__pyx_tp_as_number_Weight, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  __pyx_pw_9pywrapfst_6Weight_3__str__, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE, /*tp_flags*/
  "\n  Weight(weight_type, weight_string)\n\n  FST weight class.\n\n  This class represents an FST weight. When passed as an argument to an FST\n  operation, it should have the weight type of the input FST(s) to said\n  operation.\n\n  Args:\n    weight_type: A string indicating the weight type.\n    weight_string: A string indicating the underlying weight.\n\n  Raises:\n    FstArgError: Weight type not found.\n    FstBadWeightError: Invalid weight.\n  ", /*tp_doc*/
  0, /*tp_traverse*/
  0, /*tp_clear*/
  __pyx_tp_richcompare_9pywrapfst_Weight, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  __pyx_methods_9pywrapfst_Weight, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  __pyx_pw_9pywrapfst_6Weight_7__init__, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_9pywrapfst_Weight, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
};
static struct __pyx_vtabstruct_9pywrapfst__SymbolTable __pyx_vtable_9pywrapfst__SymbolTable;

static PyObject *__pyx_tp_new_9pywrapfst__SymbolTable(PyTypeObject *t, CYTHON_UNUSED PyObject *a, CYTHON_UNUSED PyObject *k) {
  struct __pyx_obj_9pywrapfst__SymbolTable *p;
  PyObject *o;
  if (likely((t->tp_flags & Py_TPFLAGS_IS_ABSTRACT) == 0)) {
    o = (*t->tp_alloc)(t, 0);
  } else {
    o = (PyObject *) PyBaseObject_Type.tp_new(t, __pyx_empty_tuple, 0);
  }
  if (unlikely(!o)) return 0;
  p = ((struct __pyx_obj_9pywrapfst__SymbolTable *)o);
  p->__pyx_vtab = __pyx_vtabptr_9pywrapfst__SymbolTable;
  return o;
}

static void __pyx_tp_dealloc_9pywrapfst__SymbolTable(PyObject *o) {
  #if CYTHON_USE_TP_FINALIZE
  if (unlikely(PyType_HasFeature(Py_TYPE(o), Py_TPFLAGS_HAVE_FINALIZE) && Py_TYPE(o)->tp_finalize) && (!PyType_IS_GC(Py_TYPE(o)) || !_PyGC_FINALIZED(o))) {
    if (PyObject_CallFinalizerFromDealloc(o)) return;
  }
  #endif
  (*Py_TYPE(o)->tp_free)(o);
}

static PyMethodDef __pyx_methods_9pywrapfst__SymbolTable[] = {
  {"available_key", (PyCFunction)__pyx_pw_9pywrapfst_12_SymbolTable_5available_key, METH_NOARGS, __pyx_doc_9pywrapfst_12_SymbolTable_4available_key},
  {"checksum", (PyCFunction)__pyx_pw_9pywrapfst_12_SymbolTable_7checksum, METH_NOARGS, __pyx_doc_9pywrapfst_12_SymbolTable_6checksum},
  {"copy", (PyCFunction)__pyx_pw_9pywrapfst_12_SymbolTable_9copy, METH_NOARGS, __pyx_doc_9pywrapfst_12_SymbolTable_8copy},
  {"find", (PyCFunction)__pyx_pw_9pywrapfst_12_SymbolTable_11find, METH_O, __pyx_doc_9pywrapfst_12_SymbolTable_10find},
  {"get_nth_key", (PyCFunction)__pyx_pw_9pywrapfst_12_SymbolTable_13get_nth_key, METH_O, __pyx_doc_9pywrapfst_12_SymbolTable_12get_nth_key},
  {"labeled_checksum", (PyCFunction)__pyx_pw_9pywrapfst_12_SymbolTable_15labeled_checksum, METH_NOARGS, __pyx_doc_9pywrapfst_12_SymbolTable_14labeled_checksum},
  {"member", (PyCFunction)__pyx_pw_9pywrapfst_12_SymbolTable_17member, METH_O, __pyx_doc_9pywrapfst_12_SymbolTable_16member},
  {"name", (PyCFunction)__pyx_pw_9pywrapfst_12_SymbolTable_21name, METH_NOARGS, __pyx_doc_9pywrapfst_12_SymbolTable_20name},
  {"num_symbols", (PyCFunction)__pyx_pw_9pywrapfst_12_SymbolTable_23num_symbols, METH_NOARGS, __pyx_doc_9pywrapfst_12_SymbolTable_22num_symbols},
  {"write", (PyCFunction)__pyx_pw_9pywrapfst_12_SymbolTable_25write, METH_O, __pyx_doc_9pywrapfst_12_SymbolTable_24write},
  {"write_text", (PyCFunction)__pyx_pw_9pywrapfst_12_SymbolTable_27write_text, METH_O, __pyx_doc_9pywrapfst_12_SymbolTable_26write_text},
  {"__reduce_cython__", (PyCFunction)__pyx_pw_9pywrapfst_12_SymbolTable_29__reduce_cython__, METH_NOARGS, 0},
  {"__setstate_cython__", (PyCFunction)__pyx_pw_9pywrapfst_12_SymbolTable_31__setstate_cython__, METH_O, 0},
  {0, 0, 0, 0}
};

static PySequenceMethods __pyx_tp_as_sequence__SymbolTable = {
  0, /*sq_length*/
  0, /*sq_concat*/
  0, /*sq_repeat*/
  0, /*sq_item*/
  0, /*sq_slice*/
  0, /*sq_ass_item*/
  0, /*sq_ass_slice*/
  __pyx_pw_9pywrapfst_12_SymbolTable_19__contains__, /*sq_contains*/
  0, /*sq_inplace_concat*/
  0, /*sq_inplace_repeat*/
};

static PyTypeObject __pyx_type_9pywrapfst__SymbolTable = {
  PyVarObject_HEAD_INIT(0, 0)
  "pywrapfst._SymbolTable", /*tp_name*/
  sizeof(struct __pyx_obj_9pywrapfst__SymbolTable), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_9pywrapfst__SymbolTable, /*tp_dealloc*/
  0, /*tp_print*/
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  &__pyx_tp_as_sequence__SymbolTable, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE, /*tp_flags*/
  "\n  (No constructor.)\n\n  Base class for the symbol table hierarchy.\n\n  This class is the base class for SymbolTable. It has a \"deleted\" constructor\n  and implementations for the const methods of the wrapped SymbolTable.\n  ", /*tp_doc*/
  0, /*tp_traverse*/
  0, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  __pyx_pw_9pywrapfst_12_SymbolTable_3__iter__, /*tp_iter*/
  0, /*tp_iternext*/
  __pyx_methods_9pywrapfst__SymbolTable, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  __pyx_pw_9pywrapfst_12_SymbolTable_1__init__, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_9pywrapfst__SymbolTable, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
};
static struct __pyx_vtabstruct_9pywrapfst__EncodeMapperSymbolTable __pyx_vtable_9pywrapfst__EncodeMapperSymbolTable;

static PyObject *__pyx_tp_new_9pywrapfst__EncodeMapperSymbolTable(PyTypeObject *t, PyObject *a, PyObject *k) {
  struct __pyx_obj_9pywrapfst__EncodeMapperSymbolTable *p;
  PyObject *o = __pyx_tp_new_9pywrapfst__SymbolTable(t, a, k);
  if (unlikely(!o)) return 0;
  p = ((struct __pyx_obj_9pywrapfst__EncodeMapperSymbolTable *)o);
  p->__pyx_base.__pyx_vtab = (struct __pyx_vtabstruct_9pywrapfst__SymbolTable*)__pyx_vtabptr_9pywrapfst__EncodeMapperSymbolTable;
  new((void*)&(p->_encoder)) std::shared_ptr<fst::script::EncodeMapperClass> ();
  return o;
}

static void __pyx_tp_dealloc_9pywrapfst__EncodeMapperSymbolTable(PyObject *o) {
  struct __pyx_obj_9pywrapfst__EncodeMapperSymbolTable *p = (struct __pyx_obj_9pywrapfst__EncodeMapperSymbolTable *)o;
  #if CYTHON_USE_TP_FINALIZE
  if (unlikely(PyType_HasFeature(Py_TYPE(o), Py_TPFLAGS_HAVE_FINALIZE) && Py_TYPE(o)->tp_finalize) && (!PyType_IS_GC(Py_TYPE(o)) || !_PyGC_FINALIZED(o))) {
    if (PyObject_CallFinalizerFromDealloc(o)) return;
  }
  #endif
  __Pyx_call_destructor(p->_encoder);
  __pyx_tp_dealloc_9pywrapfst__SymbolTable(o);
}

static PyMethodDef __pyx_methods_9pywrapfst__EncodeMapperSymbolTable[] = {
  {"__reduce_cython__", (PyCFunction)__pyx_pw_9pywrapfst_24_EncodeMapperSymbolTable_3__reduce_cython__, METH_NOARGS, 0},
  {"__setstate_cython__", (PyCFunction)__pyx_pw_9pywrapfst_24_EncodeMapperSymbolTable_5__setstate_cython__, METH_O, 0},
  {0, 0, 0, 0}
};

static PyTypeObject __pyx_type_9pywrapfst__EncodeMapperSymbolTable = {
  PyVarObject_HEAD_INIT(0, 0)
  "pywrapfst._EncodeMapperSymbolTable", /*tp_name*/
  sizeof(struct __pyx_obj_9pywrapfst__EncodeMapperSymbolTable), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_9pywrapfst__EncodeMapperSymbolTable, /*tp_dealloc*/
  0, /*tp_print*/
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  __pyx_pw_9pywrapfst_24_EncodeMapperSymbolTable_1__repr__, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE, /*tp_flags*/
  "\n  (No constructor.)\n\n  Immutable SymbolTable class for tables stored in an EncodeMapper.\n\n  This class wraps a library const SymbolTable and exposes const methods of the\n  wrapped object. It is only to be returned by method, never constructed\n  directly.\n  ", /*tp_doc*/
  0, /*tp_traverse*/
  0, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  #if CYTHON_COMPILING_IN_PYPY
  __pyx_pw_9pywrapfst_12_SymbolTable_3__iter__, /*tp_iter*/
  #else
  0, /*tp_iter*/
  #endif
  0, /*tp_iternext*/
  __pyx_methods_9pywrapfst__EncodeMapperSymbolTable, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  #if CYTHON_COMPILING_IN_PYPY
  __pyx_pw_9pywrapfst_12_SymbolTable_1__init__, /*tp_init*/
  #else
  0, /*tp_init*/
  #endif
  0, /*tp_alloc*/
  __pyx_tp_new_9pywrapfst__EncodeMapperSymbolTable, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
};
static struct __pyx_vtabstruct_9pywrapfst__FstSymbolTable __pyx_vtable_9pywrapfst__FstSymbolTable;

static PyObject *__pyx_tp_new_9pywrapfst__FstSymbolTable(PyTypeObject *t, PyObject *a, PyObject *k) {
  struct __pyx_obj_9pywrapfst__FstSymbolTable *p;
  PyObject *o = __pyx_tp_new_9pywrapfst__SymbolTable(t, a, k);
  if (unlikely(!o)) return 0;
  p = ((struct __pyx_obj_9pywrapfst__FstSymbolTable *)o);
  p->__pyx_base.__pyx_vtab = (struct __pyx_vtabstruct_9pywrapfst__SymbolTable*)__pyx_vtabptr_9pywrapfst__FstSymbolTable;
  new((void*)&(p->_fst)) std::shared_ptr<fst::script::FstClass> ();
  return o;
}

static void __pyx_tp_dealloc_9pywrapfst__FstSymbolTable(PyObject *o) {
  struct __pyx_obj_9pywrapfst__FstSymbolTable *p = (struct __pyx_obj_9pywrapfst__FstSymbolTable *)o;
  #if CYTHON_USE_TP_FINALIZE
  if (unlikely(PyType_HasFeature(Py_TYPE(o), Py_TPFLAGS_HAVE_FINALIZE) && Py_TYPE(o)->tp_finalize) && (!PyType_IS_GC(Py_TYPE(o)) || !_PyGC_FINALIZED(o))) {
    if (PyObject_CallFinalizerFromDealloc(o)) return;
  }
  #endif
  __Pyx_call_destructor(p->_fst);
  __pyx_tp_dealloc_9pywrapfst__SymbolTable(o);
}

static PyMethodDef __pyx_methods_9pywrapfst__FstSymbolTable[] = {
  {"__reduce_cython__", (PyCFunction)__pyx_pw_9pywrapfst_15_FstSymbolTable_3__reduce_cython__, METH_NOARGS, 0},
  {"__setstate_cython__", (PyCFunction)__pyx_pw_9pywrapfst_15_FstSymbolTable_5__setstate_cython__, METH_O, 0},
  {0, 0, 0, 0}
};

static PyTypeObject __pyx_type_9pywrapfst__FstSymbolTable = {
  PyVarObject_HEAD_INIT(0, 0)
  "pywrapfst._FstSymbolTable", /*tp_name*/
  sizeof(struct __pyx_obj_9pywrapfst__FstSymbolTable), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_9pywrapfst__FstSymbolTable, /*tp_dealloc*/
  0, /*tp_print*/
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  __pyx_pw_9pywrapfst_15_FstSymbolTable_1__repr__, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE, /*tp_flags*/
  "\n  (No constructor.)\n\n  Mutable SymbolTable class for tables stored in a mutable FST.\n\n  This class wraps a library SymbolTable and exposes methods of the wrapped\n  object. It is only to be returned by method, never constructed directly.\n  ", /*tp_doc*/
  0, /*tp_traverse*/
  0, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  #if CYTHON_COMPILING_IN_PYPY
  __pyx_pw_9pywrapfst_12_SymbolTable_3__iter__, /*tp_iter*/
  #else
  0, /*tp_iter*/
  #endif
  0, /*tp_iternext*/
  __pyx_methods_9pywrapfst__FstSymbolTable, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  #if CYTHON_COMPILING_IN_PYPY
  __pyx_pw_9pywrapfst_12_SymbolTable_1__init__, /*tp_init*/
  #else
  0, /*tp_init*/
  #endif
  0, /*tp_alloc*/
  __pyx_tp_new_9pywrapfst__FstSymbolTable, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
};
static struct __pyx_vtabstruct_9pywrapfst__MutableSymbolTable __pyx_vtable_9pywrapfst__MutableSymbolTable;

static PyObject *__pyx_tp_new_9pywrapfst__MutableSymbolTable(PyTypeObject *t, PyObject *a, PyObject *k) {
  struct __pyx_obj_9pywrapfst__MutableSymbolTable *p;
  PyObject *o = __pyx_tp_new_9pywrapfst__SymbolTable(t, a, k);
  if (unlikely(!o)) return 0;
  p = ((struct __pyx_obj_9pywrapfst__MutableSymbolTable *)o);
  p->__pyx_base.__pyx_vtab = (struct __pyx_vtabstruct_9pywrapfst__SymbolTable*)__pyx_vtabptr_9pywrapfst__MutableSymbolTable;
  return o;
}

static PyMethodDef __pyx_methods_9pywrapfst__MutableSymbolTable[] = {
  {"add_symbol", (PyCFunction)__pyx_pw_9pywrapfst_19_MutableSymbolTable_1add_symbol, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9pywrapfst_19_MutableSymbolTable_add_symbol},
  {"add_table", (PyCFunction)__pyx_pw_9pywrapfst_19_MutableSymbolTable_3add_table, METH_O, __pyx_doc_9pywrapfst_19_MutableSymbolTable_2add_table},
  {"set_name", (PyCFunction)__pyx_pw_9pywrapfst_19_MutableSymbolTable_5set_name, METH_O, 0},
  {"__reduce_cython__", (PyCFunction)__pyx_pw_9pywrapfst_19_MutableSymbolTable_7__reduce_cython__, METH_NOARGS, 0},
  {"__setstate_cython__", (PyCFunction)__pyx_pw_9pywrapfst_19_MutableSymbolTable_9__setstate_cython__, METH_O, 0},
  {0, 0, 0, 0}
};

static PyTypeObject __pyx_type_9pywrapfst__MutableSymbolTable = {
  PyVarObject_HEAD_INIT(0, 0)
  "pywrapfst._MutableSymbolTable", /*tp_name*/
  sizeof(struct __pyx_obj_9pywrapfst__MutableSymbolTable), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_9pywrapfst__SymbolTable, /*tp_dealloc*/
  0, /*tp_print*/
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE, /*tp_flags*/
  "\n  (No constructor.)\n\n  Base class for mutable symbol tables.\n\n  This class is the base class for a mutable SymbolTable. It has a \"deleted\"\n  constructor and implementations of all methods of the wrapped SymbolTable.\n  ", /*tp_doc*/
  0, /*tp_traverse*/
  0, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  #if CYTHON_COMPILING_IN_PYPY
  __pyx_pw_9pywrapfst_12_SymbolTable_3__iter__, /*tp_iter*/
  #else
  0, /*tp_iter*/
  #endif
  0, /*tp_iternext*/
  __pyx_methods_9pywrapfst__MutableSymbolTable, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  #if CYTHON_COMPILING_IN_PYPY
  __pyx_pw_9pywrapfst_12_SymbolTable_1__init__, /*tp_init*/
  #else
  0, /*tp_init*/
  #endif
  0, /*tp_alloc*/
  __pyx_tp_new_9pywrapfst__MutableSymbolTable, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
};
static struct __pyx_vtabstruct_9pywrapfst__MutableFstSymbolTable __pyx_vtable_9pywrapfst__MutableFstSymbolTable;

static PyObject *__pyx_tp_new_9pywrapfst__MutableFstSymbolTable(PyTypeObject *t, PyObject *a, PyObject *k) {
  struct __pyx_obj_9pywrapfst__MutableFstSymbolTable *p;
  PyObject *o = __pyx_tp_new_9pywrapfst__MutableSymbolTable(t, a, k);
  if (unlikely(!o)) return 0;
  p = ((struct __pyx_obj_9pywrapfst__MutableFstSymbolTable *)o);
  p->__pyx_base.__pyx_base.__pyx_vtab = (struct __pyx_vtabstruct_9pywrapfst__SymbolTable*)__pyx_vtabptr_9pywrapfst__MutableFstSymbolTable;
  new((void*)&(p->_mfst)) std::shared_ptr<fst::script::MutableFstClass> ();
  return o;
}

static void __pyx_tp_dealloc_9pywrapfst__MutableFstSymbolTable(PyObject *o) {
  struct __pyx_obj_9pywrapfst__MutableFstSymbolTable *p = (struct __pyx_obj_9pywrapfst__MutableFstSymbolTable *)o;
  #if CYTHON_USE_TP_FINALIZE
  if (unlikely(PyType_HasFeature(Py_TYPE(o), Py_TPFLAGS_HAVE_FINALIZE) && Py_TYPE(o)->tp_finalize) && (!PyType_IS_GC(Py_TYPE(o)) || !_PyGC_FINALIZED(o))) {
    if (PyObject_CallFinalizerFromDealloc(o)) return;
  }
  #endif
  __Pyx_call_destructor(p->_mfst);
  __pyx_tp_dealloc_9pywrapfst__SymbolTable(o);
}

static PyMethodDef __pyx_methods_9pywrapfst__MutableFstSymbolTable[] = {
  {"__reduce_cython__", (PyCFunction)__pyx_pw_9pywrapfst_22_MutableFstSymbolTable_3__reduce_cython__, METH_NOARGS, 0},
  {"__setstate_cython__", (PyCFunction)__pyx_pw_9pywrapfst_22_MutableFstSymbolTable_5__setstate_cython__, METH_O, 0},
  {0, 0, 0, 0}
};

static PyTypeObject __pyx_type_9pywrapfst__MutableFstSymbolTable = {
  PyVarObject_HEAD_INIT(0, 0)
  "pywrapfst._MutableFstSymbolTable", /*tp_name*/
  sizeof(struct __pyx_obj_9pywrapfst__MutableFstSymbolTable), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_9pywrapfst__MutableFstSymbolTable, /*tp_dealloc*/
  0, /*tp_print*/
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  __pyx_pw_9pywrapfst_22_MutableFstSymbolTable_1__repr__, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE, /*tp_flags*/
  "\n  (No constructor.)\n\n  Mutable SymbolTable assigned to an FST.\n  ", /*tp_doc*/
  0, /*tp_traverse*/
  0, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  #if CYTHON_COMPILING_IN_PYPY
  __pyx_pw_9pywrapfst_12_SymbolTable_3__iter__, /*tp_iter*/
  #else
  0, /*tp_iter*/
  #endif
  0, /*tp_iternext*/
  __pyx_methods_9pywrapfst__MutableFstSymbolTable, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  #if CYTHON_COMPILING_IN_PYPY
  __pyx_pw_9pywrapfst_12_SymbolTable_1__init__, /*tp_init*/
  #else
  0, /*tp_init*/
  #endif
  0, /*tp_alloc*/
  __pyx_tp_new_9pywrapfst__MutableFstSymbolTable, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
};
static struct __pyx_vtabstruct_9pywrapfst_SymbolTable __pyx_vtable_9pywrapfst_SymbolTable;

static PyObject *__pyx_tp_new_9pywrapfst_SymbolTable(PyTypeObject *t, PyObject *a, PyObject *k) {
  struct __pyx_obj_9pywrapfst_SymbolTable *p;
  PyObject *o = __pyx_tp_new_9pywrapfst__MutableSymbolTable(t, a, k);
  if (unlikely(!o)) return 0;
  p = ((struct __pyx_obj_9pywrapfst_SymbolTable *)o);
  p->__pyx_base.__pyx_base.__pyx_vtab = (struct __pyx_vtabstruct_9pywrapfst__SymbolTable*)__pyx_vtabptr_9pywrapfst_SymbolTable;
  new((void*)&(p->_smart_table)) std::unique_ptr<fst::SymbolTable> ();
  return o;
}

static void __pyx_tp_dealloc_9pywrapfst_SymbolTable(PyObject *o) {
  struct __pyx_obj_9pywrapfst_SymbolTable *p = (struct __pyx_obj_9pywrapfst_SymbolTable *)o;
  #if CYTHON_USE_TP_FINALIZE
  if (unlikely(PyType_HasFeature(Py_TYPE(o), Py_TPFLAGS_HAVE_FINALIZE) && Py_TYPE(o)->tp_finalize) && (!PyType_IS_GC(Py_TYPE(o)) || !_PyGC_FINALIZED(o))) {
    if (PyObject_CallFinalizerFromDealloc(o)) return;
  }
  #endif
  __Pyx_call_destructor(p->_smart_table);
  __pyx_tp_dealloc_9pywrapfst__SymbolTable(o);
}

static PyMethodDef __pyx_methods_9pywrapfst_SymbolTable[] = {
  {"read", (PyCFunction)__pyx_pw_9pywrapfst_11SymbolTable_5read, METH_O, __pyx_doc_9pywrapfst_11SymbolTable_4read},
  {"read_text", (PyCFunction)__pyx_pw_9pywrapfst_11SymbolTable_7read_text, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9pywrapfst_11SymbolTable_6read_text},
  {"read_fst", (PyCFunction)__pyx_pw_9pywrapfst_11SymbolTable_9read_fst, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9pywrapfst_11SymbolTable_8read_fst},
  {"__reduce_cython__", (PyCFunction)__pyx_pw_9pywrapfst_11SymbolTable_11__reduce_cython__, METH_NOARGS, 0},
  {"__setstate_cython__", (PyCFunction)__pyx_pw_9pywrapfst_11SymbolTable_13__setstate_cython__, METH_O, 0},
  {0, 0, 0, 0}
};

static PyTypeObject __pyx_type_9pywrapfst_SymbolTable = {
  PyVarObject_HEAD_INIT(0, 0)
  "pywrapfst.SymbolTable", /*tp_name*/
  sizeof(struct __pyx_obj_9pywrapfst_SymbolTable), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_9pywrapfst_SymbolTable, /*tp_dealloc*/
  0, /*tp_print*/
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  __pyx_pw_9pywrapfst_11SymbolTable_1__repr__, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE, /*tp_flags*/
  "\n  SymbolTable(name=\"<unspecified>\")\n\n  Mutable SymbolTable class.\n\n  This class wraps the library SymbolTable and exposes both const (i.e.,\n  access) and non-const (i.e., mutation) methods of wrapped object.\n\n  Unlike other classes in the hierarchy, it has a working constructor and can be\n  used to programmatically construct a SymbolTable in memory.\n\n  Args:\n    name: An optional string indicating the table's name.\n  ", /*tp_doc*/
  0, /*tp_traverse*/
  0, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  #if CYTHON_COMPILING_IN_PYPY
  __pyx_pw_9pywrapfst_12_SymbolTable_3__iter__, /*tp_iter*/
  #else
  0, /*tp_iter*/
  #endif
  0, /*tp_iternext*/
  __pyx_methods_9pywrapfst_SymbolTable, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  __pyx_pw_9pywrapfst_11SymbolTable_3__init__, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_9pywrapfst_SymbolTable, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
};
static struct __pyx_vtabstruct_9pywrapfst_SymbolTableIterator __pyx_vtable_9pywrapfst_SymbolTableIterator;

static PyObject *__pyx_tp_new_9pywrapfst_SymbolTableIterator(PyTypeObject *t, CYTHON_UNUSED PyObject *a, CYTHON_UNUSED PyObject *k) {
  struct __pyx_obj_9pywrapfst_SymbolTableIterator *p;
  PyObject *o;
  if (likely((t->tp_flags & Py_TPFLAGS_IS_ABSTRACT) == 0)) {
    o = (*t->tp_alloc)(t, 0);
  } else {
    o = (PyObject *) PyBaseObject_Type.tp_new(t, __pyx_empty_tuple, 0);
  }
  if (unlikely(!o)) return 0;
  p = ((struct __pyx_obj_9pywrapfst_SymbolTableIterator *)o);
  p->__pyx_vtab = __pyx_vtabptr_9pywrapfst_SymbolTableIterator;
  new((void*)&(p->_table)) std::shared_ptr<fst::SymbolTable> ();
  new((void*)&(p->_siter)) std::unique_ptr<fst::SymbolTableIterator> ();
  return o;
}

static void __pyx_tp_dealloc_9pywrapfst_SymbolTableIterator(PyObject *o) {
  struct __pyx_obj_9pywrapfst_SymbolTableIterator *p = (struct __pyx_obj_9pywrapfst_SymbolTableIterator *)o;
  #if CYTHON_USE_TP_FINALIZE
  if (unlikely(PyType_HasFeature(Py_TYPE(o), Py_TPFLAGS_HAVE_FINALIZE) && Py_TYPE(o)->tp_finalize) && (!PyType_IS_GC(Py_TYPE(o)) || !_PyGC_FINALIZED(o))) {
    if (PyObject_CallFinalizerFromDealloc(o)) return;
  }
  #endif
  __Pyx_call_destructor(p->_table);
  __Pyx_call_destructor(p->_siter);
  (*Py_TYPE(o)->tp_free)(o);
}

static PyMethodDef __pyx_methods_9pywrapfst_SymbolTableIterator[] = {
  {"__next__", (PyCFunction)__pyx_pw_9pywrapfst_19SymbolTableIterator_7__next__, METH_NOARGS|METH_COEXIST, 0},
  {"done", (PyCFunction)__pyx_pw_9pywrapfst_19SymbolTableIterator_9done, METH_NOARGS, __pyx_doc_9pywrapfst_19SymbolTableIterator_8done},
  {"next", (PyCFunction)__pyx_pw_9pywrapfst_19SymbolTableIterator_11next, METH_NOARGS, __pyx_doc_9pywrapfst_19SymbolTableIterator_10next},
  {"reset", (PyCFunction)__pyx_pw_9pywrapfst_19SymbolTableIterator_13reset, METH_NOARGS, __pyx_doc_9pywrapfst_19SymbolTableIterator_12reset},
  {"symbol", (PyCFunction)__pyx_pw_9pywrapfst_19SymbolTableIterator_15symbol, METH_NOARGS, __pyx_doc_9pywrapfst_19SymbolTableIterator_14symbol},
  {"value", (PyCFunction)__pyx_pw_9pywrapfst_19SymbolTableIterator_17value, METH_NOARGS, __pyx_doc_9pywrapfst_19SymbolTableIterator_16value},
  {"__reduce_cython__", (PyCFunction)__pyx_pw_9pywrapfst_19SymbolTableIterator_19__reduce_cython__, METH_NOARGS, 0},
  {"__setstate_cython__", (PyCFunction)__pyx_pw_9pywrapfst_19SymbolTableIterator_21__setstate_cython__, METH_O, 0},
  {0, 0, 0, 0}
};

static PyTypeObject __pyx_type_9pywrapfst_SymbolTableIterator = {
  PyVarObject_HEAD_INIT(0, 0)
  "pywrapfst.SymbolTableIterator", /*tp_name*/
  sizeof(struct __pyx_obj_9pywrapfst_SymbolTableIterator), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_9pywrapfst_SymbolTableIterator, /*tp_dealloc*/
  0, /*tp_print*/
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  __pyx_pw_9pywrapfst_19SymbolTableIterator_1__repr__, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE, /*tp_flags*/
  "\n  SymbolTableIterator(syms)\n\n  This class is used for iterating over a symbol table.\n  ", /*tp_doc*/
  0, /*tp_traverse*/
  0, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  __pyx_pw_9pywrapfst_19SymbolTableIterator_5__iter__, /*tp_iter*/
  __pyx_pw_9pywrapfst_19SymbolTableIterator_7__next__, /*tp_iternext*/
  __pyx_methods_9pywrapfst_SymbolTableIterator, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  __pyx_pw_9pywrapfst_19SymbolTableIterator_3__init__, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_9pywrapfst_SymbolTableIterator, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
};
static struct __pyx_vtabstruct_9pywrapfst_EncodeMapper __pyx_vtable_9pywrapfst_EncodeMapper;

static PyObject *__pyx_tp_new_9pywrapfst_EncodeMapper(PyTypeObject *t, CYTHON_UNUSED PyObject *a, CYTHON_UNUSED PyObject *k) {
  struct __pyx_obj_9pywrapfst_EncodeMapper *p;
  PyObject *o;
  if (likely((t->tp_flags & Py_TPFLAGS_IS_ABSTRACT) == 0)) {
    o = (*t->tp_alloc)(t, 0);
  } else {
    o = (PyObject *) PyBaseObject_Type.tp_new(t, __pyx_empty_tuple, 0);
  }
  if (unlikely(!o)) return 0;
  p = ((struct __pyx_obj_9pywrapfst_EncodeMapper *)o);
  p->__pyx_vtab = __pyx_vtabptr_9pywrapfst_EncodeMapper;
  new((void*)&(p->_encoder)) std::shared_ptr<fst::script::EncodeMapperClass> ();
  return o;
}

static void __pyx_tp_dealloc_9pywrapfst_EncodeMapper(PyObject *o) {
  struct __pyx_obj_9pywrapfst_EncodeMapper *p = (struct __pyx_obj_9pywrapfst_EncodeMapper *)o;
  #if CYTHON_USE_TP_FINALIZE
  if (unlikely(PyType_HasFeature(Py_TYPE(o), Py_TPFLAGS_HAVE_FINALIZE) && Py_TYPE(o)->tp_finalize) && (!PyType_IS_GC(Py_TYPE(o)) || !_PyGC_FINALIZED(o))) {
    if (PyObject_CallFinalizerFromDealloc(o)) return;
  }
  #endif
  __Pyx_call_destructor(p->_encoder);
  (*Py_TYPE(o)->tp_free)(o);
}

static PyMethodDef __pyx_methods_9pywrapfst_EncodeMapper[] = {
  {"arc_type", (PyCFunction)__pyx_pw_9pywrapfst_12EncodeMapper_5arc_type, METH_NOARGS, __pyx_doc_9pywrapfst_12EncodeMapper_4arc_type},
  {"flags", (PyCFunction)__pyx_pw_9pywrapfst_12EncodeMapper_9flags, METH_NOARGS, __pyx_doc_9pywrapfst_12EncodeMapper_8flags},
  {"input_symbols", (PyCFunction)__pyx_pw_9pywrapfst_12EncodeMapper_11input_symbols, METH_NOARGS, __pyx_doc_9pywrapfst_12EncodeMapper_10input_symbols},
  {"output_symbols", (PyCFunction)__pyx_pw_9pywrapfst_12EncodeMapper_13output_symbols, METH_NOARGS, __pyx_doc_9pywrapfst_12EncodeMapper_12output_symbols},
  {"properties", (PyCFunction)__pyx_pw_9pywrapfst_12EncodeMapper_15properties, METH_O, __pyx_doc_9pywrapfst_12EncodeMapper_14properties},
  {"set_input_symbols", (PyCFunction)__pyx_pw_9pywrapfst_12EncodeMapper_17set_input_symbols, METH_O, __pyx_doc_9pywrapfst_12EncodeMapper_16set_input_symbols},
  {"set_output_symbols", (PyCFunction)__pyx_pw_9pywrapfst_12EncodeMapper_19set_output_symbols, METH_O, __pyx_doc_9pywrapfst_12EncodeMapper_18set_output_symbols},
  {"weight_type", (PyCFunction)__pyx_pw_9pywrapfst_12EncodeMapper_21weight_type, METH_NOARGS, __pyx_doc_9pywrapfst_12EncodeMapper_20weight_type},
  {"__reduce_cython__", (PyCFunction)__pyx_pw_9pywrapfst_12EncodeMapper_23__reduce_cython__, METH_NOARGS, 0},
  {"__setstate_cython__", (PyCFunction)__pyx_pw_9pywrapfst_12EncodeMapper_25__setstate_cython__, METH_O, 0},
  {0, 0, 0, 0}
};

static PyTypeObject __pyx_type_9pywrapfst_EncodeMapper = {
  PyVarObject_HEAD_INIT(0, 0)
  "pywrapfst.EncodeMapper", /*tp_name*/
  sizeof(struct __pyx_obj_9pywrapfst_EncodeMapper), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_9pywrapfst_EncodeMapper, /*tp_dealloc*/
  0, /*tp_print*/
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  __pyx_pw_9pywrapfst_12EncodeMapper_1__repr__, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  __pyx_pw_9pywrapfst_12EncodeMapper_7__call__, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE, /*tp_flags*/
  "\n  EncodeMapper(arc_type=\"standard\", encode_labels=False, encode_weights=False)\n\n  Arc encoder class, wrapping EncodeMapperClass.\n\n  This class provides an object which can be used to encode or decode FST arcs.\n  This is most useful to convert an FST to an unweighted acceptor, on which\n  some FST operations are more efficient, and then decoding the FST afterwards.\n\n  To use an instance of this class to encode or decode a mutable FST, pass it\n  as the first argument to the FST instance methods `encode` and `decode`.\n\n  For implementational reasons, it is not currently possible to use an encoder\n  on disk to construct this class.\n\n  Args:\n    arc_type: A string indicating the arc type.\n    encode_labels: Should labels be encoded?\n    encode_weights: Should weights be encoded?\n  ", /*tp_doc*/
  0, /*tp_traverse*/
  0, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  __pyx_methods_9pywrapfst_EncodeMapper, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  __pyx_pw_9pywrapfst_12EncodeMapper_3__init__, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_9pywrapfst_EncodeMapper, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
};
static struct __pyx_vtabstruct_9pywrapfst__Fst __pyx_vtable_9pywrapfst__Fst;

static PyObject *__pyx_tp_new_9pywrapfst__Fst(PyTypeObject *t, CYTHON_UNUSED PyObject *a, CYTHON_UNUSED PyObject *k) {
  struct __pyx_obj_9pywrapfst__Fst *p;
  PyObject *o;
  if (likely((t->tp_flags & Py_TPFLAGS_IS_ABSTRACT) == 0)) {
    o = (*t->tp_alloc)(t, 0);
  } else {
    o = (PyObject *) PyBaseObject_Type.tp_new(t, __pyx_empty_tuple, 0);
  }
  if (unlikely(!o)) return 0;
  p = ((struct __pyx_obj_9pywrapfst__Fst *)o);
  p->__pyx_vtab = __pyx_vtabptr_9pywrapfst__Fst;
  new((void*)&(p->_fst)) std::shared_ptr<fst::script::FstClass> ();
  return o;
}

static void __pyx_tp_dealloc_9pywrapfst__Fst(PyObject *o) {
  struct __pyx_obj_9pywrapfst__Fst *p = (struct __pyx_obj_9pywrapfst__Fst *)o;
  #if CYTHON_USE_TP_FINALIZE
  if (unlikely(PyType_HasFeature(Py_TYPE(o), Py_TPFLAGS_HAVE_FINALIZE) && Py_TYPE(o)->tp_finalize) && (!PyType_IS_GC(Py_TYPE(o)) || !_PyGC_FINALIZED(o))) {
    if (PyObject_CallFinalizerFromDealloc(o)) return;
  }
  #endif
  __Pyx_call_destructor(p->_fst);
  (*Py_TYPE(o)->tp_free)(o);
}

static PyMethodDef __pyx_methods_9pywrapfst__Fst[] = {
  {"_repr_svg_", (PyCFunction)__pyx_pw_9pywrapfst_4_Fst_1_repr_svg_, METH_NOARGS, __pyx_doc_9pywrapfst_4_Fst__repr_svg_},
  {"__reduce__", (PyCFunction)__pyx_pw_9pywrapfst_4_Fst_9__reduce__, METH_NOARGS, 0},
  {"arc_type", (PyCFunction)__pyx_pw_9pywrapfst_4_Fst_11arc_type, METH_NOARGS, __pyx_doc_9pywrapfst_4_Fst_10arc_type},
  {"arcs", (PyCFunction)__pyx_pw_9pywrapfst_4_Fst_13arcs, METH_O, __pyx_doc_9pywrapfst_4_Fst_12arcs},
  {"copy", (PyCFunction)__pyx_pw_9pywrapfst_4_Fst_15copy, METH_NOARGS, __pyx_doc_9pywrapfst_4_Fst_14copy},
  {"draw", (PyCFunction)__pyx_pw_9pywrapfst_4_Fst_17draw, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9pywrapfst_4_Fst_16draw},
  {"final", (PyCFunction)__pyx_pw_9pywrapfst_4_Fst_19final, METH_O, __pyx_doc_9pywrapfst_4_Fst_18final},
  {"fst_type", (PyCFunction)__pyx_pw_9pywrapfst_4_Fst_21fst_type, METH_NOARGS, __pyx_doc_9pywrapfst_4_Fst_20fst_type},
  {"input_symbols", (PyCFunction)__pyx_pw_9pywrapfst_4_Fst_23input_symbols, METH_NOARGS, __pyx_doc_9pywrapfst_4_Fst_22input_symbols},
  {"num_arcs", (PyCFunction)__pyx_pw_9pywrapfst_4_Fst_25num_arcs, METH_O, __pyx_doc_9pywrapfst_4_Fst_24num_arcs},
  {"num_input_epsilons", (PyCFunction)__pyx_pw_9pywrapfst_4_Fst_27num_input_epsilons, METH_O, __pyx_doc_9pywrapfst_4_Fst_26num_input_epsilons},
  {"num_output_epsilons", (PyCFunction)__pyx_pw_9pywrapfst_4_Fst_29num_output_epsilons, METH_O, __pyx_doc_9pywrapfst_4_Fst_28num_output_epsilons},
  {"output_symbols", (PyCFunction)__pyx_pw_9pywrapfst_4_Fst_31output_symbols, METH_NOARGS, __pyx_doc_9pywrapfst_4_Fst_30output_symbols},
  {"properties", (PyCFunction)__pyx_pw_9pywrapfst_4_Fst_33properties, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9pywrapfst_4_Fst_32properties},
  {"start", (PyCFunction)__pyx_pw_9pywrapfst_4_Fst_35start, METH_NOARGS, __pyx_doc_9pywrapfst_4_Fst_34start},
  {"states", (PyCFunction)__pyx_pw_9pywrapfst_4_Fst_37states, METH_NOARGS, __pyx_doc_9pywrapfst_4_Fst_36states},
  {"text", (PyCFunction)__pyx_pw_9pywrapfst_4_Fst_39text, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9pywrapfst_4_Fst_38text},
  {"verify", (PyCFunction)__pyx_pw_9pywrapfst_4_Fst_41verify, METH_NOARGS, __pyx_doc_9pywrapfst_4_Fst_40verify},
  {"weight_type", (PyCFunction)__pyx_pw_9pywrapfst_4_Fst_43weight_type, METH_NOARGS, __pyx_doc_9pywrapfst_4_Fst_42weight_type},
  {"write", (PyCFunction)__pyx_pw_9pywrapfst_4_Fst_45write, METH_O, __pyx_doc_9pywrapfst_4_Fst_44write},
  {"write_to_string", (PyCFunction)__pyx_pw_9pywrapfst_4_Fst_47write_to_string, METH_NOARGS, __pyx_doc_9pywrapfst_4_Fst_46write_to_string},
  {0, 0, 0, 0}
};

static PyTypeObject __pyx_type_9pywrapfst__Fst = {
  PyVarObject_HEAD_INIT(0, 0)
  "pywrapfst._Fst", /*tp_name*/
  sizeof(struct __pyx_obj_9pywrapfst__Fst), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_9pywrapfst__Fst, /*tp_dealloc*/
  0, /*tp_print*/
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  __pyx_pw_9pywrapfst_4_Fst_3__repr__, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  __pyx_pw_9pywrapfst_4_Fst_7__str__, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE, /*tp_flags*/
  "\n  (No constructor.)\n\n  Immutable FST class, wrapping FstClass.\n\n  This class is the basic user-facing FST object. It does not itself support any\n  mutation operations.\n  ", /*tp_doc*/
  0, /*tp_traverse*/
  0, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  __pyx_methods_9pywrapfst__Fst, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  __pyx_pw_9pywrapfst_4_Fst_5__init__, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_9pywrapfst__Fst, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
};
static struct __pyx_vtabstruct_9pywrapfst__MutableFst __pyx_vtable_9pywrapfst__MutableFst;

static PyObject *__pyx_tp_new_9pywrapfst__MutableFst(PyTypeObject *t, PyObject *a, PyObject *k) {
  struct __pyx_obj_9pywrapfst__MutableFst *p;
  PyObject *o = __pyx_tp_new_9pywrapfst__Fst(t, a, k);
  if (unlikely(!o)) return 0;
  p = ((struct __pyx_obj_9pywrapfst__MutableFst *)o);
  p->__pyx_base.__pyx_vtab = (struct __pyx_vtabstruct_9pywrapfst__Fst*)__pyx_vtabptr_9pywrapfst__MutableFst;
  new((void*)&(p->_mfst)) std::shared_ptr<fst::script::MutableFstClass> ();
  return o;
}

static void __pyx_tp_dealloc_9pywrapfst__MutableFst(PyObject *o) {
  struct __pyx_obj_9pywrapfst__MutableFst *p = (struct __pyx_obj_9pywrapfst__MutableFst *)o;
  #if CYTHON_USE_TP_FINALIZE
  if (unlikely(PyType_HasFeature(Py_TYPE(o), Py_TPFLAGS_HAVE_FINALIZE) && Py_TYPE(o)->tp_finalize) && (!PyType_IS_GC(Py_TYPE(o)) || !_PyGC_FINALIZED(o))) {
    if (PyObject_CallFinalizerFromDealloc(o)) return;
  }
  #endif
  __Pyx_call_destructor(p->_mfst);
  __pyx_tp_dealloc_9pywrapfst__Fst(o);
}

static PyMethodDef __pyx_methods_9pywrapfst__MutableFst[] = {
  {"add_arc", (PyCFunction)__pyx_pw_9pywrapfst_11_MutableFst_1add_arc, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9pywrapfst_11_MutableFst_add_arc},
  {"add_state", (PyCFunction)__pyx_pw_9pywrapfst_11_MutableFst_3add_state, METH_NOARGS, __pyx_doc_9pywrapfst_11_MutableFst_2add_state},
  {"arcsort", (PyCFunction)__pyx_pw_9pywrapfst_11_MutableFst_5arcsort, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9pywrapfst_11_MutableFst_4arcsort},
  {"closure", (PyCFunction)__pyx_pw_9pywrapfst_11_MutableFst_7closure, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9pywrapfst_11_MutableFst_6closure},
  {"concat", (PyCFunction)__pyx_pw_9pywrapfst_11_MutableFst_9concat, METH_O, __pyx_doc_9pywrapfst_11_MutableFst_8concat},
  {"connect", (PyCFunction)__pyx_pw_9pywrapfst_11_MutableFst_11connect, METH_NOARGS, __pyx_doc_9pywrapfst_11_MutableFst_10connect},
  {"decode", (PyCFunction)__pyx_pw_9pywrapfst_11_MutableFst_13decode, METH_O, __pyx_doc_9pywrapfst_11_MutableFst_12decode},
  {"delete_arcs", (PyCFunction)__pyx_pw_9pywrapfst_11_MutableFst_15delete_arcs, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9pywrapfst_11_MutableFst_14delete_arcs},
  {"delete_states", (PyCFunction)__pyx_pw_9pywrapfst_11_MutableFst_17delete_states, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9pywrapfst_11_MutableFst_16delete_states},
  {"encode", (PyCFunction)__pyx_pw_9pywrapfst_11_MutableFst_19encode, METH_O, __pyx_doc_9pywrapfst_11_MutableFst_18encode},
  {"invert", (PyCFunction)__pyx_pw_9pywrapfst_11_MutableFst_21invert, METH_NOARGS, __pyx_doc_9pywrapfst_11_MutableFst_20invert},
  {"minimize", (PyCFunction)__pyx_pw_9pywrapfst_11_MutableFst_23minimize, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9pywrapfst_11_MutableFst_22minimize},
  {"mutable_arcs", (PyCFunction)__pyx_pw_9pywrapfst_11_MutableFst_25mutable_arcs, METH_O, __pyx_doc_9pywrapfst_11_MutableFst_24mutable_arcs},
  {"mutable_input_symbols", (PyCFunction)__pyx_pw_9pywrapfst_11_MutableFst_27mutable_input_symbols, METH_NOARGS, __pyx_doc_9pywrapfst_11_MutableFst_26mutable_input_symbols},
  {"mutable_output_symbols", (PyCFunction)__pyx_pw_9pywrapfst_11_MutableFst_29mutable_output_symbols, METH_NOARGS, __pyx_doc_9pywrapfst_11_MutableFst_28mutable_output_symbols},
  {"num_states", (PyCFunction)__pyx_pw_9pywrapfst_11_MutableFst_31num_states, METH_NOARGS, __pyx_doc_9pywrapfst_11_MutableFst_30num_states},
  {"project", (PyCFunction)__pyx_pw_9pywrapfst_11_MutableFst_33project, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9pywrapfst_11_MutableFst_32project},
  {"prune", (PyCFunction)__pyx_pw_9pywrapfst_11_MutableFst_35prune, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9pywrapfst_11_MutableFst_34prune},
  {"push", (PyCFunction)__pyx_pw_9pywrapfst_11_MutableFst_37push, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9pywrapfst_11_MutableFst_36push},
  {"relabel_pairs", (PyCFunction)__pyx_pw_9pywrapfst_11_MutableFst_39relabel_pairs, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9pywrapfst_11_MutableFst_38relabel_pairs},
  {"relabel_tables", (PyCFunction)__pyx_pw_9pywrapfst_11_MutableFst_41relabel_tables, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9pywrapfst_11_MutableFst_40relabel_tables},
  {"reserve_arcs", (PyCFunction)__pyx_pw_9pywrapfst_11_MutableFst_43reserve_arcs, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9pywrapfst_11_MutableFst_42reserve_arcs},
  {"reserve_states", (PyCFunction)__pyx_pw_9pywrapfst_11_MutableFst_45reserve_states, METH_O, __pyx_doc_9pywrapfst_11_MutableFst_44reserve_states},
  {"reweight", (PyCFunction)__pyx_pw_9pywrapfst_11_MutableFst_47reweight, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9pywrapfst_11_MutableFst_46reweight},
  {"rmepsilon", (PyCFunction)__pyx_pw_9pywrapfst_11_MutableFst_49rmepsilon, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9pywrapfst_11_MutableFst_48rmepsilon},
  {"set_final", (PyCFunction)__pyx_pw_9pywrapfst_11_MutableFst_51set_final, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9pywrapfst_11_MutableFst_50set_final},
  {"set_input_symbols", (PyCFunction)__pyx_pw_9pywrapfst_11_MutableFst_53set_input_symbols, METH_O, __pyx_doc_9pywrapfst_11_MutableFst_52set_input_symbols},
  {"set_output_symbols", (PyCFunction)__pyx_pw_9pywrapfst_11_MutableFst_55set_output_symbols, METH_O, __pyx_doc_9pywrapfst_11_MutableFst_54set_output_symbols},
  {"set_properties", (PyCFunction)__pyx_pw_9pywrapfst_11_MutableFst_57set_properties, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9pywrapfst_11_MutableFst_56set_properties},
  {"set_start", (PyCFunction)__pyx_pw_9pywrapfst_11_MutableFst_59set_start, METH_O, __pyx_doc_9pywrapfst_11_MutableFst_58set_start},
  {"topsort", (PyCFunction)__pyx_pw_9pywrapfst_11_MutableFst_61topsort, METH_NOARGS, __pyx_doc_9pywrapfst_11_MutableFst_60topsort},
  {"union", (PyCFunction)__pyx_pw_9pywrapfst_11_MutableFst_63union, METH_O, __pyx_doc_9pywrapfst_11_MutableFst_62union},
  {0, 0, 0, 0}
};

static PyTypeObject __pyx_type_9pywrapfst__MutableFst = {
  PyVarObject_HEAD_INIT(0, 0)
  "pywrapfst._MutableFst", /*tp_name*/
  sizeof(struct __pyx_obj_9pywrapfst__MutableFst), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_9pywrapfst__MutableFst, /*tp_dealloc*/
  0, /*tp_print*/
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  #if CYTHON_COMPILING_IN_PYPY
  __pyx_pw_9pywrapfst_4_Fst_3__repr__, /*tp_repr*/
  #else
  0, /*tp_repr*/
  #endif
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  #if CYTHON_COMPILING_IN_PYPY
  __pyx_pw_9pywrapfst_4_Fst_7__str__, /*tp_str*/
  #else
  0, /*tp_str*/
  #endif
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE, /*tp_flags*/
  "\n  (No constructor.)\n\n  Mutable FST class, wrapping MutableFstClass.\n\n  This class extends _Fst by adding mutation operations.\n  ", /*tp_doc*/
  0, /*tp_traverse*/
  0, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  __pyx_methods_9pywrapfst__MutableFst, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  #if CYTHON_COMPILING_IN_PYPY
  __pyx_pw_9pywrapfst_4_Fst_5__init__, /*tp_init*/
  #else
  0, /*tp_init*/
  #endif
  0, /*tp_alloc*/
  __pyx_tp_new_9pywrapfst__MutableFst, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
};
static struct __pyx_vtabstruct_9pywrapfst_Arc __pyx_vtable_9pywrapfst_Arc;

static PyObject *__pyx_tp_new_9pywrapfst_Arc(PyTypeObject *t, CYTHON_UNUSED PyObject *a, CYTHON_UNUSED PyObject *k) {
  struct __pyx_obj_9pywrapfst_Arc *p;
  PyObject *o;
  if (likely((t->tp_flags & Py_TPFLAGS_IS_ABSTRACT) == 0)) {
    o = (*t->tp_alloc)(t, 0);
  } else {
    o = (PyObject *) PyBaseObject_Type.tp_new(t, __pyx_empty_tuple, 0);
  }
  if (unlikely(!o)) return 0;
  p = ((struct __pyx_obj_9pywrapfst_Arc *)o);
  p->__pyx_vtab = __pyx_vtabptr_9pywrapfst_Arc;
  new((void*)&(p->_arc)) std::unique_ptr<fst::script::ArcClass> ();
  return o;
}

static void __pyx_tp_dealloc_9pywrapfst_Arc(PyObject *o) {
  struct __pyx_obj_9pywrapfst_Arc *p = (struct __pyx_obj_9pywrapfst_Arc *)o;
  #if CYTHON_USE_TP_FINALIZE
  if (unlikely(PyType_HasFeature(Py_TYPE(o), Py_TPFLAGS_HAVE_FINALIZE) && Py_TYPE(o)->tp_finalize) && (!PyType_IS_GC(Py_TYPE(o)) || !_PyGC_FINALIZED(o))) {
    if (PyObject_CallFinalizerFromDealloc(o)) return;
  }
  #endif
  __Pyx_call_destructor(p->_arc);
  (*Py_TYPE(o)->tp_free)(o);
}

static PyObject *__pyx_getprop_9pywrapfst_3Arc_ilabel(PyObject *o, CYTHON_UNUSED void *x) {
  return __pyx_pw_9pywrapfst_3Arc_6ilabel_1__get__(o);
}

static int __pyx_setprop_9pywrapfst_3Arc_ilabel(PyObject *o, PyObject *v, CYTHON_UNUSED void *x) {
  if (v) {
    return __pyx_pw_9pywrapfst_3Arc_6ilabel_3__set__(o, v);
  }
  else {
    PyErr_SetString(PyExc_NotImplementedError, "__del__");
    return -1;
  }
}

static PyObject *__pyx_getprop_9pywrapfst_3Arc_olabel(PyObject *o, CYTHON_UNUSED void *x) {
  return __pyx_pw_9pywrapfst_3Arc_6olabel_1__get__(o);
}

static int __pyx_setprop_9pywrapfst_3Arc_olabel(PyObject *o, PyObject *v, CYTHON_UNUSED void *x) {
  if (v) {
    return __pyx_pw_9pywrapfst_3Arc_6olabel_3__set__(o, v);
  }
  else {
    PyErr_SetString(PyExc_NotImplementedError, "__del__");
    return -1;
  }
}

static PyObject *__pyx_getprop_9pywrapfst_3Arc_weight(PyObject *o, CYTHON_UNUSED void *x) {
  return __pyx_pw_9pywrapfst_3Arc_6weight_1__get__(o);
}

static int __pyx_setprop_9pywrapfst_3Arc_weight(PyObject *o, PyObject *v, CYTHON_UNUSED void *x) {
  if (v) {
    return __pyx_pw_9pywrapfst_3Arc_6weight_3__set__(o, v);
  }
  else {
    PyErr_SetString(PyExc_NotImplementedError, "__del__");
    return -1;
  }
}

static PyObject *__pyx_getprop_9pywrapfst_3Arc_nextstate(PyObject *o, CYTHON_UNUSED void *x) {
  return __pyx_pw_9pywrapfst_3Arc_9nextstate_1__get__(o);
}

static int __pyx_setprop_9pywrapfst_3Arc_nextstate(PyObject *o, PyObject *v, CYTHON_UNUSED void *x) {
  if (v) {
    return __pyx_pw_9pywrapfst_3Arc_9nextstate_3__set__(o, v);
  }
  else {
    PyErr_SetString(PyExc_NotImplementedError, "__del__");
    return -1;
  }
}

static PyMethodDef __pyx_methods_9pywrapfst_Arc[] = {
  {"copy", (PyCFunction)__pyx_pw_9pywrapfst_3Arc_5copy, METH_NOARGS, 0},
  {"__reduce_cython__", (PyCFunction)__pyx_pw_9pywrapfst_3Arc_7__reduce_cython__, METH_NOARGS, 0},
  {"__setstate_cython__", (PyCFunction)__pyx_pw_9pywrapfst_3Arc_9__setstate_cython__, METH_O, 0},
  {0, 0, 0, 0}
};

static struct PyGetSetDef __pyx_getsets_9pywrapfst_Arc[] = {
  {(char *)"ilabel", __pyx_getprop_9pywrapfst_3Arc_ilabel, __pyx_setprop_9pywrapfst_3Arc_ilabel, (char *)0, 0},
  {(char *)"olabel", __pyx_getprop_9pywrapfst_3Arc_olabel, __pyx_setprop_9pywrapfst_3Arc_olabel, (char *)0, 0},
  {(char *)"weight", __pyx_getprop_9pywrapfst_3Arc_weight, __pyx_setprop_9pywrapfst_3Arc_weight, (char *)0, 0},
  {(char *)"nextstate", __pyx_getprop_9pywrapfst_3Arc_nextstate, __pyx_setprop_9pywrapfst_3Arc_nextstate, (char *)0, 0},
  {0, 0, 0, 0, 0}
};

static PyTypeObject __pyx_type_9pywrapfst_Arc = {
  PyVarObject_HEAD_INIT(0, 0)
  "pywrapfst.Arc", /*tp_name*/
  sizeof(struct __pyx_obj_9pywrapfst_Arc), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_9pywrapfst_Arc, /*tp_dealloc*/
  0, /*tp_print*/
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  __pyx_pw_9pywrapfst_3Arc_1__repr__, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE, /*tp_flags*/
  "\n  Arc(ilabel, olabel, weight, nextstate)\n\n  This class represents an arc while remaining agnostic about the underlying arc\n  type.  Attributes of the arc can be accessed or mutated, and the arc can be\n  copied.\n\n  Attributes:\n    ilabel: The input label.\n    olabel: The output label.\n    weight: The arc weight.\n    nextstate: The destination state for the arc.\n  ", /*tp_doc*/
  0, /*tp_traverse*/
  0, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  __pyx_methods_9pywrapfst_Arc, /*tp_methods*/
  0, /*tp_members*/
  __pyx_getsets_9pywrapfst_Arc, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  __pyx_pw_9pywrapfst_3Arc_3__init__, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_9pywrapfst_Arc, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
};
static struct __pyx_vtabstruct_9pywrapfst_ArcIterator __pyx_vtable_9pywrapfst_ArcIterator;

static PyObject *__pyx_tp_new_9pywrapfst_ArcIterator(PyTypeObject *t, CYTHON_UNUSED PyObject *a, CYTHON_UNUSED PyObject *k) {
  struct __pyx_obj_9pywrapfst_ArcIterator *p;
  PyObject *o;
  if (likely((t->tp_flags & Py_TPFLAGS_IS_ABSTRACT) == 0)) {
    o = (*t->tp_alloc)(t, 0);
  } else {
    o = (PyObject *) PyBaseObject_Type.tp_new(t, __pyx_empty_tuple, 0);
  }
  if (unlikely(!o)) return 0;
  p = ((struct __pyx_obj_9pywrapfst_ArcIterator *)o);
  p->__pyx_vtab = __pyx_vtabptr_9pywrapfst_ArcIterator;
  new((void*)&(p->_fst)) std::shared_ptr<fst::script::FstClass> ();
  new((void*)&(p->_aiter)) std::unique_ptr<fst::script::ArcIteratorClass> ();
  return o;
}

static void __pyx_tp_dealloc_9pywrapfst_ArcIterator(PyObject *o) {
  struct __pyx_obj_9pywrapfst_ArcIterator *p = (struct __pyx_obj_9pywrapfst_ArcIterator *)o;
  #if CYTHON_USE_TP_FINALIZE
  if (unlikely(PyType_HasFeature(Py_TYPE(o), Py_TPFLAGS_HAVE_FINALIZE) && Py_TYPE(o)->tp_finalize) && (!PyType_IS_GC(Py_TYPE(o)) || !_PyGC_FINALIZED(o))) {
    if (PyObject_CallFinalizerFromDealloc(o)) return;
  }
  #endif
  __Pyx_call_destructor(p->_fst);
  __Pyx_call_destructor(p->_aiter);
  (*Py_TYPE(o)->tp_free)(o);
}

static PyMethodDef __pyx_methods_9pywrapfst_ArcIterator[] = {
  {"__next__", (PyCFunction)__pyx_pw_9pywrapfst_11ArcIterator_7__next__, METH_NOARGS|METH_COEXIST, 0},
  {"done", (PyCFunction)__pyx_pw_9pywrapfst_11ArcIterator_9done, METH_NOARGS, __pyx_doc_9pywrapfst_11ArcIterator_8done},
  {"flags", (PyCFunction)__pyx_pw_9pywrapfst_11ArcIterator_11flags, METH_NOARGS, __pyx_doc_9pywrapfst_11ArcIterator_10flags},
  {"next", (PyCFunction)__pyx_pw_9pywrapfst_11ArcIterator_13next, METH_NOARGS, __pyx_doc_9pywrapfst_11ArcIterator_12next},
  {"position", (PyCFunction)__pyx_pw_9pywrapfst_11ArcIterator_15position, METH_NOARGS, __pyx_doc_9pywrapfst_11ArcIterator_14position},
  {"reset", (PyCFunction)__pyx_pw_9pywrapfst_11ArcIterator_17reset, METH_NOARGS, __pyx_doc_9pywrapfst_11ArcIterator_16reset},
  {"seek", (PyCFunction)__pyx_pw_9pywrapfst_11ArcIterator_19seek, METH_O, __pyx_doc_9pywrapfst_11ArcIterator_18seek},
  {"set_flags", (PyCFunction)__pyx_pw_9pywrapfst_11ArcIterator_21set_flags, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9pywrapfst_11ArcIterator_20set_flags},
  {"value", (PyCFunction)__pyx_pw_9pywrapfst_11ArcIterator_23value, METH_NOARGS, __pyx_doc_9pywrapfst_11ArcIterator_22value},
  {"__reduce_cython__", (PyCFunction)__pyx_pw_9pywrapfst_11ArcIterator_25__reduce_cython__, METH_NOARGS, 0},
  {"__setstate_cython__", (PyCFunction)__pyx_pw_9pywrapfst_11ArcIterator_27__setstate_cython__, METH_O, 0},
  {0, 0, 0, 0}
};

static PyTypeObject __pyx_type_9pywrapfst_ArcIterator = {
  PyVarObject_HEAD_INIT(0, 0)
  "pywrapfst.ArcIterator", /*tp_name*/
  sizeof(struct __pyx_obj_9pywrapfst_ArcIterator), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_9pywrapfst_ArcIterator, /*tp_dealloc*/
  0, /*tp_print*/
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  __pyx_pw_9pywrapfst_11ArcIterator_1__repr__, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE, /*tp_flags*/
  "\n  ArcIterator(ifst, state)\n\n  This class is used for iterating over the arcs leaving some state of an FST.\n  ", /*tp_doc*/
  0, /*tp_traverse*/
  0, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  __pyx_pw_9pywrapfst_11ArcIterator_5__iter__, /*tp_iter*/
  __pyx_pw_9pywrapfst_11ArcIterator_7__next__, /*tp_iternext*/
  __pyx_methods_9pywrapfst_ArcIterator, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  __pyx_pw_9pywrapfst_11ArcIterator_3__init__, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_9pywrapfst_ArcIterator, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
};
static struct __pyx_vtabstruct_9pywrapfst_MutableArcIterator __pyx_vtable_9pywrapfst_MutableArcIterator;

static PyObject *__pyx_tp_new_9pywrapfst_MutableArcIterator(PyTypeObject *t, CYTHON_UNUSED PyObject *a, CYTHON_UNUSED PyObject *k) {
  struct __pyx_obj_9pywrapfst_MutableArcIterator *p;
  PyObject *o;
  if (likely((t->tp_flags & Py_TPFLAGS_IS_ABSTRACT) == 0)) {
    o = (*t->tp_alloc)(t, 0);
  } else {
    o = (PyObject *) PyBaseObject_Type.tp_new(t, __pyx_empty_tuple, 0);
  }
  if (unlikely(!o)) return 0;
  p = ((struct __pyx_obj_9pywrapfst_MutableArcIterator *)o);
  p->__pyx_vtab = __pyx_vtabptr_9pywrapfst_MutableArcIterator;
  new((void*)&(p->_mfst)) std::shared_ptr<fst::script::MutableFstClass> ();
  new((void*)&(p->_aiter)) std::unique_ptr<fst::script::MutableArcIteratorClass> ();
  return o;
}

static void __pyx_tp_dealloc_9pywrapfst_MutableArcIterator(PyObject *o) {
  struct __pyx_obj_9pywrapfst_MutableArcIterator *p = (struct __pyx_obj_9pywrapfst_MutableArcIterator *)o;
  #if CYTHON_USE_TP_FINALIZE
  if (unlikely(PyType_HasFeature(Py_TYPE(o), Py_TPFLAGS_HAVE_FINALIZE) && Py_TYPE(o)->tp_finalize) && (!PyType_IS_GC(Py_TYPE(o)) || !_PyGC_FINALIZED(o))) {
    if (PyObject_CallFinalizerFromDealloc(o)) return;
  }
  #endif
  __Pyx_call_destructor(p->_mfst);
  __Pyx_call_destructor(p->_aiter);
  (*Py_TYPE(o)->tp_free)(o);
}

static PyMethodDef __pyx_methods_9pywrapfst_MutableArcIterator[] = {
  {"done", (PyCFunction)__pyx_pw_9pywrapfst_18MutableArcIterator_5done, METH_NOARGS, __pyx_doc_9pywrapfst_18MutableArcIterator_4done},
  {"flags", (PyCFunction)__pyx_pw_9pywrapfst_18MutableArcIterator_7flags, METH_NOARGS, __pyx_doc_9pywrapfst_18MutableArcIterator_6flags},
  {"next", (PyCFunction)__pyx_pw_9pywrapfst_18MutableArcIterator_9next, METH_NOARGS, __pyx_doc_9pywrapfst_18MutableArcIterator_8next},
  {"position", (PyCFunction)__pyx_pw_9pywrapfst_18MutableArcIterator_11position, METH_NOARGS, __pyx_doc_9pywrapfst_18MutableArcIterator_10position},
  {"reset", (PyCFunction)__pyx_pw_9pywrapfst_18MutableArcIterator_13reset, METH_NOARGS, __pyx_doc_9pywrapfst_18MutableArcIterator_12reset},
  {"seek", (PyCFunction)__pyx_pw_9pywrapfst_18MutableArcIterator_15seek, METH_O, __pyx_doc_9pywrapfst_18MutableArcIterator_14seek},
  {"set_flags", (PyCFunction)__pyx_pw_9pywrapfst_18MutableArcIterator_17set_flags, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9pywrapfst_18MutableArcIterator_16set_flags},
  {"set_value", (PyCFunction)__pyx_pw_9pywrapfst_18MutableArcIterator_19set_value, METH_O, __pyx_doc_9pywrapfst_18MutableArcIterator_18set_value},
  {"value", (PyCFunction)__pyx_pw_9pywrapfst_18MutableArcIterator_21value, METH_NOARGS, __pyx_doc_9pywrapfst_18MutableArcIterator_20value},
  {"__reduce_cython__", (PyCFunction)__pyx_pw_9pywrapfst_18MutableArcIterator_23__reduce_cython__, METH_NOARGS, 0},
  {"__setstate_cython__", (PyCFunction)__pyx_pw_9pywrapfst_18MutableArcIterator_25__setstate_cython__, METH_O, 0},
  {0, 0, 0, 0}
};

static PyTypeObject __pyx_type_9pywrapfst_MutableArcIterator = {
  PyVarObject_HEAD_INIT(0, 0)
  "pywrapfst.MutableArcIterator", /*tp_name*/
  sizeof(struct __pyx_obj_9pywrapfst_MutableArcIterator), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_9pywrapfst_MutableArcIterator, /*tp_dealloc*/
  0, /*tp_print*/
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  __pyx_pw_9pywrapfst_18MutableArcIterator_1__repr__, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE, /*tp_flags*/
  "\n  MutableArcIterator(ifst, state)\n\n  This class is used for iterating over the arcs leaving some state of an FST,\n  also permitting mutation of the current arc.\n  ", /*tp_doc*/
  0, /*tp_traverse*/
  0, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  __pyx_methods_9pywrapfst_MutableArcIterator, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  __pyx_pw_9pywrapfst_18MutableArcIterator_3__init__, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_9pywrapfst_MutableArcIterator, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
};
static struct __pyx_vtabstruct_9pywrapfst_StateIterator __pyx_vtable_9pywrapfst_StateIterator;

static PyObject *__pyx_tp_new_9pywrapfst_StateIterator(PyTypeObject *t, CYTHON_UNUSED PyObject *a, CYTHON_UNUSED PyObject *k) {
  struct __pyx_obj_9pywrapfst_StateIterator *p;
  PyObject *o;
  if (likely((t->tp_flags & Py_TPFLAGS_IS_ABSTRACT) == 0)) {
    o = (*t->tp_alloc)(t, 0);
  } else {
    o = (PyObject *) PyBaseObject_Type.tp_new(t, __pyx_empty_tuple, 0);
  }
  if (unlikely(!o)) return 0;
  p = ((struct __pyx_obj_9pywrapfst_StateIterator *)o);
  p->__pyx_vtab = __pyx_vtabptr_9pywrapfst_StateIterator;
  new((void*)&(p->_fst)) std::shared_ptr<fst::script::FstClass> ();
  new((void*)&(p->_siter)) std::unique_ptr<fst::script::StateIteratorClass> ();
  return o;
}

static void __pyx_tp_dealloc_9pywrapfst_StateIterator(PyObject *o) {
  struct __pyx_obj_9pywrapfst_StateIterator *p = (struct __pyx_obj_9pywrapfst_StateIterator *)o;
  #if CYTHON_USE_TP_FINALIZE
  if (unlikely(PyType_HasFeature(Py_TYPE(o), Py_TPFLAGS_HAVE_FINALIZE) && Py_TYPE(o)->tp_finalize) && (!PyType_IS_GC(Py_TYPE(o)) || !_PyGC_FINALIZED(o))) {
    if (PyObject_CallFinalizerFromDealloc(o)) return;
  }
  #endif
  __Pyx_call_destructor(p->_fst);
  __Pyx_call_destructor(p->_siter);
  (*Py_TYPE(o)->tp_free)(o);
}

static PyMethodDef __pyx_methods_9pywrapfst_StateIterator[] = {
  {"__next__", (PyCFunction)__pyx_pw_9pywrapfst_13StateIterator_7__next__, METH_NOARGS|METH_COEXIST, 0},
  {"done", (PyCFunction)__pyx_pw_9pywrapfst_13StateIterator_9done, METH_NOARGS, __pyx_doc_9pywrapfst_13StateIterator_8done},
  {"next", (PyCFunction)__pyx_pw_9pywrapfst_13StateIterator_11next, METH_NOARGS, __pyx_doc_9pywrapfst_13StateIterator_10next},
  {"reset", (PyCFunction)__pyx_pw_9pywrapfst_13StateIterator_13reset, METH_NOARGS, __pyx_doc_9pywrapfst_13StateIterator_12reset},
  {"value", (PyCFunction)__pyx_pw_9pywrapfst_13StateIterator_15value, METH_NOARGS, __pyx_doc_9pywrapfst_13StateIterator_14value},
  {"__reduce_cython__", (PyCFunction)__pyx_pw_9pywrapfst_13StateIterator_17__reduce_cython__, METH_NOARGS, 0},
  {"__setstate_cython__", (PyCFunction)__pyx_pw_9pywrapfst_13StateIterator_19__setstate_cython__, METH_O, 0},
  {0, 0, 0, 0}
};

static PyTypeObject __pyx_type_9pywrapfst_StateIterator = {
  PyVarObject_HEAD_INIT(0, 0)
  "pywrapfst.StateIterator", /*tp_name*/
  sizeof(struct __pyx_obj_9pywrapfst_StateIterator), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_9pywrapfst_StateIterator, /*tp_dealloc*/
  0, /*tp_print*/
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  __pyx_pw_9pywrapfst_13StateIterator_1__repr__, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE, /*tp_flags*/
  "\n  StateIterator(ifst)\n\n  This class is used for iterating over the states in an FST.\n  ", /*tp_doc*/
  0, /*tp_traverse*/
  0, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  __pyx_pw_9pywrapfst_13StateIterator_5__iter__, /*tp_iter*/
  __pyx_pw_9pywrapfst_13StateIterator_7__next__, /*tp_iternext*/
  __pyx_methods_9pywrapfst_StateIterator, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  __pyx_pw_9pywrapfst_13StateIterator_3__init__, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_9pywrapfst_StateIterator, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
};
static struct __pyx_vtabstruct_9pywrapfst_Compiler __pyx_vtable_9pywrapfst_Compiler;

static PyObject *__pyx_tp_new_9pywrapfst_Compiler(PyTypeObject *t, PyObject *a, PyObject *k) {
  struct __pyx_obj_9pywrapfst_Compiler *p;
  PyObject *o;
  if (likely((t->tp_flags & Py_TPFLAGS_IS_ABSTRACT) == 0)) {
    o = (*t->tp_alloc)(t, 0);
  } else {
    o = (PyObject *) PyBaseObject_Type.tp_new(t, __pyx_empty_tuple, 0);
  }
  if (unlikely(!o)) return 0;
  p = ((struct __pyx_obj_9pywrapfst_Compiler *)o);
  p->__pyx_vtab = __pyx_vtabptr_9pywrapfst_Compiler;
  new((void*)&(p->_sstrm)) std::unique_ptr<std::stringstream> ();
  new((void*)&(p->_fst_type)) std::string();
  new((void*)&(p->_arc_type)) std::string();
  if (unlikely(__pyx_pw_9pywrapfst_8Compiler_1__cinit__(o, a, k) < 0)) goto bad;
  return o;
  bad:
  Py_DECREF(o); o = 0;
  return NULL;
}

static void __pyx_tp_dealloc_9pywrapfst_Compiler(PyObject *o) {
  struct __pyx_obj_9pywrapfst_Compiler *p = (struct __pyx_obj_9pywrapfst_Compiler *)o;
  #if CYTHON_USE_TP_FINALIZE
  if (unlikely(PyType_HasFeature(Py_TYPE(o), Py_TPFLAGS_HAVE_FINALIZE) && Py_TYPE(o)->tp_finalize) && (!PyType_IS_GC(Py_TYPE(o)) || !_PyGC_FINALIZED(o))) {
    if (PyObject_CallFinalizerFromDealloc(o)) return;
  }
  #endif
  __Pyx_call_destructor(p->_sstrm);
  __Pyx_call_destructor(p->_fst_type);
  __Pyx_call_destructor(p->_arc_type);
  (*Py_TYPE(o)->tp_free)(o);
}

static PyMethodDef __pyx_methods_9pywrapfst_Compiler[] = {
  {"compile", (PyCFunction)__pyx_pw_9pywrapfst_8Compiler_3compile, METH_NOARGS, __pyx_doc_9pywrapfst_8Compiler_2compile},
  {"write", (PyCFunction)__pyx_pw_9pywrapfst_8Compiler_5write, METH_O, __pyx_doc_9pywrapfst_8Compiler_4write},
  {"__reduce_cython__", (PyCFunction)__pyx_pw_9pywrapfst_8Compiler_7__reduce_cython__, METH_NOARGS, 0},
  {"__setstate_cython__", (PyCFunction)__pyx_pw_9pywrapfst_8Compiler_9__setstate_cython__, METH_O, 0},
  {0, 0, 0, 0}
};

static PyTypeObject __pyx_type_9pywrapfst_Compiler = {
  PyVarObject_HEAD_INIT(0, 0)
  "pywrapfst.Compiler", /*tp_name*/
  sizeof(struct __pyx_obj_9pywrapfst_Compiler), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_9pywrapfst_Compiler, /*tp_dealloc*/
  0, /*tp_print*/
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE, /*tp_flags*/
  "\n  Compiler(fst_type=\"vector\", arc_type=\"standard\", isymbols=None,\n           osymbols=None, ssymbols=None, acceptor=False, keep_isymbols=False,\n           keep_osymbols=False, keep_state_numbering=False,\n           allow_negative_labels=False)\n\n  Class used to compile FSTs from strings.\n\n  This class is used to compile FSTs specified using the AT&T FSM library\n  format described here:\n\n  http://web.eecs.umich.edu/~radev/NLP-fall2015/resources/fsm_archive/fsm.5.html\n\n  This is the same format used by the `fstcompile` executable.\n\n  Compiler options (symbol tables, etc.) are set at construction time.\n\n      compiler = fst.Compiler(isymbols=ascii_syms, osymbols=ascii_syms)\n\n  Once constructed, Compiler instances behave like a file handle opened for\n  writing:\n\n      # /ba+/\n      print >> compiler, \"0 1 50 50\"\n      print >> compiler, \"1 2 49 49\"\n      print >> compiler, \"2 2 49 49\"\n      print >> compiler, \"2\"\n\n  The `compile` method returns an actual FST instance:\n\n      sheep_machine = compiler.compile()\n\n  Compilation flushes the internal buffer, so the compiler instance can be\n  reused to compile new machines with the same symbol tables (etc.)\n\n  Args:\n    fst_type: A string indicating the container type for the compiled FST.\n    arc_type: A string indicating the arc type for the compiled FST.\n    isymbols: An optional SymbolTable used to label input symbols.\n    osymbols: An optional SymbolTable used to label output symbols.\n    ssymbols: An optional SymbolTable used to label states.\n    acceptor: Should the FST be rendered in acceptor format if possible?\n    keep_isymbols: Should the input symbol table be stored in the FST?\n    keep_osymbols: Should the output symbol table be stored in the FST?\n    keep_state_numbering: Should the state numbering be preserved?\n    allow_negative_labels: Should negative labels be allowed? (Not\n        recommended; may cause conflicts).\n  ", /*tp_doc*/
  0, /*tp_traverse*/
  0, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  __pyx_methods_9pywrapfst_Compiler, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  0, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_9pywrapfst_Compiler, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
};
static struct __pyx_vtabstruct_9pywrapfst_FarReader __pyx_vtable_9pywrapfst_FarReader;

static PyObject *__pyx_tp_new_9pywrapfst_FarReader(PyTypeObject *t, CYTHON_UNUSED PyObject *a, CYTHON_UNUSED PyObject *k) {
  struct __pyx_obj_9pywrapfst_FarReader *p;
  PyObject *o;
  if (likely((t->tp_flags & Py_TPFLAGS_IS_ABSTRACT) == 0)) {
    o = (*t->tp_alloc)(t, 0);
  } else {
    o = (PyObject *) PyBaseObject_Type.tp_new(t, __pyx_empty_tuple, 0);
  }
  if (unlikely(!o)) return 0;
  p = ((struct __pyx_obj_9pywrapfst_FarReader *)o);
  p->__pyx_vtab = __pyx_vtabptr_9pywrapfst_FarReader;
  new((void*)&(p->_reader)) std::unique_ptr<fst::script::FarReaderClass> ();
  return o;
}

static void __pyx_tp_dealloc_9pywrapfst_FarReader(PyObject *o) {
  struct __pyx_obj_9pywrapfst_FarReader *p = (struct __pyx_obj_9pywrapfst_FarReader *)o;
  #if CYTHON_USE_TP_FINALIZE
  if (unlikely(PyType_HasFeature(Py_TYPE(o), Py_TPFLAGS_HAVE_FINALIZE) && Py_TYPE(o)->tp_finalize) && (!PyType_IS_GC(Py_TYPE(o)) || !_PyGC_FINALIZED(o))) {
    if (PyObject_CallFinalizerFromDealloc(o)) return;
  }
  #endif
  __Pyx_call_destructor(p->_reader);
  (*Py_TYPE(o)->tp_free)(o);
}
static PyObject *__pyx_sq_item_9pywrapfst_FarReader(PyObject *o, Py_ssize_t i) {
  PyObject *r;
  PyObject *x = PyInt_FromSsize_t(i); if(!x) return 0;
  r = Py_TYPE(o)->tp_as_mapping->mp_subscript(o, x);
  Py_DECREF(x);
  return r;
}

static PyMethodDef __pyx_methods_9pywrapfst_FarReader[] = {
  {"open", (PyCFunction)__pyx_pw_9pywrapfst_9FarReader_5open, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9pywrapfst_9FarReader_4open},
  {"arc_type", (PyCFunction)__pyx_pw_9pywrapfst_9FarReader_7arc_type, METH_NOARGS, __pyx_doc_9pywrapfst_9FarReader_6arc_type},
  {"done", (PyCFunction)__pyx_pw_9pywrapfst_9FarReader_9done, METH_NOARGS, __pyx_doc_9pywrapfst_9FarReader_8done},
  {"error", (PyCFunction)__pyx_pw_9pywrapfst_9FarReader_11error, METH_NOARGS, __pyx_doc_9pywrapfst_9FarReader_10error},
  {"far_type", (PyCFunction)__pyx_pw_9pywrapfst_9FarReader_13far_type, METH_NOARGS, 0},
  {"find", (PyCFunction)__pyx_pw_9pywrapfst_9FarReader_15find, METH_O, __pyx_doc_9pywrapfst_9FarReader_14find},
  {"get_fst", (PyCFunction)__pyx_pw_9pywrapfst_9FarReader_17get_fst, METH_NOARGS, __pyx_doc_9pywrapfst_9FarReader_16get_fst},
  {"get_key", (PyCFunction)__pyx_pw_9pywrapfst_9FarReader_19get_key, METH_NOARGS, __pyx_doc_9pywrapfst_9FarReader_18get_key},
  {"next", (PyCFunction)__pyx_pw_9pywrapfst_9FarReader_21next, METH_NOARGS, __pyx_doc_9pywrapfst_9FarReader_20next},
  {"reset", (PyCFunction)__pyx_pw_9pywrapfst_9FarReader_23reset, METH_NOARGS, __pyx_doc_9pywrapfst_9FarReader_22reset},
  {"__reduce_cython__", (PyCFunction)__pyx_pw_9pywrapfst_9FarReader_27__reduce_cython__, METH_NOARGS, 0},
  {"__setstate_cython__", (PyCFunction)__pyx_pw_9pywrapfst_9FarReader_29__setstate_cython__, METH_O, 0},
  {0, 0, 0, 0}
};

static PySequenceMethods __pyx_tp_as_sequence_FarReader = {
  0, /*sq_length*/
  0, /*sq_concat*/
  0, /*sq_repeat*/
  __pyx_sq_item_9pywrapfst_FarReader, /*sq_item*/
  0, /*sq_slice*/
  0, /*sq_ass_item*/
  0, /*sq_ass_slice*/
  0, /*sq_contains*/
  0, /*sq_inplace_concat*/
  0, /*sq_inplace_repeat*/
};

static PyMappingMethods __pyx_tp_as_mapping_FarReader = {
  0, /*mp_length*/
  __pyx_pw_9pywrapfst_9FarReader_25__getitem__, /*mp_subscript*/
  0, /*mp_ass_subscript*/
};

static PyTypeObject __pyx_type_9pywrapfst_FarReader = {
  PyVarObject_HEAD_INIT(0, 0)
  "pywrapfst.FarReader", /*tp_name*/
  sizeof(struct __pyx_obj_9pywrapfst_FarReader), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_9pywrapfst_FarReader, /*tp_dealloc*/
  0, /*tp_print*/
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  __pyx_pw_9pywrapfst_9FarReader_3__repr__, /*tp_repr*/
  0, /*tp_as_number*/
  &__pyx_tp_as_sequence_FarReader, /*tp_as_sequence*/
  &__pyx_tp_as_mapping_FarReader, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE, /*tp_flags*/
  "\n  (No constructor.)\n\n  FAR (\"Fst ARchive\") reader object.\n\n  This class is used to read a FAR from disk. FARs contain one or more FSTs (of\n  the same arc type) indexed by a unique string key. To construct a FarReader\n  object, use the `open` class method.\n\n  Attributes:\n    arc_type: A string indicating the arc type.\n    far_type: A string indicating the FAR type.\n  ", /*tp_doc*/
  0, /*tp_traverse*/
  0, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  __pyx_methods_9pywrapfst_FarReader, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  __pyx_pw_9pywrapfst_9FarReader_1__init__, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_9pywrapfst_FarReader, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
};
static struct __pyx_vtabstruct_9pywrapfst_FarWriter __pyx_vtable_9pywrapfst_FarWriter;

static PyObject *__pyx_tp_new_9pywrapfst_FarWriter(PyTypeObject *t, CYTHON_UNUSED PyObject *a, CYTHON_UNUSED PyObject *k) {
  struct __pyx_obj_9pywrapfst_FarWriter *p;
  PyObject *o;
  if (likely((t->tp_flags & Py_TPFLAGS_IS_ABSTRACT) == 0)) {
    o = (*t->tp_alloc)(t, 0);
  } else {
    o = (PyObject *) PyBaseObject_Type.tp_new(t, __pyx_empty_tuple, 0);
  }
  if (unlikely(!o)) return 0;
  p = ((struct __pyx_obj_9pywrapfst_FarWriter *)o);
  p->__pyx_vtab = __pyx_vtabptr_9pywrapfst_FarWriter;
  new((void*)&(p->_writer)) std::unique_ptr<fst::script::FarWriterClass> ();
  return o;
}

static void __pyx_tp_dealloc_9pywrapfst_FarWriter(PyObject *o) {
  struct __pyx_obj_9pywrapfst_FarWriter *p = (struct __pyx_obj_9pywrapfst_FarWriter *)o;
  #if CYTHON_USE_TP_FINALIZE
  if (unlikely(PyType_HasFeature(Py_TYPE(o), Py_TPFLAGS_HAVE_FINALIZE) && Py_TYPE(o)->tp_finalize) && (!PyType_IS_GC(Py_TYPE(o)) || !_PyGC_FINALIZED(o))) {
    if (PyObject_CallFinalizerFromDealloc(o)) return;
  }
  #endif
  __Pyx_call_destructor(p->_writer);
  (*Py_TYPE(o)->tp_free)(o);
}

static int __pyx_mp_ass_subscript_9pywrapfst_FarWriter(PyObject *o, PyObject *i, PyObject *v) {
  if (v) {
    return __pyx_pw_9pywrapfst_9FarWriter_15__setitem__(o, i, v);
  }
  else {
    PyErr_Format(PyExc_NotImplementedError,
      "Subscript deletion not supported by %.200s", Py_TYPE(o)->tp_name);
    return -1;
  }
}

static PyMethodDef __pyx_methods_9pywrapfst_FarWriter[] = {
  {"create", (PyCFunction)__pyx_pw_9pywrapfst_9FarWriter_5create, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9pywrapfst_9FarWriter_4create},
  {"add", (PyCFunction)__pyx_pw_9pywrapfst_9FarWriter_7add, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9pywrapfst_9FarWriter_6add},
  {"arc_type", (PyCFunction)__pyx_pw_9pywrapfst_9FarWriter_9arc_type, METH_NOARGS, __pyx_doc_9pywrapfst_9FarWriter_8arc_type},
  {"error", (PyCFunction)__pyx_pw_9pywrapfst_9FarWriter_11error, METH_NOARGS, __pyx_doc_9pywrapfst_9FarWriter_10error},
  {"far_type", (PyCFunction)__pyx_pw_9pywrapfst_9FarWriter_13far_type, METH_NOARGS, __pyx_doc_9pywrapfst_9FarWriter_12far_type},
  {"__reduce_cython__", (PyCFunction)__pyx_pw_9pywrapfst_9FarWriter_17__reduce_cython__, METH_NOARGS, 0},
  {"__setstate_cython__", (PyCFunction)__pyx_pw_9pywrapfst_9FarWriter_19__setstate_cython__, METH_O, 0},
  {0, 0, 0, 0}
};

static PyMappingMethods __pyx_tp_as_mapping_FarWriter = {
  0, /*mp_length*/
  0, /*mp_subscript*/
  __pyx_mp_ass_subscript_9pywrapfst_FarWriter, /*mp_ass_subscript*/
};

static PyTypeObject __pyx_type_9pywrapfst_FarWriter = {
  PyVarObject_HEAD_INIT(0, 0)
  "pywrapfst.FarWriter", /*tp_name*/
  sizeof(struct __pyx_obj_9pywrapfst_FarWriter), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_9pywrapfst_FarWriter, /*tp_dealloc*/
  0, /*tp_print*/
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  __pyx_pw_9pywrapfst_9FarWriter_3__repr__, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  &__pyx_tp_as_mapping_FarWriter, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE, /*tp_flags*/
  "\n  (No constructor.)\n\n  FAR (\"Fst ARchive\") writer object.\n\n  This class is used to write FSTs (of the same arc type) to a FAR on disk. To\n  construct a FarWriter, use the `create` class method.\n\n  Note that the data is not guaranteed to flush to disk until the FarWriter\n  is garbage-collected. If a FarWriter has been assigned to only one variable,\n  then calling `del` on that variable should decrement the object's reference\n  count from 1 to 0, triggering a flush to disk on the next GC cycle.\n\n  Attributes:\n    arc_type: A string indicating the arc type.\n    far_type: A string indicating the FAR type.\n  ", /*tp_doc*/
  0, /*tp_traverse*/
  0, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  __pyx_methods_9pywrapfst_FarWriter, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  __pyx_pw_9pywrapfst_9FarWriter_1__init__, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_9pywrapfst_FarWriter, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
};

static PyMethodDef __pyx_methods[] = {
  {"compact_symbol_table", (PyCFunction)__pyx_pw_9pywrapfst_9compact_symbol_table, METH_O, __pyx_doc_9pywrapfst_8compact_symbol_table},
  {"merge_symbol_table", (PyCFunction)__pyx_pw_9pywrapfst_11merge_symbol_table, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9pywrapfst_10merge_symbol_table},
  {"_read", (PyCFunction)__pyx_pw_9pywrapfst_13_read, METH_O, 0},
  {"_read_from_string", (PyCFunction)__pyx_pw_9pywrapfst_15_read_from_string, METH_O, 0},
  {"arcmap", (PyCFunction)__pyx_pw_9pywrapfst_17arcmap, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9pywrapfst_16arcmap},
  {"compose", (PyCFunction)__pyx_pw_9pywrapfst_19compose, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9pywrapfst_18compose},
  {"convert", (PyCFunction)__pyx_pw_9pywrapfst_21convert, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9pywrapfst_20convert},
  {"determinize", (PyCFunction)__pyx_pw_9pywrapfst_23determinize, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9pywrapfst_22determinize},
  {"difference", (PyCFunction)__pyx_pw_9pywrapfst_25difference, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9pywrapfst_24difference},
  {"disambiguate", (PyCFunction)__pyx_pw_9pywrapfst_27disambiguate, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9pywrapfst_26disambiguate},
  {"epsnormalize", (PyCFunction)__pyx_pw_9pywrapfst_29epsnormalize, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9pywrapfst_28epsnormalize},
  {"equal", (PyCFunction)__pyx_pw_9pywrapfst_31equal, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9pywrapfst_30equal},
  {"equivalent", (PyCFunction)__pyx_pw_9pywrapfst_33equivalent, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9pywrapfst_32equivalent},
  {"intersect", (PyCFunction)__pyx_pw_9pywrapfst_35intersect, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9pywrapfst_34intersect},
  {"isomorphic", (PyCFunction)__pyx_pw_9pywrapfst_37isomorphic, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9pywrapfst_36isomorphic},
  {"prune", (PyCFunction)__pyx_pw_9pywrapfst_39prune, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9pywrapfst_38prune},
  {"push", (PyCFunction)__pyx_pw_9pywrapfst_41push, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9pywrapfst_40push},
  {"randequivalent", (PyCFunction)__pyx_pw_9pywrapfst_43randequivalent, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9pywrapfst_42randequivalent},
  {"randgen", (PyCFunction)__pyx_pw_9pywrapfst_45randgen, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9pywrapfst_44randgen},
  {"replace", (PyCFunction)__pyx_pw_9pywrapfst_47replace, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9pywrapfst_46replace},
  {"reverse", (PyCFunction)__pyx_pw_9pywrapfst_49reverse, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9pywrapfst_48reverse},
  {"shortestpath", (PyCFunction)__pyx_pw_9pywrapfst_53shortestpath, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9pywrapfst_52shortestpath},
  {"statemap", (PyCFunction)__pyx_pw_9pywrapfst_55statemap, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9pywrapfst_54statemap},
  {"synchronize", (PyCFunction)__pyx_pw_9pywrapfst_57synchronize, METH_O, __pyx_doc_9pywrapfst_56synchronize},
  {0, 0, 0, 0}
};

#if PY_MAJOR_VERSION >= 3
#if CYTHON_PEP489_MULTI_PHASE_INIT
static PyObject* __pyx_pymod_create(PyObject *spec, PyModuleDef *def); /*proto*/
static int __pyx_pymod_exec_pywrapfst(PyObject* module); /*proto*/
static PyModuleDef_Slot __pyx_moduledef_slots[] = {
  {Py_mod_create, (void*)__pyx_pymod_create},
  {Py_mod_exec, (void*)__pyx_pymod_exec_pywrapfst},
  {0, NULL}
};
#endif

static struct PyModuleDef __pyx_moduledef = {
    PyModuleDef_HEAD_INIT,
    "pywrapfst",
    __pyx_k_Python_interface_to_the_FST_scri, /* m_doc */
  #if CYTHON_PEP489_MULTI_PHASE_INIT
    0, /* m_size */
  #else
    -1, /* m_size */
  #endif
    __pyx_methods /* m_methods */,
  #if CYTHON_PEP489_MULTI_PHASE_INIT
    __pyx_moduledef_slots, /* m_slots */
  #else
    NULL, /* m_reload */
  #endif
    NULL, /* m_traverse */
    NULL, /* m_clear */
    NULL /* m_free */
};
#endif

static __Pyx_StringTabEntry __pyx_string_tab[] = {
  {&__pyx_n_s_ACCEPTOR, __pyx_k_ACCEPTOR, sizeof(__pyx_k_ACCEPTOR), 0, 0, 1, 1},
  {&__pyx_n_s_ACCESSIBLE, __pyx_k_ACCESSIBLE, sizeof(__pyx_k_ACCESSIBLE), 0, 0, 1, 1},
  {&__pyx_n_s_ACYCLIC, __pyx_k_ACYCLIC, sizeof(__pyx_k_ACYCLIC), 0, 0, 1, 1},
  {&__pyx_n_s_ADD_ARC_PROPERTIES, __pyx_k_ADD_ARC_PROPERTIES, sizeof(__pyx_k_ADD_ARC_PROPERTIES), 0, 0, 1, 1},
  {&__pyx_n_s_ADD_STATE_PROPERTIES, __pyx_k_ADD_STATE_PROPERTIES, sizeof(__pyx_k_ADD_STATE_PROPERTIES), 0, 0, 1, 1},
  {&__pyx_n_s_ADD_SUPERFINAL_PROPERTIES, __pyx_k_ADD_SUPERFINAL_PROPERTIES, sizeof(__pyx_k_ADD_SUPERFINAL_PROPERTIES), 0, 0, 1, 1},
  {&__pyx_n_s_ARC_FLAGS, __pyx_k_ARC_FLAGS, sizeof(__pyx_k_ARC_FLAGS), 0, 0, 1, 1},
  {&__pyx_n_s_ARC_I_LABEL_VALUE, __pyx_k_ARC_I_LABEL_VALUE, sizeof(__pyx_k_ARC_I_LABEL_VALUE), 0, 0, 1, 1},
  {&__pyx_n_s_ARC_NEXT_STATE_VALUE, __pyx_k_ARC_NEXT_STATE_VALUE, sizeof(__pyx_k_ARC_NEXT_STATE_VALUE), 0, 0, 1, 1},
  {&__pyx_n_s_ARC_NO_CACHE, __pyx_k_ARC_NO_CACHE, sizeof(__pyx_k_ARC_NO_CACHE), 0, 0, 1, 1},
  {&__pyx_n_s_ARC_O_LABEL_VALUE, __pyx_k_ARC_O_LABEL_VALUE, sizeof(__pyx_k_ARC_O_LABEL_VALUE), 0, 0, 1, 1},
  {&__pyx_n_s_ARC_SORT_PROPERTIES, __pyx_k_ARC_SORT_PROPERTIES, sizeof(__pyx_k_ARC_SORT_PROPERTIES), 0, 0, 1, 1},
  {&__pyx_n_s_ARC_VALUE_FLAGS, __pyx_k_ARC_VALUE_FLAGS, sizeof(__pyx_k_ARC_VALUE_FLAGS), 0, 0, 1, 1},
  {&__pyx_n_s_ARC_WEIGHT_VALUE, __pyx_k_ARC_WEIGHT_VALUE, sizeof(__pyx_k_ARC_WEIGHT_VALUE), 0, 0, 1, 1},
  {&__pyx_kp_s_ArcIterator_at_0x_x, __pyx_k_ArcIterator_at_0x_x, sizeof(__pyx_k_ArcIterator_at_0x_x), 0, 0, 1, 0},
  {&__pyx_kp_s_Arc_at_0x_x, __pyx_k_Arc_at_0x_x, sizeof(__pyx_k_Arc_at_0x_x), 0, 0, 1, 0},
  {&__pyx_n_s_BINARY_PROPERTIES, __pyx_k_BINARY_PROPERTIES, sizeof(__pyx_k_BINARY_PROPERTIES), 0, 0, 1, 1},
  {&__pyx_n_s_COACCESSIBLE, __pyx_k_COACCESSIBLE, sizeof(__pyx_k_COACCESSIBLE), 0, 0, 1, 1},
  {&__pyx_n_s_COPY_PROPERTIES, __pyx_k_COPY_PROPERTIES, sizeof(__pyx_k_COPY_PROPERTIES), 0, 0, 1, 1},
  {&__pyx_n_s_CYCLIC, __pyx_k_CYCLIC, sizeof(__pyx_k_CYCLIC), 0, 0, 1, 1},
  {&__pyx_n_s_CalledProcessError, __pyx_k_CalledProcessError, sizeof(__pyx_k_CalledProcessError), 0, 0, 1, 1},
  {&__pyx_kp_s_Cannot_construct, __pyx_k_Cannot_construct, sizeof(__pyx_k_Cannot_construct), 0, 0, 1, 0},
  {&__pyx_kp_s_Cannot_encode_as_string_r, __pyx_k_Cannot_encode_as_string_r, sizeof(__pyx_k_Cannot_encode_as_string_r), 0, 0, 1, 0},
  {&__pyx_kp_s_Cannot_topsort_cyclic_FST, __pyx_k_Cannot_topsort_cyclic_FST, sizeof(__pyx_k_Cannot_topsort_cyclic_FST), 0, 0, 1, 0},
  {&__pyx_kp_s_Compilation_failed, __pyx_k_Compilation_failed, sizeof(__pyx_k_Compilation_failed), 0, 0, 1, 0},
  {&__pyx_kp_s_Conversion_to_r_failed, __pyx_k_Conversion_to_r_failed, sizeof(__pyx_k_Conversion_to_r_failed), 0, 0, 1, 0},
  {&__pyx_n_s_DELETE_ARC_PROPERTIES, __pyx_k_DELETE_ARC_PROPERTIES, sizeof(__pyx_k_DELETE_ARC_PROPERTIES), 0, 0, 1, 1},
  {&__pyx_n_s_DELETE_STATE_PROPERTIES, __pyx_k_DELETE_STATE_PROPERTIES, sizeof(__pyx_k_DELETE_STATE_PROPERTIES), 0, 0, 1, 1},
  {&__pyx_n_s_DOT_TSVG, __pyx_k_DOT_TSVG, sizeof(__pyx_k_DOT_TSVG), 0, 0, 1, 1},
  {&__pyx_n_s_ENCODE_FLAGS, __pyx_k_ENCODE_FLAGS, sizeof(__pyx_k_ENCODE_FLAGS), 0, 0, 1, 1},
  {&__pyx_n_s_ENCODE_LABELS, __pyx_k_ENCODE_LABELS, sizeof(__pyx_k_ENCODE_LABELS), 0, 0, 1, 1},
  {&__pyx_n_s_ENCODE_WEIGHTS, __pyx_k_ENCODE_WEIGHTS, sizeof(__pyx_k_ENCODE_WEIGHTS), 0, 0, 1, 1},
  {&__pyx_n_s_EPSILONS, __pyx_k_EPSILONS, sizeof(__pyx_k_EPSILONS), 0, 0, 1, 1},
  {&__pyx_n_s_ERROR, __pyx_k_ERROR, sizeof(__pyx_k_ERROR), 0, 0, 1, 1},
  {&__pyx_n_s_EXPANDED, __pyx_k_EXPANDED, sizeof(__pyx_k_EXPANDED), 0, 0, 1, 1},
  {&__pyx_n_s_EXTRINSIC_PROPERTIES, __pyx_k_EXTRINSIC_PROPERTIES, sizeof(__pyx_k_EXTRINSIC_PROPERTIES), 0, 0, 1, 1},
  {&__pyx_kp_s_EncodeMapper_at_0x_x, __pyx_k_EncodeMapper_at_0x_x, sizeof(__pyx_k_EncodeMapper_at_0x_x), 0, 0, 1, 0},
  {&__pyx_n_s_FST_PROPERTIES, __pyx_k_FST_PROPERTIES, sizeof(__pyx_k_FST_PROPERTIES), 0, 0, 1, 1},
  {&__pyx_kp_s_FarReader_at_0x_x, __pyx_k_FarReader_at_0x_x, sizeof(__pyx_k_FarReader_at_0x_x), 0, 0, 1, 0},
  {&__pyx_kp_s_FarWriter_at_0x_x, __pyx_k_FarWriter_at_0x_x, sizeof(__pyx_k_FarWriter_at_0x_x), 0, 0, 1, 0},
  {&__pyx_n_s_Fst, __pyx_k_Fst, sizeof(__pyx_k_Fst), 0, 0, 1, 1},
  {&__pyx_n_s_FstArgError, __pyx_k_FstArgError, sizeof(__pyx_k_FstArgError), 0, 0, 1, 1},
  {&__pyx_n_s_FstBadWeightError, __pyx_k_FstBadWeightError, sizeof(__pyx_k_FstBadWeightError), 0, 0, 1, 1},
  {&__pyx_n_s_FstDeletedConstructorError, __pyx_k_FstDeletedConstructorError, sizeof(__pyx_k_FstDeletedConstructorError), 0, 0, 1, 1},
  {&__pyx_n_s_FstError, __pyx_k_FstError, sizeof(__pyx_k_FstError), 0, 0, 1, 1},
  {&__pyx_n_s_FstIOError, __pyx_k_FstIOError, sizeof(__pyx_k_FstIOError), 0, 0, 1, 1},
  {&__pyx_n_s_FstIndexError, __pyx_k_FstIndexError, sizeof(__pyx_k_FstIndexError), 0, 0, 1, 1},
  {&__pyx_n_s_FstOpError, __pyx_k_FstOpError, sizeof(__pyx_k_FstOpError), 0, 0, 1, 1},
  {&__pyx_kp_s_Fst_SymbolTable_r_at_0x_x, __pyx_k_Fst_SymbolTable_r_at_0x_x, sizeof(__pyx_k_Fst_SymbolTable_r_at_0x_x), 0, 0, 1, 0},
  {&__pyx_n_s_Fst___new, __pyx_k_Fst___new, sizeof(__pyx_k_Fst___new), 0, 0, 1, 1},
  {&__pyx_kp_s_Fst_arc_type_standard_Construct, __pyx_k_Fst_arc_type_standard_Construct, sizeof(__pyx_k_Fst_arc_type_standard_Construct), 0, 0, 1, 0},
  {&__pyx_kp_s_Fst_at_0x_x, __pyx_k_Fst_at_0x_x, sizeof(__pyx_k_Fst_at_0x_x), 0, 0, 1, 0},
  {&__pyx_n_s_Fst_read, __pyx_k_Fst_read, sizeof(__pyx_k_Fst_read), 0, 0, 1, 1},
  {&__pyx_n_s_Fst_read_from_string, __pyx_k_Fst_read_from_string, sizeof(__pyx_k_Fst_read_from_string), 0, 0, 1, 1},
  {&__pyx_n_s_INITIAL_ACYCLIC, __pyx_k_INITIAL_ACYCLIC, sizeof(__pyx_k_INITIAL_ACYCLIC), 0, 0, 1, 1},
  {&__pyx_n_s_INITIAL_CYCLIC, __pyx_k_INITIAL_CYCLIC, sizeof(__pyx_k_INITIAL_CYCLIC), 0, 0, 1, 1},
  {&__pyx_n_s_INTRINSIC_PROPERTIES, __pyx_k_INTRINSIC_PROPERTIES, sizeof(__pyx_k_INTRINSIC_PROPERTIES), 0, 0, 1, 1},
  {&__pyx_n_s_IOError, __pyx_k_IOError, sizeof(__pyx_k_IOError), 0, 0, 1, 1},
  {&__pyx_n_s_I_DETERMINISTIC, __pyx_k_I_DETERMINISTIC, sizeof(__pyx_k_I_DETERMINISTIC), 0, 0, 1, 1},
  {&__pyx_n_s_I_EPSILONS, __pyx_k_I_EPSILONS, sizeof(__pyx_k_I_EPSILONS), 0, 0, 1, 1},
  {&__pyx_n_s_I_LABEL_INVARIANT_PROPERTIES, __pyx_k_I_LABEL_INVARIANT_PROPERTIES, sizeof(__pyx_k_I_LABEL_INVARIANT_PROPERTIES), 0, 0, 1, 1},
  {&__pyx_n_s_I_LABEL_SORTED, __pyx_k_I_LABEL_SORTED, sizeof(__pyx_k_I_LABEL_SORTED), 0, 0, 1, 1},
  {&__pyx_kp_s_Incompatible_or_invalid_arc_type, __pyx_k_Incompatible_or_invalid_arc_type, sizeof(__pyx_k_Incompatible_or_invalid_arc_type), 0, 0, 1, 0},
  {&__pyx_kp_s_Incompatible_or_invalid_weight, __pyx_k_Incompatible_or_invalid_weight, sizeof(__pyx_k_Incompatible_or_invalid_weight), 0, 0, 1, 0},
  {&__pyx_kp_s_Incompatible_or_invalid_weight_t, __pyx_k_Incompatible_or_invalid_weight_t, sizeof(__pyx_k_Incompatible_or_invalid_weight_t), 0, 0, 1, 0},
  {&__pyx_n_s_IndexError, __pyx_k_IndexError, sizeof(__pyx_k_IndexError), 0, 0, 1, 1},
  {&__pyx_kp_s_Invalid_weight, __pyx_k_Invalid_weight, sizeof(__pyx_k_Invalid_weight), 0, 0, 1, 0},
  {&__pyx_n_s_KeyError, __pyx_k_KeyError, sizeof(__pyx_k_KeyError), 0, 0, 1, 1},
  {&__pyx_kp_s_Key_out_of_order, __pyx_k_Key_out_of_order, sizeof(__pyx_k_Key_out_of_order), 0, 0, 1, 0},
  {&__pyx_n_s_MUTABLE, __pyx_k_MUTABLE, sizeof(__pyx_k_MUTABLE), 0, 0, 1, 1},
  {&__pyx_kp_s_MutableArcIterator_at_0x_x, __pyx_k_MutableArcIterator_at_0x_x, sizeof(__pyx_k_MutableArcIterator_at_0x_x), 0, 0, 1, 0},
  {&__pyx_n_s_NEG_TRINARY_PROPERTIES, __pyx_k_NEG_TRINARY_PROPERTIES, sizeof(__pyx_k_NEG_TRINARY_PROPERTIES), 0, 0, 1, 1},
  {&__pyx_n_s_NON_I_DETERMINISTIC, __pyx_k_NON_I_DETERMINISTIC, sizeof(__pyx_k_NON_I_DETERMINISTIC), 0, 0, 1, 1},
  {&__pyx_n_s_NON_O_DETERMINISTIC, __pyx_k_NON_O_DETERMINISTIC, sizeof(__pyx_k_NON_O_DETERMINISTIC), 0, 0, 1, 1},
  {&__pyx_n_s_NOT_ACCEPTOR, __pyx_k_NOT_ACCEPTOR, sizeof(__pyx_k_NOT_ACCEPTOR), 0, 0, 1, 1},
  {&__pyx_n_s_NOT_ACCESSIBLE, __pyx_k_NOT_ACCESSIBLE, sizeof(__pyx_k_NOT_ACCESSIBLE), 0, 0, 1, 1},
  {&__pyx_n_s_NOT_COACCESSIBLE, __pyx_k_NOT_COACCESSIBLE, sizeof(__pyx_k_NOT_COACCESSIBLE), 0, 0, 1, 1},
  {&__pyx_n_s_NOT_I_LABEL_SORTED, __pyx_k_NOT_I_LABEL_SORTED, sizeof(__pyx_k_NOT_I_LABEL_SORTED), 0, 0, 1, 1},
  {&__pyx_n_s_NOT_O_LABEL_SORTED, __pyx_k_NOT_O_LABEL_SORTED, sizeof(__pyx_k_NOT_O_LABEL_SORTED), 0, 0, 1, 1},
  {&__pyx_n_s_NOT_STRING, __pyx_k_NOT_STRING, sizeof(__pyx_k_NOT_STRING), 0, 0, 1, 1},
  {&__pyx_n_s_NOT_TOP_SORTED, __pyx_k_NOT_TOP_SORTED, sizeof(__pyx_k_NOT_TOP_SORTED), 0, 0, 1, 1},
  {&__pyx_n_s_NO_EPSILONS, __pyx_k_NO_EPSILONS, sizeof(__pyx_k_NO_EPSILONS), 0, 0, 1, 1},
  {&__pyx_n_s_NO_I_EPSILONS, __pyx_k_NO_I_EPSILONS, sizeof(__pyx_k_NO_I_EPSILONS), 0, 0, 1, 1},
  {&__pyx_n_s_NO_LABEL, __pyx_k_NO_LABEL, sizeof(__pyx_k_NO_LABEL), 0, 0, 1, 1},
  {&__pyx_n_s_NO_O_EPSILONS, __pyx_k_NO_O_EPSILONS, sizeof(__pyx_k_NO_O_EPSILONS), 0, 0, 1, 1},
  {&__pyx_n_s_NO_STATE_ID, __pyx_k_NO_STATE_ID, sizeof(__pyx_k_NO_STATE_ID), 0, 0, 1, 1},
  {&__pyx_n_s_NO_SYMBOL, __pyx_k_NO_SYMBOL, sizeof(__pyx_k_NO_SYMBOL), 0, 0, 1, 1},
  {&__pyx_n_s_NULL_PROPERTIES, __pyx_k_NULL_PROPERTIES, sizeof(__pyx_k_NULL_PROPERTIES), 0, 0, 1, 1},
  {&__pyx_n_s_NoWeight, __pyx_k_NoWeight, sizeof(__pyx_k_NoWeight), 0, 0, 1, 1},
  {&__pyx_kp_s_No_new_SymbolTables_specified, __pyx_k_No_new_SymbolTables_specified, sizeof(__pyx_k_No_new_SymbolTables_specified), 0, 0, 1, 0},
  {&__pyx_kp_s_No_relabeling_pairs_specified, __pyx_k_No_relabeling_pairs_specified, sizeof(__pyx_k_No_relabeling_pairs_specified), 0, 0, 1, 0},
  {&__pyx_n_s_Number, __pyx_k_Number, sizeof(__pyx_k_Number), 0, 0, 1, 1},
  {&__pyx_n_s_O_DETERMINISTIC, __pyx_k_O_DETERMINISTIC, sizeof(__pyx_k_O_DETERMINISTIC), 0, 0, 1, 1},
  {&__pyx_n_s_O_EPSILONS, __pyx_k_O_EPSILONS, sizeof(__pyx_k_O_EPSILONS), 0, 0, 1, 1},
  {&__pyx_n_s_O_LABEL_INVARIANT_PROPERTIES, __pyx_k_O_LABEL_INVARIANT_PROPERTIES, sizeof(__pyx_k_O_LABEL_INVARIANT_PROPERTIES), 0, 0, 1, 1},
  {&__pyx_n_s_O_LABEL_SORTED, __pyx_k_O_LABEL_SORTED, sizeof(__pyx_k_O_LABEL_SORTED), 0, 0, 1, 1},
  {&__pyx_n_s_One, __pyx_k_One, sizeof(__pyx_k_One), 0, 0, 1, 1},
  {&__pyx_kp_s_Open_failed_r, __pyx_k_Open_failed_r, sizeof(__pyx_k_Open_failed_r), 0, 0, 1, 0},
  {&__pyx_kp_s_Operation_failed, __pyx_k_Operation_failed, sizeof(__pyx_k_Operation_failed), 0, 0, 1, 0},
  {&__pyx_n_s_PIPE, __pyx_k_PIPE, sizeof(__pyx_k_PIPE), 0, 0, 1, 1},
  {&__pyx_n_s_POS_TRINARY_PROPERTIES, __pyx_k_POS_TRINARY_PROPERTIES, sizeof(__pyx_k_POS_TRINARY_PROPERTIES), 0, 0, 1, 1},
  {&__pyx_n_s_Popen, __pyx_k_Popen, sizeof(__pyx_k_Popen), 0, 0, 1, 1},
  {&__pyx_n_s_RM_SUPERFINAL_PROPERTIES, __pyx_k_RM_SUPERFINAL_PROPERTIES, sizeof(__pyx_k_RM_SUPERFINAL_PROPERTIES), 0, 0, 1, 1},
  {&__pyx_kp_s_Read_failed_r, __pyx_k_Read_failed_r, sizeof(__pyx_k_Read_failed_r), 0, 0, 1, 0},
  {&__pyx_kp_s_Read_failed_string, __pyx_k_Read_failed_string, sizeof(__pyx_k_Read_failed_string), 0, 0, 1, 0},
  {&__pyx_n_s_RuntimeError, __pyx_k_RuntimeError, sizeof(__pyx_k_RuntimeError), 0, 0, 1, 1},
  {&__pyx_n_s_SET_ARC_PROPERTIES, __pyx_k_SET_ARC_PROPERTIES, sizeof(__pyx_k_SET_ARC_PROPERTIES), 0, 0, 1, 1},
  {&__pyx_n_s_SET_FINAL_PROPERTIES, __pyx_k_SET_FINAL_PROPERTIES, sizeof(__pyx_k_SET_FINAL_PROPERTIES), 0, 0, 1, 1},
  {&__pyx_n_s_SET_START_PROPERTIES, __pyx_k_SET_START_PROPERTIES, sizeof(__pyx_k_SET_START_PROPERTIES), 0, 0, 1, 1},
  {&__pyx_n_s_STATE_SORT_PROPERTIES, __pyx_k_STATE_SORT_PROPERTIES, sizeof(__pyx_k_STATE_SORT_PROPERTIES), 0, 0, 1, 1},
  {&__pyx_n_s_STRING, __pyx_k_STRING, sizeof(__pyx_k_STRING), 0, 0, 1, 1},
  {&__pyx_kp_s_StateIterator_at_0x_x, __pyx_k_StateIterator_at_0x_x, sizeof(__pyx_k_StateIterator_at_0x_x), 0, 0, 1, 0},
  {&__pyx_kp_s_State_index_out_of_range, __pyx_k_State_index_out_of_range, sizeof(__pyx_k_State_index_out_of_range), 0, 0, 1, 0},
  {&__pyx_n_s_StopIteration, __pyx_k_StopIteration, sizeof(__pyx_k_StopIteration), 0, 0, 1, 1},
  {&__pyx_kp_s_SymbolTableIterator_at_0x_x, __pyx_k_SymbolTableIterator_at_0x_x, sizeof(__pyx_k_SymbolTableIterator_at_0x_x), 0, 0, 1, 0},
  {&__pyx_kp_s_SymbolTable_r_at_0x_x, __pyx_k_SymbolTable_r_at_0x_x, sizeof(__pyx_k_SymbolTable_r_at_0x_x), 0, 0, 1, 0},
  {&__pyx_n_s_TOP_SORTED, __pyx_k_TOP_SORTED, sizeof(__pyx_k_TOP_SORTED), 0, 0, 1, 1},
  {&__pyx_n_s_TRINARY_PROPERTIES, __pyx_k_TRINARY_PROPERTIES, sizeof(__pyx_k_TRINARY_PROPERTIES), 0, 0, 1, 1},
  {&__pyx_kp_s_Tsvg, __pyx_k_Tsvg, sizeof(__pyx_k_Tsvg), 0, 0, 1, 0},
  {&__pyx_n_s_TypeError, __pyx_k_TypeError, sizeof(__pyx_k_TypeError), 0, 0, 1, 1},
  {&__pyx_n_s_UNWEIGHTED, __pyx_k_UNWEIGHTED, sizeof(__pyx_k_UNWEIGHTED), 0, 0, 1, 1},
  {&__pyx_n_s_UNWEIGHTED_CYCLES, __pyx_k_UNWEIGHTED_CYCLES, sizeof(__pyx_k_UNWEIGHTED_CYCLES), 0, 0, 1, 1},
  {&__pyx_kp_s_Unknown_arc_type_r, __pyx_k_Unknown_arc_type_r, sizeof(__pyx_k_Unknown_arc_type_r), 0, 0, 1, 0},
  {&__pyx_kp_s_Unknown_compose_filter_type_r, __pyx_k_Unknown_compose_filter_type_r, sizeof(__pyx_k_Unknown_compose_filter_type_r), 0, 0, 1, 0},
  {&__pyx_kp_s_Unknown_determinization_type_r, __pyx_k_Unknown_determinization_type_r, sizeof(__pyx_k_Unknown_determinization_type_r), 0, 0, 1, 0},
  {&__pyx_kp_s_Unknown_map_type_r, __pyx_k_Unknown_map_type_r, sizeof(__pyx_k_Unknown_map_type_r), 0, 0, 1, 0},
  {&__pyx_kp_s_Unknown_queue_type_r, __pyx_k_Unknown_queue_type_r, sizeof(__pyx_k_Unknown_queue_type_r), 0, 0, 1, 0},
  {&__pyx_kp_s_Unknown_random_arc_selection_typ, __pyx_k_Unknown_random_arc_selection_typ, sizeof(__pyx_k_Unknown_random_arc_selection_typ), 0, 0, 1, 0},
  {&__pyx_kp_s_Unknown_replace_label_type_r, __pyx_k_Unknown_replace_label_type_r, sizeof(__pyx_k_Unknown_replace_label_type_r), 0, 0, 1, 0},
  {&__pyx_kp_s_Unknown_sort_type_r, __pyx_k_Unknown_sort_type_r, sizeof(__pyx_k_Unknown_sort_type_r), 0, 0, 1, 0},
  {&__pyx_n_s_ValueError, __pyx_k_ValueError, sizeof(__pyx_k_ValueError), 0, 0, 1, 1},
  {&__pyx_n_s_WEIGHTED, __pyx_k_WEIGHTED, sizeof(__pyx_k_WEIGHTED), 0, 0, 1, 1},
  {&__pyx_n_s_WEIGHTED_CYCLES, __pyx_k_WEIGHTED_CYCLES, sizeof(__pyx_k_WEIGHTED_CYCLES), 0, 0, 1, 1},
  {&__pyx_n_s_WEIGHT_INVARIANT_PROPERTIES, __pyx_k_WEIGHT_INVARIANT_PROPERTIES, sizeof(__pyx_k_WEIGHT_INVARIANT_PROPERTIES), 0, 0, 1, 1},
  {&__pyx_kp_s_Weight_at_0x_x, __pyx_k_Weight_at_0x_x, sizeof(__pyx_k_Weight_at_0x_x), 0, 0, 1, 0},
  {&__pyx_kp_s_Weight_type_not_found, __pyx_k_Weight_type_not_found, sizeof(__pyx_k_Weight_type_not_found), 0, 0, 1, 0},
  {&__pyx_kp_s_Write_failed_r, __pyx_k_Write_failed_r, sizeof(__pyx_k_Write_failed_r), 0, 0, 1, 0},
  {&__pyx_kp_s_Write_to_string_failed, __pyx_k_Write_to_string_failed, sizeof(__pyx_k_Write_to_string_failed), 0, 0, 1, 0},
  {&__pyx_n_s_Zero, __pyx_k_Zero, sizeof(__pyx_k_Zero), 0, 0, 1, 1},
  {&__pyx_kp_b__24, __pyx_k__24, sizeof(__pyx_k__24), 0, 0, 0, 0},
  {&__pyx_n_s_acceptor, __pyx_k_acceptor, sizeof(__pyx_k_acceptor), 0, 0, 1, 1},
  {&__pyx_n_s_add, __pyx_k_add, sizeof(__pyx_k_add), 0, 0, 1, 1},
  {&__pyx_n_s_add_state, __pyx_k_add_state, sizeof(__pyx_k_add_state), 0, 0, 1, 1},
  {&__pyx_n_s_add_symbol, __pyx_k_add_symbol, sizeof(__pyx_k_add_symbol), 0, 0, 1, 1},
  {&__pyx_n_s_add_table, __pyx_k_add_table, sizeof(__pyx_k_add_table), 0, 0, 1, 1},
  {&__pyx_n_s_allow_negative_labels, __pyx_k_allow_negative_labels, sizeof(__pyx_k_allow_negative_labels), 0, 0, 1, 1},
  {&__pyx_n_s_allow_nondet, __pyx_k_allow_nondet, sizeof(__pyx_k_allow_nondet), 0, 0, 1, 1},
  {&__pyx_n_s_arc, __pyx_k_arc, sizeof(__pyx_k_arc), 0, 0, 1, 1},
  {&__pyx_n_s_arc_type, __pyx_k_arc_type, sizeof(__pyx_k_arc_type), 0, 0, 1, 1},
  {&__pyx_n_s_arcs, __pyx_k_arcs, sizeof(__pyx_k_arcs), 0, 0, 1, 1},
  {&__pyx_n_s_atexit, __pyx_k_atexit, sizeof(__pyx_k_atexit), 0, 0, 1, 1},
  {&__pyx_n_s_attach_new_isymbols, __pyx_k_attach_new_isymbols, sizeof(__pyx_k_attach_new_isymbols), 0, 0, 1, 1},
  {&__pyx_n_s_attach_new_osymbols, __pyx_k_attach_new_osymbols, sizeof(__pyx_k_attach_new_osymbols), 0, 0, 1, 1},
  {&__pyx_n_b_auto, __pyx_k_auto, sizeof(__pyx_k_auto), 0, 0, 0, 1},
  {&__pyx_n_s_available_key, __pyx_k_available_key, sizeof(__pyx_k_available_key), 0, 0, 1, 1},
  {&__pyx_n_s_call_arc_labeling, __pyx_k_call_arc_labeling, sizeof(__pyx_k_call_arc_labeling), 0, 0, 1, 1},
  {&__pyx_n_s_checksum, __pyx_k_checksum, sizeof(__pyx_k_checksum), 0, 0, 1, 1},
  {&__pyx_n_s_class, __pyx_k_class, sizeof(__pyx_k_class), 0, 0, 1, 1},
  {&__pyx_n_s_cline_in_traceback, __pyx_k_cline_in_traceback, sizeof(__pyx_k_cline_in_traceback), 0, 0, 1, 1},
  {&__pyx_n_s_closure_plus, __pyx_k_closure_plus, sizeof(__pyx_k_closure_plus), 0, 0, 1, 1},
  {&__pyx_n_s_cls, __pyx_k_cls, sizeof(__pyx_k_cls), 0, 0, 1, 1},
  {&__pyx_n_s_communicate, __pyx_k_communicate, sizeof(__pyx_k_communicate), 0, 0, 1, 1},
  {&__pyx_n_s_compile, __pyx_k_compile, sizeof(__pyx_k_compile), 0, 0, 1, 1},
  {&__pyx_n_s_compose_filter, __pyx_k_compose_filter, sizeof(__pyx_k_compose_filter), 0, 0, 1, 1},
  {&__pyx_n_s_connect, __pyx_k_connect, sizeof(__pyx_k_connect), 0, 0, 1, 1},
  {&__pyx_kp_s_const_EncodeMapper_SymbolTable, __pyx_k_const_EncodeMapper_SymbolTable, sizeof(__pyx_k_const_EncodeMapper_SymbolTable), 0, 0, 1, 0},
  {&__pyx_kp_s_const_Fst_SymbolTable_r_at_0x_x, __pyx_k_const_Fst_SymbolTable_r_at_0x_x, sizeof(__pyx_k_const_Fst_SymbolTable_r_at_0x_x), 0, 0, 1, 0},
  {&__pyx_n_s_copy, __pyx_k_copy, sizeof(__pyx_k_copy), 0, 0, 1, 1},
  {&__pyx_n_s_create, __pyx_k_create, sizeof(__pyx_k_create), 0, 0, 1, 1},
  {&__pyx_n_s_decode, __pyx_k_decode, sizeof(__pyx_k_decode), 0, 0, 1, 1},
  {&__pyx_n_b_default, __pyx_k_default, sizeof(__pyx_k_default), 0, 0, 0, 1},
  {&__pyx_n_s_delta, __pyx_k_delta, sizeof(__pyx_k_delta), 0, 0, 1, 1},
  {&__pyx_n_s_det_type, __pyx_k_det_type, sizeof(__pyx_k_det_type), 0, 0, 1, 1},
  {&__pyx_n_s_distance, __pyx_k_distance, sizeof(__pyx_k_distance), 0, 0, 1, 1},
  {&__pyx_n_s_divide, __pyx_k_divide, sizeof(__pyx_k_divide), 0, 0, 1, 1},
  {&__pyx_n_s_doc, __pyx_k_doc, sizeof(__pyx_k_doc), 0, 0, 1, 1},
  {&__pyx_n_s_done, __pyx_k_done, sizeof(__pyx_k_done), 0, 0, 1, 1},
  {&__pyx_n_s_dot, __pyx_k_dot, sizeof(__pyx_k_dot), 0, 0, 1, 1},
  {&__pyx_n_s_draw, __pyx_k_draw, sizeof(__pyx_k_draw), 0, 0, 1, 1},
  {&__pyx_n_s_encode, __pyx_k_encode, sizeof(__pyx_k_encode), 0, 0, 1, 1},
  {&__pyx_n_s_encode_labels, __pyx_k_encode_labels, sizeof(__pyx_k_encode_labels), 0, 0, 1, 1},
  {&__pyx_n_s_encode_weights, __pyx_k_encode_weights, sizeof(__pyx_k_encode_weights), 0, 0, 1, 1},
  {&__pyx_n_s_eps_norm_output, __pyx_k_eps_norm_output, sizeof(__pyx_k_eps_norm_output), 0, 0, 1, 1},
  {&__pyx_n_s_epsilon_on_replace, __pyx_k_epsilon_on_replace, sizeof(__pyx_k_epsilon_on_replace), 0, 0, 1, 1},
  {&__pyx_n_s_error, __pyx_k_error, sizeof(__pyx_k_error), 0, 0, 1, 1},
  {&__pyx_n_s_far_type, __pyx_k_far_type, sizeof(__pyx_k_far_type), 0, 0, 1, 1},
  {&__pyx_n_s_filename, __pyx_k_filename, sizeof(__pyx_k_filename), 0, 0, 1, 1},
  {&__pyx_n_s_final, __pyx_k_final, sizeof(__pyx_k_final), 0, 0, 1, 1},
  {&__pyx_n_s_find, __pyx_k_find, sizeof(__pyx_k_find), 0, 0, 1, 1},
  {&__pyx_n_s_flags, __pyx_k_flags, sizeof(__pyx_k_flags), 0, 0, 1, 1},
  {&__pyx_n_s_float_format, __pyx_k_float_format, sizeof(__pyx_k_float_format), 0, 0, 1, 1},
  {&__pyx_n_s_fontsize, __pyx_k_fontsize, sizeof(__pyx_k_fontsize), 0, 0, 1, 1},
  {&__pyx_n_s_format, __pyx_k_format, sizeof(__pyx_k_format), 0, 0, 1, 1},
  {&__pyx_n_s_fst_error_fatal_old, __pyx_k_fst_error_fatal_old, sizeof(__pyx_k_fst_error_fatal_old), 0, 0, 1, 1},
  {&__pyx_n_s_fst_type, __pyx_k_fst_type, sizeof(__pyx_k_fst_type), 0, 0, 1, 1},
  {&__pyx_n_b_functional, __pyx_k_functional, sizeof(__pyx_k_functional), 0, 0, 0, 1},
  {&__pyx_n_b_g, __pyx_k_g, sizeof(__pyx_k_g), 0, 0, 0, 1},
  {&__pyx_n_s_get_fst, __pyx_k_get_fst, sizeof(__pyx_k_get_fst), 0, 0, 1, 1},
  {&__pyx_n_s_get_key, __pyx_k_get_key, sizeof(__pyx_k_get_key), 0, 0, 1, 1},
  {&__pyx_n_s_get_nth_key, __pyx_k_get_nth_key, sizeof(__pyx_k_get_nth_key), 0, 0, 1, 1},
  {&__pyx_n_s_getstate, __pyx_k_getstate, sizeof(__pyx_k_getstate), 0, 0, 1, 1},
  {&__pyx_n_s_height, __pyx_k_height, sizeof(__pyx_k_height), 0, 0, 1, 1},
  {&__pyx_n_s_id, __pyx_k_id, sizeof(__pyx_k_id), 0, 0, 1, 1},
  {&__pyx_n_b_identity, __pyx_k_identity, sizeof(__pyx_k_identity), 0, 0, 0, 1},
  {&__pyx_n_s_ifst, __pyx_k_ifst, sizeof(__pyx_k_ifst), 0, 0, 1, 1},
  {&__pyx_n_s_ifst1, __pyx_k_ifst1, sizeof(__pyx_k_ifst1), 0, 0, 1, 1},
  {&__pyx_n_s_ifst2, __pyx_k_ifst2, sizeof(__pyx_k_ifst2), 0, 0, 1, 1},
  {&__pyx_n_b_ilabel, __pyx_k_ilabel, sizeof(__pyx_k_ilabel), 0, 0, 0, 1},
  {&__pyx_n_s_ilabel, __pyx_k_ilabel, sizeof(__pyx_k_ilabel), 0, 0, 1, 1},
  {&__pyx_n_s_import, __pyx_k_import, sizeof(__pyx_k_import), 0, 0, 1, 1},
  {&__pyx_n_s_increment_subsequential_label, __pyx_k_increment_subsequential_label, sizeof(__pyx_k_increment_subsequential_label), 0, 0, 1, 1},
  {&__pyx_n_b_input, __pyx_k_input, sizeof(__pyx_k_input), 0, 0, 0, 1},
  {&__pyx_n_s_input_symbols, __pyx_k_input_symbols, sizeof(__pyx_k_input_symbols), 0, 0, 1, 1},
  {&__pyx_n_s_input_table, __pyx_k_input_table, sizeof(__pyx_k_input_table), 0, 0, 1, 1},
  {&__pyx_n_s_ipairs, __pyx_k_ipairs, sizeof(__pyx_k_ipairs), 0, 0, 1, 1},
  {&__pyx_n_s_isymbols, __pyx_k_isymbols, sizeof(__pyx_k_isymbols), 0, 0, 1, 1},
  {&__pyx_n_s_kNoSymbol, __pyx_k_kNoSymbol, sizeof(__pyx_k_kNoSymbol), 0, 0, 1, 1},
  {&__pyx_n_s_keep_isymbols, __pyx_k_keep_isymbols, sizeof(__pyx_k_keep_isymbols), 0, 0, 1, 1},
  {&__pyx_n_s_keep_osymbols, __pyx_k_keep_osymbols, sizeof(__pyx_k_keep_osymbols), 0, 0, 1, 1},
  {&__pyx_n_s_keep_state_numbering, __pyx_k_keep_state_numbering, sizeof(__pyx_k_keep_state_numbering), 0, 0, 1, 1},
  {&__pyx_n_s_key, __pyx_k_key, sizeof(__pyx_k_key), 0, 0, 1, 1},
  {&__pyx_n_s_labeled_checksum, __pyx_k_labeled_checksum, sizeof(__pyx_k_labeled_checksum), 0, 0, 1, 1},
  {&__pyx_n_s_lhs, __pyx_k_lhs, sizeof(__pyx_k_lhs), 0, 0, 1, 1},
  {&__pyx_n_s_logging, __pyx_k_logging, sizeof(__pyx_k_logging), 0, 0, 1, 1},
  {&__pyx_n_s_main, __pyx_k_main, sizeof(__pyx_k_main), 0, 0, 1, 1},
  {&__pyx_n_s_map_type, __pyx_k_map_type, sizeof(__pyx_k_map_type), 0, 0, 1, 1},
  {&__pyx_n_s_mask, __pyx_k_mask, sizeof(__pyx_k_mask), 0, 0, 1, 1},
  {&__pyx_n_s_max_length, __pyx_k_max_length, sizeof(__pyx_k_max_length), 0, 0, 1, 1},
  {&__pyx_n_s_member, __pyx_k_member, sizeof(__pyx_k_member), 0, 0, 1, 1},
  {&__pyx_n_s_metaclass, __pyx_k_metaclass, sizeof(__pyx_k_metaclass), 0, 0, 1, 1},
  {&__pyx_n_s_missing_sym, __pyx_k_missing_sym, sizeof(__pyx_k_missing_sym), 0, 0, 1, 1},
  {&__pyx_n_s_module, __pyx_k_module, sizeof(__pyx_k_module), 0, 0, 1, 1},
  {&__pyx_n_s_mutable_arcs, __pyx_k_mutable_arcs, sizeof(__pyx_k_mutable_arcs), 0, 0, 1, 1},
  {&__pyx_n_s_n, __pyx_k_n, sizeof(__pyx_k_n), 0, 0, 1, 1},
  {&__pyx_n_s_name, __pyx_k_name, sizeof(__pyx_k_name), 0, 0, 1, 1},
  {&__pyx_n_s_name_2, __pyx_k_name_2, sizeof(__pyx_k_name_2), 0, 0, 1, 1},
  {&__pyx_n_b_neither, __pyx_k_neither, sizeof(__pyx_k_neither), 0, 0, 0, 1},
  {&__pyx_n_s_new, __pyx_k_new, sizeof(__pyx_k_new), 0, 0, 1, 1},
  {&__pyx_n_s_new_isymbols, __pyx_k_new_isymbols, sizeof(__pyx_k_new_isymbols), 0, 0, 1, 1},
  {&__pyx_n_s_new_osymbols, __pyx_k_new_osymbols, sizeof(__pyx_k_new_osymbols), 0, 0, 1, 1},
  {&__pyx_n_s_next, __pyx_k_next, sizeof(__pyx_k_next), 0, 0, 1, 1},
  {&__pyx_n_s_nextstate, __pyx_k_nextstate, sizeof(__pyx_k_nextstate), 0, 0, 1, 1},
  {&__pyx_kp_s_no_default___reduce___due_to_non, __pyx_k_no_default___reduce___due_to_non, sizeof(__pyx_k_no_default___reduce___due_to_non), 0, 0, 1, 0},
  {&__pyx_n_s_nodesep, __pyx_k_nodesep, sizeof(__pyx_k_nodesep), 0, 0, 1, 1},
  {&__pyx_n_s_npath, __pyx_k_npath, sizeof(__pyx_k_npath), 0, 0, 1, 1},
  {&__pyx_n_s_nshortest, __pyx_k_nshortest, sizeof(__pyx_k_nshortest), 0, 0, 1, 1},
  {&__pyx_n_s_nstate, __pyx_k_nstate, sizeof(__pyx_k_nstate), 0, 0, 1, 1},
  {&__pyx_n_s_num_arcs, __pyx_k_num_arcs, sizeof(__pyx_k_num_arcs), 0, 0, 1, 1},
  {&__pyx_n_s_num_input_epsilons, __pyx_k_num_input_epsilons, sizeof(__pyx_k_num_input_epsilons), 0, 0, 1, 1},
  {&__pyx_n_s_num_output_epsilons, __pyx_k_num_output_epsilons, sizeof(__pyx_k_num_output_epsilons), 0, 0, 1, 1},
  {&__pyx_n_s_num_states, __pyx_k_num_states, sizeof(__pyx_k_num_states), 0, 0, 1, 1},
  {&__pyx_n_s_num_symbols, __pyx_k_num_symbols, sizeof(__pyx_k_num_symbols), 0, 0, 1, 1},
  {&__pyx_n_s_numbers, __pyx_k_numbers, sizeof(__pyx_k_numbers), 0, 0, 1, 1},
  {&__pyx_n_s_object, __pyx_k_object, sizeof(__pyx_k_object), 0, 0, 1, 1},
  {&__pyx_n_s_olabel, __pyx_k_olabel, sizeof(__pyx_k_olabel), 0, 0, 1, 1},
  {&__pyx_n_s_old_isymbols, __pyx_k_old_isymbols, sizeof(__pyx_k_old_isymbols), 0, 0, 1, 1},
  {&__pyx_n_s_old_osymbols, __pyx_k_old_osymbols, sizeof(__pyx_k_old_osymbols), 0, 0, 1, 1},
  {&__pyx_n_s_opairs, __pyx_k_opairs, sizeof(__pyx_k_opairs), 0, 0, 1, 1},
  {&__pyx_n_s_open, __pyx_k_open, sizeof(__pyx_k_open), 0, 0, 1, 1},
  {&__pyx_n_s_osymbols, __pyx_k_osymbols, sizeof(__pyx_k_osymbols), 0, 0, 1, 1},
  {&__pyx_n_s_output_symbols, __pyx_k_output_symbols, sizeof(__pyx_k_output_symbols), 0, 0, 1, 1},
  {&__pyx_n_s_pairs, __pyx_k_pairs, sizeof(__pyx_k_pairs), 0, 0, 1, 1},
  {&__pyx_n_s_plus, __pyx_k_plus, sizeof(__pyx_k_plus), 0, 0, 1, 1},
  {&__pyx_n_s_portrait, __pyx_k_portrait, sizeof(__pyx_k_portrait), 0, 0, 1, 1},
  {&__pyx_n_s_position, __pyx_k_position, sizeof(__pyx_k_position), 0, 0, 1, 1},
  {&__pyx_n_s_potentials, __pyx_k_potentials, sizeof(__pyx_k_potentials), 0, 0, 1, 1},
  {&__pyx_n_s_power, __pyx_k_power, sizeof(__pyx_k_power), 0, 0, 1, 1},
  {&__pyx_n_s_precision, __pyx_k_precision, sizeof(__pyx_k_precision), 0, 0, 1, 1},
  {&__pyx_n_s_prepare, __pyx_k_prepare, sizeof(__pyx_k_prepare), 0, 0, 1, 1},
  {&__pyx_n_s_project_output, __pyx_k_project_output, sizeof(__pyx_k_project_output), 0, 0, 1, 1},
  {&__pyx_n_s_properties, __pyx_k_properties, sizeof(__pyx_k_properties), 0, 0, 1, 1},
  {&__pyx_n_s_props, __pyx_k_props, sizeof(__pyx_k_props), 0, 0, 1, 1},
  {&__pyx_n_s_push_labels, __pyx_k_push_labels, sizeof(__pyx_k_push_labels), 0, 0, 1, 1},
  {&__pyx_n_s_push_weights, __pyx_k_push_weights, sizeof(__pyx_k_push_weights), 0, 0, 1, 1},
  {&__pyx_kp_b_pywrapfst, __pyx_k_pywrapfst, sizeof(__pyx_k_pywrapfst), 0, 0, 0, 0},
  {&__pyx_n_s_pywrapfst_2, __pyx_k_pywrapfst_2, sizeof(__pyx_k_pywrapfst_2), 0, 0, 1, 1},
  {&__pyx_kp_s_pywrapfst_pyx, __pyx_k_pywrapfst_pyx, sizeof(__pyx_k_pywrapfst_pyx), 0, 0, 1, 0},
  {&__pyx_n_s_pyx_vtable, __pyx_k_pyx_vtable, sizeof(__pyx_k_pyx_vtable), 0, 0, 1, 1},
  {&__pyx_n_s_qualname, __pyx_k_qualname, sizeof(__pyx_k_qualname), 0, 0, 1, 1},
  {&__pyx_n_s_queue_type, __pyx_k_queue_type, sizeof(__pyx_k_queue_type), 0, 0, 1, 1},
  {&__pyx_n_s_ranksep, __pyx_k_ranksep, sizeof(__pyx_k_ranksep), 0, 0, 1, 1},
  {&__pyx_n_s_read, __pyx_k_read, sizeof(__pyx_k_read), 0, 0, 1, 1},
  {&__pyx_n_s_read_from_string, __pyx_k_read_from_string, sizeof(__pyx_k_read_from_string), 0, 0, 1, 1},
  {&__pyx_n_s_read_from_string_2, __pyx_k_read_from_string_2, sizeof(__pyx_k_read_from_string_2), 0, 0, 1, 1},
  {&__pyx_n_s_read_fst, __pyx_k_read_fst, sizeof(__pyx_k_read_fst), 0, 0, 1, 1},
  {&__pyx_n_s_read_text, __pyx_k_read_text, sizeof(__pyx_k_read_text), 0, 0, 1, 1},
  {&__pyx_n_s_reduce, __pyx_k_reduce, sizeof(__pyx_k_reduce), 0, 0, 1, 1},
  {&__pyx_n_s_reduce_cython, __pyx_k_reduce_cython, sizeof(__pyx_k_reduce_cython), 0, 0, 1, 1},
  {&__pyx_n_s_reduce_ex, __pyx_k_reduce_ex, sizeof(__pyx_k_reduce_ex), 0, 0, 1, 1},
  {&__pyx_n_s_register, __pyx_k_register, sizeof(__pyx_k_register), 0, 0, 1, 1},
  {&__pyx_n_s_remove_common_affix, __pyx_k_remove_common_affix, sizeof(__pyx_k_remove_common_affix), 0, 0, 1, 1},
  {&__pyx_n_s_remove_total_weight, __pyx_k_remove_total_weight, sizeof(__pyx_k_remove_total_weight), 0, 0, 1, 1},
  {&__pyx_n_b_repr_svg, __pyx_k_repr_svg, sizeof(__pyx_k_repr_svg), 0, 0, 0, 1},
  {&__pyx_n_s_require_superinitial, __pyx_k_require_superinitial, sizeof(__pyx_k_require_superinitial), 0, 0, 1, 1},
  {&__pyx_n_s_reset, __pyx_k_reset, sizeof(__pyx_k_reset), 0, 0, 1, 1},
  {&__pyx_n_s_reset_fst_error_fatal, __pyx_k_reset_fst_error_fatal, sizeof(__pyx_k_reset_fst_error_fatal), 0, 0, 1, 1},
  {&__pyx_n_s_result, __pyx_k_result, sizeof(__pyx_k_result), 0, 0, 1, 1},
  {&__pyx_n_s_return_arc_labeling, __pyx_k_return_arc_labeling, sizeof(__pyx_k_return_arc_labeling), 0, 0, 1, 1},
  {&__pyx_n_s_return_label, __pyx_k_return_label, sizeof(__pyx_k_return_label), 0, 0, 1, 1},
  {&__pyx_n_s_returncode, __pyx_k_returncode, sizeof(__pyx_k_returncode), 0, 0, 1, 1},
  {&__pyx_n_s_reverse, __pyx_k_reverse, sizeof(__pyx_k_reverse), 0, 0, 1, 1},
  {&__pyx_n_s_rhs, __pyx_k_rhs, sizeof(__pyx_k_rhs), 0, 0, 1, 1},
  {&__pyx_n_s_seed, __pyx_k_seed, sizeof(__pyx_k_seed), 0, 0, 1, 1},
  {&__pyx_n_s_seek, __pyx_k_seek, sizeof(__pyx_k_seek), 0, 0, 1, 1},
  {&__pyx_n_s_select, __pyx_k_select, sizeof(__pyx_k_select), 0, 0, 1, 1},
  {&__pyx_kp_s_self__aiter_self__fst_cannot_be, __pyx_k_self__aiter_self__fst_cannot_be, sizeof(__pyx_k_self__aiter_self__fst_cannot_be), 0, 0, 1, 0},
  {&__pyx_kp_s_self__aiter_self__mfst_cannot_be, __pyx_k_self__aiter_self__mfst_cannot_be, sizeof(__pyx_k_self__aiter_self__mfst_cannot_be), 0, 0, 1, 0},
  {&__pyx_kp_s_self__arc_cannot_be_converted_to, __pyx_k_self__arc_cannot_be_converted_to, sizeof(__pyx_k_self__arc_cannot_be_converted_to), 0, 0, 1, 0},
  {&__pyx_kp_s_self__encoder_cannot_be_converte, __pyx_k_self__encoder_cannot_be_converte, sizeof(__pyx_k_self__encoder_cannot_be_converte), 0, 0, 1, 0},
  {&__pyx_kp_s_self__encoder_self__table_cannot, __pyx_k_self__encoder_self__table_cannot, sizeof(__pyx_k_self__encoder_self__table_cannot), 0, 0, 1, 0},
  {&__pyx_kp_s_self__fst_self__siter_cannot_be, __pyx_k_self__fst_self__siter_cannot_be, sizeof(__pyx_k_self__fst_self__siter_cannot_be), 0, 0, 1, 0},
  {&__pyx_kp_s_self__fst_self__table_cannot_be, __pyx_k_self__fst_self__table_cannot_be, sizeof(__pyx_k_self__fst_self__table_cannot_be), 0, 0, 1, 0},
  {&__pyx_kp_s_self__mfst_self__table_cannot_be, __pyx_k_self__mfst_self__table_cannot_be, sizeof(__pyx_k_self__mfst_self__table_cannot_be), 0, 0, 1, 0},
  {&__pyx_kp_s_self__reader_cannot_be_converted, __pyx_k_self__reader_cannot_be_converted, sizeof(__pyx_k_self__reader_cannot_be_converted), 0, 0, 1, 0},
  {&__pyx_kp_s_self__siter_self__table_cannot_b, __pyx_k_self__siter_self__table_cannot_b, sizeof(__pyx_k_self__siter_self__table_cannot_b), 0, 0, 1, 0},
  {&__pyx_kp_s_self__smart_table_self__table_ca, __pyx_k_self__smart_table_self__table_ca, sizeof(__pyx_k_self__smart_table_self__table_ca), 0, 0, 1, 0},
  {&__pyx_kp_s_self__table_cannot_be_converted, __pyx_k_self__table_cannot_be_converted, sizeof(__pyx_k_self__table_cannot_be_converted), 0, 0, 1, 0},
  {&__pyx_kp_s_self__weight_cannot_be_converted, __pyx_k_self__weight_cannot_be_converted, sizeof(__pyx_k_self__weight_cannot_be_converted), 0, 0, 1, 0},
  {&__pyx_kp_s_self__writer_cannot_be_converted, __pyx_k_self__writer_cannot_be_converted, sizeof(__pyx_k_self__writer_cannot_be_converted), 0, 0, 1, 0},
  {&__pyx_n_s_set_flags, __pyx_k_set_flags, sizeof(__pyx_k_set_flags), 0, 0, 1, 1},
  {&__pyx_n_s_set_input_symbols, __pyx_k_set_input_symbols, sizeof(__pyx_k_set_input_symbols), 0, 0, 1, 1},
  {&__pyx_n_s_set_name, __pyx_k_set_name, sizeof(__pyx_k_set_name), 0, 0, 1, 1},
  {&__pyx_n_s_set_output_symbols, __pyx_k_set_output_symbols, sizeof(__pyx_k_set_output_symbols), 0, 0, 1, 1},
  {&__pyx_n_s_set_value, __pyx_k_set_value, sizeof(__pyx_k_set_value), 0, 0, 1, 1},
  {&__pyx_n_s_setstate, __pyx_k_setstate, sizeof(__pyx_k_setstate), 0, 0, 1, 1},
  {&__pyx_n_s_setstate_cython, __pyx_k_setstate_cython, sizeof(__pyx_k_setstate_cython), 0, 0, 1, 1},
  {&__pyx_n_s_shortestdistance, __pyx_k_shortestdistance, sizeof(__pyx_k_shortestdistance), 0, 0, 1, 1},
  {&__pyx_n_s_show_weight_one, __pyx_k_show_weight_one, sizeof(__pyx_k_show_weight_one), 0, 0, 1, 1},
  {&__pyx_n_s_sort_type, __pyx_k_sort_type, sizeof(__pyx_k_sort_type), 0, 0, 1, 1},
  {&__pyx_n_s_ssymbols, __pyx_k_ssymbols, sizeof(__pyx_k_ssymbols), 0, 0, 1, 1},
  {&__pyx_n_b_standard, __pyx_k_standard, sizeof(__pyx_k_standard), 0, 0, 0, 1},
  {&__pyx_n_s_start, __pyx_k_start, sizeof(__pyx_k_start), 0, 0, 1, 1},
  {&__pyx_n_s_state, __pyx_k_state, sizeof(__pyx_k_state), 0, 0, 1, 1},
  {&__pyx_n_s_states, __pyx_k_states, sizeof(__pyx_k_states), 0, 0, 1, 1},
  {&__pyx_n_s_staticmethod, __pyx_k_staticmethod, sizeof(__pyx_k_staticmethod), 0, 0, 1, 1},
  {&__pyx_n_s_stderr, __pyx_k_stderr, sizeof(__pyx_k_stderr), 0, 0, 1, 1},
  {&__pyx_n_s_stdin, __pyx_k_stdin, sizeof(__pyx_k_stdin), 0, 0, 1, 1},
  {&__pyx_n_s_stdout, __pyx_k_stdout, sizeof(__pyx_k_stdout), 0, 0, 1, 1},
  {&__pyx_n_s_subprocess, __pyx_k_subprocess, sizeof(__pyx_k_subprocess), 0, 0, 1, 1},
  {&__pyx_n_s_subsequential_label, __pyx_k_subsequential_label, sizeof(__pyx_k_subsequential_label), 0, 0, 1, 1},
  {&__pyx_n_s_symbol, __pyx_k_symbol, sizeof(__pyx_k_symbol), 0, 0, 1, 1},
  {&__pyx_n_s_syms, __pyx_k_syms, sizeof(__pyx_k_syms), 0, 0, 1, 1},
  {&__pyx_n_s_test, __pyx_k_test, sizeof(__pyx_k_test), 0, 0, 1, 1},
  {&__pyx_n_s_test_2, __pyx_k_test_2, sizeof(__pyx_k_test_2), 0, 0, 1, 1},
  {&__pyx_n_s_text, __pyx_k_text, sizeof(__pyx_k_text), 0, 0, 1, 1},
  {&__pyx_n_s_times, __pyx_k_times, sizeof(__pyx_k_times), 0, 0, 1, 1},
  {&__pyx_n_s_title, __pyx_k_title, sizeof(__pyx_k_title), 0, 0, 1, 1},
  {&__pyx_n_s_to_final, __pyx_k_to_final, sizeof(__pyx_k_to_final), 0, 0, 1, 1},
  {&__pyx_n_s_to_string, __pyx_k_to_string, sizeof(__pyx_k_to_string), 0, 0, 1, 1},
  {&__pyx_n_b_tropical, __pyx_k_tropical, sizeof(__pyx_k_tropical), 0, 0, 0, 1},
  {&__pyx_n_s_type, __pyx_k_type, sizeof(__pyx_k_type), 0, 0, 1, 1},
  {&__pyx_n_b_uniform, __pyx_k_uniform, sizeof(__pyx_k_uniform), 0, 0, 0, 1},
  {&__pyx_n_s_unique, __pyx_k_unique, sizeof(__pyx_k_unique), 0, 0, 1, 1},
  {&__pyx_n_s_unknown_isymbol, __pyx_k_unknown_isymbol, sizeof(__pyx_k_unknown_isymbol), 0, 0, 1, 1},
  {&__pyx_n_s_unknown_osymbol, __pyx_k_unknown_osymbol, sizeof(__pyx_k_unknown_osymbol), 0, 0, 1, 1},
  {&__pyx_kp_b_unspecified, __pyx_k_unspecified, sizeof(__pyx_k_unspecified), 0, 0, 0, 0},
  {&__pyx_n_s_utf8, __pyx_k_utf8, sizeof(__pyx_k_utf8), 0, 0, 1, 1},
  {&__pyx_n_s_value, __pyx_k_value, sizeof(__pyx_k_value), 0, 0, 1, 1},
  {&__pyx_n_b_vector, __pyx_k_vector, sizeof(__pyx_k_vector), 0, 0, 0, 1},
  {&__pyx_n_s_verify, __pyx_k_verify, sizeof(__pyx_k_verify), 0, 0, 1, 1},
  {&__pyx_n_s_vertical, __pyx_k_vertical, sizeof(__pyx_k_vertical), 0, 0, 1, 1},
  {&__pyx_n_s_w, __pyx_k_w, sizeof(__pyx_k_w), 0, 0, 1, 1},
  {&__pyx_n_s_warning, __pyx_k_warning, sizeof(__pyx_k_warning), 0, 0, 1, 1},
  {&__pyx_n_s_weight, __pyx_k_weight, sizeof(__pyx_k_weight), 0, 0, 1, 1},
  {&__pyx_n_s_weight_type, __pyx_k_weight_type, sizeof(__pyx_k_weight_type), 0, 0, 1, 1},
  {&__pyx_n_s_weighted, __pyx_k_weighted, sizeof(__pyx_k_weighted), 0, 0, 1, 1},
  {&__pyx_n_s_width, __pyx_k_width, sizeof(__pyx_k_width), 0, 0, 1, 1},
  {&__pyx_n_s_write, __pyx_k_write, sizeof(__pyx_k_write), 0, 0, 1, 1},
  {&__pyx_n_s_write_text, __pyx_k_write_text, sizeof(__pyx_k_write_text), 0, 0, 1, 1},
  {&__pyx_n_b_write_to_string, __pyx_k_write_to_string, sizeof(__pyx_k_write_to_string), 0, 0, 0, 1},
  {&__pyx_n_s_write_to_string, __pyx_k_write_to_string, sizeof(__pyx_k_write_to_string), 0, 0, 1, 1},
  {0, 0, 0, 0, 0, 0, 0}
};
static int __Pyx_InitCachedBuiltins(void) {
  __pyx_builtin_ValueError = __Pyx_GetBuiltinName(__pyx_n_s_ValueError); if (!__pyx_builtin_ValueError) __PYX_ERR(0, 126, __pyx_L1_error)
  __pyx_builtin_RuntimeError = __Pyx_GetBuiltinName(__pyx_n_s_RuntimeError); if (!__pyx_builtin_RuntimeError) __PYX_ERR(0, 136, __pyx_L1_error)
  __pyx_builtin_IndexError = __Pyx_GetBuiltinName(__pyx_n_s_IndexError); if (!__pyx_builtin_IndexError) __PYX_ERR(0, 141, __pyx_L1_error)
  __pyx_builtin_IOError = __Pyx_GetBuiltinName(__pyx_n_s_IOError); if (!__pyx_builtin_IOError) __PYX_ERR(0, 146, __pyx_L1_error)
  __pyx_builtin_object = __Pyx_GetBuiltinName(__pyx_n_s_object); if (!__pyx_builtin_object) __PYX_ERR(0, 2742, __pyx_L1_error)
  __pyx_builtin_staticmethod = __Pyx_GetBuiltinName(__pyx_n_s_staticmethod); if (!__pyx_builtin_staticmethod) __PYX_ERR(0, 2762, __pyx_L1_error)
  __pyx_builtin_id = __Pyx_GetBuiltinName(__pyx_n_s_id); if (!__pyx_builtin_id) __PYX_ERR(0, 370, __pyx_L1_error)
  __pyx_builtin_TypeError = __Pyx_GetBuiltinName(__pyx_n_s_TypeError); if (!__pyx_builtin_TypeError) __PYX_ERR(1, 2, __pyx_L1_error)
  __pyx_builtin_StopIteration = __Pyx_GetBuiltinName(__pyx_n_s_StopIteration); if (!__pyx_builtin_StopIteration) __PYX_ERR(0, 1145, __pyx_L1_error)
  __pyx_builtin_KeyError = __Pyx_GetBuiltinName(__pyx_n_s_KeyError); if (!__pyx_builtin_KeyError) __PYX_ERR(0, 4357, __pyx_L1_error)
  return 0;
  __pyx_L1_error:;
  return -1;
}

static int __Pyx_InitCachedConstants(void) {
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__Pyx_InitCachedConstants", 0);

  /* "pywrapfst.pyx":388
 *   cdef void _check_weight(self) except *:
 *     if self.type() == b"none":
 *       raise FstArgError("Weight type not found")             # <<<<<<<<<<<<<<
 *     if self.to_string() == b"BadNumber":
 *       raise FstBadWeightError("Invalid weight")
 */
  __pyx_tuple_ = PyTuple_Pack(1, __pyx_kp_s_Weight_type_not_found); if (unlikely(!__pyx_tuple_)) __PYX_ERR(0, 388, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple_);
  __Pyx_GIVEREF(__pyx_tuple_);

  /* "pywrapfst.pyx":390
 *       raise FstArgError("Weight type not found")
 *     if self.to_string() == b"BadNumber":
 *       raise FstBadWeightError("Invalid weight")             # <<<<<<<<<<<<<<
 * 
 *   cpdef Weight copy(self):
 */
  __pyx_tuple__2 = PyTuple_Pack(1, __pyx_kp_s_Invalid_weight); if (unlikely(!__pyx_tuple__2)) __PYX_ERR(0, 390, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__2);
  __Pyx_GIVEREF(__pyx_tuple__2);

  /* "(tree fragment)":2
 * def __reduce_cython__(self):
 *     raise TypeError("self._weight cannot be converted to a Python object for pickling")             # <<<<<<<<<<<<<<
 * def __setstate_cython__(self, __pyx_state):
 *     raise TypeError("self._weight cannot be converted to a Python object for pickling")
 */
  __pyx_tuple__3 = PyTuple_Pack(1, __pyx_kp_s_self__weight_cannot_be_converted); if (unlikely(!__pyx_tuple__3)) __PYX_ERR(1, 2, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__3);
  __Pyx_GIVEREF(__pyx_tuple__3);

  /* "(tree fragment)":4
 *     raise TypeError("self._weight cannot be converted to a Python object for pickling")
 * def __setstate_cython__(self, __pyx_state):
 *     raise TypeError("self._weight cannot be converted to a Python object for pickling")             # <<<<<<<<<<<<<<
 */
  __pyx_tuple__4 = PyTuple_Pack(1, __pyx_kp_s_self__weight_cannot_be_converted); if (unlikely(!__pyx_tuple__4)) __PYX_ERR(1, 4, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__4);
  __Pyx_GIVEREF(__pyx_tuple__4);

  /* "pywrapfst.pyx":638
 *       tostring(weight_type))))
 *   if result._weight.get().Type() == b"none":
 *     raise FstArgError("Weight type not found")             # <<<<<<<<<<<<<<
 *   return result
 * 
 */
  __pyx_tuple__5 = PyTuple_Pack(1, __pyx_kp_s_Weight_type_not_found); if (unlikely(!__pyx_tuple__5)) __PYX_ERR(0, 638, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__5);
  __Pyx_GIVEREF(__pyx_tuple__5);

  /* "pywrapfst.pyx":647
 *         fst.WeightClass.One(tostring(weight_type))))
 *   if result._weight.get().Type() == b"none":
 *     raise FstArgError("Weight type not found")             # <<<<<<<<<<<<<<
 *   return result
 * 
 */
  __pyx_tuple__6 = PyTuple_Pack(1, __pyx_kp_s_Weight_type_not_found); if (unlikely(!__pyx_tuple__6)) __PYX_ERR(0, 647, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__6);
  __Pyx_GIVEREF(__pyx_tuple__6);

  /* "(tree fragment)":2
 * def __reduce_cython__(self):
 *     raise TypeError("self._table cannot be converted to a Python object for pickling")             # <<<<<<<<<<<<<<
 * def __setstate_cython__(self, __pyx_state):
 *     raise TypeError("self._table cannot be converted to a Python object for pickling")
 */
  __pyx_tuple__7 = PyTuple_Pack(1, __pyx_kp_s_self__table_cannot_be_converted); if (unlikely(!__pyx_tuple__7)) __PYX_ERR(1, 2, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__7);
  __Pyx_GIVEREF(__pyx_tuple__7);

  /* "(tree fragment)":4
 *     raise TypeError("self._table cannot be converted to a Python object for pickling")
 * def __setstate_cython__(self, __pyx_state):
 *     raise TypeError("self._table cannot be converted to a Python object for pickling")             # <<<<<<<<<<<<<<
 */
  __pyx_tuple__8 = PyTuple_Pack(1, __pyx_kp_s_self__table_cannot_be_converted); if (unlikely(!__pyx_tuple__8)) __PYX_ERR(1, 4, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__8);
  __Pyx_GIVEREF(__pyx_tuple__8);

  /* "(tree fragment)":2
 * def __reduce_cython__(self):
 *     raise TypeError("self._encoder,self._table cannot be converted to a Python object for pickling")             # <<<<<<<<<<<<<<
 * def __setstate_cython__(self, __pyx_state):
 *     raise TypeError("self._encoder,self._table cannot be converted to a Python object for pickling")
 */
  __pyx_tuple__9 = PyTuple_Pack(1, __pyx_kp_s_self__encoder_self__table_cannot); if (unlikely(!__pyx_tuple__9)) __PYX_ERR(1, 2, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__9);
  __Pyx_GIVEREF(__pyx_tuple__9);

  /* "(tree fragment)":4
 *     raise TypeError("self._encoder,self._table cannot be converted to a Python object for pickling")
 * def __setstate_cython__(self, __pyx_state):
 *     raise TypeError("self._encoder,self._table cannot be converted to a Python object for pickling")             # <<<<<<<<<<<<<<
 */
  __pyx_tuple__10 = PyTuple_Pack(1, __pyx_kp_s_self__encoder_self__table_cannot); if (unlikely(!__pyx_tuple__10)) __PYX_ERR(1, 4, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__10);
  __Pyx_GIVEREF(__pyx_tuple__10);

  /* "(tree fragment)":2
 * def __reduce_cython__(self):
 *     raise TypeError("self._fst,self._table cannot be converted to a Python object for pickling")             # <<<<<<<<<<<<<<
 * def __setstate_cython__(self, __pyx_state):
 *     raise TypeError("self._fst,self._table cannot be converted to a Python object for pickling")
 */
  __pyx_tuple__11 = PyTuple_Pack(1, __pyx_kp_s_self__fst_self__table_cannot_be); if (unlikely(!__pyx_tuple__11)) __PYX_ERR(1, 2, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__11);
  __Pyx_GIVEREF(__pyx_tuple__11);

  /* "(tree fragment)":4
 *     raise TypeError("self._fst,self._table cannot be converted to a Python object for pickling")
 * def __setstate_cython__(self, __pyx_state):
 *     raise TypeError("self._fst,self._table cannot be converted to a Python object for pickling")             # <<<<<<<<<<<<<<
 */
  __pyx_tuple__12 = PyTuple_Pack(1, __pyx_kp_s_self__fst_self__table_cannot_be); if (unlikely(!__pyx_tuple__12)) __PYX_ERR(1, 4, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__12);
  __Pyx_GIVEREF(__pyx_tuple__12);

  /* "(tree fragment)":2
 * def __reduce_cython__(self):
 *     raise TypeError("self._table cannot be converted to a Python object for pickling")             # <<<<<<<<<<<<<<
 * def __setstate_cython__(self, __pyx_state):
 *     raise TypeError("self._table cannot be converted to a Python object for pickling")
 */
  __pyx_tuple__14 = PyTuple_Pack(1, __pyx_kp_s_self__table_cannot_be_converted); if (unlikely(!__pyx_tuple__14)) __PYX_ERR(1, 2, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__14);
  __Pyx_GIVEREF(__pyx_tuple__14);

  /* "(tree fragment)":4
 *     raise TypeError("self._table cannot be converted to a Python object for pickling")
 * def __setstate_cython__(self, __pyx_state):
 *     raise TypeError("self._table cannot be converted to a Python object for pickling")             # <<<<<<<<<<<<<<
 */
  __pyx_tuple__15 = PyTuple_Pack(1, __pyx_kp_s_self__table_cannot_be_converted); if (unlikely(!__pyx_tuple__15)) __PYX_ERR(1, 4, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__15);
  __Pyx_GIVEREF(__pyx_tuple__15);

  /* "(tree fragment)":2
 * def __reduce_cython__(self):
 *     raise TypeError("self._mfst,self._table cannot be converted to a Python object for pickling")             # <<<<<<<<<<<<<<
 * def __setstate_cython__(self, __pyx_state):
 *     raise TypeError("self._mfst,self._table cannot be converted to a Python object for pickling")
 */
  __pyx_tuple__16 = PyTuple_Pack(1, __pyx_kp_s_self__mfst_self__table_cannot_be); if (unlikely(!__pyx_tuple__16)) __PYX_ERR(1, 2, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__16);
  __Pyx_GIVEREF(__pyx_tuple__16);

  /* "(tree fragment)":4
 *     raise TypeError("self._mfst,self._table cannot be converted to a Python object for pickling")
 * def __setstate_cython__(self, __pyx_state):
 *     raise TypeError("self._mfst,self._table cannot be converted to a Python object for pickling")             # <<<<<<<<<<<<<<
 */
  __pyx_tuple__17 = PyTuple_Pack(1, __pyx_kp_s_self__mfst_self__table_cannot_be); if (unlikely(!__pyx_tuple__17)) __PYX_ERR(1, 4, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__17);
  __Pyx_GIVEREF(__pyx_tuple__17);

  /* "(tree fragment)":2
 * def __reduce_cython__(self):
 *     raise TypeError("self._smart_table,self._table cannot be converted to a Python object for pickling")             # <<<<<<<<<<<<<<
 * def __setstate_cython__(self, __pyx_state):
 *     raise TypeError("self._smart_table,self._table cannot be converted to a Python object for pickling")
 */
  __pyx_tuple__18 = PyTuple_Pack(1, __pyx_kp_s_self__smart_table_self__table_ca); if (unlikely(!__pyx_tuple__18)) __PYX_ERR(1, 2, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__18);
  __Pyx_GIVEREF(__pyx_tuple__18);

  /* "(tree fragment)":4
 *     raise TypeError("self._smart_table,self._table cannot be converted to a Python object for pickling")
 * def __setstate_cython__(self, __pyx_state):
 *     raise TypeError("self._smart_table,self._table cannot be converted to a Python object for pickling")             # <<<<<<<<<<<<<<
 */
  __pyx_tuple__19 = PyTuple_Pack(1, __pyx_kp_s_self__smart_table_self__table_ca); if (unlikely(!__pyx_tuple__19)) __PYX_ERR(1, 4, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__19);
  __Pyx_GIVEREF(__pyx_tuple__19);

  /* "(tree fragment)":2
 * def __reduce_cython__(self):
 *     raise TypeError("self._siter,self._table cannot be converted to a Python object for pickling")             # <<<<<<<<<<<<<<
 * def __setstate_cython__(self, __pyx_state):
 *     raise TypeError("self._siter,self._table cannot be converted to a Python object for pickling")
 */
  __pyx_tuple__20 = PyTuple_Pack(1, __pyx_kp_s_self__siter_self__table_cannot_b); if (unlikely(!__pyx_tuple__20)) __PYX_ERR(1, 2, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__20);
  __Pyx_GIVEREF(__pyx_tuple__20);

  /* "(tree fragment)":4
 *     raise TypeError("self._siter,self._table cannot be converted to a Python object for pickling")
 * def __setstate_cython__(self, __pyx_state):
 *     raise TypeError("self._siter,self._table cannot be converted to a Python object for pickling")             # <<<<<<<<<<<<<<
 */
  __pyx_tuple__21 = PyTuple_Pack(1, __pyx_kp_s_self__siter_self__table_cannot_b); if (unlikely(!__pyx_tuple__21)) __PYX_ERR(1, 4, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__21);
  __Pyx_GIVEREF(__pyx_tuple__21);

  /* "(tree fragment)":2
 * def __reduce_cython__(self):
 *     raise TypeError("self._encoder cannot be converted to a Python object for pickling")             # <<<<<<<<<<<<<<
 * def __setstate_cython__(self, __pyx_state):
 *     raise TypeError("self._encoder cannot be converted to a Python object for pickling")
 */
  __pyx_tuple__22 = PyTuple_Pack(1, __pyx_kp_s_self__encoder_cannot_be_converte); if (unlikely(!__pyx_tuple__22)) __PYX_ERR(1, 2, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__22);
  __Pyx_GIVEREF(__pyx_tuple__22);

  /* "(tree fragment)":4
 *     raise TypeError("self._encoder cannot be converted to a Python object for pickling")
 * def __setstate_cython__(self, __pyx_state):
 *     raise TypeError("self._encoder cannot be converted to a Python object for pickling")             # <<<<<<<<<<<<<<
 */
  __pyx_tuple__23 = PyTuple_Pack(1, __pyx_kp_s_self__encoder_cannot_be_converte); if (unlikely(!__pyx_tuple__23)) __PYX_ERR(1, 4, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__23);
  __Pyx_GIVEREF(__pyx_tuple__23);

  /* "pywrapfst.pyx":1400
 *     if proc.returncode != 0:  # Just to be explicit.
 *       raise subprocess.CalledProcessError(proc.returncode, self._DOT_TSVG)
 *     return sout.decode("utf8")             # <<<<<<<<<<<<<<
 * 
 *   def __repr__(self):
 */
  __pyx_tuple__25 = PyTuple_Pack(1, __pyx_n_s_utf8); if (unlikely(!__pyx_tuple__25)) __PYX_ERR(0, 1400, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__25);
  __Pyx_GIVEREF(__pyx_tuple__25);

  /* "pywrapfst.pyx":1576
 *     cdef size_t result = self._fst.get().NumArcs(state)
 *     if result == SIZE_MAX:
 *       raise FstIndexError("State index out of range")             # <<<<<<<<<<<<<<
 *     return result
 * 
 */
  __pyx_tuple__26 = PyTuple_Pack(1, __pyx_kp_s_State_index_out_of_range); if (unlikely(!__pyx_tuple__26)) __PYX_ERR(0, 1576, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__26);
  __Pyx_GIVEREF(__pyx_tuple__26);

  /* "pywrapfst.pyx":1598
 *     cdef size_t result = self._fst.get().NumInputEpsilons(state)
 *     if result == SIZE_MAX:
 *       raise FstIndexError("State index out of range")             # <<<<<<<<<<<<<<
 *     return result
 * 
 */
  __pyx_tuple__27 = PyTuple_Pack(1, __pyx_kp_s_State_index_out_of_range); if (unlikely(!__pyx_tuple__27)) __PYX_ERR(0, 1598, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__27);
  __Pyx_GIVEREF(__pyx_tuple__27);

  /* "pywrapfst.pyx":1620
 *     cdef size_t result = self._fst.get().NumOutputEpsilons(state)
 *     if result == SIZE_MAX:
 *       raise FstIndexError("State index out of range")             # <<<<<<<<<<<<<<
 *     return result
 * 
 */
  __pyx_tuple__28 = PyTuple_Pack(1, __pyx_kp_s_State_index_out_of_range); if (unlikely(!__pyx_tuple__28)) __PYX_ERR(0, 1620, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__28);
  __Pyx_GIVEREF(__pyx_tuple__28);

  /* "pywrapfst.pyx":1770
 *     cdef stringstream sstrm
 *     if not self._fst.get().Write(sstrm, "write_to_string"):
 *       raise FstIOError("Write to string failed")             # <<<<<<<<<<<<<<
 *     return sstrm.str()
 * 
 */
  __pyx_tuple__29 = PyTuple_Pack(1, __pyx_kp_s_Write_to_string_failed); if (unlikely(!__pyx_tuple__29)) __PYX_ERR(0, 1770, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__29);
  __Pyx_GIVEREF(__pyx_tuple__29);

  /* "pywrapfst.pyx":1790
 *     """
 *     if self._fst.get().Properties(fst.kError, True) == fst.kError:
 *       raise FstOpError("Operation failed")             # <<<<<<<<<<<<<<
 * 
 *   cdef void _add_arc(self, int64 state, Arc arc) except *:
 */
  __pyx_tuple__30 = PyTuple_Pack(1, __pyx_kp_s_Operation_failed); if (unlikely(!__pyx_tuple__30)) __PYX_ERR(0, 1790, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__30);
  __Pyx_GIVEREF(__pyx_tuple__30);

  /* "pywrapfst.pyx":1794
 *   cdef void _add_arc(self, int64 state, Arc arc) except *:
 *     if not self._fst.get().ValidStateId(state):
 *       raise FstIndexError("State index out of range")             # <<<<<<<<<<<<<<
 *     if not self._mfst.get().AddArc(state, deref(arc._arc)):
 *       raise FstOpError("Incompatible or invalid weight type")
 */
  __pyx_tuple__31 = PyTuple_Pack(1, __pyx_kp_s_State_index_out_of_range); if (unlikely(!__pyx_tuple__31)) __PYX_ERR(0, 1794, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__31);
  __Pyx_GIVEREF(__pyx_tuple__31);

  /* "pywrapfst.pyx":1796
 *       raise FstIndexError("State index out of range")
 *     if not self._mfst.get().AddArc(state, deref(arc._arc)):
 *       raise FstOpError("Incompatible or invalid weight type")             # <<<<<<<<<<<<<<
 *     self._check_mutating_imethod()
 * 
 */
  __pyx_tuple__32 = PyTuple_Pack(1, __pyx_kp_s_Incompatible_or_invalid_weight_t); if (unlikely(!__pyx_tuple__32)) __PYX_ERR(0, 1796, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__32);
  __Pyx_GIVEREF(__pyx_tuple__32);

  /* "pywrapfst.pyx":1961
 *     if not (self._mfst.get().DeleteArcs(state, n) if n else
 *             self._mfst.get().DeleteArcs(state)):
 *       raise FstIndexError("State index out of range")             # <<<<<<<<<<<<<<
 *     self._check_mutating_imethod()
 * 
 */
  __pyx_tuple__33 = PyTuple_Pack(1, __pyx_kp_s_State_index_out_of_range); if (unlikely(!__pyx_tuple__33)) __PYX_ERR(0, 1961, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__33);
  __Pyx_GIVEREF(__pyx_tuple__33);

  /* "pywrapfst.pyx":1991
 *     if states:
 *       if not self._mfst.get().DeleteStates(<const vector[int64]> states):
 *         raise FstIndexError("State index out of range")             # <<<<<<<<<<<<<<
 *     else:
 *       self._mfst.get().DeleteStates()
 */
  __pyx_tuple__34 = PyTuple_Pack(1, __pyx_kp_s_State_index_out_of_range); if (unlikely(!__pyx_tuple__34)) __PYX_ERR(0, 1991, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__34);
  __Pyx_GIVEREF(__pyx_tuple__34);

  /* "pywrapfst.pyx":2260
 *         _opairs.get().push_back(fst.LabelPair(before, after))
 *     if _ipairs.get().empty() and _opairs.get().empty():
 *       raise FstArgError("No relabeling pairs specified.")             # <<<<<<<<<<<<<<
 *     fst.Relabel(self._mfst.get(), deref(_ipairs), deref(_opairs))
 *     self._check_mutating_imethod()
 */
  __pyx_tuple__43 = PyTuple_Pack(1, __pyx_kp_s_No_relabeling_pairs_specified); if (unlikely(!__pyx_tuple__43)) __PYX_ERR(0, 2260, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__43);
  __Pyx_GIVEREF(__pyx_tuple__43);

  /* "pywrapfst.pyx":2299
 *                             bool attach_new_osymbols=True) except *:
 *     if new_isymbols is None and new_osymbols is None:
 *       raise FstArgError("No new SymbolTables specified")             # <<<<<<<<<<<<<<
 *     cdef fst.SymbolTable *new_isymbols_ptr = NULL
 *     if new_isymbols is not None:
 */
  __pyx_tuple__44 = PyTuple_Pack(1, __pyx_kp_s_No_new_SymbolTables_specified); if (unlikely(!__pyx_tuple__44)) __PYX_ERR(0, 2299, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__44);
  __Pyx_GIVEREF(__pyx_tuple__44);

  /* "pywrapfst.pyx":2367
 *   cdef void _reserve_arcs(self, int64 state, size_t n) except *:
 *     if not self._mfst.get().ReserveArcs(state, n):
 *       raise FstIndexError("State index out of range")             # <<<<<<<<<<<<<<
 *     self._check_mutating_imethod()
 * 
 */
  __pyx_tuple__45 = PyTuple_Pack(1, __pyx_kp_s_State_index_out_of_range); if (unlikely(!__pyx_tuple__45)) __PYX_ERR(0, 2367, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__45);
  __Pyx_GIVEREF(__pyx_tuple__45);

  /* "pywrapfst.pyx":2494
 *   cdef void _set_final(self, int64 state, weight=None) except *:
 *     if not self._mfst.get().ValidStateId(state):
 *       raise FstIndexError("State index out of range")             # <<<<<<<<<<<<<<
 *     cdef fst.WeightClass wc = _get_WeightClass_or_One(self.weight_type(),
 *                                                       weight)
 */
  __pyx_tuple__50 = PyTuple_Pack(1, __pyx_kp_s_State_index_out_of_range); if (unlikely(!__pyx_tuple__50)) __PYX_ERR(0, 2494, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__50);
  __Pyx_GIVEREF(__pyx_tuple__50);

  /* "pywrapfst.pyx":2498
 *                                                       weight)
 *     if not self._mfst.get().SetFinal(state, wc):
 *       raise FstOpError("Incompatible or invalid weight")             # <<<<<<<<<<<<<<
 *     self._check_mutating_imethod()
 * 
 */
  __pyx_tuple__51 = PyTuple_Pack(1, __pyx_kp_s_Incompatible_or_invalid_weight); if (unlikely(!__pyx_tuple__51)) __PYX_ERR(0, 2498, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__51);
  __Pyx_GIVEREF(__pyx_tuple__51);

  /* "pywrapfst.pyx":2598
 *   cdef void _set_start(self, int64 state) except *:
 *     if not self._mfst.get().SetStart(state):
 *       raise FstIndexError("State index out of range")             # <<<<<<<<<<<<<<
 *     self._check_mutating_imethod()
 * 
 */
  __pyx_tuple__52 = PyTuple_Pack(1, __pyx_kp_s_State_index_out_of_range); if (unlikely(!__pyx_tuple__52)) __PYX_ERR(0, 2598, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__52);
  __Pyx_GIVEREF(__pyx_tuple__52);

  /* "pywrapfst.pyx":2624
 *     # TopSort returns False if the FST is cyclic, and thus can't be TopSorted.
 *     if not fst.TopSort(self._mfst.get()):
 *       logging.warning("Cannot topsort cyclic FST.")             # <<<<<<<<<<<<<<
 *     self._check_mutating_imethod()
 * 
 */
  __pyx_tuple__53 = PyTuple_Pack(1, __pyx_kp_s_Cannot_topsort_cyclic_FST); if (unlikely(!__pyx_tuple__53)) __PYX_ERR(0, 2624, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__53);
  __Pyx_GIVEREF(__pyx_tuple__53);

  /* "pywrapfst.pyx":2693
 * cdef _Fst _init_Fst(FstClass_ptr tfst):
 *   if tfst.Properties(fst.kError, True):
 *     raise FstOpError("Operation failed")             # <<<<<<<<<<<<<<
 *   cdef _Fst ofst = _Fst.__new__(_Fst)
 *   ofst._fst.reset(tfst)
 */
  __pyx_tuple__54 = PyTuple_Pack(1, __pyx_kp_s_Operation_failed); if (unlikely(!__pyx_tuple__54)) __PYX_ERR(0, 2693, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__54);
  __Pyx_GIVEREF(__pyx_tuple__54);

  /* "pywrapfst.pyx":2701
 * cdef _MutableFst _init_MutableFst(MutableFstClass_ptr tfst):
 *   if tfst.Properties(fst.kError, True):
 *     raise FstOpError("Operation failed")             # <<<<<<<<<<<<<<
 *   cdef _MutableFst ofst = _MutableFst.__new__(_MutableFst)
 *   ofst._fst.reset(tfst)
 */
  __pyx_tuple__55 = PyTuple_Pack(1, __pyx_kp_s_Operation_failed); if (unlikely(!__pyx_tuple__55)) __PYX_ERR(0, 2701, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__55);
  __Pyx_GIVEREF(__pyx_tuple__55);

  /* "pywrapfst.pyx":2738
 *   tfst.reset(fst.FstClass.ReadFromStream(sstrm, b"<pywrapfst>"))
 *   if tfst.get() == NULL:
 *     raise FstIOError("Read failed: <string>")             # <<<<<<<<<<<<<<
 *   return _init_XFst(tfst.release())
 * 
 */
  __pyx_tuple__56 = PyTuple_Pack(1, __pyx_kp_s_Read_failed_string); if (unlikely(!__pyx_tuple__56)) __PYX_ERR(0, 2738, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__56);
  __Pyx_GIVEREF(__pyx_tuple__56);

  /* "(tree fragment)":2
 * def __reduce_cython__(self):
 *     raise TypeError("self._arc cannot be converted to a Python object for pickling")             # <<<<<<<<<<<<<<
 * def __setstate_cython__(self, __pyx_state):
 *     raise TypeError("self._arc cannot be converted to a Python object for pickling")
 */
  __pyx_tuple__57 = PyTuple_Pack(1, __pyx_kp_s_self__arc_cannot_be_converted_to); if (unlikely(!__pyx_tuple__57)) __PYX_ERR(1, 2, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__57);
  __Pyx_GIVEREF(__pyx_tuple__57);

  /* "(tree fragment)":4
 *     raise TypeError("self._arc cannot be converted to a Python object for pickling")
 * def __setstate_cython__(self, __pyx_state):
 *     raise TypeError("self._arc cannot be converted to a Python object for pickling")             # <<<<<<<<<<<<<<
 */
  __pyx_tuple__58 = PyTuple_Pack(1, __pyx_kp_s_self__arc_cannot_be_converted_to); if (unlikely(!__pyx_tuple__58)) __PYX_ERR(1, 4, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__58);
  __Pyx_GIVEREF(__pyx_tuple__58);

  /* "pywrapfst.pyx":2978
 *   def __init__(self, _Fst ifst, int64 state):
 *     if not ifst._fst.get().ValidStateId(state):
 *       raise FstIndexError("State index out of range")             # <<<<<<<<<<<<<<
 *     # Makes copy of the shared_ptr, potentially extending the FST's lifetime.
 *     self._fst = ifst._fst
 */
  __pyx_tuple__59 = PyTuple_Pack(1, __pyx_kp_s_State_index_out_of_range); if (unlikely(!__pyx_tuple__59)) __PYX_ERR(0, 2978, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__59);
  __Pyx_GIVEREF(__pyx_tuple__59);

  /* "(tree fragment)":2
 * def __reduce_cython__(self):
 *     raise TypeError("self._aiter,self._fst cannot be converted to a Python object for pickling")             # <<<<<<<<<<<<<<
 * def __setstate_cython__(self, __pyx_state):
 *     raise TypeError("self._aiter,self._fst cannot be converted to a Python object for pickling")
 */
  __pyx_tuple__60 = PyTuple_Pack(1, __pyx_kp_s_self__aiter_self__fst_cannot_be); if (unlikely(!__pyx_tuple__60)) __PYX_ERR(1, 2, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__60);
  __Pyx_GIVEREF(__pyx_tuple__60);

  /* "(tree fragment)":4
 *     raise TypeError("self._aiter,self._fst cannot be converted to a Python object for pickling")
 * def __setstate_cython__(self, __pyx_state):
 *     raise TypeError("self._aiter,self._fst cannot be converted to a Python object for pickling")             # <<<<<<<<<<<<<<
 */
  __pyx_tuple__61 = PyTuple_Pack(1, __pyx_kp_s_self__aiter_self__fst_cannot_be); if (unlikely(!__pyx_tuple__61)) __PYX_ERR(1, 4, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__61);
  __Pyx_GIVEREF(__pyx_tuple__61);

  /* "pywrapfst.pyx":3090
 *   def __init__(self, _MutableFst ifst, int64 state):
 *     if not ifst._fst.get().ValidStateId(state):
 *       raise FstIndexError("State index out of range")             # <<<<<<<<<<<<<<
 *     # Makes copy of the shared_ptr, potentially extending the FST's lifetime.
 *     self._mfst = ifst._mfst
 */
  __pyx_tuple__62 = PyTuple_Pack(1, __pyx_kp_s_State_index_out_of_range); if (unlikely(!__pyx_tuple__62)) __PYX_ERR(0, 3090, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__62);
  __Pyx_GIVEREF(__pyx_tuple__62);

  /* "(tree fragment)":2
 * def __reduce_cython__(self):
 *     raise TypeError("self._aiter,self._mfst cannot be converted to a Python object for pickling")             # <<<<<<<<<<<<<<
 * def __setstate_cython__(self, __pyx_state):
 *     raise TypeError("self._aiter,self._mfst cannot be converted to a Python object for pickling")
 */
  __pyx_tuple__63 = PyTuple_Pack(1, __pyx_kp_s_self__aiter_self__mfst_cannot_be); if (unlikely(!__pyx_tuple__63)) __PYX_ERR(1, 2, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__63);
  __Pyx_GIVEREF(__pyx_tuple__63);

  /* "(tree fragment)":4
 *     raise TypeError("self._aiter,self._mfst cannot be converted to a Python object for pickling")
 * def __setstate_cython__(self, __pyx_state):
 *     raise TypeError("self._aiter,self._mfst cannot be converted to a Python object for pickling")             # <<<<<<<<<<<<<<
 */
  __pyx_tuple__64 = PyTuple_Pack(1, __pyx_kp_s_self__aiter_self__mfst_cannot_be); if (unlikely(!__pyx_tuple__64)) __PYX_ERR(1, 4, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__64);
  __Pyx_GIVEREF(__pyx_tuple__64);

  /* "(tree fragment)":2
 * def __reduce_cython__(self):
 *     raise TypeError("self._fst,self._siter cannot be converted to a Python object for pickling")             # <<<<<<<<<<<<<<
 * def __setstate_cython__(self, __pyx_state):
 *     raise TypeError("self._fst,self._siter cannot be converted to a Python object for pickling")
 */
  __pyx_tuple__65 = PyTuple_Pack(1, __pyx_kp_s_self__fst_self__siter_cannot_be); if (unlikely(!__pyx_tuple__65)) __PYX_ERR(1, 2, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__65);
  __Pyx_GIVEREF(__pyx_tuple__65);

  /* "(tree fragment)":4
 *     raise TypeError("self._fst,self._siter cannot be converted to a Python object for pickling")
 * def __setstate_cython__(self, __pyx_state):
 *     raise TypeError("self._fst,self._siter cannot be converted to a Python object for pickling")             # <<<<<<<<<<<<<<
 */
  __pyx_tuple__66 = PyTuple_Pack(1, __pyx_kp_s_self__fst_self__siter_cannot_be); if (unlikely(!__pyx_tuple__66)) __PYX_ERR(1, 4, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__66);
  __Pyx_GIVEREF(__pyx_tuple__66);

  /* "pywrapfst.pyx":4190
 *     self._sstrm.reset(new stringstream())
 *     if tfst.get() == NULL:
 *       raise FstOpError("Compilation failed")             # <<<<<<<<<<<<<<
 *     return _init_XFst(tfst.release())
 * 
 */
  __pyx_tuple__90 = PyTuple_Pack(1, __pyx_kp_s_Compilation_failed); if (unlikely(!__pyx_tuple__90)) __PYX_ERR(0, 4190, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__90);
  __Pyx_GIVEREF(__pyx_tuple__90);

  /* "(tree fragment)":2
 * def __reduce_cython__(self):
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
 * def __setstate_cython__(self, __pyx_state):
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
 */
  __pyx_tuple__91 = PyTuple_Pack(1, __pyx_kp_s_no_default___reduce___due_to_non); if (unlikely(!__pyx_tuple__91)) __PYX_ERR(1, 2, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__91);
  __Pyx_GIVEREF(__pyx_tuple__91);

  /* "(tree fragment)":4
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
 * def __setstate_cython__(self, __pyx_state):
 *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")             # <<<<<<<<<<<<<<
 */
  __pyx_tuple__92 = PyTuple_Pack(1, __pyx_kp_s_no_default___reduce___due_to_non); if (unlikely(!__pyx_tuple__92)) __PYX_ERR(1, 4, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__92);
  __Pyx_GIVEREF(__pyx_tuple__92);

  /* "(tree fragment)":2
 * def __reduce_cython__(self):
 *     raise TypeError("self._reader cannot be converted to a Python object for pickling")             # <<<<<<<<<<<<<<
 * def __setstate_cython__(self, __pyx_state):
 *     raise TypeError("self._reader cannot be converted to a Python object for pickling")
 */
  __pyx_tuple__93 = PyTuple_Pack(1, __pyx_kp_s_self__reader_cannot_be_converted); if (unlikely(!__pyx_tuple__93)) __PYX_ERR(1, 2, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__93);
  __Pyx_GIVEREF(__pyx_tuple__93);

  /* "(tree fragment)":4
 *     raise TypeError("self._reader cannot be converted to a Python object for pickling")
 * def __setstate_cython__(self, __pyx_state):
 *     raise TypeError("self._reader cannot be converted to a Python object for pickling")             # <<<<<<<<<<<<<<
 */
  __pyx_tuple__94 = PyTuple_Pack(1, __pyx_kp_s_self__reader_cannot_be_converted); if (unlikely(!__pyx_tuple__94)) __PYX_ERR(1, 4, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__94);
  __Pyx_GIVEREF(__pyx_tuple__94);

  /* "pywrapfst.pyx":4443
 *     # used by the FAR was initialized to use.
 *     if not self._writer.get().Add(tostring(key), deref(ifst._fst)):
 *       raise FstOpError("Incompatible or invalid arc type")             # <<<<<<<<<<<<<<
 *     # An error here usually indicates a key out of order.
 *     if self._writer.get().Error():
 */
  __pyx_tuple__95 = PyTuple_Pack(1, __pyx_kp_s_Incompatible_or_invalid_arc_type); if (unlikely(!__pyx_tuple__95)) __PYX_ERR(0, 4443, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__95);
  __Pyx_GIVEREF(__pyx_tuple__95);

  /* "pywrapfst.pyx":4446
 *     # An error here usually indicates a key out of order.
 *     if self._writer.get().Error():
 *       raise FstArgError("Key out of order")             # <<<<<<<<<<<<<<
 * 
 *   cpdef string arc_type(self):
 */
  __pyx_tuple__96 = PyTuple_Pack(1, __pyx_kp_s_Key_out_of_order); if (unlikely(!__pyx_tuple__96)) __PYX_ERR(0, 4446, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__96);
  __Pyx_GIVEREF(__pyx_tuple__96);

  /* "(tree fragment)":2
 * def __reduce_cython__(self):
 *     raise TypeError("self._writer cannot be converted to a Python object for pickling")             # <<<<<<<<<<<<<<
 * def __setstate_cython__(self, __pyx_state):
 *     raise TypeError("self._writer cannot be converted to a Python object for pickling")
 */
  __pyx_tuple__97 = PyTuple_Pack(1, __pyx_kp_s_self__writer_cannot_be_converted); if (unlikely(!__pyx_tuple__97)) __PYX_ERR(1, 2, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__97);
  __Pyx_GIVEREF(__pyx_tuple__97);

  /* "(tree fragment)":4
 *     raise TypeError("self._writer cannot be converted to a Python object for pickling")
 * def __setstate_cython__(self, __pyx_state):
 *     raise TypeError("self._writer cannot be converted to a Python object for pickling")             # <<<<<<<<<<<<<<
 */
  __pyx_tuple__98 = PyTuple_Pack(1, __pyx_kp_s_self__writer_cannot_be_converted); if (unlikely(!__pyx_tuple__98)) __PYX_ERR(1, 4, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__98);
  __Pyx_GIVEREF(__pyx_tuple__98);

  /* "pywrapfst.pyx":456
 * 
 * 
 * def plus(Weight lhs, Weight rhs):             # <<<<<<<<<<<<<<
 *   """
 *   plus(lhs, rhs)
 */
  __pyx_tuple__99 = PyTuple_Pack(3, __pyx_n_s_lhs, __pyx_n_s_rhs, __pyx_n_s_result); if (unlikely(!__pyx_tuple__99)) __PYX_ERR(0, 456, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__99);
  __Pyx_GIVEREF(__pyx_tuple__99);
  __pyx_codeobj__100 = (PyObject*)__Pyx_PyCode_New(2, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__99, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_pywrapfst_pyx, __pyx_n_s_plus, 456, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__100)) __PYX_ERR(0, 456, __pyx_L1_error)

  /* "pywrapfst.pyx":488
 * 
 * 
 * def times(Weight lhs, Weight rhs):             # <<<<<<<<<<<<<<
 *   """
 *   times(lhs, rhs)
 */
  __pyx_tuple__101 = PyTuple_Pack(3, __pyx_n_s_lhs, __pyx_n_s_rhs, __pyx_n_s_result); if (unlikely(!__pyx_tuple__101)) __PYX_ERR(0, 488, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__101);
  __Pyx_GIVEREF(__pyx_tuple__101);
  __pyx_codeobj__102 = (PyObject*)__Pyx_PyCode_New(2, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__101, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_pywrapfst_pyx, __pyx_n_s_times, 488, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__102)) __PYX_ERR(0, 488, __pyx_L1_error)

  /* "pywrapfst.pyx":520
 * 
 * 
 * def divide(Weight lhs, Weight rhs):             # <<<<<<<<<<<<<<
 *   """
 *   divide(lhs, rhs)
 */
  __pyx_tuple__103 = PyTuple_Pack(3, __pyx_n_s_lhs, __pyx_n_s_rhs, __pyx_n_s_result); if (unlikely(!__pyx_tuple__103)) __PYX_ERR(0, 520, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__103);
  __Pyx_GIVEREF(__pyx_tuple__103);
  __pyx_codeobj__104 = (PyObject*)__Pyx_PyCode_New(2, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__103, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_pywrapfst_pyx, __pyx_n_s_divide, 520, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__104)) __PYX_ERR(0, 520, __pyx_L1_error)

  /* "pywrapfst.pyx":553
 * 
 * 
 * def power(Weight w, size_t n):             # <<<<<<<<<<<<<<
 *   """
 *   power(lhs, rhs)
 */
  __pyx_tuple__105 = PyTuple_Pack(3, __pyx_n_s_w, __pyx_n_s_n, __pyx_n_s_result); if (unlikely(!__pyx_tuple__105)) __PYX_ERR(0, 553, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__105);
  __Pyx_GIVEREF(__pyx_tuple__105);
  __pyx_codeobj__106 = (PyObject*)__Pyx_PyCode_New(2, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__105, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_pywrapfst_pyx, __pyx_n_s_power, 553, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__106)) __PYX_ERR(0, 553, __pyx_L1_error)

  /* "pywrapfst.pyx":2742
 * 
 * 
 * class Fst(object):             # <<<<<<<<<<<<<<
 * 
 *    """
 */
  __pyx_tuple__107 = PyTuple_Pack(1, __pyx_builtin_object); if (unlikely(!__pyx_tuple__107)) __PYX_ERR(0, 2742, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__107);
  __Pyx_GIVEREF(__pyx_tuple__107);

  /* "pywrapfst.pyx":2759
 *    """
 * 
 *    def __new__(cls, arc_type=b"standard"):             # <<<<<<<<<<<<<<
 *     return _create_Fst(arc_type)
 * 
 */
  __pyx_tuple__108 = PyTuple_Pack(2, __pyx_n_s_cls, __pyx_n_s_arc_type); if (unlikely(!__pyx_tuple__108)) __PYX_ERR(0, 2759, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__108);
  __Pyx_GIVEREF(__pyx_tuple__108);
  __pyx_codeobj__109 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__108, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_pywrapfst_pyx, __pyx_n_s_new, 2759, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__109)) __PYX_ERR(0, 2759, __pyx_L1_error)
  __pyx_tuple__110 = PyTuple_Pack(1, ((PyObject*)__pyx_n_b_standard)); if (unlikely(!__pyx_tuple__110)) __PYX_ERR(0, 2759, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__110);
  __Pyx_GIVEREF(__pyx_tuple__110);

  /* "pywrapfst.pyx":2763
 * 
 *    @staticmethod
 *    def read(filename):             # <<<<<<<<<<<<<<
 *      """
 *      read(filename):
 */
  __pyx_tuple__111 = PyTuple_Pack(1, __pyx_n_s_filename); if (unlikely(!__pyx_tuple__111)) __PYX_ERR(0, 2763, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__111);
  __Pyx_GIVEREF(__pyx_tuple__111);
  __pyx_codeobj__112 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__111, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_pywrapfst_pyx, __pyx_n_s_read, 2763, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__112)) __PYX_ERR(0, 2763, __pyx_L1_error)

  /* "pywrapfst.pyx":2781
 * 
 *    @staticmethod
 *    def read_from_string(state):             # <<<<<<<<<<<<<<
 *      """
 *      read_from_string(string, fst_type=None)
 */
  __pyx_tuple__113 = PyTuple_Pack(1, __pyx_n_s_state); if (unlikely(!__pyx_tuple__113)) __PYX_ERR(0, 2781, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__113);
  __Pyx_GIVEREF(__pyx_tuple__113);
  __pyx_codeobj__114 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__113, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_pywrapfst_pyx, __pyx_n_s_read_from_string_2, 2781, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__114)) __PYX_ERR(0, 2781, __pyx_L1_error)

  /* "pywrapfst.pyx":3949
 * 
 * 
 * def shortestdistance(_Fst ifst,             # <<<<<<<<<<<<<<
 *                      float delta=fst.kShortestDelta,
 *                      int64 nstate=fst.kNoStateId,
 */
  __pyx_tuple__115 = PyTuple_Pack(8, __pyx_n_s_ifst, __pyx_n_s_delta, __pyx_n_s_nstate, __pyx_n_s_queue_type, __pyx_n_s_reverse, __pyx_n_s_distance, __pyx_n_s_weight_type, __pyx_n_s_weight); if (unlikely(!__pyx_tuple__115)) __PYX_ERR(0, 3949, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__115);
  __Pyx_GIVEREF(__pyx_tuple__115);
  __pyx_codeobj__116 = (PyObject*)__Pyx_PyCode_New(5, 0, 8, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__115, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_pywrapfst_pyx, __pyx_n_s_shortestdistance, 3949, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__116)) __PYX_ERR(0, 3949, __pyx_L1_error)

  /* "pywrapfst.pyx":4492
 * 
 * @atexit.register
 * def _reset_fst_error_fatal():             # <<<<<<<<<<<<<<
 *   fst.FLAGS_fst_error_fatal = _fst_error_fatal_old
 * 
 */
  __pyx_codeobj__117 = (PyObject*)__Pyx_PyCode_New(0, 0, 0, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_pywrapfst_pyx, __pyx_n_s_reset_fst_error_fatal, 4492, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__117)) __PYX_ERR(0, 4492, __pyx_L1_error)
  __Pyx_RefNannyFinishContext();
  return 0;
  __pyx_L1_error:;
  __Pyx_RefNannyFinishContext();
  return -1;
}

static int __Pyx_InitGlobals(void) {
  if (__Pyx_InitStrings(__pyx_string_tab) < 0) __PYX_ERR(0, 1, __pyx_L1_error);
  __pyx_int_0 = PyInt_FromLong(0); if (unlikely(!__pyx_int_0)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_neg_1 = PyInt_FromLong(-1); if (unlikely(!__pyx_int_neg_1)) __PYX_ERR(0, 1, __pyx_L1_error)
  return 0;
  __pyx_L1_error:;
  return -1;
}

#if PY_MAJOR_VERSION < 3
PyMODINIT_FUNC initpywrapfst(void); /*proto*/
PyMODINIT_FUNC initpywrapfst(void)
#else
PyMODINIT_FUNC PyInit_pywrapfst(void); /*proto*/
PyMODINIT_FUNC PyInit_pywrapfst(void)
#if CYTHON_PEP489_MULTI_PHASE_INIT
{
  return PyModuleDef_Init(&__pyx_moduledef);
}
static int __Pyx_copy_spec_to_module(PyObject *spec, PyObject *moddict, const char* from_name, const char* to_name) {
    PyObject *value = PyObject_GetAttrString(spec, from_name);
    int result = 0;
    if (likely(value)) {
        result = PyDict_SetItemString(moddict, to_name, value);
        Py_DECREF(value);
    } else if (PyErr_ExceptionMatches(PyExc_AttributeError)) {
        PyErr_Clear();
    } else {
        result = -1;
    }
    return result;
}
static PyObject* __pyx_pymod_create(PyObject *spec, CYTHON_UNUSED PyModuleDef *def) {
    PyObject *module = NULL, *moddict, *modname;
    if (__pyx_m)
        return __Pyx_NewRef(__pyx_m);
    modname = PyObject_GetAttrString(spec, "name");
    if (unlikely(!modname)) goto bad;
    module = PyModule_NewObject(modname);
    Py_DECREF(modname);
    if (unlikely(!module)) goto bad;
    moddict = PyModule_GetDict(module);
    if (unlikely(!moddict)) goto bad;
    if (unlikely(__Pyx_copy_spec_to_module(spec, moddict, "loader", "__loader__") < 0)) goto bad;
    if (unlikely(__Pyx_copy_spec_to_module(spec, moddict, "origin", "__file__") < 0)) goto bad;
    if (unlikely(__Pyx_copy_spec_to_module(spec, moddict, "parent", "__package__") < 0)) goto bad;
    if (unlikely(__Pyx_copy_spec_to_module(spec, moddict, "submodule_search_locations", "__path__") < 0)) goto bad;
    return module;
bad:
    Py_XDECREF(module);
    return NULL;
}


static int __pyx_pymod_exec_pywrapfst(PyObject *__pyx_pyinit_module)
#endif
#endif
{
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  __pyx_t_10basictypes_int64 __pyx_t_5;
  std::string __pyx_t_6;
  PyObject *__pyx_t_7 = NULL;
  __Pyx_RefNannyDeclarations
  #if CYTHON_PEP489_MULTI_PHASE_INIT
  if (__pyx_m && __pyx_m == __pyx_pyinit_module) return 0;
  #endif
  #if CYTHON_REFNANNY
  __Pyx_RefNanny = __Pyx_RefNannyImportAPI("refnanny");
  if (!__Pyx_RefNanny) {
      PyErr_Clear();
      __Pyx_RefNanny = __Pyx_RefNannyImportAPI("Cython.Runtime.refnanny");
      if (!__Pyx_RefNanny)
          Py_FatalError("failed to import 'refnanny' module");
  }
  #endif
  __Pyx_RefNannySetupContext("PyMODINIT_FUNC PyInit_pywrapfst(void)", 0);
  if (__Pyx_check_binary_version() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_empty_tuple = PyTuple_New(0); if (unlikely(!__pyx_empty_tuple)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_empty_bytes = PyBytes_FromStringAndSize("", 0); if (unlikely(!__pyx_empty_bytes)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_empty_unicode = PyUnicode_FromStringAndSize("", 0); if (unlikely(!__pyx_empty_unicode)) __PYX_ERR(0, 1, __pyx_L1_error)
  #ifdef __Pyx_CyFunction_USED
  if (__pyx_CyFunction_init() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  #endif
  #ifdef __Pyx_FusedFunction_USED
  if (__pyx_FusedFunction_init() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  #endif
  #ifdef __Pyx_Coroutine_USED
  if (__pyx_Coroutine_init() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  #endif
  #ifdef __Pyx_Generator_USED
  if (__pyx_Generator_init() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  #endif
  #ifdef __Pyx_AsyncGen_USED
  if (__pyx_AsyncGen_init() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  #endif
  #ifdef __Pyx_StopAsyncIteration_USED
  if (__pyx_StopAsyncIteration_init() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  #endif
  /*--- Library function declarations ---*/
  /*--- Threads initialization code ---*/
  #if defined(__PYX_FORCE_INIT_THREADS) && __PYX_FORCE_INIT_THREADS
  #ifdef WITH_THREAD /* Python build with threading support? */
  PyEval_InitThreads();
  #endif
  #endif
  /*--- Module creation code ---*/
  #if CYTHON_PEP489_MULTI_PHASE_INIT
  __pyx_m = __pyx_pyinit_module;
  Py_INCREF(__pyx_m);
  #else
  #if PY_MAJOR_VERSION < 3
  __pyx_m = Py_InitModule4("pywrapfst", __pyx_methods, __pyx_k_Python_interface_to_the_FST_scri, 0, PYTHON_API_VERSION); Py_XINCREF(__pyx_m);
  #else
  __pyx_m = PyModule_Create(&__pyx_moduledef);
  #endif
  if (unlikely(!__pyx_m)) __PYX_ERR(0, 1, __pyx_L1_error)
  #endif
  __pyx_d = PyModule_GetDict(__pyx_m); if (unlikely(!__pyx_d)) __PYX_ERR(0, 1, __pyx_L1_error)
  Py_INCREF(__pyx_d);
  __pyx_b = PyImport_AddModule(__Pyx_BUILTIN_MODULE_NAME); if (unlikely(!__pyx_b)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_cython_runtime = PyImport_AddModule((char *) "cython_runtime"); if (unlikely(!__pyx_cython_runtime)) __PYX_ERR(0, 1, __pyx_L1_error)
  #if CYTHON_COMPILING_IN_PYPY
  Py_INCREF(__pyx_b);
  #endif
  if (PyObject_SetAttrString(__pyx_m, "__builtins__", __pyx_b) < 0) __PYX_ERR(0, 1, __pyx_L1_error);
  /*--- Initialize various global constants etc. ---*/
  if (__Pyx_InitGlobals() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  #if PY_MAJOR_VERSION < 3 && (__PYX_DEFAULT_STRING_ENCODING_IS_ASCII || __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT)
  if (__Pyx_init_sys_getdefaultencoding_params() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  #endif
  if (__pyx_module_is_main_pywrapfst) {
    if (PyObject_SetAttrString(__pyx_m, "__name__", __pyx_n_s_main) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  }
  #if PY_MAJOR_VERSION >= 3
  {
    PyObject *modules = PyImport_GetModuleDict(); if (unlikely(!modules)) __PYX_ERR(0, 1, __pyx_L1_error)
    if (!PyDict_GetItemString(modules, "pywrapfst")) {
      if (unlikely(PyDict_SetItemString(modules, "pywrapfst", __pyx_m) < 0)) __PYX_ERR(0, 1, __pyx_L1_error)
    }
  }
  #endif
  /*--- Builtin init code ---*/
  if (__Pyx_InitCachedBuiltins() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  /*--- Constants init code ---*/
  if (__Pyx_InitCachedConstants() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  /*--- Global init code ---*/
  /*--- Variable export code ---*/
  /*--- Function export code ---*/
  if (__Pyx_ExportFunction("tostring", (void (*)(void))__pyx_f_9pywrapfst_tostring, "std::string (PyObject *, struct __pyx_opt_args_9pywrapfst_tostring *__pyx_optional_args)") < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  if (__Pyx_ExportFunction("weight_tostring", (void (*)(void))__pyx_f_9pywrapfst_weight_tostring, "std::string (PyObject *, struct __pyx_opt_args_9pywrapfst_weight_tostring *__pyx_optional_args)") < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  if (__Pyx_ExportFunction("_get_compose_filter", (void (*)(void))__pyx_f_9pywrapfst__get_compose_filter, "enum fst::ComposeFilter (std::string const &)") < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  if (__Pyx_ExportFunction("_get_determinize_type", (void (*)(void))__pyx_f_9pywrapfst__get_determinize_type, "enum fst::DeterminizeType (std::string const &)") < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  if (__Pyx_ExportFunction("_get_queue_type", (void (*)(void))__pyx_f_9pywrapfst__get_queue_type, "enum fst::QueueType (std::string const &)") < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  if (__Pyx_ExportFunction("_get_rand_arc_selection", (void (*)(void))__pyx_f_9pywrapfst__get_rand_arc_selection, "enum fst::script::RandArcSelection (std::string const &)") < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  if (__Pyx_ExportFunction("_get_replace_label_type", (void (*)(void))__pyx_f_9pywrapfst__get_replace_label_type, "enum fst::ReplaceLabelType (std::string const &, bool)") < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  if (__Pyx_ExportFunction("_get_WeightClass_or_One", (void (*)(void))__pyx_f_9pywrapfst__get_WeightClass_or_One, "fst::script::WeightClass (std::string const &, PyObject *)") < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  if (__Pyx_ExportFunction("_get_WeightClass_or_Zero", (void (*)(void))__pyx_f_9pywrapfst__get_WeightClass_or_Zero, "fst::script::WeightClass (std::string const &, PyObject *)") < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  if (__Pyx_ExportFunction("_Zero", (void (*)(void))__pyx_f_9pywrapfst__Zero, "struct __pyx_obj_9pywrapfst_Weight *(PyObject *)") < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  if (__Pyx_ExportFunction("_One", (void (*)(void))__pyx_f_9pywrapfst__One, "struct __pyx_obj_9pywrapfst_Weight *(PyObject *)") < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  if (__Pyx_ExportFunction("_NoWeight", (void (*)(void))__pyx_f_9pywrapfst__NoWeight, "struct __pyx_obj_9pywrapfst_Weight *(PyObject *)") < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  if (__Pyx_ExportFunction("_plus", (void (*)(void))__pyx_f_9pywrapfst__plus, "struct __pyx_obj_9pywrapfst_Weight *(struct __pyx_obj_9pywrapfst_Weight *, struct __pyx_obj_9pywrapfst_Weight *)") < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  if (__Pyx_ExportFunction("_times", (void (*)(void))__pyx_f_9pywrapfst__times, "struct __pyx_obj_9pywrapfst_Weight *(struct __pyx_obj_9pywrapfst_Weight *, struct __pyx_obj_9pywrapfst_Weight *)") < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  if (__Pyx_ExportFunction("_divide", (void (*)(void))__pyx_f_9pywrapfst__divide, "struct __pyx_obj_9pywrapfst_Weight *(struct __pyx_obj_9pywrapfst_Weight *, struct __pyx_obj_9pywrapfst_Weight *)") < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  if (__Pyx_ExportFunction("_power", (void (*)(void))__pyx_f_9pywrapfst__power, "struct __pyx_obj_9pywrapfst_Weight *(struct __pyx_obj_9pywrapfst_Weight *, size_t)") < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  if (__Pyx_ExportFunction("_init_EncodeMapperSymbolTable", (void (*)(void))__pyx_f_9pywrapfst__init_EncodeMapperSymbolTable, "struct __pyx_obj_9pywrapfst__EncodeMapperSymbolTable *(fst::SymbolTable *, std::shared_ptr<fst::script::EncodeMapperClass> )") < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  if (__Pyx_ExportFunction("_init_FstSymbolTable", (void (*)(void))__pyx_f_9pywrapfst__init_FstSymbolTable, "struct __pyx_obj_9pywrapfst__FstSymbolTable *(fst::SymbolTable *, std::shared_ptr<fst::script::FstClass> )") < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  if (__Pyx_ExportFunction("_init_MutableFstSymbolTable", (void (*)(void))__pyx_f_9pywrapfst__init_MutableFstSymbolTable, "struct __pyx_obj_9pywrapfst__MutableFstSymbolTable *(fst::SymbolTable *, std::shared_ptr<fst::script::MutableFstClass> )") < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  if (__Pyx_ExportFunction("_init_SymbolTable", (void (*)(void))__pyx_f_9pywrapfst__init_SymbolTable, "struct __pyx_obj_9pywrapfst_SymbolTable *(fst::SymbolTable *)") < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  if (__Pyx_ExportFunction("_init_Fst", (void (*)(void))__pyx_f_9pywrapfst__init_Fst, "struct __pyx_obj_9pywrapfst__Fst *(__pyx_t_9pywrapfst_FstClass_ptr)") < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  if (__Pyx_ExportFunction("_init_MutableFst", (void (*)(void))__pyx_f_9pywrapfst__init_MutableFst, "struct __pyx_obj_9pywrapfst__MutableFst *(__pyx_t_9pywrapfst_MutableFstClass_ptr)") < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  if (__Pyx_ExportFunction("_init_XFst", (void (*)(void))__pyx_f_9pywrapfst__init_XFst, "struct __pyx_obj_9pywrapfst__Fst *(__pyx_t_9pywrapfst_FstClass_ptr)") < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  if (__Pyx_ExportFunction("_create_Fst", (void (*)(void))__pyx_f_9pywrapfst__create_Fst, "struct __pyx_obj_9pywrapfst__MutableFst *(struct __pyx_opt_args_9pywrapfst__create_Fst *__pyx_optional_args)") < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  if (__Pyx_ExportFunction("_read", (void (*)(void))__pyx_f_9pywrapfst__read, "struct __pyx_obj_9pywrapfst__Fst *(PyObject *, int __pyx_skip_dispatch)") < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  if (__Pyx_ExportFunction("_read_from_string", (void (*)(void))__pyx_f_9pywrapfst__read_from_string, "struct __pyx_obj_9pywrapfst__Fst *(PyObject *, int __pyx_skip_dispatch)") < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  if (__Pyx_ExportFunction("_init_Arc", (void (*)(void))__pyx_f_9pywrapfst__init_Arc, "struct __pyx_obj_9pywrapfst_Arc *(fst::script::ArcClass const &)") < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  if (__Pyx_ExportFunction("_map", (void (*)(void))__pyx_f_9pywrapfst__map, "struct __pyx_obj_9pywrapfst__Fst *(struct __pyx_obj_9pywrapfst__Fst *, struct __pyx_opt_args_9pywrapfst__map *__pyx_optional_args)") < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  if (__Pyx_ExportFunction("arcmap", (void (*)(void))__pyx_f_9pywrapfst_arcmap, "struct __pyx_obj_9pywrapfst__Fst *(struct __pyx_obj_9pywrapfst__Fst *, int __pyx_skip_dispatch, struct __pyx_opt_args_9pywrapfst_arcmap *__pyx_optional_args)") < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  if (__Pyx_ExportFunction("compose", (void (*)(void))__pyx_f_9pywrapfst_compose, "struct __pyx_obj_9pywrapfst__MutableFst *(struct __pyx_obj_9pywrapfst__Fst *, struct __pyx_obj_9pywrapfst__Fst *, int __pyx_skip_dispatch, struct __pyx_opt_args_9pywrapfst_compose *__pyx_optional_args)") < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  if (__Pyx_ExportFunction("convert", (void (*)(void))__pyx_f_9pywrapfst_convert, "struct __pyx_obj_9pywrapfst__Fst *(struct __pyx_obj_9pywrapfst__Fst *, int __pyx_skip_dispatch, struct __pyx_opt_args_9pywrapfst_convert *__pyx_optional_args)") < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  if (__Pyx_ExportFunction("determinize", (void (*)(void))__pyx_f_9pywrapfst_determinize, "struct __pyx_obj_9pywrapfst__MutableFst *(struct __pyx_obj_9pywrapfst__Fst *, int __pyx_skip_dispatch, struct __pyx_opt_args_9pywrapfst_determinize *__pyx_optional_args)") < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  if (__Pyx_ExportFunction("difference", (void (*)(void))__pyx_f_9pywrapfst_difference, "struct __pyx_obj_9pywrapfst__MutableFst *(struct __pyx_obj_9pywrapfst__Fst *, struct __pyx_obj_9pywrapfst__Fst *, int __pyx_skip_dispatch, struct __pyx_opt_args_9pywrapfst_difference *__pyx_optional_args)") < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  if (__Pyx_ExportFunction("disambiguate", (void (*)(void))__pyx_f_9pywrapfst_disambiguate, "struct __pyx_obj_9pywrapfst__MutableFst *(struct __pyx_obj_9pywrapfst__Fst *, int __pyx_skip_dispatch, struct __pyx_opt_args_9pywrapfst_disambiguate *__pyx_optional_args)") < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  if (__Pyx_ExportFunction("epsnormalize", (void (*)(void))__pyx_f_9pywrapfst_epsnormalize, "struct __pyx_obj_9pywrapfst__MutableFst *(struct __pyx_obj_9pywrapfst__Fst *, int __pyx_skip_dispatch, struct __pyx_opt_args_9pywrapfst_epsnormalize *__pyx_optional_args)") < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  if (__Pyx_ExportFunction("equal", (void (*)(void))__pyx_f_9pywrapfst_equal, "bool (struct __pyx_obj_9pywrapfst__Fst *, struct __pyx_obj_9pywrapfst__Fst *, int __pyx_skip_dispatch, struct __pyx_opt_args_9pywrapfst_equal *__pyx_optional_args)") < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  if (__Pyx_ExportFunction("equivalent", (void (*)(void))__pyx_f_9pywrapfst_equivalent, "bool (struct __pyx_obj_9pywrapfst__Fst *, struct __pyx_obj_9pywrapfst__Fst *, int __pyx_skip_dispatch, struct __pyx_opt_args_9pywrapfst_equivalent *__pyx_optional_args)") < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  if (__Pyx_ExportFunction("intersect", (void (*)(void))__pyx_f_9pywrapfst_intersect, "struct __pyx_obj_9pywrapfst__MutableFst *(struct __pyx_obj_9pywrapfst__Fst *, struct __pyx_obj_9pywrapfst__Fst *, int __pyx_skip_dispatch, struct __pyx_opt_args_9pywrapfst_intersect *__pyx_optional_args)") < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  if (__Pyx_ExportFunction("isomorphic", (void (*)(void))__pyx_f_9pywrapfst_isomorphic, "bool (struct __pyx_obj_9pywrapfst__Fst *, struct __pyx_obj_9pywrapfst__Fst *, int __pyx_skip_dispatch, struct __pyx_opt_args_9pywrapfst_isomorphic *__pyx_optional_args)") < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  if (__Pyx_ExportFunction("prune", (void (*)(void))__pyx_f_9pywrapfst_prune, "struct __pyx_obj_9pywrapfst__MutableFst *(struct __pyx_obj_9pywrapfst__Fst *, int __pyx_skip_dispatch, struct __pyx_opt_args_9pywrapfst_prune *__pyx_optional_args)") < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  if (__Pyx_ExportFunction("push", (void (*)(void))__pyx_f_9pywrapfst_push, "struct __pyx_obj_9pywrapfst__MutableFst *(struct __pyx_obj_9pywrapfst__Fst *, int __pyx_skip_dispatch, struct __pyx_opt_args_9pywrapfst_push *__pyx_optional_args)") < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  if (__Pyx_ExportFunction("randequivalent", (void (*)(void))__pyx_f_9pywrapfst_randequivalent, "bool (struct __pyx_obj_9pywrapfst__Fst *, struct __pyx_obj_9pywrapfst__Fst *, int __pyx_skip_dispatch, struct __pyx_opt_args_9pywrapfst_randequivalent *__pyx_optional_args)") < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  if (__Pyx_ExportFunction("randgen", (void (*)(void))__pyx_f_9pywrapfst_randgen, "struct __pyx_obj_9pywrapfst__MutableFst *(struct __pyx_obj_9pywrapfst__Fst *, int __pyx_skip_dispatch, struct __pyx_opt_args_9pywrapfst_randgen *__pyx_optional_args)") < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  if (__Pyx_ExportFunction("replace", (void (*)(void))__pyx_f_9pywrapfst_replace, "struct __pyx_obj_9pywrapfst__MutableFst *(PyObject *, int __pyx_skip_dispatch, struct __pyx_opt_args_9pywrapfst_replace *__pyx_optional_args)") < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  if (__Pyx_ExportFunction("reverse", (void (*)(void))__pyx_f_9pywrapfst_reverse, "struct __pyx_obj_9pywrapfst__MutableFst *(struct __pyx_obj_9pywrapfst__Fst *, int __pyx_skip_dispatch, struct __pyx_opt_args_9pywrapfst_reverse *__pyx_optional_args)") < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  if (__Pyx_ExportFunction("_shortestdistance", (void (*)(void))__pyx_f_9pywrapfst__shortestdistance, "std::vector<fst::script::WeightClass>  *(struct __pyx_obj_9pywrapfst__Fst *, struct __pyx_opt_args_9pywrapfst__shortestdistance *__pyx_optional_args)") < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  if (__Pyx_ExportFunction("shortestpath", (void (*)(void))__pyx_f_9pywrapfst_shortestpath, "struct __pyx_obj_9pywrapfst__MutableFst *(struct __pyx_obj_9pywrapfst__Fst *, int __pyx_skip_dispatch, struct __pyx_opt_args_9pywrapfst_shortestpath *__pyx_optional_args)") < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  if (__Pyx_ExportFunction("statemap", (void (*)(void))__pyx_f_9pywrapfst_statemap, "struct __pyx_obj_9pywrapfst__Fst *(struct __pyx_obj_9pywrapfst__Fst *, PyObject *, int __pyx_skip_dispatch)") < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  if (__Pyx_ExportFunction("synchronize", (void (*)(void))__pyx_f_9pywrapfst_synchronize, "struct __pyx_obj_9pywrapfst__MutableFst *(struct __pyx_obj_9pywrapfst__Fst *, int __pyx_skip_dispatch)") < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  /*--- Type init code ---*/
  __pyx_vtabptr_9pywrapfst_Weight = &__pyx_vtable_9pywrapfst_Weight;
  __pyx_vtable_9pywrapfst_Weight._check_weight = (void (*)(struct __pyx_obj_9pywrapfst_Weight *))__pyx_f_9pywrapfst_6Weight__check_weight;
  __pyx_vtable_9pywrapfst_Weight.copy = (struct __pyx_obj_9pywrapfst_Weight *(*)(struct __pyx_obj_9pywrapfst_Weight *, int __pyx_skip_dispatch))__pyx_f_9pywrapfst_6Weight_copy;
  __pyx_vtable_9pywrapfst_Weight.to_string = (std::string (*)(struct __pyx_obj_9pywrapfst_Weight *, int __pyx_skip_dispatch))__pyx_f_9pywrapfst_6Weight_to_string;
  __pyx_vtable_9pywrapfst_Weight.type = (std::string (*)(struct __pyx_obj_9pywrapfst_Weight *, int __pyx_skip_dispatch))__pyx_f_9pywrapfst_6Weight_type;
  if (PyType_Ready(&__pyx_type_9pywrapfst_Weight) < 0) __PYX_ERR(0, 348, __pyx_L1_error)
  __pyx_type_9pywrapfst_Weight.tp_print = 0;
  if (__Pyx_SetVtable(__pyx_type_9pywrapfst_Weight.tp_dict, __pyx_vtabptr_9pywrapfst_Weight) < 0) __PYX_ERR(0, 348, __pyx_L1_error)
  if (PyObject_SetAttrString(__pyx_m, "Weight", (PyObject *)&__pyx_type_9pywrapfst_Weight) < 0) __PYX_ERR(0, 348, __pyx_L1_error)
  if (__Pyx_setup_reduce((PyObject*)&__pyx_type_9pywrapfst_Weight) < 0) __PYX_ERR(0, 348, __pyx_L1_error)
  __pyx_ptype_9pywrapfst_Weight = &__pyx_type_9pywrapfst_Weight;
  __pyx_vtabptr_9pywrapfst__SymbolTable = &__pyx_vtable_9pywrapfst__SymbolTable;
  __pyx_vtable_9pywrapfst__SymbolTable.available_key = (__pyx_t_10basictypes_int64 (*)(struct __pyx_obj_9pywrapfst__SymbolTable *, int __pyx_skip_dispatch))__pyx_f_9pywrapfst_12_SymbolTable_available_key;
  __pyx_vtable_9pywrapfst__SymbolTable.checksum = (std::string (*)(struct __pyx_obj_9pywrapfst__SymbolTable *, int __pyx_skip_dispatch))__pyx_f_9pywrapfst_12_SymbolTable_checksum;
  __pyx_vtable_9pywrapfst__SymbolTable.copy = (struct __pyx_obj_9pywrapfst_SymbolTable *(*)(struct __pyx_obj_9pywrapfst__SymbolTable *, int __pyx_skip_dispatch))__pyx_f_9pywrapfst_12_SymbolTable_copy;
  __pyx_vtable_9pywrapfst__SymbolTable.get_nth_key = (__pyx_t_10basictypes_int64 (*)(struct __pyx_obj_9pywrapfst__SymbolTable *, Py_ssize_t, int __pyx_skip_dispatch))__pyx_f_9pywrapfst_12_SymbolTable_get_nth_key;
  __pyx_vtable_9pywrapfst__SymbolTable.labeled_checksum = (std::string (*)(struct __pyx_obj_9pywrapfst__SymbolTable *, int __pyx_skip_dispatch))__pyx_f_9pywrapfst_12_SymbolTable_labeled_checksum;
  __pyx_vtable_9pywrapfst__SymbolTable.member = (bool (*)(struct __pyx_obj_9pywrapfst__SymbolTable *, PyObject *, int __pyx_skip_dispatch))__pyx_f_9pywrapfst_12_SymbolTable_member;
  __pyx_vtable_9pywrapfst__SymbolTable.name = (std::string (*)(struct __pyx_obj_9pywrapfst__SymbolTable *, int __pyx_skip_dispatch))__pyx_f_9pywrapfst_12_SymbolTable_name;
  __pyx_vtable_9pywrapfst__SymbolTable.num_symbols = (size_t (*)(struct __pyx_obj_9pywrapfst__SymbolTable *, int __pyx_skip_dispatch))__pyx_f_9pywrapfst_12_SymbolTable_num_symbols;
  __pyx_vtable_9pywrapfst__SymbolTable.write = (void (*)(struct __pyx_obj_9pywrapfst__SymbolTable *, PyObject *, int __pyx_skip_dispatch))__pyx_f_9pywrapfst_12_SymbolTable_write;
  __pyx_vtable_9pywrapfst__SymbolTable.write_text = (void (*)(struct __pyx_obj_9pywrapfst__SymbolTable *, PyObject *, int __pyx_skip_dispatch))__pyx_f_9pywrapfst_12_SymbolTable_write_text;
  if (PyType_Ready(&__pyx_type_9pywrapfst__SymbolTable) < 0) __PYX_ERR(0, 675, __pyx_L1_error)
  __pyx_type_9pywrapfst__SymbolTable.tp_print = 0;
  if (__Pyx_SetVtable(__pyx_type_9pywrapfst__SymbolTable.tp_dict, __pyx_vtabptr_9pywrapfst__SymbolTable) < 0) __PYX_ERR(0, 675, __pyx_L1_error)
  if (PyObject_SetAttrString(__pyx_m, "_SymbolTable", (PyObject *)&__pyx_type_9pywrapfst__SymbolTable) < 0) __PYX_ERR(0, 675, __pyx_L1_error)
  if (__Pyx_setup_reduce((PyObject*)&__pyx_type_9pywrapfst__SymbolTable) < 0) __PYX_ERR(0, 675, __pyx_L1_error)
  __pyx_ptype_9pywrapfst__SymbolTable = &__pyx_type_9pywrapfst__SymbolTable;
  __pyx_vtabptr_9pywrapfst__EncodeMapperSymbolTable = &__pyx_vtable_9pywrapfst__EncodeMapperSymbolTable;
  __pyx_vtable_9pywrapfst__EncodeMapperSymbolTable.__pyx_base = *__pyx_vtabptr_9pywrapfst__SymbolTable;
  __pyx_type_9pywrapfst__EncodeMapperSymbolTable.tp_base = __pyx_ptype_9pywrapfst__SymbolTable;
  if (PyType_Ready(&__pyx_type_9pywrapfst__EncodeMapperSymbolTable) < 0) __PYX_ERR(0, 839, __pyx_L1_error)
  __pyx_type_9pywrapfst__EncodeMapperSymbolTable.tp_print = 0;
  if (__Pyx_SetVtable(__pyx_type_9pywrapfst__EncodeMapperSymbolTable.tp_dict, __pyx_vtabptr_9pywrapfst__EncodeMapperSymbolTable) < 0) __PYX_ERR(0, 839, __pyx_L1_error)
  if (PyObject_SetAttrString(__pyx_m, "_EncodeMapperSymbolTable", (PyObject *)&__pyx_type_9pywrapfst__EncodeMapperSymbolTable) < 0) __PYX_ERR(0, 839, __pyx_L1_error)
  if (__Pyx_setup_reduce((PyObject*)&__pyx_type_9pywrapfst__EncodeMapperSymbolTable) < 0) __PYX_ERR(0, 839, __pyx_L1_error)
  __pyx_ptype_9pywrapfst__EncodeMapperSymbolTable = &__pyx_type_9pywrapfst__EncodeMapperSymbolTable;
  __pyx_vtabptr_9pywrapfst__FstSymbolTable = &__pyx_vtable_9pywrapfst__FstSymbolTable;
  __pyx_vtable_9pywrapfst__FstSymbolTable.__pyx_base = *__pyx_vtabptr_9pywrapfst__SymbolTable;
  __pyx_type_9pywrapfst__FstSymbolTable.tp_base = __pyx_ptype_9pywrapfst__SymbolTable;
  if (PyType_Ready(&__pyx_type_9pywrapfst__FstSymbolTable) < 0) __PYX_ERR(0, 859, __pyx_L1_error)
  __pyx_type_9pywrapfst__FstSymbolTable.tp_print = 0;
  if (__Pyx_SetVtable(__pyx_type_9pywrapfst__FstSymbolTable.tp_dict, __pyx_vtabptr_9pywrapfst__FstSymbolTable) < 0) __PYX_ERR(0, 859, __pyx_L1_error)
  if (PyObject_SetAttrString(__pyx_m, "_FstSymbolTable", (PyObject *)&__pyx_type_9pywrapfst__FstSymbolTable) < 0) __PYX_ERR(0, 859, __pyx_L1_error)
  if (__Pyx_setup_reduce((PyObject*)&__pyx_type_9pywrapfst__FstSymbolTable) < 0) __PYX_ERR(0, 859, __pyx_L1_error)
  __pyx_ptype_9pywrapfst__FstSymbolTable = &__pyx_type_9pywrapfst__FstSymbolTable;
  __pyx_vtabptr_9pywrapfst__MutableSymbolTable = &__pyx_vtable_9pywrapfst__MutableSymbolTable;
  __pyx_vtable_9pywrapfst__MutableSymbolTable.__pyx_base = *__pyx_vtabptr_9pywrapfst__SymbolTable;
  __pyx_vtable_9pywrapfst__MutableSymbolTable.add_symbol = (__pyx_t_10basictypes_int64 (*)(struct __pyx_obj_9pywrapfst__MutableSymbolTable *, PyObject *, int __pyx_skip_dispatch, struct __pyx_opt_args_9pywrapfst_19_MutableSymbolTable_add_symbol *__pyx_optional_args))__pyx_f_9pywrapfst_19_MutableSymbolTable_add_symbol;
  __pyx_vtable_9pywrapfst__MutableSymbolTable.add_table = (void (*)(struct __pyx_obj_9pywrapfst__MutableSymbolTable *, struct __pyx_obj_9pywrapfst__SymbolTable *, int __pyx_skip_dispatch))__pyx_f_9pywrapfst_19_MutableSymbolTable_add_table;
  __pyx_vtable_9pywrapfst__MutableSymbolTable.set_name = (void (*)(struct __pyx_obj_9pywrapfst__MutableSymbolTable *, PyObject *, int __pyx_skip_dispatch))__pyx_f_9pywrapfst_19_MutableSymbolTable_set_name;
  __pyx_type_9pywrapfst__MutableSymbolTable.tp_base = __pyx_ptype_9pywrapfst__SymbolTable;
  if (PyType_Ready(&__pyx_type_9pywrapfst__MutableSymbolTable) < 0) __PYX_ERR(0, 878, __pyx_L1_error)
  __pyx_type_9pywrapfst__MutableSymbolTable.tp_print = 0;
  if (__Pyx_SetVtable(__pyx_type_9pywrapfst__MutableSymbolTable.tp_dict, __pyx_vtabptr_9pywrapfst__MutableSymbolTable) < 0) __PYX_ERR(0, 878, __pyx_L1_error)
  if (PyObject_SetAttrString(__pyx_m, "_MutableSymbolTable", (PyObject *)&__pyx_type_9pywrapfst__MutableSymbolTable) < 0) __PYX_ERR(0, 878, __pyx_L1_error)
  if (__Pyx_setup_reduce((PyObject*)&__pyx_type_9pywrapfst__MutableSymbolTable) < 0) __PYX_ERR(0, 878, __pyx_L1_error)
  __pyx_ptype_9pywrapfst__MutableSymbolTable = &__pyx_type_9pywrapfst__MutableSymbolTable;
  __pyx_vtabptr_9pywrapfst__MutableFstSymbolTable = &__pyx_vtable_9pywrapfst__MutableFstSymbolTable;
  __pyx_vtable_9pywrapfst__MutableFstSymbolTable.__pyx_base = *__pyx_vtabptr_9pywrapfst__MutableSymbolTable;
  __pyx_type_9pywrapfst__MutableFstSymbolTable.tp_base = __pyx_ptype_9pywrapfst__MutableSymbolTable;
  if (PyType_Ready(&__pyx_type_9pywrapfst__MutableFstSymbolTable) < 0) __PYX_ERR(0, 930, __pyx_L1_error)
  __pyx_type_9pywrapfst__MutableFstSymbolTable.tp_print = 0;
  if (__Pyx_SetVtable(__pyx_type_9pywrapfst__MutableFstSymbolTable.tp_dict, __pyx_vtabptr_9pywrapfst__MutableFstSymbolTable) < 0) __PYX_ERR(0, 930, __pyx_L1_error)
  if (PyObject_SetAttrString(__pyx_m, "_MutableFstSymbolTable", (PyObject *)&__pyx_type_9pywrapfst__MutableFstSymbolTable) < 0) __PYX_ERR(0, 930, __pyx_L1_error)
  if (__Pyx_setup_reduce((PyObject*)&__pyx_type_9pywrapfst__MutableFstSymbolTable) < 0) __PYX_ERR(0, 930, __pyx_L1_error)
  __pyx_ptype_9pywrapfst__MutableFstSymbolTable = &__pyx_type_9pywrapfst__MutableFstSymbolTable;
  __pyx_vtabptr_9pywrapfst_SymbolTable = &__pyx_vtable_9pywrapfst_SymbolTable;
  __pyx_vtable_9pywrapfst_SymbolTable.__pyx_base = *__pyx_vtabptr_9pywrapfst__MutableSymbolTable;
  __pyx_type_9pywrapfst_SymbolTable.tp_base = __pyx_ptype_9pywrapfst__MutableSymbolTable;
  if (PyType_Ready(&__pyx_type_9pywrapfst_SymbolTable) < 0) __PYX_ERR(0, 941, __pyx_L1_error)
  __pyx_type_9pywrapfst_SymbolTable.tp_print = 0;
  if (__Pyx_SetVtable(__pyx_type_9pywrapfst_SymbolTable.tp_dict, __pyx_vtabptr_9pywrapfst_SymbolTable) < 0) __PYX_ERR(0, 941, __pyx_L1_error)
  if (PyObject_SetAttrString(__pyx_m, "SymbolTable", (PyObject *)&__pyx_type_9pywrapfst_SymbolTable) < 0) __PYX_ERR(0, 941, __pyx_L1_error)
  if (__Pyx_setup_reduce((PyObject*)&__pyx_type_9pywrapfst_SymbolTable) < 0) __PYX_ERR(0, 941, __pyx_L1_error)
  __pyx_ptype_9pywrapfst_SymbolTable = &__pyx_type_9pywrapfst_SymbolTable;
  __pyx_vtabptr_9pywrapfst_SymbolTableIterator = &__pyx_vtable_9pywrapfst_SymbolTableIterator;
  __pyx_vtable_9pywrapfst_SymbolTableIterator.done = (bool (*)(struct __pyx_obj_9pywrapfst_SymbolTableIterator *, int __pyx_skip_dispatch))__pyx_f_9pywrapfst_19SymbolTableIterator_done;
  __pyx_vtable_9pywrapfst_SymbolTableIterator.next = (void (*)(struct __pyx_obj_9pywrapfst_SymbolTableIterator *, int __pyx_skip_dispatch))__pyx_f_9pywrapfst_19SymbolTableIterator_next;
  __pyx_vtable_9pywrapfst_SymbolTableIterator.reset = (void (*)(struct __pyx_obj_9pywrapfst_SymbolTableIterator *, int __pyx_skip_dispatch))__pyx_f_9pywrapfst_19SymbolTableIterator_reset;
  __pyx_vtable_9pywrapfst_SymbolTableIterator.symbol = (std::string (*)(struct __pyx_obj_9pywrapfst_SymbolTableIterator *, int __pyx_skip_dispatch))__pyx_f_9pywrapfst_19SymbolTableIterator_symbol;
  __pyx_vtable_9pywrapfst_SymbolTableIterator.value = (__pyx_t_10basictypes_int64 (*)(struct __pyx_obj_9pywrapfst_SymbolTableIterator *, int __pyx_skip_dispatch))__pyx_f_9pywrapfst_19SymbolTableIterator_value;
  if (PyType_Ready(&__pyx_type_9pywrapfst_SymbolTableIterator) < 0) __PYX_ERR(0, 1124, __pyx_L1_error)
  __pyx_type_9pywrapfst_SymbolTableIterator.tp_print = 0;
  if (__Pyx_SetVtable(__pyx_type_9pywrapfst_SymbolTableIterator.tp_dict, __pyx_vtabptr_9pywrapfst_SymbolTableIterator) < 0) __PYX_ERR(0, 1124, __pyx_L1_error)
  if (PyObject_SetAttrString(__pyx_m, "SymbolTableIterator", (PyObject *)&__pyx_type_9pywrapfst_SymbolTableIterator) < 0) __PYX_ERR(0, 1124, __pyx_L1_error)
  if (__Pyx_setup_reduce((PyObject*)&__pyx_type_9pywrapfst_SymbolTableIterator) < 0) __PYX_ERR(0, 1124, __pyx_L1_error)
  __pyx_ptype_9pywrapfst_SymbolTableIterator = &__pyx_type_9pywrapfst_SymbolTableIterator;
  __pyx_vtabptr_9pywrapfst_EncodeMapper = &__pyx_vtable_9pywrapfst_EncodeMapper;
  __pyx_vtable_9pywrapfst_EncodeMapper.arc_type = (std::string (*)(struct __pyx_obj_9pywrapfst_EncodeMapper *, int __pyx_skip_dispatch))__pyx_f_9pywrapfst_12EncodeMapper_arc_type;
  __pyx_vtable_9pywrapfst_EncodeMapper.flags = (__pyx_t_10basictypes_uint32 (*)(struct __pyx_obj_9pywrapfst_EncodeMapper *, int __pyx_skip_dispatch))__pyx_f_9pywrapfst_12EncodeMapper_flags;
  __pyx_vtable_9pywrapfst_EncodeMapper.input_symbols = (struct __pyx_obj_9pywrapfst__EncodeMapperSymbolTable *(*)(struct __pyx_obj_9pywrapfst_EncodeMapper *, int __pyx_skip_dispatch))__pyx_f_9pywrapfst_12EncodeMapper_input_symbols;
  __pyx_vtable_9pywrapfst_EncodeMapper.output_symbols = (struct __pyx_obj_9pywrapfst__EncodeMapperSymbolTable *(*)(struct __pyx_obj_9pywrapfst_EncodeMapper *, int __pyx_skip_dispatch))__pyx_f_9pywrapfst_12EncodeMapper_output_symbols;
  __pyx_vtable_9pywrapfst_EncodeMapper.properties = (__pyx_t_10basictypes_uint64 (*)(struct __pyx_obj_9pywrapfst_EncodeMapper *, __pyx_t_10basictypes_uint64, int __pyx_skip_dispatch))__pyx_f_9pywrapfst_12EncodeMapper_properties;
  __pyx_vtable_9pywrapfst_EncodeMapper.set_input_symbols = (void (*)(struct __pyx_obj_9pywrapfst_EncodeMapper *, struct __pyx_obj_9pywrapfst__SymbolTable *, int __pyx_skip_dispatch))__pyx_f_9pywrapfst_12EncodeMapper_set_input_symbols;
  __pyx_vtable_9pywrapfst_EncodeMapper.set_output_symbols = (void (*)(struct __pyx_obj_9pywrapfst_EncodeMapper *, struct __pyx_obj_9pywrapfst__SymbolTable *, int __pyx_skip_dispatch))__pyx_f_9pywrapfst_12EncodeMapper_set_output_symbols;
  __pyx_vtable_9pywrapfst_EncodeMapper.weight_type = (std::string (*)(struct __pyx_obj_9pywrapfst_EncodeMapper *, int __pyx_skip_dispatch))__pyx_f_9pywrapfst_12EncodeMapper_weight_type;
  if (PyType_Ready(&__pyx_type_9pywrapfst_EncodeMapper) < 0) __PYX_ERR(0, 1206, __pyx_L1_error)
  __pyx_type_9pywrapfst_EncodeMapper.tp_print = 0;
  #if CYTHON_COMPILING_IN_CPYTHON
  {
    PyObject *wrapper = PyObject_GetAttrString((PyObject *)&__pyx_type_9pywrapfst_EncodeMapper, "__call__"); if (unlikely(!wrapper)) __PYX_ERR(0, 1206, __pyx_L1_error)
    if (Py_TYPE(wrapper) == &PyWrapperDescr_Type) {
      __pyx_wrapperbase_9pywrapfst_12EncodeMapper_6__call__ = *((PyWrapperDescrObject *)wrapper)->d_base;
      __pyx_wrapperbase_9pywrapfst_12EncodeMapper_6__call__.doc = __pyx_doc_9pywrapfst_12EncodeMapper_6__call__;
      ((PyWrapperDescrObject *)wrapper)->d_base = &__pyx_wrapperbase_9pywrapfst_12EncodeMapper_6__call__;
    }
  }
  #endif
  if (__Pyx_SetVtable(__pyx_type_9pywrapfst_EncodeMapper.tp_dict, __pyx_vtabptr_9pywrapfst_EncodeMapper) < 0) __PYX_ERR(0, 1206, __pyx_L1_error)
  if (PyObject_SetAttrString(__pyx_m, "EncodeMapper", (PyObject *)&__pyx_type_9pywrapfst_EncodeMapper) < 0) __PYX_ERR(0, 1206, __pyx_L1_error)
  if (__Pyx_setup_reduce((PyObject*)&__pyx_type_9pywrapfst_EncodeMapper) < 0) __PYX_ERR(0, 1206, __pyx_L1_error)
  __pyx_ptype_9pywrapfst_EncodeMapper = &__pyx_type_9pywrapfst_EncodeMapper;
  __pyx_vtabptr_9pywrapfst__Fst = &__pyx_vtable_9pywrapfst__Fst;
  __pyx_vtable_9pywrapfst__Fst.arc_type = (std::string (*)(struct __pyx_obj_9pywrapfst__Fst *, int __pyx_skip_dispatch))__pyx_f_9pywrapfst_4_Fst_arc_type;
  __pyx_vtable_9pywrapfst__Fst.arcs = (struct __pyx_obj_9pywrapfst_ArcIterator *(*)(struct __pyx_obj_9pywrapfst__Fst *, __pyx_t_10basictypes_int64, int __pyx_skip_dispatch))__pyx_f_9pywrapfst_4_Fst_arcs;
  __pyx_vtable_9pywrapfst__Fst.copy = (struct __pyx_obj_9pywrapfst__Fst *(*)(struct __pyx_obj_9pywrapfst__Fst *, int __pyx_skip_dispatch))__pyx_f_9pywrapfst_4_Fst_copy;
  __pyx_vtable_9pywrapfst__Fst.draw = (void (*)(struct __pyx_obj_9pywrapfst__Fst *, PyObject *, int __pyx_skip_dispatch, struct __pyx_opt_args_9pywrapfst_4_Fst_draw *__pyx_optional_args))__pyx_f_9pywrapfst_4_Fst_draw;
  __pyx_vtable_9pywrapfst__Fst.final = (struct __pyx_obj_9pywrapfst_Weight *(*)(struct __pyx_obj_9pywrapfst__Fst *, __pyx_t_10basictypes_int64, int __pyx_skip_dispatch))__pyx_f_9pywrapfst_4_Fst_final;
  __pyx_vtable_9pywrapfst__Fst.fst_type = (std::string (*)(struct __pyx_obj_9pywrapfst__Fst *, int __pyx_skip_dispatch))__pyx_f_9pywrapfst_4_Fst_fst_type;
  __pyx_vtable_9pywrapfst__Fst.input_symbols = (struct __pyx_obj_9pywrapfst__FstSymbolTable *(*)(struct __pyx_obj_9pywrapfst__Fst *, int __pyx_skip_dispatch))__pyx_f_9pywrapfst_4_Fst_input_symbols;
  __pyx_vtable_9pywrapfst__Fst.num_arcs = (size_t (*)(struct __pyx_obj_9pywrapfst__Fst *, __pyx_t_10basictypes_int64, int __pyx_skip_dispatch))__pyx_f_9pywrapfst_4_Fst_num_arcs;
  __pyx_vtable_9pywrapfst__Fst.num_input_epsilons = (size_t (*)(struct __pyx_obj_9pywrapfst__Fst *, __pyx_t_10basictypes_int64, int __pyx_skip_dispatch))__pyx_f_9pywrapfst_4_Fst_num_input_epsilons;
  __pyx_vtable_9pywrapfst__Fst.num_output_epsilons = (size_t (*)(struct __pyx_obj_9pywrapfst__Fst *, __pyx_t_10basictypes_int64, int __pyx_skip_dispatch))__pyx_f_9pywrapfst_4_Fst_num_output_epsilons;
  __pyx_vtable_9pywrapfst__Fst.output_symbols = (struct __pyx_obj_9pywrapfst__FstSymbolTable *(*)(struct __pyx_obj_9pywrapfst__Fst *, int __pyx_skip_dispatch))__pyx_f_9pywrapfst_4_Fst_output_symbols;
  __pyx_vtable_9pywrapfst__Fst.properties = (__pyx_t_10basictypes_uint64 (*)(struct __pyx_obj_9pywrapfst__Fst *, __pyx_t_10basictypes_uint64, bool, int __pyx_skip_dispatch))__pyx_f_9pywrapfst_4_Fst_properties;
  __pyx_vtable_9pywrapfst__Fst.start = (__pyx_t_10basictypes_int64 (*)(struct __pyx_obj_9pywrapfst__Fst *, int __pyx_skip_dispatch))__pyx_f_9pywrapfst_4_Fst_start;
  __pyx_vtable_9pywrapfst__Fst.states = (struct __pyx_obj_9pywrapfst_StateIterator *(*)(struct __pyx_obj_9pywrapfst__Fst *, int __pyx_skip_dispatch))__pyx_f_9pywrapfst_4_Fst_states;
  __pyx_vtable_9pywrapfst__Fst.text = (std::string (*)(struct __pyx_obj_9pywrapfst__Fst *, int __pyx_skip_dispatch, struct __pyx_opt_args_9pywrapfst_4_Fst_text *__pyx_optional_args))__pyx_f_9pywrapfst_4_Fst_text;
  __pyx_vtable_9pywrapfst__Fst.verify = (bool (*)(struct __pyx_obj_9pywrapfst__Fst *, int __pyx_skip_dispatch))__pyx_f_9pywrapfst_4_Fst_verify;
  __pyx_vtable_9pywrapfst__Fst.weight_type = (std::string (*)(struct __pyx_obj_9pywrapfst__Fst *, int __pyx_skip_dispatch))__pyx_f_9pywrapfst_4_Fst_weight_type;
  __pyx_vtable_9pywrapfst__Fst.write = (void (*)(struct __pyx_obj_9pywrapfst__Fst *, PyObject *, int __pyx_skip_dispatch))__pyx_f_9pywrapfst_4_Fst_write;
  __pyx_vtable_9pywrapfst__Fst.write_to_string = (std::string (*)(struct __pyx_obj_9pywrapfst__Fst *, int __pyx_skip_dispatch))__pyx_f_9pywrapfst_4_Fst_write_to_string;
  if (PyType_Ready(&__pyx_type_9pywrapfst__Fst) < 0) __PYX_ERR(0, 1362, __pyx_L1_error)
  __pyx_type_9pywrapfst__Fst.tp_print = 0;
  if (__Pyx_SetVtable(__pyx_type_9pywrapfst__Fst.tp_dict, __pyx_vtabptr_9pywrapfst__Fst) < 0) __PYX_ERR(0, 1362, __pyx_L1_error)
  if (PyObject_SetAttrString(__pyx_m, "_Fst", (PyObject *)&__pyx_type_9pywrapfst__Fst) < 0) __PYX_ERR(0, 1362, __pyx_L1_error)
  __pyx_ptype_9pywrapfst__Fst = &__pyx_type_9pywrapfst__Fst;
  __pyx_vtabptr_9pywrapfst__MutableFst = &__pyx_vtable_9pywrapfst__MutableFst;
  __pyx_vtable_9pywrapfst__MutableFst.__pyx_base = *__pyx_vtabptr_9pywrapfst__Fst;
  __pyx_vtable_9pywrapfst__MutableFst._check_mutating_imethod = (void (*)(struct __pyx_obj_9pywrapfst__MutableFst *))__pyx_f_9pywrapfst_11_MutableFst__check_mutating_imethod;
  __pyx_vtable_9pywrapfst__MutableFst._add_arc = (void (*)(struct __pyx_obj_9pywrapfst__MutableFst *, __pyx_t_10basictypes_int64, struct __pyx_obj_9pywrapfst_Arc *))__pyx_f_9pywrapfst_11_MutableFst__add_arc;
  __pyx_vtable_9pywrapfst__MutableFst.add_state = (__pyx_t_10basictypes_int64 (*)(struct __pyx_obj_9pywrapfst__MutableFst *, int __pyx_skip_dispatch))__pyx_f_9pywrapfst_11_MutableFst_add_state;
  __pyx_vtable_9pywrapfst__MutableFst._arcsort = (void (*)(struct __pyx_obj_9pywrapfst__MutableFst *, struct __pyx_opt_args_9pywrapfst_11_MutableFst__arcsort *__pyx_optional_args))__pyx_f_9pywrapfst_11_MutableFst__arcsort;
  __pyx_vtable_9pywrapfst__MutableFst._closure = (void (*)(struct __pyx_obj_9pywrapfst__MutableFst *, struct __pyx_opt_args_9pywrapfst_11_MutableFst__closure *__pyx_optional_args))__pyx_f_9pywrapfst_11_MutableFst__closure;
  __pyx_vtable_9pywrapfst__MutableFst._concat = (void (*)(struct __pyx_obj_9pywrapfst__MutableFst *, struct __pyx_obj_9pywrapfst__Fst *))__pyx_f_9pywrapfst_11_MutableFst__concat;
  __pyx_vtable_9pywrapfst__MutableFst._connect = (void (*)(struct __pyx_obj_9pywrapfst__MutableFst *))__pyx_f_9pywrapfst_11_MutableFst__connect;
  __pyx_vtable_9pywrapfst__MutableFst._decode = (void (*)(struct __pyx_obj_9pywrapfst__MutableFst *, struct __pyx_obj_9pywrapfst_EncodeMapper *))__pyx_f_9pywrapfst_11_MutableFst__decode;
  __pyx_vtable_9pywrapfst__MutableFst._delete_arcs = (void (*)(struct __pyx_obj_9pywrapfst__MutableFst *, __pyx_t_10basictypes_int64, struct __pyx_opt_args_9pywrapfst_11_MutableFst__delete_arcs *__pyx_optional_args))__pyx_f_9pywrapfst_11_MutableFst__delete_arcs;
  __pyx_vtable_9pywrapfst__MutableFst._delete_states = (void (*)(struct __pyx_obj_9pywrapfst__MutableFst *, struct __pyx_opt_args_9pywrapfst_11_MutableFst__delete_states *__pyx_optional_args))__pyx_f_9pywrapfst_11_MutableFst__delete_states;
  __pyx_vtable_9pywrapfst__MutableFst._encode = (void (*)(struct __pyx_obj_9pywrapfst__MutableFst *, struct __pyx_obj_9pywrapfst_EncodeMapper *))__pyx_f_9pywrapfst_11_MutableFst__encode;
  __pyx_vtable_9pywrapfst__MutableFst._invert = (void (*)(struct __pyx_obj_9pywrapfst__MutableFst *))__pyx_f_9pywrapfst_11_MutableFst__invert;
  __pyx_vtable_9pywrapfst__MutableFst._minimize = (void (*)(struct __pyx_obj_9pywrapfst__MutableFst *, struct __pyx_opt_args_9pywrapfst_11_MutableFst__minimize *__pyx_optional_args))__pyx_f_9pywrapfst_11_MutableFst__minimize;
  __pyx_vtable_9pywrapfst__MutableFst.mutable_arcs = (struct __pyx_obj_9pywrapfst_MutableArcIterator *(*)(struct __pyx_obj_9pywrapfst__MutableFst *, __pyx_t_10basictypes_int64, int __pyx_skip_dispatch))__pyx_f_9pywrapfst_11_MutableFst_mutable_arcs;
  __pyx_vtable_9pywrapfst__MutableFst.num_states = (__pyx_t_10basictypes_int64 (*)(struct __pyx_obj_9pywrapfst__MutableFst *, int __pyx_skip_dispatch))__pyx_f_9pywrapfst_11_MutableFst_num_states;
  __pyx_vtable_9pywrapfst__MutableFst._project = (void (*)(struct __pyx_obj_9pywrapfst__MutableFst *, struct __pyx_opt_args_9pywrapfst_11_MutableFst__project *__pyx_optional_args))__pyx_f_9pywrapfst_11_MutableFst__project;
  __pyx_vtable_9pywrapfst__MutableFst._prune = (void (*)(struct __pyx_obj_9pywrapfst__MutableFst *, struct __pyx_opt_args_9pywrapfst_11_MutableFst__prune *__pyx_optional_args))__pyx_f_9pywrapfst_11_MutableFst__prune;
  __pyx_vtable_9pywrapfst__MutableFst._push = (void (*)(struct __pyx_obj_9pywrapfst__MutableFst *, struct __pyx_opt_args_9pywrapfst_11_MutableFst__push *__pyx_optional_args))__pyx_f_9pywrapfst_11_MutableFst__push;
  __pyx_vtable_9pywrapfst__MutableFst._relabel_pairs = (void (*)(struct __pyx_obj_9pywrapfst__MutableFst *, struct __pyx_opt_args_9pywrapfst_11_MutableFst__relabel_pairs *__pyx_optional_args))__pyx_f_9pywrapfst_11_MutableFst__relabel_pairs;
  __pyx_vtable_9pywrapfst__MutableFst._relabel_tables = (void (*)(struct __pyx_obj_9pywrapfst__MutableFst *, struct __pyx_opt_args_9pywrapfst_11_MutableFst__relabel_tables *__pyx_optional_args))__pyx_f_9pywrapfst_11_MutableFst__relabel_tables;
  __pyx_vtable_9pywrapfst__MutableFst._reserve_arcs = (void (*)(struct __pyx_obj_9pywrapfst__MutableFst *, __pyx_t_10basictypes_int64, size_t))__pyx_f_9pywrapfst_11_MutableFst__reserve_arcs;
  __pyx_vtable_9pywrapfst__MutableFst._reserve_states = (void (*)(struct __pyx_obj_9pywrapfst__MutableFst *, __pyx_t_10basictypes_int64))__pyx_f_9pywrapfst_11_MutableFst__reserve_states;
  __pyx_vtable_9pywrapfst__MutableFst._reweight = (void (*)(struct __pyx_obj_9pywrapfst__MutableFst *, PyObject *, struct __pyx_opt_args_9pywrapfst_11_MutableFst__reweight *__pyx_optional_args))__pyx_f_9pywrapfst_11_MutableFst__reweight;
  __pyx_vtable_9pywrapfst__MutableFst._rmepsilon = (void (*)(struct __pyx_obj_9pywrapfst__MutableFst *, struct __pyx_opt_args_9pywrapfst_11_MutableFst__rmepsilon *__pyx_optional_args))__pyx_f_9pywrapfst_11_MutableFst__rmepsilon;
  __pyx_vtable_9pywrapfst__MutableFst._set_final = (void (*)(struct __pyx_obj_9pywrapfst__MutableFst *, __pyx_t_10basictypes_int64, struct __pyx_opt_args_9pywrapfst_11_MutableFst__set_final *__pyx_optional_args))__pyx_f_9pywrapfst_11_MutableFst__set_final;
  __pyx_vtable_9pywrapfst__MutableFst._set_properties = (void (*)(struct __pyx_obj_9pywrapfst__MutableFst *, __pyx_t_10basictypes_uint64, __pyx_t_10basictypes_uint64))__pyx_f_9pywrapfst_11_MutableFst__set_properties;
  __pyx_vtable_9pywrapfst__MutableFst._set_start = (void (*)(struct __pyx_obj_9pywrapfst__MutableFst *, __pyx_t_10basictypes_int64))__pyx_f_9pywrapfst_11_MutableFst__set_start;
  __pyx_vtable_9pywrapfst__MutableFst._set_input_symbols = (void (*)(struct __pyx_obj_9pywrapfst__MutableFst *, struct __pyx_obj_9pywrapfst__SymbolTable *))__pyx_f_9pywrapfst_11_MutableFst__set_input_symbols;
  __pyx_vtable_9pywrapfst__MutableFst._set_output_symbols = (void (*)(struct __pyx_obj_9pywrapfst__MutableFst *, struct __pyx_obj_9pywrapfst__SymbolTable *))__pyx_f_9pywrapfst_11_MutableFst__set_output_symbols;
  __pyx_vtable_9pywrapfst__MutableFst._topsort = (void (*)(struct __pyx_obj_9pywrapfst__MutableFst *))__pyx_f_9pywrapfst_11_MutableFst__topsort;
  __pyx_vtable_9pywrapfst__MutableFst._union = (void (*)(struct __pyx_obj_9pywrapfst__MutableFst *, struct __pyx_obj_9pywrapfst__Fst *))__pyx_f_9pywrapfst_11_MutableFst__union;
  __pyx_type_9pywrapfst__MutableFst.tp_base = __pyx_ptype_9pywrapfst__Fst;
  if (PyType_Ready(&__pyx_type_9pywrapfst__MutableFst) < 0) __PYX_ERR(0, 1774, __pyx_L1_error)
  __pyx_type_9pywrapfst__MutableFst.tp_print = 0;
  if (__Pyx_SetVtable(__pyx_type_9pywrapfst__MutableFst.tp_dict, __pyx_vtabptr_9pywrapfst__MutableFst) < 0) __PYX_ERR(0, 1774, __pyx_L1_error)
  if (PyObject_SetAttrString(__pyx_m, "_MutableFst", (PyObject *)&__pyx_type_9pywrapfst__MutableFst) < 0) __PYX_ERR(0, 1774, __pyx_L1_error)
  __pyx_ptype_9pywrapfst__MutableFst = &__pyx_type_9pywrapfst__MutableFst;
  __pyx_vtabptr_9pywrapfst_Arc = &__pyx_vtable_9pywrapfst_Arc;
  __pyx_vtable_9pywrapfst_Arc.copy = (struct __pyx_obj_9pywrapfst_Arc *(*)(struct __pyx_obj_9pywrapfst_Arc *, int __pyx_skip_dispatch))__pyx_f_9pywrapfst_3Arc_copy;
  if (PyType_Ready(&__pyx_type_9pywrapfst_Arc) < 0) __PYX_ERR(0, 2898, __pyx_L1_error)
  __pyx_type_9pywrapfst_Arc.tp_print = 0;
  if (__Pyx_SetVtable(__pyx_type_9pywrapfst_Arc.tp_dict, __pyx_vtabptr_9pywrapfst_Arc) < 0) __PYX_ERR(0, 2898, __pyx_L1_error)
  if (PyObject_SetAttrString(__pyx_m, "Arc", (PyObject *)&__pyx_type_9pywrapfst_Arc) < 0) __PYX_ERR(0, 2898, __pyx_L1_error)
  if (__Pyx_setup_reduce((PyObject*)&__pyx_type_9pywrapfst_Arc) < 0) __PYX_ERR(0, 2898, __pyx_L1_error)
  __pyx_ptype_9pywrapfst_Arc = &__pyx_type_9pywrapfst_Arc;
  __pyx_vtabptr_9pywrapfst_ArcIterator = &__pyx_vtable_9pywrapfst_ArcIterator;
  __pyx_vtable_9pywrapfst_ArcIterator.done = (bool (*)(struct __pyx_obj_9pywrapfst_ArcIterator *, int __pyx_skip_dispatch))__pyx_f_9pywrapfst_11ArcIterator_done;
  __pyx_vtable_9pywrapfst_ArcIterator.flags = (__pyx_t_10basictypes_uint32 (*)(struct __pyx_obj_9pywrapfst_ArcIterator *, int __pyx_skip_dispatch))__pyx_f_9pywrapfst_11ArcIterator_flags;
  __pyx_vtable_9pywrapfst_ArcIterator.next = (void (*)(struct __pyx_obj_9pywrapfst_ArcIterator *, int __pyx_skip_dispatch))__pyx_f_9pywrapfst_11ArcIterator_next;
  __pyx_vtable_9pywrapfst_ArcIterator.position = (size_t (*)(struct __pyx_obj_9pywrapfst_ArcIterator *, int __pyx_skip_dispatch))__pyx_f_9pywrapfst_11ArcIterator_position;
  __pyx_vtable_9pywrapfst_ArcIterator.reset = (void (*)(struct __pyx_obj_9pywrapfst_ArcIterator *, int __pyx_skip_dispatch))__pyx_f_9pywrapfst_11ArcIterator_reset;
  __pyx_vtable_9pywrapfst_ArcIterator.seek = (void (*)(struct __pyx_obj_9pywrapfst_ArcIterator *, size_t, int __pyx_skip_dispatch))__pyx_f_9pywrapfst_11ArcIterator_seek;
  __pyx_vtable_9pywrapfst_ArcIterator.set_flags = (void (*)(struct __pyx_obj_9pywrapfst_ArcIterator *, __pyx_t_10basictypes_uint32, __pyx_t_10basictypes_uint32, int __pyx_skip_dispatch))__pyx_f_9pywrapfst_11ArcIterator_set_flags;
  __pyx_vtable_9pywrapfst_ArcIterator.value = (PyObject *(*)(struct __pyx_obj_9pywrapfst_ArcIterator *, int __pyx_skip_dispatch))__pyx_f_9pywrapfst_11ArcIterator_value;
  if (PyType_Ready(&__pyx_type_9pywrapfst_ArcIterator) < 0) __PYX_ERR(0, 2965, __pyx_L1_error)
  __pyx_type_9pywrapfst_ArcIterator.tp_print = 0;
  if (__Pyx_SetVtable(__pyx_type_9pywrapfst_ArcIterator.tp_dict, __pyx_vtabptr_9pywrapfst_ArcIterator) < 0) __PYX_ERR(0, 2965, __pyx_L1_error)
  if (PyObject_SetAttrString(__pyx_m, "ArcIterator", (PyObject *)&__pyx_type_9pywrapfst_ArcIterator) < 0) __PYX_ERR(0, 2965, __pyx_L1_error)
  if (__Pyx_setup_reduce((PyObject*)&__pyx_type_9pywrapfst_ArcIterator) < 0) __PYX_ERR(0, 2965, __pyx_L1_error)
  __pyx_ptype_9pywrapfst_ArcIterator = &__pyx_type_9pywrapfst_ArcIterator;
  __pyx_vtabptr_9pywrapfst_MutableArcIterator = &__pyx_vtable_9pywrapfst_MutableArcIterator;
  __pyx_vtable_9pywrapfst_MutableArcIterator.done = (bool (*)(struct __pyx_obj_9pywrapfst_MutableArcIterator *, int __pyx_skip_dispatch))__pyx_f_9pywrapfst_18MutableArcIterator_done;
  __pyx_vtable_9pywrapfst_MutableArcIterator.flags = (__pyx_t_10basictypes_uint32 (*)(struct __pyx_obj_9pywrapfst_MutableArcIterator *, int __pyx_skip_dispatch))__pyx_f_9pywrapfst_18MutableArcIterator_flags;
  __pyx_vtable_9pywrapfst_MutableArcIterator.next = (void (*)(struct __pyx_obj_9pywrapfst_MutableArcIterator *, int __pyx_skip_dispatch))__pyx_f_9pywrapfst_18MutableArcIterator_next;
  __pyx_vtable_9pywrapfst_MutableArcIterator.position = (size_t (*)(struct __pyx_obj_9pywrapfst_MutableArcIterator *, int __pyx_skip_dispatch))__pyx_f_9pywrapfst_18MutableArcIterator_position;
  __pyx_vtable_9pywrapfst_MutableArcIterator.reset = (void (*)(struct __pyx_obj_9pywrapfst_MutableArcIterator *, int __pyx_skip_dispatch))__pyx_f_9pywrapfst_18MutableArcIterator_reset;
  __pyx_vtable_9pywrapfst_MutableArcIterator.seek = (void (*)(struct __pyx_obj_9pywrapfst_MutableArcIterator *, size_t, int __pyx_skip_dispatch))__pyx_f_9pywrapfst_18MutableArcIterator_seek;
  __pyx_vtable_9pywrapfst_MutableArcIterator.set_flags = (void (*)(struct __pyx_obj_9pywrapfst_MutableArcIterator *, __pyx_t_10basictypes_uint32, __pyx_t_10basictypes_uint32, int __pyx_skip_dispatch))__pyx_f_9pywrapfst_18MutableArcIterator_set_flags;
  __pyx_vtable_9pywrapfst_MutableArcIterator.set_value = (void (*)(struct __pyx_obj_9pywrapfst_MutableArcIterator *, struct __pyx_obj_9pywrapfst_Arc *, int __pyx_skip_dispatch))__pyx_f_9pywrapfst_18MutableArcIterator_set_value;
  __pyx_vtable_9pywrapfst_MutableArcIterator.value = (PyObject *(*)(struct __pyx_obj_9pywrapfst_MutableArcIterator *, int __pyx_skip_dispatch))__pyx_f_9pywrapfst_18MutableArcIterator_value;
  if (PyType_Ready(&__pyx_type_9pywrapfst_MutableArcIterator) < 0) __PYX_ERR(0, 3076, __pyx_L1_error)
  __pyx_type_9pywrapfst_MutableArcIterator.tp_print = 0;
  if (__Pyx_SetVtable(__pyx_type_9pywrapfst_MutableArcIterator.tp_dict, __pyx_vtabptr_9pywrapfst_MutableArcIterator) < 0) __PYX_ERR(0, 3076, __pyx_L1_error)
  if (PyObject_SetAttrString(__pyx_m, "MutableArcIterator", (PyObject *)&__pyx_type_9pywrapfst_MutableArcIterator) < 0) __PYX_ERR(0, 3076, __pyx_L1_error)
  if (__Pyx_setup_reduce((PyObject*)&__pyx_type_9pywrapfst_MutableArcIterator) < 0) __PYX_ERR(0, 3076, __pyx_L1_error)
  __pyx_ptype_9pywrapfst_MutableArcIterator = &__pyx_type_9pywrapfst_MutableArcIterator;
  __pyx_vtabptr_9pywrapfst_StateIterator = &__pyx_vtable_9pywrapfst_StateIterator;
  __pyx_vtable_9pywrapfst_StateIterator.done = (bool (*)(struct __pyx_obj_9pywrapfst_StateIterator *, int __pyx_skip_dispatch))__pyx_f_9pywrapfst_13StateIterator_done;
  __pyx_vtable_9pywrapfst_StateIterator.next = (void (*)(struct __pyx_obj_9pywrapfst_StateIterator *, int __pyx_skip_dispatch))__pyx_f_9pywrapfst_13StateIterator_next;
  __pyx_vtable_9pywrapfst_StateIterator.reset = (void (*)(struct __pyx_obj_9pywrapfst_StateIterator *, int __pyx_skip_dispatch))__pyx_f_9pywrapfst_13StateIterator_reset;
  __pyx_vtable_9pywrapfst_StateIterator.value = (__pyx_t_10basictypes_int64 (*)(struct __pyx_obj_9pywrapfst_StateIterator *, int __pyx_skip_dispatch))__pyx_f_9pywrapfst_13StateIterator_value;
  if (PyType_Ready(&__pyx_type_9pywrapfst_StateIterator) < 0) __PYX_ERR(0, 3190, __pyx_L1_error)
  __pyx_type_9pywrapfst_StateIterator.tp_print = 0;
  if (__Pyx_SetVtable(__pyx_type_9pywrapfst_StateIterator.tp_dict, __pyx_vtabptr_9pywrapfst_StateIterator) < 0) __PYX_ERR(0, 3190, __pyx_L1_error)
  if (PyObject_SetAttrString(__pyx_m, "StateIterator", (PyObject *)&__pyx_type_9pywrapfst_StateIterator) < 0) __PYX_ERR(0, 3190, __pyx_L1_error)
  if (__Pyx_setup_reduce((PyObject*)&__pyx_type_9pywrapfst_StateIterator) < 0) __PYX_ERR(0, 3190, __pyx_L1_error)
  __pyx_ptype_9pywrapfst_StateIterator = &__pyx_type_9pywrapfst_StateIterator;
  __pyx_vtabptr_9pywrapfst_Compiler = &__pyx_vtable_9pywrapfst_Compiler;
  __pyx_vtable_9pywrapfst_Compiler.compile = (struct __pyx_obj_9pywrapfst__Fst *(*)(struct __pyx_obj_9pywrapfst_Compiler *, int __pyx_skip_dispatch))__pyx_f_9pywrapfst_8Compiler_compile;
  __pyx_vtable_9pywrapfst_Compiler.write = (void (*)(struct __pyx_obj_9pywrapfst_Compiler *, PyObject *, int __pyx_skip_dispatch))__pyx_f_9pywrapfst_8Compiler_write;
  if (PyType_Ready(&__pyx_type_9pywrapfst_Compiler) < 0) __PYX_ERR(0, 4088, __pyx_L1_error)
  __pyx_type_9pywrapfst_Compiler.tp_print = 0;
  if (__Pyx_SetVtable(__pyx_type_9pywrapfst_Compiler.tp_dict, __pyx_vtabptr_9pywrapfst_Compiler) < 0) __PYX_ERR(0, 4088, __pyx_L1_error)
  if (PyObject_SetAttrString(__pyx_m, "Compiler", (PyObject *)&__pyx_type_9pywrapfst_Compiler) < 0) __PYX_ERR(0, 4088, __pyx_L1_error)
  if (__Pyx_setup_reduce((PyObject*)&__pyx_type_9pywrapfst_Compiler) < 0) __PYX_ERR(0, 4088, __pyx_L1_error)
  __pyx_ptype_9pywrapfst_Compiler = &__pyx_type_9pywrapfst_Compiler;
  __pyx_vtabptr_9pywrapfst_FarReader = &__pyx_vtable_9pywrapfst_FarReader;
  __pyx_vtable_9pywrapfst_FarReader.arc_type = (std::string (*)(struct __pyx_obj_9pywrapfst_FarReader *, int __pyx_skip_dispatch))__pyx_f_9pywrapfst_9FarReader_arc_type;
  __pyx_vtable_9pywrapfst_FarReader.done = (bool (*)(struct __pyx_obj_9pywrapfst_FarReader *, int __pyx_skip_dispatch))__pyx_f_9pywrapfst_9FarReader_done;
  __pyx_vtable_9pywrapfst_FarReader.error = (bool (*)(struct __pyx_obj_9pywrapfst_FarReader *, int __pyx_skip_dispatch))__pyx_f_9pywrapfst_9FarReader_error;
  __pyx_vtable_9pywrapfst_FarReader.far_type = (std::string (*)(struct __pyx_obj_9pywrapfst_FarReader *, int __pyx_skip_dispatch))__pyx_f_9pywrapfst_9FarReader_far_type;
  __pyx_vtable_9pywrapfst_FarReader.find = (bool (*)(struct __pyx_obj_9pywrapfst_FarReader *, PyObject *, int __pyx_skip_dispatch))__pyx_f_9pywrapfst_9FarReader_find;
  __pyx_vtable_9pywrapfst_FarReader.get_fst = (struct __pyx_obj_9pywrapfst__Fst *(*)(struct __pyx_obj_9pywrapfst_FarReader *, int __pyx_skip_dispatch))__pyx_f_9pywrapfst_9FarReader_get_fst;
  __pyx_vtable_9pywrapfst_FarReader.get_key = (std::string (*)(struct __pyx_obj_9pywrapfst_FarReader *, int __pyx_skip_dispatch))__pyx_f_9pywrapfst_9FarReader_get_key;
  __pyx_vtable_9pywrapfst_FarReader.next = (void (*)(struct __pyx_obj_9pywrapfst_FarReader *, int __pyx_skip_dispatch))__pyx_f_9pywrapfst_9FarReader_next;
  __pyx_vtable_9pywrapfst_FarReader.reset = (void (*)(struct __pyx_obj_9pywrapfst_FarReader *, int __pyx_skip_dispatch))__pyx_f_9pywrapfst_9FarReader_reset;
  if (PyType_Ready(&__pyx_type_9pywrapfst_FarReader) < 0) __PYX_ERR(0, 4215, __pyx_L1_error)
  __pyx_type_9pywrapfst_FarReader.tp_print = 0;
  if (__Pyx_SetVtable(__pyx_type_9pywrapfst_FarReader.tp_dict, __pyx_vtabptr_9pywrapfst_FarReader) < 0) __PYX_ERR(0, 4215, __pyx_L1_error)
  if (PyObject_SetAttrString(__pyx_m, "FarReader", (PyObject *)&__pyx_type_9pywrapfst_FarReader) < 0) __PYX_ERR(0, 4215, __pyx_L1_error)
  if (__Pyx_setup_reduce((PyObject*)&__pyx_type_9pywrapfst_FarReader) < 0) __PYX_ERR(0, 4215, __pyx_L1_error)
  __pyx_ptype_9pywrapfst_FarReader = &__pyx_type_9pywrapfst_FarReader;
  __pyx_vtabptr_9pywrapfst_FarWriter = &__pyx_vtable_9pywrapfst_FarWriter;
  __pyx_vtable_9pywrapfst_FarWriter.arc_type = (std::string (*)(struct __pyx_obj_9pywrapfst_FarWriter *, int __pyx_skip_dispatch))__pyx_f_9pywrapfst_9FarWriter_arc_type;
  __pyx_vtable_9pywrapfst_FarWriter.close = (void (*)(struct __pyx_obj_9pywrapfst_FarWriter *))__pyx_f_9pywrapfst_9FarWriter_close;
  __pyx_vtable_9pywrapfst_FarWriter.add = (void (*)(struct __pyx_obj_9pywrapfst_FarWriter *, PyObject *, struct __pyx_obj_9pywrapfst__Fst *, int __pyx_skip_dispatch))__pyx_f_9pywrapfst_9FarWriter_add;
  __pyx_vtable_9pywrapfst_FarWriter.error = (bool (*)(struct __pyx_obj_9pywrapfst_FarWriter *, int __pyx_skip_dispatch))__pyx_f_9pywrapfst_9FarWriter_error;
  __pyx_vtable_9pywrapfst_FarWriter.far_type = (std::string (*)(struct __pyx_obj_9pywrapfst_FarWriter *, int __pyx_skip_dispatch))__pyx_f_9pywrapfst_9FarWriter_far_type;
  if (PyType_Ready(&__pyx_type_9pywrapfst_FarWriter) < 0) __PYX_ERR(0, 4360, __pyx_L1_error)
  __pyx_type_9pywrapfst_FarWriter.tp_print = 0;
  if (__Pyx_SetVtable(__pyx_type_9pywrapfst_FarWriter.tp_dict, __pyx_vtabptr_9pywrapfst_FarWriter) < 0) __PYX_ERR(0, 4360, __pyx_L1_error)
  if (PyObject_SetAttrString(__pyx_m, "FarWriter", (PyObject *)&__pyx_type_9pywrapfst_FarWriter) < 0) __PYX_ERR(0, 4360, __pyx_L1_error)
  if (__Pyx_setup_reduce((PyObject*)&__pyx_type_9pywrapfst_FarWriter) < 0) __PYX_ERR(0, 4360, __pyx_L1_error)
  __pyx_ptype_9pywrapfst_FarWriter = &__pyx_type_9pywrapfst_FarWriter;
  /*--- Type import code ---*/
  /*--- Variable import code ---*/
  /*--- Function import code ---*/
  /*--- Execution code ---*/
  #if defined(__Pyx_Generator_USED) || defined(__Pyx_Coroutine_USED)
  if (__Pyx_patch_abc() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  #endif

  /* "pywrapfst.pyx":107
 * 
 * # Python imports.
 * import atexit             # <<<<<<<<<<<<<<
 * import numbers
 * import subprocess
 */
  __pyx_t_1 = __Pyx_Import(__pyx_n_s_atexit, 0, -1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 107, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_atexit, __pyx_t_1) < 0) __PYX_ERR(0, 107, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pywrapfst.pyx":108
 * # Python imports.
 * import atexit
 * import numbers             # <<<<<<<<<<<<<<
 * import subprocess
 * import logging
 */
  __pyx_t_1 = __Pyx_Import(__pyx_n_s_numbers, 0, -1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 108, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_numbers, __pyx_t_1) < 0) __PYX_ERR(0, 108, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pywrapfst.pyx":109
 * import atexit
 * import numbers
 * import subprocess             # <<<<<<<<<<<<<<
 * import logging
 * 
 */
  __pyx_t_1 = __Pyx_Import(__pyx_n_s_subprocess, 0, -1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 109, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_subprocess, __pyx_t_1) < 0) __PYX_ERR(0, 109, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pywrapfst.pyx":110
 * import numbers
 * import subprocess
 * import logging             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __pyx_t_1 = __Pyx_Import(__pyx_n_s_logging, 0, -1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 110, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_logging, __pyx_t_1) < 0) __PYX_ERR(0, 110, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pywrapfst.pyx":115
 * # TODO(kbg): Figure out how to access static class variables so I don't have
 * # to do it this way.
 * kNoSymbol = -1             # <<<<<<<<<<<<<<
 * 
 * 
 */
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_kNoSymbol, __pyx_int_neg_1) < 0) __PYX_ERR(0, 115, __pyx_L1_error)

  /* "pywrapfst.pyx":121
 * 
 * 
 * class FstError(Exception):             # <<<<<<<<<<<<<<
 * 
 *   pass
 */
  __pyx_t_1 = PyTuple_New(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 121, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_INCREF(((PyObject *)(&((PyTypeObject*)PyExc_Exception)[0])));
  __Pyx_GIVEREF(((PyObject *)(&((PyTypeObject*)PyExc_Exception)[0])));
  PyTuple_SET_ITEM(__pyx_t_1, 0, ((PyObject *)(&((PyTypeObject*)PyExc_Exception)[0])));
  __pyx_t_2 = __Pyx_CalculateMetaclass(NULL, __pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 121, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = __Pyx_Py3MetaclassPrepare(__pyx_t_2, __pyx_t_1, __pyx_n_s_FstError, __pyx_n_s_FstError, (PyObject *) NULL, __pyx_n_s_pywrapfst_2, (PyObject *) NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 121, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_4 = __Pyx_Py3ClassCreate(__pyx_t_2, __pyx_n_s_FstError, __pyx_t_1, __pyx_t_3, NULL, 0, 1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 121, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_FstError, __pyx_t_4) < 0) __PYX_ERR(0, 121, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pywrapfst.pyx":126
 * 
 * 
 * class FstArgError(FstError, ValueError):             # <<<<<<<<<<<<<<
 * 
 *   pass
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_FstError); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 126, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyTuple_New(2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 126, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_GIVEREF(__pyx_t_1);
  PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_t_1);
  __Pyx_INCREF(__pyx_builtin_ValueError);
  __Pyx_GIVEREF(__pyx_builtin_ValueError);
  PyTuple_SET_ITEM(__pyx_t_2, 1, __pyx_builtin_ValueError);
  __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_CalculateMetaclass(NULL, __pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 126, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_3 = __Pyx_Py3MetaclassPrepare(__pyx_t_1, __pyx_t_2, __pyx_n_s_FstArgError, __pyx_n_s_FstArgError, (PyObject *) NULL, __pyx_n_s_pywrapfst_2, (PyObject *) NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 126, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_4 = __Pyx_Py3ClassCreate(__pyx_t_1, __pyx_n_s_FstArgError, __pyx_t_2, __pyx_t_3, NULL, 0, 1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 126, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_FstArgError, __pyx_t_4) < 0) __PYX_ERR(0, 126, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "pywrapfst.pyx":131
 * 
 * 
 * class FstBadWeightError(FstError, ValueError):             # <<<<<<<<<<<<<<
 * 
 *   pass
 */
  __pyx_t_2 = __Pyx_GetModuleGlobalName(__pyx_n_s_FstError); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 131, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_1 = PyTuple_New(2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 131, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_GIVEREF(__pyx_t_2);
  PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_t_2);
  __Pyx_INCREF(__pyx_builtin_ValueError);
  __Pyx_GIVEREF(__pyx_builtin_ValueError);
  PyTuple_SET_ITEM(__pyx_t_1, 1, __pyx_builtin_ValueError);
  __pyx_t_2 = 0;
  __pyx_t_2 = __Pyx_CalculateMetaclass(NULL, __pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 131, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = __Pyx_Py3MetaclassPrepare(__pyx_t_2, __pyx_t_1, __pyx_n_s_FstBadWeightError, __pyx_n_s_FstBadWeightError, (PyObject *) NULL, __pyx_n_s_pywrapfst_2, (PyObject *) NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 131, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_4 = __Pyx_Py3ClassCreate(__pyx_t_2, __pyx_n_s_FstBadWeightError, __pyx_t_1, __pyx_t_3, NULL, 0, 1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 131, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_FstBadWeightError, __pyx_t_4) < 0) __PYX_ERR(0, 131, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pywrapfst.pyx":136
 * 
 * 
 * class FstDeletedConstructorError(FstError, RuntimeError):             # <<<<<<<<<<<<<<
 * 
 *   pass
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_FstError); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 136, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyTuple_New(2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 136, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_GIVEREF(__pyx_t_1);
  PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_t_1);
  __Pyx_INCREF(__pyx_builtin_RuntimeError);
  __Pyx_GIVEREF(__pyx_builtin_RuntimeError);
  PyTuple_SET_ITEM(__pyx_t_2, 1, __pyx_builtin_RuntimeError);
  __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_CalculateMetaclass(NULL, __pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 136, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_3 = __Pyx_Py3MetaclassPrepare(__pyx_t_1, __pyx_t_2, __pyx_n_s_FstDeletedConstructorError, __pyx_n_s_FstDeletedConstructorError, (PyObject *) NULL, __pyx_n_s_pywrapfst_2, (PyObject *) NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 136, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_4 = __Pyx_Py3ClassCreate(__pyx_t_1, __pyx_n_s_FstDeletedConstructorError, __pyx_t_2, __pyx_t_3, NULL, 0, 1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 136, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_FstDeletedConstructorError, __pyx_t_4) < 0) __PYX_ERR(0, 136, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "pywrapfst.pyx":141
 * 
 * 
 * class FstIndexError(FstError, IndexError):             # <<<<<<<<<<<<<<
 * 
 *   pass
 */
  __pyx_t_2 = __Pyx_GetModuleGlobalName(__pyx_n_s_FstError); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 141, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_1 = PyTuple_New(2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 141, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_GIVEREF(__pyx_t_2);
  PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_t_2);
  __Pyx_INCREF(__pyx_builtin_IndexError);
  __Pyx_GIVEREF(__pyx_builtin_IndexError);
  PyTuple_SET_ITEM(__pyx_t_1, 1, __pyx_builtin_IndexError);
  __pyx_t_2 = 0;
  __pyx_t_2 = __Pyx_CalculateMetaclass(NULL, __pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 141, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = __Pyx_Py3MetaclassPrepare(__pyx_t_2, __pyx_t_1, __pyx_n_s_FstIndexError, __pyx_n_s_FstIndexError, (PyObject *) NULL, __pyx_n_s_pywrapfst_2, (PyObject *) NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 141, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_4 = __Pyx_Py3ClassCreate(__pyx_t_2, __pyx_n_s_FstIndexError, __pyx_t_1, __pyx_t_3, NULL, 0, 1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 141, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_FstIndexError, __pyx_t_4) < 0) __PYX_ERR(0, 141, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pywrapfst.pyx":146
 * 
 * 
 * class FstIOError(FstError, IOError):             # <<<<<<<<<<<<<<
 * 
 *   pass
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_FstError); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 146, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyTuple_New(2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 146, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_GIVEREF(__pyx_t_1);
  PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_t_1);
  __Pyx_INCREF(__pyx_builtin_IOError);
  __Pyx_GIVEREF(__pyx_builtin_IOError);
  PyTuple_SET_ITEM(__pyx_t_2, 1, __pyx_builtin_IOError);
  __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_CalculateMetaclass(NULL, __pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 146, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_3 = __Pyx_Py3MetaclassPrepare(__pyx_t_1, __pyx_t_2, __pyx_n_s_FstIOError, __pyx_n_s_FstIOError, (PyObject *) NULL, __pyx_n_s_pywrapfst_2, (PyObject *) NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 146, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_4 = __Pyx_Py3ClassCreate(__pyx_t_1, __pyx_n_s_FstIOError, __pyx_t_2, __pyx_t_3, NULL, 0, 1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 146, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_FstIOError, __pyx_t_4) < 0) __PYX_ERR(0, 146, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "pywrapfst.pyx":151
 * 
 * 
 * class FstOpError(FstError, RuntimeError):             # <<<<<<<<<<<<<<
 * 
 *   pass
 */
  __pyx_t_2 = __Pyx_GetModuleGlobalName(__pyx_n_s_FstError); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 151, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_1 = PyTuple_New(2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 151, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_GIVEREF(__pyx_t_2);
  PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_t_2);
  __Pyx_INCREF(__pyx_builtin_RuntimeError);
  __Pyx_GIVEREF(__pyx_builtin_RuntimeError);
  PyTuple_SET_ITEM(__pyx_t_1, 1, __pyx_builtin_RuntimeError);
  __pyx_t_2 = 0;
  __pyx_t_2 = __Pyx_CalculateMetaclass(NULL, __pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 151, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = __Pyx_Py3MetaclassPrepare(__pyx_t_2, __pyx_t_1, __pyx_n_s_FstOpError, __pyx_n_s_FstOpError, (PyObject *) NULL, __pyx_n_s_pywrapfst_2, (PyObject *) NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 151, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_4 = __Pyx_Py3ClassCreate(__pyx_t_2, __pyx_n_s_FstOpError, __pyx_t_1, __pyx_t_3, NULL, 0, 1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 151, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_FstOpError, __pyx_t_4) < 0) __PYX_ERR(0, 151, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pywrapfst.pyx":406
 * 
 *   @classmethod
 *   def Zero(cls, weight_type):             # <<<<<<<<<<<<<<
 *     """
 *     Weight.Zero(weight_type)
 */
  __pyx_t_1 = __Pyx_GetNameInClass((PyObject *)__pyx_ptype_9pywrapfst_Weight, __pyx_n_s_Zero); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 406, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);

  /* "pywrapfst.pyx":405
 *   # C++ part out-of-class and then call it from within.
 * 
 *   @classmethod             # <<<<<<<<<<<<<<
 *   def Zero(cls, weight_type):
 *     """
 */
  __pyx_t_2 = __Pyx_Method_ClassMethod(__pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 405, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  if (PyDict_SetItem((PyObject *)__pyx_ptype_9pywrapfst_Weight->tp_dict, __pyx_n_s_Zero, __pyx_t_2) < 0) __PYX_ERR(0, 406, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  PyType_Modified(__pyx_ptype_9pywrapfst_Weight);

  /* "pywrapfst.pyx":415
 * 
 *   @classmethod
 *   def One(cls, weight_type):             # <<<<<<<<<<<<<<
 *     """
 *     Weight.One(weight_type)
 */
  __pyx_t_2 = __Pyx_GetNameInClass((PyObject *)__pyx_ptype_9pywrapfst_Weight, __pyx_n_s_One); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 415, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);

  /* "pywrapfst.pyx":414
 *     return _Zero(weight_type)
 * 
 *   @classmethod             # <<<<<<<<<<<<<<
 *   def One(cls, weight_type):
 *     """
 */
  __pyx_t_1 = __Pyx_Method_ClassMethod(__pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 414, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  if (PyDict_SetItem((PyObject *)__pyx_ptype_9pywrapfst_Weight->tp_dict, __pyx_n_s_One, __pyx_t_1) < 0) __PYX_ERR(0, 415, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  PyType_Modified(__pyx_ptype_9pywrapfst_Weight);

  /* "pywrapfst.pyx":424
 * 
 *   @classmethod
 *   def NoWeight(cls, weight_type):             # <<<<<<<<<<<<<<
 *     """
 *     Weight.NoWeight(weight_type)
 */
  __pyx_t_1 = __Pyx_GetNameInClass((PyObject *)__pyx_ptype_9pywrapfst_Weight, __pyx_n_s_NoWeight); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 424, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);

  /* "pywrapfst.pyx":423
 *     return _One(weight_type)
 * 
 *   @classmethod             # <<<<<<<<<<<<<<
 *   def NoWeight(cls, weight_type):
 *     """
 */
  __pyx_t_2 = __Pyx_Method_ClassMethod(__pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 423, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  if (PyDict_SetItem((PyObject *)__pyx_ptype_9pywrapfst_Weight->tp_dict, __pyx_n_s_NoWeight, __pyx_t_2) < 0) __PYX_ERR(0, 424, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  PyType_Modified(__pyx_ptype_9pywrapfst_Weight);

  /* "pywrapfst.pyx":456
 * 
 * 
 * def plus(Weight lhs, Weight rhs):             # <<<<<<<<<<<<<<
 *   """
 *   plus(lhs, rhs)
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_9pywrapfst_1plus, NULL, __pyx_n_s_pywrapfst_2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 456, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_plus, __pyx_t_2) < 0) __PYX_ERR(0, 456, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "pywrapfst.pyx":488
 * 
 * 
 * def times(Weight lhs, Weight rhs):             # <<<<<<<<<<<<<<
 *   """
 *   times(lhs, rhs)
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_9pywrapfst_3times, NULL, __pyx_n_s_pywrapfst_2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 488, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_times, __pyx_t_2) < 0) __PYX_ERR(0, 488, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "pywrapfst.pyx":520
 * 
 * 
 * def divide(Weight lhs, Weight rhs):             # <<<<<<<<<<<<<<
 *   """
 *   divide(lhs, rhs)
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_9pywrapfst_5divide, NULL, __pyx_n_s_pywrapfst_2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 520, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_divide, __pyx_t_2) < 0) __PYX_ERR(0, 520, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "pywrapfst.pyx":553
 * 
 * 
 * def power(Weight w, size_t n):             # <<<<<<<<<<<<<<
 *   """
 *   power(lhs, rhs)
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_9pywrapfst_7power, NULL, __pyx_n_s_pywrapfst_2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 553, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_power, __pyx_t_2) < 0) __PYX_ERR(0, 553, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "pywrapfst.pyx":889
 *   """
 * 
 *   cpdef int64 add_symbol(self, symbol, int64 key=kNoSymbol):             # <<<<<<<<<<<<<<
 *     """
 *     add_symbol(self, symbol, key=NO_SYMBOL)
 */
  __pyx_t_2 = __Pyx_GetModuleGlobalName(__pyx_n_s_kNoSymbol); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 889, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_5 = __Pyx_PyInt_As_int64_t(__pyx_t_2); if (unlikely((__pyx_t_5 == ((int64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 889, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_k__13 = __pyx_t_5;
  __pyx_t_2 = __Pyx_GetModuleGlobalName(__pyx_n_s_kNoSymbol); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 889, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_5 = __Pyx_PyInt_As_int64_t(__pyx_t_2); if (unlikely((__pyx_t_5 == ((int64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 889, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_k__13 = __pyx_t_5;

  /* "pywrapfst.pyx":966
 * 
 *   @classmethod
 *   def read(cls, filename):             # <<<<<<<<<<<<<<
 *     """
 *     SymbolTable.read(filename)
 */
  __pyx_t_2 = __Pyx_GetNameInClass((PyObject *)__pyx_ptype_9pywrapfst_SymbolTable, __pyx_n_s_read); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 966, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);

  /* "pywrapfst.pyx":965
 *     self._smart_table.reset(self._table)
 * 
 *   @classmethod             # <<<<<<<<<<<<<<
 *   def read(cls, filename):
 *     """
 */
  __pyx_t_1 = __Pyx_Method_ClassMethod(__pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 965, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  if (PyDict_SetItem((PyObject *)__pyx_ptype_9pywrapfst_SymbolTable->tp_dict, __pyx_n_s_read, __pyx_t_1) < 0) __PYX_ERR(0, 966, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  PyType_Modified(__pyx_ptype_9pywrapfst_SymbolTable);

  /* "pywrapfst.pyx":988
 * 
 *   @classmethod
 *   def read_text(cls, filename, bool allow_negative_labels=False):             # <<<<<<<<<<<<<<
 *     """
 *     SymbolTable.read_text(filename)
 */
  __pyx_t_1 = __Pyx_GetNameInClass((PyObject *)__pyx_ptype_9pywrapfst_SymbolTable, __pyx_n_s_read_text); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 988, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);

  /* "pywrapfst.pyx":987
 *     return _init_SymbolTable(tsyms)
 * 
 *   @classmethod             # <<<<<<<<<<<<<<
 *   def read_text(cls, filename, bool allow_negative_labels=False):
 *     """
 */
  __pyx_t_2 = __Pyx_Method_ClassMethod(__pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 987, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  if (PyDict_SetItem((PyObject *)__pyx_ptype_9pywrapfst_SymbolTable->tp_dict, __pyx_n_s_read_text, __pyx_t_2) < 0) __PYX_ERR(0, 988, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  PyType_Modified(__pyx_ptype_9pywrapfst_SymbolTable);

  /* "pywrapfst.pyx":1015
 * 
 *   @classmethod
 *   def read_fst(cls, filename, bool input_table):             # <<<<<<<<<<<<<<
 *     """
 *     SymbolTable.read_fst(filename, input_table)
 */
  __pyx_t_2 = __Pyx_GetNameInClass((PyObject *)__pyx_ptype_9pywrapfst_SymbolTable, __pyx_n_s_read_fst); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1015, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);

  /* "pywrapfst.pyx":1014
 *     return _init_SymbolTable(tsyms)
 * 
 *   @classmethod             # <<<<<<<<<<<<<<
 *   def read_fst(cls, filename, bool input_table):
 *     """
 */
  __pyx_t_1 = __Pyx_Method_ClassMethod(__pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1014, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  if (PyDict_SetItem((PyObject *)__pyx_ptype_9pywrapfst_SymbolTable->tp_dict, __pyx_n_s_read_fst, __pyx_t_1) < 0) __PYX_ERR(0, 1015, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  PyType_Modified(__pyx_ptype_9pywrapfst_SymbolTable);

  /* "pywrapfst.pyx":2064
 *     return self
 * 
 *   cdef void _minimize(self, float delta=fst.kShortestDelta,             # <<<<<<<<<<<<<<
 *                       bool allow_nondet=False) except *:
 *     # This runs in-place when the second argument is null.
 */
  __pyx_k__35 = fst::kShortestDelta;

  /* "pywrapfst.pyx":2070
 *     self._check_mutating_imethod()
 * 
 *   def minimize(self, float delta=fst.kShortestDelta, bool allow_nondet=False):             # <<<<<<<<<<<<<<
 *     """
 *     minimize(self, delta=1e-6, allow_nondet=False)
 */
  __pyx_k__36 = fst::kShortestDelta;

  /* "pywrapfst.pyx":2170
 *     return self
 * 
 *   cdef void _prune(self, float delta=fst.kDelta, int64 nstate=fst.kNoStateId,             # <<<<<<<<<<<<<<
 *                    weight=None) except *:
 *     # Threshold is set to semiring Zero (no pruning) if no weight is specified.
 */
  __pyx_k__37 = fst::kDelta;
  __pyx_k__38 = fst::kNoStateId;

  /* "pywrapfst.pyx":2179
 * 
 *   def prune(self,
 *             float delta=fst.kDelta,             # <<<<<<<<<<<<<<
 *             int64 nstate=fst.kNoStateId,
 *             weight=None):
 */
  __pyx_k__39 = fst::kDelta;

  /* "pywrapfst.pyx":2180
 *   def prune(self,
 *             float delta=fst.kDelta,
 *             int64 nstate=fst.kNoStateId,             # <<<<<<<<<<<<<<
 *             weight=None):
 *     """
 */
  __pyx_k__40 = fst::kNoStateId;

  /* "pywrapfst.pyx":2207
 * 
 *   cdef void _push(self,
 *                   float delta=fst.kDelta,             # <<<<<<<<<<<<<<
 *                   bool remove_total_weight=False,
 *                   bool to_final=False) except *:
 */
  __pyx_k__41 = fst::kDelta;

  /* "pywrapfst.pyx":2215
 * 
 *   def push(self,
 *            float delta=fst.kDelta,             # <<<<<<<<<<<<<<
 *            bool remove_total_weight=False,
 *            bool to_final=False):
 */
  __pyx_k__42 = fst::kDelta;

  /* "pywrapfst.pyx":2452
 *                        bool connect=True,
 *                        weight=None,
 *                        int64 nstate=fst.kNoStateId,             # <<<<<<<<<<<<<<
 *                        float delta=fst.kShortestDelta) except *:
 *     cdef fst.WeightClass wc = _get_WeightClass_or_Zero(self.weight_type(),
 */
  __pyx_k__46 = fst::kNoStateId;

  /* "pywrapfst.pyx":2453
 *                        weight=None,
 *                        int64 nstate=fst.kNoStateId,
 *                        float delta=fst.kShortestDelta) except *:             # <<<<<<<<<<<<<<
 *     cdef fst.WeightClass wc = _get_WeightClass_or_Zero(self.weight_type(),
 *                                                        weight)
 */
  __pyx_k__47 = fst::kShortestDelta;

  /* "pywrapfst.pyx":2466
 *                 bool connect=True,
 *                 weight=None,
 *                 int64 nstate=fst.kNoStateId,             # <<<<<<<<<<<<<<
 *                 float delta=fst.kShortestDelta):
 *     """
 */
  __pyx_k__48 = fst::kNoStateId;

  /* "pywrapfst.pyx":2467
 *                 weight=None,
 *                 int64 nstate=fst.kNoStateId,
 *                 float delta=fst.kShortestDelta):             # <<<<<<<<<<<<<<
 *     """
 *     rmepsilon(self, queue_type="auto", connect=True, weight=None,
 */
  __pyx_k__49 = fst::kShortestDelta;

  /* "pywrapfst.pyx":2742
 * 
 * 
 * class Fst(object):             # <<<<<<<<<<<<<<
 * 
 *    """
 */
  __pyx_t_1 = __Pyx_CalculateMetaclass(NULL, __pyx_tuple__107); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2742, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = __Pyx_Py3MetaclassPrepare(__pyx_t_1, __pyx_tuple__107, __pyx_n_s_Fst, __pyx_n_s_Fst, (PyObject *) NULL, __pyx_n_s_pywrapfst_2, __pyx_kp_s_Fst_arc_type_standard_Construct); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 2742, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);

  /* "pywrapfst.pyx":2759
 *    """
 * 
 *    def __new__(cls, arc_type=b"standard"):             # <<<<<<<<<<<<<<
 *     return _create_Fst(arc_type)
 * 
 */
  __pyx_t_3 = __Pyx_CyFunction_NewEx(&__pyx_mdef_9pywrapfst_3Fst_1__new__, __Pyx_CYFUNCTION_STATICMETHOD, __pyx_n_s_Fst___new, NULL, __pyx_n_s_pywrapfst_2, __pyx_d, ((PyObject *)__pyx_codeobj__109)); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 2759, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_CyFunction_SetDefaultsTuple(__pyx_t_3, __pyx_tuple__110);
  if (PyObject_SetItem(__pyx_t_2, __pyx_n_s_new, __pyx_t_3) < 0) __PYX_ERR(0, 2759, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "pywrapfst.pyx":2763
 * 
 *    @staticmethod
 *    def read(filename):             # <<<<<<<<<<<<<<
 *      """
 *      read(filename):
 */
  __pyx_t_3 = __Pyx_CyFunction_NewEx(&__pyx_mdef_9pywrapfst_3Fst_3read, __Pyx_CYFUNCTION_STATICMETHOD, __pyx_n_s_Fst_read, NULL, __pyx_n_s_pywrapfst_2, __pyx_d, ((PyObject *)__pyx_codeobj__112)); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 2763, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);

  /* "pywrapfst.pyx":2762
 *     return _create_Fst(arc_type)
 * 
 *    @staticmethod             # <<<<<<<<<<<<<<
 *    def read(filename):
 *      """
 */
  __pyx_t_4 = PyTuple_New(1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2762, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_GIVEREF(__pyx_t_3);
  PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_t_3);
  __pyx_t_3 = 0;
  __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_staticmethod, __pyx_t_4, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 2762, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  if (PyObject_SetItem(__pyx_t_2, __pyx_n_s_read, __pyx_t_3) < 0) __PYX_ERR(0, 2763, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "pywrapfst.pyx":2781
 * 
 *    @staticmethod
 *    def read_from_string(state):             # <<<<<<<<<<<<<<
 *      """
 *      read_from_string(string, fst_type=None)
 */
  __pyx_t_3 = __Pyx_CyFunction_NewEx(&__pyx_mdef_9pywrapfst_3Fst_5read_from_string, __Pyx_CYFUNCTION_STATICMETHOD, __pyx_n_s_Fst_read_from_string, NULL, __pyx_n_s_pywrapfst_2, __pyx_d, ((PyObject *)__pyx_codeobj__114)); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 2781, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);

  /* "pywrapfst.pyx":2780
 *      return _read(filename)
 * 
 *    @staticmethod             # <<<<<<<<<<<<<<
 *    def read_from_string(state):
 *      """
 */
  __pyx_t_4 = PyTuple_New(1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2780, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_GIVEREF(__pyx_t_3);
  PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_t_3);
  __pyx_t_3 = 0;
  __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_staticmethod, __pyx_t_4, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 2780, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  if (PyObject_SetItem(__pyx_t_2, __pyx_n_s_read_from_string_2, __pyx_t_3) < 0) __PYX_ERR(0, 2781, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "pywrapfst.pyx":2742
 * 
 * 
 * class Fst(object):             # <<<<<<<<<<<<<<
 * 
 *    """
 */
  __pyx_t_3 = __Pyx_Py3ClassCreate(__pyx_t_1, __pyx_n_s_Fst, __pyx_tuple__107, __pyx_t_2, NULL, 0, 1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 2742, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_Fst, __pyx_t_3) < 0) __PYX_ERR(0, 2742, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pywrapfst.pyx":2805
 * 
 * 
 * NO_LABEL = fst.kNoLabel             # <<<<<<<<<<<<<<
 * NO_STATE_ID = fst.kNoStateId
 * # TODO(kbg): Figure out how to access static class variables so I don't have
 */
  __pyx_t_1 = __Pyx_PyInt_From_int(fst::kNoLabel); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2805, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_NO_LABEL, __pyx_t_1) < 0) __PYX_ERR(0, 2805, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pywrapfst.pyx":2806
 * 
 * NO_LABEL = fst.kNoLabel
 * NO_STATE_ID = fst.kNoStateId             # <<<<<<<<<<<<<<
 * # TODO(kbg): Figure out how to access static class variables so I don't have
 * # to do it this way.
 */
  __pyx_t_1 = __Pyx_PyInt_From_int(fst::kNoStateId); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2806, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_NO_STATE_ID, __pyx_t_1) < 0) __PYX_ERR(0, 2806, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pywrapfst.pyx":2809
 * # TODO(kbg): Figure out how to access static class variables so I don't have
 * # to do it this way.
 * NO_SYMBOL = kNoSymbol             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_kNoSymbol); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2809, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_NO_SYMBOL, __pyx_t_1) < 0) __PYX_ERR(0, 2809, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pywrapfst.pyx":2815
 * 
 * 
 * EXPANDED = fst.kExpanded             # <<<<<<<<<<<<<<
 * MUTABLE = fst.kMutable
 * ERROR = fst.kError
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint64_t(fst::kExpanded); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2815, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_EXPANDED, __pyx_t_1) < 0) __PYX_ERR(0, 2815, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pywrapfst.pyx":2816
 * 
 * EXPANDED = fst.kExpanded
 * MUTABLE = fst.kMutable             # <<<<<<<<<<<<<<
 * ERROR = fst.kError
 * ACCEPTOR = fst.kAcceptor
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint64_t(fst::kMutable); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2816, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_MUTABLE, __pyx_t_1) < 0) __PYX_ERR(0, 2816, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pywrapfst.pyx":2817
 * EXPANDED = fst.kExpanded
 * MUTABLE = fst.kMutable
 * ERROR = fst.kError             # <<<<<<<<<<<<<<
 * ACCEPTOR = fst.kAcceptor
 * NOT_ACCEPTOR = fst.kNotAcceptor
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint64_t(fst::kError); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2817, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_ERROR, __pyx_t_1) < 0) __PYX_ERR(0, 2817, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pywrapfst.pyx":2818
 * MUTABLE = fst.kMutable
 * ERROR = fst.kError
 * ACCEPTOR = fst.kAcceptor             # <<<<<<<<<<<<<<
 * NOT_ACCEPTOR = fst.kNotAcceptor
 * I_DETERMINISTIC = fst.kIDeterministic
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint64_t(fst::kAcceptor); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2818, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_ACCEPTOR, __pyx_t_1) < 0) __PYX_ERR(0, 2818, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pywrapfst.pyx":2819
 * ERROR = fst.kError
 * ACCEPTOR = fst.kAcceptor
 * NOT_ACCEPTOR = fst.kNotAcceptor             # <<<<<<<<<<<<<<
 * I_DETERMINISTIC = fst.kIDeterministic
 * NON_I_DETERMINISTIC = fst.kNonIDeterministic
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint64_t(fst::kNotAcceptor); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2819, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_NOT_ACCEPTOR, __pyx_t_1) < 0) __PYX_ERR(0, 2819, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pywrapfst.pyx":2820
 * ACCEPTOR = fst.kAcceptor
 * NOT_ACCEPTOR = fst.kNotAcceptor
 * I_DETERMINISTIC = fst.kIDeterministic             # <<<<<<<<<<<<<<
 * NON_I_DETERMINISTIC = fst.kNonIDeterministic
 * O_DETERMINISTIC = fst.kODeterministic
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint64_t(fst::kIDeterministic); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2820, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_I_DETERMINISTIC, __pyx_t_1) < 0) __PYX_ERR(0, 2820, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pywrapfst.pyx":2821
 * NOT_ACCEPTOR = fst.kNotAcceptor
 * I_DETERMINISTIC = fst.kIDeterministic
 * NON_I_DETERMINISTIC = fst.kNonIDeterministic             # <<<<<<<<<<<<<<
 * O_DETERMINISTIC = fst.kODeterministic
 * NON_O_DETERMINISTIC = fst.kNonODeterministic
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint64_t(fst::kNonIDeterministic); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2821, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_NON_I_DETERMINISTIC, __pyx_t_1) < 0) __PYX_ERR(0, 2821, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pywrapfst.pyx":2822
 * I_DETERMINISTIC = fst.kIDeterministic
 * NON_I_DETERMINISTIC = fst.kNonIDeterministic
 * O_DETERMINISTIC = fst.kODeterministic             # <<<<<<<<<<<<<<
 * NON_O_DETERMINISTIC = fst.kNonODeterministic
 * EPSILONS = fst.kEpsilons
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint64_t(fst::kODeterministic); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2822, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_O_DETERMINISTIC, __pyx_t_1) < 0) __PYX_ERR(0, 2822, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pywrapfst.pyx":2823
 * NON_I_DETERMINISTIC = fst.kNonIDeterministic
 * O_DETERMINISTIC = fst.kODeterministic
 * NON_O_DETERMINISTIC = fst.kNonODeterministic             # <<<<<<<<<<<<<<
 * EPSILONS = fst.kEpsilons
 * NO_EPSILONS = fst.kNoEpsilons
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint64_t(fst::kNonODeterministic); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2823, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_NON_O_DETERMINISTIC, __pyx_t_1) < 0) __PYX_ERR(0, 2823, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pywrapfst.pyx":2824
 * O_DETERMINISTIC = fst.kODeterministic
 * NON_O_DETERMINISTIC = fst.kNonODeterministic
 * EPSILONS = fst.kEpsilons             # <<<<<<<<<<<<<<
 * NO_EPSILONS = fst.kNoEpsilons
 * I_EPSILONS = fst.kIEpsilons
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint64_t(fst::kEpsilons); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2824, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_EPSILONS, __pyx_t_1) < 0) __PYX_ERR(0, 2824, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pywrapfst.pyx":2825
 * NON_O_DETERMINISTIC = fst.kNonODeterministic
 * EPSILONS = fst.kEpsilons
 * NO_EPSILONS = fst.kNoEpsilons             # <<<<<<<<<<<<<<
 * I_EPSILONS = fst.kIEpsilons
 * NO_I_EPSILONS = fst.kNoIEpsilons
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint64_t(fst::kNoEpsilons); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2825, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_NO_EPSILONS, __pyx_t_1) < 0) __PYX_ERR(0, 2825, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pywrapfst.pyx":2826
 * EPSILONS = fst.kEpsilons
 * NO_EPSILONS = fst.kNoEpsilons
 * I_EPSILONS = fst.kIEpsilons             # <<<<<<<<<<<<<<
 * NO_I_EPSILONS = fst.kNoIEpsilons
 * O_EPSILONS = fst.kOEpsilons
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint64_t(fst::kIEpsilons); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2826, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_I_EPSILONS, __pyx_t_1) < 0) __PYX_ERR(0, 2826, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pywrapfst.pyx":2827
 * NO_EPSILONS = fst.kNoEpsilons
 * I_EPSILONS = fst.kIEpsilons
 * NO_I_EPSILONS = fst.kNoIEpsilons             # <<<<<<<<<<<<<<
 * O_EPSILONS = fst.kOEpsilons
 * NO_O_EPSILONS = fst.kNoOEpsilons
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint64_t(fst::kNoIEpsilons); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2827, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_NO_I_EPSILONS, __pyx_t_1) < 0) __PYX_ERR(0, 2827, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pywrapfst.pyx":2828
 * I_EPSILONS = fst.kIEpsilons
 * NO_I_EPSILONS = fst.kNoIEpsilons
 * O_EPSILONS = fst.kOEpsilons             # <<<<<<<<<<<<<<
 * NO_O_EPSILONS = fst.kNoOEpsilons
 * I_LABEL_SORTED = fst.kILabelSorted
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint64_t(fst::kOEpsilons); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2828, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_O_EPSILONS, __pyx_t_1) < 0) __PYX_ERR(0, 2828, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pywrapfst.pyx":2829
 * NO_I_EPSILONS = fst.kNoIEpsilons
 * O_EPSILONS = fst.kOEpsilons
 * NO_O_EPSILONS = fst.kNoOEpsilons             # <<<<<<<<<<<<<<
 * I_LABEL_SORTED = fst.kILabelSorted
 * NOT_I_LABEL_SORTED = fst.kNotILabelSorted
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint64_t(fst::kNoOEpsilons); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2829, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_NO_O_EPSILONS, __pyx_t_1) < 0) __PYX_ERR(0, 2829, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pywrapfst.pyx":2830
 * O_EPSILONS = fst.kOEpsilons
 * NO_O_EPSILONS = fst.kNoOEpsilons
 * I_LABEL_SORTED = fst.kILabelSorted             # <<<<<<<<<<<<<<
 * NOT_I_LABEL_SORTED = fst.kNotILabelSorted
 * O_LABEL_SORTED = fst.kOLabelSorted
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint64_t(fst::kILabelSorted); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2830, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_I_LABEL_SORTED, __pyx_t_1) < 0) __PYX_ERR(0, 2830, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pywrapfst.pyx":2831
 * NO_O_EPSILONS = fst.kNoOEpsilons
 * I_LABEL_SORTED = fst.kILabelSorted
 * NOT_I_LABEL_SORTED = fst.kNotILabelSorted             # <<<<<<<<<<<<<<
 * O_LABEL_SORTED = fst.kOLabelSorted
 * NOT_O_LABEL_SORTED = fst.kNotOLabelSorted
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint64_t(fst::kNotILabelSorted); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2831, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_NOT_I_LABEL_SORTED, __pyx_t_1) < 0) __PYX_ERR(0, 2831, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pywrapfst.pyx":2832
 * I_LABEL_SORTED = fst.kILabelSorted
 * NOT_I_LABEL_SORTED = fst.kNotILabelSorted
 * O_LABEL_SORTED = fst.kOLabelSorted             # <<<<<<<<<<<<<<
 * NOT_O_LABEL_SORTED = fst.kNotOLabelSorted
 * WEIGHTED = fst.kWeighted
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint64_t(fst::kOLabelSorted); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2832, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_O_LABEL_SORTED, __pyx_t_1) < 0) __PYX_ERR(0, 2832, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pywrapfst.pyx":2833
 * NOT_I_LABEL_SORTED = fst.kNotILabelSorted
 * O_LABEL_SORTED = fst.kOLabelSorted
 * NOT_O_LABEL_SORTED = fst.kNotOLabelSorted             # <<<<<<<<<<<<<<
 * WEIGHTED = fst.kWeighted
 * UNWEIGHTED = fst.kUnweighted
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint64_t(fst::kNotOLabelSorted); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2833, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_NOT_O_LABEL_SORTED, __pyx_t_1) < 0) __PYX_ERR(0, 2833, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pywrapfst.pyx":2834
 * O_LABEL_SORTED = fst.kOLabelSorted
 * NOT_O_LABEL_SORTED = fst.kNotOLabelSorted
 * WEIGHTED = fst.kWeighted             # <<<<<<<<<<<<<<
 * UNWEIGHTED = fst.kUnweighted
 * CYCLIC = fst.kCyclic
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint64_t(fst::kWeighted); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2834, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_WEIGHTED, __pyx_t_1) < 0) __PYX_ERR(0, 2834, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pywrapfst.pyx":2835
 * NOT_O_LABEL_SORTED = fst.kNotOLabelSorted
 * WEIGHTED = fst.kWeighted
 * UNWEIGHTED = fst.kUnweighted             # <<<<<<<<<<<<<<
 * CYCLIC = fst.kCyclic
 * ACYCLIC = fst.kAcyclic
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint64_t(fst::kUnweighted); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2835, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_UNWEIGHTED, __pyx_t_1) < 0) __PYX_ERR(0, 2835, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pywrapfst.pyx":2836
 * WEIGHTED = fst.kWeighted
 * UNWEIGHTED = fst.kUnweighted
 * CYCLIC = fst.kCyclic             # <<<<<<<<<<<<<<
 * ACYCLIC = fst.kAcyclic
 * INITIAL_CYCLIC = fst.kInitialCyclic
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint64_t(fst::kCyclic); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2836, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_CYCLIC, __pyx_t_1) < 0) __PYX_ERR(0, 2836, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pywrapfst.pyx":2837
 * UNWEIGHTED = fst.kUnweighted
 * CYCLIC = fst.kCyclic
 * ACYCLIC = fst.kAcyclic             # <<<<<<<<<<<<<<
 * INITIAL_CYCLIC = fst.kInitialCyclic
 * INITIAL_ACYCLIC = fst.kInitialAcyclic
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint64_t(fst::kAcyclic); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2837, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_ACYCLIC, __pyx_t_1) < 0) __PYX_ERR(0, 2837, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pywrapfst.pyx":2838
 * CYCLIC = fst.kCyclic
 * ACYCLIC = fst.kAcyclic
 * INITIAL_CYCLIC = fst.kInitialCyclic             # <<<<<<<<<<<<<<
 * INITIAL_ACYCLIC = fst.kInitialAcyclic
 * TOP_SORTED = fst.kTopSorted
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint64_t(fst::kInitialCyclic); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2838, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_INITIAL_CYCLIC, __pyx_t_1) < 0) __PYX_ERR(0, 2838, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pywrapfst.pyx":2839
 * ACYCLIC = fst.kAcyclic
 * INITIAL_CYCLIC = fst.kInitialCyclic
 * INITIAL_ACYCLIC = fst.kInitialAcyclic             # <<<<<<<<<<<<<<
 * TOP_SORTED = fst.kTopSorted
 * NOT_TOP_SORTED = fst.kNotTopSorted
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint64_t(fst::kInitialAcyclic); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2839, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_INITIAL_ACYCLIC, __pyx_t_1) < 0) __PYX_ERR(0, 2839, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pywrapfst.pyx":2840
 * INITIAL_CYCLIC = fst.kInitialCyclic
 * INITIAL_ACYCLIC = fst.kInitialAcyclic
 * TOP_SORTED = fst.kTopSorted             # <<<<<<<<<<<<<<
 * NOT_TOP_SORTED = fst.kNotTopSorted
 * ACCESSIBLE = fst.kAccessible
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint64_t(fst::kTopSorted); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2840, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_TOP_SORTED, __pyx_t_1) < 0) __PYX_ERR(0, 2840, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pywrapfst.pyx":2841
 * INITIAL_ACYCLIC = fst.kInitialAcyclic
 * TOP_SORTED = fst.kTopSorted
 * NOT_TOP_SORTED = fst.kNotTopSorted             # <<<<<<<<<<<<<<
 * ACCESSIBLE = fst.kAccessible
 * NOT_ACCESSIBLE = fst.kNotAccessible
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint64_t(fst::kNotTopSorted); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2841, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_NOT_TOP_SORTED, __pyx_t_1) < 0) __PYX_ERR(0, 2841, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pywrapfst.pyx":2842
 * TOP_SORTED = fst.kTopSorted
 * NOT_TOP_SORTED = fst.kNotTopSorted
 * ACCESSIBLE = fst.kAccessible             # <<<<<<<<<<<<<<
 * NOT_ACCESSIBLE = fst.kNotAccessible
 * COACCESSIBLE = fst.kCoAccessible
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint64_t(fst::kAccessible); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2842, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_ACCESSIBLE, __pyx_t_1) < 0) __PYX_ERR(0, 2842, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pywrapfst.pyx":2843
 * NOT_TOP_SORTED = fst.kNotTopSorted
 * ACCESSIBLE = fst.kAccessible
 * NOT_ACCESSIBLE = fst.kNotAccessible             # <<<<<<<<<<<<<<
 * COACCESSIBLE = fst.kCoAccessible
 * NOT_COACCESSIBLE = fst.kNotCoAccessible
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint64_t(fst::kNotAccessible); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2843, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_NOT_ACCESSIBLE, __pyx_t_1) < 0) __PYX_ERR(0, 2843, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pywrapfst.pyx":2844
 * ACCESSIBLE = fst.kAccessible
 * NOT_ACCESSIBLE = fst.kNotAccessible
 * COACCESSIBLE = fst.kCoAccessible             # <<<<<<<<<<<<<<
 * NOT_COACCESSIBLE = fst.kNotCoAccessible
 * STRING = fst.kString
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint64_t(fst::kCoAccessible); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2844, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_COACCESSIBLE, __pyx_t_1) < 0) __PYX_ERR(0, 2844, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pywrapfst.pyx":2845
 * NOT_ACCESSIBLE = fst.kNotAccessible
 * COACCESSIBLE = fst.kCoAccessible
 * NOT_COACCESSIBLE = fst.kNotCoAccessible             # <<<<<<<<<<<<<<
 * STRING = fst.kString
 * NOT_STRING = fst.kNotString
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint64_t(fst::kNotCoAccessible); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2845, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_NOT_COACCESSIBLE, __pyx_t_1) < 0) __PYX_ERR(0, 2845, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pywrapfst.pyx":2846
 * COACCESSIBLE = fst.kCoAccessible
 * NOT_COACCESSIBLE = fst.kNotCoAccessible
 * STRING = fst.kString             # <<<<<<<<<<<<<<
 * NOT_STRING = fst.kNotString
 * WEIGHTED_CYCLES = fst.kWeightedCycles
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint64_t(fst::kString); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2846, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_STRING, __pyx_t_1) < 0) __PYX_ERR(0, 2846, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pywrapfst.pyx":2847
 * NOT_COACCESSIBLE = fst.kNotCoAccessible
 * STRING = fst.kString
 * NOT_STRING = fst.kNotString             # <<<<<<<<<<<<<<
 * WEIGHTED_CYCLES = fst.kWeightedCycles
 * UNWEIGHTED_CYCLES = fst.kUnweightedCycles
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint64_t(fst::kNotString); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2847, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_NOT_STRING, __pyx_t_1) < 0) __PYX_ERR(0, 2847, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pywrapfst.pyx":2848
 * STRING = fst.kString
 * NOT_STRING = fst.kNotString
 * WEIGHTED_CYCLES = fst.kWeightedCycles             # <<<<<<<<<<<<<<
 * UNWEIGHTED_CYCLES = fst.kUnweightedCycles
 * NULL_PROPERTIES = fst.kNullProperties
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint64_t(fst::kWeightedCycles); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2848, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_WEIGHTED_CYCLES, __pyx_t_1) < 0) __PYX_ERR(0, 2848, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pywrapfst.pyx":2849
 * NOT_STRING = fst.kNotString
 * WEIGHTED_CYCLES = fst.kWeightedCycles
 * UNWEIGHTED_CYCLES = fst.kUnweightedCycles             # <<<<<<<<<<<<<<
 * NULL_PROPERTIES = fst.kNullProperties
 * COPY_PROPERTIES = fst.kCopyProperties
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint64_t(fst::kUnweightedCycles); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2849, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_UNWEIGHTED_CYCLES, __pyx_t_1) < 0) __PYX_ERR(0, 2849, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pywrapfst.pyx":2850
 * WEIGHTED_CYCLES = fst.kWeightedCycles
 * UNWEIGHTED_CYCLES = fst.kUnweightedCycles
 * NULL_PROPERTIES = fst.kNullProperties             # <<<<<<<<<<<<<<
 * COPY_PROPERTIES = fst.kCopyProperties
 * INTRINSIC_PROPERTIES = fst.kIntrinsicProperties
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint64_t(fst::kNullProperties); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2850, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_NULL_PROPERTIES, __pyx_t_1) < 0) __PYX_ERR(0, 2850, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pywrapfst.pyx":2851
 * UNWEIGHTED_CYCLES = fst.kUnweightedCycles
 * NULL_PROPERTIES = fst.kNullProperties
 * COPY_PROPERTIES = fst.kCopyProperties             # <<<<<<<<<<<<<<
 * INTRINSIC_PROPERTIES = fst.kIntrinsicProperties
 * EXTRINSIC_PROPERTIES = fst.kExtrinsicProperties
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint64_t(fst::kCopyProperties); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2851, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_COPY_PROPERTIES, __pyx_t_1) < 0) __PYX_ERR(0, 2851, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pywrapfst.pyx":2852
 * NULL_PROPERTIES = fst.kNullProperties
 * COPY_PROPERTIES = fst.kCopyProperties
 * INTRINSIC_PROPERTIES = fst.kIntrinsicProperties             # <<<<<<<<<<<<<<
 * EXTRINSIC_PROPERTIES = fst.kExtrinsicProperties
 * SET_START_PROPERTIES = fst.kSetStartProperties
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint64_t(fst::kIntrinsicProperties); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2852, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_INTRINSIC_PROPERTIES, __pyx_t_1) < 0) __PYX_ERR(0, 2852, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pywrapfst.pyx":2853
 * COPY_PROPERTIES = fst.kCopyProperties
 * INTRINSIC_PROPERTIES = fst.kIntrinsicProperties
 * EXTRINSIC_PROPERTIES = fst.kExtrinsicProperties             # <<<<<<<<<<<<<<
 * SET_START_PROPERTIES = fst.kSetStartProperties
 * SET_FINAL_PROPERTIES = fst.kSetFinalProperties
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint64_t(fst::kExtrinsicProperties); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2853, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_EXTRINSIC_PROPERTIES, __pyx_t_1) < 0) __PYX_ERR(0, 2853, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pywrapfst.pyx":2854
 * INTRINSIC_PROPERTIES = fst.kIntrinsicProperties
 * EXTRINSIC_PROPERTIES = fst.kExtrinsicProperties
 * SET_START_PROPERTIES = fst.kSetStartProperties             # <<<<<<<<<<<<<<
 * SET_FINAL_PROPERTIES = fst.kSetFinalProperties
 * ADD_STATE_PROPERTIES = fst.kAddStateProperties
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint64_t(fst::kSetStartProperties); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2854, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_SET_START_PROPERTIES, __pyx_t_1) < 0) __PYX_ERR(0, 2854, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pywrapfst.pyx":2855
 * EXTRINSIC_PROPERTIES = fst.kExtrinsicProperties
 * SET_START_PROPERTIES = fst.kSetStartProperties
 * SET_FINAL_PROPERTIES = fst.kSetFinalProperties             # <<<<<<<<<<<<<<
 * ADD_STATE_PROPERTIES = fst.kAddStateProperties
 * ADD_ARC_PROPERTIES = fst.kAddArcProperties
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint64_t(fst::kSetFinalProperties); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2855, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_SET_FINAL_PROPERTIES, __pyx_t_1) < 0) __PYX_ERR(0, 2855, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pywrapfst.pyx":2856
 * SET_START_PROPERTIES = fst.kSetStartProperties
 * SET_FINAL_PROPERTIES = fst.kSetFinalProperties
 * ADD_STATE_PROPERTIES = fst.kAddStateProperties             # <<<<<<<<<<<<<<
 * ADD_ARC_PROPERTIES = fst.kAddArcProperties
 * SET_ARC_PROPERTIES = fst.kSetArcProperties
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint64_t(fst::kAddStateProperties); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2856, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_ADD_STATE_PROPERTIES, __pyx_t_1) < 0) __PYX_ERR(0, 2856, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pywrapfst.pyx":2857
 * SET_FINAL_PROPERTIES = fst.kSetFinalProperties
 * ADD_STATE_PROPERTIES = fst.kAddStateProperties
 * ADD_ARC_PROPERTIES = fst.kAddArcProperties             # <<<<<<<<<<<<<<
 * SET_ARC_PROPERTIES = fst.kSetArcProperties
 * DELETE_STATE_PROPERTIES = fst.kDeleteStatesProperties
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint64_t(fst::kAddArcProperties); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2857, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_ADD_ARC_PROPERTIES, __pyx_t_1) < 0) __PYX_ERR(0, 2857, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pywrapfst.pyx":2858
 * ADD_STATE_PROPERTIES = fst.kAddStateProperties
 * ADD_ARC_PROPERTIES = fst.kAddArcProperties
 * SET_ARC_PROPERTIES = fst.kSetArcProperties             # <<<<<<<<<<<<<<
 * DELETE_STATE_PROPERTIES = fst.kDeleteStatesProperties
 * DELETE_ARC_PROPERTIES = fst.kDeleteArcsProperties
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint64_t(fst::kSetArcProperties); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2858, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_SET_ARC_PROPERTIES, __pyx_t_1) < 0) __PYX_ERR(0, 2858, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pywrapfst.pyx":2859
 * ADD_ARC_PROPERTIES = fst.kAddArcProperties
 * SET_ARC_PROPERTIES = fst.kSetArcProperties
 * DELETE_STATE_PROPERTIES = fst.kDeleteStatesProperties             # <<<<<<<<<<<<<<
 * DELETE_ARC_PROPERTIES = fst.kDeleteArcsProperties
 * STATE_SORT_PROPERTIES = fst.kStateSortProperties
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint64_t(fst::kDeleteStatesProperties); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2859, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_DELETE_STATE_PROPERTIES, __pyx_t_1) < 0) __PYX_ERR(0, 2859, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pywrapfst.pyx":2860
 * SET_ARC_PROPERTIES = fst.kSetArcProperties
 * DELETE_STATE_PROPERTIES = fst.kDeleteStatesProperties
 * DELETE_ARC_PROPERTIES = fst.kDeleteArcsProperties             # <<<<<<<<<<<<<<
 * STATE_SORT_PROPERTIES = fst.kStateSortProperties
 * ARC_SORT_PROPERTIES = fst.kArcSortProperties
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint64_t(fst::kDeleteArcsProperties); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2860, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_DELETE_ARC_PROPERTIES, __pyx_t_1) < 0) __PYX_ERR(0, 2860, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pywrapfst.pyx":2861
 * DELETE_STATE_PROPERTIES = fst.kDeleteStatesProperties
 * DELETE_ARC_PROPERTIES = fst.kDeleteArcsProperties
 * STATE_SORT_PROPERTIES = fst.kStateSortProperties             # <<<<<<<<<<<<<<
 * ARC_SORT_PROPERTIES = fst.kArcSortProperties
 * I_LABEL_INVARIANT_PROPERTIES = fst.kILabelInvariantProperties
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint64_t(fst::kStateSortProperties); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2861, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_STATE_SORT_PROPERTIES, __pyx_t_1) < 0) __PYX_ERR(0, 2861, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pywrapfst.pyx":2862
 * DELETE_ARC_PROPERTIES = fst.kDeleteArcsProperties
 * STATE_SORT_PROPERTIES = fst.kStateSortProperties
 * ARC_SORT_PROPERTIES = fst.kArcSortProperties             # <<<<<<<<<<<<<<
 * I_LABEL_INVARIANT_PROPERTIES = fst.kILabelInvariantProperties
 * O_LABEL_INVARIANT_PROPERTIES = fst.kOLabelInvariantProperties
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint64_t(fst::kArcSortProperties); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2862, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_ARC_SORT_PROPERTIES, __pyx_t_1) < 0) __PYX_ERR(0, 2862, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pywrapfst.pyx":2863
 * STATE_SORT_PROPERTIES = fst.kStateSortProperties
 * ARC_SORT_PROPERTIES = fst.kArcSortProperties
 * I_LABEL_INVARIANT_PROPERTIES = fst.kILabelInvariantProperties             # <<<<<<<<<<<<<<
 * O_LABEL_INVARIANT_PROPERTIES = fst.kOLabelInvariantProperties
 * WEIGHT_INVARIANT_PROPERTIES = fst.kWeightInvariantProperties
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint64_t(fst::kILabelInvariantProperties); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2863, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_I_LABEL_INVARIANT_PROPERTIES, __pyx_t_1) < 0) __PYX_ERR(0, 2863, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pywrapfst.pyx":2864
 * ARC_SORT_PROPERTIES = fst.kArcSortProperties
 * I_LABEL_INVARIANT_PROPERTIES = fst.kILabelInvariantProperties
 * O_LABEL_INVARIANT_PROPERTIES = fst.kOLabelInvariantProperties             # <<<<<<<<<<<<<<
 * WEIGHT_INVARIANT_PROPERTIES = fst.kWeightInvariantProperties
 * ADD_SUPERFINAL_PROPERTIES = fst.kAddSuperFinalProperties
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint64_t(fst::kOLabelInvariantProperties); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2864, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_O_LABEL_INVARIANT_PROPERTIES, __pyx_t_1) < 0) __PYX_ERR(0, 2864, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pywrapfst.pyx":2865
 * I_LABEL_INVARIANT_PROPERTIES = fst.kILabelInvariantProperties
 * O_LABEL_INVARIANT_PROPERTIES = fst.kOLabelInvariantProperties
 * WEIGHT_INVARIANT_PROPERTIES = fst.kWeightInvariantProperties             # <<<<<<<<<<<<<<
 * ADD_SUPERFINAL_PROPERTIES = fst.kAddSuperFinalProperties
 * RM_SUPERFINAL_PROPERTIES = fst.kRmSuperFinalProperties
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint64_t(fst::kWeightInvariantProperties); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2865, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_WEIGHT_INVARIANT_PROPERTIES, __pyx_t_1) < 0) __PYX_ERR(0, 2865, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pywrapfst.pyx":2866
 * O_LABEL_INVARIANT_PROPERTIES = fst.kOLabelInvariantProperties
 * WEIGHT_INVARIANT_PROPERTIES = fst.kWeightInvariantProperties
 * ADD_SUPERFINAL_PROPERTIES = fst.kAddSuperFinalProperties             # <<<<<<<<<<<<<<
 * RM_SUPERFINAL_PROPERTIES = fst.kRmSuperFinalProperties
 * BINARY_PROPERTIES = fst.kBinaryProperties
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint64_t(fst::kAddSuperFinalProperties); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2866, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_ADD_SUPERFINAL_PROPERTIES, __pyx_t_1) < 0) __PYX_ERR(0, 2866, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pywrapfst.pyx":2867
 * WEIGHT_INVARIANT_PROPERTIES = fst.kWeightInvariantProperties
 * ADD_SUPERFINAL_PROPERTIES = fst.kAddSuperFinalProperties
 * RM_SUPERFINAL_PROPERTIES = fst.kRmSuperFinalProperties             # <<<<<<<<<<<<<<
 * BINARY_PROPERTIES = fst.kBinaryProperties
 * TRINARY_PROPERTIES = fst.kTrinaryProperties
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint64_t(fst::kRmSuperFinalProperties); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2867, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_RM_SUPERFINAL_PROPERTIES, __pyx_t_1) < 0) __PYX_ERR(0, 2867, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pywrapfst.pyx":2868
 * ADD_SUPERFINAL_PROPERTIES = fst.kAddSuperFinalProperties
 * RM_SUPERFINAL_PROPERTIES = fst.kRmSuperFinalProperties
 * BINARY_PROPERTIES = fst.kBinaryProperties             # <<<<<<<<<<<<<<
 * TRINARY_PROPERTIES = fst.kTrinaryProperties
 * POS_TRINARY_PROPERTIES = fst.kPosTrinaryProperties
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint64_t(fst::kBinaryProperties); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2868, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_BINARY_PROPERTIES, __pyx_t_1) < 0) __PYX_ERR(0, 2868, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pywrapfst.pyx":2869
 * RM_SUPERFINAL_PROPERTIES = fst.kRmSuperFinalProperties
 * BINARY_PROPERTIES = fst.kBinaryProperties
 * TRINARY_PROPERTIES = fst.kTrinaryProperties             # <<<<<<<<<<<<<<
 * POS_TRINARY_PROPERTIES = fst.kPosTrinaryProperties
 * NEG_TRINARY_PROPERTIES = fst.kNegTrinaryProperties
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint64_t(fst::kTrinaryProperties); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2869, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_TRINARY_PROPERTIES, __pyx_t_1) < 0) __PYX_ERR(0, 2869, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pywrapfst.pyx":2870
 * BINARY_PROPERTIES = fst.kBinaryProperties
 * TRINARY_PROPERTIES = fst.kTrinaryProperties
 * POS_TRINARY_PROPERTIES = fst.kPosTrinaryProperties             # <<<<<<<<<<<<<<
 * NEG_TRINARY_PROPERTIES = fst.kNegTrinaryProperties
 * FST_PROPERTIES = fst.kFstProperties
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint64_t(fst::kPosTrinaryProperties); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2870, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_POS_TRINARY_PROPERTIES, __pyx_t_1) < 0) __PYX_ERR(0, 2870, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pywrapfst.pyx":2871
 * TRINARY_PROPERTIES = fst.kTrinaryProperties
 * POS_TRINARY_PROPERTIES = fst.kPosTrinaryProperties
 * NEG_TRINARY_PROPERTIES = fst.kNegTrinaryProperties             # <<<<<<<<<<<<<<
 * FST_PROPERTIES = fst.kFstProperties
 * 
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint64_t(fst::kNegTrinaryProperties); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2871, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_NEG_TRINARY_PROPERTIES, __pyx_t_1) < 0) __PYX_ERR(0, 2871, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pywrapfst.pyx":2872
 * POS_TRINARY_PROPERTIES = fst.kPosTrinaryProperties
 * NEG_TRINARY_PROPERTIES = fst.kNegTrinaryProperties
 * FST_PROPERTIES = fst.kFstProperties             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint64_t(fst::kFstProperties); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2872, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_FST_PROPERTIES, __pyx_t_1) < 0) __PYX_ERR(0, 2872, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pywrapfst.pyx":2878
 * 
 * 
 * ARC_I_LABEL_VALUE = fst.kArcILabelValue             # <<<<<<<<<<<<<<
 * ARC_O_LABEL_VALUE = fst.kArcOLabelValue
 * ARC_WEIGHT_VALUE = fst.kArcWeightValue
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint32_t(fst::kArcILabelValue); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2878, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_ARC_I_LABEL_VALUE, __pyx_t_1) < 0) __PYX_ERR(0, 2878, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pywrapfst.pyx":2879
 * 
 * ARC_I_LABEL_VALUE = fst.kArcILabelValue
 * ARC_O_LABEL_VALUE = fst.kArcOLabelValue             # <<<<<<<<<<<<<<
 * ARC_WEIGHT_VALUE = fst.kArcWeightValue
 * ARC_NEXT_STATE_VALUE = fst.kArcNextStateValue
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint32_t(fst::kArcOLabelValue); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2879, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_ARC_O_LABEL_VALUE, __pyx_t_1) < 0) __PYX_ERR(0, 2879, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pywrapfst.pyx":2880
 * ARC_I_LABEL_VALUE = fst.kArcILabelValue
 * ARC_O_LABEL_VALUE = fst.kArcOLabelValue
 * ARC_WEIGHT_VALUE = fst.kArcWeightValue             # <<<<<<<<<<<<<<
 * ARC_NEXT_STATE_VALUE = fst.kArcNextStateValue
 * ARC_NO_CACHE = fst.kArcNoCache
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint32_t(fst::kArcWeightValue); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2880, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_ARC_WEIGHT_VALUE, __pyx_t_1) < 0) __PYX_ERR(0, 2880, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pywrapfst.pyx":2881
 * ARC_O_LABEL_VALUE = fst.kArcOLabelValue
 * ARC_WEIGHT_VALUE = fst.kArcWeightValue
 * ARC_NEXT_STATE_VALUE = fst.kArcNextStateValue             # <<<<<<<<<<<<<<
 * ARC_NO_CACHE = fst.kArcNoCache
 * ARC_VALUE_FLAGS = fst.kArcValueFlags
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint32_t(fst::kArcNextStateValue); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2881, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_ARC_NEXT_STATE_VALUE, __pyx_t_1) < 0) __PYX_ERR(0, 2881, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pywrapfst.pyx":2882
 * ARC_WEIGHT_VALUE = fst.kArcWeightValue
 * ARC_NEXT_STATE_VALUE = fst.kArcNextStateValue
 * ARC_NO_CACHE = fst.kArcNoCache             # <<<<<<<<<<<<<<
 * ARC_VALUE_FLAGS = fst.kArcValueFlags
 * ARC_FLAGS = fst.kArcFlags
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint32_t(fst::kArcNoCache); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2882, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_ARC_NO_CACHE, __pyx_t_1) < 0) __PYX_ERR(0, 2882, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pywrapfst.pyx":2883
 * ARC_NEXT_STATE_VALUE = fst.kArcNextStateValue
 * ARC_NO_CACHE = fst.kArcNoCache
 * ARC_VALUE_FLAGS = fst.kArcValueFlags             # <<<<<<<<<<<<<<
 * ARC_FLAGS = fst.kArcFlags
 * 
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint32_t(fst::kArcValueFlags); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2883, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_ARC_VALUE_FLAGS, __pyx_t_1) < 0) __PYX_ERR(0, 2883, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pywrapfst.pyx":2884
 * ARC_NO_CACHE = fst.kArcNoCache
 * ARC_VALUE_FLAGS = fst.kArcValueFlags
 * ARC_FLAGS = fst.kArcFlags             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint32_t(fst::kArcFlags); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2884, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_ARC_FLAGS, __pyx_t_1) < 0) __PYX_ERR(0, 2884, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pywrapfst.pyx":2890
 * 
 * 
 * ENCODE_LABELS = fst.kEncodeLabels             # <<<<<<<<<<<<<<
 * ENCODE_WEIGHTS = fst.kEncodeWeights
 * ENCODE_FLAGS = fst.kEncodeFlags
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint32_t(fst::kEncodeLabels); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2890, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_ENCODE_LABELS, __pyx_t_1) < 0) __PYX_ERR(0, 2890, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pywrapfst.pyx":2891
 * 
 * ENCODE_LABELS = fst.kEncodeLabels
 * ENCODE_WEIGHTS = fst.kEncodeWeights             # <<<<<<<<<<<<<<
 * ENCODE_FLAGS = fst.kEncodeFlags
 * 
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint32_t(fst::kEncodeWeights); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2891, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_ENCODE_WEIGHTS, __pyx_t_1) < 0) __PYX_ERR(0, 2891, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pywrapfst.pyx":2892
 * ENCODE_LABELS = fst.kEncodeLabels
 * ENCODE_WEIGHTS = fst.kEncodeWeights
 * ENCODE_FLAGS = fst.kEncodeFlags             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __pyx_t_1 = __Pyx_PyInt_From_uint32_t(fst::kEncodeFlags); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2892, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_ENCODE_FLAGS, __pyx_t_1) < 0) __PYX_ERR(0, 2892, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pywrapfst.pyx":3258
 * 
 * cdef _Fst _map(_Fst ifst,
 *                float delta=fst.kDelta,             # <<<<<<<<<<<<<<
 *                map_type=b"identity",
 *                double power=1.,
 */
  __pyx_k__67 = fst::kDelta;

  /* "pywrapfst.pyx":3272
 * 
 * cpdef _Fst arcmap(_Fst ifst,
 *                   float delta=fst.kDelta,             # <<<<<<<<<<<<<<
 *                   map_type=b"identity",
 *                   double power=1.,
 */
  __pyx_k__68 = fst::kDelta;

  /* "pywrapfst.pyx":3271
 * 
 * 
 * cpdef _Fst arcmap(_Fst ifst,             # <<<<<<<<<<<<<<
 *                   float delta=fst.kDelta,
 *                   map_type=b"identity",
 */
  __pyx_k__68 = fst::kDelta;

  /* "pywrapfst.pyx":3384
 * 
 * cpdef _MutableFst determinize(_Fst ifst,
 *                               float delta=fst.kShortestDelta,             # <<<<<<<<<<<<<<
 *                               det_type=b"functional",
 *                               int64 nstate=fst.kNoStateId,
 */
  __pyx_k__69 = fst::kShortestDelta;

  /* "pywrapfst.pyx":3386
 *                               float delta=fst.kShortestDelta,
 *                               det_type=b"functional",
 *                               int64 nstate=fst.kNoStateId,             # <<<<<<<<<<<<<<
 *                               int64 subsequential_label=0,
 *                               weight=None,
 */
  __pyx_k__70 = fst::kNoStateId;

  /* "pywrapfst.pyx":3384
 * 
 * cpdef _MutableFst determinize(_Fst ifst,
 *                               float delta=fst.kShortestDelta,             # <<<<<<<<<<<<<<
 *                               det_type=b"functional",
 *                               int64 nstate=fst.kNoStateId,
 */
  __pyx_k__69 = fst::kShortestDelta;

  /* "pywrapfst.pyx":3386
 *                               float delta=fst.kShortestDelta,
 *                               det_type=b"functional",
 *                               int64 nstate=fst.kNoStateId,             # <<<<<<<<<<<<<<
 *                               int64 subsequential_label=0,
 *                               weight=None,
 */
  __pyx_k__70 = fst::kNoStateId;

  /* "pywrapfst.pyx":3477
 * 
 * cpdef _MutableFst disambiguate(_Fst ifst,
 *                                float delta=fst.kDelta,             # <<<<<<<<<<<<<<
 *                                int64 nstate=fst.kNoStateId,
 *                                int64 subsequential_label=0,
 */
  __pyx_k__71 = fst::kDelta;

  /* "pywrapfst.pyx":3478
 * cpdef _MutableFst disambiguate(_Fst ifst,
 *                                float delta=fst.kDelta,
 *                                int64 nstate=fst.kNoStateId,             # <<<<<<<<<<<<<<
 *                                int64 subsequential_label=0,
 *                                weight=None):
 */
  __pyx_k__72 = fst::kNoStateId;

  /* "pywrapfst.pyx":3477
 * 
 * cpdef _MutableFst disambiguate(_Fst ifst,
 *                                float delta=fst.kDelta,             # <<<<<<<<<<<<<<
 *                                int64 nstate=fst.kNoStateId,
 *                                int64 subsequential_label=0,
 */
  __pyx_k__71 = fst::kDelta;

  /* "pywrapfst.pyx":3478
 * cpdef _MutableFst disambiguate(_Fst ifst,
 *                                float delta=fst.kDelta,
 *                                int64 nstate=fst.kNoStateId,             # <<<<<<<<<<<<<<
 *                                int64 subsequential_label=0,
 *                                weight=None):
 */
  __pyx_k__72 = fst::kNoStateId;

  /* "pywrapfst.pyx":3548
 * 
 * 
 * cpdef bool equal(_Fst ifst1, _Fst ifst2, float delta=fst.kDelta):             # <<<<<<<<<<<<<<
 *   """
 *   equal(ifst1, ifst2, delta=0.0009765625)
 */
  __pyx_k__73 = fst::kDelta;
  __pyx_k__73 = fst::kDelta;

  /* "pywrapfst.pyx":3571
 * 
 * 
 * cpdef bool equivalent(_Fst ifst1, _Fst ifst2, float delta=fst.kDelta) except *:             # <<<<<<<<<<<<<<
 *   """
 *   equivalent(ifst1, ifst2, delta=0.0009765625)
 */
  __pyx_k__74 = fst::kDelta;
  __pyx_k__74 = fst::kDelta;

  /* "pywrapfst.pyx":3627
 * 
 * 
 * cpdef bool isomorphic(_Fst ifst1, _Fst ifst2, float delta=fst.kDelta):             # <<<<<<<<<<<<<<
 *   """
 *   isomorphic(ifst1, ifst2, delta=0.0009765625)
 */
  __pyx_k__75 = fst::kDelta;
  __pyx_k__75 = fst::kDelta;

  /* "pywrapfst.pyx":3654
 * 
 * cpdef _MutableFst prune(_Fst ifst,
 *                         float delta=fst.kDelta,             # <<<<<<<<<<<<<<
 *                         int64 nstate=fst.kNoStateId,
 *                         weight=None):
 */
  __pyx_k__76 = fst::kDelta;

  /* "pywrapfst.pyx":3655
 * cpdef _MutableFst prune(_Fst ifst,
 *                         float delta=fst.kDelta,
 *                         int64 nstate=fst.kNoStateId,             # <<<<<<<<<<<<<<
 *                         weight=None):
 *   """
 */
  __pyx_k__77 = fst::kNoStateId;

  /* "pywrapfst.pyx":3654
 * 
 * cpdef _MutableFst prune(_Fst ifst,
 *                         float delta=fst.kDelta,             # <<<<<<<<<<<<<<
 *                         int64 nstate=fst.kNoStateId,
 *                         weight=None):
 */
  __pyx_k__76 = fst::kDelta;

  /* "pywrapfst.pyx":3655
 * cpdef _MutableFst prune(_Fst ifst,
 *                         float delta=fst.kDelta,
 *                         int64 nstate=fst.kNoStateId,             # <<<<<<<<<<<<<<
 *                         weight=None):
 *   """
 */
  __pyx_k__77 = fst::kNoStateId;

  /* "pywrapfst.pyx":3687
 * 
 * cpdef _MutableFst push(_Fst ifst,
 *                        float delta=fst.kDelta,             # <<<<<<<<<<<<<<
 *                        bool push_weights=False,
 *                        bool push_labels=False,
 */
  __pyx_k__78 = fst::kDelta;

  /* "pywrapfst.pyx":3686
 * 
 * 
 * cpdef _MutableFst push(_Fst ifst,             # <<<<<<<<<<<<<<
 *                        float delta=fst.kDelta,
 *                        bool push_weights=False,
 */
  __pyx_k__78 = fst::kDelta;

  /* "pywrapfst.pyx":3743
 *                           _Fst ifst2,
 *                           int32 npath=1,
 *                           float delta=fst.kDelta,             # <<<<<<<<<<<<<<
 *                           time_t seed=0,
 *                           select=b"uniform",
 */
  __pyx_k__79 = fst::kDelta;

  /* "pywrapfst.pyx":3746
 *                           time_t seed=0,
 *                           select=b"uniform",
 *                           int32 max_length=INT32_MAX) except *:             # <<<<<<<<<<<<<<
 *   """
 *   randequivalent(ifst1, ifst2, npath=1, delta=0.0009765625, seed=0,
 */
  __pyx_k__80 = INT32_MAX;

  /* "pywrapfst.pyx":3743
 *                           _Fst ifst2,
 *                           int32 npath=1,
 *                           float delta=fst.kDelta,             # <<<<<<<<<<<<<<
 *                           time_t seed=0,
 *                           select=b"uniform",
 */
  __pyx_k__79 = fst::kDelta;

  /* "pywrapfst.pyx":3746
 *                           time_t seed=0,
 *                           select=b"uniform",
 *                           int32 max_length=INT32_MAX) except *:             # <<<<<<<<<<<<<<
 *   """
 *   randequivalent(ifst1, ifst2, npath=1, delta=0.0009765625, seed=0,
 */
  __pyx_k__80 = INT32_MAX;

  /* "pywrapfst.pyx":3790
 *                           time_t seed=0,
 *                           select=b"uniform",
 *                           int32 max_length=INT32_MAX,             # <<<<<<<<<<<<<<
 *                           bool weighted=False,
 *                           bool remove_total_weight=False):
 */
  __pyx_k__81 = INT32_MAX;

  /* "pywrapfst.pyx":3786
 * 
 * 
 * cpdef _MutableFst randgen(_Fst ifst,             # <<<<<<<<<<<<<<
 *                           int32 npath=1,
 *                           time_t seed=0,
 */
  __pyx_k__81 = INT32_MAX;

  /* "pywrapfst.pyx":3928
 * 
 * cdef vector[fst.WeightClass] *_shortestdistance(_Fst ifst,
 *                                                 float delta=fst.kShortestDelta,             # <<<<<<<<<<<<<<
 *                                                 int64 nstate=fst.kNoStateId,
 *                                                 queue_type=b"auto",
 */
  __pyx_k__82 = fst::kShortestDelta;

  /* "pywrapfst.pyx":3929
 * cdef vector[fst.WeightClass] *_shortestdistance(_Fst ifst,
 *                                                 float delta=fst.kShortestDelta,
 *                                                 int64 nstate=fst.kNoStateId,             # <<<<<<<<<<<<<<
 *                                                 queue_type=b"auto",
 *                                                 bool reverse=False) except *:
 */
  __pyx_k__83 = fst::kNoStateId;

  /* "pywrapfst.pyx":3950
 * 
 * def shortestdistance(_Fst ifst,
 *                      float delta=fst.kShortestDelta,             # <<<<<<<<<<<<<<
 *                      int64 nstate=fst.kNoStateId,
 *                      queue_type=b"auto",
 */
  __pyx_k__84 = fst::kShortestDelta;

  /* "pywrapfst.pyx":3951
 * def shortestdistance(_Fst ifst,
 *                      float delta=fst.kShortestDelta,
 *                      int64 nstate=fst.kNoStateId,             # <<<<<<<<<<<<<<
 *                      queue_type=b"auto",
 *                      bool reverse=False):
 */
  __pyx_k__85 = fst::kNoStateId;

  /* "pywrapfst.pyx":3949
 * 
 * 
 * def shortestdistance(_Fst ifst,             # <<<<<<<<<<<<<<
 *                      float delta=fst.kShortestDelta,
 *                      int64 nstate=fst.kNoStateId,
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_9pywrapfst_51shortestdistance, NULL, __pyx_n_s_pywrapfst_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3949, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_shortestdistance, __pyx_t_1) < 0) __PYX_ERR(0, 3949, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pywrapfst.pyx":3987
 * 
 * cpdef _MutableFst shortestpath(_Fst ifst,
 *                                float delta=fst.kShortestDelta,             # <<<<<<<<<<<<<<
 *                                int32 nshortest=1,
 *                                int64 nstate=fst.kNoStateId,
 */
  __pyx_k__86 = fst::kShortestDelta;

  /* "pywrapfst.pyx":3989
 *                                float delta=fst.kShortestDelta,
 *                                int32 nshortest=1,
 *                                int64 nstate=fst.kNoStateId,             # <<<<<<<<<<<<<<
 *                                queue_type=b"auto",
 *                                bool unique=False,
 */
  __pyx_k__87 = fst::kNoStateId;

  /* "pywrapfst.pyx":3987
 * 
 * cpdef _MutableFst shortestpath(_Fst ifst,
 *                                float delta=fst.kShortestDelta,             # <<<<<<<<<<<<<<
 *                                int32 nshortest=1,
 *                                int64 nstate=fst.kNoStateId,
 */
  __pyx_k__86 = fst::kShortestDelta;

  /* "pywrapfst.pyx":3989
 *                                float delta=fst.kShortestDelta,
 *                                int32 nshortest=1,
 *                                int64 nstate=fst.kNoStateId,             # <<<<<<<<<<<<<<
 *                                queue_type=b"auto",
 *                                bool unique=False,
 */
  __pyx_k__87 = fst::kNoStateId;

  /* "pywrapfst.pyx":4140
 * 
 *   def __cinit__(self,
 *                 string fst_type=b"vector",             # <<<<<<<<<<<<<<
 *                 string arc_type=b"standard",
 *                 SymbolTable isymbols=None,
 */
  __pyx_t_6 = __pyx_convert_string_from_py_std__in_string(__pyx_n_b_vector); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 4140, __pyx_L1_error)
  __pyx_k__88 = __pyx_t_6;

  /* "pywrapfst.pyx":4141
 *   def __cinit__(self,
 *                 string fst_type=b"vector",
 *                 string arc_type=b"standard",             # <<<<<<<<<<<<<<
 *                 SymbolTable isymbols=None,
 *                 SymbolTable osymbols=None,
 */
  __pyx_t_6 = __pyx_convert_string_from_py_std__in_string(__pyx_n_b_standard); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 4141, __pyx_L1_error)
  __pyx_k__89 = __pyx_t_6;

  /* "pywrapfst.pyx":4239
 * 
 *   @classmethod
 *   def open(cls, *filenames):             # <<<<<<<<<<<<<<
 *     """
 *     FarReader.open(*filenames)
 */
  __pyx_t_1 = __Pyx_GetNameInClass((PyObject *)__pyx_ptype_9pywrapfst_FarReader, __pyx_n_s_open); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4239, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);

  /* "pywrapfst.pyx":4238
 *     return "<{} FarReader at 0x{:x}>".format(self.far_type(), id(self))
 * 
 *   @classmethod             # <<<<<<<<<<<<<<
 *   def open(cls, *filenames):
 *     """
 */
  __pyx_t_2 = __Pyx_Method_ClassMethod(__pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 4238, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  if (PyDict_SetItem((PyObject *)__pyx_ptype_9pywrapfst_FarReader->tp_dict, __pyx_n_s_open, __pyx_t_2) < 0) __PYX_ERR(0, 4239, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  PyType_Modified(__pyx_ptype_9pywrapfst_FarReader);

  /* "pywrapfst.pyx":4388
 * 
 *   @classmethod
 *   def create(cls, filename, arc_type=b"standard", far_type=b"default"):             # <<<<<<<<<<<<<<
 *     """
 *     FarWriter.
 */
  __pyx_t_2 = __Pyx_GetNameInClass((PyObject *)__pyx_ptype_9pywrapfst_FarWriter, __pyx_n_s_create); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 4388, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);

  /* "pywrapfst.pyx":4387
 *     return "<{} FarWriter at 0x{:x}>".format(self.far_type(), id(self))
 * 
 *   @classmethod             # <<<<<<<<<<<<<<
 *   def create(cls, filename, arc_type=b"standard", far_type=b"default"):
 *     """
 */
  __pyx_t_1 = __Pyx_Method_ClassMethod(__pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4387, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  if (PyDict_SetItem((PyObject *)__pyx_ptype_9pywrapfst_FarWriter->tp_dict, __pyx_n_s_create, __pyx_t_1) < 0) __PYX_ERR(0, 4388, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  PyType_Modified(__pyx_ptype_9pywrapfst_FarWriter);

  /* "pywrapfst.pyx":4487
 * 
 * 
 * _fst_error_fatal_old = fst.FLAGS_fst_error_fatal             # <<<<<<<<<<<<<<
 * fst.FLAGS_fst_error_fatal = False
 * 
 */
  __pyx_t_1 = __Pyx_PyBool_FromLong(FLAGS_fst_error_fatal); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4487, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_fst_error_fatal_old, __pyx_t_1) < 0) __PYX_ERR(0, 4487, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pywrapfst.pyx":4488
 * 
 * _fst_error_fatal_old = fst.FLAGS_fst_error_fatal
 * fst.FLAGS_fst_error_fatal = False             # <<<<<<<<<<<<<<
 * 
 * 
 */
  FLAGS_fst_error_fatal = 0;

  /* "pywrapfst.pyx":4491
 * 
 * 
 * @atexit.register             # <<<<<<<<<<<<<<
 * def _reset_fst_error_fatal():
 *   fst.FLAGS_fst_error_fatal = _fst_error_fatal_old
 */
  __pyx_t_2 = __Pyx_GetModuleGlobalName(__pyx_n_s_atexit); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 4491, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_register); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 4491, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "pywrapfst.pyx":4492
 * 
 * @atexit.register
 * def _reset_fst_error_fatal():             # <<<<<<<<<<<<<<
 *   fst.FLAGS_fst_error_fatal = _fst_error_fatal_old
 * 
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_9pywrapfst_59_reset_fst_error_fatal, NULL, __pyx_n_s_pywrapfst_2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 4492, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_4 = NULL;
  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
    __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
    if (likely(__pyx_t_4)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
      __Pyx_INCREF(__pyx_t_4);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_3, function);
    }
  }
  if (!__pyx_t_4) {
    __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4491, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __Pyx_GOTREF(__pyx_t_1);
  } else {
    #if CYTHON_FAST_PYCALL
    if (PyFunction_Check(__pyx_t_3)) {
      PyObject *__pyx_temp[2] = {__pyx_t_4, __pyx_t_2};
      __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_3, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4491, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    } else
    #endif
    #if CYTHON_FAST_PYCCALL
    if (__Pyx_PyFastCFunction_Check(__pyx_t_3)) {
      PyObject *__pyx_temp[2] = {__pyx_t_4, __pyx_t_2};
      __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_3, __pyx_temp+1-1, 1+1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4491, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    } else
    #endif
    {
      __pyx_t_7 = PyTuple_New(1+1); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 4491, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_7);
      __Pyx_GIVEREF(__pyx_t_4); PyTuple_SET_ITEM(__pyx_t_7, 0, __pyx_t_4); __pyx_t_4 = NULL;
      __Pyx_GIVEREF(__pyx_t_2);
      PyTuple_SET_ITEM(__pyx_t_7, 0+1, __pyx_t_2);
      __pyx_t_2 = 0;
      __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_7, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4491, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
    }
  }
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_reset_fst_error_fatal, __pyx_t_1) < 0) __PYX_ERR(0, 4492, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pywrapfst.pyx":1
 * #cython: nonecheck=True             # <<<<<<<<<<<<<<
 * # Licensed under the Apache License, Version 2.0 (the "License");
 * # you may not use this file except in compliance with the License.
 */
  __pyx_t_1 = __Pyx_PyDict_NewPresized(0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_test_2, __pyx_t_1) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "vector.from_py":45
 * 
 * @cname("__pyx_convert_vector_from_py_std_3a__3a_string")
 * cdef vector[X] __pyx_convert_vector_from_py_std_3a__3a_string(object o) except *:             # <<<<<<<<<<<<<<
 *     cdef vector[X] v
 *     for item in o:
 */

  /*--- Wrapped vars code ---*/

  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_7);
  if (__pyx_m) {
    if (__pyx_d) {
      __Pyx_AddTraceback("init pywrapfst", 0, __pyx_lineno, __pyx_filename);
    }
    Py_DECREF(__pyx_m); __pyx_m = 0;
  } else if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_ImportError, "init pywrapfst");
  }
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  #if CYTHON_PEP489_MULTI_PHASE_INIT
  return (__pyx_m != NULL) ? 0 : -1;
  #elif PY_MAJOR_VERSION >= 3
  return __pyx_m;
  #else
  return;
  #endif
}

/* --- Runtime support code --- */
/* Refnanny */
#if CYTHON_REFNANNY
static __Pyx_RefNannyAPIStruct *__Pyx_RefNannyImportAPI(const char *modname) {
    PyObject *m = NULL, *p = NULL;
    void *r = NULL;
    m = PyImport_ImportModule((char *)modname);
    if (!m) goto end;
    p = PyObject_GetAttrString(m, (char *)"RefNannyAPI");
    if (!p) goto end;
    r = PyLong_AsVoidPtr(p);
end:
    Py_XDECREF(p);
    Py_XDECREF(m);
    return (__Pyx_RefNannyAPIStruct *)r;
}
#endif

/* GetBuiltinName */
static PyObject *__Pyx_GetBuiltinName(PyObject *name) {
    PyObject* result = __Pyx_PyObject_GetAttrStr(__pyx_b, name);
    if (unlikely(!result)) {
        PyErr_Format(PyExc_NameError,
#if PY_MAJOR_VERSION >= 3
            "name '%U' is not defined", name);
#else
            "name '%.200s' is not defined", PyString_AS_STRING(name));
#endif
    }
    return result;
}

/* PyCFunctionFastCall */
#if CYTHON_FAST_PYCCALL
static CYTHON_INLINE PyObject * __Pyx_PyCFunction_FastCall(PyObject *func_obj, PyObject **args, Py_ssize_t nargs) {
    PyCFunctionObject *func = (PyCFunctionObject*)func_obj;
    PyCFunction meth = PyCFunction_GET_FUNCTION(func);
    PyObject *self = PyCFunction_GET_SELF(func);
    int flags = PyCFunction_GET_FLAGS(func);
    assert(PyCFunction_Check(func));
    assert(METH_FASTCALL == (flags & ~(METH_CLASS | METH_STATIC | METH_COEXIST | METH_KEYWORDS)));
    assert(nargs >= 0);
    assert(nargs == 0 || args != NULL);
    /* _PyCFunction_FastCallDict() must not be called with an exception set,
       because it may clear it (directly or indirectly) and so the
       caller loses its exception */
    assert(!PyErr_Occurred());
    if ((PY_VERSION_HEX < 0x030700A0) || unlikely(flags & METH_KEYWORDS)) {
        return (*((__Pyx_PyCFunctionFastWithKeywords)meth)) (self, args, nargs, NULL);
    } else {
        return (*((__Pyx_PyCFunctionFast)meth)) (self, args, nargs);
    }
}
#endif

/* PyFunctionFastCall */
#if CYTHON_FAST_PYCALL
#include "frameobject.h"
static PyObject* __Pyx_PyFunction_FastCallNoKw(PyCodeObject *co, PyObject **args, Py_ssize_t na,
                                               PyObject *globals) {
    PyFrameObject *f;
    PyThreadState *tstate = __Pyx_PyThreadState_Current;
    PyObject **fastlocals;
    Py_ssize_t i;
    PyObject *result;
    assert(globals != NULL);
    /* XXX Perhaps we should create a specialized
       PyFrame_New() that doesn't take locals, but does
       take builtins without sanity checking them.
       */
    assert(tstate != NULL);
    f = PyFrame_New(tstate, co, globals, NULL);
    if (f == NULL) {
        return NULL;
    }
    fastlocals = f->f_localsplus;
    for (i = 0; i < na; i++) {
        Py_INCREF(*args);
        fastlocals[i] = *args++;
    }
    result = PyEval_EvalFrameEx(f,0);
    ++tstate->recursion_depth;
    Py_DECREF(f);
    --tstate->recursion_depth;
    return result;
}
#if 1 || PY_VERSION_HEX < 0x030600B1
static PyObject *__Pyx_PyFunction_FastCallDict(PyObject *func, PyObject **args, int nargs, PyObject *kwargs) {
    PyCodeObject *co = (PyCodeObject *)PyFunction_GET_CODE(func);
    PyObject *globals = PyFunction_GET_GLOBALS(func);
    PyObject *argdefs = PyFunction_GET_DEFAULTS(func);
    PyObject *closure;
#if PY_MAJOR_VERSION >= 3
    PyObject *kwdefs;
#endif
    PyObject *kwtuple, **k;
    PyObject **d;
    Py_ssize_t nd;
    Py_ssize_t nk;
    PyObject *result;
    assert(kwargs == NULL || PyDict_Check(kwargs));
    nk = kwargs ? PyDict_Size(kwargs) : 0;
    if (Py_EnterRecursiveCall((char*)" while calling a Python object")) {
        return NULL;
    }
    if (
#if PY_MAJOR_VERSION >= 3
            co->co_kwonlyargcount == 0 &&
#endif
            likely(kwargs == NULL || nk == 0) &&
            co->co_flags == (CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE)) {
        if (argdefs == NULL && co->co_argcount == nargs) {
            result = __Pyx_PyFunction_FastCallNoKw(co, args, nargs, globals);
            goto done;
        }
        else if (nargs == 0 && argdefs != NULL
                 && co->co_argcount == Py_SIZE(argdefs)) {
            /* function called with no arguments, but all parameters have
               a default value: use default values as arguments .*/
            args = &PyTuple_GET_ITEM(argdefs, 0);
            result =__Pyx_PyFunction_FastCallNoKw(co, args, Py_SIZE(argdefs), globals);
            goto done;
        }
    }
    if (kwargs != NULL) {
        Py_ssize_t pos, i;
        kwtuple = PyTuple_New(2 * nk);
        if (kwtuple == NULL) {
            result = NULL;
            goto done;
        }
        k = &PyTuple_GET_ITEM(kwtuple, 0);
        pos = i = 0;
        while (PyDict_Next(kwargs, &pos, &k[i], &k[i+1])) {
            Py_INCREF(k[i]);
            Py_INCREF(k[i+1]);
            i += 2;
        }
        nk = i / 2;
    }
    else {
        kwtuple = NULL;
        k = NULL;
    }
    closure = PyFunction_GET_CLOSURE(func);
#if PY_MAJOR_VERSION >= 3
    kwdefs = PyFunction_GET_KW_DEFAULTS(func);
#endif
    if (argdefs != NULL) {
        d = &PyTuple_GET_ITEM(argdefs, 0);
        nd = Py_SIZE(argdefs);
    }
    else {
        d = NULL;
        nd = 0;
    }
#if PY_MAJOR_VERSION >= 3
    result = PyEval_EvalCodeEx((PyObject*)co, globals, (PyObject *)NULL,
                               args, nargs,
                               k, (int)nk,
                               d, (int)nd, kwdefs, closure);
#else
    result = PyEval_EvalCodeEx(co, globals, (PyObject *)NULL,
                               args, nargs,
                               k, (int)nk,
                               d, (int)nd, closure);
#endif
    Py_XDECREF(kwtuple);
done:
    Py_LeaveRecursiveCall();
    return result;
}
#endif
#endif

/* PyObjectCall */
#if CYTHON_COMPILING_IN_CPYTHON
static CYTHON_INLINE PyObject* __Pyx_PyObject_Call(PyObject *func, PyObject *arg, PyObject *kw) {
    PyObject *result;
    ternaryfunc call = func->ob_type->tp_call;
    if (unlikely(!call))
        return PyObject_Call(func, arg, kw);
    if (unlikely(Py_EnterRecursiveCall((char*)" while calling a Python object")))
        return NULL;
    result = (*call)(func, arg, kw);
    Py_LeaveRecursiveCall();
    if (unlikely(!result) && unlikely(!PyErr_Occurred())) {
        PyErr_SetString(
            PyExc_SystemError,
            "NULL result without error in PyObject_Call");
    }
    return result;
}
#endif

/* PyObjectCallMethO */
#if CYTHON_COMPILING_IN_CPYTHON
static CYTHON_INLINE PyObject* __Pyx_PyObject_CallMethO(PyObject *func, PyObject *arg) {
    PyObject *self, *result;
    PyCFunction cfunc;
    cfunc = PyCFunction_GET_FUNCTION(func);
    self = PyCFunction_GET_SELF(func);
    if (unlikely(Py_EnterRecursiveCall((char*)" while calling a Python object")))
        return NULL;
    result = cfunc(self, arg);
    Py_LeaveRecursiveCall();
    if (unlikely(!result) && unlikely(!PyErr_Occurred())) {
        PyErr_SetString(
            PyExc_SystemError,
            "NULL result without error in PyObject_Call");
    }
    return result;
}
#endif

/* PyObjectCallOneArg */
#if CYTHON_COMPILING_IN_CPYTHON
static PyObject* __Pyx__PyObject_CallOneArg(PyObject *func, PyObject *arg) {
    PyObject *result;
    PyObject *args = PyTuple_New(1);
    if (unlikely(!args)) return NULL;
    Py_INCREF(arg);
    PyTuple_SET_ITEM(args, 0, arg);
    result = __Pyx_PyObject_Call(func, args, NULL);
    Py_DECREF(args);
    return result;
}
static CYTHON_INLINE PyObject* __Pyx_PyObject_CallOneArg(PyObject *func, PyObject *arg) {
#if CYTHON_FAST_PYCALL
    if (PyFunction_Check(func)) {
        return __Pyx_PyFunction_FastCall(func, &arg, 1);
    }
#endif
    if (likely(PyCFunction_Check(func))) {
        if (likely(PyCFunction_GET_FLAGS(func) & METH_O)) {
            return __Pyx_PyObject_CallMethO(func, arg);
#if CYTHON_FAST_PYCCALL
        } else if (PyCFunction_GET_FLAGS(func) & METH_FASTCALL) {
            return __Pyx_PyCFunction_FastCall(func, &arg, 1);
#endif
        }
    }
    return __Pyx__PyObject_CallOneArg(func, arg);
}
#else
static CYTHON_INLINE PyObject* __Pyx_PyObject_CallOneArg(PyObject *func, PyObject *arg) {
    PyObject *result;
    PyObject *args = PyTuple_Pack(1, arg);
    if (unlikely(!args)) return NULL;
    result = __Pyx_PyObject_Call(func, args, NULL);
    Py_DECREF(args);
    return result;
}
#endif

/* GetModuleGlobalName */
static CYTHON_INLINE PyObject *__Pyx_GetModuleGlobalName(PyObject *name) {
    PyObject *result;
#if !CYTHON_AVOID_BORROWED_REFS
    result = PyDict_GetItem(__pyx_d, name);
    if (likely(result)) {
        Py_INCREF(result);
    } else {
#else
    result = PyObject_GetItem(__pyx_d, name);
    if (!result) {
        PyErr_Clear();
#endif
        result = __Pyx_GetBuiltinName(name);
    }
    return result;
}

/* PyErrFetchRestore */
  #if CYTHON_FAST_THREAD_STATE
static CYTHON_INLINE void __Pyx_ErrRestoreInState(PyThreadState *tstate, PyObject *type, PyObject *value, PyObject *tb) {
    PyObject *tmp_type, *tmp_value, *tmp_tb;
    tmp_type = tstate->curexc_type;
    tmp_value = tstate->curexc_value;
    tmp_tb = tstate->curexc_traceback;
    tstate->curexc_type = type;
    tstate->curexc_value = value;
    tstate->curexc_traceback = tb;
    Py_XDECREF(tmp_type);
    Py_XDECREF(tmp_value);
    Py_XDECREF(tmp_tb);
}
static CYTHON_INLINE void __Pyx_ErrFetchInState(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb) {
    *type = tstate->curexc_type;
    *value = tstate->curexc_value;
    *tb = tstate->curexc_traceback;
    tstate->curexc_type = 0;
    tstate->curexc_value = 0;
    tstate->curexc_traceback = 0;
}
#endif

/* RaiseException */
  #if PY_MAJOR_VERSION < 3
static void __Pyx_Raise(PyObject *type, PyObject *value, PyObject *tb,
                        CYTHON_UNUSED PyObject *cause) {
    __Pyx_PyThreadState_declare
    Py_XINCREF(type);
    if (!value || value == Py_None)
        value = NULL;
    else
        Py_INCREF(value);
    if (!tb || tb == Py_None)
        tb = NULL;
    else {
        Py_INCREF(tb);
        if (!PyTraceBack_Check(tb)) {
            PyErr_SetString(PyExc_TypeError,
                "raise: arg 3 must be a traceback or None");
            goto raise_error;
        }
    }
    if (PyType_Check(type)) {
#if CYTHON_COMPILING_IN_PYPY
        if (!value) {
            Py_INCREF(Py_None);
            value = Py_None;
        }
#endif
        PyErr_NormalizeException(&type, &value, &tb);
    } else {
        if (value) {
            PyErr_SetString(PyExc_TypeError,
                "instance exception may not have a separate value");
            goto raise_error;
        }
        value = type;
        type = (PyObject*) Py_TYPE(type);
        Py_INCREF(type);
        if (!PyType_IsSubtype((PyTypeObject *)type, (PyTypeObject *)PyExc_BaseException)) {
            PyErr_SetString(PyExc_TypeError,
                "raise: exception class must be a subclass of BaseException");
            goto raise_error;
        }
    }
    __Pyx_PyThreadState_assign
    __Pyx_ErrRestore(type, value, tb);
    return;
raise_error:
    Py_XDECREF(value);
    Py_XDECREF(type);
    Py_XDECREF(tb);
    return;
}
#else
static void __Pyx_Raise(PyObject *type, PyObject *value, PyObject *tb, PyObject *cause) {
    PyObject* owned_instance = NULL;
    if (tb == Py_None) {
        tb = 0;
    } else if (tb && !PyTraceBack_Check(tb)) {
        PyErr_SetString(PyExc_TypeError,
            "raise: arg 3 must be a traceback or None");
        goto bad;
    }
    if (value == Py_None)
        value = 0;
    if (PyExceptionInstance_Check(type)) {
        if (value) {
            PyErr_SetString(PyExc_TypeError,
                "instance exception may not have a separate value");
            goto bad;
        }
        value = type;
        type = (PyObject*) Py_TYPE(value);
    } else if (PyExceptionClass_Check(type)) {
        PyObject *instance_class = NULL;
        if (value && PyExceptionInstance_Check(value)) {
            instance_class = (PyObject*) Py_TYPE(value);
            if (instance_class != type) {
                int is_subclass = PyObject_IsSubclass(instance_class, type);
                if (!is_subclass) {
                    instance_class = NULL;
                } else if (unlikely(is_subclass == -1)) {
                    goto bad;
                } else {
                    type = instance_class;
                }
            }
        }
        if (!instance_class) {
            PyObject *args;
            if (!value)
                args = PyTuple_New(0);
            else if (PyTuple_Check(value)) {
                Py_INCREF(value);
                args = value;
            } else
                args = PyTuple_Pack(1, value);
            if (!args)
                goto bad;
            owned_instance = PyObject_Call(type, args, NULL);
            Py_DECREF(args);
            if (!owned_instance)
                goto bad;
            value = owned_instance;
            if (!PyExceptionInstance_Check(value)) {
                PyErr_Format(PyExc_TypeError,
                             "calling %R should have returned an instance of "
                             "BaseException, not %R",
                             type, Py_TYPE(value));
                goto bad;
            }
        }
    } else {
        PyErr_SetString(PyExc_TypeError,
            "raise: exception class must be a subclass of BaseException");
        goto bad;
    }
    if (cause) {
        PyObject *fixed_cause;
        if (cause == Py_None) {
            fixed_cause = NULL;
        } else if (PyExceptionClass_Check(cause)) {
            fixed_cause = PyObject_CallObject(cause, NULL);
            if (fixed_cause == NULL)
                goto bad;
        } else if (PyExceptionInstance_Check(cause)) {
            fixed_cause = cause;
            Py_INCREF(fixed_cause);
        } else {
            PyErr_SetString(PyExc_TypeError,
                            "exception causes must derive from "
                            "BaseException");
            goto bad;
        }
        PyException_SetCause(value, fixed_cause);
    }
    PyErr_SetObject(type, value);
    if (tb) {
#if CYTHON_COMPILING_IN_PYPY
        PyObject *tmp_type, *tmp_value, *tmp_tb;
        PyErr_Fetch(&tmp_type, &tmp_value, &tmp_tb);
        Py_INCREF(tb);
        PyErr_Restore(tmp_type, tmp_value, tb);
        Py_XDECREF(tmp_tb);
#else
        PyThreadState *tstate = __Pyx_PyThreadState_Current;
        PyObject* tmp_tb = tstate->curexc_traceback;
        if (tb != tmp_tb) {
            Py_INCREF(tb);
            tstate->curexc_traceback = tb;
            Py_XDECREF(tmp_tb);
        }
#endif
    }
bad:
    Py_XDECREF(owned_instance);
    return;
}
#endif

/* RaiseArgTupleInvalid */
  static void __Pyx_RaiseArgtupleInvalid(
    const char* func_name,
    int exact,
    Py_ssize_t num_min,
    Py_ssize_t num_max,
    Py_ssize_t num_found)
{
    Py_ssize_t num_expected;
    const char *more_or_less;
    if (num_found < num_min) {
        num_expected = num_min;
        more_or_less = "at least";
    } else {
        num_expected = num_max;
        more_or_less = "at most";
    }
    if (exact) {
        more_or_less = "exactly";
    }
    PyErr_Format(PyExc_TypeError,
                 "%.200s() takes %.8s %" CYTHON_FORMAT_SSIZE_T "d positional argument%.1s (%" CYTHON_FORMAT_SSIZE_T "d given)",
                 func_name, more_or_less, num_expected,
                 (num_expected == 1) ? "" : "s", num_found);
}

/* RaiseDoubleKeywords */
  static void __Pyx_RaiseDoubleKeywordsError(
    const char* func_name,
    PyObject* kw_name)
{
    PyErr_Format(PyExc_TypeError,
        #if PY_MAJOR_VERSION >= 3
        "%s() got multiple values for keyword argument '%U'", func_name, kw_name);
        #else
        "%s() got multiple values for keyword argument '%s'", func_name,
        PyString_AsString(kw_name));
        #endif
}

/* ParseKeywords */
  static int __Pyx_ParseOptionalKeywords(
    PyObject *kwds,
    PyObject **argnames[],
    PyObject *kwds2,
    PyObject *values[],
    Py_ssize_t num_pos_args,
    const char* function_name)
{
    PyObject *key = 0, *value = 0;
    Py_ssize_t pos = 0;
    PyObject*** name;
    PyObject*** first_kw_arg = argnames + num_pos_args;
    while (PyDict_Next(kwds, &pos, &key, &value)) {
        name = first_kw_arg;
        while (*name && (**name != key)) name++;
        if (*name) {
            values[name-argnames] = value;
            continue;
        }
        name = first_kw_arg;
        #if PY_MAJOR_VERSION < 3
        if (likely(PyString_CheckExact(key)) || likely(PyString_Check(key))) {
            while (*name) {
                if ((CYTHON_COMPILING_IN_PYPY || PyString_GET_SIZE(**name) == PyString_GET_SIZE(key))
                        && _PyString_Eq(**name, key)) {
                    values[name-argnames] = value;
                    break;
                }
                name++;
            }
            if (*name) continue;
            else {
                PyObject*** argname = argnames;
                while (argname != first_kw_arg) {
                    if ((**argname == key) || (
                            (CYTHON_COMPILING_IN_PYPY || PyString_GET_SIZE(**argname) == PyString_GET_SIZE(key))
                             && _PyString_Eq(**argname, key))) {
                        goto arg_passed_twice;
                    }
                    argname++;
                }
            }
        } else
        #endif
        if (likely(PyUnicode_Check(key))) {
            while (*name) {
                int cmp = (**name == key) ? 0 :
                #if !CYTHON_COMPILING_IN_PYPY && PY_MAJOR_VERSION >= 3
                    (PyUnicode_GET_SIZE(**name) != PyUnicode_GET_SIZE(key)) ? 1 :
                #endif
                    PyUnicode_Compare(**name, key);
                if (cmp < 0 && unlikely(PyErr_Occurred())) goto bad;
                if (cmp == 0) {
                    values[name-argnames] = value;
                    break;
                }
                name++;
            }
            if (*name) continue;
            else {
                PyObject*** argname = argnames;
                while (argname != first_kw_arg) {
                    int cmp = (**argname == key) ? 0 :
                    #if !CYTHON_COMPILING_IN_PYPY && PY_MAJOR_VERSION >= 3
                        (PyUnicode_GET_SIZE(**argname) != PyUnicode_GET_SIZE(key)) ? 1 :
                    #endif
                        PyUnicode_Compare(**argname, key);
                    if (cmp < 0 && unlikely(PyErr_Occurred())) goto bad;
                    if (cmp == 0) goto arg_passed_twice;
                    argname++;
                }
            }
        } else
            goto invalid_keyword_type;
        if (kwds2) {
            if (unlikely(PyDict_SetItem(kwds2, key, value))) goto bad;
        } else {
            goto invalid_keyword;
        }
    }
    return 0;
arg_passed_twice:
    __Pyx_RaiseDoubleKeywordsError(function_name, key);
    goto bad;
invalid_keyword_type:
    PyErr_Format(PyExc_TypeError,
        "%.200s() keywords must be strings", function_name);
    goto bad;
invalid_keyword:
    PyErr_Format(PyExc_TypeError,
    #if PY_MAJOR_VERSION < 3
        "%.200s() got an unexpected keyword argument '%.200s'",
        function_name, PyString_AsString(key));
    #else
        "%s() got an unexpected keyword argument '%U'",
        function_name, key);
    #endif
bad:
    return -1;
}

/* PyObjectCallNoArg */
  #if CYTHON_COMPILING_IN_CPYTHON
static CYTHON_INLINE PyObject* __Pyx_PyObject_CallNoArg(PyObject *func) {
#if CYTHON_FAST_PYCALL
    if (PyFunction_Check(func)) {
        return __Pyx_PyFunction_FastCall(func, NULL, 0);
    }
#endif
#ifdef __Pyx_CyFunction_USED
    if (likely(PyCFunction_Check(func) || __Pyx_TypeCheck(func, __pyx_CyFunctionType))) {
#else
    if (likely(PyCFunction_Check(func))) {
#endif
        if (likely(PyCFunction_GET_FLAGS(func) & METH_NOARGS)) {
            return __Pyx_PyObject_CallMethO(func, NULL);
        }
    }
    return __Pyx_PyObject_Call(func, __pyx_empty_tuple, NULL);
}
#endif

/* ExtTypeTest */
    static CYTHON_INLINE int __Pyx_TypeTest(PyObject *obj, PyTypeObject *type) {
    if (unlikely(!type)) {
        PyErr_SetString(PyExc_SystemError, "Missing type object");
        return 0;
    }
    if (likely(__Pyx_TypeCheck(obj, type)))
        return 1;
    PyErr_Format(PyExc_TypeError, "Cannot convert %.200s to %.200s",
                 Py_TYPE(obj)->tp_name, type->tp_name);
    return 0;
}

/* ArgTypeTest */
    static int __Pyx__ArgTypeTest(PyObject *obj, PyTypeObject *type, const char *name, int exact)
{
    if (unlikely(!type)) {
        PyErr_SetString(PyExc_SystemError, "Missing type object");
        return 0;
    }
    else if (exact) {
        #if PY_MAJOR_VERSION == 2
        if ((type == &PyBaseString_Type) && likely(__Pyx_PyBaseString_CheckExact(obj))) return 1;
        #endif
    }
    else {
        if (likely(__Pyx_TypeCheck(obj, type))) return 1;
    }
    PyErr_Format(PyExc_TypeError,
        "Argument '%.200s' has incorrect type (expected %.200s, got %.200s)",
        name, type->tp_name, Py_TYPE(obj)->tp_name);
    return 0;
}

/* WriteUnraisableException */
    static void __Pyx_WriteUnraisable(const char *name, CYTHON_UNUSED int clineno,
                                  CYTHON_UNUSED int lineno, CYTHON_UNUSED const char *filename,
                                  int full_traceback, CYTHON_UNUSED int nogil) {
    PyObject *old_exc, *old_val, *old_tb;
    PyObject *ctx;
    __Pyx_PyThreadState_declare
#ifdef WITH_THREAD
    PyGILState_STATE state;
    if (nogil)
        state = PyGILState_Ensure();
#ifdef _MSC_VER
    else state = (PyGILState_STATE)-1;
#endif
#endif
    __Pyx_PyThreadState_assign
    __Pyx_ErrFetch(&old_exc, &old_val, &old_tb);
    if (full_traceback) {
        Py_XINCREF(old_exc);
        Py_XINCREF(old_val);
        Py_XINCREF(old_tb);
        __Pyx_ErrRestore(old_exc, old_val, old_tb);
        PyErr_PrintEx(1);
    }
    #if PY_MAJOR_VERSION < 3
    ctx = PyString_FromString(name);
    #else
    ctx = PyUnicode_FromString(name);
    #endif
    __Pyx_ErrRestore(old_exc, old_val, old_tb);
    if (!ctx) {
        PyErr_WriteUnraisable(Py_None);
    } else {
        PyErr_WriteUnraisable(ctx);
        Py_DECREF(ctx);
    }
#ifdef WITH_THREAD
    if (nogil)
        PyGILState_Release(state);
#endif
}

/* KeywordStringCheck */
    static int __Pyx_CheckKeywordStrings(
    PyObject *kwdict,
    const char* function_name,
    int kw_allowed)
{
    PyObject* key = 0;
    Py_ssize_t pos = 0;
#if CYTHON_COMPILING_IN_PYPY
    if (!kw_allowed && PyDict_Next(kwdict, &pos, &key, 0))
        goto invalid_keyword;
    return 1;
#else
    while (PyDict_Next(kwdict, &pos, &key, 0)) {
        #if PY_MAJOR_VERSION < 3
        if (unlikely(!PyString_Check(key)))
        #endif
            if (unlikely(!PyUnicode_Check(key)))
                goto invalid_keyword_type;
    }
    if ((!kw_allowed) && unlikely(key))
        goto invalid_keyword;
    return 1;
invalid_keyword_type:
    PyErr_Format(PyExc_TypeError,
        "%.200s() keywords must be strings", function_name);
    return 0;
#endif
invalid_keyword:
    PyErr_Format(PyExc_TypeError,
    #if PY_MAJOR_VERSION < 3
        "%.200s() got an unexpected keyword argument '%.200s'",
        function_name, PyString_AsString(key));
    #else
        "%s() got an unexpected keyword argument '%U'",
        function_name, key);
    #endif
    return 0;
}

/* SaveResetException */
    #if CYTHON_FAST_THREAD_STATE
static CYTHON_INLINE void __Pyx__ExceptionSave(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb) {
    #if PY_VERSION_HEX >= 0x030700A2
    *type = tstate->exc_state.exc_type;
    *value = tstate->exc_state.exc_value;
    *tb = tstate->exc_state.exc_traceback;
    #else
    *type = tstate->exc_type;
    *value = tstate->exc_value;
    *tb = tstate->exc_traceback;
    #endif
    Py_XINCREF(*type);
    Py_XINCREF(*value);
    Py_XINCREF(*tb);
}
static CYTHON_INLINE void __Pyx__ExceptionReset(PyThreadState *tstate, PyObject *type, PyObject *value, PyObject *tb) {
    PyObject *tmp_type, *tmp_value, *tmp_tb;
    #if PY_VERSION_HEX >= 0x030700A2
    tmp_type = tstate->exc_state.exc_type;
    tmp_value = tstate->exc_state.exc_value;
    tmp_tb = tstate->exc_state.exc_traceback;
    tstate->exc_state.exc_type = type;
    tstate->exc_state.exc_value = value;
    tstate->exc_state.exc_traceback = tb;
    #else
    tmp_type = tstate->exc_type;
    tmp_value = tstate->exc_value;
    tmp_tb = tstate->exc_traceback;
    tstate->exc_type = type;
    tstate->exc_value = value;
    tstate->exc_traceback = tb;
    #endif
    Py_XDECREF(tmp_type);
    Py_XDECREF(tmp_value);
    Py_XDECREF(tmp_tb);
}
#endif

/* PyErrExceptionMatches */
    #if CYTHON_FAST_THREAD_STATE
static int __Pyx_PyErr_ExceptionMatchesTuple(PyObject *exc_type, PyObject *tuple) {
    Py_ssize_t i, n;
    n = PyTuple_GET_SIZE(tuple);
#if PY_MAJOR_VERSION >= 3
    for (i=0; i<n; i++) {
        if (exc_type == PyTuple_GET_ITEM(tuple, i)) return 1;
    }
#endif
    for (i=0; i<n; i++) {
        if (__Pyx_PyErr_GivenExceptionMatches(exc_type, PyTuple_GET_ITEM(tuple, i))) return 1;
    }
    return 0;
}
static CYTHON_INLINE int __Pyx_PyErr_ExceptionMatchesInState(PyThreadState* tstate, PyObject* err) {
    PyObject *exc_type = tstate->curexc_type;
    if (exc_type == err) return 1;
    if (unlikely(!exc_type)) return 0;
    if (unlikely(PyTuple_Check(err)))
        return __Pyx_PyErr_ExceptionMatchesTuple(exc_type, err);
    return __Pyx_PyErr_GivenExceptionMatches(exc_type, err);
}
#endif

/* GetException */
    #if CYTHON_FAST_THREAD_STATE
static int __Pyx__GetException(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb) {
#else
static int __Pyx_GetException(PyObject **type, PyObject **value, PyObject **tb) {
#endif
    PyObject *local_type, *local_value, *local_tb;
#if CYTHON_FAST_THREAD_STATE
    PyObject *tmp_type, *tmp_value, *tmp_tb;
    local_type = tstate->curexc_type;
    local_value = tstate->curexc_value;
    local_tb = tstate->curexc_traceback;
    tstate->curexc_type = 0;
    tstate->curexc_value = 0;
    tstate->curexc_traceback = 0;
#else
    PyErr_Fetch(&local_type, &local_value, &local_tb);
#endif
    PyErr_NormalizeException(&local_type, &local_value, &local_tb);
#if CYTHON_FAST_THREAD_STATE
    if (unlikely(tstate->curexc_type))
#else
    if (unlikely(PyErr_Occurred()))
#endif
        goto bad;
    #if PY_MAJOR_VERSION >= 3
    if (local_tb) {
        if (unlikely(PyException_SetTraceback(local_value, local_tb) < 0))
            goto bad;
    }
    #endif
    Py_XINCREF(local_tb);
    Py_XINCREF(local_type);
    Py_XINCREF(local_value);
    *type = local_type;
    *value = local_value;
    *tb = local_tb;
#if CYTHON_FAST_THREAD_STATE
    #if PY_VERSION_HEX >= 0x030700A2
    tmp_type = tstate->exc_state.exc_type;
    tmp_value = tstate->exc_state.exc_value;
    tmp_tb = tstate->exc_state.exc_traceback;
    tstate->exc_state.exc_type = local_type;
    tstate->exc_state.exc_value = local_value;
    tstate->exc_state.exc_traceback = local_tb;
    #else
    tmp_type = tstate->exc_type;
    tmp_value = tstate->exc_value;
    tmp_tb = tstate->exc_traceback;
    tstate->exc_type = local_type;
    tstate->exc_value = local_value;
    tstate->exc_traceback = local_tb;
    #endif
    Py_XDECREF(tmp_type);
    Py_XDECREF(tmp_value);
    Py_XDECREF(tmp_tb);
#else
    PyErr_SetExcInfo(local_type, local_value, local_tb);
#endif
    return 0;
bad:
    *type = 0;
    *value = 0;
    *tb = 0;
    Py_XDECREF(local_type);
    Py_XDECREF(local_value);
    Py_XDECREF(local_tb);
    return -1;
}

/* RaiseTooManyValuesToUnpack */
      static CYTHON_INLINE void __Pyx_RaiseTooManyValuesError(Py_ssize_t expected) {
    PyErr_Format(PyExc_ValueError,
                 "too many values to unpack (expected %" CYTHON_FORMAT_SSIZE_T "d)", expected);
}

/* RaiseNeedMoreValuesToUnpack */
      static CYTHON_INLINE void __Pyx_RaiseNeedMoreValuesError(Py_ssize_t index) {
    PyErr_Format(PyExc_ValueError,
                 "need more than %" CYTHON_FORMAT_SSIZE_T "d value%.1s to unpack",
                 index, (index == 1) ? "" : "s");
}

/* IterFinish */
      static CYTHON_INLINE int __Pyx_IterFinish(void) {
#if CYTHON_FAST_THREAD_STATE
    PyThreadState *tstate = __Pyx_PyThreadState_Current;
    PyObject* exc_type = tstate->curexc_type;
    if (unlikely(exc_type)) {
        if (likely(__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) {
            PyObject *exc_value, *exc_tb;
            exc_value = tstate->curexc_value;
            exc_tb = tstate->curexc_traceback;
            tstate->curexc_type = 0;
            tstate->curexc_value = 0;
            tstate->curexc_traceback = 0;
            Py_DECREF(exc_type);
            Py_XDECREF(exc_value);
            Py_XDECREF(exc_tb);
            return 0;
        } else {
            return -1;
        }
    }
    return 0;
#else
    if (unlikely(PyErr_Occurred())) {
        if (likely(PyErr_ExceptionMatches(PyExc_StopIteration))) {
            PyErr_Clear();
            return 0;
        } else {
            return -1;
        }
    }
    return 0;
#endif
}

/* UnpackItemEndCheck */
      static int __Pyx_IternextUnpackEndCheck(PyObject *retval, Py_ssize_t expected) {
    if (unlikely(retval)) {
        Py_DECREF(retval);
        __Pyx_RaiseTooManyValuesError(expected);
        return -1;
    } else {
        return __Pyx_IterFinish();
    }
    return 0;
}

/* IterNext */
      static PyObject *__Pyx_PyIter_Next2Default(PyObject* defval) {
    PyObject* exc_type;
    __Pyx_PyThreadState_declare
    __Pyx_PyThreadState_assign
    exc_type = __Pyx_PyErr_Occurred();
    if (unlikely(exc_type)) {
        if (unlikely(!__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration)))
            return NULL;
        if (defval) {
            __Pyx_PyErr_Clear();
            Py_INCREF(defval);
        }
        return defval;
    }
    if (defval) {
        Py_INCREF(defval);
        return defval;
    }
    __Pyx_PyErr_SetNone(PyExc_StopIteration);
    return NULL;
}
static void __Pyx_PyIter_Next_ErrorNoIterator(PyObject *iterator) {
    PyErr_Format(PyExc_TypeError,
        "%.200s object is not an iterator", Py_TYPE(iterator)->tp_name);
}
static CYTHON_INLINE PyObject *__Pyx_PyIter_Next2(PyObject* iterator, PyObject* defval) {
    PyObject* next;
    iternextfunc iternext = Py_TYPE(iterator)->tp_iternext;
    if (likely(iternext)) {
#if CYTHON_USE_TYPE_SLOTS
        next = iternext(iterator);
        if (likely(next))
            return next;
        #if PY_VERSION_HEX >= 0x02070000
        if (unlikely(iternext == &_PyObject_NextNotImplemented))
            return NULL;
        #endif
#else
        next = PyIter_Next(iterator);
        if (likely(next))
            return next;
#endif
    } else if (CYTHON_USE_TYPE_SLOTS || !PyIter_Check(iterator)) {
        __Pyx_PyIter_Next_ErrorNoIterator(iterator);
        return NULL;
    }
    return __Pyx_PyIter_Next2Default(defval);
}

/* SetVTable */
      static int __Pyx_SetVtable(PyObject *dict, void *vtable) {
#if PY_VERSION_HEX >= 0x02070000
    PyObject *ob = PyCapsule_New(vtable, 0, 0);
#else
    PyObject *ob = PyCObject_FromVoidPtr(vtable, 0);
#endif
    if (!ob)
        goto bad;
    if (PyDict_SetItem(dict, __pyx_n_s_pyx_vtable, ob) < 0)
        goto bad;
    Py_DECREF(ob);
    return 0;
bad:
    Py_XDECREF(ob);
    return -1;
}

/* SetupReduce */
      static int __Pyx_setup_reduce_is_named(PyObject* meth, PyObject* name) {
  int ret;
  PyObject *name_attr;
  name_attr = __Pyx_PyObject_GetAttrStr(meth, __pyx_n_s_name);
  if (likely(name_attr)) {
      ret = PyObject_RichCompareBool(name_attr, name, Py_EQ);
  } else {
      ret = -1;
  }
  if (unlikely(ret < 0)) {
      PyErr_Clear();
      ret = 0;
  }
  Py_XDECREF(name_attr);
  return ret;
}
static int __Pyx_setup_reduce(PyObject* type_obj) {
    int ret = 0;
    PyObject *object_reduce = NULL;
    PyObject *object_reduce_ex = NULL;
    PyObject *reduce = NULL;
    PyObject *reduce_ex = NULL;
    PyObject *reduce_cython = NULL;
    PyObject *setstate = NULL;
    PyObject *setstate_cython = NULL;
#if CYTHON_USE_PYTYPE_LOOKUP
    if (_PyType_Lookup((PyTypeObject*)type_obj, __pyx_n_s_getstate)) goto GOOD;
#else
    if (PyObject_HasAttr(type_obj, __pyx_n_s_getstate)) goto GOOD;
#endif
#if CYTHON_USE_PYTYPE_LOOKUP
    object_reduce_ex = _PyType_Lookup(&PyBaseObject_Type, __pyx_n_s_reduce_ex); if (!object_reduce_ex) goto BAD;
#else
    object_reduce_ex = __Pyx_PyObject_GetAttrStr((PyObject*)&PyBaseObject_Type, __pyx_n_s_reduce_ex); if (!object_reduce_ex) goto BAD;
#endif
    reduce_ex = __Pyx_PyObject_GetAttrStr(type_obj, __pyx_n_s_reduce_ex); if (unlikely(!reduce_ex)) goto BAD;
    if (reduce_ex == object_reduce_ex) {
#if CYTHON_USE_PYTYPE_LOOKUP
        object_reduce = _PyType_Lookup(&PyBaseObject_Type, __pyx_n_s_reduce); if (!object_reduce) goto BAD;
#else
        object_reduce = __Pyx_PyObject_GetAttrStr((PyObject*)&PyBaseObject_Type, __pyx_n_s_reduce); if (!object_reduce) goto BAD;
#endif
        reduce = __Pyx_PyObject_GetAttrStr(type_obj, __pyx_n_s_reduce); if (unlikely(!reduce)) goto BAD;
        if (reduce == object_reduce || __Pyx_setup_reduce_is_named(reduce, __pyx_n_s_reduce_cython)) {
            reduce_cython = __Pyx_PyObject_GetAttrStr(type_obj, __pyx_n_s_reduce_cython); if (unlikely(!reduce_cython)) goto BAD;
            ret = PyDict_SetItem(((PyTypeObject*)type_obj)->tp_dict, __pyx_n_s_reduce, reduce_cython); if (unlikely(ret < 0)) goto BAD;
            ret = PyDict_DelItem(((PyTypeObject*)type_obj)->tp_dict, __pyx_n_s_reduce_cython); if (unlikely(ret < 0)) goto BAD;
            setstate = __Pyx_PyObject_GetAttrStr(type_obj, __pyx_n_s_setstate);
            if (!setstate) PyErr_Clear();
            if (!setstate || __Pyx_setup_reduce_is_named(setstate, __pyx_n_s_setstate_cython)) {
                setstate_cython = __Pyx_PyObject_GetAttrStr(type_obj, __pyx_n_s_setstate_cython); if (unlikely(!setstate_cython)) goto BAD;
                ret = PyDict_SetItem(((PyTypeObject*)type_obj)->tp_dict, __pyx_n_s_setstate, setstate_cython); if (unlikely(ret < 0)) goto BAD;
                ret = PyDict_DelItem(((PyTypeObject*)type_obj)->tp_dict, __pyx_n_s_setstate_cython); if (unlikely(ret < 0)) goto BAD;
            }
            PyType_Modified((PyTypeObject*)type_obj);
        }
    }
    goto GOOD;
BAD:
    if (!PyErr_Occurred())
        PyErr_Format(PyExc_RuntimeError, "Unable to initialize pickling for %s", ((PyTypeObject*)type_obj)->tp_name);
    ret = -1;
GOOD:
#if !CYTHON_USE_PYTYPE_LOOKUP
    Py_XDECREF(object_reduce);
    Py_XDECREF(object_reduce_ex);
#endif
    Py_XDECREF(reduce);
    Py_XDECREF(reduce_ex);
    Py_XDECREF(reduce_cython);
    Py_XDECREF(setstate);
    Py_XDECREF(setstate_cython);
    return ret;
}

/* Import */
      static PyObject *__Pyx_Import(PyObject *name, PyObject *from_list, int level) {
    PyObject *empty_list = 0;
    PyObject *module = 0;
    PyObject *global_dict = 0;
    PyObject *empty_dict = 0;
    PyObject *list;
    #if PY_MAJOR_VERSION < 3
    PyObject *py_import;
    py_import = __Pyx_PyObject_GetAttrStr(__pyx_b, __pyx_n_s_import);
    if (!py_import)
        goto bad;
    #endif
    if (from_list)
        list = from_list;
    else {
        empty_list = PyList_New(0);
        if (!empty_list)
            goto bad;
        list = empty_list;
    }
    global_dict = PyModule_GetDict(__pyx_m);
    if (!global_dict)
        goto bad;
    empty_dict = PyDict_New();
    if (!empty_dict)
        goto bad;
    {
        #if PY_MAJOR_VERSION >= 3
        if (level == -1) {
            if (strchr(__Pyx_MODULE_NAME, '.')) {
                module = PyImport_ImportModuleLevelObject(
                    name, global_dict, empty_dict, list, 1);
                if (!module) {
                    if (!PyErr_ExceptionMatches(PyExc_ImportError))
                        goto bad;
                    PyErr_Clear();
                }
            }
            level = 0;
        }
        #endif
        if (!module) {
            #if PY_MAJOR_VERSION < 3
            PyObject *py_level = PyInt_FromLong(level);
            if (!py_level)
                goto bad;
            module = PyObject_CallFunctionObjArgs(py_import,
                name, global_dict, empty_dict, list, py_level, NULL);
            Py_DECREF(py_level);
            #else
            module = PyImport_ImportModuleLevelObject(
                name, global_dict, empty_dict, list, level);
            #endif
        }
    }
bad:
    #if PY_MAJOR_VERSION < 3
    Py_XDECREF(py_import);
    #endif
    Py_XDECREF(empty_list);
    Py_XDECREF(empty_dict);
    return module;
}

/* CalculateMetaclass */
      static PyObject *__Pyx_CalculateMetaclass(PyTypeObject *metaclass, PyObject *bases) {
    Py_ssize_t i, nbases = PyTuple_GET_SIZE(bases);
    for (i=0; i < nbases; i++) {
        PyTypeObject *tmptype;
        PyObject *tmp = PyTuple_GET_ITEM(bases, i);
        tmptype = Py_TYPE(tmp);
#if PY_MAJOR_VERSION < 3
        if (tmptype == &PyClass_Type)
            continue;
#endif
        if (!metaclass) {
            metaclass = tmptype;
            continue;
        }
        if (PyType_IsSubtype(metaclass, tmptype))
            continue;
        if (PyType_IsSubtype(tmptype, metaclass)) {
            metaclass = tmptype;
            continue;
        }
        PyErr_SetString(PyExc_TypeError,
                        "metaclass conflict: "
                        "the metaclass of a derived class "
                        "must be a (non-strict) subclass "
                        "of the metaclasses of all its bases");
        return NULL;
    }
    if (!metaclass) {
#if PY_MAJOR_VERSION < 3
        metaclass = &PyClass_Type;
#else
        metaclass = &PyType_Type;
#endif
    }
    Py_INCREF((PyObject*) metaclass);
    return (PyObject*) metaclass;
}

/* Py3ClassCreate */
      static PyObject *__Pyx_Py3MetaclassPrepare(PyObject *metaclass, PyObject *bases, PyObject *name,
                                           PyObject *qualname, PyObject *mkw, PyObject *modname, PyObject *doc) {
    PyObject *ns;
    if (metaclass) {
        PyObject *prep = __Pyx_PyObject_GetAttrStr(metaclass, __pyx_n_s_prepare);
        if (prep) {
            PyObject *pargs = PyTuple_Pack(2, name, bases);
            if (unlikely(!pargs)) {
                Py_DECREF(prep);
                return NULL;
            }
            ns = PyObject_Call(prep, pargs, mkw);
            Py_DECREF(prep);
            Py_DECREF(pargs);
        } else {
            if (unlikely(!PyErr_ExceptionMatches(PyExc_AttributeError)))
                return NULL;
            PyErr_Clear();
            ns = PyDict_New();
        }
    } else {
        ns = PyDict_New();
    }
    if (unlikely(!ns))
        return NULL;
    if (unlikely(PyObject_SetItem(ns, __pyx_n_s_module, modname) < 0)) goto bad;
    if (unlikely(PyObject_SetItem(ns, __pyx_n_s_qualname, qualname) < 0)) goto bad;
    if (unlikely(doc && PyObject_SetItem(ns, __pyx_n_s_doc, doc) < 0)) goto bad;
    return ns;
bad:
    Py_DECREF(ns);
    return NULL;
}
static PyObject *__Pyx_Py3ClassCreate(PyObject *metaclass, PyObject *name, PyObject *bases,
                                      PyObject *dict, PyObject *mkw,
                                      int calculate_metaclass, int allow_py2_metaclass) {
    PyObject *result, *margs;
    PyObject *owned_metaclass = NULL;
    if (allow_py2_metaclass) {
        owned_metaclass = PyObject_GetItem(dict, __pyx_n_s_metaclass);
        if (owned_metaclass) {
            metaclass = owned_metaclass;
        } else if (likely(PyErr_ExceptionMatches(PyExc_KeyError))) {
            PyErr_Clear();
        } else {
            return NULL;
        }
    }
    if (calculate_metaclass && (!metaclass || PyType_Check(metaclass))) {
        metaclass = __Pyx_CalculateMetaclass((PyTypeObject*) metaclass, bases);
        Py_XDECREF(owned_metaclass);
        if (unlikely(!metaclass))
            return NULL;
        owned_metaclass = metaclass;
    }
    margs = PyTuple_Pack(3, name, bases, dict);
    if (unlikely(!margs)) {
        result = NULL;
    } else {
        result = PyObject_Call(metaclass, margs, mkw);
        Py_DECREF(margs);
    }
    Py_XDECREF(owned_metaclass);
    return result;
}

/* GetNameInClass */
      static PyObject *__Pyx_GetGlobalNameAfterAttributeLookup(PyObject *name) {
    __Pyx_PyThreadState_declare
    __Pyx_PyThreadState_assign
    if (unlikely(!__Pyx_PyErr_ExceptionMatches(PyExc_AttributeError)))
        return NULL;
    __Pyx_PyErr_Clear();
    return __Pyx_GetModuleGlobalName(name);
}
static PyObject *__Pyx_GetNameInClass(PyObject *nmspace, PyObject *name) {
    PyObject *result;
    result = __Pyx_PyObject_GetAttrStr(nmspace, name);
    if (!result) {
        result = __Pyx_GetGlobalNameAfterAttributeLookup(name);
    }
    return result;
}

/* ClassMethod */
      static PyObject* __Pyx_Method_ClassMethod(PyObject *method) {
#if CYTHON_COMPILING_IN_PYPY && PYPY_VERSION_NUM <= 0x05080000
    if (PyObject_TypeCheck(method, &PyWrapperDescr_Type)) {
        return PyClassMethod_New(method);
    }
#else
#if CYTHON_COMPILING_IN_PYSTON || CYTHON_COMPILING_IN_PYPY
    if (PyMethodDescr_Check(method)) {
#else
    static PyTypeObject *methoddescr_type = NULL;
    if (methoddescr_type == NULL) {
       PyObject *meth = PyObject_GetAttrString((PyObject*)&PyList_Type, "append");
       if (!meth) return NULL;
       methoddescr_type = Py_TYPE(meth);
       Py_DECREF(meth);
    }
    if (__Pyx_TypeCheck(method, methoddescr_type)) {
#endif
        PyMethodDescrObject *descr = (PyMethodDescrObject *)method;
        #if PY_VERSION_HEX < 0x03020000
        PyTypeObject *d_type = descr->d_type;
        #else
        PyTypeObject *d_type = descr->d_common.d_type;
        #endif
        return PyDescr_NewClassMethod(d_type, descr->d_method);
    }
#endif
    else if (PyMethod_Check(method)) {
        return PyClassMethod_New(PyMethod_GET_FUNCTION(method));
    }
    else if (PyCFunction_Check(method)) {
        return PyClassMethod_New(method);
    }
#ifdef __Pyx_CyFunction_USED
    else if (__Pyx_TypeCheck(method, __pyx_CyFunctionType)) {
        return PyClassMethod_New(method);
    }
#endif
    PyErr_SetString(PyExc_TypeError,
                   "Class-level classmethod() can only be called on "
                   "a method_descriptor or instance method.");
    return NULL;
}

/* FetchCommonType */
        static PyTypeObject* __Pyx_FetchCommonType(PyTypeObject* type) {
    PyObject* fake_module;
    PyTypeObject* cached_type = NULL;
    fake_module = PyImport_AddModule((char*) "_cython_" CYTHON_ABI);
    if (!fake_module) return NULL;
    Py_INCREF(fake_module);
    cached_type = (PyTypeObject*) PyObject_GetAttrString(fake_module, type->tp_name);
    if (cached_type) {
        if (!PyType_Check((PyObject*)cached_type)) {
            PyErr_Format(PyExc_TypeError,
                "Shared Cython type %.200s is not a type object",
                type->tp_name);
            goto bad;
        }
        if (cached_type->tp_basicsize != type->tp_basicsize) {
            PyErr_Format(PyExc_TypeError,
                "Shared Cython type %.200s has the wrong size, try recompiling",
                type->tp_name);
            goto bad;
        }
    } else {
        if (!PyErr_ExceptionMatches(PyExc_AttributeError)) goto bad;
        PyErr_Clear();
        if (PyType_Ready(type) < 0) goto bad;
        if (PyObject_SetAttrString(fake_module, type->tp_name, (PyObject*) type) < 0)
            goto bad;
        Py_INCREF(type);
        cached_type = type;
    }
done:
    Py_DECREF(fake_module);
    return cached_type;
bad:
    Py_XDECREF(cached_type);
    cached_type = NULL;
    goto done;
}

/* CythonFunction */
        static PyObject *
__Pyx_CyFunction_get_doc(__pyx_CyFunctionObject *op, CYTHON_UNUSED void *closure)
{
    if (unlikely(op->func_doc == NULL)) {
        if (op->func.m_ml->ml_doc) {
#if PY_MAJOR_VERSION >= 3
            op->func_doc = PyUnicode_FromString(op->func.m_ml->ml_doc);
#else
            op->func_doc = PyString_FromString(op->func.m_ml->ml_doc);
#endif
            if (unlikely(op->func_doc == NULL))
                return NULL;
        } else {
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    Py_INCREF(op->func_doc);
    return op->func_doc;
}
static int
__Pyx_CyFunction_set_doc(__pyx_CyFunctionObject *op, PyObject *value)
{
    PyObject *tmp = op->func_doc;
    if (value == NULL) {
        value = Py_None;
    }
    Py_INCREF(value);
    op->func_doc = value;
    Py_XDECREF(tmp);
    return 0;
}
static PyObject *
__Pyx_CyFunction_get_name(__pyx_CyFunctionObject *op)
{
    if (unlikely(op->func_name == NULL)) {
#if PY_MAJOR_VERSION >= 3
        op->func_name = PyUnicode_InternFromString(op->func.m_ml->ml_name);
#else
        op->func_name = PyString_InternFromString(op->func.m_ml->ml_name);
#endif
        if (unlikely(op->func_name == NULL))
            return NULL;
    }
    Py_INCREF(op->func_name);
    return op->func_name;
}
static int
__Pyx_CyFunction_set_name(__pyx_CyFunctionObject *op, PyObject *value)
{
    PyObject *tmp;
#if PY_MAJOR_VERSION >= 3
    if (unlikely(value == NULL || !PyUnicode_Check(value))) {
#else
    if (unlikely(value == NULL || !PyString_Check(value))) {
#endif
        PyErr_SetString(PyExc_TypeError,
                        "__name__ must be set to a string object");
        return -1;
    }
    tmp = op->func_name;
    Py_INCREF(value);
    op->func_name = value;
    Py_XDECREF(tmp);
    return 0;
}
static PyObject *
__Pyx_CyFunction_get_qualname(__pyx_CyFunctionObject *op)
{
    Py_INCREF(op->func_qualname);
    return op->func_qualname;
}
static int
__Pyx_CyFunction_set_qualname(__pyx_CyFunctionObject *op, PyObject *value)
{
    PyObject *tmp;
#if PY_MAJOR_VERSION >= 3
    if (unlikely(value == NULL || !PyUnicode_Check(value))) {
#else
    if (unlikely(value == NULL || !PyString_Check(value))) {
#endif
        PyErr_SetString(PyExc_TypeError,
                        "__qualname__ must be set to a string object");
        return -1;
    }
    tmp = op->func_qualname;
    Py_INCREF(value);
    op->func_qualname = value;
    Py_XDECREF(tmp);
    return 0;
}
static PyObject *
__Pyx_CyFunction_get_self(__pyx_CyFunctionObject *m, CYTHON_UNUSED void *closure)
{
    PyObject *self;
    self = m->func_closure;
    if (self == NULL)
        self = Py_None;
    Py_INCREF(self);
    return self;
}
static PyObject *
__Pyx_CyFunction_get_dict(__pyx_CyFunctionObject *op)
{
    if (unlikely(op->func_dict == NULL)) {
        op->func_dict = PyDict_New();
        if (unlikely(op->func_dict == NULL))
            return NULL;
    }
    Py_INCREF(op->func_dict);
    return op->func_dict;
}
static int
__Pyx_CyFunction_set_dict(__pyx_CyFunctionObject *op, PyObject *value)
{
    PyObject *tmp;
    if (unlikely(value == NULL)) {
        PyErr_SetString(PyExc_TypeError,
               "function's dictionary may not be deleted");
        return -1;
    }
    if (unlikely(!PyDict_Check(value))) {
        PyErr_SetString(PyExc_TypeError,
               "setting function's dictionary to a non-dict");
        return -1;
    }
    tmp = op->func_dict;
    Py_INCREF(value);
    op->func_dict = value;
    Py_XDECREF(tmp);
    return 0;
}
static PyObject *
__Pyx_CyFunction_get_globals(__pyx_CyFunctionObject *op)
{
    Py_INCREF(op->func_globals);
    return op->func_globals;
}
static PyObject *
__Pyx_CyFunction_get_closure(CYTHON_UNUSED __pyx_CyFunctionObject *op)
{
    Py_INCREF(Py_None);
    return Py_None;
}
static PyObject *
__Pyx_CyFunction_get_code(__pyx_CyFunctionObject *op)
{
    PyObject* result = (op->func_code) ? op->func_code : Py_None;
    Py_INCREF(result);
    return result;
}
static int
__Pyx_CyFunction_init_defaults(__pyx_CyFunctionObject *op) {
    int result = 0;
    PyObject *res = op->defaults_getter((PyObject *) op);
    if (unlikely(!res))
        return -1;
    #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
    op->defaults_tuple = PyTuple_GET_ITEM(res, 0);
    Py_INCREF(op->defaults_tuple);
    op->defaults_kwdict = PyTuple_GET_ITEM(res, 1);
    Py_INCREF(op->defaults_kwdict);
    #else
    op->defaults_tuple = PySequence_ITEM(res, 0);
    if (unlikely(!op->defaults_tuple)) result = -1;
    else {
        op->defaults_kwdict = PySequence_ITEM(res, 1);
        if (unlikely(!op->defaults_kwdict)) result = -1;
    }
    #endif
    Py_DECREF(res);
    return result;
}
static int
__Pyx_CyFunction_set_defaults(__pyx_CyFunctionObject *op, PyObject* value) {
    PyObject* tmp;
    if (!value) {
        value = Py_None;
    } else if (value != Py_None && !PyTuple_Check(value)) {
        PyErr_SetString(PyExc_TypeError,
                        "__defaults__ must be set to a tuple object");
        return -1;
    }
    Py_INCREF(value);
    tmp = op->defaults_tuple;
    op->defaults_tuple = value;
    Py_XDECREF(tmp);
    return 0;
}
static PyObject *
__Pyx_CyFunction_get_defaults(__pyx_CyFunctionObject *op) {
    PyObject* result = op->defaults_tuple;
    if (unlikely(!result)) {
        if (op->defaults_getter) {
            if (__Pyx_CyFunction_init_defaults(op) < 0) return NULL;
            result = op->defaults_tuple;
        } else {
            result = Py_None;
        }
    }
    Py_INCREF(result);
    return result;
}
static int
__Pyx_CyFunction_set_kwdefaults(__pyx_CyFunctionObject *op, PyObject* value) {
    PyObject* tmp;
    if (!value) {
        value = Py_None;
    } else if (value != Py_None && !PyDict_Check(value)) {
        PyErr_SetString(PyExc_TypeError,
                        "__kwdefaults__ must be set to a dict object");
        return -1;
    }
    Py_INCREF(value);
    tmp = op->defaults_kwdict;
    op->defaults_kwdict = value;
    Py_XDECREF(tmp);
    return 0;
}
static PyObject *
__Pyx_CyFunction_get_kwdefaults(__pyx_CyFunctionObject *op) {
    PyObject* result = op->defaults_kwdict;
    if (unlikely(!result)) {
        if (op->defaults_getter) {
            if (__Pyx_CyFunction_init_defaults(op) < 0) return NULL;
            result = op->defaults_kwdict;
        } else {
            result = Py_None;
        }
    }
    Py_INCREF(result);
    return result;
}
static int
__Pyx_CyFunction_set_annotations(__pyx_CyFunctionObject *op, PyObject* value) {
    PyObject* tmp;
    if (!value || value == Py_None) {
        value = NULL;
    } else if (!PyDict_Check(value)) {
        PyErr_SetString(PyExc_TypeError,
                        "__annotations__ must be set to a dict object");
        return -1;
    }
    Py_XINCREF(value);
    tmp = op->func_annotations;
    op->func_annotations = value;
    Py_XDECREF(tmp);
    return 0;
}
static PyObject *
__Pyx_CyFunction_get_annotations(__pyx_CyFunctionObject *op) {
    PyObject* result = op->func_annotations;
    if (unlikely(!result)) {
        result = PyDict_New();
        if (unlikely(!result)) return NULL;
        op->func_annotations = result;
    }
    Py_INCREF(result);
    return result;
}
static PyGetSetDef __pyx_CyFunction_getsets[] = {
    {(char *) "func_doc", (getter)__Pyx_CyFunction_get_doc, (setter)__Pyx_CyFunction_set_doc, 0, 0},
    {(char *) "__doc__",  (getter)__Pyx_CyFunction_get_doc, (setter)__Pyx_CyFunction_set_doc, 0, 0},
    {(char *) "func_name", (getter)__Pyx_CyFunction_get_name, (setter)__Pyx_CyFunction_set_name, 0, 0},
    {(char *) "__name__", (getter)__Pyx_CyFunction_get_name, (setter)__Pyx_CyFunction_set_name, 0, 0},
    {(char *) "__qualname__", (getter)__Pyx_CyFunction_get_qualname, (setter)__Pyx_CyFunction_set_qualname, 0, 0},
    {(char *) "__self__", (getter)__Pyx_CyFunction_get_self, 0, 0, 0},
    {(char *) "func_dict", (getter)__Pyx_CyFunction_get_dict, (setter)__Pyx_CyFunction_set_dict, 0, 0},
    {(char *) "__dict__", (getter)__Pyx_CyFunction_get_dict, (setter)__Pyx_CyFunction_set_dict, 0, 0},
    {(char *) "func_globals", (getter)__Pyx_CyFunction_get_globals, 0, 0, 0},
    {(char *) "__globals__", (getter)__Pyx_CyFunction_get_globals, 0, 0, 0},
    {(char *) "func_closure", (getter)__Pyx_CyFunction_get_closure, 0, 0, 0},
    {(char *) "__closure__", (getter)__Pyx_CyFunction_get_closure, 0, 0, 0},
    {(char *) "func_code", (getter)__Pyx_CyFunction_get_code, 0, 0, 0},
    {(char *) "__code__", (getter)__Pyx_CyFunction_get_code, 0, 0, 0},
    {(char *) "func_defaults", (getter)__Pyx_CyFunction_get_defaults, (setter)__Pyx_CyFunction_set_defaults, 0, 0},
    {(char *) "__defaults__", (getter)__Pyx_CyFunction_get_defaults, (setter)__Pyx_CyFunction_set_defaults, 0, 0},
    {(char *) "__kwdefaults__", (getter)__Pyx_CyFunction_get_kwdefaults, (setter)__Pyx_CyFunction_set_kwdefaults, 0, 0},
    {(char *) "__annotations__", (getter)__Pyx_CyFunction_get_annotations, (setter)__Pyx_CyFunction_set_annotations, 0, 0},
    {0, 0, 0, 0, 0}
};
static PyMemberDef __pyx_CyFunction_members[] = {
    {(char *) "__module__", T_OBJECT, offsetof(PyCFunctionObject, m_module), PY_WRITE_RESTRICTED, 0},
    {0, 0, 0,  0, 0}
};
static PyObject *
__Pyx_CyFunction_reduce(__pyx_CyFunctionObject *m, CYTHON_UNUSED PyObject *args)
{
#if PY_MAJOR_VERSION >= 3
    return PyUnicode_FromString(m->func.m_ml->ml_name);
#else
    return PyString_FromString(m->func.m_ml->ml_name);
#endif
}
static PyMethodDef __pyx_CyFunction_methods[] = {
    {"__reduce__", (PyCFunction)__Pyx_CyFunction_reduce, METH_VARARGS, 0},
    {0, 0, 0, 0}
};
#if PY_VERSION_HEX < 0x030500A0
#define __Pyx_CyFunction_weakreflist(cyfunc) ((cyfunc)->func_weakreflist)
#else
#define __Pyx_CyFunction_weakreflist(cyfunc) ((cyfunc)->func.m_weakreflist)
#endif
static PyObject *__Pyx_CyFunction_New(PyTypeObject *type, PyMethodDef *ml, int flags, PyObject* qualname,
                                      PyObject *closure, PyObject *module, PyObject* globals, PyObject* code) {
    __pyx_CyFunctionObject *op = PyObject_GC_New(__pyx_CyFunctionObject, type);
    if (op == NULL)
        return NULL;
    op->flags = flags;
    __Pyx_CyFunction_weakreflist(op) = NULL;
    op->func.m_ml = ml;
    op->func.m_self = (PyObject *) op;
    Py_XINCREF(closure);
    op->func_closure = closure;
    Py_XINCREF(module);
    op->func.m_module = module;
    op->func_dict = NULL;
    op->func_name = NULL;
    Py_INCREF(qualname);
    op->func_qualname = qualname;
    op->func_doc = NULL;
    op->func_classobj = NULL;
    op->func_globals = globals;
    Py_INCREF(op->func_globals);
    Py_XINCREF(code);
    op->func_code = code;
    op->defaults_pyobjects = 0;
    op->defaults = NULL;
    op->defaults_tuple = NULL;
    op->defaults_kwdict = NULL;
    op->defaults_getter = NULL;
    op->func_annotations = NULL;
    PyObject_GC_Track(op);
    return (PyObject *) op;
}
static int
__Pyx_CyFunction_clear(__pyx_CyFunctionObject *m)
{
    Py_CLEAR(m->func_closure);
    Py_CLEAR(m->func.m_module);
    Py_CLEAR(m->func_dict);
    Py_CLEAR(m->func_name);
    Py_CLEAR(m->func_qualname);
    Py_CLEAR(m->func_doc);
    Py_CLEAR(m->func_globals);
    Py_CLEAR(m->func_code);
    Py_CLEAR(m->func_classobj);
    Py_CLEAR(m->defaults_tuple);
    Py_CLEAR(m->defaults_kwdict);
    Py_CLEAR(m->func_annotations);
    if (m->defaults) {
        PyObject **pydefaults = __Pyx_CyFunction_Defaults(PyObject *, m);
        int i;
        for (i = 0; i < m->defaults_pyobjects; i++)
            Py_XDECREF(pydefaults[i]);
        PyObject_Free(m->defaults);
        m->defaults = NULL;
    }
    return 0;
}
static void __Pyx__CyFunction_dealloc(__pyx_CyFunctionObject *m)
{
    if (__Pyx_CyFunction_weakreflist(m) != NULL)
        PyObject_ClearWeakRefs((PyObject *) m);
    __Pyx_CyFunction_clear(m);
    PyObject_GC_Del(m);
}
static void __Pyx_CyFunction_dealloc(__pyx_CyFunctionObject *m)
{
    PyObject_GC_UnTrack(m);
    __Pyx__CyFunction_dealloc(m);
}
static int __Pyx_CyFunction_traverse(__pyx_CyFunctionObject *m, visitproc visit, void *arg)
{
    Py_VISIT(m->func_closure);
    Py_VISIT(m->func.m_module);
    Py_VISIT(m->func_dict);
    Py_VISIT(m->func_name);
    Py_VISIT(m->func_qualname);
    Py_VISIT(m->func_doc);
    Py_VISIT(m->func_globals);
    Py_VISIT(m->func_code);
    Py_VISIT(m->func_classobj);
    Py_VISIT(m->defaults_tuple);
    Py_VISIT(m->defaults_kwdict);
    if (m->defaults) {
        PyObject **pydefaults = __Pyx_CyFunction_Defaults(PyObject *, m);
        int i;
        for (i = 0; i < m->defaults_pyobjects; i++)
            Py_VISIT(pydefaults[i]);
    }
    return 0;
}
static PyObject *__Pyx_CyFunction_descr_get(PyObject *func, PyObject *obj, PyObject *type)
{
    __pyx_CyFunctionObject *m = (__pyx_CyFunctionObject *) func;
    if (m->flags & __Pyx_CYFUNCTION_STATICMETHOD) {
        Py_INCREF(func);
        return func;
    }
    if (m->flags & __Pyx_CYFUNCTION_CLASSMETHOD) {
        if (type == NULL)
            type = (PyObject *)(Py_TYPE(obj));
        return __Pyx_PyMethod_New(func, type, (PyObject *)(Py_TYPE(type)));
    }
    if (obj == Py_None)
        obj = NULL;
    return __Pyx_PyMethod_New(func, obj, type);
}
static PyObject*
__Pyx_CyFunction_repr(__pyx_CyFunctionObject *op)
{
#if PY_MAJOR_VERSION >= 3
    return PyUnicode_FromFormat("<cyfunction %U at %p>",
                                op->func_qualname, (void *)op);
#else
    return PyString_FromFormat("<cyfunction %s at %p>",
                               PyString_AsString(op->func_qualname), (void *)op);
#endif
}
static PyObject * __Pyx_CyFunction_CallMethod(PyObject *func, PyObject *self, PyObject *arg, PyObject *kw) {
    PyCFunctionObject* f = (PyCFunctionObject*)func;
    PyCFunction meth = f->m_ml->ml_meth;
    Py_ssize_t size;
    switch (f->m_ml->ml_flags & (METH_VARARGS | METH_KEYWORDS | METH_NOARGS | METH_O)) {
    case METH_VARARGS:
        if (likely(kw == NULL || PyDict_Size(kw) == 0))
            return (*meth)(self, arg);
        break;
    case METH_VARARGS | METH_KEYWORDS:
        return (*(PyCFunctionWithKeywords)meth)(self, arg, kw);
    case METH_NOARGS:
        if (likely(kw == NULL || PyDict_Size(kw) == 0)) {
            size = PyTuple_GET_SIZE(arg);
            if (likely(size == 0))
                return (*meth)(self, NULL);
            PyErr_Format(PyExc_TypeError,
                "%.200s() takes no arguments (%" CYTHON_FORMAT_SSIZE_T "d given)",
                f->m_ml->ml_name, size);
            return NULL;
        }
        break;
    case METH_O:
        if (likely(kw == NULL || PyDict_Size(kw) == 0)) {
            size = PyTuple_GET_SIZE(arg);
            if (likely(size == 1)) {
                PyObject *result, *arg0;
                #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
                arg0 = PyTuple_GET_ITEM(arg, 0);
                #else
                arg0 = PySequence_ITEM(arg, 0); if (unlikely(!arg0)) return NULL;
                #endif
                result = (*meth)(self, arg0);
                #if !(CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS)
                Py_DECREF(arg0);
                #endif
                return result;
            }
            PyErr_Format(PyExc_TypeError,
                "%.200s() takes exactly one argument (%" CYTHON_FORMAT_SSIZE_T "d given)",
                f->m_ml->ml_name, size);
            return NULL;
        }
        break;
    default:
        PyErr_SetString(PyExc_SystemError, "Bad call flags in "
                        "__Pyx_CyFunction_Call. METH_OLDARGS is no "
                        "longer supported!");
        return NULL;
    }
    PyErr_Format(PyExc_TypeError, "%.200s() takes no keyword arguments",
                 f->m_ml->ml_name);
    return NULL;
}
static CYTHON_INLINE PyObject *__Pyx_CyFunction_Call(PyObject *func, PyObject *arg, PyObject *kw) {
    return __Pyx_CyFunction_CallMethod(func, ((PyCFunctionObject*)func)->m_self, arg, kw);
}
static PyObject *__Pyx_CyFunction_CallAsMethod(PyObject *func, PyObject *args, PyObject *kw) {
    PyObject *result;
    __pyx_CyFunctionObject *cyfunc = (__pyx_CyFunctionObject *) func;
    if ((cyfunc->flags & __Pyx_CYFUNCTION_CCLASS) && !(cyfunc->flags & __Pyx_CYFUNCTION_STATICMETHOD)) {
        Py_ssize_t argc;
        PyObject *new_args;
        PyObject *self;
        argc = PyTuple_GET_SIZE(args);
        new_args = PyTuple_GetSlice(args, 1, argc);
        if (unlikely(!new_args))
            return NULL;
        self = PyTuple_GetItem(args, 0);
        if (unlikely(!self)) {
            Py_DECREF(new_args);
            return NULL;
        }
        result = __Pyx_CyFunction_CallMethod(func, self, new_args, kw);
        Py_DECREF(new_args);
    } else {
        result = __Pyx_CyFunction_Call(func, args, kw);
    }
    return result;
}
static PyTypeObject __pyx_CyFunctionType_type = {
    PyVarObject_HEAD_INIT(0, 0)
    "cython_function_or_method",
    sizeof(__pyx_CyFunctionObject),
    0,
    (destructor) __Pyx_CyFunction_dealloc,
    0,
    0,
    0,
#if PY_MAJOR_VERSION < 3
    0,
#else
    0,
#endif
    (reprfunc) __Pyx_CyFunction_repr,
    0,
    0,
    0,
    0,
    __Pyx_CyFunction_CallAsMethod,
    0,
    0,
    0,
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC,
    0,
    (traverseproc) __Pyx_CyFunction_traverse,
    (inquiry) __Pyx_CyFunction_clear,
    0,
#if PY_VERSION_HEX < 0x030500A0
    offsetof(__pyx_CyFunctionObject, func_weakreflist),
#else
    offsetof(PyCFunctionObject, m_weakreflist),
#endif
    0,
    0,
    __pyx_CyFunction_methods,
    __pyx_CyFunction_members,
    __pyx_CyFunction_getsets,
    0,
    0,
    __Pyx_CyFunction_descr_get,
    0,
    offsetof(__pyx_CyFunctionObject, func_dict),
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
#if PY_VERSION_HEX >= 0x030400a1
    0,
#endif
};
static int __pyx_CyFunction_init(void) {
    __pyx_CyFunctionType = __Pyx_FetchCommonType(&__pyx_CyFunctionType_type);
    if (unlikely(__pyx_CyFunctionType == NULL)) {
        return -1;
    }
    return 0;
}
static CYTHON_INLINE void *__Pyx_CyFunction_InitDefaults(PyObject *func, size_t size, int pyobjects) {
    __pyx_CyFunctionObject *m = (__pyx_CyFunctionObject *) func;
    m->defaults = PyObject_Malloc(size);
    if (unlikely(!m->defaults))
        return PyErr_NoMemory();
    memset(m->defaults, 0, size);
    m->defaults_pyobjects = pyobjects;
    return m->defaults;
}
static CYTHON_INLINE void __Pyx_CyFunction_SetDefaultsTuple(PyObject *func, PyObject *tuple) {
    __pyx_CyFunctionObject *m = (__pyx_CyFunctionObject *) func;
    m->defaults_tuple = tuple;
    Py_INCREF(tuple);
}
static CYTHON_INLINE void __Pyx_CyFunction_SetDefaultsKwDict(PyObject *func, PyObject *dict) {
    __pyx_CyFunctionObject *m = (__pyx_CyFunctionObject *) func;
    m->defaults_kwdict = dict;
    Py_INCREF(dict);
}
static CYTHON_INLINE void __Pyx_CyFunction_SetAnnotationsDict(PyObject *func, PyObject *dict) {
    __pyx_CyFunctionObject *m = (__pyx_CyFunctionObject *) func;
    m->func_annotations = dict;
    Py_INCREF(dict);
}

/* CLineInTraceback */
            #ifndef CYTHON_CLINE_IN_TRACEBACK
static int __Pyx_CLineForTraceback(CYTHON_UNUSED PyThreadState *tstate, int c_line) {
    PyObject *use_cline;
    PyObject *ptype, *pvalue, *ptraceback;
#if CYTHON_COMPILING_IN_CPYTHON
    PyObject **cython_runtime_dict;
#endif
    __Pyx_ErrFetchInState(tstate, &ptype, &pvalue, &ptraceback);
#if CYTHON_COMPILING_IN_CPYTHON
    cython_runtime_dict = _PyObject_GetDictPtr(__pyx_cython_runtime);
    if (likely(cython_runtime_dict)) {
      use_cline = PyDict_GetItem(*cython_runtime_dict, __pyx_n_s_cline_in_traceback);
    } else
#endif
    {
      PyObject *use_cline_obj = __Pyx_PyObject_GetAttrStr(__pyx_cython_runtime, __pyx_n_s_cline_in_traceback);
      if (use_cline_obj) {
        use_cline = PyObject_Not(use_cline_obj) ? Py_False : Py_True;
        Py_DECREF(use_cline_obj);
      } else {
        PyErr_Clear();
        use_cline = NULL;
      }
    }
    if (!use_cline) {
        c_line = 0;
        PyObject_SetAttr(__pyx_cython_runtime, __pyx_n_s_cline_in_traceback, Py_False);
    }
    else if (PyObject_Not(use_cline) != 0) {
        c_line = 0;
    }
    __Pyx_ErrRestoreInState(tstate, ptype, pvalue, ptraceback);
    return c_line;
}
#endif

/* CodeObjectCache */
            static int __pyx_bisect_code_objects(__Pyx_CodeObjectCacheEntry* entries, int count, int code_line) {
    int start = 0, mid = 0, end = count - 1;
    if (end >= 0 && code_line > entries[end].code_line) {
        return count;
    }
    while (start < end) {
        mid = start + (end - start) / 2;
        if (code_line < entries[mid].code_line) {
            end = mid;
        } else if (code_line > entries[mid].code_line) {
             start = mid + 1;
        } else {
            return mid;
        }
    }
    if (code_line <= entries[mid].code_line) {
        return mid;
    } else {
        return mid + 1;
    }
}
static PyCodeObject *__pyx_find_code_object(int code_line) {
    PyCodeObject* code_object;
    int pos;
    if (unlikely(!code_line) || unlikely(!__pyx_code_cache.entries)) {
        return NULL;
    }
    pos = __pyx_bisect_code_objects(__pyx_code_cache.entries, __pyx_code_cache.count, code_line);
    if (unlikely(pos >= __pyx_code_cache.count) || unlikely(__pyx_code_cache.entries[pos].code_line != code_line)) {
        return NULL;
    }
    code_object = __pyx_code_cache.entries[pos].code_object;
    Py_INCREF(code_object);
    return code_object;
}
static void __pyx_insert_code_object(int code_line, PyCodeObject* code_object) {
    int pos, i;
    __Pyx_CodeObjectCacheEntry* entries = __pyx_code_cache.entries;
    if (unlikely(!code_line)) {
        return;
    }
    if (unlikely(!entries)) {
        entries = (__Pyx_CodeObjectCacheEntry*)PyMem_Malloc(64*sizeof(__Pyx_CodeObjectCacheEntry));
        if (likely(entries)) {
            __pyx_code_cache.entries = entries;
            __pyx_code_cache.max_count = 64;
            __pyx_code_cache.count = 1;
            entries[0].code_line = code_line;
            entries[0].code_object = code_object;
            Py_INCREF(code_object);
        }
        return;
    }
    pos = __pyx_bisect_code_objects(__pyx_code_cache.entries, __pyx_code_cache.count, code_line);
    if ((pos < __pyx_code_cache.count) && unlikely(__pyx_code_cache.entries[pos].code_line == code_line)) {
        PyCodeObject* tmp = entries[pos].code_object;
        entries[pos].code_object = code_object;
        Py_DECREF(tmp);
        return;
    }
    if (__pyx_code_cache.count == __pyx_code_cache.max_count) {
        int new_max = __pyx_code_cache.max_count + 64;
        entries = (__Pyx_CodeObjectCacheEntry*)PyMem_Realloc(
            __pyx_code_cache.entries, (size_t)new_max*sizeof(__Pyx_CodeObjectCacheEntry));
        if (unlikely(!entries)) {
            return;
        }
        __pyx_code_cache.entries = entries;
        __pyx_code_cache.max_count = new_max;
    }
    for (i=__pyx_code_cache.count; i>pos; i--) {
        entries[i] = entries[i-1];
    }
    entries[pos].code_line = code_line;
    entries[pos].code_object = code_object;
    __pyx_code_cache.count++;
    Py_INCREF(code_object);
}

/* AddTraceback */
            #include "compile.h"
#include "frameobject.h"
#include "traceback.h"
static PyCodeObject* __Pyx_CreateCodeObjectForTraceback(
            const char *funcname, int c_line,
            int py_line, const char *filename) {
    PyCodeObject *py_code = 0;
    PyObject *py_srcfile = 0;
    PyObject *py_funcname = 0;
    #if PY_MAJOR_VERSION < 3
    py_srcfile = PyString_FromString(filename);
    #else
    py_srcfile = PyUnicode_FromString(filename);
    #endif
    if (!py_srcfile) goto bad;
    if (c_line) {
        #if PY_MAJOR_VERSION < 3
        py_funcname = PyString_FromFormat( "%s (%s:%d)", funcname, __pyx_cfilenm, c_line);
        #else
        py_funcname = PyUnicode_FromFormat( "%s (%s:%d)", funcname, __pyx_cfilenm, c_line);
        #endif
    }
    else {
        #if PY_MAJOR_VERSION < 3
        py_funcname = PyString_FromString(funcname);
        #else
        py_funcname = PyUnicode_FromString(funcname);
        #endif
    }
    if (!py_funcname) goto bad;
    py_code = __Pyx_PyCode_New(
        0,
        0,
        0,
        0,
        0,
        __pyx_empty_bytes, /*PyObject *code,*/
        __pyx_empty_tuple, /*PyObject *consts,*/
        __pyx_empty_tuple, /*PyObject *names,*/
        __pyx_empty_tuple, /*PyObject *varnames,*/
        __pyx_empty_tuple, /*PyObject *freevars,*/
        __pyx_empty_tuple, /*PyObject *cellvars,*/
        py_srcfile,   /*PyObject *filename,*/
        py_funcname,  /*PyObject *name,*/
        py_line,
        __pyx_empty_bytes  /*PyObject *lnotab*/
    );
    Py_DECREF(py_srcfile);
    Py_DECREF(py_funcname);
    return py_code;
bad:
    Py_XDECREF(py_srcfile);
    Py_XDECREF(py_funcname);
    return NULL;
}
static void __Pyx_AddTraceback(const char *funcname, int c_line,
                               int py_line, const char *filename) {
    PyCodeObject *py_code = 0;
    PyFrameObject *py_frame = 0;
    PyThreadState *tstate = __Pyx_PyThreadState_Current;
    if (c_line) {
        c_line = __Pyx_CLineForTraceback(tstate, c_line);
    }
    py_code = __pyx_find_code_object(c_line ? -c_line : py_line);
    if (!py_code) {
        py_code = __Pyx_CreateCodeObjectForTraceback(
            funcname, c_line, py_line, filename);
        if (!py_code) goto bad;
        __pyx_insert_code_object(c_line ? -c_line : py_line, py_code);
    }
    py_frame = PyFrame_New(
        tstate,            /*PyThreadState *tstate,*/
        py_code,           /*PyCodeObject *code,*/
        __pyx_d,    /*PyObject *globals,*/
        0                  /*PyObject *locals*/
    );
    if (!py_frame) goto bad;
    __Pyx_PyFrame_SetLineNumber(py_frame, py_line);
    PyTraceBack_Here(py_frame);
bad:
    Py_XDECREF(py_code);
    Py_XDECREF(py_frame);
}

/* CIntFromPyVerify */
            #define __PYX_VERIFY_RETURN_INT(target_type, func_type, func_value)\
    __PYX__VERIFY_RETURN_INT(target_type, func_type, func_value, 0)
#define __PYX_VERIFY_RETURN_INT_EXC(target_type, func_type, func_value)\
    __PYX__VERIFY_RETURN_INT(target_type, func_type, func_value, 1)
#define __PYX__VERIFY_RETURN_INT(target_type, func_type, func_value, exc)\
    {\
        func_type value = func_value;\
        if (sizeof(target_type) < sizeof(func_type)) {\
            if (unlikely(value != (func_type) (target_type) value)) {\
                func_type zero = 0;\
                if (exc && unlikely(value == (func_type)-1 && PyErr_Occurred()))\
                    return (target_type) -1;\
                if (is_unsigned && unlikely(value < zero))\
                    goto raise_neg_overflow;\
                else\
                    goto raise_overflow;\
            }\
        }\
        return (target_type) value;\
    }

/* CIntToPy */
            static CYTHON_INLINE PyObject* __Pyx_PyInt_From_int(int value) {
    const int neg_one = (int) -1, const_zero = (int) 0;
    const int is_unsigned = neg_one > const_zero;
    if (is_unsigned) {
        if (sizeof(int) < sizeof(long)) {
            return PyInt_FromLong((long) value);
        } else if (sizeof(int) <= sizeof(unsigned long)) {
            return PyLong_FromUnsignedLong((unsigned long) value);
#ifdef HAVE_LONG_LONG
        } else if (sizeof(int) <= sizeof(unsigned PY_LONG_LONG)) {
            return PyLong_FromUnsignedLongLong((unsigned PY_LONG_LONG) value);
#endif
        }
    } else {
        if (sizeof(int) <= sizeof(long)) {
            return PyInt_FromLong((long) value);
#ifdef HAVE_LONG_LONG
        } else if (sizeof(int) <= sizeof(PY_LONG_LONG)) {
            return PyLong_FromLongLong((PY_LONG_LONG) value);
#endif
        }
    }
    {
        int one = 1; int little = (int)*(unsigned char *)&one;
        unsigned char *bytes = (unsigned char *)&value;
        return _PyLong_FromByteArray(bytes, sizeof(int),
                                     little, !is_unsigned);
    }
}

/* CIntToPy */
            static CYTHON_INLINE PyObject* __Pyx_PyInt_From_uint64_t(uint64_t value) {
    const uint64_t neg_one = (uint64_t) -1, const_zero = (uint64_t) 0;
    const int is_unsigned = neg_one > const_zero;
    if (is_unsigned) {
        if (sizeof(uint64_t) < sizeof(long)) {
            return PyInt_FromLong((long) value);
        } else if (sizeof(uint64_t) <= sizeof(unsigned long)) {
            return PyLong_FromUnsignedLong((unsigned long) value);
#ifdef HAVE_LONG_LONG
        } else if (sizeof(uint64_t) <= sizeof(unsigned PY_LONG_LONG)) {
            return PyLong_FromUnsignedLongLong((unsigned PY_LONG_LONG) value);
#endif
        }
    } else {
        if (sizeof(uint64_t) <= sizeof(long)) {
            return PyInt_FromLong((long) value);
#ifdef HAVE_LONG_LONG
        } else if (sizeof(uint64_t) <= sizeof(PY_LONG_LONG)) {
            return PyLong_FromLongLong((PY_LONG_LONG) value);
#endif
        }
    }
    {
        int one = 1; int little = (int)*(unsigned char *)&one;
        unsigned char *bytes = (unsigned char *)&value;
        return _PyLong_FromByteArray(bytes, sizeof(uint64_t),
                                     little, !is_unsigned);
    }
}

/* CIntToPy */
            static CYTHON_INLINE PyObject* __Pyx_PyInt_From_uint32_t(uint32_t value) {
    const uint32_t neg_one = (uint32_t) -1, const_zero = (uint32_t) 0;
    const int is_unsigned = neg_one > const_zero;
    if (is_unsigned) {
        if (sizeof(uint32_t) < sizeof(long)) {
            return PyInt_FromLong((long) value);
        } else if (sizeof(uint32_t) <= sizeof(unsigned long)) {
            return PyLong_FromUnsignedLong((unsigned long) value);
#ifdef HAVE_LONG_LONG
        } else if (sizeof(uint32_t) <= sizeof(unsigned PY_LONG_LONG)) {
            return PyLong_FromUnsignedLongLong((unsigned PY_LONG_LONG) value);
#endif
        }
    } else {
        if (sizeof(uint32_t) <= sizeof(long)) {
            return PyInt_FromLong((long) value);
#ifdef HAVE_LONG_LONG
        } else if (sizeof(uint32_t) <= sizeof(PY_LONG_LONG)) {
            return PyLong_FromLongLong((PY_LONG_LONG) value);
#endif
        }
    }
    {
        int one = 1; int little = (int)*(unsigned char *)&one;
        unsigned char *bytes = (unsigned char *)&value;
        return _PyLong_FromByteArray(bytes, sizeof(uint32_t),
                                     little, !is_unsigned);
    }
}

/* CIntToPy */
            static CYTHON_INLINE PyObject* __Pyx_PyInt_From_int64_t(int64_t value) {
    const int64_t neg_one = (int64_t) -1, const_zero = (int64_t) 0;
    const int is_unsigned = neg_one > const_zero;
    if (is_unsigned) {
        if (sizeof(int64_t) < sizeof(long)) {
            return PyInt_FromLong((long) value);
        } else if (sizeof(int64_t) <= sizeof(unsigned long)) {
            return PyLong_FromUnsignedLong((unsigned long) value);
#ifdef HAVE_LONG_LONG
        } else if (sizeof(int64_t) <= sizeof(unsigned PY_LONG_LONG)) {
            return PyLong_FromUnsignedLongLong((unsigned PY_LONG_LONG) value);
#endif
        }
    } else {
        if (sizeof(int64_t) <= sizeof(long)) {
            return PyInt_FromLong((long) value);
#ifdef HAVE_LONG_LONG
        } else if (sizeof(int64_t) <= sizeof(PY_LONG_LONG)) {
            return PyLong_FromLongLong((PY_LONG_LONG) value);
#endif
        }
    }
    {
        int one = 1; int little = (int)*(unsigned char *)&one;
        unsigned char *bytes = (unsigned char *)&value;
        return _PyLong_FromByteArray(bytes, sizeof(int64_t),
                                     little, !is_unsigned);
    }
}

/* CIntToPy */
            static CYTHON_INLINE PyObject* __Pyx_PyInt_From_int32_t(int32_t value) {
    const int32_t neg_one = (int32_t) -1, const_zero = (int32_t) 0;
    const int is_unsigned = neg_one > const_zero;
    if (is_unsigned) {
        if (sizeof(int32_t) < sizeof(long)) {
            return PyInt_FromLong((long) value);
        } else if (sizeof(int32_t) <= sizeof(unsigned long)) {
            return PyLong_FromUnsignedLong((unsigned long) value);
#ifdef HAVE_LONG_LONG
        } else if (sizeof(int32_t) <= sizeof(unsigned PY_LONG_LONG)) {
            return PyLong_FromUnsignedLongLong((unsigned PY_LONG_LONG) value);
#endif
        }
    } else {
        if (sizeof(int32_t) <= sizeof(long)) {
            return PyInt_FromLong((long) value);
#ifdef HAVE_LONG_LONG
        } else if (sizeof(int32_t) <= sizeof(PY_LONG_LONG)) {
            return PyLong_FromLongLong((PY_LONG_LONG) value);
#endif
        }
    }
    {
        int one = 1; int little = (int)*(unsigned char *)&one;
        unsigned char *bytes = (unsigned char *)&value;
        return _PyLong_FromByteArray(bytes, sizeof(int32_t),
                                     little, !is_unsigned);
    }
}

/* CIntFromPy */
            static CYTHON_INLINE size_t __Pyx_PyInt_As_size_t(PyObject *x) {
    const size_t neg_one = (size_t) -1, const_zero = (size_t) 0;
    const int is_unsigned = neg_one > const_zero;
#if PY_MAJOR_VERSION < 3
    if (likely(PyInt_Check(x))) {
        if (sizeof(size_t) < sizeof(long)) {
            __PYX_VERIFY_RETURN_INT(size_t, long, PyInt_AS_LONG(x))
        } else {
            long val = PyInt_AS_LONG(x);
            if (is_unsigned && unlikely(val < 0)) {
                goto raise_neg_overflow;
            }
            return (size_t) val;
        }
    } else
#endif
    if (likely(PyLong_Check(x))) {
        if (is_unsigned) {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (size_t) 0;
                case  1: __PYX_VERIFY_RETURN_INT(size_t, digit, digits[0])
                case 2:
                    if (8 * sizeof(size_t) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(size_t, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(size_t) >= 2 * PyLong_SHIFT) {
                            return (size_t) (((((size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0]));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(size_t) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(size_t, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(size_t) >= 3 * PyLong_SHIFT) {
                            return (size_t) (((((((size_t)digits[2]) << PyLong_SHIFT) | (size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0]));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(size_t) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(size_t, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(size_t) >= 4 * PyLong_SHIFT) {
                            return (size_t) (((((((((size_t)digits[3]) << PyLong_SHIFT) | (size_t)digits[2]) << PyLong_SHIFT) | (size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0]));
                        }
                    }
                    break;
            }
#endif
#if CYTHON_COMPILING_IN_CPYTHON
            if (unlikely(Py_SIZE(x) < 0)) {
                goto raise_neg_overflow;
            }
#else
            {
                int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                if (unlikely(result < 0))
                    return (size_t) -1;
                if (unlikely(result == 1))
                    goto raise_neg_overflow;
            }
#endif
            if (sizeof(size_t) <= sizeof(unsigned long)) {
                __PYX_VERIFY_RETURN_INT_EXC(size_t, unsigned long, PyLong_AsUnsignedLong(x))
#ifdef HAVE_LONG_LONG
            } else if (sizeof(size_t) <= sizeof(unsigned PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(size_t, unsigned PY_LONG_LONG, PyLong_AsUnsignedLongLong(x))
#endif
            }
        } else {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (size_t) 0;
                case -1: __PYX_VERIFY_RETURN_INT(size_t, sdigit, (sdigit) (-(sdigit)digits[0]))
                case  1: __PYX_VERIFY_RETURN_INT(size_t,  digit, +digits[0])
                case -2:
                    if (8 * sizeof(size_t) - 1 > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(size_t, long, -(long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(size_t) - 1 > 2 * PyLong_SHIFT) {
                            return (size_t) (((size_t)-1)*(((((size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0])));
                        }
                    }
                    break;
                case 2:
                    if (8 * sizeof(size_t) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(size_t, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(size_t) - 1 > 2 * PyLong_SHIFT) {
                            return (size_t) ((((((size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0])));
                        }
                    }
                    break;
                case -3:
                    if (8 * sizeof(size_t) - 1 > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(size_t, long, -(long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(size_t) - 1 > 3 * PyLong_SHIFT) {
                            return (size_t) (((size_t)-1)*(((((((size_t)digits[2]) << PyLong_SHIFT) | (size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0])));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(size_t) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(size_t, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(size_t) - 1 > 3 * PyLong_SHIFT) {
                            return (size_t) ((((((((size_t)digits[2]) << PyLong_SHIFT) | (size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0])));
                        }
                    }
                    break;
                case -4:
                    if (8 * sizeof(size_t) - 1 > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(size_t, long, -(long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(size_t) - 1 > 4 * PyLong_SHIFT) {
                            return (size_t) (((size_t)-1)*(((((((((size_t)digits[3]) << PyLong_SHIFT) | (size_t)digits[2]) << PyLong_SHIFT) | (size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0])));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(size_t) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(size_t, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(size_t) - 1 > 4 * PyLong_SHIFT) {
                            return (size_t) ((((((((((size_t)digits[3]) << PyLong_SHIFT) | (size_t)digits[2]) << PyLong_SHIFT) | (size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0])));
                        }
                    }
                    break;
            }
#endif
            if (sizeof(size_t) <= sizeof(long)) {
                __PYX_VERIFY_RETURN_INT_EXC(size_t, long, PyLong_AsLong(x))
#ifdef HAVE_LONG_LONG
            } else if (sizeof(size_t) <= sizeof(PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(size_t, PY_LONG_LONG, PyLong_AsLongLong(x))
#endif
            }
        }
        {
#if CYTHON_COMPILING_IN_PYPY && !defined(_PyLong_AsByteArray)
            PyErr_SetString(PyExc_RuntimeError,
                            "_PyLong_AsByteArray() not available in PyPy, cannot convert large numbers");
#else
            size_t val;
            PyObject *v = __Pyx_PyNumber_IntOrLong(x);
 #if PY_MAJOR_VERSION < 3
            if (likely(v) && !PyLong_Check(v)) {
                PyObject *tmp = v;
                v = PyNumber_Long(tmp);
                Py_DECREF(tmp);
            }
 #endif
            if (likely(v)) {
                int one = 1; int is_little = (int)*(unsigned char *)&one;
                unsigned char *bytes = (unsigned char *)&val;
                int ret = _PyLong_AsByteArray((PyLongObject *)v,
                                              bytes, sizeof(val),
                                              is_little, !is_unsigned);
                Py_DECREF(v);
                if (likely(!ret))
                    return val;
            }
#endif
            return (size_t) -1;
        }
    } else {
        size_t val;
        PyObject *tmp = __Pyx_PyNumber_IntOrLong(x);
        if (!tmp) return (size_t) -1;
        val = __Pyx_PyInt_As_size_t(tmp);
        Py_DECREF(tmp);
        return val;
    }
raise_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "value too large to convert to size_t");
    return (size_t) -1;
raise_neg_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "can't convert negative value to size_t");
    return (size_t) -1;
}

/* CIntFromPy */
            static CYTHON_INLINE int64_t __Pyx_PyInt_As_int64_t(PyObject *x) {
    const int64_t neg_one = (int64_t) -1, const_zero = (int64_t) 0;
    const int is_unsigned = neg_one > const_zero;
#if PY_MAJOR_VERSION < 3
    if (likely(PyInt_Check(x))) {
        if (sizeof(int64_t) < sizeof(long)) {
            __PYX_VERIFY_RETURN_INT(int64_t, long, PyInt_AS_LONG(x))
        } else {
            long val = PyInt_AS_LONG(x);
            if (is_unsigned && unlikely(val < 0)) {
                goto raise_neg_overflow;
            }
            return (int64_t) val;
        }
    } else
#endif
    if (likely(PyLong_Check(x))) {
        if (is_unsigned) {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (int64_t) 0;
                case  1: __PYX_VERIFY_RETURN_INT(int64_t, digit, digits[0])
                case 2:
                    if (8 * sizeof(int64_t) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int64_t, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int64_t) >= 2 * PyLong_SHIFT) {
                            return (int64_t) (((((int64_t)digits[1]) << PyLong_SHIFT) | (int64_t)digits[0]));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(int64_t) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int64_t, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int64_t) >= 3 * PyLong_SHIFT) {
                            return (int64_t) (((((((int64_t)digits[2]) << PyLong_SHIFT) | (int64_t)digits[1]) << PyLong_SHIFT) | (int64_t)digits[0]));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(int64_t) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int64_t, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int64_t) >= 4 * PyLong_SHIFT) {
                            return (int64_t) (((((((((int64_t)digits[3]) << PyLong_SHIFT) | (int64_t)digits[2]) << PyLong_SHIFT) | (int64_t)digits[1]) << PyLong_SHIFT) | (int64_t)digits[0]));
                        }
                    }
                    break;
            }
#endif
#if CYTHON_COMPILING_IN_CPYTHON
            if (unlikely(Py_SIZE(x) < 0)) {
                goto raise_neg_overflow;
            }
#else
            {
                int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                if (unlikely(result < 0))
                    return (int64_t) -1;
                if (unlikely(result == 1))
                    goto raise_neg_overflow;
            }
#endif
            if (sizeof(int64_t) <= sizeof(unsigned long)) {
                __PYX_VERIFY_RETURN_INT_EXC(int64_t, unsigned long, PyLong_AsUnsignedLong(x))
#ifdef HAVE_LONG_LONG
            } else if (sizeof(int64_t) <= sizeof(unsigned PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(int64_t, unsigned PY_LONG_LONG, PyLong_AsUnsignedLongLong(x))
#endif
            }
        } else {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (int64_t) 0;
                case -1: __PYX_VERIFY_RETURN_INT(int64_t, sdigit, (sdigit) (-(sdigit)digits[0]))
                case  1: __PYX_VERIFY_RETURN_INT(int64_t,  digit, +digits[0])
                case -2:
                    if (8 * sizeof(int64_t) - 1 > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int64_t, long, -(long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int64_t) - 1 > 2 * PyLong_SHIFT) {
                            return (int64_t) (((int64_t)-1)*(((((int64_t)digits[1]) << PyLong_SHIFT) | (int64_t)digits[0])));
                        }
                    }
                    break;
                case 2:
                    if (8 * sizeof(int64_t) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int64_t, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int64_t) - 1 > 2 * PyLong_SHIFT) {
                            return (int64_t) ((((((int64_t)digits[1]) << PyLong_SHIFT) | (int64_t)digits[0])));
                        }
                    }
                    break;
                case -3:
                    if (8 * sizeof(int64_t) - 1 > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int64_t, long, -(long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int64_t) - 1 > 3 * PyLong_SHIFT) {
                            return (int64_t) (((int64_t)-1)*(((((((int64_t)digits[2]) << PyLong_SHIFT) | (int64_t)digits[1]) << PyLong_SHIFT) | (int64_t)digits[0])));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(int64_t) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int64_t, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int64_t) - 1 > 3 * PyLong_SHIFT) {
                            return (int64_t) ((((((((int64_t)digits[2]) << PyLong_SHIFT) | (int64_t)digits[1]) << PyLong_SHIFT) | (int64_t)digits[0])));
                        }
                    }
                    break;
                case -4:
                    if (8 * sizeof(int64_t) - 1 > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int64_t, long, -(long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int64_t) - 1 > 4 * PyLong_SHIFT) {
                            return (int64_t) (((int64_t)-1)*(((((((((int64_t)digits[3]) << PyLong_SHIFT) | (int64_t)digits[2]) << PyLong_SHIFT) | (int64_t)digits[1]) << PyLong_SHIFT) | (int64_t)digits[0])));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(int64_t) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int64_t, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int64_t) - 1 > 4 * PyLong_SHIFT) {
                            return (int64_t) ((((((((((int64_t)digits[3]) << PyLong_SHIFT) | (int64_t)digits[2]) << PyLong_SHIFT) | (int64_t)digits[1]) << PyLong_SHIFT) | (int64_t)digits[0])));
                        }
                    }
                    break;
            }
#endif
            if (sizeof(int64_t) <= sizeof(long)) {
                __PYX_VERIFY_RETURN_INT_EXC(int64_t, long, PyLong_AsLong(x))
#ifdef HAVE_LONG_LONG
            } else if (sizeof(int64_t) <= sizeof(PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(int64_t, PY_LONG_LONG, PyLong_AsLongLong(x))
#endif
            }
        }
        {
#if CYTHON_COMPILING_IN_PYPY && !defined(_PyLong_AsByteArray)
            PyErr_SetString(PyExc_RuntimeError,
                            "_PyLong_AsByteArray() not available in PyPy, cannot convert large numbers");
#else
            int64_t val;
            PyObject *v = __Pyx_PyNumber_IntOrLong(x);
 #if PY_MAJOR_VERSION < 3
            if (likely(v) && !PyLong_Check(v)) {
                PyObject *tmp = v;
                v = PyNumber_Long(tmp);
                Py_DECREF(tmp);
            }
 #endif
            if (likely(v)) {
                int one = 1; int is_little = (int)*(unsigned char *)&one;
                unsigned char *bytes = (unsigned char *)&val;
                int ret = _PyLong_AsByteArray((PyLongObject *)v,
                                              bytes, sizeof(val),
                                              is_little, !is_unsigned);
                Py_DECREF(v);
                if (likely(!ret))
                    return val;
            }
#endif
            return (int64_t) -1;
        }
    } else {
        int64_t val;
        PyObject *tmp = __Pyx_PyNumber_IntOrLong(x);
        if (!tmp) return (int64_t) -1;
        val = __Pyx_PyInt_As_int64_t(tmp);
        Py_DECREF(tmp);
        return val;
    }
raise_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "value too large to convert to int64_t");
    return (int64_t) -1;
raise_neg_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "can't convert negative value to int64_t");
    return (int64_t) -1;
}

/* CIntFromPy */
            static CYTHON_INLINE uint64_t __Pyx_PyInt_As_uint64_t(PyObject *x) {
    const uint64_t neg_one = (uint64_t) -1, const_zero = (uint64_t) 0;
    const int is_unsigned = neg_one > const_zero;
#if PY_MAJOR_VERSION < 3
    if (likely(PyInt_Check(x))) {
        if (sizeof(uint64_t) < sizeof(long)) {
            __PYX_VERIFY_RETURN_INT(uint64_t, long, PyInt_AS_LONG(x))
        } else {
            long val = PyInt_AS_LONG(x);
            if (is_unsigned && unlikely(val < 0)) {
                goto raise_neg_overflow;
            }
            return (uint64_t) val;
        }
    } else
#endif
    if (likely(PyLong_Check(x))) {
        if (is_unsigned) {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (uint64_t) 0;
                case  1: __PYX_VERIFY_RETURN_INT(uint64_t, digit, digits[0])
                case 2:
                    if (8 * sizeof(uint64_t) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(uint64_t, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(uint64_t) >= 2 * PyLong_SHIFT) {
                            return (uint64_t) (((((uint64_t)digits[1]) << PyLong_SHIFT) | (uint64_t)digits[0]));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(uint64_t) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(uint64_t, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(uint64_t) >= 3 * PyLong_SHIFT) {
                            return (uint64_t) (((((((uint64_t)digits[2]) << PyLong_SHIFT) | (uint64_t)digits[1]) << PyLong_SHIFT) | (uint64_t)digits[0]));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(uint64_t) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(uint64_t, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(uint64_t) >= 4 * PyLong_SHIFT) {
                            return (uint64_t) (((((((((uint64_t)digits[3]) << PyLong_SHIFT) | (uint64_t)digits[2]) << PyLong_SHIFT) | (uint64_t)digits[1]) << PyLong_SHIFT) | (uint64_t)digits[0]));
                        }
                    }
                    break;
            }
#endif
#if CYTHON_COMPILING_IN_CPYTHON
            if (unlikely(Py_SIZE(x) < 0)) {
                goto raise_neg_overflow;
            }
#else
            {
                int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                if (unlikely(result < 0))
                    return (uint64_t) -1;
                if (unlikely(result == 1))
                    goto raise_neg_overflow;
            }
#endif
            if (sizeof(uint64_t) <= sizeof(unsigned long)) {
                __PYX_VERIFY_RETURN_INT_EXC(uint64_t, unsigned long, PyLong_AsUnsignedLong(x))
#ifdef HAVE_LONG_LONG
            } else if (sizeof(uint64_t) <= sizeof(unsigned PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(uint64_t, unsigned PY_LONG_LONG, PyLong_AsUnsignedLongLong(x))
#endif
            }
        } else {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (uint64_t) 0;
                case -1: __PYX_VERIFY_RETURN_INT(uint64_t, sdigit, (sdigit) (-(sdigit)digits[0]))
                case  1: __PYX_VERIFY_RETURN_INT(uint64_t,  digit, +digits[0])
                case -2:
                    if (8 * sizeof(uint64_t) - 1 > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(uint64_t, long, -(long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(uint64_t) - 1 > 2 * PyLong_SHIFT) {
                            return (uint64_t) (((uint64_t)-1)*(((((uint64_t)digits[1]) << PyLong_SHIFT) | (uint64_t)digits[0])));
                        }
                    }
                    break;
                case 2:
                    if (8 * sizeof(uint64_t) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(uint64_t, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(uint64_t) - 1 > 2 * PyLong_SHIFT) {
                            return (uint64_t) ((((((uint64_t)digits[1]) << PyLong_SHIFT) | (uint64_t)digits[0])));
                        }
                    }
                    break;
                case -3:
                    if (8 * sizeof(uint64_t) - 1 > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(uint64_t, long, -(long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(uint64_t) - 1 > 3 * PyLong_SHIFT) {
                            return (uint64_t) (((uint64_t)-1)*(((((((uint64_t)digits[2]) << PyLong_SHIFT) | (uint64_t)digits[1]) << PyLong_SHIFT) | (uint64_t)digits[0])));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(uint64_t) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(uint64_t, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(uint64_t) - 1 > 3 * PyLong_SHIFT) {
                            return (uint64_t) ((((((((uint64_t)digits[2]) << PyLong_SHIFT) | (uint64_t)digits[1]) << PyLong_SHIFT) | (uint64_t)digits[0])));
                        }
                    }
                    break;
                case -4:
                    if (8 * sizeof(uint64_t) - 1 > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(uint64_t, long, -(long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(uint64_t) - 1 > 4 * PyLong_SHIFT) {
                            return (uint64_t) (((uint64_t)-1)*(((((((((uint64_t)digits[3]) << PyLong_SHIFT) | (uint64_t)digits[2]) << PyLong_SHIFT) | (uint64_t)digits[1]) << PyLong_SHIFT) | (uint64_t)digits[0])));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(uint64_t) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(uint64_t, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(uint64_t) - 1 > 4 * PyLong_SHIFT) {
                            return (uint64_t) ((((((((((uint64_t)digits[3]) << PyLong_SHIFT) | (uint64_t)digits[2]) << PyLong_SHIFT) | (uint64_t)digits[1]) << PyLong_SHIFT) | (uint64_t)digits[0])));
                        }
                    }
                    break;
            }
#endif
            if (sizeof(uint64_t) <= sizeof(long)) {
                __PYX_VERIFY_RETURN_INT_EXC(uint64_t, long, PyLong_AsLong(x))
#ifdef HAVE_LONG_LONG
            } else if (sizeof(uint64_t) <= sizeof(PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(uint64_t, PY_LONG_LONG, PyLong_AsLongLong(x))
#endif
            }
        }
        {
#if CYTHON_COMPILING_IN_PYPY && !defined(_PyLong_AsByteArray)
            PyErr_SetString(PyExc_RuntimeError,
                            "_PyLong_AsByteArray() not available in PyPy, cannot convert large numbers");
#else
            uint64_t val;
            PyObject *v = __Pyx_PyNumber_IntOrLong(x);
 #if PY_MAJOR_VERSION < 3
            if (likely(v) && !PyLong_Check(v)) {
                PyObject *tmp = v;
                v = PyNumber_Long(tmp);
                Py_DECREF(tmp);
            }
 #endif
            if (likely(v)) {
                int one = 1; int is_little = (int)*(unsigned char *)&one;
                unsigned char *bytes = (unsigned char *)&val;
                int ret = _PyLong_AsByteArray((PyLongObject *)v,
                                              bytes, sizeof(val),
                                              is_little, !is_unsigned);
                Py_DECREF(v);
                if (likely(!ret))
                    return val;
            }
#endif
            return (uint64_t) -1;
        }
    } else {
        uint64_t val;
        PyObject *tmp = __Pyx_PyNumber_IntOrLong(x);
        if (!tmp) return (uint64_t) -1;
        val = __Pyx_PyInt_As_uint64_t(tmp);
        Py_DECREF(tmp);
        return val;
    }
raise_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "value too large to convert to uint64_t");
    return (uint64_t) -1;
raise_neg_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "can't convert negative value to uint64_t");
    return (uint64_t) -1;
}

/* CIntFromPy */
            static CYTHON_INLINE int32_t __Pyx_PyInt_As_int32_t(PyObject *x) {
    const int32_t neg_one = (int32_t) -1, const_zero = (int32_t) 0;
    const int is_unsigned = neg_one > const_zero;
#if PY_MAJOR_VERSION < 3
    if (likely(PyInt_Check(x))) {
        if (sizeof(int32_t) < sizeof(long)) {
            __PYX_VERIFY_RETURN_INT(int32_t, long, PyInt_AS_LONG(x))
        } else {
            long val = PyInt_AS_LONG(x);
            if (is_unsigned && unlikely(val < 0)) {
                goto raise_neg_overflow;
            }
            return (int32_t) val;
        }
    } else
#endif
    if (likely(PyLong_Check(x))) {
        if (is_unsigned) {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (int32_t) 0;
                case  1: __PYX_VERIFY_RETURN_INT(int32_t, digit, digits[0])
                case 2:
                    if (8 * sizeof(int32_t) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int32_t, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int32_t) >= 2 * PyLong_SHIFT) {
                            return (int32_t) (((((int32_t)digits[1]) << PyLong_SHIFT) | (int32_t)digits[0]));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(int32_t) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int32_t, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int32_t) >= 3 * PyLong_SHIFT) {
                            return (int32_t) (((((((int32_t)digits[2]) << PyLong_SHIFT) | (int32_t)digits[1]) << PyLong_SHIFT) | (int32_t)digits[0]));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(int32_t) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int32_t, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int32_t) >= 4 * PyLong_SHIFT) {
                            return (int32_t) (((((((((int32_t)digits[3]) << PyLong_SHIFT) | (int32_t)digits[2]) << PyLong_SHIFT) | (int32_t)digits[1]) << PyLong_SHIFT) | (int32_t)digits[0]));
                        }
                    }
                    break;
            }
#endif
#if CYTHON_COMPILING_IN_CPYTHON
            if (unlikely(Py_SIZE(x) < 0)) {
                goto raise_neg_overflow;
            }
#else
            {
                int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                if (unlikely(result < 0))
                    return (int32_t) -1;
                if (unlikely(result == 1))
                    goto raise_neg_overflow;
            }
#endif
            if (sizeof(int32_t) <= sizeof(unsigned long)) {
                __PYX_VERIFY_RETURN_INT_EXC(int32_t, unsigned long, PyLong_AsUnsignedLong(x))
#ifdef HAVE_LONG_LONG
            } else if (sizeof(int32_t) <= sizeof(unsigned PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(int32_t, unsigned PY_LONG_LONG, PyLong_AsUnsignedLongLong(x))
#endif
            }
        } else {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (int32_t) 0;
                case -1: __PYX_VERIFY_RETURN_INT(int32_t, sdigit, (sdigit) (-(sdigit)digits[0]))
                case  1: __PYX_VERIFY_RETURN_INT(int32_t,  digit, +digits[0])
                case -2:
                    if (8 * sizeof(int32_t) - 1 > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int32_t, long, -(long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int32_t) - 1 > 2 * PyLong_SHIFT) {
                            return (int32_t) (((int32_t)-1)*(((((int32_t)digits[1]) << PyLong_SHIFT) | (int32_t)digits[0])));
                        }
                    }
                    break;
                case 2:
                    if (8 * sizeof(int32_t) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int32_t, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int32_t) - 1 > 2 * PyLong_SHIFT) {
                            return (int32_t) ((((((int32_t)digits[1]) << PyLong_SHIFT) | (int32_t)digits[0])));
                        }
                    }
                    break;
                case -3:
                    if (8 * sizeof(int32_t) - 1 > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int32_t, long, -(long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int32_t) - 1 > 3 * PyLong_SHIFT) {
                            return (int32_t) (((int32_t)-1)*(((((((int32_t)digits[2]) << PyLong_SHIFT) | (int32_t)digits[1]) << PyLong_SHIFT) | (int32_t)digits[0])));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(int32_t) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int32_t, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int32_t) - 1 > 3 * PyLong_SHIFT) {
                            return (int32_t) ((((((((int32_t)digits[2]) << PyLong_SHIFT) | (int32_t)digits[1]) << PyLong_SHIFT) | (int32_t)digits[0])));
                        }
                    }
                    break;
                case -4:
                    if (8 * sizeof(int32_t) - 1 > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int32_t, long, -(long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int32_t) - 1 > 4 * PyLong_SHIFT) {
                            return (int32_t) (((int32_t)-1)*(((((((((int32_t)digits[3]) << PyLong_SHIFT) | (int32_t)digits[2]) << PyLong_SHIFT) | (int32_t)digits[1]) << PyLong_SHIFT) | (int32_t)digits[0])));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(int32_t) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int32_t, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int32_t) - 1 > 4 * PyLong_SHIFT) {
                            return (int32_t) ((((((((((int32_t)digits[3]) << PyLong_SHIFT) | (int32_t)digits[2]) << PyLong_SHIFT) | (int32_t)digits[1]) << PyLong_SHIFT) | (int32_t)digits[0])));
                        }
                    }
                    break;
            }
#endif
            if (sizeof(int32_t) <= sizeof(long)) {
                __PYX_VERIFY_RETURN_INT_EXC(int32_t, long, PyLong_AsLong(x))
#ifdef HAVE_LONG_LONG
            } else if (sizeof(int32_t) <= sizeof(PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(int32_t, PY_LONG_LONG, PyLong_AsLongLong(x))
#endif
            }
        }
        {
#if CYTHON_COMPILING_IN_PYPY && !defined(_PyLong_AsByteArray)
            PyErr_SetString(PyExc_RuntimeError,
                            "_PyLong_AsByteArray() not available in PyPy, cannot convert large numbers");
#else
            int32_t val;
            PyObject *v = __Pyx_PyNumber_IntOrLong(x);
 #if PY_MAJOR_VERSION < 3
            if (likely(v) && !PyLong_Check(v)) {
                PyObject *tmp = v;
                v = PyNumber_Long(tmp);
                Py_DECREF(tmp);
            }
 #endif
            if (likely(v)) {
                int one = 1; int is_little = (int)*(unsigned char *)&one;
                unsigned char *bytes = (unsigned char *)&val;
                int ret = _PyLong_AsByteArray((PyLongObject *)v,
                                              bytes, sizeof(val),
                                              is_little, !is_unsigned);
                Py_DECREF(v);
                if (likely(!ret))
                    return val;
            }
#endif
            return (int32_t) -1;
        }
    } else {
        int32_t val;
        PyObject *tmp = __Pyx_PyNumber_IntOrLong(x);
        if (!tmp) return (int32_t) -1;
        val = __Pyx_PyInt_As_int32_t(tmp);
        Py_DECREF(tmp);
        return val;
    }
raise_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "value too large to convert to int32_t");
    return (int32_t) -1;
raise_neg_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "can't convert negative value to int32_t");
    return (int32_t) -1;
}

/* CIntFromPy */
            static CYTHON_INLINE uint32_t __Pyx_PyInt_As_uint32_t(PyObject *x) {
    const uint32_t neg_one = (uint32_t) -1, const_zero = (uint32_t) 0;
    const int is_unsigned = neg_one > const_zero;
#if PY_MAJOR_VERSION < 3
    if (likely(PyInt_Check(x))) {
        if (sizeof(uint32_t) < sizeof(long)) {
            __PYX_VERIFY_RETURN_INT(uint32_t, long, PyInt_AS_LONG(x))
        } else {
            long val = PyInt_AS_LONG(x);
            if (is_unsigned && unlikely(val < 0)) {
                goto raise_neg_overflow;
            }
            return (uint32_t) val;
        }
    } else
#endif
    if (likely(PyLong_Check(x))) {
        if (is_unsigned) {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (uint32_t) 0;
                case  1: __PYX_VERIFY_RETURN_INT(uint32_t, digit, digits[0])
                case 2:
                    if (8 * sizeof(uint32_t) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(uint32_t, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(uint32_t) >= 2 * PyLong_SHIFT) {
                            return (uint32_t) (((((uint32_t)digits[1]) << PyLong_SHIFT) | (uint32_t)digits[0]));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(uint32_t) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(uint32_t, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(uint32_t) >= 3 * PyLong_SHIFT) {
                            return (uint32_t) (((((((uint32_t)digits[2]) << PyLong_SHIFT) | (uint32_t)digits[1]) << PyLong_SHIFT) | (uint32_t)digits[0]));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(uint32_t) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(uint32_t, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(uint32_t) >= 4 * PyLong_SHIFT) {
                            return (uint32_t) (((((((((uint32_t)digits[3]) << PyLong_SHIFT) | (uint32_t)digits[2]) << PyLong_SHIFT) | (uint32_t)digits[1]) << PyLong_SHIFT) | (uint32_t)digits[0]));
                        }
                    }
                    break;
            }
#endif
#if CYTHON_COMPILING_IN_CPYTHON
            if (unlikely(Py_SIZE(x) < 0)) {
                goto raise_neg_overflow;
            }
#else
            {
                int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                if (unlikely(result < 0))
                    return (uint32_t) -1;
                if (unlikely(result == 1))
                    goto raise_neg_overflow;
            }
#endif
            if (sizeof(uint32_t) <= sizeof(unsigned long)) {
                __PYX_VERIFY_RETURN_INT_EXC(uint32_t, unsigned long, PyLong_AsUnsignedLong(x))
#ifdef HAVE_LONG_LONG
            } else if (sizeof(uint32_t) <= sizeof(unsigned PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(uint32_t, unsigned PY_LONG_LONG, PyLong_AsUnsignedLongLong(x))
#endif
            }
        } else {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (uint32_t) 0;
                case -1: __PYX_VERIFY_RETURN_INT(uint32_t, sdigit, (sdigit) (-(sdigit)digits[0]))
                case  1: __PYX_VERIFY_RETURN_INT(uint32_t,  digit, +digits[0])
                case -2:
                    if (8 * sizeof(uint32_t) - 1 > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(uint32_t, long, -(long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(uint32_t) - 1 > 2 * PyLong_SHIFT) {
                            return (uint32_t) (((uint32_t)-1)*(((((uint32_t)digits[1]) << PyLong_SHIFT) | (uint32_t)digits[0])));
                        }
                    }
                    break;
                case 2:
                    if (8 * sizeof(uint32_t) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(uint32_t, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(uint32_t) - 1 > 2 * PyLong_SHIFT) {
                            return (uint32_t) ((((((uint32_t)digits[1]) << PyLong_SHIFT) | (uint32_t)digits[0])));
                        }
                    }
                    break;
                case -3:
                    if (8 * sizeof(uint32_t) - 1 > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(uint32_t, long, -(long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(uint32_t) - 1 > 3 * PyLong_SHIFT) {
                            return (uint32_t) (((uint32_t)-1)*(((((((uint32_t)digits[2]) << PyLong_SHIFT) | (uint32_t)digits[1]) << PyLong_SHIFT) | (uint32_t)digits[0])));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(uint32_t) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(uint32_t, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(uint32_t) - 1 > 3 * PyLong_SHIFT) {
                            return (uint32_t) ((((((((uint32_t)digits[2]) << PyLong_SHIFT) | (uint32_t)digits[1]) << PyLong_SHIFT) | (uint32_t)digits[0])));
                        }
                    }
                    break;
                case -4:
                    if (8 * sizeof(uint32_t) - 1 > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(uint32_t, long, -(long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(uint32_t) - 1 > 4 * PyLong_SHIFT) {
                            return (uint32_t) (((uint32_t)-1)*(((((((((uint32_t)digits[3]) << PyLong_SHIFT) | (uint32_t)digits[2]) << PyLong_SHIFT) | (uint32_t)digits[1]) << PyLong_SHIFT) | (uint32_t)digits[0])));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(uint32_t) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(uint32_t, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(uint32_t) - 1 > 4 * PyLong_SHIFT) {
                            return (uint32_t) ((((((((((uint32_t)digits[3]) << PyLong_SHIFT) | (uint32_t)digits[2]) << PyLong_SHIFT) | (uint32_t)digits[1]) << PyLong_SHIFT) | (uint32_t)digits[0])));
                        }
                    }
                    break;
            }
#endif
            if (sizeof(uint32_t) <= sizeof(long)) {
                __PYX_VERIFY_RETURN_INT_EXC(uint32_t, long, PyLong_AsLong(x))
#ifdef HAVE_LONG_LONG
            } else if (sizeof(uint32_t) <= sizeof(PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(uint32_t, PY_LONG_LONG, PyLong_AsLongLong(x))
#endif
            }
        }
        {
#if CYTHON_COMPILING_IN_PYPY && !defined(_PyLong_AsByteArray)
            PyErr_SetString(PyExc_RuntimeError,
                            "_PyLong_AsByteArray() not available in PyPy, cannot convert large numbers");
#else
            uint32_t val;
            PyObject *v = __Pyx_PyNumber_IntOrLong(x);
 #if PY_MAJOR_VERSION < 3
            if (likely(v) && !PyLong_Check(v)) {
                PyObject *tmp = v;
                v = PyNumber_Long(tmp);
                Py_DECREF(tmp);
            }
 #endif
            if (likely(v)) {
                int one = 1; int is_little = (int)*(unsigned char *)&one;
                unsigned char *bytes = (unsigned char *)&val;
                int ret = _PyLong_AsByteArray((PyLongObject *)v,
                                              bytes, sizeof(val),
                                              is_little, !is_unsigned);
                Py_DECREF(v);
                if (likely(!ret))
                    return val;
            }
#endif
            return (uint32_t) -1;
        }
    } else {
        uint32_t val;
        PyObject *tmp = __Pyx_PyNumber_IntOrLong(x);
        if (!tmp) return (uint32_t) -1;
        val = __Pyx_PyInt_As_uint32_t(tmp);
        Py_DECREF(tmp);
        return val;
    }
raise_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "value too large to convert to uint32_t");
    return (uint32_t) -1;
raise_neg_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "can't convert negative value to uint32_t");
    return (uint32_t) -1;
}

/* CIntFromPy */
            static CYTHON_INLINE time_t __Pyx_PyInt_As_time_t(PyObject *x) {
    const time_t neg_one = (time_t) -1, const_zero = (time_t) 0;
    const int is_unsigned = neg_one > const_zero;
#if PY_MAJOR_VERSION < 3
    if (likely(PyInt_Check(x))) {
        if (sizeof(time_t) < sizeof(long)) {
            __PYX_VERIFY_RETURN_INT(time_t, long, PyInt_AS_LONG(x))
        } else {
            long val = PyInt_AS_LONG(x);
            if (is_unsigned && unlikely(val < 0)) {
                goto raise_neg_overflow;
            }
            return (time_t) val;
        }
    } else
#endif
    if (likely(PyLong_Check(x))) {
        if (is_unsigned) {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (time_t) 0;
                case  1: __PYX_VERIFY_RETURN_INT(time_t, digit, digits[0])
                case 2:
                    if (8 * sizeof(time_t) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(time_t, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(time_t) >= 2 * PyLong_SHIFT) {
                            return (time_t) (((((time_t)digits[1]) << PyLong_SHIFT) | (time_t)digits[0]));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(time_t) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(time_t, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(time_t) >= 3 * PyLong_SHIFT) {
                            return (time_t) (((((((time_t)digits[2]) << PyLong_SHIFT) | (time_t)digits[1]) << PyLong_SHIFT) | (time_t)digits[0]));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(time_t) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(time_t, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(time_t) >= 4 * PyLong_SHIFT) {
                            return (time_t) (((((((((time_t)digits[3]) << PyLong_SHIFT) | (time_t)digits[2]) << PyLong_SHIFT) | (time_t)digits[1]) << PyLong_SHIFT) | (time_t)digits[0]));
                        }
                    }
                    break;
            }
#endif
#if CYTHON_COMPILING_IN_CPYTHON
            if (unlikely(Py_SIZE(x) < 0)) {
                goto raise_neg_overflow;
            }
#else
            {
                int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                if (unlikely(result < 0))
                    return (time_t) -1;
                if (unlikely(result == 1))
                    goto raise_neg_overflow;
            }
#endif
            if (sizeof(time_t) <= sizeof(unsigned long)) {
                __PYX_VERIFY_RETURN_INT_EXC(time_t, unsigned long, PyLong_AsUnsignedLong(x))
#ifdef HAVE_LONG_LONG
            } else if (sizeof(time_t) <= sizeof(unsigned PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(time_t, unsigned PY_LONG_LONG, PyLong_AsUnsignedLongLong(x))
#endif
            }
        } else {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (time_t) 0;
                case -1: __PYX_VERIFY_RETURN_INT(time_t, sdigit, (sdigit) (-(sdigit)digits[0]))
                case  1: __PYX_VERIFY_RETURN_INT(time_t,  digit, +digits[0])
                case -2:
                    if (8 * sizeof(time_t) - 1 > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(time_t, long, -(long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(time_t) - 1 > 2 * PyLong_SHIFT) {
                            return (time_t) (((time_t)-1)*(((((time_t)digits[1]) << PyLong_SHIFT) | (time_t)digits[0])));
                        }
                    }
                    break;
                case 2:
                    if (8 * sizeof(time_t) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(time_t, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(time_t) - 1 > 2 * PyLong_SHIFT) {
                            return (time_t) ((((((time_t)digits[1]) << PyLong_SHIFT) | (time_t)digits[0])));
                        }
                    }
                    break;
                case -3:
                    if (8 * sizeof(time_t) - 1 > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(time_t, long, -(long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(time_t) - 1 > 3 * PyLong_SHIFT) {
                            return (time_t) (((time_t)-1)*(((((((time_t)digits[2]) << PyLong_SHIFT) | (time_t)digits[1]) << PyLong_SHIFT) | (time_t)digits[0])));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(time_t) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(time_t, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(time_t) - 1 > 3 * PyLong_SHIFT) {
                            return (time_t) ((((((((time_t)digits[2]) << PyLong_SHIFT) | (time_t)digits[1]) << PyLong_SHIFT) | (time_t)digits[0])));
                        }
                    }
                    break;
                case -4:
                    if (8 * sizeof(time_t) - 1 > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(time_t, long, -(long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(time_t) - 1 > 4 * PyLong_SHIFT) {
                            return (time_t) (((time_t)-1)*(((((((((time_t)digits[3]) << PyLong_SHIFT) | (time_t)digits[2]) << PyLong_SHIFT) | (time_t)digits[1]) << PyLong_SHIFT) | (time_t)digits[0])));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(time_t) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(time_t, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(time_t) - 1 > 4 * PyLong_SHIFT) {
                            return (time_t) ((((((((((time_t)digits[3]) << PyLong_SHIFT) | (time_t)digits[2]) << PyLong_SHIFT) | (time_t)digits[1]) << PyLong_SHIFT) | (time_t)digits[0])));
                        }
                    }
                    break;
            }
#endif
            if (sizeof(time_t) <= sizeof(long)) {
                __PYX_VERIFY_RETURN_INT_EXC(time_t, long, PyLong_AsLong(x))
#ifdef HAVE_LONG_LONG
            } else if (sizeof(time_t) <= sizeof(PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(time_t, PY_LONG_LONG, PyLong_AsLongLong(x))
#endif
            }
        }
        {
#if CYTHON_COMPILING_IN_PYPY && !defined(_PyLong_AsByteArray)
            PyErr_SetString(PyExc_RuntimeError,
                            "_PyLong_AsByteArray() not available in PyPy, cannot convert large numbers");
#else
            time_t val;
            PyObject *v = __Pyx_PyNumber_IntOrLong(x);
 #if PY_MAJOR_VERSION < 3
            if (likely(v) && !PyLong_Check(v)) {
                PyObject *tmp = v;
                v = PyNumber_Long(tmp);
                Py_DECREF(tmp);
            }
 #endif
            if (likely(v)) {
                int one = 1; int is_little = (int)*(unsigned char *)&one;
                unsigned char *bytes = (unsigned char *)&val;
                int ret = _PyLong_AsByteArray((PyLongObject *)v,
                                              bytes, sizeof(val),
                                              is_little, !is_unsigned);
                Py_DECREF(v);
                if (likely(!ret))
                    return val;
            }
#endif
            return (time_t) -1;
        }
    } else {
        time_t val;
        PyObject *tmp = __Pyx_PyNumber_IntOrLong(x);
        if (!tmp) return (time_t) -1;
        val = __Pyx_PyInt_As_time_t(tmp);
        Py_DECREF(tmp);
        return val;
    }
raise_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "value too large to convert to time_t");
    return (time_t) -1;
raise_neg_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "can't convert negative value to time_t");
    return (time_t) -1;
}

/* CIntToPy */
            static CYTHON_INLINE PyObject* __Pyx_PyInt_From_long(long value) {
    const long neg_one = (long) -1, const_zero = (long) 0;
    const int is_unsigned = neg_one > const_zero;
    if (is_unsigned) {
        if (sizeof(long) < sizeof(long)) {
            return PyInt_FromLong((long) value);
        } else if (sizeof(long) <= sizeof(unsigned long)) {
            return PyLong_FromUnsignedLong((unsigned long) value);
#ifdef HAVE_LONG_LONG
        } else if (sizeof(long) <= sizeof(unsigned PY_LONG_LONG)) {
            return PyLong_FromUnsignedLongLong((unsigned PY_LONG_LONG) value);
#endif
        }
    } else {
        if (sizeof(long) <= sizeof(long)) {
            return PyInt_FromLong((long) value);
#ifdef HAVE_LONG_LONG
        } else if (sizeof(long) <= sizeof(PY_LONG_LONG)) {
            return PyLong_FromLongLong((PY_LONG_LONG) value);
#endif
        }
    }
    {
        int one = 1; int little = (int)*(unsigned char *)&one;
        unsigned char *bytes = (unsigned char *)&value;
        return _PyLong_FromByteArray(bytes, sizeof(long),
                                     little, !is_unsigned);
    }
}

/* CIntFromPy */
            static CYTHON_INLINE long __Pyx_PyInt_As_long(PyObject *x) {
    const long neg_one = (long) -1, const_zero = (long) 0;
    const int is_unsigned = neg_one > const_zero;
#if PY_MAJOR_VERSION < 3
    if (likely(PyInt_Check(x))) {
        if (sizeof(long) < sizeof(long)) {
            __PYX_VERIFY_RETURN_INT(long, long, PyInt_AS_LONG(x))
        } else {
            long val = PyInt_AS_LONG(x);
            if (is_unsigned && unlikely(val < 0)) {
                goto raise_neg_overflow;
            }
            return (long) val;
        }
    } else
#endif
    if (likely(PyLong_Check(x))) {
        if (is_unsigned) {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (long) 0;
                case  1: __PYX_VERIFY_RETURN_INT(long, digit, digits[0])
                case 2:
                    if (8 * sizeof(long) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(long) >= 2 * PyLong_SHIFT) {
                            return (long) (((((long)digits[1]) << PyLong_SHIFT) | (long)digits[0]));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(long) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(long) >= 3 * PyLong_SHIFT) {
                            return (long) (((((((long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0]));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(long) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(long) >= 4 * PyLong_SHIFT) {
                            return (long) (((((((((long)digits[3]) << PyLong_SHIFT) | (long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0]));
                        }
                    }
                    break;
            }
#endif
#if CYTHON_COMPILING_IN_CPYTHON
            if (unlikely(Py_SIZE(x) < 0)) {
                goto raise_neg_overflow;
            }
#else
            {
                int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                if (unlikely(result < 0))
                    return (long) -1;
                if (unlikely(result == 1))
                    goto raise_neg_overflow;
            }
#endif
            if (sizeof(long) <= sizeof(unsigned long)) {
                __PYX_VERIFY_RETURN_INT_EXC(long, unsigned long, PyLong_AsUnsignedLong(x))
#ifdef HAVE_LONG_LONG
            } else if (sizeof(long) <= sizeof(unsigned PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(long, unsigned PY_LONG_LONG, PyLong_AsUnsignedLongLong(x))
#endif
            }
        } else {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (long) 0;
                case -1: __PYX_VERIFY_RETURN_INT(long, sdigit, (sdigit) (-(sdigit)digits[0]))
                case  1: __PYX_VERIFY_RETURN_INT(long,  digit, +digits[0])
                case -2:
                    if (8 * sizeof(long) - 1 > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(long, long, -(long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(long) - 1 > 2 * PyLong_SHIFT) {
                            return (long) (((long)-1)*(((((long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
                        }
                    }
                    break;
                case 2:
                    if (8 * sizeof(long) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(long) - 1 > 2 * PyLong_SHIFT) {
                            return (long) ((((((long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
                        }
                    }
                    break;
                case -3:
                    if (8 * sizeof(long) - 1 > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(long, long, -(long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(long) - 1 > 3 * PyLong_SHIFT) {
                            return (long) (((long)-1)*(((((((long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(long) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(long) - 1 > 3 * PyLong_SHIFT) {
                            return (long) ((((((((long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
                        }
                    }
                    break;
                case -4:
                    if (8 * sizeof(long) - 1 > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(long, long, -(long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(long) - 1 > 4 * PyLong_SHIFT) {
                            return (long) (((long)-1)*(((((((((long)digits[3]) << PyLong_SHIFT) | (long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(long) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(long) - 1 > 4 * PyLong_SHIFT) {
                            return (long) ((((((((((long)digits[3]) << PyLong_SHIFT) | (long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
                        }
                    }
                    break;
            }
#endif
            if (sizeof(long) <= sizeof(long)) {
                __PYX_VERIFY_RETURN_INT_EXC(long, long, PyLong_AsLong(x))
#ifdef HAVE_LONG_LONG
            } else if (sizeof(long) <= sizeof(PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(long, PY_LONG_LONG, PyLong_AsLongLong(x))
#endif
            }
        }
        {
#if CYTHON_COMPILING_IN_PYPY && !defined(_PyLong_AsByteArray)
            PyErr_SetString(PyExc_RuntimeError,
                            "_PyLong_AsByteArray() not available in PyPy, cannot convert large numbers");
#else
            long val;
            PyObject *v = __Pyx_PyNumber_IntOrLong(x);
 #if PY_MAJOR_VERSION < 3
            if (likely(v) && !PyLong_Check(v)) {
                PyObject *tmp = v;
                v = PyNumber_Long(tmp);
                Py_DECREF(tmp);
            }
 #endif
            if (likely(v)) {
                int one = 1; int is_little = (int)*(unsigned char *)&one;
                unsigned char *bytes = (unsigned char *)&val;
                int ret = _PyLong_AsByteArray((PyLongObject *)v,
                                              bytes, sizeof(val),
                                              is_little, !is_unsigned);
                Py_DECREF(v);
                if (likely(!ret))
                    return val;
            }
#endif
            return (long) -1;
        }
    } else {
        long val;
        PyObject *tmp = __Pyx_PyNumber_IntOrLong(x);
        if (!tmp) return (long) -1;
        val = __Pyx_PyInt_As_long(tmp);
        Py_DECREF(tmp);
        return val;
    }
raise_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "value too large to convert to long");
    return (long) -1;
raise_neg_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "can't convert negative value to long");
    return (long) -1;
}

/* CIntFromPy */
            static CYTHON_INLINE int __Pyx_PyInt_As_int(PyObject *x) {
    const int neg_one = (int) -1, const_zero = (int) 0;
    const int is_unsigned = neg_one > const_zero;
#if PY_MAJOR_VERSION < 3
    if (likely(PyInt_Check(x))) {
        if (sizeof(int) < sizeof(long)) {
            __PYX_VERIFY_RETURN_INT(int, long, PyInt_AS_LONG(x))
        } else {
            long val = PyInt_AS_LONG(x);
            if (is_unsigned && unlikely(val < 0)) {
                goto raise_neg_overflow;
            }
            return (int) val;
        }
    } else
#endif
    if (likely(PyLong_Check(x))) {
        if (is_unsigned) {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (int) 0;
                case  1: __PYX_VERIFY_RETURN_INT(int, digit, digits[0])
                case 2:
                    if (8 * sizeof(int) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int) >= 2 * PyLong_SHIFT) {
                            return (int) (((((int)digits[1]) << PyLong_SHIFT) | (int)digits[0]));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(int) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int) >= 3 * PyLong_SHIFT) {
                            return (int) (((((((int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0]));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(int) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int) >= 4 * PyLong_SHIFT) {
                            return (int) (((((((((int)digits[3]) << PyLong_SHIFT) | (int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0]));
                        }
                    }
                    break;
            }
#endif
#if CYTHON_COMPILING_IN_CPYTHON
            if (unlikely(Py_SIZE(x) < 0)) {
                goto raise_neg_overflow;
            }
#else
            {
                int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                if (unlikely(result < 0))
                    return (int) -1;
                if (unlikely(result == 1))
                    goto raise_neg_overflow;
            }
#endif
            if (sizeof(int) <= sizeof(unsigned long)) {
                __PYX_VERIFY_RETURN_INT_EXC(int, unsigned long, PyLong_AsUnsignedLong(x))
#ifdef HAVE_LONG_LONG
            } else if (sizeof(int) <= sizeof(unsigned PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(int, unsigned PY_LONG_LONG, PyLong_AsUnsignedLongLong(x))
#endif
            }
        } else {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (int) 0;
                case -1: __PYX_VERIFY_RETURN_INT(int, sdigit, (sdigit) (-(sdigit)digits[0]))
                case  1: __PYX_VERIFY_RETURN_INT(int,  digit, +digits[0])
                case -2:
                    if (8 * sizeof(int) - 1 > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int, long, -(long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int) - 1 > 2 * PyLong_SHIFT) {
                            return (int) (((int)-1)*(((((int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
                        }
                    }
                    break;
                case 2:
                    if (8 * sizeof(int) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int) - 1 > 2 * PyLong_SHIFT) {
                            return (int) ((((((int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
                        }
                    }
                    break;
                case -3:
                    if (8 * sizeof(int) - 1 > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int, long, -(long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int) - 1 > 3 * PyLong_SHIFT) {
                            return (int) (((int)-1)*(((((((int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(int) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int) - 1 > 3 * PyLong_SHIFT) {
                            return (int) ((((((((int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
                        }
                    }
                    break;
                case -4:
                    if (8 * sizeof(int) - 1 > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int, long, -(long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int) - 1 > 4 * PyLong_SHIFT) {
                            return (int) (((int)-1)*(((((((((int)digits[3]) << PyLong_SHIFT) | (int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(int) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int) - 1 > 4 * PyLong_SHIFT) {
                            return (int) ((((((((((int)digits[3]) << PyLong_SHIFT) | (int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
                        }
                    }
                    break;
            }
#endif
            if (sizeof(int) <= sizeof(long)) {
                __PYX_VERIFY_RETURN_INT_EXC(int, long, PyLong_AsLong(x))
#ifdef HAVE_LONG_LONG
            } else if (sizeof(int) <= sizeof(PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(int, PY_LONG_LONG, PyLong_AsLongLong(x))
#endif
            }
        }
        {
#if CYTHON_COMPILING_IN_PYPY && !defined(_PyLong_AsByteArray)
            PyErr_SetString(PyExc_RuntimeError,
                            "_PyLong_AsByteArray() not available in PyPy, cannot convert large numbers");
#else
            int val;
            PyObject *v = __Pyx_PyNumber_IntOrLong(x);
 #if PY_MAJOR_VERSION < 3
            if (likely(v) && !PyLong_Check(v)) {
                PyObject *tmp = v;
                v = PyNumber_Long(tmp);
                Py_DECREF(tmp);
            }
 #endif
            if (likely(v)) {
                int one = 1; int is_little = (int)*(unsigned char *)&one;
                unsigned char *bytes = (unsigned char *)&val;
                int ret = _PyLong_AsByteArray((PyLongObject *)v,
                                              bytes, sizeof(val),
                                              is_little, !is_unsigned);
                Py_DECREF(v);
                if (likely(!ret))
                    return val;
            }
#endif
            return (int) -1;
        }
    } else {
        int val;
        PyObject *tmp = __Pyx_PyNumber_IntOrLong(x);
        if (!tmp) return (int) -1;
        val = __Pyx_PyInt_As_int(tmp);
        Py_DECREF(tmp);
        return val;
    }
raise_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "value too large to convert to int");
    return (int) -1;
raise_neg_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "can't convert negative value to int");
    return (int) -1;
}

/* FastTypeChecks */
            #if CYTHON_COMPILING_IN_CPYTHON
static int __Pyx_InBases(PyTypeObject *a, PyTypeObject *b) {
    while (a) {
        a = a->tp_base;
        if (a == b)
            return 1;
    }
    return b == &PyBaseObject_Type;
}
static CYTHON_INLINE int __Pyx_IsSubtype(PyTypeObject *a, PyTypeObject *b) {
    PyObject *mro;
    if (a == b) return 1;
    mro = a->tp_mro;
    if (likely(mro)) {
        Py_ssize_t i, n;
        n = PyTuple_GET_SIZE(mro);
        for (i = 0; i < n; i++) {
            if (PyTuple_GET_ITEM(mro, i) == (PyObject *)b)
                return 1;
        }
        return 0;
    }
    return __Pyx_InBases(a, b);
}
#if PY_MAJOR_VERSION == 2
static int __Pyx_inner_PyErr_GivenExceptionMatches2(PyObject *err, PyObject* exc_type1, PyObject* exc_type2) {
    PyObject *exception, *value, *tb;
    int res;
    __Pyx_PyThreadState_declare
    __Pyx_PyThreadState_assign
    __Pyx_ErrFetch(&exception, &value, &tb);
    res = exc_type1 ? PyObject_IsSubclass(err, exc_type1) : 0;
    if (unlikely(res == -1)) {
        PyErr_WriteUnraisable(err);
        res = 0;
    }
    if (!res) {
        res = PyObject_IsSubclass(err, exc_type2);
        if (unlikely(res == -1)) {
            PyErr_WriteUnraisable(err);
            res = 0;
        }
    }
    __Pyx_ErrRestore(exception, value, tb);
    return res;
}
#else
static CYTHON_INLINE int __Pyx_inner_PyErr_GivenExceptionMatches2(PyObject *err, PyObject* exc_type1, PyObject *exc_type2) {
    int res = exc_type1 ? __Pyx_IsSubtype((PyTypeObject*)err, (PyTypeObject*)exc_type1) : 0;
    if (!res) {
        res = __Pyx_IsSubtype((PyTypeObject*)err, (PyTypeObject*)exc_type2);
    }
    return res;
}
#endif
static CYTHON_INLINE int __Pyx_PyErr_GivenExceptionMatches(PyObject *err, PyObject* exc_type) {
    if (likely(err == exc_type)) return 1;
    if (likely(PyExceptionClass_Check(err))) {
        return __Pyx_inner_PyErr_GivenExceptionMatches2(err, NULL, exc_type);
    }
    return PyErr_GivenExceptionMatches(err, exc_type);
}
static CYTHON_INLINE int __Pyx_PyErr_GivenExceptionMatches2(PyObject *err, PyObject *exc_type1, PyObject *exc_type2) {
    if (likely(err == exc_type1 || err == exc_type2)) return 1;
    if (likely(PyExceptionClass_Check(err))) {
        return __Pyx_inner_PyErr_GivenExceptionMatches2(err, exc_type1, exc_type2);
    }
    return (PyErr_GivenExceptionMatches(err, exc_type1) || PyErr_GivenExceptionMatches(err, exc_type2));
}
#endif

/* CheckBinaryVersion */
            static int __Pyx_check_binary_version(void) {
    char ctversion[4], rtversion[4];
    PyOS_snprintf(ctversion, 4, "%d.%d", PY_MAJOR_VERSION, PY_MINOR_VERSION);
    PyOS_snprintf(rtversion, 4, "%s", Py_GetVersion());
    if (ctversion[0] != rtversion[0] || ctversion[2] != rtversion[2]) {
        char message[200];
        PyOS_snprintf(message, sizeof(message),
                      "compiletime version %s of module '%.100s' "
                      "does not match runtime version %s",
                      ctversion, __Pyx_MODULE_NAME, rtversion);
        return PyErr_WarnEx(NULL, message, 1);
    }
    return 0;
}

/* FunctionExport */
            static int __Pyx_ExportFunction(const char *name, void (*f)(void), const char *sig) {
    PyObject *d = 0;
    PyObject *cobj = 0;
    union {
        void (*fp)(void);
        void *p;
    } tmp;
    d = PyObject_GetAttrString(__pyx_m, (char *)"__pyx_capi__");
    if (!d) {
        PyErr_Clear();
        d = PyDict_New();
        if (!d)
            goto bad;
        Py_INCREF(d);
        if (PyModule_AddObject(__pyx_m, (char *)"__pyx_capi__", d) < 0)
            goto bad;
    }
    tmp.fp = f;
#if PY_VERSION_HEX >= 0x02070000
    cobj = PyCapsule_New(tmp.p, sig, 0);
#else
    cobj = PyCObject_FromVoidPtrAndDesc(tmp.p, (void *)sig, 0);
#endif
    if (!cobj)
        goto bad;
    if (PyDict_SetItemString(d, name, cobj) < 0)
        goto bad;
    Py_DECREF(cobj);
    Py_DECREF(d);
    return 0;
bad:
    Py_XDECREF(cobj);
    Py_XDECREF(d);
    return -1;
}

/* InitStrings */
            static int __Pyx_InitStrings(__Pyx_StringTabEntry *t) {
    while (t->p) {
        #if PY_MAJOR_VERSION < 3
        if (t->is_unicode) {
            *t->p = PyUnicode_DecodeUTF8(t->s, t->n - 1, NULL);
        } else if (t->intern) {
            *t->p = PyString_InternFromString(t->s);
        } else {
            *t->p = PyString_FromStringAndSize(t->s, t->n - 1);
        }
        #else
        if (t->is_unicode | t->is_str) {
            if (t->intern) {
                *t->p = PyUnicode_InternFromString(t->s);
            } else if (t->encoding) {
                *t->p = PyUnicode_Decode(t->s, t->n - 1, t->encoding, NULL);
            } else {
                *t->p = PyUnicode_FromStringAndSize(t->s, t->n - 1);
            }
        } else {
            *t->p = PyBytes_FromStringAndSize(t->s, t->n - 1);
        }
        #endif
        if (!*t->p)
            return -1;
        if (PyObject_Hash(*t->p) == -1)
            PyErr_Clear();
        ++t;
    }
    return 0;
}

static CYTHON_INLINE PyObject* __Pyx_PyUnicode_FromString(const char* c_str) {
    return __Pyx_PyUnicode_FromStringAndSize(c_str, (Py_ssize_t)strlen(c_str));
}
static CYTHON_INLINE const char* __Pyx_PyObject_AsString(PyObject* o) {
    Py_ssize_t ignore;
    return __Pyx_PyObject_AsStringAndSize(o, &ignore);
}
#if __PYX_DEFAULT_STRING_ENCODING_IS_ASCII || __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT
#if !CYTHON_PEP393_ENABLED
static const char* __Pyx_PyUnicode_AsStringAndSize(PyObject* o, Py_ssize_t *length) {
    char* defenc_c;
    PyObject* defenc = _PyUnicode_AsDefaultEncodedString(o, NULL);
    if (!defenc) return NULL;
    defenc_c = PyBytes_AS_STRING(defenc);
#if __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
    {
        char* end = defenc_c + PyBytes_GET_SIZE(defenc);
        char* c;
        for (c = defenc_c; c < end; c++) {
            if ((unsigned char) (*c) >= 128) {
                PyUnicode_AsASCIIString(o);
                return NULL;
            }
        }
    }
#endif
    *length = PyBytes_GET_SIZE(defenc);
    return defenc_c;
}
#else
static CYTHON_INLINE const char* __Pyx_PyUnicode_AsStringAndSize(PyObject* o, Py_ssize_t *length) {
    if (unlikely(__Pyx_PyUnicode_READY(o) == -1)) return NULL;
#if __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
    if (likely(PyUnicode_IS_ASCII(o))) {
        *length = PyUnicode_GET_LENGTH(o);
        return PyUnicode_AsUTF8(o);
    } else {
        PyUnicode_AsASCIIString(o);
        return NULL;
    }
#else
    return PyUnicode_AsUTF8AndSize(o, length);
#endif
}
#endif
#endif
static CYTHON_INLINE const char* __Pyx_PyObject_AsStringAndSize(PyObject* o, Py_ssize_t *length) {
#if __PYX_DEFAULT_STRING_ENCODING_IS_ASCII || __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT
    if (
#if PY_MAJOR_VERSION < 3 && __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
            __Pyx_sys_getdefaultencoding_not_ascii &&
#endif
            PyUnicode_Check(o)) {
        return __Pyx_PyUnicode_AsStringAndSize(o, length);
    } else
#endif
#if (!CYTHON_COMPILING_IN_PYPY) || (defined(PyByteArray_AS_STRING) && defined(PyByteArray_GET_SIZE))
    if (PyByteArray_Check(o)) {
        *length = PyByteArray_GET_SIZE(o);
        return PyByteArray_AS_STRING(o);
    } else
#endif
    {
        char* result;
        int r = PyBytes_AsStringAndSize(o, &result, length);
        if (unlikely(r < 0)) {
            return NULL;
        } else {
            return result;
        }
    }
}
static CYTHON_INLINE int __Pyx_PyObject_IsTrue(PyObject* x) {
   int is_true = x == Py_True;
   if (is_true | (x == Py_False) | (x == Py_None)) return is_true;
   else return PyObject_IsTrue(x);
}
static PyObject* __Pyx_PyNumber_IntOrLongWrongResultType(PyObject* result, const char* type_name) {
#if PY_MAJOR_VERSION >= 3
    if (PyLong_Check(result)) {
        if (PyErr_WarnFormat(PyExc_DeprecationWarning, 1,
                "__int__ returned non-int (type %.200s).  "
                "The ability to return an instance of a strict subclass of int "
                "is deprecated, and may be removed in a future version of Python.",
                Py_TYPE(result)->tp_name)) {
            Py_DECREF(result);
            return NULL;
        }
        return result;
    }
#endif
    PyErr_Format(PyExc_TypeError,
                 "__%.4s__ returned non-%.4s (type %.200s)",
                 type_name, type_name, Py_TYPE(result)->tp_name);
    Py_DECREF(result);
    return NULL;
}
static CYTHON_INLINE PyObject* __Pyx_PyNumber_IntOrLong(PyObject* x) {
#if CYTHON_USE_TYPE_SLOTS
  PyNumberMethods *m;
#endif
  const char *name = NULL;
  PyObject *res = NULL;
#if PY_MAJOR_VERSION < 3
  if (likely(PyInt_Check(x) || PyLong_Check(x)))
#else
  if (likely(PyLong_Check(x)))
#endif
    return __Pyx_NewRef(x);
#if CYTHON_USE_TYPE_SLOTS
  m = Py_TYPE(x)->tp_as_number;
  #if PY_MAJOR_VERSION < 3
  if (m && m->nb_int) {
    name = "int";
    res = m->nb_int(x);
  }
  else if (m && m->nb_long) {
    name = "long";
    res = m->nb_long(x);
  }
  #else
  if (likely(m && m->nb_int)) {
    name = "int";
    res = m->nb_int(x);
  }
  #endif
#else
  if (!PyBytes_CheckExact(x) && !PyUnicode_CheckExact(x)) {
    res = PyNumber_Int(x);
  }
#endif
  if (likely(res)) {
#if PY_MAJOR_VERSION < 3
    if (unlikely(!PyInt_Check(res) && !PyLong_Check(res))) {
#else
    if (unlikely(!PyLong_CheckExact(res))) {
#endif
        return __Pyx_PyNumber_IntOrLongWrongResultType(res, name);
    }
  }
  else if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
                    "an integer is required");
  }
  return res;
}
static CYTHON_INLINE Py_ssize_t __Pyx_PyIndex_AsSsize_t(PyObject* b) {
  Py_ssize_t ival;
  PyObject *x;
#if PY_MAJOR_VERSION < 3
  if (likely(PyInt_CheckExact(b))) {
    if (sizeof(Py_ssize_t) >= sizeof(long))
        return PyInt_AS_LONG(b);
    else
        return PyInt_AsSsize_t(x);
  }
#endif
  if (likely(PyLong_CheckExact(b))) {
    #if CYTHON_USE_PYLONG_INTERNALS
    const digit* digits = ((PyLongObject*)b)->ob_digit;
    const Py_ssize_t size = Py_SIZE(b);
    if (likely(__Pyx_sst_abs(size) <= 1)) {
        ival = likely(size) ? digits[0] : 0;
        if (size == -1) ival = -ival;
        return ival;
    } else {
      switch (size) {
         case 2:
           if (8 * sizeof(Py_ssize_t) > 2 * PyLong_SHIFT) {
             return (Py_ssize_t) (((((size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0]));
           }
           break;
         case -2:
           if (8 * sizeof(Py_ssize_t) > 2 * PyLong_SHIFT) {
             return -(Py_ssize_t) (((((size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0]));
           }
           break;
         case 3:
           if (8 * sizeof(Py_ssize_t) > 3 * PyLong_SHIFT) {
             return (Py_ssize_t) (((((((size_t)digits[2]) << PyLong_SHIFT) | (size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0]));
           }
           break;
         case -3:
           if (8 * sizeof(Py_ssize_t) > 3 * PyLong_SHIFT) {
             return -(Py_ssize_t) (((((((size_t)digits[2]) << PyLong_SHIFT) | (size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0]));
           }
           break;
         case 4:
           if (8 * sizeof(Py_ssize_t) > 4 * PyLong_SHIFT) {
             return (Py_ssize_t) (((((((((size_t)digits[3]) << PyLong_SHIFT) | (size_t)digits[2]) << PyLong_SHIFT) | (size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0]));
           }
           break;
         case -4:
           if (8 * sizeof(Py_ssize_t) > 4 * PyLong_SHIFT) {
             return -(Py_ssize_t) (((((((((size_t)digits[3]) << PyLong_SHIFT) | (size_t)digits[2]) << PyLong_SHIFT) | (size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0]));
           }
           break;
      }
    }
    #endif
    return PyLong_AsSsize_t(b);
  }
  x = PyNumber_Index(b);
  if (!x) return -1;
  ival = PyInt_AsSsize_t(x);
  Py_DECREF(x);
  return ival;
}
static CYTHON_INLINE PyObject * __Pyx_PyInt_FromSize_t(size_t ival) {
    return PyInt_FromSize_t(ival);
}


#endif /* Py_PYTHON_H */
// See www.openfst.org for extensive documentation on this weighted
// finite-state transducer library.

#include <fst/extensions/linear/linear-fst.h>
#include <fst/register.h>

using fst::LinearClassifierFst;
using fst::StdArc;
using fst::LogArc;

REGISTER_FST(LinearClassifierFst, StdArc);
REGISTER_FST(LinearClassifierFst, LogArc);
// See www.openfst.org for extensive documentation on this weighted
// finite-state transducer library.

#include <cctype>
#include <cstdio>
#include <set>

#include <fst/compat.h>
#include <fst/flags.h>
#include <fst/extensions/linear/linearscript.h>
#include <fst/arc.h>
#include <fstream>
#include <fst/script/script-impl.h>

DEFINE_string(delimiter, "|",
              "Single non-white-space character delimiter inside sequences of "
              "feature symbols and output symbols");
DEFINE_string(empty_symbol, "<empty>",
              "Special symbol that designates an empty sequence");

DEFINE_string(start_symbol, "<s>", "Start of sentence symbol");
DEFINE_string(end_symbol, "</s>", "End of sentence symbol");

DEFINE_bool(classifier, false,
            "Treat input model as a classifier instead of a tagger");

namespace fst {
namespace script {

bool ValidateDelimiter() {
  if (FLAGS_delimiter.size() == 1 && !std::isspace(FLAGS_delimiter[0]))
    return true;
  return false;
}

bool ValidateEmptySymbol() {
  bool okay = !FLAGS_empty_symbol.empty();
  for (size_t i = 0; i < FLAGS_empty_symbol.size(); ++i) {
    char c = FLAGS_empty_symbol[i];
    if (std::isspace(c)) okay = false;
  }
  return okay;
}

void LinearCompile(const string &arc_type, const string &epsilon_symbol,
                   const string &unknown_symbol, const string &vocab,
                   char **models, int models_len, const string &out,
                   const string &save_isymbols, const string &save_fsymbols,
                   const string &save_osymbols) {
  LinearCompileArgs args(epsilon_symbol, unknown_symbol, vocab, models,
                         models_len, out, save_isymbols, save_fsymbols,
                         save_osymbols);
  Apply<Operation<LinearCompileArgs>>("LinearCompileTpl", arc_type, &args);
}

// Instantiate templates for common arc types
REGISTER_FST_LINEAR_OPERATIONS(StdArc);
REGISTER_FST_LINEAR_OPERATIONS(LogArc);

void SplitByWhitespace(const string &str, std::vector<string> *out) {
  out->clear();
  std::istringstream strm(str);
  string buf;
  while (strm >> buf) out->push_back(buf);
}

int ScanNumClasses(char **models, int models_len) {
  std::set<string> preds;
  for (int i = 0; i < models_len; ++i) {
    std::ifstream in(models[i]);
    if (!in) LOG(FATAL) << "Failed to open " << models[i];

    string line;
    std::getline(in, line);

    size_t num_line = 1;
    while (std::getline(in, line)) {
      ++num_line;
      std::vector<string> fields;
      SplitByWhitespace(line, &fields);
      if (fields.size() != 3)
        LOG(FATAL) << "Wrong number of fields in source " << models[i]
                   << ", line " << num_line;
      preds.insert(fields[1]);
    }
  }
  return preds.size();
}

}  // namespace script
}  // namespace fst
// See www.openfst.org for extensive documentation on this weighted
// finite-state transducer library.

#include <fst/extensions/linear/linearscript.h>

#include <fst/flags.h>

DEFINE_string(arc_type, "standard", "Output arc type");

DEFINE_string(epsilon_symbol, "<eps>", "Epsilon symbol");
DEFINE_string(unknown_symbol, "<unk>", "Unknown word symbol");

DEFINE_string(vocab, "", "Path to the vocabulary file");
DEFINE_string(out, "", "Path to the output binary");

DEFINE_string(save_isymbols, "", "Save input symbol table to file");
DEFINE_string(save_fsymbols, "", "Save feature symbol table to file");
DEFINE_string(save_osymbols, "", "Save output symbol table to file");

int main(int argc, char **argv) {
  // TODO(wuke): more detailed usage
  std::set_new_handler(FailedNewHandler);
  SET_FLAGS(argv[0], &argc, &argv, true);
  fst::script::ValidateDelimiter();
  fst::script::ValidateEmptySymbol();

  if (argc == 1) {
    ShowUsage();
    return 1;
  }

  fst::script::LinearCompile(FLAGS_arc_type, FLAGS_epsilon_symbol,
                                 FLAGS_unknown_symbol, FLAGS_vocab, argv + 1,
                                 argc - 1, FLAGS_out, FLAGS_save_isymbols,
                                 FLAGS_save_fsymbols, FLAGS_save_osymbols);
}
// See www.openfst.org for extensive documentation on this weighted
// finite-state transducer library.

#include <fst/compat.h>
#include <fst/extensions/linear/linear-fst.h>
#include <fst/extensions/linear/loglinear-apply.h>
#include <fst/vector-fst.h>

#include <fst/flags.h>
#include <fst/log.h>

DEFINE_bool(normalize, true, "Normalize to get posterior");

int main(int argc, char **argv) {
  string usage =
      "Applies an FST to another FST, treating the second as a log-linear "
      "model.\n\n  "
      "Usage: ";
  usage += argv[0];
  usage += " in.fst linear.fst [out.fst]\n";

  std::set_new_handler(FailedNewHandler);
  SET_FLAGS(usage.c_str(), &argc, &argv, true);
  if (argc < 3 || argc > 4) {
    ShowUsage();
    return 1;
  }

  string in_name = strcmp(argv[1], "-") != 0 ? argv[1] : "";
  string linear_name = (argc > 2 && (strcmp(argv[2], "-") != 0)) ? argv[2] : "";
  string out_name = argc > 3 ? argv[3] : "";

  if (in_name.empty() && linear_name.empty()) {
    LOG(ERROR) << argv[0] << ": Can't take both inputs from standard input.";
    return 1;
  }

  fst::StdFst *ifst1 = fst::StdFst::Read(in_name);
  if (!ifst1) return 1;

  fst::StdFst *ifst2 = fst::StdFst::Read(linear_name);
  if (!ifst2) return 1;

  fst::StdVectorFst ofst;

  LogLinearApply(*ifst1, *ifst2, &ofst, FLAGS_normalize);

  ofst.Write(out_name);

  return 0;
}
// See www.openfst.org for extensive documentation on this weighted
// finite-state transducer library.

#include <fst/extensions/linear/linear-fst.h>
#include <fst/register.h>

using fst::LinearTaggerFst;
using fst::StdArc;
using fst::LogArc;

REGISTER_FST(LinearTaggerFst, StdArc);
REGISTER_FST(LinearTaggerFst, LogArc);
// See www.openfst.org for extensive documentation on this weighted
// finite-state transducer library.
//
// Converts an RTN represented by FSTs and non-terminal labels into a PDT.

#include <cstring>

#include <string>
#include <vector>

#include <fst/flags.h>

#include <fst/extensions/pdt/getters.h>
#include <fst/extensions/pdt/pdtscript.h>
#include <fst/util.h>
#include <fst/vector-fst.h>

DEFINE_string(pdt_parentheses, "", "PDT parenthesis label pairs");
DEFINE_string(pdt_parser_type, "left",
              "Construction method, one of: \"left\", \"left_sr\"");
DEFINE_int64(start_paren_labels, fst::kNoLabel,
             "Index to use for the first inserted parentheses; if not "
             "specified, the next available label beyond the highest output "
             "label is used");
DEFINE_string(left_paren_prefix, "(_", "Prefix to attach to SymbolTable "
              "labels for inserted left parentheses");
DEFINE_string(right_paren_prefix, ")_", "Prefix to attach to SymbolTable "
              "labels for inserted right parentheses");

void Cleanup(std::vector<fst::script::LabelFstClassPair> *pairs) {
  for (const auto &pair : *pairs) {
    delete pair.second;
  }
  pairs->clear();
}

int main(int argc, char **argv) {
  namespace s = fst::script;
  using fst::script::FstClass;
  using fst::script::VectorFstClass;
  using fst::PdtParserType;
  using fst::WriteLabelPairs;

  string usage = "Converts an RTN represented by FSTs";
  usage += " and non-terminal labels into PDT.\n\n  Usage: ";
  usage += argv[0];
  usage += " root.fst rootlabel [rule1.fst label1 ...] [out.fst]\n";

  std::set_new_handler(FailedNewHandler);
  SET_FLAGS(usage.c_str(), &argc, &argv, true);
  if (argc < 4) {
    ShowUsage();
    return 1;
  }

  const string in_name = argv[1];
  const string out_name = argc % 2 == 0 ? argv[argc - 1] : "";

  auto *ifst = FstClass::Read(in_name);
  if (!ifst) return 1;

  PdtParserType parser_type;
  if (!s::GetPdtParserType(FLAGS_pdt_parser_type, &parser_type)) {
    LOG(ERROR) << argv[0] << ": Unknown PDT parser type: "
               << FLAGS_pdt_parser_type;
    delete ifst;
    return 1;
  }

  std::vector<s::LabelFstClassPair> pairs;
  // Note that if the root label is beyond the range of the underlying FST's
  // labels, truncation will occur.
  const auto root = atoll(argv[2]);
  pairs.emplace_back(root, ifst);

  for (auto i = 3; i < argc - 1; i += 2) {
    ifst = FstClass::Read(argv[i]);
    if (!ifst) {
      Cleanup(&pairs);
      return 1;
    }
    // Note that if the root label is beyond the range of the underlying FST's
    // labels, truncation will occur.
    const auto label = atoll(argv[i + 1]);
    pairs.emplace_back(label, ifst);
  }

  VectorFstClass ofst(ifst->ArcType());
  std::vector<s::LabelPair> parens;
  s::PdtReplace(pairs, &ofst, &parens, root, parser_type,
                FLAGS_start_paren_labels, FLAGS_left_paren_prefix,
                FLAGS_right_paren_prefix);
  Cleanup(&pairs);

  if (!FLAGS_pdt_parentheses.empty()) {
    if (!WriteLabelPairs(FLAGS_pdt_parentheses, parens)) return 1;
  }

  ofst.Write(out_name);

  return 0;
}
// See www.openfst.org for extensive documentation on this weighted
// finite-state transducer library.
//
// Prints out various information about a PDT such as number of states, arcs,
// and parentheses.

#include <cstring>

#include <memory>
#include <string>
#include <vector>

#include <fst/flags.h>
#include <fst/log.h>

#include <fst/extensions/pdt/pdtscript.h>
#include <fst/util.h>

DEFINE_string(pdt_parentheses, "", "PDT parenthesis label pairs");

int main(int argc, char **argv) {
  namespace s = fst::script;
  using fst::ReadLabelPairs;
  using fst::script::FstClass;

  string usage = "Prints out information about a PDT.\n\n  Usage: ";
  usage += argv[0];
  usage += " in.pdt\n";

  std::set_new_handler(FailedNewHandler);
  SET_FLAGS(usage.c_str(), &argc, &argv, true);
  if (argc > 2) {
    ShowUsage();
    return 1;
  }

  const string in_name =
      (argc > 1 && (strcmp(argv[1], "-") != 0)) ? argv[1] : "";

  std::unique_ptr<FstClass> ifst(FstClass::Read(in_name));
  if (!ifst) return 1;

  if (FLAGS_pdt_parentheses.empty()) {
    LOG(ERROR) << argv[0] << ": No PDT parenthesis label pairs provided";
    return 1;
  }

  std::vector<s::LabelPair> parens;
  if (!ReadLabelPairs(FLAGS_pdt_parentheses, &parens, false)) return 1;

  s::PrintPdtInfo(*ifst, parens);

  return 0;
}
// See www.openfst.org for extensive documentation on this weighted
// finite-state transducer library.
//
// Definitions of 'scriptable' versions of pdt operations, that is,
// those that can be called with FstClass-type arguments.
//
// See comments in nlp/fst/script/script-impl.h for how the registration
// mechanism allows these to work with various arc types.

#include <string>
#include <vector>

#include <fst/extensions/pdt/compose.h>
#include <fst/extensions/pdt/expand.h>
#include <fst/extensions/pdt/pdtscript.h>
#include <fst/extensions/pdt/replace.h>
#include <fst/extensions/pdt/reverse.h>
#include <fst/extensions/pdt/shortest-path.h>
#include <fst/script/script-impl.h>

namespace fst {
namespace script {

void PdtCompose(const FstClass &ifst1, const FstClass &ifst2,
                const std::vector<LabelPair> &parens,
                MutableFstClass *ofst, const PdtComposeOptions &copts,
                bool left_pdt) {
  if (!internal::ArcTypesMatch(ifst1, ifst2, "PdtCompose") ||
      !internal::ArcTypesMatch(ifst1, *ofst, "PdtCompose"))
    return;
  PdtComposeArgs args(ifst1, ifst2, parens, ofst, copts, left_pdt);
  Apply<Operation<PdtComposeArgs>>("PdtCompose", ifst1.ArcType(), &args);
}

void PdtExpand(const FstClass &ifst,
               const std::vector<LabelPair> &parens,
               MutableFstClass *ofst, const PdtExpandOptions &opts) {
  PdtExpandArgs args(ifst, parens, ofst, opts);
  Apply<Operation<PdtExpandArgs>>("PdtExpand", ifst.ArcType(), &args);
}

void PdtExpand(const FstClass &ifst,
               const std::vector<std::pair<int64, int64>> &parens,
               MutableFstClass *ofst, bool connect, bool keep_parentheses,
               const WeightClass &weight_threshold) {
  PdtExpand(ifst, parens, ofst,
            PdtExpandOptions(connect, keep_parentheses, weight_threshold));
}

void PdtReplace(const std::vector<LabelFstClassPair> &pairs,
                MutableFstClass *ofst, std::vector<LabelPair> *parens,
                int64 root, PdtParserType parser_type, int64 start_paren_labels,
                const string &left_paren_prefix,
                const string &right_paren_prefix) {
  for (size_t i = 1; i < pairs.size(); ++i) {
    if (!internal::ArcTypesMatch(*pairs[i - 1].second, *pairs[i].second,
                                 "PdtReplace"))
      return;
  }
  if (!internal::ArcTypesMatch(*pairs[0].second, *ofst, "PdtReplace")) return;
  PdtReplaceArgs args(pairs, ofst, parens, root, parser_type,
                      start_paren_labels, left_paren_prefix,
                      right_paren_prefix);
  Apply<Operation<PdtReplaceArgs>>("PdtReplace", ofst->ArcType(), &args);
}

void PdtReverse(const FstClass &ifst,
                const std::vector<LabelPair> &parens,
                MutableFstClass *ofst) {
  PdtReverseArgs args(ifst, parens, ofst);
  Apply<Operation<PdtReverseArgs>>("PdtReverse", ifst.ArcType(), &args);
}

void PdtShortestPath(const FstClass &ifst,
                     const std::vector<LabelPair> &parens,
                     MutableFstClass *ofst,
                     const PdtShortestPathOptions &opts) {
  PdtShortestPathArgs args(ifst, parens, ofst, opts);
  Apply<Operation<PdtShortestPathArgs>>("PdtShortestPath", ifst.ArcType(),
                                        &args);
}

void PrintPdtInfo(const FstClass &ifst,
                  const std::vector<LabelPair> &parens) {
  PrintPdtInfoArgs args(ifst, parens);
  Apply<Operation<PrintPdtInfoArgs>>("PrintPdtInfo", ifst.ArcType(), &args);
}

// Register operations for common arc types.

REGISTER_FST_PDT_OPERATIONS(StdArc);
REGISTER_FST_PDT_OPERATIONS(LogArc);
REGISTER_FST_PDT_OPERATIONS(Log64Arc);

}  // namespace script
}  // namespace fst
// See www.openfst.org for extensive documentation on this weighted
// finite-state transducer library.
//
// Reverses a PDT.

#include <cstring>

#include <memory>
#include <string>
#include <vector>

#include <fst/flags.h>
#include <fst/log.h>

#include <fst/extensions/pdt/pdtscript.h>
#include <fst/util.h>

DEFINE_string(pdt_parentheses, "", "PDT parenthesis label pairs");

int main(int argc, char **argv) {
  namespace s = fst::script;
  using fst::ReadLabelPairs;
  using fst::script::FstClass;
  using fst::script::VectorFstClass;

  string usage = "Reverse a PDT.\n\n  Usage: ";
  usage += argv[0];
  usage += " in.pdt [out.fst]\n";

  std::set_new_handler(FailedNewHandler);
  SET_FLAGS(usage.c_str(), &argc, &argv, true);
  if (argc > 3) {
    ShowUsage();
    return 1;
  }

  const string in_name =
      (argc > 1 && (strcmp(argv[1], "-") != 0)) ? argv[1] : "";
  const string out_name = argc > 2 ? argv[2] : "";

  std::unique_ptr<FstClass> ifst(FstClass::Read(in_name));
  if (!ifst) return 1;

  if (FLAGS_pdt_parentheses.empty()) {
    LOG(ERROR) << argv[0] << ": No PDT parenthesis label pairs provided";
    return 1;
  }

  std::vector<s::LabelPair> parens;
  if (!ReadLabelPairs(FLAGS_pdt_parentheses, &parens, false)) return 1;

  VectorFstClass ofst(ifst->ArcType());

  s::PdtReverse(*ifst, parens, &ofst);

  ofst.Write(out_name);

  return 0;
}
// See www.openfst.org for extensive documentation on this weighted
// finite-state transducer library.
//
// Expands a (bounded-stack) PDT as an FST.

#include <cstring>

#include <memory>
#include <string>
#include <vector>

#include <fst/flags.h>
#include <fst/log.h>

#include <fst/extensions/pdt/pdtscript.h>
#include <fst/util.h>

DEFINE_string(pdt_parentheses, "", "PDT parenthesis label pairs");
DEFINE_bool(connect, true, "Trim output?");
DEFINE_bool(keep_parentheses, false, "Keep PDT parentheses in result?");
DEFINE_string(weight, "", "Weight threshold");

int main(int argc, char **argv) {
  namespace s = fst::script;
  using fst::script::FstClass;
  using fst::script::VectorFstClass;
  using fst::script::WeightClass;
  using fst::ReadLabelPairs;

  string usage = "Expand a (bounded-stack) PDT as an FST.\n\n  Usage: ";
  usage += argv[0];
  usage += " in.pdt [out.fst]\n";

  std::set_new_handler(FailedNewHandler);
  SET_FLAGS(usage.c_str(), &argc, &argv, true);
  if (argc > 3) {
    ShowUsage();
    return 1;
  }

  const string in_name =
      (argc > 1 && (strcmp(argv[1], "-") != 0)) ? argv[1] : "";
  const string out_name = argc > 2 ? argv[2] : "";

  std::unique_ptr<FstClass> ifst(FstClass::Read(in_name));
  if (!ifst) return 1;

  if (FLAGS_pdt_parentheses.empty()) {
    LOG(ERROR) << argv[0] << ": No PDT parenthesis label pairs provided";
    return 1;
  }

  std::vector<s::LabelPair> parens;
  if (!ReadLabelPairs(FLAGS_pdt_parentheses, &parens, false)) return 1;

  const auto weight_threshold =
      FLAGS_weight.empty() ? WeightClass::Zero(ifst->WeightType())
                           : WeightClass(ifst->WeightType(), FLAGS_weight);

  VectorFstClass ofst(ifst->ArcType());
  s::PdtExpand(*ifst, parens, &ofst,
               s::PdtExpandOptions(FLAGS_connect, FLAGS_keep_parentheses,
                                   weight_threshold));

  ofst.Write(out_name);

  return 0;
}
// See www.openfst.org for extensive documentation on this weighted
// finite-state transducer library.

#include <fst/extensions/pdt/getters.h>

namespace fst {
namespace script {

bool GetPdtComposeFilter(const string &str, PdtComposeFilter *cf) {
  if (str == "expand") {
    *cf = EXPAND_FILTER;
  } else if (str == "expand_paren") {
    *cf = EXPAND_PAREN_FILTER;
  } else if (str == "paren") {
    *cf = PAREN_FILTER;
  } else {
    return false;
  }
  return true;
}

bool GetPdtParserType(const string &str, PdtParserType *pt) {
  if (str == "left") {
    *pt = PDT_LEFT_PARSER;
  } else if (str == "left_sr") {
    *pt = PDT_LEFT_SR_PARSER;
  } else {
    return false;
  }
  return true;
}

}  // namespace script
}  // namespace fst
// See www.openfst.org for extensive documentation on this weighted
// finite-state transducer library.
//
// Returns the shortest path in a (bounded-stack) PDT.

#include <cstring>

#include <memory>
#include <string>
#include <vector>

#include <fst/flags.h>
#include <fst/log.h>

#include <fst/extensions/pdt/pdtscript.h>
#include <fst/util.h>

DEFINE_bool(keep_parentheses, false, "Keep PDT parentheses in result?");
DEFINE_string(queue_type, "fifo",
              "Queue type: one of: "
              "\"fifo\", \"lifo\", \"state\"");
DEFINE_bool(path_gc, true, "Garbage collect shortest path data?");
DEFINE_string(pdt_parentheses, "", "PDT parenthesis label pairs");

int main(int argc, char **argv) {
  namespace s = fst::script;
  using fst::script::FstClass;
  using fst::script::VectorFstClass;
  using fst::QueueType;
  using fst::ReadLabelPairs;

  string usage = "Shortest path in a (bounded-stack) PDT.\n\n  Usage: ";
  usage += argv[0];
  usage += " in.pdt [out.fst]\n";

  std::set_new_handler(FailedNewHandler);
  SET_FLAGS(usage.c_str(), &argc, &argv, true);
  if (argc > 3) {
    ShowUsage();
    return 1;
  }

  const string in_name =
      (argc > 1 && (strcmp(argv[1], "-") != 0)) ? argv[1] : "";
  const string out_name = argc > 2 ? argv[2] : "";

  std::unique_ptr<FstClass> ifst(FstClass::Read(in_name));
  if (!ifst) return 1;

  if (FLAGS_pdt_parentheses.empty()) {
    LOG(ERROR) << argv[0] << ": No PDT parenthesis label pairs provided";
    return 1;
  }

  std::vector<s::LabelPair> parens;
  if (!ReadLabelPairs(FLAGS_pdt_parentheses, &parens, false)) return 1;

  VectorFstClass ofst(ifst->ArcType());

  QueueType qt;
  if (FLAGS_queue_type == "fifo") {
    qt = fst::FIFO_QUEUE;
  } else if (FLAGS_queue_type == "lifo") {
    qt = fst::LIFO_QUEUE;
  } else if (FLAGS_queue_type == "state") {
    qt = fst::STATE_ORDER_QUEUE;
  } else {
    LOG(ERROR) << "Unknown queue type: " << FLAGS_queue_type;
    return 1;
  }

  const s::PdtShortestPathOptions opts(qt, FLAGS_keep_parentheses,
                                       FLAGS_path_gc);

  s::PdtShortestPath(*ifst, parens, &ofst, opts);

  ofst.Write(out_name);

  return 0;
}
// See www.openfst.org for extensive documentation on this weighted
// finite-state transducer library.
//
// Composes a PDT and an FST.

#include <cstring>

#include <memory>
#include <string>
#include <vector>

#include <fst/flags.h>
#include <fst/log.h>

#include <fst/extensions/pdt/getters.h>
#include <fst/extensions/pdt/pdtscript.h>
#include <fst/util.h>

DEFINE_string(pdt_parentheses, "", "PDT parenthesis label pairs");
DEFINE_bool(left_pdt, true, "Is the first argument the PDT?");
DEFINE_bool(connect, true, "Trim output?");
DEFINE_string(compose_filter, "paren",
              "Composition filter, one of: \"expand\", \"expand_paren\", "
              "\"paren\"");

int main(int argc, char **argv) {
  namespace s = fst::script;
  using fst::ReadLabelPairs;
  using fst::PdtComposeFilter;
  using fst::PdtComposeOptions;
  using fst::script::FstClass;
  using fst::script::VectorFstClass;

  string usage = "Compose a PDT and an FST.\n\n  Usage: ";
  usage += argv[0];
  usage += " in.pdt in.fst [out.pdt]\n";
  usage += " in.fst in.pdt [out.pdt]\n";

  std::set_new_handler(FailedNewHandler);
  SET_FLAGS(usage.c_str(), &argc, &argv, true);
  if (argc < 3 || argc > 4) {
    ShowUsage();
    return 1;
  }

  const string in1_name = strcmp(argv[1], "-") == 0 ? "" : argv[1];
  const string in2_name = strcmp(argv[2], "-") == 0 ? "" : argv[2];
  const string out_name = argc > 3 ? argv[3] : "";

  if (in1_name.empty() && in2_name.empty()) {
    LOG(ERROR) << argv[0] << ": Can't take both inputs from standard input.";
    return 1;
  }

  std::unique_ptr<FstClass> ifst1(FstClass::Read(in1_name));
  if (!ifst1) return 1;
  std::unique_ptr<FstClass> ifst2(FstClass::Read(in2_name));
  if (!ifst2) return 1;

  if (FLAGS_pdt_parentheses.empty()) {
    LOG(ERROR) << argv[0] << ": No PDT parenthesis label pairs provided";
    return 1;
  }

  std::vector<s::LabelPair> parens;
  if (!ReadLabelPairs(FLAGS_pdt_parentheses, &parens, false)) return 1;

  VectorFstClass ofst(ifst1->ArcType());

  PdtComposeFilter compose_filter;
  if (!s::GetPdtComposeFilter(FLAGS_compose_filter, &compose_filter)) {
    LOG(ERROR) << argv[0] << ": Unknown or unsupported compose filter type: "
               << FLAGS_compose_filter;
    return 1;
  }

  const PdtComposeOptions copts(FLAGS_connect, compose_filter);

  s::PdtCompose(*ifst1, *ifst2, parens, &ofst, copts, FLAGS_left_pdt);

  ofst.Write(out_name);

  return 0;
}
// See www.openfst.org for extensive documentation on this weighted
// finite-state transducer library.

#include <fst/extensions/ngram/nthbit.h>

// This table is generated using:
//
//  unsigned int nth_bit_scan(uint64 v, unsigned int r) {
//    int i=0;
//    for (; i<64; i++) {
//      if ((r -= v & 1) == 0) return i;
//      v >>= 1;
//    }
//    return i;
//  }
//
//  for (size_t i = 0; i < 256; ++i) {
//    uint32 offsets = 0;
//    for (size_t b = 1; b <= 8; ++b) {
//      uint32 offset = min<uint32>(nth_bit_scan(i, b), 8);
//      offsets |= (offset << ((b - 1) << 2));
//    }
//    bit_offset = offsets;
//    printf("0x%x, ", bit_offset);
//    if (i % 4 == 3) printf("\n");
//  }
//
uint32 nth_bit_bit_offset[] = {
    0x88888888, 0x88888880, 0x88888881, 0x88888810, 0x88888882, 0x88888820,
    0x88888821, 0x88888210, 0x88888883, 0x88888830, 0x88888831, 0x88888310,
    0x88888832, 0x88888320, 0x88888321, 0x88883210, 0x88888884, 0x88888840,
    0x88888841, 0x88888410, 0x88888842, 0x88888420, 0x88888421, 0x88884210,
    0x88888843, 0x88888430, 0x88888431, 0x88884310, 0x88888432, 0x88884320,
    0x88884321, 0x88843210, 0x88888885, 0x88888850, 0x88888851, 0x88888510,
    0x88888852, 0x88888520, 0x88888521, 0x88885210, 0x88888853, 0x88888530,
    0x88888531, 0x88885310, 0x88888532, 0x88885320, 0x88885321, 0x88853210,
    0x88888854, 0x88888540, 0x88888541, 0x88885410, 0x88888542, 0x88885420,
    0x88885421, 0x88854210, 0x88888543, 0x88885430, 0x88885431, 0x88854310,
    0x88885432, 0x88854320, 0x88854321, 0x88543210, 0x88888886, 0x88888860,
    0x88888861, 0x88888610, 0x88888862, 0x88888620, 0x88888621, 0x88886210,
    0x88888863, 0x88888630, 0x88888631, 0x88886310, 0x88888632, 0x88886320,
    0x88886321, 0x88863210, 0x88888864, 0x88888640, 0x88888641, 0x88886410,
    0x88888642, 0x88886420, 0x88886421, 0x88864210, 0x88888643, 0x88886430,
    0x88886431, 0x88864310, 0x88886432, 0x88864320, 0x88864321, 0x88643210,
    0x88888865, 0x88888650, 0x88888651, 0x88886510, 0x88888652, 0x88886520,
    0x88886521, 0x88865210, 0x88888653, 0x88886530, 0x88886531, 0x88865310,
    0x88886532, 0x88865320, 0x88865321, 0x88653210, 0x88888654, 0x88886540,
    0x88886541, 0x88865410, 0x88886542, 0x88865420, 0x88865421, 0x88654210,
    0x88886543, 0x88865430, 0x88865431, 0x88654310, 0x88865432, 0x88654320,
    0x88654321, 0x86543210, 0x88888887, 0x88888870, 0x88888871, 0x88888710,
    0x88888872, 0x88888720, 0x88888721, 0x88887210, 0x88888873, 0x88888730,
    0x88888731, 0x88887310, 0x88888732, 0x88887320, 0x88887321, 0x88873210,
    0x88888874, 0x88888740, 0x88888741, 0x88887410, 0x88888742, 0x88887420,
    0x88887421, 0x88874210, 0x88888743, 0x88887430, 0x88887431, 0x88874310,
    0x88887432, 0x88874320, 0x88874321, 0x88743210, 0x88888875, 0x88888750,
    0x88888751, 0x88887510, 0x88888752, 0x88887520, 0x88887521, 0x88875210,
    0x88888753, 0x88887530, 0x88887531, 0x88875310, 0x88887532, 0x88875320,
    0x88875321, 0x88753210, 0x88888754, 0x88887540, 0x88887541, 0x88875410,
    0x88887542, 0x88875420, 0x88875421, 0x88754210, 0x88887543, 0x88875430,
    0x88875431, 0x88754310, 0x88875432, 0x88754320, 0x88754321, 0x87543210,
    0x88888876, 0x88888760, 0x88888761, 0x88887610, 0x88888762, 0x88887620,
    0x88887621, 0x88876210, 0x88888763, 0x88887630, 0x88887631, 0x88876310,
    0x88887632, 0x88876320, 0x88876321, 0x88763210, 0x88888764, 0x88887640,
    0x88887641, 0x88876410, 0x88887642, 0x88876420, 0x88876421, 0x88764210,
    0x88887643, 0x88876430, 0x88876431, 0x88764310, 0x88876432, 0x88764320,
    0x88764321, 0x87643210, 0x88888765, 0x88887650, 0x88887651, 0x88876510,
    0x88887652, 0x88876520, 0x88876521, 0x88765210, 0x88887653, 0x88876530,
    0x88876531, 0x88765310, 0x88876532, 0x88765320, 0x88765321, 0x87653210,
    0x88887654, 0x88876540, 0x88876541, 0x88765410, 0x88876542, 0x88765420,
    0x88765421, 0x87654210, 0x88876543, 0x88765430, 0x88765431, 0x87654310,
    0x88765432, 0x87654320, 0x87654321, 0x76543210,
};
// See www.openfst.org for extensive documentation on this weighted
// finite-state transducer library.

#include <fst/extensions/ngram/bitmap-index.h>

#include <algorithm>
#include <iterator>

#include <fst/log.h>
#include <fst/extensions/ngram/nthbit.h>

namespace fst {
namespace {
const size_t kPrimaryBlockBits =
    BitmapIndex::kStorageBitSize * BitmapIndex::kSecondaryBlockSize;

// If [begin, begin+size) is a monotonically increasing running sum of
// popcounts for a bitmap, this will return the index of the word that contains
// the value'th zero.  If value is larger then the number of zeros in the
// bitmap, size will be returned.  The idea is that the number of zerocounts
// (i.e. the popcount of logical NOT of values) is offset * kStorageBitSize
// minus the value for each element of the running sum.
template <size_t BlockSize, typename Container>
size_t InvertedSearch(const Container& c,
                      size_t first_idx,
                      size_t last_idx,
                      size_t value) {
  const size_t begin_idx = first_idx;
  while (first_idx != last_idx) {
    // Invariant: [first_idx, last_idx) is the search range.
    size_t mid_idx = first_idx + ((last_idx - first_idx) / 2);
    size_t mid_value = BlockSize * (1 + (mid_idx - begin_idx)) - c[mid_idx];
    if (mid_value < value) {
      first_idx = mid_idx + 1;
    } else {
      last_idx = mid_idx;
    }
  }
  return first_idx;
}
}  // namespace

size_t BitmapIndex::Rank1(size_t end) const {
  if (end == 0) return 0;
  const uint32 end_word = (end - 1) >> BitmapIndex::kStorageLogBitSize;
  const uint32 sum = get_index_ones_count(end_word);
  const size_t masked = end & kStorageBlockMask;
  if (masked == 0) {
    return sum + __builtin_popcountll(bits_[end_word]);
  } else {
    const uint64 zero = 0;
    return sum + __builtin_popcountll(bits_[end_word] &
                                      (~zero >> (kStorageBitSize - masked)));
  }
}

size_t BitmapIndex::Select1(size_t bit_index) const {
  if (bit_index >= GetOnesCount()) return Bits();
  // search primary index for the relevant block
  uint32 rembits = bit_index + 1;
  const uint32 block = find_primary_block(bit_index + 1);
  uint32 offset = 0;
  if (block > 0) {
    rembits -= primary_index_[block - 1];
    offset += block * kSecondaryBlockSize;
  }
  // search the secondary index
  uint32 word = find_secondary_block(offset, rembits);
  if (word > 0) {
    rembits -= secondary_index_[offset + word - 1];
    offset += word;
  }
  int nth = nth_bit(bits_[offset], rembits);
  return (offset << BitmapIndex::kStorageLogBitSize) + nth;
}

size_t BitmapIndex::Select0(size_t bit_index) const {
  if (bit_index >= Bits() - GetOnesCount()) return Bits();
  // search inverted primary index for relevant block
  uint32 remzeros = bit_index + 1;
  uint32 offset = 0;
  const uint32 block = find_inverted_primary_block(bit_index + 1);
  if (block > 0) {
    remzeros -= kPrimaryBlockBits * block - primary_index_[block - 1];
    offset += block * kSecondaryBlockSize;
  }
  // search the inverted secondary index
  uint32 word = find_inverted_secondary_block(offset, remzeros);
  if (word > 0) {
    remzeros -= BitmapIndex::kStorageBitSize * word -
                secondary_index_[offset + word - 1];
    offset += word;
  }
  int nth = nth_bit(~bits_[offset], remzeros);
  return (offset << BitmapIndex::kStorageLogBitSize) + nth;
}

std::pair<size_t, size_t> BitmapIndex::Select0s(size_t bit_index) const {
  const uint64 zero = 0;
  const uint64 ones = ~zero;
  size_t zeros_count = Bits() - GetOnesCount();
  if (bit_index >= zeros_count) return std::make_pair(Bits(), Bits());
  if (bit_index + 1 >= zeros_count) {
    return std::make_pair(Select0(bit_index), Bits());
  }
  // search inverted primary index for relevant block
  uint32 remzeros = bit_index + 1;
  uint32 offset = 0;
  const uint32 block = find_inverted_primary_block(bit_index + 1);
  size_t num_zeros_in_block =
      kPrimaryBlockBits * (1 + block) - primary_index_[block];
  if (block > 0) {
    size_t num_zeros_next =
        kPrimaryBlockBits * block - primary_index_[block - 1];
    num_zeros_in_block -= num_zeros_next;
    remzeros -= num_zeros_next;
    offset += block * kSecondaryBlockSize;
  }
  // search the inverted secondary index
  uint32 word = find_inverted_secondary_block(offset, remzeros);
  uint32 sum_zeros_next_word = BitmapIndex::kStorageBitSize * (1 + word) -
                               secondary_index_[offset + word];
  uint32 sum_zeros_this_word = 0;
  if (word > 0) {
    sum_zeros_this_word = BitmapIndex::kStorageBitSize * word -
                          secondary_index_[offset + word - 1];
    remzeros -= sum_zeros_this_word;
    offset += word;
  }
  int nth = nth_bit(~bits_[offset], remzeros);
  size_t current_zero = (offset << BitmapIndex::kStorageLogBitSize) + nth;

  size_t next_zero;
  // Does the current block contain the next zero?
  if (num_zeros_in_block > remzeros + 1) {
    if (sum_zeros_next_word - sum_zeros_this_word >= remzeros + 1) {
      // the next zero is in this word
      next_zero = (offset << BitmapIndex::kStorageLogBitSize) +
                  nth_bit(~bits_[offset], remzeros + 1);
    } else {
      // Find the first field that is not all ones by linear scan.
      // In the worst case, this may scan 8Kbytes.  The alternative is
      // to inspect secondary_index_ looking for a place to jump to, but
      // that would probably use more cache.
      while (bits_[++offset] == ones) {
      }
      next_zero = (offset << BitmapIndex::kStorageLogBitSize) +
                  __builtin_ctzll(~bits_[offset]);
    }
  } else {
    // the next zero is in a different block, a full search is required.
    next_zero = Select0(bit_index + 1);
  }
  return std::make_pair(current_zero, next_zero);
}

size_t BitmapIndex::get_index_ones_count(size_t array_index) const {
  uint32 sum = 0;
  if (array_index > 0) {
    sum += secondary_index_[array_index - 1];
    uint32 end_block = (array_index - 1) / kSecondaryBlockSize;
    if (end_block > 0) sum += primary_index_[end_block - 1];
  }
  return sum;
}

void BitmapIndex::BuildIndex(const uint64 *bits, size_t size) {
  bits_ = bits;
  size_ = size;
  primary_index_.resize(primary_index_size());
  secondary_index_.resize(ArraySize());
  const uint64 zero = 0;
  const uint64 ones = ~zero;
  uint32 popcount = 0;
  for (uint32 block = 0; block * kSecondaryBlockSize < ArraySize(); block++) {
    uint32 block_popcount = 0;
    uint32 block_begin = block * kSecondaryBlockSize;
    uint32 block_end = block_begin + kSecondaryBlockSize;
    if (block_end > ArraySize()) block_end = ArraySize();
    for (uint32 j = block_begin; j < block_end; ++j) {
      uint64 mask = ones;
      if (j == ArraySize() - 1) {
        mask = ones >> (-size_ & BitmapIndex::kStorageBlockMask);
      }
      block_popcount += __builtin_popcountll(bits_[j] & mask);
      secondary_index_[j] = block_popcount;
    }
    popcount += block_popcount;
    primary_index_[block] = popcount;
  }
}

size_t BitmapIndex::find_secondary_block(size_t block_begin,
                                         size_t rem_bit_index) const {
  size_t block_end = block_begin + kSecondaryBlockSize;
  if (block_end > ArraySize()) block_end = ArraySize();
  return std::distance(
      secondary_index_.begin() + block_begin,
      std::lower_bound(secondary_index_.begin() + block_begin,
                       secondary_index_.begin() + block_end, rem_bit_index));
}

size_t BitmapIndex::find_inverted_secondary_block(size_t block_begin,
                                                  size_t rem_bit_index) const {
  size_t block_end = block_begin + kSecondaryBlockSize;
  if (block_end > ArraySize()) block_end = ArraySize();
  return InvertedSearch<BitmapIndex::kStorageBitSize>(secondary_index_,
                                                      block_begin, block_end,
                                                      rem_bit_index)
      - block_begin;
}

inline size_t BitmapIndex::find_primary_block(size_t bit_index) const {
  return std::distance(
      primary_index_.begin(),
      std::lower_bound(primary_index_.begin(),
                       primary_index_.begin() + primary_index_size(),
                       bit_index));
}

size_t BitmapIndex::find_inverted_primary_block(size_t bit_index) const {
  return InvertedSearch<kPrimaryBlockBits>(
      primary_index_, 0, primary_index_.size(), bit_index);
}
}  // end namespace fst
// See www.openfst.org for extensive documentation on this weighted
// finite-state transducer library.

#include <fst/extensions/ngram/ngram-fst.h>

#include <sys/types.h>

#include <fst/arc.h>
#include <fst/register.h>

using fst::NGramFst;
using fst::StdArc;
using fst::LogArc;

REGISTER_FST(NGramFst, StdArc);
REGISTER_FST(NGramFst, LogArc);
// See www.openfst.org for extensive documentation on this weighted
// finite-state transducer library.

#include <fst/fst.h>
#include <fst/extensions/special/phi-fst.h>

DEFINE_int64(phi_fst_phi_label, 0,
             "Label of transitions to be interpreted as phi ('failure') "
              "transitions");
DEFINE_bool(phi_fst_phi_loop, true,
            "When true, a phi self loop consumes a symbol");
DEFINE_string(phi_fst_rewrite_mode, "auto",
              "Rewrite both sides when matching? One of:"
              " \"auto\" (rewrite iff acceptor), \"always\", \"never\"");

namespace fst {

const char phi_fst_type[] = "phi";
const char input_phi_fst_type[] = "input_phi";
const char output_phi_fst_type[] = "output_phi";

static FstRegisterer<StdPhiFst> PhiFst_StdArc_registerer;
static FstRegisterer<LogPhiFst> PhiFst_LogArc_registerer;
static FstRegisterer<Log64PhiFst> PhiFst_Log64Arc_registerer;

static FstRegisterer<StdInputPhiFst> InputPhiFst_StdArc_registerer;
static FstRegisterer<LogInputPhiFst> InputPhiFst_LogArc_registerer;
static FstRegisterer<Log64InputPhiFst> InputPhiFst_Log64Arc_registerer;

static FstRegisterer<StdOutputPhiFst> OutputPhiFst_StdArc_registerer;
static FstRegisterer<LogOutputPhiFst> OutputPhiFst_LogArc_registerer;
static FstRegisterer<Log64OutputPhiFst> OutputPhiFst_Log64Arc_registerer;

}  // namespace fst
// See www.openfst.org for extensive documentation on this weighted
// finite-state transducer library.

#include <fst/extensions/special/sigma-fst.h>

#include <fst/fst.h>

DEFINE_int64(sigma_fst_sigma_label, 0,
             "Label of transitions to be interpreted as sigma ('any') "
             "transitions");
DEFINE_string(sigma_fst_rewrite_mode, "auto",
              "Rewrite both sides when matching? One of:"
              " \"auto\" (rewrite iff acceptor), \"always\", \"never\"");

namespace fst {

const char sigma_fst_type[] = "sigma";
const char input_sigma_fst_type[] = "input_sigma";
const char output_sigma_fst_type[] = "output_sigma";

static FstRegisterer<StdSigmaFst> SigmaFst_StdArc_registerer;
static FstRegisterer<LogSigmaFst> SigmaFst_LogArc_registerer;
static FstRegisterer<Log64SigmaFst> SigmaFst_Log64Arc_registerer;

static FstRegisterer<StdInputSigmaFst> InputSigmaFst_StdArc_registerer;
static FstRegisterer<LogInputSigmaFst> InputSigmaFst_LogArc_registerer;
static FstRegisterer<Log64InputSigmaFst> InputSigmaFst_Log64Arc_registerer;

static FstRegisterer<StdOutputSigmaFst> OutputSigmaFst_StdArc_registerer;
static FstRegisterer<LogOutputSigmaFst> OutputSigmaFst_LogArc_registerer;
static FstRegisterer<Log64OutputSigmaFst> OutputSigmaFst_Log64Arc_registerer;

}  // namespace fst
// See www.openfst.org for extensive documentation on this weighted
// finite-state transducer library.

#include <fst/extensions/special/rho-fst.h>

#include <fst/fst.h>

DEFINE_int64(rho_fst_rho_label, 0,
             "Label of transitions to be interpreted as rho ('rest') "
             "transitions");
DEFINE_string(rho_fst_rewrite_mode, "auto",
              "Rewrite both sides when matching? One of:"
              " \"auto\" (rewrite iff acceptor), \"always\", \"never\"");

namespace fst {

const char rho_fst_type[] = "rho";
const char input_rho_fst_type[] = "input_rho";
const char output_rho_fst_type[] = "output_rho";

static FstRegisterer<StdRhoFst> RhoFst_StdArc_registerer;
static FstRegisterer<LogRhoFst> RhoFst_LogArc_registerer;
static FstRegisterer<Log64RhoFst> RhoFst_Log64Arc_registerer;

static FstRegisterer<StdInputRhoFst> InputRhoFst_StdArc_registerer;
static FstRegisterer<LogInputRhoFst> InputRhoFst_LogArc_registerer;
static FstRegisterer<Log64InputRhoFst> InputRhoFst_Log64Arc_registerer;

static FstRegisterer<StdOutputRhoFst> OutputRhoFst_StdArc_registerer;
static FstRegisterer<LogOutputRhoFst> OutputRhoFst_LogArc_registerer;
static FstRegisterer<Log64OutputRhoFst> OutputRhoFst_Log64Arc_registerer;

}  // namespace fst
// See www.openfst.org for extensive documentation on this weighted
// finite-state transducer library.

#include <fst/fst.h>
#include <fst/const-fst.h>

namespace fst {

static FstRegisterer<ConstFst<StdArc, uint16>>
    ConstFst_StdArc_uint16_registerer;
static FstRegisterer<ConstFst<LogArc, uint16>>
    ConstFst_LogArc_uint16_registerer;
static FstRegisterer<ConstFst<Log64Arc, uint16>>
    ConstFst_Log64Arc_uint16_registerer;

}  // namespace fst
// See www.openfst.org for extensive documentation on this weighted
// finite-state transducer library.

#include <fst/fst.h>
#include <fst/const-fst.h>

namespace fst {

static FstRegisterer<ConstFst<StdArc, uint8>> ConstFst_StdArc_uint8_registerer;
static FstRegisterer<ConstFst<LogArc, uint8>> ConstFst_LogArc_uint8_registerer;
static FstRegisterer<ConstFst<Log64Arc, uint8>>
    ConstFst_Log64Arc_uint8_registerer;

}  // namespace fst
// See www.openfst.org for extensive documentation on this weighted
// finite-state transducer library.

#include <fst/fst.h>
#include <fst/const-fst.h>

namespace fst {

static FstRegisterer<ConstFst<StdArc, uint64>>
    ConstFst_StdArc_uint64_registerer;
static FstRegisterer<ConstFst<LogArc, uint64>>
    ConstFst_LogArc_uint64_registerer;
static FstRegisterer<ConstFst<Log64Arc, uint64>>
    ConstFst_Log64Arc_uint64_registerer;

}  // namespace fst
// See www.openfst.org for extensive documentation on this weighted
// finite-state transducer library.
//
// Prints some basic information about the FSTs in an FST archive.

#include <string>
#include <vector>

#include <fst/flags.h>
#include <fst/extensions/far/farscript.h>
#include <fst/extensions/far/getters.h>

DEFINE_string(begin_key, "",
              "First key to extract (default: first key in archive)");
DEFINE_string(end_key, "",
              "Last key to extract (default: last key in archive)");

DEFINE_bool(list_fsts, false, "Display FST information for each key");

int main(int argc, char **argv) {
  namespace s = fst::script;

  string usage = "Prints some basic information about the FSTs in an FST ";
  usage += "archive.\n\n  Usage:";
  usage += argv[0];
  usage += " [in1.far in2.far...]\n";
  usage += "  Flags: begin_key end_key list_fsts";

  std::set_new_handler(FailedNewHandler);
  SET_FLAGS(usage.c_str(), &argc, &argv, true);
  s::ExpandArgs(argc, argv, &argc, &argv);

  std::vector<string> in_fnames;
  for (int i = 1; i < argc; ++i) in_fnames.push_back(argv[i]);
  if (in_fnames.empty()) in_fnames.push_back("");

  const auto arc_type = s::LoadArcTypeFromFar(in_fnames[0]);
  if (arc_type.empty()) return 1;

  s::FarInfo(in_fnames, arc_type, FLAGS_begin_key, FLAGS_end_key,
             FLAGS_list_fsts);

  return 0;
}
// See www.openfst.org for extensive documentation on this weighted
// finite-state transducer library.
//
// Tests if two Far files contains isomorphic (key,fst) pairs.

#include <string>

#include <fst/flags.h>
#include <fst/extensions/far/farscript.h>
#include <fst/extensions/far/getters.h>

DEFINE_string(begin_key, "",
              "First key to extract (def: first key in archive)");
DEFINE_string(end_key, "", "Last key to extract (def: last key in archive)");
DEFINE_double(delta, fst::kDelta, "Comparison/quantization delta");

int main(int argc, char **argv) {
  namespace s = fst::script;

  string usage = "Compares the FSTs in two FST archives for isomorphism.";
  usage += "\n\n  Usage:";
  usage += argv[0];
  usage += " in1.far in2.far\n";
  usage += "  Flags: begin_key end_key";

  std::set_new_handler(FailedNewHandler);
  SET_FLAGS(usage.c_str(), &argc, &argv, true);
  s::ExpandArgs(argc, argv, &argc, &argv);

  if (argc != 3) {
    ShowUsage();
    return 1;
  }

  const auto arc_type = s::LoadArcTypeFromFar(argv[1]);
  if (arc_type.empty()) return 1;

  bool result = s::FarIsomorphic(argv[1], argv[2], arc_type,
                                 FLAGS_delta, FLAGS_begin_key, FLAGS_end_key);

  if (!result) VLOG(1) << "FARs are not isomorphic.";

  return result ? 0 : 2;
}
// See www.openfst.org for extensive documentation on this weighted
// finite-state transducer library.
//
// Outputs as strings the string FSTs in a finite-state archive.

#include <string>
#include <vector>

#include <fst/flags.h>
#include <fst/extensions/far/farscript.h>
#include <fst/extensions/far/getters.h>

DEFINE_string(filename_prefix, "", "Prefix to append to filenames");
DEFINE_string(filename_suffix, "", "Suffix to append to filenames");
DEFINE_int32(generate_filenames, 0,
             "Generate N digit numeric filenames (def: use keys)");
DEFINE_string(begin_key, "",
              "First key to extract (def: first key in archive)");
DEFINE_string(end_key, "", "Last key to extract (def: last key in archive)");
// PrintStringsMain specific flag definitions.
DEFINE_bool(print_key, false, "Prefix each string by its key");
DEFINE_bool(print_weight, false, "Suffix each string by its weight");
DEFINE_string(entry_type, "line",
              "Entry type: one of : "
              "\"file\" (one FST per file), \"line\" (one FST per line)");
DEFINE_string(token_type, "symbol",
              "Token type: one of : "
              "\"symbol\", \"byte\", \"utf8\"");
DEFINE_string(symbols, "", "Label symbol table");
DEFINE_bool(initial_symbols, true,
            "Uses symbol table from the first Fst in archive for all entries.");

int main(int argc, char **argv) {
  namespace s = fst::script;

  string usage = "Print as string the string FSTs in an archive.\n\n  Usage:";
  usage += argv[0];
  usage += " [in1.far in2.far ...]\n";

  std::set_new_handler(FailedNewHandler);
  SET_FLAGS(usage.c_str(), &argc, &argv, true);
  s::ExpandArgs(argc, argv, &argc, &argv);

  std::vector<string> in_fnames;
  for (int i = 1; i < argc; ++i) in_fnames.push_back(argv[i]);
  if (in_fnames.empty()) in_fnames.push_back("");

  const auto arc_type = s::LoadArcTypeFromFar(in_fnames[0]);
  if (arc_type.empty()) return 1;

  fst::FarEntryType entry_type;
  if (!s::GetFarEntryType(FLAGS_entry_type, &entry_type)) {
    LOG(ERROR) << "Unknown or unsupported FAR entry type: " << FLAGS_entry_type;
    return 1;
  }

  fst::FarTokenType token_type;
  if (!s::GetFarTokenType(FLAGS_token_type, &token_type)) {
    LOG(ERROR) << "Unknown or unsupported FAR token type: " << FLAGS_token_type;
    return 1;
  }

  s::FarPrintStrings(in_fnames, arc_type, entry_type, token_type,
                     FLAGS_begin_key, FLAGS_end_key, FLAGS_print_key,
                     FLAGS_print_weight, FLAGS_symbols, FLAGS_initial_symbols,
                     FLAGS_generate_filenames, FLAGS_filename_prefix,
                     FLAGS_filename_suffix);

  return 0;
}
// See www.openfst.org for extensive documentation on this weighted
// finite-state transducer library.
//
// Definitions of 'scriptable' versions of FAR operations, that is,
// those that can be called with FstClass-type arguments.

#include <fst/extensions/far/farscript.h>
#include <fst/extensions/far/far.h>
#include <fst/script/script-impl.h>

namespace fst {
namespace script {

void FarCompileStrings(const std::vector<string> &in_fnames,
                       const string &out_fname, const string &arc_type,
                       const string &fst_type, const FarType &far_type,
                       int32 generate_keys, FarEntryType fet, FarTokenType tt,
                       const string &symbols_fname,
                       const string &unknown_symbol, bool keep_symbols,
                       bool initial_symbols, bool allow_negative_labels,
                       const string &key_prefix, const string &key_suffix) {
  FarCompileStringsArgs args(in_fnames, out_fname, fst_type, far_type,
                             generate_keys, fet, tt, symbols_fname,
                             unknown_symbol, keep_symbols, initial_symbols,
                             allow_negative_labels, key_prefix, key_suffix);
  Apply<Operation<FarCompileStringsArgs>>("FarCompileStrings", arc_type, &args);
}

void FarCreate(const std::vector<string> &in_fnames, const string &out_fname,
               const string &arc_type, const int32 generate_keys,
               const FarType &far_type, const string &key_prefix,
               const string &key_suffix) {
  FarCreateArgs args(in_fnames, out_fname, generate_keys, far_type, key_prefix,
                     key_suffix);
  Apply<Operation<FarCreateArgs>>("FarCreate", arc_type, &args);
}

bool FarEqual(const string &filename1, const string &filename2,
              const string &arc_type, float delta, const string &begin_key,
              const string &end_key) {
  FarEqualInnerArgs args(filename1, filename2, delta, begin_key, end_key);
  FarEqualArgs args_with_retval(args);
  Apply<Operation<FarEqualArgs>>("FarEqual", arc_type, &args_with_retval);
  return args_with_retval.retval;
}

void FarExtract(const std::vector<string> &ifilenames, const string &arc_type,
                int32 generate_filenames, const string &keys,
                const string &key_separator, const string &range_delimiter,
                const string &filename_prefix, const string &filename_suffix) {
  FarExtractArgs args(ifilenames, generate_filenames, keys, key_separator,
                      range_delimiter, filename_prefix, filename_suffix);
  Apply<Operation<FarExtractArgs>>("FarExtract", arc_type, &args);
}

void FarInfo(const std::vector<string> &filenames, const string &arc_type,
             const string &begin_key, const string &end_key,
             const bool list_fsts) {
  FarInfoArgs args(filenames, begin_key, end_key, list_fsts);
  Apply<Operation<FarInfoArgs>>("FarInfo", arc_type, &args);
}

void GetFarInfo(const std::vector<string> &filenames, const string &arc_type,
                const string &begin_key, const string &end_key,
                const bool list_fsts, FarInfoData *data) {
  GetFarInfoArgs args(filenames, begin_key, end_key, list_fsts, data);
  Apply<Operation<GetFarInfoArgs>>("GetFarInfo", arc_type, &args);
}

bool FarIsomorphic(const string &filename1, const string &filename2,
                   const string &arc_type, float delta, const string &begin_key,
                   const string &end_key) {
  FarIsomorphicInnerArgs args(filename1, filename2, delta, begin_key, end_key);
  FarIsomorphicArgs args_with_retval(args);
  Apply<Operation<FarIsomorphicArgs>>("FarIsomorphic", arc_type,
                                      &args_with_retval);
  return args_with_retval.retval;
}

void FarPrintStrings(const std::vector<string> &ifilenames,
                     const string &arc_type, const FarEntryType entry_type,
                     const FarTokenType token_type, const string &begin_key,
                     const string &end_key, const bool print_key,
                     const bool print_weight, const string &symbols_fname,
                     const bool initial_symbols, const int32 generate_filenames,
                     const string &filename_prefix,
                     const string &filename_suffix) {
  FarPrintStringsArgs args(ifilenames, entry_type, token_type, begin_key,
                           end_key, print_key, print_weight, symbols_fname,
                           initial_symbols, generate_filenames, filename_prefix,
                           filename_suffix);
  Apply<Operation<FarPrintStringsArgs>>("FarPrintStrings", arc_type, &args);
}

// Instantiate all templates for common arc types.

REGISTER_FST_FAR_OPERATIONS(StdArc);
REGISTER_FST_FAR_OPERATIONS(LogArc);
REGISTER_FST_FAR_OPERATIONS(Log64Arc);

}  // namespace script
}  // namespace fst
// See www.openfst.org for extensive documentation on this weighted
// finite-state transducer library.

#include <fstream>
#include <fst/extensions/far/sttable.h>

namespace fst {

bool IsSTTable(const string &filename) {
  std::ifstream strm(filename);
  if (!strm.good()) return false;

  int32 magic_number = 0;
  ReadType(strm, &magic_number);
  return magic_number == kSTTableMagicNumber;
}

}  // namespace fst
// See www.openfst.org for extensive documentation on this weighted
// finite-state transducer library.

#include <cmath>
#include <string>

#include <fst/flags.h>
#include <fst/extensions/far/compile-strings.h>
#include <fstream>

DEFINE_string(far_field_separator, "\t",
              "Set of characters used as a separator between printed fields");

namespace fst {

// Computes the minimal length required to encode each line number as a decimal
// number.
int KeySize(const char *filename) {
  std::ifstream istrm(filename);
  istrm.seekg(0);
  string s;
  int nline = 0;
  while (getline(istrm, s)) ++nline;
  istrm.seekg(0);
  return nline ? ceil(log10(nline + 1)) : 1;
}

}  // namespace fst
// See www.openfst.org for extensive documentation on this weighted
// finite-state transducer library.
//
// Extracts component FSTs from an finite-state archive.

#include <string>
#include <vector>

#include <fst/flags.h>
#include <fst/extensions/far/farscript.h>
#include <fst/extensions/far/getters.h>

DEFINE_string(filename_prefix, "", "Prefix to append to filenames");
DEFINE_string(filename_suffix, "", "Suffix to append to filenames");
DEFINE_int32(generate_filenames, 0,
             "Generate N digit numeric filenames (def: use keys)");
DEFINE_string(keys, "",
              "Extract set of keys separated by comma (default) "
              "including ranges delimited by dash (default)");
DEFINE_string(key_separator, ",", "Separator for individual keys");
DEFINE_string(range_delimiter, "-", "Delimiter for ranges of keys");

int main(int argc, char **argv) {
  namespace s = fst::script;

  string usage = "Extracts FSTs from a finite-state archive.\n\n Usage:";
  usage += argv[0];
  usage += " [in1.far in2.far...]\n";

  std::set_new_handler(FailedNewHandler);
  SET_FLAGS(usage.c_str(), &argc, &argv, true);
  s::ExpandArgs(argc, argv, &argc, &argv);

  std::vector<string> in_fnames;
  for (int i = 1; i < argc; ++i) in_fnames.push_back(argv[i]);
  if (in_fnames.empty()) in_fnames.push_back("");

  const auto arc_type = s::LoadArcTypeFromFar(in_fnames[0]);
  if (arc_type.empty()) return 1;

  s::FarExtract(in_fnames, arc_type, FLAGS_generate_filenames, FLAGS_keys,
                FLAGS_key_separator, FLAGS_range_delimiter,
                FLAGS_filename_prefix, FLAGS_filename_suffix);

  return 0;
}
// See www.openfst.org for extensive documentation on this weighted
// finite-state transducer library.
//
// Definitions and functions for invoking and using Far main functions that
// support multiple and extensible arc types.

#include <fst/extensions/far/script-impl.h>

#include <string>

#include <fst/extensions/far/far.h>
#include <fstream>

namespace fst {
namespace script {

string LoadArcTypeFromFar(const string &far_fname) {
  FarHeader hdr;
  if (!hdr.Read(far_fname)) {
    LOG(ERROR) << "Error reading FAR: " << far_fname;
    return "";
  }
  string atype = hdr.ArcType();
  if (atype == "unknown") {
    LOG(ERROR) << "Empty FST archive: " << far_fname;
    return "";
  }
  return atype;
}

string LoadArcTypeFromFst(const string &fst_fname) {
  FstHeader hdr;
  std::ifstream in(fst_fname, std::ios_base::in | std::ios_base::binary);
  if (!hdr.Read(in, fst_fname)) {
    LOG(ERROR) << "Error reading FST: " << fst_fname;
    return "";
  }
  return hdr.ArcType();
}

}  // namespace script
}  // namespace fst
// See www.openfst.org for extensive documentation on this weighted
// finite-state transducer library.

#include <fst/extensions/far/far-class.h>

#include <fst/script/script-impl.h>
#include <fst/extensions/far/script-impl.h>

namespace fst {
namespace script {


// FarReaderClass.

FarReaderClass *FarReaderClass::Open(const string &filename) {
  OpenFarReaderClassArgs1 args(filename);
  args.retval = nullptr;
  Apply<Operation<OpenFarReaderClassArgs1>>("OpenFarReaderClass",
                                            LoadArcTypeFromFar(filename),
                                            &args);
  return args.retval;
}

FarReaderClass *FarReaderClass::Open(const std::vector<string> &filenames) {
  if (filenames.empty()) {
    LOG(ERROR) << "FarReaderClass::Open: No files specified";
    return nullptr;
  }
  auto it = filenames.cbegin();
  const auto arc_type = LoadArcTypeFromFar(*it);
  if (arc_type.empty()) return nullptr;
  // FIXME(kbg): Is any of this really necessary? I am doing this purely
  // to conform to what I did with fst::script::Replace.
  ++it;
  for (; it != filenames.cend(); ++it) {
    const string other_arc_type = LoadArcTypeFromFar(*it);
    if (other_arc_type.empty()) return nullptr;
    if (arc_type != other_arc_type) {
      LOG(ERROR) << "FarReaderClass::Open: Trying to open FARs with "
                 << "non-matching arc types:\n\t" << arc_type << " and "
                 << other_arc_type;
      return nullptr;
    }
  }
  OpenFarReaderClassArgs2 args(filenames);
  args.retval = nullptr;
  Apply<Operation<OpenFarReaderClassArgs2>>("OpenFarReaderClass", arc_type,
                                            &args);
  return args.retval;
}

REGISTER_FST_OPERATION(OpenFarReaderClass, StdArc, OpenFarReaderClassArgs1);
REGISTER_FST_OPERATION(OpenFarReaderClass, LogArc, OpenFarReaderClassArgs1);
REGISTER_FST_OPERATION(OpenFarReaderClass, Log64Arc, OpenFarReaderClassArgs1);

REGISTER_FST_OPERATION(OpenFarReaderClass, StdArc, OpenFarReaderClassArgs2);
REGISTER_FST_OPERATION(OpenFarReaderClass, LogArc, OpenFarReaderClassArgs2);
REGISTER_FST_OPERATION(OpenFarReaderClass, Log64Arc, OpenFarReaderClassArgs2);

// FarWriterClass.

FarWriterClass *FarWriterClass::Create(const string &filename,
                                       const string &arc_type, FarType type) {
  CreateFarWriterClassInnerArgs iargs(filename, type);
  CreateFarWriterClassArgs args(iargs);
  args.retval = nullptr;
  Apply<Operation<CreateFarWriterClassArgs>>("CreateFarWriterClass", arc_type,
                                             &args);
  return args.retval;
}

REGISTER_FST_OPERATION(CreateFarWriterClass, StdArc, CreateFarWriterClassArgs);
REGISTER_FST_OPERATION(CreateFarWriterClass, LogArc, CreateFarWriterClassArgs);
REGISTER_FST_OPERATION(CreateFarWriterClass, Log64Arc,
                       CreateFarWriterClassArgs);

}  // namespace script
}  // namespace fst
// See www.openfst.org for extensive documentation on this weighted
// finite-state transducer library.
//
// Tests if two Far files contains the same (key,fst) pairs.

#include <string>

#include <fst/flags.h>
#include <fst/extensions/far/farscript.h>
#include <fst/extensions/far/getters.h>

DEFINE_string(begin_key, "",
              "First key to extract (def: first key in archive)");
DEFINE_string(end_key, "", "Last key to extract (def: last key in archive)");
DEFINE_double(delta, fst::kDelta, "Comparison/quantization delta");

int main(int argc, char **argv) {
  namespace s = fst::script;

  string usage = "Compares the FSTs in two FST archives for equality.";
  usage += "\n\n  Usage:";
  usage += argv[0];
  usage += " in1.far in2.far";

  std::set_new_handler(FailedNewHandler);
  SET_FLAGS(usage.c_str(), &argc, &argv, true);
  s::ExpandArgs(argc, argv, &argc, &argv);
  if (argc != 3) {
    ShowUsage();
    return 1;
  }

  const auto arc_type = s::LoadArcTypeFromFar(argv[1]);
  if (arc_type.empty()) return 1;

  bool result = s::FarEqual(argv[1], argv[2], arc_type, FLAGS_delta,
                            FLAGS_begin_key, FLAGS_end_key);

  if (!result) VLOG(1) << "FARs are not equal.";

  return result ? 0 : 2;
}
// See www.openfst.org for extensive documentation on this weighted
// finite-state transducer library.
//
// Compiles a set of stings as FSTs and stores them in a finite-state archive.

#include <string>
#include <vector>

#include <fst/flags.h>
#include <fst/extensions/far/farscript.h>
#include <fst/extensions/far/getters.h>
#include <fstream>

DEFINE_string(key_prefix, "", "Prefix to append to keys");
DEFINE_string(key_suffix, "", "Suffix to append to keys");
DEFINE_int32(generate_keys, 0,
             "Generate N digit numeric keys (def: use file basenames)");
DEFINE_string(far_type, "default",
              "FAR file format type: one of: \"default\", \"fst\", "
              "\"stlist\", \"sttable\"");
DEFINE_bool(allow_negative_labels, false,
            "Allow negative labels (not recommended; may cause conflicts)");
DEFINE_string(arc_type, "standard", "Output arc type");
DEFINE_string(entry_type, "line",
              "Entry type: one of : "
              "\"file\" (one FST per file), \"line\" (one FST per line)");
DEFINE_string(fst_type, "vector", "Output FST type");
DEFINE_string(token_type, "symbol",
              "Token type: one of : "
              "\"symbol\", \"byte\", \"utf8\"");
DEFINE_string(symbols, "", "Label symbol table");
DEFINE_string(unknown_symbol, "", "");
DEFINE_bool(file_list_input, false,
            "Each input file contains a list of files to be processed");
DEFINE_bool(keep_symbols, false, "Store symbol table in the FAR file");
DEFINE_bool(initial_symbols, true,
            "When keep_symbols is true, stores symbol table only for the first"
            " FST in archive.");

int main(int argc, char **argv) {
  namespace s = fst::script;

  string usage = "Compiles a set of strings as FSTs and stores them in";
  usage += " a finite-state archive.\n\n  Usage:";
  usage += argv[0];
  usage += " [in1.txt [[in2.txt ...] out.far]]\n";

  std::set_new_handler(FailedNewHandler);
  SET_FLAGS(usage.c_str(), &argc, &argv, true);
  s::ExpandArgs(argc, argv, &argc, &argv);

  std::vector<string> in_fnames;
  if (FLAGS_file_list_input) {
    for (int i = 1; i < argc - 1; ++i) {
      std::ifstream istrm(argv[i]);
      string str;
      while (getline(istrm, str)) in_fnames.push_back(str);
    }
  } else {
    for (int i = 1; i < argc - 1; ++i)
      in_fnames.push_back(argv[i]);
  }
  if (in_fnames.empty()) {
    in_fnames.push_back(argc == 2 && strcmp(argv[1], "-") != 0 ? argv[1] : "");
  }

  string out_fname =
      argc > 2 && strcmp(argv[argc - 1], "-") != 0 ? argv[argc - 1] : "";

  fst::FarEntryType entry_type;
  if (!s::GetFarEntryType(FLAGS_entry_type, &entry_type)) {
    LOG(ERROR) << "Unknown or unsupported FAR entry type: " << FLAGS_entry_type;
    return 1;
  }

  fst::FarTokenType token_type;
  if (!s::GetFarTokenType(FLAGS_token_type, &token_type)) {
    LOG(ERROR) << "Unkonwn or unsupported FAR token type: " << FLAGS_token_type;
    return 1;
  }

  const auto far_type = s::GetFarType(FLAGS_far_type);

  s::FarCompileStrings(in_fnames, out_fname, FLAGS_arc_type, FLAGS_fst_type,
                       far_type, FLAGS_generate_keys, entry_type, token_type,
                       FLAGS_symbols, FLAGS_unknown_symbol, FLAGS_keep_symbols,
                       FLAGS_initial_symbols, FLAGS_allow_negative_labels,
                       FLAGS_key_prefix, FLAGS_key_suffix);

  return 0;
}
// See www.openfst.org for extensive documentation on this weighted
// finite-state transducer library.
//
//
// Definitions and functions for invoking and using Far main functions that
// support multiple and extensible arc types.

#include <fst/extensions/far/getters.h>

#include <string>
#include <vector>

#include <fstream>

namespace fst {

namespace script {

FarType GetFarType(const string &str) {
  if (str == "fst") {
    return FAR_FST;
  } else if (str == "stlist") {
    return FAR_STLIST;
  } else if (str == "sttable") {
    return FAR_STTABLE;
  } else {
    return FAR_DEFAULT;
  }
}

bool GetFarEntryType(const string &str, FarEntryType *entry_type) {
  if (str == "line") {
    *entry_type = FET_LINE;
  } else if (str == "file") {
    *entry_type = FET_FILE;
  } else {
    return false;
  }
  return true;
}

bool GetFarTokenType(const string &str, FarTokenType *token_type) {
  if (str == "symbol") {
    *token_type = FTT_SYMBOL;
  } else if (str == "byte") {
    *token_type = FTT_BYTE;
  } else if (str == "utf8") {
    *token_type = FTT_UTF8;
  } else {
    return false;
  }
  return true;
}

void ExpandArgs(int argc, char **argv, int *argcp, char ***argvp) {
}

}  // namespace script

string GetFarTypeString(FarType type) {
  switch (type) {
    case FAR_FST:
      return "fst";
    case FAR_STLIST:
      return "stlist";
    case FAR_STTABLE:
      return "sttable";
    case FAR_DEFAULT:
      return "default";
    default:
      return "<unknown>";
  }
}

}  // namespace fst
// See www.openfst.org for extensive documentation on this weighted
// finite-state transducer library.
//
// Creates a finite-state archive from input FSTs.

#include <string>
#include <vector>

#include <fst/flags.h>
#include <fst/extensions/far/farscript.h>
#include <fst/extensions/far/getters.h>
#include <fstream>

DEFINE_string(key_prefix, "", "Prefix to append to keys");
DEFINE_string(key_suffix, "", "Suffix to append to keys");
DEFINE_int32(generate_keys, 0,
             "Generate N digit numeric keys (def: use file basenames)");
DEFINE_string(far_type, "default",
              "FAR file format type: one of: \"default\", "
              "\"stlist\", \"sttable\"");
DEFINE_bool(file_list_input, false,
            "Each input file contains a list of files to be processed");

int main(int argc, char **argv) {
  namespace s = fst::script;

  string usage = "Creates a finite-state archive from input FSTs.\n\n Usage:";
  usage += argv[0];
  usage += " [in1.fst [[in2.fst ...] out.far]]\n";

  std::set_new_handler(FailedNewHandler);
  SET_FLAGS(usage.c_str(), &argc, &argv, true);
  s::ExpandArgs(argc, argv, &argc, &argv);

  std::vector<string> in_fnames;
  if (FLAGS_file_list_input) {
    for (int i = 1; i < argc - 1; ++i) {
      std::ifstream istrm(argv[i]);
      string str;
      while (getline(istrm, str)) in_fnames.push_back(str);
    }
  } else {
    for (int i = 1; i < argc - 1; ++i)
      in_fnames.push_back(argv[i]);
  }
  if (in_fnames.empty())
    in_fnames.push_back(argc == 2 && strcmp(argv[1], "-") != 0 ? argv[1] : "");

  string out_fname =
      argc > 2 && strcmp(argv[argc - 1], "-") != 0 ? argv[argc - 1] : "";

  const auto arc_type = s::LoadArcTypeFromFst(in_fnames[0]);
  if (arc_type.empty()) return 1;

  const auto far_type = s::GetFarType(FLAGS_far_type);

  s::FarCreate(in_fnames, out_fname, arc_type, FLAGS_generate_keys, far_type,
               FLAGS_key_prefix, FLAGS_key_suffix);

  return 0;
}
// See www.openfst.org for extensive documentation on this weighted
// finite-state transducer library.

#include <ios>

#include <fst/extensions/far/stlist.h>
#include <fstream>

namespace fst {

bool IsSTList(const string &filename) {
  std::ifstream strm(filename, std::ios_base::in | std::ios_base::binary);
  if (!strm) return false;
  int32 magic_number = 0;
  ReadType(strm, &magic_number);
  return magic_number == kSTListMagicNumber;
}

}  // namespace fst
// See www.openfst.org for extensive documentation on this weighted
// finite-state transducer library.
//
// Reverses an MPDT.

#include <cstring>

#include <memory>
#include <string>
#include <vector>

#include <fst/flags.h>
#include <fst/log.h>

#include <fst/extensions/mpdt/mpdtscript.h>
#include <fst/extensions/mpdt/read_write_utils.h>
#include <fst/util.h>

DEFINE_string(mpdt_parentheses, "",
              "MPDT parenthesis label pairs with assignments.");

DEFINE_string(mpdt_new_parentheses, "",
              "Output for reassigned parentheses and stacks");

int main(int argc, char **argv) {
  namespace s = fst::script;
  using fst::ReadLabelTriples;
  using fst::WriteLabelTriples;
  using fst::script::FstClass;
  using fst::script::VectorFstClass;

  string usage = "Reverse an MPDT.\n\n  Usage: ";
  usage += argv[0];
  usage += " in.pdt [out.fst]\n";

  std::set_new_handler(FailedNewHandler);
  SET_FLAGS(usage.c_str(), &argc, &argv, true);
  if (argc > 3) {
    ShowUsage();
    return 1;
  }

  const string in_name =
      (argc > 1 && (strcmp(argv[1], "-") != 0)) ? argv[1] : "";
  const string out_name = argc > 2 ? argv[2] : "";

  std::unique_ptr<FstClass> ifst(FstClass::Read(in_name));
  if (!ifst) return 1;

  if (FLAGS_mpdt_parentheses.empty()) {
    LOG(ERROR) << argv[0] << ": No MPDT parenthesis label pairs provided";
    return 1;
  }

  if (FLAGS_mpdt_new_parentheses.empty()) {
    LOG(ERROR) << argv[0] << ": No MPDT output parenthesis label file provided";
    return 1;
  }

  std::vector<s::LabelPair> parens;
  std::vector<int64> assignments;
  if (!ReadLabelTriples(FLAGS_mpdt_parentheses, &parens, &assignments, false))
    return 1;

  VectorFstClass ofst(ifst->ArcType());

  s::MPdtReverse(*ifst, parens, &assignments, &ofst);

  ofst.Write(out_name);

  if (!WriteLabelTriples(FLAGS_mpdt_new_parentheses, parens, assignments))
    return 1;

  return 0;
}
// See www.openfst.org for extensive documentation on this weighted
// finite-state transducer library.
//
// Composes an MPDT and an FST.

#include <cstring>

#include <memory>
#include <string>
#include <vector>

#include <fst/flags.h>
#include <fst/log.h>

#include <fst/extensions/mpdt/mpdtscript.h>
#include <fst/extensions/mpdt/read_write_utils.h>
#include <fst/extensions/pdt/getters.h>
#include <fst/util.h>

DEFINE_string(mpdt_parentheses, "",
              "MPDT parenthesis label pairs with assignments");
DEFINE_bool(left_mpdt, true, "Is the first argument the MPDT?");
DEFINE_bool(connect, true, "Trim output?");
DEFINE_string(compose_filter, "paren",
              "Composition filter, one of: \"expand\", \"expand_paren\", "
              "\"paren\"");

int main(int argc, char **argv) {
  namespace s = fst::script;
  using fst::MPdtComposeOptions;
  using fst::PdtComposeFilter;
  using fst::ReadLabelTriples;
  using fst::script::FstClass;
  using fst::script::VectorFstClass;

  string usage = "Compose an MPDT and an FST.\n\n  Usage: ";
  usage += argv[0];
  usage += " in.pdt in.fst [out.mpdt]\n";
  usage += " in.fst in.pdt [out.mpdt]\n";

  std::set_new_handler(FailedNewHandler);
  SET_FLAGS(usage.c_str(), &argc, &argv, true);
  if (argc < 3 || argc > 4) {
    ShowUsage();
    return 1;
  }

  const string in1_name = strcmp(argv[1], "-") == 0 ? "" : argv[1];
  const string in2_name = strcmp(argv[2], "-") == 0 ? "" : argv[2];
  const string out_name = argc > 3 ? argv[3] : "";

  if (in1_name.empty() && in2_name.empty()) {
    LOG(ERROR) << argv[0] << ": Can't take both inputs from standard input.";
    return 1;
  }

  std::unique_ptr<FstClass> ifst1(FstClass::Read(in1_name));
  if (!ifst1) return 1;
  std::unique_ptr<FstClass> ifst2(FstClass::Read(in2_name));
  if (!ifst2) return 1;

  if (FLAGS_mpdt_parentheses.empty()) {
    LOG(ERROR) << argv[0] << ": No MPDT parenthesis label pairs provided";
    return 1;
  }

  std::vector<s::LabelPair> parens;
  std::vector<int64> assignments;
  if (!ReadLabelTriples(FLAGS_mpdt_parentheses, &parens, &assignments, false))
    return 1;

  VectorFstClass ofst(ifst1->ArcType());

  PdtComposeFilter compose_filter;
  if (!s::GetPdtComposeFilter(FLAGS_compose_filter, &compose_filter)) {
    LOG(ERROR) << argv[0] << ": Unknown or unsupported compose filter type: "
               << FLAGS_compose_filter;
    return 1;
  }

  const MPdtComposeOptions opts(FLAGS_connect, compose_filter);

  s::MPdtCompose(*ifst1, *ifst2, parens, assignments, &ofst, opts,
                 FLAGS_left_mpdt);

  ofst.Write(out_name);

  return 0;
}
// See www.openfst.org for extensive documentation on this weighted
// finite-state transducer library.
//
// Prints out various information about an MPDT such as number of states, arcs,
// and parentheses.

#include <cstring>

#include <memory>
#include <string>
#include <vector>

#include <fst/flags.h>
#include <fst/log.h>

#include <fst/extensions/mpdt/mpdtscript.h>
#include <fst/extensions/mpdt/read_write_utils.h>
#include <fst/util.h>

DEFINE_string(mpdt_parentheses, "",
              "MPDT parenthesis label pairs with assignments");

int main(int argc, char **argv) {
  namespace s = fst::script;
  using fst::script::FstClass;
  using fst::ReadLabelTriples;

  string usage = "Prints out information about an MPDT.\n\n  Usage: ";
  usage += argv[0];
  usage += " in.pdt\n";

  std::set_new_handler(FailedNewHandler);
  SET_FLAGS(usage.c_str(), &argc, &argv, true);
  if (argc > 2) {
    ShowUsage();
    return 1;
  }

  const string in_name =
      (argc > 1 && (strcmp(argv[1], "-") != 0)) ? argv[1] : "";

  std::unique_ptr<FstClass> ifst(FstClass::Read(in_name));
  if (!ifst) return 1;

  if (FLAGS_mpdt_parentheses.empty()) {
    LOG(ERROR) << argv[0] << ": No MPDT parenthesis label pairs provided";
    return 1;
  }

  std::vector<s::LabelPair> parens;
  std::vector<int64> assignments;
  if (!ReadLabelTriples(FLAGS_mpdt_parentheses, &parens, &assignments, false))
    return 1;

  s::PrintMPdtInfo(*ifst, parens, assignments);

  return 0;
}
// See www.openfst.org for extensive documentation on this weighted
// finite-state transducer library.
//
// Expands a (bounded-stack) MPDT as an FST.

#include <cstring>

#include <memory>
#include <string>
#include <vector>

#include <fst/flags.h>
#include <fst/log.h>

#include <fst/extensions/mpdt/mpdtscript.h>
#include <fst/extensions/mpdt/read_write_utils.h>
#include <fst/util.h>

DEFINE_string(mpdt_parentheses, "",
              "MPDT parenthesis label pairs with assignments");
DEFINE_bool(connect, true, "Trim output?");
DEFINE_bool(keep_parentheses, false, "Keep PDT parentheses in result?");

int main(int argc, char **argv) {
  namespace s = fst::script;
  using fst::script::FstClass;
  using fst::script::VectorFstClass;
  using fst::ReadLabelTriples;
  using fst::MPdtExpandOptions;

  string usage = "Expand a (bounded-stack) MPDT as an FST.\n\n  Usage: ";
  usage += argv[0];
  usage += " in.pdt [out.fst]\n";

  std::set_new_handler(FailedNewHandler);
  SET_FLAGS(usage.c_str(), &argc, &argv, true);
  if (argc > 3) {
    ShowUsage();
    return 1;
  }

  const string in_name =
      (argc > 1 && (strcmp(argv[1], "-") != 0)) ? argv[1] : "";
  const string out_name = argc > 2 ? argv[2] : "";

  std::unique_ptr<FstClass> ifst(FstClass::Read(in_name));
  if (!ifst) return 1;

  if (FLAGS_mpdt_parentheses.empty()) {
    LOG(ERROR) << argv[0] << ": No MPDT parenthesis label pairs provided";
    return 1;
  }

  std::vector<s::LabelPair> parens;
  std::vector<int64> assignments;
  if (!ReadLabelTriples(FLAGS_mpdt_parentheses, &parens, &assignments, false))
    return 1;

  VectorFstClass ofst(ifst->ArcType());

  const MPdtExpandOptions opts(FLAGS_connect, FLAGS_keep_parentheses);

  s::MPdtExpand(*ifst, parens, assignments, &ofst, opts);

  ofst.Write(out_name);

  return 0;
}
// See www.openfst.org for extensive documentation on this weighted
// finite-state transducer library.
//
// Definitions of 'scriptable' versions of mpdt operations, that is,
// those that can be called with FstClass-type arguments.
//
// See comments in nlp/fst/script/script-impl.h for how the registration
// mechanism allows these to work with various arc types.

#include <string>
#include <vector>

#include <fst/extensions/mpdt/compose.h>
#include <fst/extensions/mpdt/expand.h>
#include <fst/extensions/mpdt/mpdtscript.h>
#include <fst/extensions/mpdt/reverse.h>
#include <fst/script/script-impl.h>

namespace fst {
namespace script {

void MPdtCompose(const FstClass &ifst1, const FstClass &ifst2,
                 const std::vector<LabelPair> &parens,
                 const std::vector<int64> &assignments, MutableFstClass *ofst,
                 const MPdtComposeOptions &copts, bool left_pdt) {
  if (!internal::ArcTypesMatch(ifst1, ifst2, "MPdtCompose") ||
      !internal::ArcTypesMatch(ifst1, *ofst, "MPdtCompose")) return;
  MPdtComposeArgs args(ifst1, ifst2, parens, assignments, ofst, copts,
                       left_pdt);
  Apply<Operation<MPdtComposeArgs>>("MPdtCompose", ifst1.ArcType(), &args);
}

void MPdtExpand(const FstClass &ifst, const std::vector<LabelPair> &parens,
                const std::vector<int64> &assignments, MutableFstClass *ofst,
                const MPdtExpandOptions &opts) {
  MPdtExpandArgs args(ifst, parens, assignments, ofst, opts);
  Apply<Operation<MPdtExpandArgs>>("MPdtExpand", ifst.ArcType(), &args);
}

void MPdtExpand(const FstClass &ifst, const std::vector<LabelPair> &parens,
                const std::vector<int64> &assignments, MutableFstClass *ofst,
                bool connect) {
  MPdtExpand(ifst, parens, assignments, ofst, MPdtExpandOptions(connect));
}

void MPdtReverse(const FstClass &ifst, const std::vector<LabelPair> &parens,
                 std::vector<int64> *assignments, MutableFstClass *ofst) {
  MPdtReverseArgs args(ifst, parens, assignments, ofst);
  Apply<Operation<MPdtReverseArgs>>("MPdtReverse", ifst.ArcType(), &args);
}

void PrintMPdtInfo(const FstClass &ifst, const std::vector<LabelPair> &parens,
                   const std::vector<int64> &assignments) {
  PrintMPdtInfoArgs args(ifst, parens, assignments);
  Apply<Operation<PrintMPdtInfoArgs>>("PrintMPdtInfo", ifst.ArcType(), &args);
}

// Register operations for common arc types.

REGISTER_FST_MPDT_OPERATIONS(StdArc);
REGISTER_FST_MPDT_OPERATIONS(LogArc);
REGISTER_FST_MPDT_OPERATIONS(Log64Arc);

}  // namespace script
}  // namespace fst
// See www.openfst.org for extensive documentation on this weighted
// finite-state transducer library.
//

#include <fst/mapped-file.h>

#include <errno.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <unistd.h>

#include <algorithm>
#include <ios>
#include <memory>

#include <fst/log.h>

namespace fst {

MappedFile::MappedFile(const MemoryRegion &region) : region_(region) {}

MappedFile::~MappedFile() {
  if (region_.size != 0) {
    if (region_.mmap) {
      VLOG(1) << "munmap'ed " << region_.size << " bytes at " << region_.mmap;
      if (munmap(region_.mmap, region_.size) != 0) {
        LOG(ERROR) << "Failed to unmap region: " << strerror(errno);
      }
    } else {
      if (region_.data) {
        operator delete(static_cast<char *>(region_.data) - region_.offset);
      }
    }
  }
}

MappedFile *MappedFile::Map(std::istream *istrm, bool memorymap,
                            const string &source, size_t size) {
  const auto spos = istrm->tellg();
  VLOG(1) << "memorymap: " << (memorymap ? "true" : "false") << " source: \""
          << source << "\""
          << " size: " << size << " offset: " << spos;
  if (memorymap && spos >= 0 && spos % kArchAlignment == 0) {
    const size_t pos = spos;
    int fd = open(source.c_str(), O_RDONLY);
    if (fd != -1) {
      const int pagesize = sysconf(_SC_PAGESIZE);
      const off_t offset = pos % pagesize;
      const off_t upsize = size + offset;
      void *map =
          mmap(nullptr, upsize, PROT_READ, MAP_SHARED, fd, pos - offset);
      auto *data = reinterpret_cast<char *>(map);
      if (close(fd) == 0 && map != MAP_FAILED) {
        MemoryRegion region;
        region.mmap = map;
        region.size = upsize;
        region.data = reinterpret_cast<void *>(data + offset);
        region.offset = offset;
        std::unique_ptr<MappedFile> mmf(new MappedFile(region));
        istrm->seekg(pos + size, std::ios::beg);
        if (istrm) {
          VLOG(1) << "mmap'ed region of " << size << " at offset " << pos
                  << " from " << source << " to addr " << map;
          return mmf.release();
        }
      } else {
        LOG(INFO) << "Mapping of file failed: " << strerror(errno);
      }
    }
  }
  // If all else fails, reads from the file into the allocated buffer.
  if (memorymap) {
    LOG(WARNING) << "File mapping at offset " << spos << " of file " << source
                 << " could not be honored, reading instead";
  }
  // Reads the file into the buffer in chunks not larger than kMaxReadChunk.
  std::unique_ptr<MappedFile> mf(Allocate(size));
  auto *buffer = reinterpret_cast<char *>(mf->mutable_data());
  while (size > 0) {
    const auto next_size = std::min(size, kMaxReadChunk);
    const auto current_pos = istrm->tellg();
    if (!istrm->read(buffer, next_size)) {
      LOG(ERROR) << "Failed to read " << next_size << " bytes at offset "
                 << current_pos << "from \"" << source << "\"";
      return nullptr;
    }
    size -= next_size;
    buffer += next_size;
    VLOG(2) << "Read " << next_size << " bytes. " << size << " remaining";
  }
  return mf.release();
}

MappedFile *MappedFile::Allocate(size_t size, int align) {
  MemoryRegion region;
  region.data = nullptr;
  region.offset = 0;
  if (size > 0) {
    char *buffer = static_cast<char *>(operator new(size + align));
    size_t address = reinterpret_cast<size_t>(buffer);
    region.offset = kArchAlignment - (address % align);
    region.data = buffer + region.offset;
  }
  region.mmap = nullptr;
  region.size = size;
  return new MappedFile(region);
}

MappedFile *MappedFile::Borrow(void *data) {
  MemoryRegion region;
  region.data = data;
  region.mmap = data;
  region.size = 0;
  region.offset = 0;
  return new MappedFile(region);
}

constexpr int MappedFile::kArchAlignment;

constexpr size_t MappedFile::kMaxReadChunk;

}  // namespace fst
// See www.openfst.org for extensive documentation on this weighted
// finite-state transducer library.
//
// FST definitions.

#include <fst/fst.h>

#include <sstream>

#include <fst/flags.h>
#include <fst/log.h>
#include <fst/matcher-fst.h>  // declarations of *_lookahead_fst_type

// FST flag definitions.

DEFINE_bool(fst_verify_properties, false,
            "Verify FST properties queried by TestProperties");

DEFINE_bool(fst_default_cache_gc, true, "Enable garbage collection of cache");

DEFINE_int64(fst_default_cache_gc_limit, 1 << 20LL,
             "Cache byte size that triggers garbage collection");

DEFINE_bool(fst_align, false, "Write FST data aligned where appropriate");

DEFINE_string(save_relabel_ipairs, "", "Save input relabel pairs to file");
DEFINE_string(save_relabel_opairs, "", "Save output relabel pairs to file");

DEFINE_string(fst_read_mode, "read",
              "Default file reading mode for mappable files");

namespace fst {

// FST type definitions for lookahead FSTs.
const char arc_lookahead_fst_type[] = "arc_lookahead";
const char ilabel_lookahead_fst_type[] = "ilabel_lookahead";
const char olabel_lookahead_fst_type[] = "olabel_lookahead";

// Identifies stream data as an FST (and its endianity).
constexpr int32 kFstMagicNumber = 2125659606;

// Checks for FST magic number in stream, to indicate caller function that the
// stream content is an FST header.
bool IsFstHeader(std::istream &strm, const string &source) {
  int64 pos = strm.tellg();
  bool match = true;
  int32 magic_number = 0;
  ReadType(strm, &magic_number);
  if (magic_number != kFstMagicNumber) {
      match = false;
  }
  strm.seekg(pos);
  return match;
}

// Checks FST magic number and reads in the header; if rewind = true,
// the stream is repositioned before call if possible.
bool FstHeader::Read(std::istream &strm, const string &source, bool rewind) {
  int64 pos = 0;
  if (rewind) pos = strm.tellg();
  int32 magic_number = 0;
  ReadType(strm, &magic_number);
  if (magic_number != kFstMagicNumber) {
      LOG(ERROR) << "FstHeader::Read: Bad FST header: " << source;
      if (rewind) strm.seekg(pos);
      return false;
  }
  ReadType(strm, &fsttype_);
  ReadType(strm, &arctype_);
  ReadType(strm, &version_);
  ReadType(strm, &flags_);
  ReadType(strm, &properties_);
  ReadType(strm, &start_);
  ReadType(strm, &numstates_);
  ReadType(strm, &numarcs_);
  if (!strm) {
    LOG(ERROR) << "FstHeader::Read: Read failed: " << source;
    return false;
  }
  if (rewind) strm.seekg(pos);
  return true;
}

// Writes FST magic number and FST header.
bool FstHeader::Write(std::ostream &strm, const string &source) const {
  WriteType(strm, kFstMagicNumber);
  WriteType(strm, fsttype_);
  WriteType(strm, arctype_);
  WriteType(strm, version_);
  WriteType(strm, flags_);
  WriteType(strm, properties_);
  WriteType(strm, start_);
  WriteType(strm, numstates_);
  WriteType(strm, numarcs_);
  return true;
}

string FstHeader::DebugString() const {
  std::ostringstream ostrm;
  ostrm << "fsttype: \"" << fsttype_ << "\" arctype: \"" << arctype_
        << "\" version: \"" << version_ << "\" flags: \"" << flags_
        << "\" properties: \"" << properties_ << "\" start: \"" << start_
        << "\" numstates: \"" << numstates_ << "\" numarcs: \"" << numarcs_
        << "\"";
  return ostrm.str();
}

FstReadOptions::FstReadOptions(const string &source, const FstHeader *header,
                               const SymbolTable *isymbols,
                               const SymbolTable *osymbols)
    : source(source),
      header(header),
      isymbols(isymbols),
      osymbols(osymbols),
      read_isymbols(true),
      read_osymbols(true) {
  mode = ReadMode(FLAGS_fst_read_mode);
}

FstReadOptions::FstReadOptions(const string &source,
                               const SymbolTable *isymbols,
                               const SymbolTable *osymbols)
    : source(source),
      header(nullptr),
      isymbols(isymbols),
      osymbols(osymbols),
      read_isymbols(true),
      read_osymbols(true) {
  mode = ReadMode(FLAGS_fst_read_mode);
}

FstReadOptions::FileReadMode FstReadOptions::ReadMode(const string &mode) {
  if (mode == "read") return READ;
  if (mode == "map") return MAP;
  LOG(ERROR) << "Unknown file read mode " << mode;
  return READ;
}

string FstReadOptions::DebugString() const {
  std::ostringstream ostrm;
  ostrm << "source: \"" << source << "\" mode: \""
        << (mode == READ ? "READ" : "MAP") << "\" read_isymbols: \""
        << (read_isymbols ? "true" : "false") << "\" read_osymbols: \""
        << (read_osymbols ? "true" : "false") << "\" header: \""
        << (header ? "set" : "null") << "\" isymbols: \""
        << (isymbols ? "set" : "null") << "\" osymbols: \""
        << (osymbols ? "set" : "null") << "\"";
  return ostrm.str();
}

}  // namespace fst
// See www.openfst.org for extensive documentation on this weighted
// finite-state transducer library.
//

#include <fst/symbol-table-ops.h>

#include <string>

namespace fst {

SymbolTable *MergeSymbolTable(const SymbolTable &left, const SymbolTable &right,
                              bool *right_relabel_output) {
  // MergeSymbolTable detects several special cases.  It will return a reference
  // copied version of SymbolTable of left or right if either symbol table is
  // a superset of the other.
  std::unique_ptr<SymbolTable> merged(
      new SymbolTable("merge_" + left.Name() + "_" + right.Name()));
  // Copies everything from the left symbol table.
  bool left_has_all = true;
  bool right_has_all = true;
  bool relabel = false;
  for (SymbolTableIterator liter(left); !liter.Done(); liter.Next()) {
    merged->AddSymbol(liter.Symbol(), liter.Value());
    if (right_has_all) {
      int64 key = right.Find(liter.Symbol());
      if (key == -1) {
        right_has_all = false;
      } else if (!relabel && key != liter.Value()) {
        relabel = true;
      }
    }
  }
  if (right_has_all) {
    if (right_relabel_output) *right_relabel_output = relabel;
    return right.Copy();
  }
  // add all symbols we can from right symbol table
  std::vector<string> conflicts;
  for (SymbolTableIterator riter(right); !riter.Done(); riter.Next()) {
    int64 key = merged->Find(riter.Symbol());
    if (key != -1) {
      // Symbol already exists, maybe with different value
      if (key != riter.Value()) relabel = true;
      continue;
    }
    // Symbol doesn't exist from left
    left_has_all = false;
    if (!merged->Find(riter.Value()).empty()) {
      // we can't add this where we want to, add it later, in order
      conflicts.push_back(riter.Symbol());
      continue;
    }
    // there is a hole and we can add this symbol with its id
    merged->AddSymbol(riter.Symbol(), riter.Value());
  }
  if (right_relabel_output) *right_relabel_output = relabel;
  if (left_has_all) return left.Copy();
  // Add all symbols that conflicted, in order
  for (const auto &conflict : conflicts) merged->AddSymbol(conflict);
  return merged.release();
}

SymbolTable *CompactSymbolTable(const SymbolTable &syms) {
  std::map<int64, string> sorted;
  SymbolTableIterator stiter(syms);
  for (; !stiter.Done(); stiter.Next()) {
    sorted[stiter.Value()] = stiter.Symbol();
  }
  auto *compact = new SymbolTable(syms.Name() + "_compact");
  int64 newkey = 0;
  for (const auto &kv : sorted) compact->AddSymbol(kv.second, newkey++);
  return compact;
}

SymbolTable *FstReadSymbols(const string &filename, bool input_symbols) {
  std::ifstream in(filename, std::ios_base::in | std::ios_base::binary);
  if (!in) {
    LOG(ERROR) << "FstReadSymbols: Can't open file " << filename;
    return nullptr;
  }
  FstHeader hdr;
  if (!hdr.Read(in, filename)) {
    LOG(ERROR) << "FstReadSymbols: Couldn't read header from " << filename;
    return nullptr;
  }
  if (hdr.GetFlags() & FstHeader::HAS_ISYMBOLS) {
    std::unique_ptr<SymbolTable> isymbols(SymbolTable::Read(in, filename));
    if (isymbols == nullptr) {
      LOG(ERROR) << "FstReadSymbols: Couldn't read input symbols from "
                 << filename;
      return nullptr;
    }
    if (input_symbols) return isymbols.release();
  }
  if (hdr.GetFlags() & FstHeader::HAS_OSYMBOLS) {
    std::unique_ptr<SymbolTable> osymbols(SymbolTable::Read(in, filename));
    if (osymbols == nullptr) {
      LOG(ERROR) << "FstReadSymbols: Couldn't read output symbols from "
                 << filename;
      return nullptr;
    }
    if (!input_symbols) return osymbols.release();
  }
  LOG(ERROR) << "FstReadSymbols: The file " << filename
             << " doesn't contain the requested symbols";
  return nullptr;
}

bool AddAuxiliarySymbols(const string &prefix, int64 start_label,
                         int64 nlabels, SymbolTable *syms) {
  for (int64 i = 0; i < nlabels; ++i) {
    auto index = i + start_label;
    if (index != syms->AddSymbol(prefix + std::to_string(i), index)) {
      FSTERROR() << "AddAuxiliarySymbols: Symbol table clash";
      return false;
    }
  }
  return true;
}

}  // namespace fst
// Registration of common Fst and arc types.

#include <fst/arc.h>
#include <fst/compact-fst.h>
#include <fst/const-fst.h>
#include <fst/edit-fst.h>
#include <fst/register.h>
#include <fst/vector-fst.h>

namespace fst {

// Registers VectorFst, ConstFst and EditFst for common arcs types.
REGISTER_FST(VectorFst, StdArc);
REGISTER_FST(VectorFst, LogArc);
REGISTER_FST(VectorFst, Log64Arc);
REGISTER_FST(ConstFst, StdArc);
REGISTER_FST(ConstFst, LogArc);
REGISTER_FST(ConstFst, Log64Arc);
REGISTER_FST(EditFst, StdArc);
REGISTER_FST(EditFst, LogArc);
REGISTER_FST(EditFst, Log64Arc);

// Register CompactFst for common arcs with the default (uint32) size type
REGISTER_FST(CompactStringFst, StdArc);
REGISTER_FST(CompactStringFst, LogArc);
REGISTER_FST(CompactWeightedStringFst, StdArc);
REGISTER_FST(CompactWeightedStringFst, LogArc);
REGISTER_FST(CompactAcceptorFst, StdArc);
REGISTER_FST(CompactAcceptorFst, LogArc);
REGISTER_FST(CompactUnweightedFst, StdArc);
REGISTER_FST(CompactUnweightedFst, LogArc);
REGISTER_FST(CompactUnweightedAcceptorFst, StdArc);
REGISTER_FST(CompactUnweightedAcceptorFst, LogArc);

}  // namespace fst
// See www.openfst.org for extensive documentation on this weighted
// finite-state transducer library.
//
// Classes to provide symbol-to-integer and integer-to-symbol mappings.

#include <fst/symbol-table.h>

#include <fst/flags.h>
#include <fst/log.h>

#include <fstream>
#include <fst/util.h>

DEFINE_bool(fst_compat_symbols, true,
            "Require symbol tables to match when appropriate");
DEFINE_string(fst_field_separator, "\t ",
              "Set of characters used as a separator between printed fields");

namespace fst {

// Maximum line length in textual symbols file.
static constexpr int kLineLen = 8096;

// Identifies stream data as a symbol table (and its endianity).
static constexpr int32 kSymbolTableMagicNumber = 2125658996;

SymbolTableTextOptions::SymbolTableTextOptions(bool allow_negative_labels)
    : allow_negative_labels(allow_negative_labels),
      fst_field_separator(FLAGS_fst_field_separator) {}

namespace internal {

SymbolTableImpl *SymbolTableImpl::ReadText(std::istream &strm,
                                           const string &filename,
                                           const SymbolTableTextOptions &opts) {
  std::unique_ptr<SymbolTableImpl> impl(new SymbolTableImpl(filename));
  int64 nline = 0;
  char line[kLineLen];
  while (!strm.getline(line, kLineLen).fail()) {
    ++nline;
    std::vector<char *> col;
    auto separator = opts.fst_field_separator + "\n";
    SplitString(line, separator.c_str(), &col, true);
    if (col.empty()) continue;  // Empty line.
    if (col.size() != 2) {
      LOG(ERROR) << "SymbolTable::ReadText: Bad number of columns ("
                 << col.size() << "), "
                 << "file = " << filename << ", line = " << nline << ":<"
                 << line << ">";
      return nullptr;
    }
    const char *symbol = col[0];
    const char *value = col[1];
    char *p;
    const auto key = strtoll(value, &p, 10);
    if (p < value + strlen(value) || (!opts.allow_negative_labels && key < 0) ||
        key == kNoSymbol) {
      LOG(ERROR) << "SymbolTable::ReadText: Bad non-negative integer \""
                 << value << "\", "
                 << "file = " << filename << ", line = " << nline;
      return nullptr;
    }
    impl->AddSymbol(symbol, key);
  }
  return impl.release();
}

void SymbolTableImpl::MaybeRecomputeCheckSum() const {
  {
    ReaderMutexLock check_sum_lock(&check_sum_mutex_);
    if (check_sum_finalized_) return;
  }
  // We'll acquire an exclusive lock to recompute the checksums.
  MutexLock check_sum_lock(&check_sum_mutex_);
  if (check_sum_finalized_) {  // Another thread (coming in around the same time
    return;                    // might have done it already). So we recheck.
  }
  // Calculates the original label-agnostic checksum.
  CheckSummer check_sum;
  for (size_t i = 0; i < symbols_.size(); ++i) {
    const auto &symbol = symbols_.GetSymbol(i);
    check_sum.Update(symbol.data(), symbol.size());
    check_sum.Update("", 1);
  }
  check_sum_string_ = check_sum.Digest();
  // Calculates the safer, label-dependent checksum.
  CheckSummer labeled_check_sum;
  for (int64 i = 0; i < dense_key_limit_; ++i) {
    std::ostringstream line;
    line << symbols_.GetSymbol(i) << '\t' << i;
    labeled_check_sum.Update(line.str().data(), line.str().size());
  }
  using citer = map<int64, int64>::const_iterator;
  for (citer it = key_map_.begin(); it != key_map_.end(); ++it) {
    // TODO(tombagby, 2013-11-22) This line maintains a bug that ignores
    // negative labels in the checksum that too many tests rely on.
    if (it->first < dense_key_limit_) continue;
    std::ostringstream line;
    line << symbols_.GetSymbol(it->second) << '\t' << it->first;
    labeled_check_sum.Update(line.str().data(), line.str().size());
  }
  labeled_check_sum_string_ = labeled_check_sum.Digest();
  check_sum_finalized_ = true;
}

int64 SymbolTableImpl::AddSymbol(const string &symbol, int64 key) {
  if (key == kNoSymbol) return key;
  const std::pair<int64, bool> &insert_key = symbols_.InsertOrFind(symbol);
  if (!insert_key.second) {
    auto key_already = GetNthKey(insert_key.first);
    if (key_already == key) return key;
    VLOG(1) << "SymbolTable::AddSymbol: symbol = " << symbol
            << " already in symbol_map_ with key = " << key_already
            << " but supplied new key = " << key << " (ignoring new key)";
    return key_already;
  }
  if (key == (symbols_.size() - 1) && key == dense_key_limit_) {
    ++dense_key_limit_;
  } else {
    idx_key_.push_back(key);
    key_map_[key] = symbols_.size() - 1;
  }
  if (key >= available_key_) available_key_ = key + 1;
  check_sum_finalized_ = false;
  return key;
}

// TODO(rybach): Consider a more efficient implementation which re-uses holes in
// the dense-key range or re-arranges the dense-key range from time to time.
void SymbolTableImpl::RemoveSymbol(const int64 key) {
  auto idx = key;
  if (key < 0 || key >= dense_key_limit_) {
    auto iter = key_map_.find(key);
    if (iter == key_map_.end()) return;
    idx = iter->second;
    key_map_.erase(iter);
  }
  if (idx < 0 || idx >= symbols_.size()) return;
  symbols_.RemoveSymbol(idx);
  // Removed one symbol, all indexes > idx are shifted by -1.
  for (auto &k : key_map_) {
    if (k.second > idx) --k.second;
  }
  if (key >= 0 && key < dense_key_limit_) {
    // Removal puts a hole in the dense key range. Adjusts range to [0, key).
    const auto new_dense_key_limit = key;
    for (int64 i = key + 1; i < dense_key_limit_; ++i) {
      key_map_[i] = i - 1;
    }
    // Moves existing values in idx_key to new place.
    idx_key_.resize(symbols_.size() - new_dense_key_limit);
    for (int64 i = symbols_.size(); i >= dense_key_limit_; --i) {
      idx_key_[i - new_dense_key_limit - 1] = idx_key_[i - dense_key_limit_];
    }
    // Adds indexes for previously dense keys.
    for (int64 i = new_dense_key_limit; i < dense_key_limit_ - 1; ++i) {
      idx_key_[i - new_dense_key_limit] = i + 1;
    }
    dense_key_limit_ = new_dense_key_limit;
  } else {
    // Remove entry for removed index in idx_key.
    for (int64 i = idx - dense_key_limit_; i < idx_key_.size() - 1; ++i) {
      idx_key_[i] = idx_key_[i + 1];
    }
    idx_key_.pop_back();
  }
  if (key == available_key_ - 1) available_key_ = key;
}

SymbolTableImpl *SymbolTableImpl::Read(std::istream &strm,
                                       const SymbolTableReadOptions &opts) {
  int32 magic_number = 0;
  ReadType(strm, &magic_number);
  if (strm.fail()) {
    LOG(ERROR) << "SymbolTable::Read: Read failed";
    return nullptr;
  }
  string name;
  ReadType(strm, &name);
  std::unique_ptr<SymbolTableImpl> impl(new SymbolTableImpl(name));
  ReadType(strm, &impl->available_key_);
  int64 size;
  ReadType(strm, &size);
  if (strm.fail()) {
    LOG(ERROR) << "SymbolTable::Read: Read failed";
    return nullptr;
  }
  string symbol;
  int64 key;
  impl->check_sum_finalized_ = false;
  for (int64 i = 0; i < size; ++i) {
    ReadType(strm, &symbol);
    ReadType(strm, &key);
    if (strm.fail()) {
      LOG(ERROR) << "SymbolTable::Read: Read failed";
      return nullptr;
    }
    impl->AddSymbol(symbol, key);
  }
  return impl.release();
}

bool SymbolTableImpl::Write(std::ostream &strm) const {
  WriteType(strm, kSymbolTableMagicNumber);
  WriteType(strm, name_);
  WriteType(strm, available_key_);
  int64 size = symbols_.size();
  WriteType(strm, size);
  for (int64 i = 0; i < size; ++i) {
    auto key = (i < dense_key_limit_) ? i : idx_key_[i - dense_key_limit_];
    WriteType(strm, symbols_.GetSymbol(i));
    WriteType(strm, key);
  }
  strm.flush();
  if (strm.fail()) {
    LOG(ERROR) << "SymbolTable::Write: Write failed";
    return false;
  }
  return true;
}

}  // namespace internal

void SymbolTable::AddTable(const SymbolTable &table) {
  MutateCheck();
  for (SymbolTableIterator iter(table); !iter.Done(); iter.Next()) {
    impl_->AddSymbol(iter.Symbol());
  }
}

bool SymbolTable::WriteText(std::ostream &strm,
                            const SymbolTableTextOptions &opts) const {
  if (opts.fst_field_separator.empty()) {
    LOG(ERROR) << "Missing required field separator";
    return false;
  }
  bool once_only = false;
  for (SymbolTableIterator iter(*this); !iter.Done(); iter.Next()) {
    std::ostringstream line;
    if (iter.Value() < 0 && !opts.allow_negative_labels && !once_only) {
      LOG(WARNING) << "Negative symbol table entry when not allowed";
      once_only = true;
    }
    line << iter.Symbol() << opts.fst_field_separator[0] << iter.Value()
         << '\n';
    strm.write(line.str().data(), line.str().length());
  }
  return true;
}

namespace internal {

DenseSymbolMap::DenseSymbolMap()
    : empty_(-1), buckets_(1 << 4), hash_mask_(buckets_.size() - 1) {
  std::uninitialized_fill(buckets_.begin(), buckets_.end(), empty_);
}

DenseSymbolMap::DenseSymbolMap(const DenseSymbolMap &x)
    : empty_(-1),
      symbols_(x.symbols_.size()),
      buckets_(x.buckets_),
      hash_mask_(x.hash_mask_) {
  for (size_t i = 0; i < symbols_.size(); ++i) {
    const auto sz = strlen(x.symbols_[i]) + 1;
    auto *cpy = new char[sz];
    memcpy(cpy, x.symbols_[i], sz);
    symbols_[i] = cpy;
  }
}

DenseSymbolMap::~DenseSymbolMap() {
  for (size_t i = 0; i < symbols_.size(); ++i) {
    delete[] symbols_[i];
  }
}

std::pair<int64, bool> DenseSymbolMap::InsertOrFind(const string &key) {
  static constexpr float kMaxOccupancyRatio = 0.75;  // Grows when 75% full.
  if (symbols_.size() >= kMaxOccupancyRatio * buckets_.size()) {
    Rehash(buckets_.size() * 2);
  }
  size_t idx = str_hash_(key) & hash_mask_;
  while (buckets_[idx] != empty_) {
    const auto stored_value = buckets_[idx];
    if (!strcmp(symbols_[stored_value], key.c_str())) {
      return {stored_value, false};
    }
    idx = (idx + 1) & hash_mask_;
  }
  auto next = symbols_.size();
  buckets_[idx] = next;
  symbols_.push_back(NewSymbol(key));
  return {next, true};
}

int64 DenseSymbolMap::Find(const string &key) const {
  size_t idx = str_hash_(key) & hash_mask_;
  while (buckets_[idx] != empty_) {
    const auto stored_value = buckets_[idx];
    if (!strcmp(symbols_[stored_value], key.c_str())) {
      return stored_value;
    }
    idx = (idx + 1) & hash_mask_;
  }
  return buckets_[idx];
}

void DenseSymbolMap::Rehash(size_t num_buckets) {
  buckets_.resize(num_buckets);
  hash_mask_ = buckets_.size() - 1;
  std::uninitialized_fill(buckets_.begin(), buckets_.end(), empty_);
  for (size_t i = 0; i < symbols_.size(); ++i) {
    size_t idx = str_hash_(string(symbols_[i])) & hash_mask_;
    while (buckets_[idx] != empty_) {
      idx = (idx + 1) & hash_mask_;
    }
    buckets_[idx] = i;
  }
}

const char *DenseSymbolMap::NewSymbol(const string &sym) {
  auto num = sym.size() + 1;
  auto newstr = new char[num];
  memcpy(newstr, sym.c_str(), num);
  return newstr;
}

void DenseSymbolMap::RemoveSymbol(size_t idx) {
  delete[] symbols_[idx];
  symbols_.erase(symbols_.begin() + idx);
  Rehash(buckets_.size());
}

}  // namespace internal

bool CompatSymbols(const SymbolTable *syms1, const SymbolTable *syms2,
                   bool warning) {
  // Flag can explicitly override this check.
  if (!FLAGS_fst_compat_symbols) return true;
  if (syms1 && syms2 &&
      (syms1->LabeledCheckSum() != syms2->LabeledCheckSum())) {
    if (warning) {
      LOG(WARNING) << "CompatSymbols: Symbol table checksums do not match. "
                   << "Table sizes are " << syms1->NumSymbols() << " and "
                   << syms2->NumSymbols();
    }
    return false;
  } else {
    return true;
  }
}

void SymbolTableToString(const SymbolTable *table, string *result) {
  std::ostringstream ostrm;
  table->Write(ostrm);
  *result = ostrm.str();
}

SymbolTable *StringToSymbolTable(const string &str) {
  std::istringstream istrm(str);
  return SymbolTable::Read(istrm, SymbolTableReadOptions());
}
}  // namespace fst
// See www.openfst.org for extensive documentation on this weighted
// finite-state transducer library.
//
// FST utility definitions.

#include <fst/util.h>
#include <cctype>
#include <sstream>
#include <string>
#include <fst/flags.h>
#include <fst/log.h>
#include <fst/mapped-file.h>

// Utility flag definitions

DEFINE_bool(fst_error_fatal, true,
            "FST errors are fatal; o.w. return objects flagged as bad: "
            "e.g., FSTs: kError property set, FST weights: not a Member()");

namespace fst {

void SplitString(char *full, const char *delim, std::vector<char *> *vec,
                 bool omit_empty_strings) {
  char *p = full;
  while (p) {
    if ((p = strpbrk(full, delim))) {
      p[0] = '\0';
    }
    if (!omit_empty_strings || full[0] != '\0') vec->push_back(full);
    if (p) full = p + 1;
  }
}

int64 StrToInt64(const string &s, const string &src, size_t nline,
                 bool allow_negative, bool *error) {
  int64 n;
  const char *cs = s.c_str();
  char *p;
  if (error) *error = false;
  n = strtoll(cs, &p, 10);
  if (p < cs + s.size() || (!allow_negative && n < 0)) {
    FSTERROR() << "StrToInt64: Bad integer = " << s << "\", source = " << src
               << ", line = " << nline;
    if (error) *error = true;
    return 0;
  }
  return n;
}

void ConvertToLegalCSymbol(string *s) {
  for (auto it = s->begin(); it != s->end(); ++it) {
    if (!isalnum(*it)) {
      *it = '_';
    }
  }
}

// Skips over input characters to align to 'align' bytes. Returns false if can't
// align.
bool AlignInput(std::istream &strm) {
  char c;
  for (int i = 0; i < MappedFile::kArchAlignment; ++i) {
    int64 pos = strm.tellg();
    if (pos < 0) {
      LOG(ERROR) << "AlignInput: Can't determine stream position";
      return false;
    }
    if (pos % MappedFile::kArchAlignment == 0) break;
    strm.read(&c, 1);
  }
  return true;
}

// Write null output characters to align to 'align' bytes. Returns false if
// can't align.
bool AlignOutput(std::ostream &strm) {
  for (int i = 0; i < MappedFile::kArchAlignment; ++i) {
    int64 pos = strm.tellp();
    if (pos < 0) {
      LOG(ERROR) << "AlignOutput: Can't determine stream position";
      return false;
    }
    if (pos % MappedFile::kArchAlignment == 0) break;
    strm.write("", 1);
  }
  return true;
}

}  // namespace fst
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Google-style flag handling definitions.

#include <fst/compat.h>
#include <fst/flags.h>

static const char *private_tmpdir = getenv("TMPDIR");

DEFINE_int32(v, 0, "verbosity level");
DEFINE_bool(help, false, "show usage information");
DEFINE_bool(helpshort, false, "show brief usage information");
DEFINE_string(tmpdir, private_tmpdir ? private_tmpdir : "/tmp",
              "temporary directory");

using namespace std;

static string flag_usage;
static string prog_src;

void SetFlags(const char *usage, int *argc, char ***argv,
              bool remove_flags, const char *src) {
  flag_usage = usage;
  prog_src = src;
  int index = 1;
  for (; index < *argc; ++index) {
    string argval = (*argv)[index];
    if (argval[0] != '-' || argval == "-") break;
    while (argval[0] == '-') argval = argval.substr(1);  // Removes initial '-'.
    string arg = argval;
    string val = "";
    // Splits argval (arg=val) into arg and val.
    auto pos = argval.find("=");
    if (pos != string::npos) {
      arg = argval.substr(0, pos);
      val = argval.substr(pos + 1);
    }
    auto bool_register = FlagRegister<bool>::GetRegister();
    if (bool_register->SetFlag(arg, val))
      continue;
    auto string_register = FlagRegister<string>::GetRegister();
    if (string_register->SetFlag(arg, val))
      continue;
    auto int32_register = FlagRegister<int32>::GetRegister();
    if (int32_register->SetFlag(arg, val))
      continue;
    auto int64_register = FlagRegister<int64>::GetRegister();
    if (int64_register->SetFlag(arg, val))
      continue;
    auto double_register = FlagRegister<double>::GetRegister();
    if (double_register->SetFlag(arg, val))
      continue;
    LOG(FATAL) << "SetFlags: Bad option: " << (*argv)[index];
  }
  if (remove_flags) {
    for (auto i = 0; i < *argc - index; ++i) {
      (*argv)[i + 1] = (*argv)[i + index];
    }
    *argc -= index - 1;
  }
  if (FLAGS_help) {
    ShowUsage(true);
    exit(1);
  }
  if (FLAGS_helpshort) {
    ShowUsage(false);
    exit(1);
  }
}

// If flag is defined in file 'src' and 'in_src' true or is not
// defined in file 'src' and 'in_src' is false, then print usage.
static void
ShowUsageRestrict(const std::set<pair<string, string>> &usage_set,
		  const string &src, bool in_src, bool show_file) {
  string old_file;
  bool file_out = false;
  bool usage_out = false;
  for (const auto &pair : usage_set) {
    const auto &file = pair.first;
    const auto &usage = pair.second;
    bool match = file == src;
    if ((match && !in_src) || (!match && in_src)) continue;
    if (file != old_file) {
      if (show_file) {
        if (file_out) cout << "\n";
	    cout << "Flags from: " << file << "\n";
        file_out = true;
      }
      old_file = file;
    }
    cout << usage << "\n";
    usage_out = true;
  }
  if (usage_out) cout << "\n";
}

void ShowUsage(bool long_usage) {
  std::set<pair<string, string>> usage_set;
  cout << flag_usage << "\n";
  auto bool_register = FlagRegister<bool>::GetRegister();
  bool_register->GetUsage(&usage_set);
  auto string_register = FlagRegister<string>::GetRegister();
  string_register->GetUsage(&usage_set);
  auto int32_register = FlagRegister<int32>::GetRegister();
  int32_register->GetUsage(&usage_set);
  auto int64_register = FlagRegister<int64>::GetRegister();
  int64_register->GetUsage(&usage_set);
  auto double_register = FlagRegister<double>::GetRegister();
  double_register->GetUsage(&usage_set);
  if (!prog_src.empty()) {
    cout << "PROGRAM FLAGS:\n\n";
    ShowUsageRestrict(usage_set, prog_src, true, false);
  }
  if (!long_usage) return;
  if (!prog_src.empty()) cout << "LIBRARY FLAGS:\n\n";
  ShowUsageRestrict(usage_set, prog_src, false, true);
}
#include <fst/weight.h>

DEFINE_string(fst_weight_separator, ",",
              "Character separator between printed composite weights; "
              "must be a single character");

DEFINE_string(fst_weight_parentheses, "",
              "Characters enclosing the first weight of a printed composite "
              "weight (e.g., pair weight, tuple weight and derived classes) to "
              "ensure proper I/O of nested composite weights; "
              "must have size 0 (none) or 2 (open and close parenthesis)");

namespace fst {

namespace internal {

CompositeWeightIO::CompositeWeightIO(char separator,
                                     std::pair<char, char> parentheses)
    : separator_(separator),
      open_paren_(parentheses.first),
      close_paren_(parentheses.second),
      error_(false) {
  if ((open_paren_ == 0 || close_paren_ == 0) && open_paren_ != close_paren_) {
    FSTERROR() << "Invalid configuration of weight parentheses: "
               << static_cast<int>(open_paren_) << " "
               << static_cast<int>(close_paren_);
    error_ = true;
  }
}

CompositeWeightIO::CompositeWeightIO()
    : CompositeWeightIO(FLAGS_fst_weight_separator.empty()
                            ? 0
                            : FLAGS_fst_weight_separator.front(),
                        {FLAGS_fst_weight_parentheses.empty()
                             ? 0
                             : FLAGS_fst_weight_parentheses[0],
                         FLAGS_fst_weight_parentheses.size() < 2
                             ? 0
                             : FLAGS_fst_weight_parentheses[1]}) {
  if (FLAGS_fst_weight_separator.size() != 1) {
    FSTERROR() << "CompositeWeight: "
               << "FLAGS_fst_weight_separator.size() is not equal to 1";
    error_ = true;
  }
  if (!FLAGS_fst_weight_parentheses.empty() &&
      FLAGS_fst_weight_parentheses.size() != 2) {
    FSTERROR() << "CompositeWeight: "
               << "FLAGS_fst_weight_parentheses.size() is not equal to 2";
    error_ = true;
  }
}

}  // namespace internal

CompositeWeightWriter::CompositeWeightWriter(std::ostream &ostrm)
    : ostrm_(ostrm) {
  if (error()) ostrm.clear(std::ios::badbit);
}

CompositeWeightWriter::CompositeWeightWriter(std::ostream &ostrm,
                                             char separator,
                                             std::pair<char, char> parentheses)
    : internal::CompositeWeightIO(separator, parentheses), ostrm_(ostrm) {
  if (error()) ostrm_.clear(std::ios::badbit);
}

void CompositeWeightWriter::WriteBegin() {
  if (open_paren_ != 0) {
    ostrm_ << open_paren_;
  }
}

void CompositeWeightWriter::WriteEnd() {
  if (close_paren_ != 0) {
    ostrm_ << close_paren_;
  }
}

CompositeWeightReader::CompositeWeightReader(std::istream &istrm)
    : istrm_(istrm) {
  if (error()) istrm_.clear(std::ios::badbit);
}

CompositeWeightReader::CompositeWeightReader(std::istream &istrm,
                                             char separator,
                                             std::pair<char, char> parentheses)
    : internal::CompositeWeightIO(separator, parentheses), istrm_(istrm) {
  if (error()) istrm_.clear(std::ios::badbit);
}

void CompositeWeightReader::ReadBegin() {
  do {  // Skips whitespace.
    c_ = istrm_.get();
  } while (std::isspace(c_));
  if (open_paren_ != 0) {
    if (c_ != open_paren_) {
      FSTERROR() << "CompositeWeightReader: Open paren missing: "
                 << "fst_weight_parentheses flag set correcty?";
      istrm_.clear(std::ios::badbit);
      return;
    }
    ++depth_;
    c_ = istrm_.get();
  }
}

void CompositeWeightReader::ReadEnd() {
  if (c_ != EOF && !std::isspace(c_)) {
    FSTERROR() << "CompositeWeightReader: excess character: '"
               << static_cast<char>(c_)
               << "': fst_weight_parentheses flag set correcty?";
    istrm_.clear(std::ios::badbit);
  }
}

}  // namespace fst
// See www.openfst.org for extensive documentation on this weighted
// finite-state transducer library.
//
// Functions for updating property bits for various FST operations and
// string names of the properties.

#include <fst/properties.h>

#include <stddef.h>
#include <vector>

namespace fst {

// These functions determine the properties associated with the FST result of
// various finite-state operations. The property arguments correspond to the
// operation's FST arguments. The properties returned assume the operation
// modifies its first argument. Bitwise-and this result with kCopyProperties for
// the case when a new (possibly delayed) FST is instead constructed.

// Properties for a concatenatively-closed FST.
uint64 ClosureProperties(uint64 inprops, bool star, bool delayed) {
  auto outprops = (kError | kAcceptor | kUnweighted | kAccessible) & inprops;
  if (inprops & kUnweighted) outprops |= kUnweightedCycles;
  if (!delayed) {
    outprops |=
        (kExpanded | kMutable | kCoAccessible | kNotTopSorted | kNotString) &
        inprops;
  }
  if (!delayed || inprops & kAccessible) {
    outprops |= (kNotAcceptor | kNonIDeterministic | kNonODeterministic |
                 kNotILabelSorted | kNotOLabelSorted | kWeighted |
                 kWeightedCycles | kNotAccessible | kNotCoAccessible) & inprops;
    if ((inprops & kWeighted) && (inprops & kAccessible) &&
        (inprops & kCoAccessible)) {
        outprops |= kWeightedCycles;
    }
  }
  return outprops;
}

// Properties for a complemented FST.
uint64 ComplementProperties(uint64 inprops) {
  auto outprops = kAcceptor | kUnweighted | kUnweightedCycles | kNoEpsilons |
                  kNoIEpsilons | kNoOEpsilons | kIDeterministic |
                  kODeterministic | kAccessible;
  outprops |=
      (kError | kILabelSorted | kOLabelSorted | kInitialCyclic) & inprops;
  if (inprops & kAccessible) {
    outprops |= kNotILabelSorted | kNotOLabelSorted | kCyclic;
  }
  return outprops;
}

// Properties for a composed FST.
uint64 ComposeProperties(uint64 inprops1, uint64 inprops2) {
  auto outprops = kError & (inprops1 | inprops2);
  if (inprops1 & kAcceptor && inprops2 & kAcceptor) {
    outprops |= kAcceptor | kAccessible;
    outprops |= (kNoEpsilons | kNoIEpsilons | kNoOEpsilons | kAcyclic |
                 kInitialAcyclic) &
                inprops1 & inprops2;
    if (kNoIEpsilons & inprops1 & inprops2) {
      outprops |= (kIDeterministic | kODeterministic) & inprops1 & inprops2;
    }
  } else {
    outprops |= kAccessible;
    outprops |= (kAcceptor | kNoIEpsilons | kAcyclic | kInitialAcyclic) &
                inprops1 & inprops2;
    if (kNoIEpsilons & inprops1 & inprops2) {
      outprops |= kIDeterministic & inprops1 & inprops2;
    }
  }
  return outprops;
}

// Properties for a concatenated FST.
uint64 ConcatProperties(uint64 inprops1, uint64 inprops2, bool delayed) {
  auto outprops = (kAcceptor | kUnweighted | kUnweightedCycles | kAcyclic) &
                  inprops1 & inprops2;
  outprops |= kError & (inprops1 | inprops2);
  const bool empty1 = delayed;  // Can the first FST be the empty machine?
  const bool empty2 = delayed;  // Can the second FST be the empty machine?
  if (!delayed) {
    outprops |= (kExpanded | kMutable | kNotTopSorted | kNotString) & inprops1;
    outprops |= (kNotTopSorted | kNotString) & inprops2;
  }
  if (!empty1) outprops |= (kInitialAcyclic | kInitialCyclic) & inprops1;
  if (!delayed || inprops1 & kAccessible) {
    outprops |= (kNotAcceptor | kNonIDeterministic | kNonODeterministic |
                 kEpsilons | kIEpsilons | kOEpsilons | kNotILabelSorted |
                 kNotOLabelSorted | kWeighted | kWeightedCycles | kCyclic |
                 kNotAccessible | kNotCoAccessible) &
                inprops1;
  }
  if ((inprops1 & (kAccessible | kCoAccessible)) ==
          (kAccessible | kCoAccessible) &&
      !empty1) {
    outprops |= kAccessible & inprops2;
    if (!empty2) outprops |= kCoAccessible & inprops2;
    if (!delayed || inprops2 & kAccessible) {
      outprops |= (kNotAcceptor | kNonIDeterministic | kNonODeterministic |
                   kEpsilons | kIEpsilons | kOEpsilons | kNotILabelSorted |
                   kNotOLabelSorted | kWeighted | kWeightedCycles | kCyclic |
                   kNotAccessible | kNotCoAccessible) &
                  inprops2;
    }
  }
  return outprops;
}

// Properties for a determinized FST.
uint64 DeterminizeProperties(uint64 inprops, bool has_subsequential_label,
                             bool distinct_psubsequential_labels) {
  auto outprops = kAccessible;
  if ((kAcceptor & inprops) ||
      ((kNoIEpsilons & inprops) && distinct_psubsequential_labels) ||
      (has_subsequential_label && distinct_psubsequential_labels)) {
    outprops |= kIDeterministic;
  }
  outprops |= (kError | kAcceptor | kAcyclic | kInitialAcyclic | kCoAccessible |
               kString) &
              inprops;
  if ((inprops & kNoIEpsilons) && distinct_psubsequential_labels) {
    outprops |= kNoEpsilons & inprops;
  }
  if (inprops & kAccessible) {
    outprops |= (kIEpsilons | kOEpsilons | kCyclic) & inprops;
  }
  if (inprops & kAcceptor) outprops |= (kNoIEpsilons | kNoOEpsilons) & inprops;
  if ((inprops & kNoIEpsilons) && has_subsequential_label) {
    outprops |= kNoIEpsilons;
  }
  return outprops;
}

// Properties for factored weight FST.
uint64 FactorWeightProperties(uint64 inprops) {
  auto outprops = (kExpanded | kMutable | kError | kAcceptor | kAcyclic |
                   kAccessible | kCoAccessible) &
                  inprops;
  if (inprops & kAccessible) {
    outprops |= (kNotAcceptor | kNonIDeterministic | kNonODeterministic |
                 kEpsilons | kIEpsilons | kOEpsilons | kCyclic |
                 kNotILabelSorted | kNotOLabelSorted) &
                inprops;
  }
  return outprops;
}

// Properties for an inverted FST.
uint64 InvertProperties(uint64 inprops) {
  auto outprops = (kExpanded | kMutable | kError | kAcceptor | kNotAcceptor |
                   kEpsilons | kNoEpsilons | kWeighted | kUnweighted |
                   kWeightedCycles | kUnweightedCycles | kCyclic | kAcyclic |
                   kInitialCyclic | kInitialAcyclic | kTopSorted |
                   kNotTopSorted | kAccessible | kNotAccessible |
                   kCoAccessible | kNotCoAccessible | kString | kNotString) &
                  inprops;
  if (kIDeterministic & inprops) outprops |= kODeterministic;
  if (kNonIDeterministic & inprops) outprops |= kNonODeterministic;
  if (kODeterministic & inprops) outprops |= kIDeterministic;
  if (kNonODeterministic & inprops) outprops |= kNonIDeterministic;

  if (kIEpsilons & inprops) outprops |= kOEpsilons;
  if (kNoIEpsilons & inprops) outprops |= kNoOEpsilons;
  if (kOEpsilons & inprops) outprops |= kIEpsilons;
  if (kNoOEpsilons & inprops) outprops |= kNoIEpsilons;

  if (kILabelSorted & inprops) outprops |= kOLabelSorted;
  if (kNotILabelSorted & inprops) outprops |= kNotOLabelSorted;
  if (kOLabelSorted & inprops) outprops |= kILabelSorted;
  if (kNotOLabelSorted & inprops) outprops |= kNotILabelSorted;
  return outprops;
}

// Properties for a projected FST.
uint64 ProjectProperties(uint64 inprops, bool project_input) {
  auto outprops = kAcceptor;
  outprops |= (kExpanded | kMutable | kError | kWeighted | kUnweighted |
               kWeightedCycles | kUnweightedCycles |
               kCyclic | kAcyclic | kInitialCyclic | kInitialAcyclic |
               kTopSorted | kNotTopSorted | kAccessible | kNotAccessible |
               kCoAccessible | kNotCoAccessible | kString | kNotString) &
              inprops;
  if (project_input) {
    outprops |= (kIDeterministic | kNonIDeterministic | kIEpsilons |
                 kNoIEpsilons | kILabelSorted | kNotILabelSorted) &
                inprops;

    if (kIDeterministic & inprops) outprops |= kODeterministic;
    if (kNonIDeterministic & inprops) outprops |= kNonODeterministic;

    if (kIEpsilons & inprops) outprops |= kOEpsilons | kEpsilons;
    if (kNoIEpsilons & inprops) outprops |= kNoOEpsilons | kNoEpsilons;

    if (kILabelSorted & inprops) outprops |= kOLabelSorted;
    if (kNotILabelSorted & inprops) outprops |= kNotOLabelSorted;
  } else {
    outprops |= (kODeterministic | kNonODeterministic | kOEpsilons |
                 kNoOEpsilons | kOLabelSorted | kNotOLabelSorted) &
                inprops;

    if (kODeterministic & inprops) outprops |= kIDeterministic;
    if (kNonODeterministic & inprops) outprops |= kNonIDeterministic;

    if (kOEpsilons & inprops) outprops |= kIEpsilons | kEpsilons;
    if (kNoOEpsilons & inprops) outprops |= kNoIEpsilons | kNoEpsilons;

    if (kOLabelSorted & inprops) outprops |= kILabelSorted;
    if (kNotOLabelSorted & inprops) outprops |= kNotILabelSorted;
  }
  return outprops;
}

// Properties for a randgen FST.
uint64 RandGenProperties(uint64 inprops, bool weighted) {
  auto outprops = kAcyclic | kInitialAcyclic | kAccessible | kUnweightedCycles;
  outprops |= inprops & kError;
  if (weighted) {
    outprops |= kTopSorted;
    outprops |=
        (kAcceptor | kNoEpsilons | kNoIEpsilons | kNoOEpsilons |
         kIDeterministic | kODeterministic | kILabelSorted | kOLabelSorted) &
        inprops;
  } else {
    outprops |= kUnweighted;
    outprops |= (kAcceptor | kILabelSorted | kOLabelSorted) & inprops;
  }
  return outprops;
}

// Properties for a replace FST.
uint64 ReplaceProperties(const std::vector<uint64>& inprops, ssize_t root,
                         bool epsilon_on_call, bool epsilon_on_return,
                         bool out_epsilon_on_call, bool out_epsilon_on_return,
                         bool replace_transducer, bool no_empty_fsts,
                         bool all_ilabel_sorted, bool all_olabel_sorted,
                         bool all_negative_or_dense) {
  if (inprops.empty()) return kNullProperties;
  uint64 outprops = 0;
  for (auto inprop : inprops) outprops |= kError & inprop;
  uint64 access_props = no_empty_fsts ? kAccessible | kCoAccessible : 0;
  for (auto inprop : inprops) {
    access_props &= (inprop & (kAccessible | kCoAccessible));
  }
  if (access_props == (kAccessible | kCoAccessible)) {
    outprops |= access_props;
    if (inprops[root] & kInitialCyclic) outprops |= kInitialCyclic;
    uint64 props = 0;
    bool string = true;
    for (auto inprop : inprops) {
      if (replace_transducer) props |= kNotAcceptor & inprop;
      props |= (kNonIDeterministic | kNonODeterministic | kEpsilons |
                kIEpsilons | kOEpsilons | kWeighted | kWeightedCycles |
                kCyclic | kNotTopSorted | kNotString) & inprop;
      if (!(inprop & kString)) string = false;
    }
    outprops |= props;
    if (string) outprops |= kString;
  }
  bool acceptor = !replace_transducer;
  bool ideterministic = !epsilon_on_call && epsilon_on_return;
  bool no_iepsilons = !epsilon_on_call && !epsilon_on_return;
  bool acyclic = true;
  bool unweighted = true;
  for (size_t i = 0; i < inprops.size(); ++i) {
    if (!(inprops[i] & kAcceptor)) acceptor = false;
    if (!(inprops[i] & kIDeterministic)) ideterministic = false;
    if (!(inprops[i] & kNoIEpsilons)) no_iepsilons = false;
    if (!(inprops[i] & kAcyclic)) acyclic = false;
    if (!(inprops[i] & kUnweighted)) unweighted = false;
    if (i != root && !(inprops[i] & kNoIEpsilons)) ideterministic = false;
  }
  if (acceptor) outprops |= kAcceptor;
  if (ideterministic) outprops |= kIDeterministic;
  if (no_iepsilons) outprops |= kNoIEpsilons;
  if (acyclic) outprops |= kAcyclic;
  if (unweighted) outprops |= kUnweighted;
  if (inprops[root] & kInitialAcyclic) outprops |= kInitialAcyclic;
  // We assume that all terminals are positive. The resulting ReplaceFst is
  // known to be kILabelSorted when: (1) all sub-FSTs are kILabelSorted, (2) the
  // input label of the return arc is epsilon, and (3) one of the 3 following
  // conditions is satisfied:
  //
  //  1. the input label of the call arc is not epsilon
  //  2. all non-terminals are negative, or
  //  3. all non-terninals are positive and form a dense range containing 1.
  if (all_ilabel_sorted && epsilon_on_return &&
      (!epsilon_on_call || all_negative_or_dense)) {
    outprops |= kILabelSorted;
  }
  // Similarly, the resulting ReplaceFst is known to be kOLabelSorted when: (1)
  // all sub-FSTs are kOLabelSorted, (2) the output label of the return arc is
  // epsilon, and (3) one of the 3 following conditions is satisfied:
  //
  //  1. the output label of the call arc is not epsilon
  //  2. all non-terminals are negative, or
  //  3. all non-terninals are positive and form a dense range containing 1.
  if (all_olabel_sorted && out_epsilon_on_return &&
      (!out_epsilon_on_call || all_negative_or_dense)) {
    outprops |= kOLabelSorted;
  }
  return outprops;
}

// Properties for a relabeled FST.
uint64 RelabelProperties(uint64 inprops) {
  static constexpr auto outprops =
      kExpanded | kMutable | kError | kWeighted | kUnweighted |
      kWeightedCycles | kUnweightedCycles | kCyclic | kAcyclic |
      kInitialCyclic | kInitialAcyclic | kTopSorted | kNotTopSorted |
      kAccessible | kNotAccessible | kCoAccessible | kNotCoAccessible |
      kString | kNotString;
  return outprops & inprops;
}

// Properties for a reversed FST (the superinitial state limits this set).
uint64 ReverseProperties(uint64 inprops, bool has_superinitial) {
  auto outprops = (kExpanded | kMutable | kError | kAcceptor | kNotAcceptor |
                   kEpsilons | kIEpsilons | kOEpsilons | kUnweighted | kCyclic |
                   kAcyclic | kWeightedCycles | kUnweightedCycles) &
                  inprops;
  if (has_superinitial) outprops |= kWeighted & inprops;
  return outprops;
}

// Properties for re-weighted FST.
uint64 ReweightProperties(uint64 inprops) {
  auto outprops = inprops & kWeightInvariantProperties;
  outprops = outprops & ~kCoAccessible;
  return outprops;
}

// Properties for an epsilon-removed FST.
uint64 RmEpsilonProperties(uint64 inprops, bool delayed) {
  auto outprops = kNoEpsilons;
  outprops |= (kError | kAcceptor | kAcyclic | kInitialAcyclic) & inprops;
  if (inprops & kAcceptor) outprops |= kNoIEpsilons | kNoOEpsilons;
  if (!delayed) {
    outprops |= kExpanded | kMutable;
    outprops |= kTopSorted & inprops;
  }
  if (!delayed || inprops & kAccessible) outprops |= kNotAcceptor & inprops;
  return outprops;
}

// Properties for shortest path. This function computes how the properties of
// the output of shortest path need to be updated, given that 'props' is already
// known.
uint64 ShortestPathProperties(uint64 props, bool tree) {
  auto outprops =
      props | kAcyclic | kInitialAcyclic | kAccessible | kUnweightedCycles;
  if (!tree) outprops |= kCoAccessible;
  return outprops;
}

// Properties for a synchronized FST.
uint64 SynchronizeProperties(uint64 inprops) {
  auto outprops = (kError | kAcceptor | kAcyclic | kAccessible | kCoAccessible |
                   kUnweighted | kUnweightedCycles) &
                  inprops;
  if (inprops & kAccessible) {
    outprops |= (kCyclic | kNotCoAccessible | kWeighted | kWeightedCycles) &
        inprops;
  }
  return outprops;
}

// Properties for a unioned FST.
uint64 UnionProperties(uint64 inprops1, uint64 inprops2, bool delayed) {
  auto outprops =
      (kAcceptor | kUnweighted | kUnweightedCycles | kAcyclic | kAccessible) &
      inprops1 & inprops2;
  outprops |= kError & (inprops1 | inprops2);
  outprops |= kInitialAcyclic;
  bool empty1 = delayed;  // Can the first FST be the empty machine?
  bool empty2 = delayed;  // Can the second FST be the empty machine?
  if (!delayed) {
    outprops |= (kExpanded | kMutable | kNotTopSorted) & inprops1;
    outprops |= kNotTopSorted & inprops2;
  }
  if (!empty1 && !empty2) {
    outprops |= kEpsilons | kIEpsilons | kOEpsilons;
    outprops |= kCoAccessible & inprops1 & inprops2;
  }
  // Note kNotCoAccessible does not hold because of kInitialAcyclic option.
  if (!delayed || inprops1 & kAccessible) {
    outprops |=
        (kNotAcceptor | kNonIDeterministic | kNonODeterministic | kEpsilons |
         kIEpsilons | kOEpsilons | kNotILabelSorted | kNotOLabelSorted |
         kWeighted | kWeightedCycles | kCyclic | kNotAccessible) &
        inprops1;
  }
  if (!delayed || inprops2 & kAccessible) {
    outprops |= (kNotAcceptor | kNonIDeterministic | kNonODeterministic |
                 kEpsilons | kIEpsilons | kOEpsilons | kNotILabelSorted |
                 kNotOLabelSorted | kWeighted | kWeightedCycles | kCyclic |
                 kNotAccessible | kNotCoAccessible) &
                inprops2;
  }
  return outprops;
}

// Property string names (indexed by bit position).
const char* PropertyNames[] = {
    // Binary.
    "expanded", "mutable", "error", "", "", "", "", "", "", "", "", "", "", "",
    "", "",
    // Ternary.
    "acceptor", "not acceptor", "input deterministic",
    "non input deterministic", "output deterministic",
    "non output deterministic", "input/output epsilons",
    "no input/output epsilons", "input epsilons", "no input epsilons",
    "output epsilons", "no output epsilons", "input label sorted",
    "not input label sorted", "output label sorted", "not output label sorted",
    "weighted", "unweighted", "cyclic", "acyclic", "cyclic at initial state",
    "acyclic at initial state", "top sorted", "not top sorted", "accessible",
    "not accessible", "coaccessible", "not coaccessible", "string",
    "not string", "weighted cycles", "unweighted cycles"};

}  // namespace fst
// compat.cc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Author: riley@google.com (Michael Riley)
//
// \file
// Google compatibility definitions.

#include <cstring>
#include <fst/compat.h>

using namespace std;

void FailedNewHandler() {
  cerr << "Memory allocation failed\n";
  exit(1);
}
